
C This whole file duplicates routines from the crystals sources, so it
C is only required if Cameron is compiled as a separate application. (Rarely)
C
C From time to time it would be worth checking that these routines have
C not been replaced or fixed in the crystals sources...
C
C e.g. the NAG routines are gone!
C

#if defined(_DOS_)
CRYSTALS CODE FOR DUPLICAT.FOR                                                  
CODE FOR F01AJF
      SUBROUTINE F01AJF(N, ATOL, A, IA, D, E, Z, IZ)
C     MARK 2 RELEASE. NAG COPYRIGHT 1972
C     MARK 4 REVISED.
C     MARK 4.5 REVISED
C     MARK 5C REVISED
C
C     TRED2
C     THIS SUBROUTINE REDUCES THE GIVEN LOWER TRIANGLE OF A
C     SYMMETRIC MATRIX, A, STORED IN THE ARRAY A(N,N), TO
C     TRIDIAGONAL FORM USING HOUSEHOLDERS REDUCTION. THE DIAGONAL
C     OF THE RESULT IS STORED IN THE ARRAY D(N) AND THE
C     SUB-DIAGONAL IN THE LAST N - 1 STORES OF THE ARRAY E(N)
C     (WITH THE ADDITIONAL ELEMENT E(1) = 0). THE TRANSFORMATION
C     MATRICES ARE ACCUMULATED IN THE ARRAY Z(N,N). THE ARRAY
C     A IS LEFT UNALTERED UNLESS THE ACTUAL PARAMETERS
C     CORRESPONDING TO A AND Z ARE IDENTICAL.
C     1ST AUGUST 1971
C
      INTEGER I, IA, II, IZ, J1, J, K, L, N
      DOUBLE PRECISION ATOL, F, G, H, HH, A(IA,N), D(N), E(N), Z(IZ,N)
      DO 40 I=1,N
         DO 20 J=1,I
            Z(I,J) = A(I,J)
   20    CONTINUE
   40 CONTINUE
      IF (N.EQ.1) GO TO 280
      DO 260 II=2,N
         I = N - II + 2
         L = I - 2
         F = Z(I,I-1)
         G = 0.0D0
         IF (L.EQ.0) GO TO 80
         DO 60 K=1,L
            G = G + Z(I,K)*Z(I,K)
   60    CONTINUE
   80    H = G + F*F
C     IF G IS TOO SMALL FOR ORTHOGONALITY TO BE
C     GUARANTEED THE TRANSFORMATION IS SKIPPED
         IF (G.GT.ATOL) GO TO 100
         E(I) = F
         H = 0.0D0
         GO TO 240
  100    L = L + 1
         G = DSQRT(H)
         IF (F.GE.0.0D0) G = -G
         E(I) = G
         H = H - F*G
         Z(I,I-1) = F - G
         F = 0.0D0
         DO 180 J=1,L
            Z(J,I) = Z(I,J)/H
            G = 0.0D0
C     FORM ELEMENT OF A*U
            DO 120 K=1,J
               G = G + Z(J,K)*Z(I,K)
  120       CONTINUE
            J1 = J + 1
            IF (J1.GT.L) GO TO 160
            DO 140 K=J1,L
               G = G + Z(K,J)*Z(I,K)
  140       CONTINUE
C     FORM ELEMENT OF P
  160       E(J) = G/H
            F = F + G*Z(J,I)
  180    CONTINUE
C     FORM K
         HH = F/(H+H)
C     FORM REDUCED A
         DO 220 J=1,L
            F = Z(I,J)
            G = E(J) - HH*F
            E(J) = G
            DO 200 K=1,J
               Z(J,K) = Z(J,K) - F*E(K) - G*Z(I,K)
  200       CONTINUE
  220    CONTINUE
  240    D(I) = H
  260 CONTINUE
  280 E(1) = 0.0D0
      D(1) = 0.0D0
C     ACCUMULATION OF TRANSFORMATION MATRICES
      DO 400 I=1,N
         L = I - 1
         IF (D(I).EQ.0.0D0) GO TO 360
         DO 340 J=1,L
            G = 0.0D0
            DO 300 K=1,L
               G = G + Z(I,K)*Z(K,J)
  300       CONTINUE
            DO 320 K=1,L
               Z(K,J) = Z(K,J) - G*Z(K,I)
  320       CONTINUE
  340    CONTINUE
  360    D(I) = Z(I,I)
         Z(I,I) = 1.0D0
         IF (L.EQ.0) GO TO 400
         DO 380 J=1,L
            Z(I,J) = 0.0D0
            Z(J,I) = 0.0D0
  380    CONTINUE
  400 CONTINUE
      RETURN
      END
** END OF F01AJFTEXT
 
CODE FOR F02ABF
* F02FTEXT
      SUBROUTINE F02ABF(A, IA, N, R, V, IV, E, IFAIL)
C     MARK 2 RELEASE. NAG COPYRIGHT 1972
C     MARK 3 REVISED.
C     MARK 4.5 REVISED
C
C     EIGENVALUES AND EIGENVECTORS OF A REAL SYMMETRIX MATRIX
C     1ST AUGUST 1971
C
      INTEGER P01AAF, ISAVE, IFAIL, N, IA, IV
C$P 1
      DOUBLE PRECISION SRNAME
      DOUBLE PRECISION TOL, XXXX, A(IA,N), R(N), V(IV,N), E(N), X02ADF,
     * X02AAF
      DATA SRNAME /8H F02ABF /
      ISAVE = IFAIL
      IFAIL = 1
      TOL = X02ADF(1.0D0)
      CALL F01AJF(N, TOL, A, IA, R, E, V, IV)
      TOL = X02AAF(1.0D0)
      CALL F02AMF(N, TOL, R, E, V, IV, IFAIL)
      IF (IFAIL.NE.0) IFAIL = P01AAF(ISAVE,IFAIL,SRNAME)
      RETURN
      END
** END OF F02ABFTEXT
CODE FOR F02AMF
      SUBROUTINE F02AMF(N, ACHEPS, D, E, Z, IZ, IFAIL)
C     MARK 2 RELEASE. NAG COPYRIGHT 1972
C     MARK 3 REVISED.
C     MARK 4 REVISED.
C     MARK 4.5 REVISED
C
C     TQL2
C     THIS SUBROUTINE FINDS THE EIGENVALUES AND EIGENVECTORS OF A
C     TRIDIAGONAL MATRIX, T, GIVEN WITH ITS DIAGONAL ELEMENTS IN
C     THE ARRAY D(N) AND ITS SUB-DIAGONAL ELEMENTS IN THE LAST N
C     - 1 STORES OF THE ARRAY E(N), USING QL TRANSFORMATIONS. THE
C     EIGENVALUES ARE OVERWRITTEN ON THE DIAGONAL ELEMENTS IN THE
C     ARRAY D IN ASCENDING ORDER. THE EIGENVECTORS ARE FORMED IN
C     THE ARRAY Z(N,N), OVERWRITING THE ACCUMULATED
C     TRANSFORMATIONS AS SUPPLIED BY THE SUBROUTINE F01AJF. THE
C     SUBROUTINE WILL FAIL IF ANY ONE EIGENVALUE TAKES MORE THAN 30
C     ITERATIONS.
C     1ST APRIL 1972
C
      INTEGER P01AAF, ISAVE, IFAIL, N, I, L, J, M, I1, M1, II, K, IZ
C$P 1
      DOUBLE PRECISION SRNAME
      DOUBLE PRECISION B, F, H, ACHEPS, G, P, R, C, S, D(N), E(N), Z(IZ,
     *N)
      DATA SRNAME /8H F02AMF /
      ISAVE = IFAIL
      IF (N.EQ.1) GO TO 40
      DO 20 I=2,N
         E(I-1) = E(I)
   20 CONTINUE
   40 E(N) = 0.0D0
      B = 0.0D0
      F = 0.0D0
      DO 300 L=1,N
         J = 0
         H = ACHEPS*(DABS(D(L))+DABS(E(L)))
         IF (B.LT.H) B = H
C     LOOK FOR SMALL SUB-DIAG ELEMENT
         DO 60 M=L,N
            IF (DABS(E(M)).LE.B) GO TO 80
   60    CONTINUE
   80    IF (M.EQ.L) GO TO 280
  100    IF (J.EQ.30) GO TO 400
         J = J + 1
C     FORM SHIFT
         G = D(L)
         H = D(L+1) - G
         IF (DABS(H).GE.DABS(E(L))) GO TO 120
         P = H*0.5D0/E(L)
         R = DSQRT(P*P+1.0D0)
         H = P + R
         IF (P.LT.0.0D0) H = P - R
         D(L) = E(L)/H
         GO TO 140
  120    P = 2.0D0*E(L)/H
         R = DSQRT(P*P+1.0D0)
         D(L) = E(L)*P/(1.0D0+R)
  140    H = G - D(L)
         I1 = L + 1
         IF (I1.GT.N) GO TO 180
         DO 160 I=I1,N
            D(I) = D(I) - H
  160    CONTINUE
  180    F = F + H
C     QL TRANSFORMATION
         P = D(M)
         C = 1.0D0
         S = 0.0D0
         M1 = M - 1
         DO 260 II=L,M1
            I = M1 - II + L
            G = C*E(I)
            H = C*P
            IF (DABS(P).LT.DABS(E(I))) GO TO 200
            C = E(I)/P
            R = DSQRT(C*C+1.0D0)
            E(I+1) = S*P*R
            S = C/R
            C = 1.0D0/R
            GO TO 220
  200       C = P/E(I)
            R = DSQRT(C*C+1.0D0)
            E(I+1) = S*E(I)*R
            S = 1.0D0/R
            C = C/R
  220       P = C*D(I) - S*G
            D(I+1) = H + S*(C*G+S*D(I))
C     FORM VECTOR
            DO 240 K=1,N
               H = Z(K,I+1)
               Z(K,I+1) = S*Z(K,I) + C*H
               Z(K,I) = C*Z(K,I) - S*H
  240       CONTINUE
  260    CONTINUE
         E(L) = S*P
         D(L) = C*P
         IF (DABS(E(L)).GT.B) GO TO 100
  280    D(L) = D(L) + F
  300 CONTINUE
C     ORDER EIGENVALUES AND EIGENVECTORS
      DO 380 I=1,N
         K = I
         P = D(I)
         I1 = I + 1
         IF (I1.GT.N) GO TO 340
         DO 320 J=I1,N
            IF (D(J).GE.P) GO TO 320
            K = J
            P = D(J)
  320    CONTINUE
  340    IF (K.EQ.I) GO TO 380
         D(K) = D(I)
         D(I) = P
         DO 360 J=1,N
            P = Z(J,I)
            Z(J,I) = Z(J,K)
            Z(J,K) = P
  360    CONTINUE
  380 CONTINUE
      IFAIL = 0
      RETURN
  400 IFAIL = P01AAF(ISAVE,1,SRNAME)
      RETURN
      END
** END OF F02AMFTEXT
* P01FTEXT
CODE FOR NCROP3
      FUNCTION NCROP3(A,B,C)
C--COMPUTES THE CROSS PRODUCT OF THE VECTORS A AND B AND STORES THE
C  RESULT IN C.
C
C  A  THE FIRST VECTOR.
C  B  THE SECOND VECTOR.
C  C  THE CROSS PRODUCT OF A WITH B. (C = A CROSS B).
C
C--THE RETURN VALUES OF 'NCROP' ARE :
C
C  -1  THE INPUT VECTORS ARE PARALLEL  RESULTANT VECTOR HAS ZERO LENGTH.
C  >0  THE RESULTANT VECTOR IS NOT ZERO.
C
C--THE OUTPUT VECTOR IN 'C' IS NORMALISED BEFORE RETURN.
C
C--
C
      DIMENSION A(3),B(3),C(3)
C
      NCROP3=1
      CALL ZVMULT(A,B,C)
      IF(NORM3(C))1000,1000,1050
C--ZERO LENGTH VECTOR
1000  CONTINUE
      NCROP3=-1
1050  CONTINUE
      RETURN
      END
 
CODE FOR P01AAF
*UPTODATE P01AAFTEXT
      INTEGER FUNCTION P01AAF(IFAIL, ERROR, SRNAME)
C     MARK 1 RELEASE.  NAG COPYRIGHT 1971
C     MARK 3 REVISED
C     MARK 4A REVISED, IER-45
C     MARK 4.5 REVISED
C     MARK 7 REVISED (DEC 1978)
C     RETURNS THE VALUE OF ERROR OR TERMINATES THE PROGRAM.
      INTEGER ERROR, IFAIL, NOUT
C$P 1
      DOUBLE PRECISION SRNAME
C     TEST IF NO ERROR DETECTED
      IF (ERROR.EQ.0) GO TO 20
C     DETERMINE OUTPUT UNIT FOR MESSAGE
      CALL X04AAF (0,NOUT)
C     TEST FOR SOFT FAILURE
      IF (MOD(IFAIL,10).EQ.1) GO TO 10
C     HARD FAILURE
      WRITE (NOUT,99999) SRNAME, ERROR
C     STOPPING MECHANISM MAY ALSO DIFFER
C     CALL P01AAZ
      STOP
C     SOFT FAIL
C     TEST IF ERROR MESSAGES SUPPRESSED
   10 IF (MOD(IFAIL/10,10).EQ.0) GO TO 20
      WRITE (NOUT,99999) SRNAME, ERROR
   20 P01AAF = ERROR
      RETURN
99999 FORMAT (1H0, 38HERROR DETECTED BY NAG LIBRARY ROUTINE , A8,
     * 11H - IFAIL = , I5//)
      END
** END OF P01AAFTEXT
 
* X02FTEXT
*UPTODATE X02AAFTEXT
CODE FOR X02AAF
      DOUBLE PRECISION FUNCTION X02AAF(X)
C     NAG COPYRIGHT 1975
C     MARK 4.5 RELEASE
      DOUBLE PRECISION X
C     * EPS *
C     RETURNS THE VALUE EPS WHERE EPS IS THE SMALLEST
C     POSITIVE
C     NUMBER SUCH THAT 1.0 + EPS > 1.0
C     THE X PARAMETER IS NOT USED
C     FOR DEC VAX 11/780
C     X02AAF = 2.0**(-56.0)
      X02AAF = 2.0D0**(-55)
      RETURN
      END
** END OF X02AAFTEXT
CODE FOR X02ADF
*UPTODATE X02ADFTEXT
      DOUBLE PRECISION FUNCTION X02ADF(X)
C     NAG COPYRIGHT 1975
C     MARK 4.5 RELEASE
      DOUBLE PRECISION X
C     * TOL *
C     RETURNS THE RATIO OF THE SMALLEST POSITIVE REAL FLOATING-
C     POINT NUMBER REPRESENTABLE ON THE COMPUTER TO EPS
C     FOR DEC VAX 11/780
C     X02ADF = 2.0D0**(-72)
      X02ADF = 2.0D0**(-72)
      RETURN
      END
** END OF X02ADFTEXT
* X04FTEXT
CODE FOR XDETR3
      FUNCTION XDETR3(AMAT)
C--COMPUTE THE DETERMINANT OF THE 3 BY 3 MATRIX 'AMAT'.
C
C  AMAT  THE MATRIX.
C
C--THE RETURN VALUE IS THE VALUE OF THE DETERMINANT.
C
C--
C
      DIMENSION AMAT(9)
C
      XDETR3=(AMAT(5)*AMAT(9)-AMAT(8)*AMAT(6))*AMAT(1)-(AMAT(2)*AMAT(9)
     2 -AMAT(8)*AMAT(3))*AMAT(4)+(AMAT(2)*AMAT(6)-AMAT(5)*AMAT(3))
     3 *AMAT(7)
      RETURN
      END
C
 
 
CODE FOR NORM3
      FUNCTION NORM3(X)
C--NORMALISE THE VECTOR 'X' SO THAT THE SUM OF THE SQUARES
C  OF ITS THREE ELEMENTS IS UNITY.
C
C  X  THE VECTOR, CONTAINING THREE ELEMENTS.
C
C--THE RETURN VALUES OF 'NORM' ARE :
C
C  -1  THE VECTOR HAS ZERO LENGTH  (<0.0000001).
C  >0  ALL OKAY.
C
C--
C
      DIMENSION X(3)
C
C
C
      DATA D/0.0/
C
C--SUM THE SQUARES
      D=X(1)*X(1)+X(2)*X(2)+X(3)*X(3)
      IF (D.LT.0.0000001) THEN
        NORM3 = -1
        RETURN
      ENDIF
C--NORMALISE THE COMPONENTS
      D=1./SQRT(D)
      X(1)=X(1)*D
      X(2)=X(2)*D
      X(3)=X(3)*D
      NORM3=1
C--AND NOW RETURN
      RETURN
      END
 
CODE FOR X04AAF
*UPTODATE X04AAFTEXT
      SUBROUTINE X04AAF(I,NERR)
C     MARK 7 RELEASE. NAG COPYRIGHT 1978
C     MARK 7C REVISED IER-190 (MAY 1979)
C     IF I = 0, SETS NERR TO CURRENT ERROR MESSAGE UNIT NUMBER
C     (STORED IN NERR1).
C     IF I = 1, CHANGES CURRENT ERROR MESSAGE UNIT NUMBER TO
C     VALUE SPECIFIED BY NERR.
C
C     *** NOTE ***
C     THIS ROUTINE ASSUMES THAT THE VALUE OF NERR1 IS SAVED
C     BETWEEN CALLS. IN SOME IMPLEMENTATIONS IT MAY BE
C     NECESSARY TO STORE NERR1 IN A LABELLED COMMON
C     BLOCK /AX04AA/ TO ACHIEVE THIS.
C
C     .. SCALAR ARGUMENTS ..
      INTEGER I, NERR
C     ..
C     .. LOCAL SCALARS ..
      INTEGER NERR1
C     ..
      DATA NERR1 /6/
      IF (I.EQ.0) NERR = NERR1
      IF (I.EQ.1) NERR1 = NERR
      RETURN
      END
** END OF X04AAFTEXT
 
CODE FOR MTRNLG
      SUBROUTINE MTRNLG(FILNAM,STATUS,LENNAM)
C
C----- EXPAND LOGICAL NAMES (ENVIRONMENT VARIABLES) IF THEY
C      ARE PART OF THE FILE NAME.
C
C      CODE BY MARTIN KRETSCHMAR, TUBINGEN, 1991
C
C FILNAM CONTAINS THE OLD FILE NAME AND WILL PASS BACK THE NEW ONE.
C
C STATUS IS THE THE WAY THE FILE IS INTENDED TO BE OPENED. IF SEARCH-
C LISTS LIKE THE VAX/VMS LOGICAL NAMES ARE TO BE EMULATED, IT IS
C IMPORTANT TO KNOW THIS.
C
C LENNAM USEFUL LENGTH OF FILENAME
C
C      IMPLICIT NONE
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      INTEGER MAXLVL
      PARAMETER (MAXLVL=30)
      CHARACTER*(*) FILNAM,STATUS
      LOGICAL LEXIST
      INTEGER KSTRLN
      INTEGER I,J,K,LEVEL,IWHAT
      INTEGER NAMLEN(MAXLVL),COLPOS(MAXLVL)
      INTEGER LSTLEN(MAXLVL),LSTPOS(MAXLVL)
      CHARACTER*200 INQNAM,NAME(MAXLVL),LIST(MAXLVL)
      NCAWU = ISTOUT
C
C\XUNITS
C\XOPVAL
C\XERVAL
C
C NOW WE SEARCH FOR THE LENGTH OF OUR FILE NAME AND REMOVE BLANKS.
C
C      WRITE(NCAWU,*) 'MTRNLG:  Input="',FILNAM(1:KSTRLN(FILNAM)),
C     & '":',LEN(FILNAM),', Status="',STATUS(1:KSTRLN(STATUS)),'"'
      LEVEL=1
      J=0
      DO 1 I=1,LEN(FILNAM)
        IF(FILNAM(I:I).NE.' ') THEN
          J=J+1
          IF(J.LE.LEN(NAME(1))) NAME(1)(J:J)=FILNAM(I:I)
        ENDIF
1     CONTINUE
      NAMLEN(1)=J
      LSTPOS(1)=0
      LSTLEN(1)=-1
C
C CHECK ON FILE NAME NAMLEN OVERFLOW
C
      IF(J.GT.LEN(NAME(LEVEL))) THEN
      WRITE ( NCAWU, '(// '' MTRNLG: Filename too long ''//)')
      CALL XOPMSG (IOPCRY, IOPABN, 0 )
      CALL XERHND (IERSEV)
      ENDIF
C
C
C
      IWHAT=0
      IF(STATUS.EQ.'OLD') IWHAT=1
      IF(STATUS.EQ.'NEW') IWHAT=2
      IF(STATUS.EQ.'FRESH') IWHAT=2
      IF(STATUS.EQ.'UNKNOWN') IWHAT=3
      IF(IWHAT.EQ.0) THEN
      WRITE ( NCAWU, '(// '' MTRNLG: Unknown status ''//)')
      CALL XOPMSG (IOPCRY, IOPABN, 0 )
      CALL XERHND (IERSEV)
      END IF
C
C HERE COMES THE BIG SEARCH LOOP. IT IS GUIDED BY THE LEVEL AND THE IWHAT
C VARIABLE.
C
C SEARCH FOR THE FIRST ':' IF THERE IS ANY
C
2     COLPOS(LEVEL)=INDEX(NAME(LEVEL)(1:NAMLEN(LEVEL)),':')
C
C TEST IF SOMETHING CAN BE DONE
C
      IF(COLPOS(LEVEL).LT.3) THEN
C        WRITE(NCAWU,*) 'Inquiring "',NAME(LEVEL)(1:NAMLEN(LEVEL)),'"'
        IF(IWHAT.EQ.2) GOTO 9999
        INQNAM=NAME(LEVEL)(1:NAMLEN(LEVEL))
        DO 6666 I=NAMLEN(LEVEL)+1,LEN(INQNAM)
          INQNAM(I:I)=' '
6666    CONTINUE
        INQUIRE(FILE=INQNAM,EXIST=LEXIST)
        IF(LEXIST) GOTO 9999
        LEVEL=LEVEL-1
        IF(LEVEL.GE.1) GOTO 3
        LEVEL=1
        GOTO 9999
      ENDIF
C
C LOOK FOR AN ENVIRONMENT STRING IF NONE WAS ASSIGNED UP TO NOW
C
      IF(LSTLEN(LEVEL).LT.0) THEN
        CALL XCCUPC(NAME(LEVEL)(1:COLPOS(LEVEL)-1),
     &              NAME(LEVEL)(1:COLPOS(LEVEL)-1))
        LIST(LEVEL) = ' '
C----- DOSPARAM@ ( CPARAM, CVALUE) RETURNS THE CVALUE OF THE PARAMETER
C      CPARAM, INITIALISED WITH THE DOS COMMAND
C      SET CPARAM=CVALUE
       CALL DOSPARAM@(NAME(LEVEL)(1:COLPOS(LEVEL)-1),LIST(LEVEL))
C&UNX        CALL GETENV(NAME(LEVEL)(1:COLPOS(LEVEL)-1),LIST(LEVEL))
        LSTPOS(LEVEL)=0
        LSTLEN(LEVEL)=KSTRLN(LIST(LEVEL))
C        WRITE(NCAWU,*) 'Environment ',LEVEL,'  "',
C     &    NAME(LEVEL)(1:COLPOS(LEVEL)-1),'"  = "',
C     &    LIST(LEVEL)(1:LSTLEN(LEVEL)),'"'
      ENDIF
C
C TEST LIST FOR SOMETHING TO PROCESS
C
3     CONTINUE
C      WRITE(NCAWU,*) 'Testing ',LEVEL,'  "',
C     &  NAME(LEVEL)(1:NAMLEN(LEVEL)),'"'
      IF((LSTPOS(LEVEL).GE.LSTLEN(LEVEL))
     &  .OR.((LSTPOS(LEVEL).GT.0).AND.(IWHAT.EQ.2))) THEN
        LEVEL=LEVEL-1
        IF(LEVEL.GE.1) GOTO 3
        LEVEL=1
        IF(IWHAT.EQ.3) THEN
          IWHAT=2
          LEVEL=1
          LSTPOS(1)=0
          LSTLEN(1)=-1
          GOTO 2
        ENDIF
        GOTO 9999
      ELSE
        IF(LEVEL.GE.MAXLVL) THEN
      WRITE ( NCAWU, '(// '' MTRNLG: Out of levels ''//)')
      CALL XOPMSG (IOPCRY, IOPABN, 0 )
      CALL XERHND (IERSEV)
        END IF
        J=LSTPOS(LEVEL)+1
        LSTPOS(LEVEL)=INDEX(LIST(LEVEL)(J:LSTLEN(LEVEL)),',')+J-1
        IF(LSTPOS(LEVEL).EQ.(J-1)) LSTPOS(LEVEL)=LSTLEN(LEVEL)+1
C         WRITE(NCAWU,*)
C     1 'Extracted     "',LIST(LEVEL)(J:LSTPOS(LEVEL)-1),'"'
        K=LSTPOS(LEVEL)-J
        NAME(LEVEL+1)(1:K)=LIST(LEVEL)(J:LSTPOS(LEVEL)-1)
C          WRITE(NCAWU,*)'Name="',NAME(LEVEL+1)(1:K),'"',J,K
        J=COLPOS(LEVEL)
C
C IF SOME 'REST' OF THE ORIGINAL FILE NAME REMAINDED
C
        IF(J.LT.NAMLEN(LEVEL)) THEN
C
C IF THE 'REST' CAN BE ADDED TO THE STRING WE GOT, DO SO
C
          IF((K+(NAMLEN(LEVEL)-J)).LE.LEN(NAME(LEVEL+1))) THEN
            NAME(LEVEL+1)(K+1:K+(NAMLEN(LEVEL)-J))
     &        =NAME(LEVEL)(J+1:NAMLEN(LEVEL))
            NAMLEN(LEVEL+1)=K+(NAMLEN(LEVEL)-J)
            DO 4 I=NAMLEN(LEVEL+1)+1,LEN(NAME(LEVEL+1))
              NAME(LEVEL+1)(I:I)=' '
4           CONTINUE
          ELSE
            NAME(LEVEL+1)(K+1:LEN(NAME(LEVEL+1)))
     &        =NAME(LEVEL)(J+1:J+(LEN(NAME(LEVEL+1))-K))
            NAMLEN(LEVEL+1)=LEN(NAME(LEVEL+1))
C           ...
          ENDIF
        ELSE
          NAMLEN(LEVEL+1)=K
        ENDIF
        LEVEL = LEVEL+1
        LSTPOS(LEVEL) = 0
        LSTLEN(LEVEL) = 0
        GOTO 2
      ENDIF
9999  CONTINUE
      IF(LEN(FILNAM).LT.NAMLEN(LEVEL)) THEN
          WRITE ( NCAWU, '(// '' MTRNLG: Filename too small ''//)')
          CALL XOPMSG (IOPCRY, IOPABN, 0 )
          CALL XERHND (IERSEV)
       END IF
C
      FILNAM(1:NAMLEN(LEVEL))=NAME(LEVEL)(1:NAMLEN(LEVEL))
      DO 8888 I=NAMLEN(LEVEL)+1,LEN(FILNAM)
        FILNAM(I:I)=' '
8888  CONTINUE
      LENNAM = KSTRLN(FILNAM)
C      WRITE(NCAWU,*) 'MTRNLG: Output="',FILNAM(1:LENNAM),'"'
      RETURN
      END
C
 
CODE FOR XOPMSG
      SUBROUTINE XOPMSG (I,J,K)
C THIS IS A DUMMY ROUTINE
      RETURN
      END
 
CODE FOR XERHND (I)
C THIS IS ANOTHER DUMMY ROUTINE - THE PROPER ONE WILL BE LINKED
C IN WITH CRYSTALS IF REQUIRED.
      SUBROUTINE XERHND (I)
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      WRITE (ISTOUT,*) 'Error - data files not found. Cannot continue.'
      WRITE (ISTOUT,*) 'Check the existence of the pointer CRYSDIR'
C cljf
      call zmore1('Check the existence of the pointer CRYSDIR',0)
      STOP
      END
 
CODE FOR KSTRLN
      FUNCTION KSTRLN(STRING)
      CHARACTER*(*) STRING
      INTEGER I,J
      J=0
      DO 1 I=1,LEN(STRING)
        IF((STRING(I:I).NE.CHAR(32)).AND.(STRING(I:I).NE.' ')) J=I
1     CONTINUE
      KSTRLN=J
      RETURN
      END
 
CODE FOR XCCUPC
      SUBROUTINE XCCUPC ( CLOWER , CUPPER )
C
C -- CONVERT STRING TO UPPERCASE
C
C      CLOWER      SOURCE STRING TO BE CONVERTED
C      CUPPER      RESULTANT STRING
C
C
      CHARACTER*(*) CLOWER , CUPPER
C
      CHARACTER*26 CALPHA , CEQUIV
C
      DATA CALPHA / 'abcdefghijklmnopqrstuvwxyz' /
      DATA CEQUIV / 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' /
C
C
C -- MOVE WHOLE STRING.
C      CUPPER = CLOWER
C
      LENGTH = MIN0 ( LEN ( CLOWER ) , LEN ( CUPPER ) )
C
C -- SEARCH FOR LOWERCASE CHARACTERS AND CONVERT TO UPPERCASE
      DO 2000 I = 1 , LENGTH
        IPOS = INDEX ( CALPHA , CLOWER(I:I) )
        IF ( IPOS .GT. 0 ) CUPPER(I:I) = CEQUIV(IPOS:IPOS)
2000  CONTINUE
      RETURN
      END
C
 
#else

      SUBROUTINE DUMMY_EMPTY_ROUTINE
      END
#endif
