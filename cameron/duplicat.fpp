CRYSTALS CODE FOR DUPLICAT.FOR                                                  
CODE FOR F01AJF
      SUBROUTINE F01AJF(N, ATOL, A, IA, D, E, Z, IZ)
C     MARK 2 RELEASE. NAG COPYRIGHT 1972
C     MARK 4 REVISED.
C     MARK 4.5 REVISED
C     MARK 5C REVISED
C
C     TRED2
C     THIS SUBROUTINE REDUCES THE GIVEN LOWER TRIANGLE OF A
C     SYMMETRIC MATRIX, A, STORED IN THE ARRAY A(N,N), TO
C     TRIDIAGONAL FORM USING HOUSEHOLDERS REDUCTION. THE DIAGONAL
C     OF THE RESULT IS STORED IN THE ARRAY D(N) AND THE
C     SUB-DIAGONAL IN THE LAST N - 1 STORES OF THE ARRAY E(N)
C     (WITH THE ADDITIONAL ELEMENT E(1) = 0). THE TRANSFORMATION
C     MATRICES ARE ACCUMULATED IN THE ARRAY Z(N,N). THE ARRAY
C     A IS LEFT UNALTERED UNLESS THE ACTUAL PARAMETERS
C     CORRESPONDING TO A AND Z ARE IDENTICAL.
C     1ST AUGUST 1971
C
      INTEGER I, IA, II, IZ, J1, J, K, L, N
      DOUBLE PRECISION ATOL, F, G, H, HH, A(IA,N), D(N), E(N), Z(IZ,N)
      DO 40 I=1,N
         DO 20 J=1,I
            Z(I,J) = A(I,J)
   20    CONTINUE
   40 CONTINUE
      IF (N.EQ.1) GO TO 280
      DO 260 II=2,N
         I = N - II + 2
         L = I - 2
         F = Z(I,I-1)
         G = 0.0D0
         IF (L.EQ.0) GO TO 80
         DO 60 K=1,L
            G = G + Z(I,K)*Z(I,K)
   60    CONTINUE
   80    H = G + F*F
C     IF G IS TOO SMALL FOR ORTHOGONALITY TO BE
C     GUARANTEED THE TRANSFORMATION IS SKIPPED
         IF (G.GT.ATOL) GO TO 100
         E(I) = F
         H = 0.0D0
         GO TO 240
  100    L = L + 1
         G = DSQRT(H)
         IF (F.GE.0.0D0) G = -G
         E(I) = G
         H = H - F*G
         Z(I,I-1) = F - G
         F = 0.0D0
         DO 180 J=1,L
            Z(J,I) = Z(I,J)/H
            G = 0.0D0
C     FORM ELEMENT OF A*U
            DO 120 K=1,J
               G = G + Z(J,K)*Z(I,K)
  120       CONTINUE
            J1 = J + 1
            IF (J1.GT.L) GO TO 160
            DO 140 K=J1,L
               G = G + Z(K,J)*Z(I,K)
  140       CONTINUE
C     FORM ELEMENT OF P
  160       E(J) = G/H
            F = F + G*Z(J,I)
  180    CONTINUE
C     FORM K
         HH = F/(H+H)
C     FORM REDUCED A
         DO 220 J=1,L
            F = Z(I,J)
            G = E(J) - HH*F
            E(J) = G
            DO 200 K=1,J
               Z(J,K) = Z(J,K) - F*E(K) - G*Z(I,K)
  200       CONTINUE
  220    CONTINUE
  240    D(I) = H
  260 CONTINUE
  280 E(1) = 0.0D0
      D(1) = 0.0D0
C     ACCUMULATION OF TRANSFORMATION MATRICES
      DO 400 I=1,N
         L = I - 1
         IF (D(I).EQ.0.0D0) GO TO 360
         DO 340 J=1,L
            G = 0.0D0
            DO 300 K=1,L
               G = G + Z(I,K)*Z(K,J)
  300       CONTINUE
            DO 320 K=1,L
               Z(K,J) = Z(K,J) - G*Z(K,I)
  320       CONTINUE
  340    CONTINUE
  360    D(I) = Z(I,I)
         Z(I,I) = 1.0D0
         IF (L.EQ.0) GO TO 400
         DO 380 J=1,L
            Z(I,J) = 0.0D0
            Z(J,I) = 0.0D0
  380    CONTINUE
  400 CONTINUE
      RETURN
      END
** END OF F01AJFTEXT
 
CODE FOR F02ABF
* F02FTEXT
      SUBROUTINE F02ABF(A, IA, N, R, V, IV, E, IFAIL)
C     MARK 2 RELEASE. NAG COPYRIGHT 1972
C     MARK 3 REVISED.
C     MARK 4.5 REVISED
C
C     EIGENVALUES AND EIGENVECTORS OF A REAL SYMMETRIX MATRIX
C     1ST AUGUST 1971
C
      INTEGER P01AAF, ISAVE, IFAIL, N, IA, IV
C$P 1
      DOUBLE PRECISION SRNAME
      DOUBLE PRECISION TOL, XXXX, A(IA,N), R(N), V(IV,N), E(N), X02ADF,
     * X02AAF
      DATA SRNAME /8H F02ABF /
      ISAVE = IFAIL
      IFAIL = 1
      TOL = X02ADF(1.0D0)
      CALL F01AJF(N, TOL, A, IA, R, E, V, IV)
      TOL = X02AAF(1.0D0)
      CALL F02AMF(N, TOL, R, E, V, IV, IFAIL)
      IF (IFAIL.NE.0) IFAIL = P01AAF(ISAVE,IFAIL,SRNAME)
      RETURN
      END
** END OF F02ABFTEXT
CODE FOR F02AMF
      SUBROUTINE F02AMF(N, ACHEPS, D, E, Z, IZ, IFAIL)
C     MARK 2 RELEASE. NAG COPYRIGHT 1972
C     MARK 3 REVISED.
C     MARK 4 REVISED.
C     MARK 4.5 REVISED
C
C     TQL2
C     THIS SUBROUTINE FINDS THE EIGENVALUES AND EIGENVECTORS OF A
C     TRIDIAGONAL MATRIX, T, GIVEN WITH ITS DIAGONAL ELEMENTS IN
C     THE ARRAY D(N) AND ITS SUB-DIAGONAL ELEMENTS IN THE LAST N
C     - 1 STORES OF THE ARRAY E(N), USING QL TRANSFORMATIONS. THE
C     EIGENVALUES ARE OVERWRITTEN ON THE DIAGONAL ELEMENTS IN THE
C     ARRAY D IN ASCENDING ORDER. THE EIGENVECTORS ARE FORMED IN
C     THE ARRAY Z(N,N), OVERWRITING THE ACCUMULATED
C     TRANSFORMATIONS AS SUPPLIED BY THE SUBROUTINE F01AJF. THE
C     SUBROUTINE WILL FAIL IF ANY ONE EIGENVALUE TAKES MORE THAN 30
C     ITERATIONS.
C     1ST APRIL 1972
C
      INTEGER P01AAF, ISAVE, IFAIL, N, I, L, J, M, I1, M1, II, K, IZ
C$P 1
      DOUBLE PRECISION SRNAME
      DOUBLE PRECISION B, F, H, ACHEPS, G, P, R, C, S, D(N), E(N), Z(IZ,
     *N)
      DATA SRNAME /8H F02AMF /
      ISAVE = IFAIL
      IF (N.EQ.1) GO TO 40
      DO 20 I=2,N
         E(I-1) = E(I)
   20 CONTINUE
   40 E(N) = 0.0D0
      B = 0.0D0
      F = 0.0D0
      DO 300 L=1,N
         J = 0
         H = ACHEPS*(DABS(D(L))+DABS(E(L)))
         IF (B.LT.H) B = H
C     LOOK FOR SMALL SUB-DIAG ELEMENT
         DO 60 M=L,N
            IF (DABS(E(M)).LE.B) GO TO 80
   60    CONTINUE
   80    IF (M.EQ.L) GO TO 280
  100    IF (J.EQ.30) GO TO 400
         J = J + 1
C     FORM SHIFT
         G = D(L)
         H = D(L+1) - G
         IF (DABS(H).GE.DABS(E(L))) GO TO 120
         P = H*0.5D0/E(L)
         R = DSQRT(P*P+1.0D0)
         H = P + R
         IF (P.LT.0.0D0) H = P - R
         D(L) = E(L)/H
         GO TO 140
  120    P = 2.0D0*E(L)/H
         R = DSQRT(P*P+1.0D0)
         D(L) = E(L)*P/(1.0D0+R)
  140    H = G - D(L)
         I1 = L + 1
         IF (I1.GT.N) GO TO 180
         DO 160 I=I1,N
            D(I) = D(I) - H
  160    CONTINUE
  180    F = F + H
C     QL TRANSFORMATION
         P = D(M)
         C = 1.0D0
         S = 0.0D0
         M1 = M - 1
         DO 260 II=L,M1
            I = M1 - II + L
            G = C*E(I)
            H = C*P
            IF (DABS(P).LT.DABS(E(I))) GO TO 200
            C = E(I)/P
            R = DSQRT(C*C+1.0D0)
            E(I+1) = S*P*R
            S = C/R
            C = 1.0D0/R
            GO TO 220
  200       C = P/E(I)
            R = DSQRT(C*C+1.0D0)
            E(I+1) = S*E(I)*R
            S = 1.0D0/R
            C = C/R
  220       P = C*D(I) - S*G
            D(I+1) = H + S*(C*G+S*D(I))
C     FORM VECTOR
            DO 240 K=1,N
               H = Z(K,I+1)
               Z(K,I+1) = S*Z(K,I) + C*H
               Z(K,I) = C*Z(K,I) - S*H
  240       CONTINUE
  260    CONTINUE
         E(L) = S*P
         D(L) = C*P
         IF (DABS(E(L)).GT.B) GO TO 100
  280    D(L) = D(L) + F
  300 CONTINUE
C     ORDER EIGENVALUES AND EIGENVECTORS
      DO 380 I=1,N
         K = I
         P = D(I)
         I1 = I + 1
         IF (I1.GT.N) GO TO 340
         DO 320 J=I1,N
            IF (D(J).GE.P) GO TO 320
            K = J
            P = D(J)
  320    CONTINUE
  340    IF (K.EQ.I) GO TO 380
         D(K) = D(I)
         D(I) = P
         DO 360 J=1,N
            P = Z(J,I)
            Z(J,I) = Z(J,K)
            Z(J,K) = P
  360    CONTINUE
  380 CONTINUE
      IFAIL = 0
      RETURN
  400 IFAIL = P01AAF(ISAVE,1,SRNAME)
      RETURN
      END
** END OF F02AMFTEXT
* P01FTEXT
CODE FOR NCROP3
      FUNCTION NCROP3(A,B,C)
C--COMPUTES THE CROSS PRODUCT OF THE VECTORS A AND B AND STORES THE
C  RESULT IN C.
C
C  A  THE FIRST VECTOR.
C  B  THE SECOND VECTOR.
C  C  THE CROSS PRODUCT OF A WITH B. (C = A CROSS B).
C
C--THE RETURN VALUES OF 'NCROP' ARE :
C
C  -1  THE INPUT VECTORS ARE PARALLEL  RESULTANT VECTOR HAS ZERO LENGTH.
C  >0  THE RESULTANT VECTOR IS NOT ZERO.
C
C--THE OUTPUT VECTOR IN 'C' IS NORMALISED BEFORE RETURN.
C
C--
C
      DIMENSION A(3),B(3),C(3)
C
      NCROP3=1
      CALL ZVMULT(A,B,C)
      IF(NORM3(C))1000,1000,1050
C--ZERO LENGTH VECTOR
1000  CONTINUE
      NCROP3=-1
1050  CONTINUE
      RETURN
      END
 
CODE FOR P01AAF
*UPTODATE P01AAFTEXT
      INTEGER FUNCTION P01AAF(IFAIL, ERROR, SRNAME)
C     MARK 1 RELEASE.  NAG COPYRIGHT 1971
C     MARK 3 REVISED
C     MARK 4A REVISED, IER-45
C     MARK 4.5 REVISED
C     MARK 7 REVISED (DEC 1978)
C     RETURNS THE VALUE OF ERROR OR TERMINATES THE PROGRAM.
      INTEGER ERROR, IFAIL, NOUT
C$P 1
      DOUBLE PRECISION SRNAME
C     TEST IF NO ERROR DETECTED
      IF (ERROR.EQ.0) GO TO 20
C     DETERMINE OUTPUT UNIT FOR MESSAGE
      CALL X04AAF (0,NOUT)
C     TEST FOR SOFT FAILURE
      IF (MOD(IFAIL,10).EQ.1) GO TO 10
C     HARD FAILURE
      WRITE (NOUT,99999) SRNAME, ERROR
C     STOPPING MECHANISM MAY ALSO DIFFER
C     CALL P01AAZ
      STOP
C     SOFT FAIL
C     TEST IF ERROR MESSAGES SUPPRESSED
   10 IF (MOD(IFAIL/10,10).EQ.0) GO TO 20
      WRITE (NOUT,99999) SRNAME, ERROR
   20 P01AAF = ERROR
      RETURN
99999 FORMAT (1H0, 38HERROR DETECTED BY NAG LIBRARY ROUTINE , A8,
     * 11H - IFAIL = , I5//)
      END
** END OF P01AAFTEXT
 
* X02FTEXT
*UPTODATE X02AAFTEXT
CODE FOR X02AAF
      DOUBLE PRECISION FUNCTION X02AAF(X)
C     NAG COPYRIGHT 1975
C     MARK 4.5 RELEASE
      DOUBLE PRECISION X
C     * EPS *
C     RETURNS THE VALUE EPS WHERE EPS IS THE SMALLEST
C     POSITIVE
C     NUMBER SUCH THAT 1.0 + EPS > 1.0
C     THE X PARAMETER IS NOT USED
C     FOR DEC VAX 11/780
C     X02AAF = 2.0**(-56.0)
      X02AAF = 2.0D0**(-55)
      RETURN
      END
** END OF X02AAFTEXT
CODE FOR X02ADF
*UPTODATE X02ADFTEXT
      DOUBLE PRECISION FUNCTION X02ADF(X)
C     NAG COPYRIGHT 1975
C     MARK 4.5 RELEASE
      DOUBLE PRECISION X
C     * TOL *
C     RETURNS THE RATIO OF THE SMALLEST POSITIVE REAL FLOATING-
C     POINT NUMBER REPRESENTABLE ON THE COMPUTER TO EPS
C     FOR DEC VAX 11/780
C     X02ADF = 2.0D0**(-72)
      X02ADF = 2.0D0**(-72)
      RETURN
      END
** END OF X02ADFTEXT
* X04FTEXT
CODE FOR XDETR3
      FUNCTION XDETR3(AMAT)
C--COMPUTE THE DETERMINANT OF THE 3 BY 3 MATRIX 'AMAT'.
C
C  AMAT  THE MATRIX.
C
C--THE RETURN VALUE IS THE VALUE OF THE DETERMINANT.
C
C--
C
      DIMENSION AMAT(9)
C
      XDETR3=(AMAT(5)*AMAT(9)-AMAT(8)*AMAT(6))*AMAT(1)-(AMAT(2)*AMAT(9)
     2 -AMAT(8)*AMAT(3))*AMAT(4)+(AMAT(2)*AMAT(6)-AMAT(5)*AMAT(3))
     3 *AMAT(7)
      RETURN
      END
C
 
 
CODE FOR NORM3
      FUNCTION NORM3(X)
C--NORMALISE THE VECTOR 'X' SO THAT THE SUM OF THE SQUARES
C  OF ITS THREE ELEMENTS IS UNITY.
C
C  X  THE VECTOR, CONTAINING THREE ELEMENTS.
C
C--THE RETURN VALUES OF 'NORM' ARE :
C
C  -1  THE VECTOR HAS ZERO LENGTH  (<0.0000001).
C  >0  ALL OKAY.
C
C--
C
      DIMENSION X(3)
C
C
C
      DATA D/0.0/
C
C--SUM THE SQUARES
      D=X(1)*X(1)+X(2)*X(2)+X(3)*X(3)
      IF (D.LT.0.0000001) THEN
        NORM3 = -1
        RETURN
      ENDIF
C--NORMALISE THE COMPONENTS
      D=1./SQRT(D)
      X(1)=X(1)*D
      X(2)=X(2)*D
      X(3)=X(3)*D
      NORM3=1
C--AND NOW RETURN
      RETURN
      END
 
CODE FOR X04AAF
*UPTODATE X04AAFTEXT
      SUBROUTINE X04AAF(I,NERR)
C     MARK 7 RELEASE. NAG COPYRIGHT 1978
C     MARK 7C REVISED IER-190 (MAY 1979)
C     IF I = 0, SETS NERR TO CURRENT ERROR MESSAGE UNIT NUMBER
C     (STORED IN NERR1).
C     IF I = 1, CHANGES CURRENT ERROR MESSAGE UNIT NUMBER TO
C     VALUE SPECIFIED BY NERR.
C
C     *** NOTE ***
C     THIS ROUTINE ASSUMES THAT THE VALUE OF NERR1 IS SAVED
C     BETWEEN CALLS. IN SOME IMPLEMENTATIONS IT MAY BE
C     NECESSARY TO STORE NERR1 IN A LABELLED COMMON
C     BLOCK /AX04AA/ TO ACHIEVE THIS.
C
C     .. SCALAR ARGUMENTS ..
      INTEGER I, NERR
C     ..
C     .. LOCAL SCALARS ..
      INTEGER NERR1
C     ..
      DATA NERR1 /6/
      IF (I.EQ.0) NERR = NERR1
      IF (I.EQ.1) NERR1 = NERR
      RETURN
      END
** END OF X04AAFTEXT
 
CODE FOR MTRNLG
      SUBROUTINE MTRNLG(FILNAM,STATUS,LENNAM)
C
C----- EXPAND LOGICAL NAMES (ENVIRONMENT VARIABLES) IF THEY
C      ARE PART OF THE FILE NAME.
C
C      CODE BY MARTIN KRETSCHMAR, TUBINGEN, 1991
C
C FILNAM CONTAINS THE OLD FILE NAME AND WILL PASS BACK THE NEW ONE.
C
C STATUS IS THE THE WAY THE FILE IS INTENDED TO BE OPENED. IF SEARCH-
C LISTS LIKE THE VAX/VMS LOGICAL NAMES ARE TO BE EMULATED, IT IS
C IMPORTANT TO KNOW THIS.
C
C LENNAM USEFUL LENGTH OF FILENAME
C
C      IMPLICIT NONE
      INCLUDE 'COMMON.INC'
      INTEGER MAXLVL
      PARAMETER (MAXLVL=30)
      CHARACTER*(*) FILNAM,STATUS
      LOGICAL LEXIST
      INTEGER KSTRLN
      INTEGER I,J,K,LEVEL,IWHAT
      INTEGER NAMLEN(MAXLVL),COLPOS(MAXLVL)
      INTEGER LSTLEN(MAXLVL),LSTPOS(MAXLVL)
      CHARACTER*200 INQNAM,NAME(MAXLVL),LIST(MAXLVL)
      NCAWU = ISTOUT
C
C\XUNITS
C\XOPVAL
C\XERVAL
C
C NOW WE SEARCH FOR THE LENGTH OF OUR FILE NAME AND REMOVE BLANKS.
C
C      WRITE(NCAWU,*) 'MTRNLG:  Input="',FILNAM(1:KSTRLN(FILNAM)),
C     & '":',LEN(FILNAM),', Status="',STATUS(1:KSTRLN(STATUS)),'"'
      LEVEL=1
      J=0
      DO 1 I=1,LEN(FILNAM)
        IF(FILNAM(I:I).NE.' ') THEN
          J=J+1
          IF(J.LE.LEN(NAME(1))) NAME(1)(J:J)=FILNAM(I:I)
        ENDIF
1     CONTINUE
      NAMLEN(1)=J
      LSTPOS(1)=0
      LSTLEN(1)=-1
C
C CHECK ON FILE NAME NAMLEN OVERFLOW
C
      IF(J.GT.LEN(NAME(LEVEL))) THEN
      WRITE ( NCAWU, '(// '' MTRNLG: Filename too long ''//)')
      CALL XOPMSG (IOPCRY, IOPABN, 0 )
      CALL XERHND (IERSEV)
      ENDIF
C
C
C
      IWHAT=0
      IF(STATUS.EQ.'OLD') IWHAT=1
      IF(STATUS.EQ.'NEW') IWHAT=2
      IF(STATUS.EQ.'FRESH') IWHAT=2
      IF(STATUS.EQ.'UNKNOWN') IWHAT=3
      IF(IWHAT.EQ.0) THEN
      WRITE ( NCAWU, '(// '' MTRNLG: Unknown status ''//)')
      CALL XOPMSG (IOPCRY, IOPABN, 0 )
      CALL XERHND (IERSEV)
      END IF
C
C HERE COMES THE BIG SEARCH LOOP. IT IS GUIDED BY THE LEVEL AND THE IWHAT
C VARIABLE.
C
C SEARCH FOR THE FIRST ':' IF THERE IS ANY
C
2     COLPOS(LEVEL)=INDEX(NAME(LEVEL)(1:NAMLEN(LEVEL)),':')
C
C TEST IF SOMETHING CAN BE DONE
C
      IF(COLPOS(LEVEL).LT.3) THEN
C        WRITE(NCAWU,*) 'Inquiring "',NAME(LEVEL)(1:NAMLEN(LEVEL)),'"'
        IF(IWHAT.EQ.2) GOTO 9999
        INQNAM=NAME(LEVEL)(1:NAMLEN(LEVEL))
        DO 6666 I=NAMLEN(LEVEL)+1,LEN(INQNAM)
          INQNAM(I:I)=' '
6666    CONTINUE
        INQUIRE(FILE=INQNAM,EXIST=LEXIST)
        IF(LEXIST) GOTO 9999
        LEVEL=LEVEL-1
        IF(LEVEL.GE.1) GOTO 3
        LEVEL=1
        GOTO 9999
      ENDIF
C
C LOOK FOR AN ENVIRONMENT STRING IF NONE WAS ASSIGNED UP TO NOW
C
      IF(LSTLEN(LEVEL).LT.0) THEN
        CALL XCCUPC(NAME(LEVEL)(1:COLPOS(LEVEL)-1),
     &              NAME(LEVEL)(1:COLPOS(LEVEL)-1))
        LIST(LEVEL) = ' '
C----- DOSPARAM@ ( CPARAM, CVALUE) RETURNS THE CVALUE OF THE PARAMETER
C      CPARAM, INITIALISED WITH THE DOS COMMAND
C      SET CPARAM=CVALUE
       CALL DOSPARAM@(NAME(LEVEL)(1:COLPOS(LEVEL)-1),LIST(LEVEL))
C&UNX        CALL GETENV(NAME(LEVEL)(1:COLPOS(LEVEL)-1),LIST(LEVEL))
        LSTPOS(LEVEL)=0
        LSTLEN(LEVEL)=KSTRLN(LIST(LEVEL))
C        WRITE(NCAWU,*) 'Environment ',LEVEL,'  "',
C     &    NAME(LEVEL)(1:COLPOS(LEVEL)-1),'"  = "',
C     &    LIST(LEVEL)(1:LSTLEN(LEVEL)),'"'
      ENDIF
C
C TEST LIST FOR SOMETHING TO PROCESS
C
3     CONTINUE
C      WRITE(NCAWU,*) 'Testing ',LEVEL,'  "',
C     &  NAME(LEVEL)(1:NAMLEN(LEVEL)),'"'
      IF((LSTPOS(LEVEL).GE.LSTLEN(LEVEL))
     &  .OR.((LSTPOS(LEVEL).GT.0).AND.(IWHAT.EQ.2))) THEN
        LEVEL=LEVEL-1
        IF(LEVEL.GE.1) GOTO 3
        LEVEL=1
        IF(IWHAT.EQ.3) THEN
          IWHAT=2
          LEVEL=1
          LSTPOS(1)=0
          LSTLEN(1)=-1
          GOTO 2
        ENDIF
        GOTO 9999
      ELSE
        IF(LEVEL.GE.MAXLVL) THEN
      WRITE ( NCAWU, '(// '' MTRNLG: Out of levels ''//)')
      CALL XOPMSG (IOPCRY, IOPABN, 0 )
      CALL XERHND (IERSEV)
        END IF
        J=LSTPOS(LEVEL)+1
        LSTPOS(LEVEL)=INDEX(LIST(LEVEL)(J:LSTLEN(LEVEL)),',')+J-1
        IF(LSTPOS(LEVEL).EQ.(J-1)) LSTPOS(LEVEL)=LSTLEN(LEVEL)+1
C         WRITE(NCAWU,*)
C     1 'Extracted     "',LIST(LEVEL)(J:LSTPOS(LEVEL)-1),'"'
        K=LSTPOS(LEVEL)-J
        NAME(LEVEL+1)(1:K)=LIST(LEVEL)(J:LSTPOS(LEVEL)-1)
C          WRITE(NCAWU,*)'Name="',NAME(LEVEL+1)(1:K),'"',J,K
        J=COLPOS(LEVEL)
C
C IF SOME 'REST' OF THE ORIGINAL FILE NAME REMAINDED
C
        IF(J.LT.NAMLEN(LEVEL)) THEN
C
C IF THE 'REST' CAN BE ADDED TO THE STRING WE GOT, DO SO
C
          IF((K+(NAMLEN(LEVEL)-J)).LE.LEN(NAME(LEVEL+1))) THEN
            NAME(LEVEL+1)(K+1:K+(NAMLEN(LEVEL)-J))
     &        =NAME(LEVEL)(J+1:NAMLEN(LEVEL))
            NAMLEN(LEVEL+1)=K+(NAMLEN(LEVEL)-J)
            DO 4 I=NAMLEN(LEVEL+1)+1,LEN(NAME(LEVEL+1))
              NAME(LEVEL+1)(I:I)=' '
4           CONTINUE
          ELSE
            NAME(LEVEL+1)(K+1:LEN(NAME(LEVEL+1)))
     &        =NAME(LEVEL)(J+1:J+(LEN(NAME(LEVEL+1))-K))
            NAMLEN(LEVEL+1)=LEN(NAME(LEVEL+1))
C           ...
          ENDIF
        ELSE
          NAMLEN(LEVEL+1)=K
        ENDIF
        LEVEL = LEVEL+1
        LSTPOS(LEVEL) = 0
        LSTLEN(LEVEL) = 0
        GOTO 2
      ENDIF
9999  CONTINUE
      IF(LEN(FILNAM).LT.NAMLEN(LEVEL)) THEN
          WRITE ( NCAWU, '(// '' MTRNLG: Filename too small ''//)')
          CALL XOPMSG (IOPCRY, IOPABN, 0 )
          CALL XERHND (IERSEV)
       END IF
C
      FILNAM(1:NAMLEN(LEVEL))=NAME(LEVEL)(1:NAMLEN(LEVEL))
      DO 8888 I=NAMLEN(LEVEL)+1,LEN(FILNAM)
        FILNAM(I:I)=' '
8888  CONTINUE
      LENNAM = KSTRLN(FILNAM)
C      WRITE(NCAWU,*) 'MTRNLG: Output="',FILNAM(1:LENNAM),'"'
      RETURN
      END
C
 
CODE FOR XOPMSG
      SUBROUTINE XOPMSG (I,J,K)
C THIS IS A DUMMY ROUTINE
      RETURN
      END
 
CODE FOR XERHND (I)
C THIS IS ANOTHER DUMMY ROUTINE - THE PROPER ONE WILL BE LINKED
C IN WITH CRYSTALS IF REQUIRED.
      SUBROUTINE XERHND (I)
      INCLUDE 'COMMON.INC'
      WRITE (ISTOUT,*) 'Error - data files not found. Cannot continue.'
      WRITE (ISTOUT,*) 'Check the existence of the pointer CRYSDIR'
C cljf
      call zmore1('Check the existence of the pointer CRYSDIR',0)
      STOP
      END
 
CODE FOR KSTRLN
      FUNCTION KSTRLN(STRING)
      CHARACTER*(*) STRING
      INTEGER I,J
      J=0
      DO 1 I=1,LEN(STRING)
        IF((STRING(I:I).NE.CHAR(32)).AND.(STRING(I:I).NE.' ')) J=I
1     CONTINUE
      KSTRLN=J
      RETURN
      END
 
CODE FOR XCCUPC
      SUBROUTINE XCCUPC ( CLOWER , CUPPER )
C
C -- CONVERT STRING TO UPPERCASE
C
C      CLOWER      SOURCE STRING TO BE CONVERTED
C      CUPPER      RESULTANT STRING
C
C
      CHARACTER*(*) CLOWER , CUPPER
C
      CHARACTER*26 CALPHA , CEQUIV
C
      DATA CALPHA / 'abcdefghijklmnopqrstuvwxyz' /
      DATA CEQUIV / 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' /
C
C
C -- MOVE WHOLE STRING.
C      CUPPER = CLOWER
C
      LENGTH = MIN0 ( LEN ( CLOWER ) , LEN ( CUPPER ) )
C
C -- SEARCH FOR LOWERCASE CHARACTERS AND CONVERT TO UPPERCASE
      DO 2000 I = 1 , LENGTH
        IPOS = INDEX ( CALPHA , CLOWER(I:I) )
        IF ( IPOS .GT. 0 ) CUPPER(I:I) = CEQUIV(IPOS:IPOS)
2000  CONTINUE
      RETURN
      END
C
 
