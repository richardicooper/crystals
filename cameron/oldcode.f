
CODE FOR ZGTMPS
      SUBROUTINE ZGTMPS (IMX,IMY)
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

#if defined(DOS) 
      INCLUDE 'CAMWIN.INC'
#endif
      INTEGER IMX,IMY
C cljf
C      INTEGER*2 IMMX,IMMY,BUTTON_STATUS
C&DOS      call get_mouse_position (immx,immy)
C&DOS      imx = nint(float(immx)/scale_X)
C&DOS      imy = nint(float(immy)/scale_Y)
      CALL ZMORE('Error: ZGTMPS called',0)
      RETURN
      END

CODE FOR ZRTSBL
      SUBROUTINE ZRTSBL (IX,IY,IBUFF,IFLAG,ERROR)
#if defined(DOS) 
      INCLUDE 'CAMWIN.INC'
#endif
      INTEGER IX,IY
#if defined(DOS) 
      INTEGER*2 IXX,IYY
#endif
      INTEGER IFLAG,ERROR
      INTEGER IBUFF
#if defined(DOS) 
      ixx = nint(float(ix)*scale_X)
      iyy = nint(float(iy)*scale_Y)
      CALL RESTORE_SCREEN_BLOCK@(IXX,IYY,IBUFF,IFLAG,ERROR)
#endif
      RETURN
      END

CODE FOR ZGTBUT
      SUBROUTINE ZGTBUT (N,IB)
      INTEGER IB,N
#if defined(DOS) 
      INTEGER*2 IBB,NN
      CALL GET_MOUSE_BUTTON_PRESS_COUNT(N,IB)
#else
      CALL ZMORE('Error: ZGTBUT called',0)
#endif
      RETURN
      END

CODE FOR ZMOUSE
      SUBROUTINE ZMOUSE
      INTEGER IBX,IBY,IBCHCK
c^^^      INCLUDE 'BUTTON.INC'
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      CALL ZMINIT
      CALL ZMDISP
      IB = 0
10    CONTINUE
      CALL ZGTBUT (1,IB)
      IF (IB.GT.0) RETURN
      CALL ZGTBUT (0,IB)
      IF (IB.EQ.0) GOTO 10
C GET THE MOUSE POSITION
      CALL ZGTMPS (IBX,IBY)
C CHECK THIS POSITION
      INO = IBCHCK (IBX,IBY)
      IF (INO.GT.0) THEN
        WRITE (6,*) CBUTTX (INO)
      ENDIF
      GOTO 10
      END

CODE FOR ZMDISP
      SUBROUTINE ZMDISP
C cljf
C      CALL DISPLAY_MOUSE_CURSOR@
C      RETURN
      END

CODE FOR ZMHIDE
      SUBROUTINE ZMHIDE
C cljf
C      CALL HIDE_MOUSE_CURSOR@
C      RETURN
      END

CODE FOR ZVGA

      SUBROUTINE ZVGA
C      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

C cljf
C      CALL VGA@
C      WRITE (ISTOUT,'(A1,A6)') CHAR(27),'[37;1m'
C      RETURN
      END
 
CODE FOR ZEGA
      SUBROUTINE ZEGA
C      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

C cljf
C      CALL EGA@
C      WRITE (ISTOUT,'(2A)') CHAR(27),'[37;1m'
C      RETURN
      END

CODE FOR ZMREST
      SUBROUTINE ZMREST
C cljf
C      LOGICAL LRESET
C      CALL MOUSE_SOFT_RESET@(LRESET)
C      IF (.NOT.RESET) THEN
C        WRITE (6,*) 'Warning MOUSE driver not installed.'
C      ENDIF
C      CALL INITIALISE_MOUSE@
C      RETURN
      END
 
 
CODE FOR ZMINIT
      SUBROUTINE ZMINIT
C cljf
C      CALL INITIALISE_MOUSE@
C      CALL SET_MOUSE_BOUNDS@(0,0,639,479)
C      RETURN
      END

CODE FOR ZTMODE
      SUBROUTINE ZTMODE
C cljf
C      CALL TEXT_MODE@
C      RETURN
      END

CODE FOR ZPCX
      SUBROUTINE ZPCX
C  cljf
C      INTEGER BUFFER
C      INTEGER*2  ERROR
C      CALL GET_SCREEN_BLOCK@(0,0,639,479,BUFFER)
C      CALL SCREEN_BLOCK_TO_PCX@('TITLE.PCX',BUFFER,ERROR)
C      CALL RETURN_STORAGE@(BUFFER)
      RETURN
      END

CODE FOR ZPCXT ( IERR )
      SUBROUTINE ZPCXT ( IERR )
C TITLE PAGE LOADING FOR  VGA TERMINALS
      CHARACTER*17 PALETTE
      CHARACTER*80 FILENM
      INTEGER*2 IX,IX1,IY,ICOL,IVAL,ICOUNT
      LOGICAL LFILES
      INTEGER IFIN
C TEMP DISABLE TITLE
C----- enable by djw 11 jan 95
C      RETURN
      IFIN = 12
      FILENM = 'CAMERON.LJP'
      IERR = 0
      IF (.NOT.LFILES(-4,FILENM,IFIN)) THEN
        IERR = 1
        RETURN
      ENDIF
      IX = 1
      IY = 1
      READ (IFIN) PALETTE
      CALL SET_ALL_PALETTE_REGS@(PALETTE)
10    CONTINUE
      READ (IFIN) IVAL
      ICOL = MOD(IVAL,20)
      ICOUNT = IVAL/20
      IX1 = IX + ICOUNT - 1
      CALL FILL_RECTANGLE@(IX,IY,IX1,IY,ICOL)
      IX = IX + ICOUNT
      IF (IX.EQ.641) THEN
        IX = 1
        IY = IY + 1
      ENDIF
      IF (IY.LE.480) GOTO 10
      IF (.NOT.LFILES(0,' ',IFIN)) THEN
        IERR= 1
        RETURN
      ENDIF
      CALL ZSLEEP(3.0)
      RETURN
      END

CODE FOR ZFLUSH
      SUBROUTINE ZFLUSH
C THIS ROUTINE FLUSHES THE KEYBOARD BUFFER
#if defined(DOS) 
      integer*2 k,get_wkey1@
10    k=get_wkey1@()
      if(k .ne. 0) goto 10
#endif
      END

CODE FOR ZOINIT
      SUBROUTINE ZOINIT
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

CVAX      COMMON /SMG/ IKEYBD
CVAX      INTEGER SMG$CREATE_VIRTUAL_KEYBOARD
CVAX      INCLUDE '($SMGDEF)'
CVAX      I = SMG$CREATE_VIRTUAL_KEYBOARD (IKEYBD,'TT:')
CVAX      OPEN (UNIT=IGOUT,FILE='TT:',FORM='FORMATTED',STATUS='UNKNOWN'
CVAX     + , CARRIAGECONTROL='NONE')
CVAX      OPEN (UNIT=ISTOUT,FILE='TT:',FORM='FORMATTED', STATUS='UNKNOWN',
CVAX     + CARRIAGECONTROL = 'LIST')
      RETURN
      END

CODE FOR RRAND
      REAL FUNCTION RRAND ( )
      DOUBLE PRECISION RANVAL
      RANVAL = RANDOM()
      RRAND = REAL(RANVAL)
      RETURN
      END

CODE FOR ZCURSR
      SUBROUTINE ZCURSR (IX,IY)
C cljf
C      INTEGER*2 IXX,IYY
C      IXX = IX
C      IYY = IY
C      CALL SET_CURSOR_POS@(IXX,IYY)
C      RETURN
      END

CODE FOR ZMNKEY [ KEY CONTROL OF MENUS ]
      SUBROUTINE ZMNKEY
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      INTEGER KK
C10    CONTINUE
      CALL ZGETKY(KK)
      IF (KK.EQ.ICRGHT) THEN
        CALL ZRIGHT
      ELSE IF (KK.EQ.ICLEFT) THEN
        CALL ZLEFT
      ELSE IF (KK.EQ.ICDOWN) THEN
        CALL ZDOWN
      ELSE IF (KK.EQ.ICUP) THEN
        CALL ZUP
      ELSE IF (KK.EQ.ICESP) THEN
        CALL ZESCP
      ELSE IF (KK.EQ.ICRET) THEN
        CALL ZRET
      ELSE IF ((KK.EQ.ICLV).OR.(KK.EQ.ICUV)) THEN
        CALL ZV
      ENDIF
      RETURN
      END

CODE FOR ZLEFT
      SUBROUTINE ZLEFT
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

C THIS ROUTINE ACTS UPON A LEFT CURSOR.
      IF (IMENVT.GT.1) THEN
C DO WE HAVE AN ARROW
        IF (IMNTOP.GT.NITEM/2) THEN
C YES THERE ARE RIGHT ARROWS POSSIBLE
          ILAR = IMENU(IMENVT,3)
          ILAR = NINT (RSTORE (ILAR+2) )
          IF (ILAR.GT.0) THEN
C YES THERE IS AN ARROW - GET THE NEXT ROUTINE
C WHERE ARE WE IN THE CURRENT ROUTINE?
            N = ( IMENU(IMENVT,3) - IMENU(IMENVT,1) ) /4
            IMENVT = IMENVT + 1
            IMENX(IMENVT) = IMENX(IMENVT-1) - IMENWD/2
            IMENY(IMENVT) = IMENY(IMENVT-1) + 15*N
            CALL ZMNVET(1)
          ENDIF
        ELSE
C LEFT ARROW - GOES BACK UP A MENU
          CALL ZMNVET(-1)
          IMENVT = IMENVT - 1
          CALL ZMNRED(2)
        ENDIF
        RETURN
C NO ARROW - IGNORE THIS
      ENDIF
      N = IMENU(1,3)
      M = N - 4
      IMNTOP = IMNTOP - 1
      IMENU(1,3) = IMENU(1,3) - 4
      IF (M.LT.IMENU(1,1)) THEN
C CAN'T GO LEFT
        IMENU(1,3) = IMENU(1,1)
        IMNTOP = 1
        RETURN
      ENDIF
      IF (IMNTOP.EQ.0) THEN
C        IF (M.GE.IMENU(1,1)) THEN
C        IF (IMENU(IMENVT,3).GT.IMENU(IMENVT,1)) THEN
C NEED TO MOVE OVER THE MENU BAR
C          IMENU(IMENVT,3) = IMENU(IMENVT,3) - 4
C          M = IMENU(1,3)
C        ELSE
C          M = IMENU(1,1)
C        ENDIF
        IMNTOP = 1
        A = IMENU(1,3)
        B = IMENU(1,3) + NITEM*4 - 4
        CALL ZCHARW(A,B)
        CALL ZMNTOP(A,B)
      ENDIF
      CALL ZMNHI (N,M)
      RETURN
      END
 
CODE FOR ZMENU
      SUBROUTINE ZMENU
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      INTEGER IX1,IY1,IX2,IY2
      IX1 = 0
      IY1 = 0
      IX2 = 639
      IY2 = 479
      CALL ZGTSCN(IX1,IY1,IX2,IY2,IBUFF)
      IMNTOP = 1
      IMENVT = 1
      NITEM = 6
      ICONTR = 2
      A= IMENU(1,1)
      B = IMENU(1,1)+NITEM*4 -4
      CALL ZCHARW(A,B)
      CALL ZMNTOP(A,B)
C NOW DO THE HIGHLIGHT ROUTINE
      CALL ZMNHI (IMENU(1,1),IMENU(1,1))
      IMENCN = 2
      RETURN
      END
 
CODE FOR ZRET
      SUBROUTINE ZRET
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      CHARACTER*(ICLEN) CTEXT
      CHARACTER*12 CNAME
      INTEGER IPOS
      INTEGER IX1,IY1,IX2,IY2
      INTEGER IERROR,IMNOLD,ICLFLG
C This routine acts upon the return keystroke.
      ICLFLG = 0
      IPOS = 1
      IESCP = 0
      IF (IMENVT.EQ.1) THEN
C DO NOTHING IF WE IN THE TOP BAR.
        RETURN
      ENDIF
C RETURN IS NOT ALLOWED FOR COMMANDS IN THE MIDDLE OF A SUB
C MENU STACK.
      ILINE = 0
      IF (RSTORE(IMENU(IMENVT,3)+1).GT.0) RETURN
C SET HEADER COMMAND FLAG
      IHEAD = 1
      IMNOLD = IMENVT
C WE NEED TO LOOP OVER THE ITEMS ABOVE
      DO 10 I = 2 , IMNOLD
        II = IMENU(I,3)
C GET THE COMMAND NAME
        IF (NINT(RSTORE(II+3)).NE.2) THEN
          CNAME = CSTORE(NINT(RSTORE(II)))
     +    //CSTORE(NINT(RSTORE(II))+1)
          ILINE = ILINE + 1
          IF (ILINE.EQ.10) ILINE=1
          IEND = 0
          LINE(ILINE) = CNAME
C PASS DOWN THE NAME
          CALL ZCANAL
          IF (IPROC.EQ.0) THEN
            CALL ZABAND(2)
            GOTO 11
          ENDIF
        ENDIF
C ARE WE WAITING FOR INPUT?
        IINP = NINT ( RSTORE ( IMENU ( I,3 ) + 3) )
        IF (IINP.GT.0.AND.ICLFLG.EQ.0) THEN
          IX1 = 0
          IY1 = 0
          IERROR = 0
          IF (IBUFF.EQ.0) THEN
            CALL ZCLEAR
          ELSE
            CALL ZRTSBL (IX1,IY1,IBUFF,0,IERROR)
          ENDIF
          IMENVT = 1
          CALL ZMNRED(1)
          IMENVT = IMNOLD
          ICLFLG = 1
        ENDIF
        IF (IINP.GT.0) THEN
          CALL ZMNINL(CTEXT,IESCP,I)
          IF (IESCP.EQ.1) THEN
            CALL ZABAND(2)
            GOTO 11
          ENDIF
C ADD THE TEXT INTO THE LINE
          ILINE = ILINE + 1
          IF (ILINE.EQ.10) ILINE=1
          LINE(ILINE) = CTEXT
          IEND = 0
          CALL ZCANAL
          IF (IPROC.EQ.0) THEN
            CALL ZABAND(2)
            GOTO 11
          ENDIF
        ENDIF
10    CONTINUE
      IF (IPROC.EQ.3) THEN
C FORCE STORAGE OF INFO
        INFCMD(ICINPS) = IC*100 + IN*10 + IR
        ICINPS = ICINPS + 1
        ISTORE = 1
      ENDIF
11    CONTINUE
      IX1 = 0
      IY1 = 0
      IERROR = 0
      IF (IBUFF.EQ.0) THEN
        CALL ZCLEAR
      ELSE
        CALL ZRTSBL (IX1,IY1,IBUFF,0,IERROR)
      ENDIF
      CALL ZCOMDO
      CALL ZABAND(2)
      IF (ICAMER.EQ.-1) RETURN
      CALL ZRETST(IBUFF)
      IX1 = 0
      IY1 = 0
      IX2 = 2*XCEN - 1
      IY2 = 2*YCEN - 1
      CALL ZGTSCN(IX1,IY1,IX2,IY2,IBUFF)
      IMENVT = 1
      CALL ZMNRED(1)
      RETURN
      END
 
 
CODE FOR ZRIGHT
      SUBROUTINE ZRIGHT
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

C THIS ROUTINE ACTS UPON A RIGHT CURSOR PRESS.
      IF (IMENVT.GT.1) THEN
C DO WE HAVE AN ARROW
        IF (IMNTOP.LE.NITEM/2) THEN
C YES THERE ARE RIGHT ARROWS POSSIBLE
          ILAR = IMENU(IMENVT,3)
          ILAR = NINT (RSTORE (ILAR+2) )
          IF (ILAR.GT.0) THEN
C YES THERE IS AN ARROW - GET THE NEXT ROUTINE
C WHERE ARE WE IN THE PREVIOUS ROUTINE?
            N = ( IMENU(IMENVT,3) - IMENU(IMENVT,1) ) / 4
            IMENVT = IMENVT + 1
            IMENX(IMENVT) = IMENX(IMENVT-1) + IMENWD/2
            IMENY(IMENVT) = IMENY(IMENVT-1) + 15*N
            CALL ZMNVET(1)
          ENDIF
        ELSE
C GO BACK UP A MENU
          CALL ZMNVET(-1)
          IMENVT = IMENVT - 1
          CALL ZMNRED(2)
        ENDIF
        RETURN
C NO ARROW - IGNORE THIS
      ENDIF
      N = IMENU(1,3)
      M = IMENU(1,3) + 4
      IMENU(IMENVT,3) = IMENU (IMENVT,3) + 4
      IMNTOP = IMNTOP + 1
      IF (IMENU(IMENVT,3).GT.IMENU(IMENVT,2)) THEN
C CAN'T GO RIGHT
        IMENU(IMENVT,3) = IMENU(IMENVT,2)
        M = M - 4
        IMNTOP = IMNTOP - 1
        RETURN
      ENDIF
      IF (IMNTOP.GT.NITEM) THEN
C WE NEED TO MOVE OVER THE TOP MENU BAR
C      IF (M.LE.IMENU(1,2)) THEN
C        IF (IMENU(IMENVT,2)-IMENU(IMENVT,3).GT.NITEM*4) THEN
C MOVE THE MENU BAR
C        ELSE
C          M = IMENU(1,2)
C        ENDIF
        A = IMENU(1,3) - NITEM*4 + 4
        B = IMENU(1,3)
        CALL ZCHARW(A,B)
        CALL ZMNTOP(A,B)
        IMNTOP = NITEM
      ENDIF
      CALL ZMNHI (N,M)
      RETURN
      END

CODE FOR ZUP
      SUBROUTINE ZUP
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

C FIRST OF ALL - ARE WE WITHIN A VERTICAL MENU?
      IF (IMENVT.EQ.1) THEN
C NO WE AREN'T
        RETURN
      ENDIF
C OTHERWISE - WE MUST BE ALREADY IN A MENU - DO UP WITHIN THIS.
      N = IMENU(IMENVT,3)
      M = N - 4
C      IVERT(IMENVT) = IVERT(IMENVT) - 1
      IMENU(IMENVT,3) = IMENU(IMENVT,3) - 4
      IF (M.LT.IMENU(IMENVT,1)) THEN
C        M = 1
C        IVERT(IMENVT) = 1
C GO UP A MENU
      IMENVT = IMENVT - 1
      M = IMENU(IMENVT,3)
      N = IMENU(IMENVT,3)
      CALL ZMNRED(1)
C      M = IMENU(IMENVT,1)
C      IMENU(IMENVT,3) = M
      ENDIF
      IF (IMENVT.EQ.1) THEN
        CALL ZMNHI(N,M)
      ELSE
        CALL ZMNVHI (N , M)
      ENDIF
      RETURN
      END
 
CODE FOR ZV
      SUBROUTINE ZV
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      CHARACTER*80 CTEXT
C THIS CAUSES A VIEW TO BE EXECUTED.
      IF (IMENVT.EQ.1) THEN
        CALL ZMNCOM (CTEXT,3)
      ENDIF
      RETURN
      END

CODE FOR OLDZDIAG2 (WORK,VEC2,VEC3,EIG1,EIG2,P)
      SUBROUTINE OLDZDIAG2 (WORK,VEC2,VEC3,EIG1,EIG2,P)
      REAL WORK(3,3),VEC2(3),VEC3(3),EIG1,EIG2,P
C IS THE MATRIX SYMMETRIC AND REAL?
C Diagonalise the xy components of the matrix to find out the principal
C axes of this new ELLIPSE.
C This is done by forming and solving a quadratic eqn in the eigenvalues
C FIRST CHECK FOR ZERO OFF DIAGONAL TERMS
      IF (ABS(WORK(1,2)).LT.0.0000001) THEN
	EIG1 = WORK(1,1)
	EIG2 = WORK(2,2)
C NOW CHECK FOR ZERO EIGENVALUES
	IF (ABS(EIG1).LT.0.0000001) THEN
	  VEC2(1) = 0.0
	  VEC2(2) = 0.0
	  VEC3(1) = 0.0
	  VEC3(2) = - 1.0 / SQRT ( EIG2 )
	  P = 0.0
	ELSE IF (ABS(EIG2).LT.0.000001) THEN
	  VEC2(1) = -1.0 / SQRT ( EIG1 )
	  VEC2(2) = 0.0
	  VEC3(1) = 0.0
	  VEC3(2) = 0.0
	  P = 0.0
	ELSE
	  VEC2(1) = 1.0 / SQRT ( EIG1 )
	  VEC2(2) = 0.0
	  VEC3(1) = 0.0
	  VEC3(2) = 1.0 / SQRT ( EIG2 )
	  P = 0.0
	ENDIF
	VEC2(3) = 0.0
	VEC3(3) = 0.0
	RETURN
      ENDIF
C OTHERWISE CALCULATE THE EIGENVALUES AND VECTORS AS NORMAL
      B = WORK(1,1) + WORK(2,2)
      C = B*B - 4*(WORK(1,1)*WORK(2,2) - WORK(1,2)*WORK(2,1))
      IF (C.LT.0.0) C = 0.0
      C = SQRT (C)
      EIG1 = ABS((B+C)/2)
      EIG2 = ABS((B-C)/2)
      V =  ( EIG1-WORK(1,1) ) / WORK(2,1)
      V1 = 1.0/(EIG1*(V*V+1))
      VEC2(1) = SQRT(V1)
      VEC2(2) = V*VEC2(1)
      VEC2(3) = 0.0
      IF (ABS(EIG2).LT.0.0000001) THEN
	VEC3(1) = 0.0
	VEC3(2) = 0.0
	VEC3(3) = 0.0
      ELSE
	V = ( EIG2 - WORK ( 1,1) ) / WORK ( 2,1 )
	V1 = 1.0/(EIG2*(V*V+1))
	VEC3(1) = SQRT(V1)
	VEC3(2) = V*VEC3(1)
	VEC3(3) = 0.0
      ENDIF
      P = ATAN2 ( VEC2(2) , VEC2(1) )
      RETURN
      END

CODE FOR ZSPSCH [CHARACTER STRING SEARCH]
      SUBROUTINE ZSPSCH (STRING,ILN,ISTART,IFIN)
      CHARACTER*(*) STRING
      CHARACTER*1 SPACE
C THIS ROUTINE FINDS THE FIRST AND LAST SPACES IN A STRING
      SPACE = ' '
      ISTART = 0
      IFIN = 0
      DO 10 I = 1 , ILN
      IF (ISTART.EQ.0) THEN
C SEARCH FOR FIRST SPACE
	IF (STRING(I:I).EQ.SPACE) THEN
	  ISTART = I
	ENDIF
      ELSE
	IF ((STRING(I:I).NE.SPACE).AND.(IFIN.EQ.0)) THEN
	  IFIN = I
	 ENDIF
      ENDIF
10    CONTINUE
      RETURN
      END

CODE FOR ZDRELL
      SUBROUTINE ZZDRELL (ITYPE,IXC,IYC,IMAJ,IMIN,ICOL,IFTYPE,IATNO)
C This routines draws an ELLIPSE with major/minor axes IMAJ/IMIN
C in colour ICOL.
C ITYPE = 1 - outline of ELLIPSE
C ITYPE = 2 - solid ELLIPSE
C IFTYPE = 2 -SMALL CIRCLE
C IATNO = number of atom we are drawing
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      INTEGER IXC,IYC,IMAJ,IMIN,ICOL
      CHARACTER*1 HEX(16)
      INTEGER IX(90),IY(90)
      DATA HEX/'0','1','2','3','4','5','6','7','8','9','A',
     c 'B','C','D','E','F'/
      GOTO (100,200,300,300,500,500,100,500) ISCRN
100   CONTINUE
C VGA
      IF (ITYPE.EQ.1) THEN
        CALL ZVGAEL(IXC+INT(XCEN+XOFF),IYC+INT(YCEN+YOFF)
     + ,IMAJ,IMIN,ICOL)
      ELSE
        CALL ZFILEL(IXC+INT(XCEN+XOFF),IYC+INT(YCEN+YOFF)
     + ,IMAJ,IMIN,ICOL)
      ENDIF
      GOTO 9999
200   CONTINUE
C SIGMA
      IELL = (256 * IMAJ / IMIN) + 100
      IELL1 = (IMAJ+100)*10
C MOVE CURSOR
      WRITE (11,'('' +-*/GI'',2I3)') IXC+100+INT(XCEN+XOFF)
     c ,IYC+100+INT(YCEN+YOFF)
C CHANGE COLOUR TO ICOL
      WRITE (11,'('' +-*/HI'',A1)') HEX(ICOL+1)
C SET UP SHAPE OF ELLIPSE
      WRITE (11,'('' +-*/JO'',I3)') IELL
C DRAW THE ELLIPSE
      IF (ITYPE.EQ.1) THEN
        WRITE (11,'('' +-*/JM'',I4)') IELL1
            ELSE
        WRITE (11,'('' +-*/JN'',I4)') IELL1
            ENDIF
      GOTO 9999
300   CONTINUE
C CANNOT DO SOLID CIRCLES FOR THIS TYPE OF DEVICE
      IF (ITYPE.EQ.2) RETURN
      ISTEP = 4 + 250/IMAJ
C NON RASTER GENERATE CIRCLE AND CHECK FOR OVERLAP
      K = 1
      DO 310 I = 1 , 361 , ISTEP
      IX(K) = IMAJ * XCOS(I) + IXC
      IY(K) = IMAJ * XSIN(I) + IYC
      K = K + 1
310   CONTINUE
      CALL ZDRLIN(1,IX,IY,K-1,IDEVCL(ICOL+1),IATNO)
      GOTO 9999
500   CONTINUE
C POSTSCRIPT
      IF (ITYPE.EQ.1) RETURN
C DONT NEED TO DO OUTLINE SEPERATELY
      WRITE (IFOUT,'(7A)') 'newpath'
      WRITE (IFOUT,501) (IXC+INT(XCEN+XOFF))/10.0,
     + (IYC+INT(YCEN+YOFF))/10.0
     + ,IMAJ/10.0
501   FORMAT ( 3(F7.2,2X),' 0 360 arc' )
      WRITE (IFOUT,'(9A)') 'closepath'
      WRITE (IFOUT,'(5A)') 'gsave'
      IF (IFILL.EQ.0) THEN
        WRITE (IFOUT,'(9A)') '1 setgray'
      ELSE
        IF (ICPOST.EQ.0) THEN
C NEED TO DO COLOUR
          C = ICOL/15.0
          WRITE (IFOUT,502) C
502     FORMAT (F3.1,' setgray')
        ELSE
          WRITE (IFOUT,503) IPSTCL(1,ICOL+1),IPSTCL(2,ICOL+1),
     +    IPSTCL(3,ICOL+1)
503       FORMAT (F5.2,' ',F5.2,' ',F5.2,' setrgbcolor')
        ENDIF
      ENDIF
      WRITE (IFOUT,'(4A)') 'fill'
      WRITE (IFOUT,'(7A)') 'grestore'
      WRITE (IFOUT,'(9A)') '0 setgray'
      WRITE (IFOUT,'(6A)') 'stroke'
9999  CONTINUE
      RETURN
      END

CODE FOR ZCHARW [ CHECK ARROW ]
      SUBROUTINE ZCHARW(A,B)
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

C SETS THE VALUE OF IMENAR
      IMENAR = 0
      IF (A.GT.IMENU(1,1)) THEN
        IMENAR = 1
      ENDIF
      IF (B.LT.IMENU(1,2)) THEN
        IMENAR = IMENAR + 2
      ENDIF
      RETURN
      END

CODE FOR ZMNINL [ INPUT LINE ]
      SUBROUTINE ZMNINL (CTEXT,IESCP,IMNNUM)
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      INTEGER IX(5),IY(5),ICOL
      CHARACTER*80 CH
      CHARACTER*(ICLEN) CTEXT
      LOGICAL LFILES
      IESCP = 0
C      CH = 'This is the line of HELP text that is to be used!'
C This routine writes a box on the screen into which the user types
C text.
C First get the text.
C Load in the appropriate error message
      IF (ABS(NINT(RSTORE(IMENU(IMNNUM,3)+3))).EQ.2) THEN
C THE ID WE WANT IS THAT OF THE PREVIOUS COMMAND
        ID = NINT(RSTORE(IMENU(IMNNUM-1,3)))
      ELSE
        ID = NINT (RSTORE( IMENU(IMNNUM,3) ))
      ENDIF
      IF (.NOT.LFILES (-1,'COMMAND.CMN',IINPT)) THEN
        CALL ZMORE('Error - COMMAND.CMN cannout be accessed.',0)
        CH = 'Help unavailable.'
      ELSE
        ID = (ID - ICOM)/ISCOM
        DO 210 I = 1 , ID
          READ (IINPT,'(//)')
210     CONTINUE
        READ (IINPT,220) CH
220     FORMAT (//,A80,/)
        IF (.NOT.LFILES (0,' ',IINPT)) THEN
          CALL ZMORE('Error on closing COMMAND.CMN.',0)
        ENDIF
      ENDIF
C Do the text box.
      IX(1) = 0
      IX(2) = 639
      IX(3) = 639
      IX(4) = 0
      IX(5) = 0
      IY(1) = 440
      IY(2) = 440
      IY(3) = 480
      IY(4) = IY(3)
      IY(5) = IY(4)
      ICOL = 1
C      CALL ZCPLGN(IX,IY,4,HANDLE,ERROR)
C      CALL ZFPLGN(HANDLE,ICOL,ERROR)
      CALL ZPOLGN (IX,IY,4,ICOL)
      ICOL = 8
      CALL ZPLINE(IX,IY,5,ICOL)
C NOW WRITE OUT THE HELP TEXT
      IXX = 2
      IYY = 442
      ICOL = 14
      CALL ZDTEXT(CH,IXX,IYY,ICOL)
      IX(1) = 2
      IY(1) = 462
C Don't call ZXT. Try to keep event loop at "top" of program.
C      CALL ZTXT (IX(1),IY(1), CTEXT, IESCP)

C CLOSE DOWN THE BOX
C      CALL ZDPLGN(HANDLE,ERROR)
C REDRAW THE MENUS
C      CALL ZMNRED(1)
      RETURN
      END

CODE FOR ZOLAP
      SUBROUTINE ZZOLAP (X,Y,IDRAW,I)
C This routine checks whether the point about to be drawn is obscured by
C another atom.
C I is the atom we are drawing at the moment
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      IDRAW = 1
C FIND THE START OF THE INFO
      IOSTART = NINT (RSTORE ( I + ILAB + 3 ))
      NOVER = NINT (RSTORE ( I + ILAB + 4 ))
      DO 10 J = 0, NOVER - 1
        NN = NINT (RSTORE ( IOSTART - J ) )
C WHAT STYLE IS THIS ATOM?
        IF (NINT (RSTORE (NN)).EQ.2) THEN
C CIRCLE
          XX = (X - (RSTORE(NN+IXYZO) - XCP)*SCALE)**2
     c       + (Y- (RSTORE(NN+IXYZO+1) - YCP)*SCALE)**2
          IF (XX.LT.(RSTORE(NN+IATTYP+4)*SCALE)**2) THEN
            IDRAW = 0
          ENDIF
        ELSE IF (NINT (RSTORE(NN)).EQ.1) THEN
          GOTO 10
        ELSE
C ELLIPSE
C XX AND YY ARE THE POINTS OF THE ELLIPSE ROTATED ABOUT THE CENTRE OF
C THE OVERLAPPING ELLIPSE SO THAT IT CAN BE TREATED AS THOUGHT IT HAD
C MAJ/MINOR AXES LYING ALONG THE X,Y DIRECTIONS.
C GET THE ELLIPSE INFO
C WE HAVE A UISO ATOM
          IF (RSTORE(NN+IXYZO+12).LT.0.0) THEN
C WE HAVE A UISO ATOM
            XX = (X - (RSTORE(NN+IXYZO) -XCP)*SCALE)**2
     c         + (Y - (RSTORE(NN+IXYZO+1) - YCP)*SCALE)**2
            IF (XX.LT.(SQRT(ABS(RSTORE(NN+IXYZO+12)))*SCALE)**2) THEN
              IDRAW = 0
            ENDIF
          ELSE
            NEL = NINT (RSTORE (NN+IXYZO+15))
            P = RSTORE (NEL+2)
            EIG1 = RSTORE (NEL)*SCALE
            EIG2 = RSTORE (NEL+1)*SCALE
            XX =  (X-(RSTORE(NN+IXYZO)-XCP)*SCALE)*COS(P)
     c       + (Y-(RSTORE(NN+IXYZO+1)-YCP)*SCALE)*SIN(P)
            YY = - (X-(RSTORE(NN+IXYZO)-XCP)*SCALE)*SIN(P)
     c       + (Y-(RSTORE(NN+IXYZO+1)-YCP)*SCALE)*COS(P)
C NOW CALCULATE OVERLAP
            AA = ((XX)**2/EIG1**2) + ((YY)**2/EIG2**2)
            IF (AA.LT.1.0) THEN
              IDRAW = 0
            ENDIF
          ENDIF
        ENDIF
10    CONTINUE
      RETURN
      END
CODE FOR ZCOLMV [ COLLECT MOVE ]
      SUBROUTINE ZCOLMV(INCMV)
C This routine takes the atoms stored after a COLLECT procedure and
C moves them into the main store. Their atomic information is taken
C from the initial atoms, they are sorted so that their order remains
C the same as it was in the input data.
C
C Before this is done it is necessary to check that the centroid of
C the newly collected molecule lies within the unit cell.
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      INTEGER MCX(3)
      REAL SYMM(4,4),C(3),D(3,3),D1(3,3)
C UNFLAG THE ATOMS
      DO 5 I = ISVIEW+IPACKT*8,IFVIEW-1,IPACKT
	RSTORE(I) = ABS(RSTORE(I))
5     CONTINUE
C CALCULATE THE CENTROID
      CALL ZZEROF (CENTR,3)
      CALL ZZEROI (MCX,3)
      DO 10 I = 0,INCMV-1
	DO 20 J = 1,3
	  CENTR(J) = CENTR(J) + RSTORE(IREND-I*5-J)
20      CONTINUE
10    CONTINUE
C GET THE SYMMETRY OPERATOR.
      DO 30 J = 1,3
	CENTR(J) = CENTR(J)/INCMV
C THE VALUE CONTAINED IN MCX REPRESENTS THE TRANSLATION REQUIRED TO
C MOVE THE CENTROID INTO THE CELL.
	IF (CENTR(J).LT.0.0) MCX(J) = 1.0
	IF (CENTR(J).GT.1.0) MCX(J) = -1.0
	CENTR(J) = CENTR(J) + MCX(J)
30    CONTINUE
C FIRST MOVE OVER THE CELL CORNERS
      CALL ZMOVE (RSTORE(ISINIT),RSTORE(IFVIEW),IPACKT*8)
C ALSO MOVE OVER THE CELL LABELS
      ICCC = (IFVIEW-IRATOM)/IPACKT + ICATOM
      DO 3000 ICL = 0 , 7
	CSTORE (ICCC+ICL) = CSTORE (ICATOM+ICL)
3000  CONTINUE
C NOW MOVE THE ATOMS OVER, SORTING ON THE INITIAL ATOMIC POSITION.
      IATMIN = IFVIEW + IPACKT*8
      DO 40 J = 1,INCMV
	DO 50 I = 0,INCMV-1
	  N = RSTORE(IREND-I*5)
	  IF (N.LT.IATMIN) THEN
	    IATMIN = N
	    K = I
	  ENDIF
50      CONTINUE
	DO 70 L = 1,3
	  C(L) = RSTORE(IREND-K*5-L) + MCX(L)
70      CONTINUE
C GET THE CORRECT SYMMETRY OPERATOR.
	NS = NINT(RSTORE(IREND-K*5-4))
	CALL ZMOVE (RSTORE(ITOT-(NS*16)),SYMM,16)
	DO 71 L = 1,3
	  DO 72 M = 1,3
	    D1(L,M) = RSTORE(IATMIN+L*3+M)
72        CONTINUE
71      CONTINUE
	DO 73 L = 1,3
	  DO 74 M = 1,3
	    D(L,M) = SYMM(M,1)*D1(L,1) + SYMM(M,2)*D1(L,2)
     c      + SYMM(M,3)*D1(L,3)
74        CONTINUE
73      CONTINUE
	CALL ZIMOVE (C,D,IATMIN,IFVIEW+(IATMIN-ISVIEW),0)
C REMOVE THIS ATOM FROM THE MIN CALCULATION.
	RSTORE (IREND-K*5) = IFVIEW
	IATMIN = IFVIEW
40    CONTINUE
      RETURN
      END
CODE FOR ZSOUT [ SYMMETRY OPERATOR OUTPUT ]
      SUBROUTINE xxSOUT (SYMM,SWORD,ISLEN)
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      REAL SYMM(4,4),TRAN(8)
      CHARACTER*3 CTRAN(8),SX(3)
      CHARACTER*50 SWORD,STEMP
      CHARACTER*10 CTEMP
      DATA TRAN /0.0,0.5,0.3333,0.25,0.66667,0.75,0.166667,0.8333333/
      DATA CTRAN /'0  ','1/2','1/3','1/4','2/3','3/4','1/6','5/6'/
      DATA SX /'x','y','z'/
C This routine takes in the symmetry operator and prints out its text
C equivalent.
      K = 0
      DO 10 I = 1 , 3
C GET THE PARTS ONE LINE AT A TIME
C DO THE X Y Z BIT FIRST
C FIRST CHECK FOR X-Y OR Y-X BITS
	IF ((NINT(SYMM(I,1)).EQ.1).AND.(NINT(SYMM(I,2)).EQ.-1)) THEN
	  IF (K.EQ.0) THEN
	    SWORD = ' x-y'
	    K = 4
	  ELSE
	    STEMP = SWORD(1:K)//' x-y'
	    SWORD = STEMP
	    K = K + 4
	  ENDIF
	ELSE IF ((NINT(SYMM(I,1)).EQ.-1).AND.(NINT(SYMM(I,2)).EQ.1))
     c THEN
	  IF (K.EQ.0) THEN
	    SWORD = ' y-x'
	    K = 4
	  ELSE
	    STEMP = SWORD(1:K)//' y-x'
	    SWORD = STEMP
	    K = K + 4
	  ENDIF
	ELSE
C WHERE DOES THE 1 LIE?
	  JJ = 0
	  DO 30 J = 1 , 3
	    IF (ABS(NINT(SYMM(I,J))).EQ.1) JJ = J
30        CONTINUE
	  IF (NINT(SYMM(I,JJ)).EQ.1) THEN
	    IF (K.EQ.0) THEN
	      SWORD = SX(JJ)
	      K = 1
	    ELSE
	      STEMP = SWORD(1:K)//' '//SX(JJ)
	      SWORD = STEMP
	      K = K + 2
	    ENDIF
	  ELSE
	    IF (K.EQ.0) THEN
	      SWORD = ' -'//SX(JJ)
	      K = 3
	    ELSE
	      STEMP = SWORD(1:K)//' -'//SX(JJ)
	      SWORD = STEMP
	      K = K + 3
	    ENDIF
	  ENDIF
	ENDIF
C NOW DO THE TRANSLATION IF IT OCCURS
	IF ((ABS(SYMM(I,4)-0.000).GT.0.001).AND.
     c  (ABS(SYMM(I,4)-1.000).GT.0.001)) THEN
C NOT ZERO OR ONE - WHAT IS IT?
	  L = 0
	  DO 20 J = 2 , 8
	    IF (ABS(ABS(SYMM(I,4))-TRAN(J)).LT.0.001) L = J
20        CONTINUE
C NOW ADD IN THE TEXT
	  IF (L.EQ.0) THEN
C THE NUMBER IS NOT A RECOGNISED ONE
	    WRITE (CTEMP,'(SP,F10.4)') SYMM(I,4)
	    STEMP = SWORD(1:K)//'-'//CTEMP
	    INLEN = 11
	  ELSE
	    IF (SYMM(I,4).GT.0.0) THEN
C POSITIVE
	      STEMP = SWORD(1:K)//'+'//CTRAN(L)
	    ELSE
	      STEMP = SWORD(1:K)//'-'//CTRAN(L)
	    ENDIF
	    INLEN = 4
	  ENDIF
	  SWORD = STEMP
	  K = K + INLEN
	ENDIF
C ADD IN THE SPACE
	STEMP = SWORD(1:K)//' '
	SWORD = STEMP
	K = K + 1
10    CONTINUE
      ISLEN = K
      RETURN
      END

CODE FOR ZMAXIM [ MAXIMISE PICTURE SIZE ]
      SUBROUTINE ZMAXIM (IDIR)
C This routine will maximise the picture size in the plane perpendicular
C to the direction defined by IDIR.
C IDIR = 1 - x-direction (used for VERT)
C IDIR = 2 - y-direction (used for HORZ)
C IDIR = 3 - z-direction (used for ALONG,BISECT,PLANE).
C This will only maximise included atoms.
C N,M then define the two rotating coordintes.
C This routine also flags atoms not to be drawn as they overlap, by
C making IPCK = IPCK*100.
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

C      REAL XXC(3),WORK(3,3),VEC1(3),VEC2(3)
      N = MOD(IDIR,3)
      M = MOD(IDIR+1,3)
      IF (M.LT.N) THEN
	M = 2
	N = 0
      ENDIF
C The picture is maximised by diagonalising the relevant 2x2 matrix eg
C { sum (x**2) sum (xy)   }
C { sum (xy)   sum (y**2) }
C for the xy plane (IDIR=3)
      XCOLD = XC
      YCOLD = YC
      ZCOLD = ZC
      X2 = 0.0
      Y2 = 0.0
      XY = 0.0
      D2 = 0.0
      K = 0
      L = 0
      DO 10 I = ISVIEW,IFVIEW-1,IPACKT
C CHECK IF ATOM IS INCLUDED
	X = RSTORE (I+IXYZO+N)
	Y = RSTORE (I+IXYZO+M)
	IF (RSTORE(I+IPCK+1).LT.0.0) GOTO 10
	DO 20 J = ISVIEW,IFVIEW-1,IPACKT
	  X1 = RSTORE (J+IXYZO+N)
	  Y1 = RSTORE (J+IXYZO+M)
	  D = (X-X1)**2 + (Y-Y1)**2
	  IF (D.GT.D2) THEN
	    D2 = D
	    K = I
	    L = J
	  ENDIF
20      CONTINUE
10    CONTINUE
      X = RSTORE (K+IXYZO+N) - RSTORE(L+IXYZO+N)
      Y = RSTORE (K+IXYZO+M) - RSTORE(L+IXYZO+M)
      P = ATAN (Y/X)
      IF (IDIR.NE.1) P = -P
C SET THE CENTRE OF ROTATION TO ATOM 1
      XC = RSTORE(K+IXYZO)
      YC = RSTORE(K+IXYZO+1)
      ZC = RSTORE(K+IXYZO+2)
      CALL ZROT (P,IDIR)
C RESET CENTRE
      XC = XCOLD
      YC = YCOLD
      ZC = ZCOLD
      CALL ZATMUL(0,0,0)
      RETURN
      END

CODE FOR ZSPECL
      SUBROUTINE ZSPECL (ITYPE)
C THIS ROUTINE CHECKS THE MOLECULE FOR ATOMS ON SPECIAL POSITIONS.
C THE SYMMETRY OPERATORS ARE APPLIED ONE BY ONE AND A LIST OF THOSE
C OPERATORS THAT RESULT IN UNIQUE POSITIONS ARE STORED AT THE END OF THE
C RSTORE ARRAY.
C THE NUMBER AND POSITION OF THE SPACEGROUP INFO ARE HELD AT
C I+ISYM AND I+ISYM+1
C ITYPE = 1 all atoms are unique
C       = 2 used after SETUNIT to look for symmetry equivalent atoms.
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      REAL X(3),X1(3),SYMM(4,4)
C DO NOT LOOP OVER CELL CORNERS FOR THIS
      NSPOS = ISYMED
      NAT = 0
      DO 10 I = ISINIT + IPACKT*8 , IFINIT -1 , IPACKT
	NAT = 0
	NSSYM = 0
	DO 20 J = 1 , 3
	  X(J) = RSTORE (I+J)
20      CONTINUE
C LOOP OVER AND GET THE SYMMETRY OPERATORS
	DO 30 II = 1 , NSYMM
	  CALL ZMOVE (RSTORE(ITOT-II*16),SYMM,16)
C APPLY THE OPERATOR
	  CALL ZMATV4 (SYMM,X,X1)
C CHECK ATOMS PREVIOUSLY FOUND
	  ISAT = 0
	  IF (NAT.GT.0) THEN
	    DO 40 J = IRLAST , IRLAST + NAT*3 - 1 , 3
	      IF (ABS(X1(1)-RSTORE(J)).LE.RSTOL) THEN
		IF (ABS(X1(2)-RSTORE(J+1)).LE.RSTOL) THEN
		  IF (ABS(X1(3)-RSTORE(J+2)).LE.RSTOL) THEN
		    ISAT = 1
		  ENDIF
		ENDIF
	      ENDIF
40          CONTINUE
	  ENDIF
C ONLY STORE THE ATOMS COORDINATES AND THIS OPERATOR NUMBER IF
C A PREVIOUS ATOM IS NOT FOUND.
	  IF (ISAT.EQ.0) THEN
	    RSTORE (NSPOS-NSSYM) = II
	    NSSYM = NSSYM + 1
	    RSTORE (IRLAST + NAT*3 )     = X1(1)
	    RSTORE (IRLAST + NAT*3 + 1 ) = X1(2)
	    RSTORE (IRLAST + NAT*3 + 2 ) = X1(3)
	    NAT = NAT + 1
	  ENDIF
30      CONTINUE
C STORE THE INFO
	RSTORE ( I + ISYM ) = NSPOS
	RSTORE ( I + ISYM + 1) = NSSYM
	NSPOS = NSPOS - NSSYM
10    CONTINUE
      ISYMED = NSPOS
C      IF (ITYPE.NE.2) RETURN
C IF ITYPE = 2 THEN WE HAVE TO CHECK THE ASSYMETRIC UNIT AS WELL
C TO ALLOW FOR ATOMS THAT ARE SYMMETRY EQUIVALENTS.
C      IS = ( ISINIT - IRATOM ) / IPACKT + ICATOM + 8
C      IF = ( IFINIT - IRATOM ) / IPACKT + ICATOM
C LOOP OVER THE ATOM LABELS
C      DO 50 I = IS , IF - 1
C        DO 60 J = I+1 , IF - 1
C          IF (CSTORE(I).EQ.CSTORE(J)) THEN
C ATOMS ARE POSSIBLY SYMMETRY EQUIVALENT
C GET THE COORDS OF BOTH THE ATOMS
C            N = ( I - ICATOM ) *IPACKT + IRATOM
C            M = ( J - ICATOM ) *IPACKT + IRATOM
C            DO 70 II = 1 , 3
C              X(II) = RSTORE (N + II)
C              X1(II) = RSTORE (M +II)
C70          CONTINUE
C LOOP OVER THE SYMMETRY OPERATORS OF THE FIRST ATOM AND LOOK FOR
C THE COORDS OF THE SECOND
C            NSTART = NINT (RSTORE (N + ISYM ))
C            NSSYM = NINT ( RSTORE (N+ ISYM + 1))
C            DO 80 K = NSTART , NSTART - NSSYM + 1 , -1
C              ISSYM = NINT (RSTORE (K))
C GET THE OPERATOR
C              CALL ZMOVE( RSTORE(ITOT-ISSYM*16), SYMM , 16)
C APPLY IT TO ATOM 1
C              CALL ZMATV4 (SYMM,X,X2)
C COMPARE THE RESULT
C              ISAME = 0
C              DO 90 L = 1 , 3
C                DVAL = ABS ( X2(L) - X1(L) )
C100             CONTINUE
C                IF (DVAL.GE.1.0) THEN
C                  DVAL = DVAL - 1.0
C                  GOTO 100
C                ENDIF
C                IF (ABS(DVAL).LT.0.0000001) THEN
C                  ISAME = ISAME + 1
C                ENDIF
C90            CONTINUE
C              IF (ISAME.EQ.3) THEN
C WE HAVE A DUPLICATE ATOM - GET RID OF THIS OPERATOR!
C                RSTORE(K) = 0.0
C              ENDIF
C80          CONTINUE
C          ENDIF
C60      CONTINUE
C50    CONTINUE
      RETURN
      END

CODE FOR ZOVERL
      SUBROUTINE ZZOVERL
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

C THIS ROUTINE CALCULATES THE OVERLAPPING ATOMS FOR NON RASTER DEVICES.
      DO 100 I = ISVIEW , IFVIEW - 1 , IPACKT
C FIND THE FURTHEST DISTANCE
        NOVER = 0
        DMAX2 = 2.0
C LOOP OVER THE BONDS
C WE NEED THE ATOMS AT THE ENDS OF THE BONDS TO BE INCLUDED IN THE CALC.
        IBNDST = NINT ( RSTORE ( I + IBOND ) )
        NBONDS = NINT ( RSTORE ( I + IBOND + 1 ) )
        IF (NBONDS.EQ.0) GOTO 100
        DO 110 J = 0, NBONDS
          NN = NINT (RSTORE ( IBNDST - J*2 ) )
          IF (NN.EQ.0) GOTO 110
          D = ( RSTORE ( I + IXYZO ) - RSTORE ( NN + IXYZO ) ) **2
     c      + ( RSTORE ( I + IXYZO + 1 ) - RSTORE (NN + IXYZO + 1 )) **2
          IF (D.GT.DMAX2) DMAX2 = D
110     CONTINUE
        DMAX = SQRT(DMAX2)
        DO 120 J = ISVIEW , IFVIEW - 1 , IPACKT
          IF (I.EQ.J) GOTO 120
C ATOM MUST BE INCLUDED!
          IF (NINT(RSTORE(J+IPCK+1)).LT.0) GOTO 120
C ONLY COUNT OVERLAP BETWEEN ATOMS OF HIGHER Z
          IF (RSTORE(I+IXYZO+2).GT.RSTORE(J+IXYZO+2)) GOTO 120
          IF (ABS( RSTORE(I+IXYZO) - RSTORE(J+IXYZO)).GT.DMAX) GOTO 120
          IF (ABS( RSTORE(I+IXYZO+1)-RSTORE(J+IXYZO+1)).GT.DMAX)
     c GOTO 120
C COULD BE WITHIN RANGE
          D = ( RSTORE(I+IXYZO)-RSTORE(J+IXYZO))**2 +
     c        ( RSTORE(I+IXYZO+1)-RSTORE(J+IXYZO+1))**2
          IF (D.GT.DMAX2) GOTO 120
C IS WITHIN RANGE - STORE
          RSTORE (IREND-NOVER) = J
          NOVER = NOVER + 1
120     CONTINUE
C STORE THE LOCATION AND NUMBER OF OVERLAPPED ATOMS
        RSTORE ( I + ILAB + 3 ) = IREND
        RSTORE ( I + ILAB + 4 ) = NOVER
        IREND = IREND - NOVER
100   CONTINUE
      RETURN
      END

CODE FOR LGNDST [ GENERAL DISTANCE ROUTINE - INCLUDES SYMMETRY ]
      FUNCTION LGNDST (X,X1,C,NS,DIST)
C This is a general distance routine which incorporates the use of
C symmetry operators.
C X is the crystal coords of the pivot atom, C is its connectivity
C radius, X1 is the coords of the other atom.
C DIST IS THE MINIMUM CONNECTION RADIUS IF A BOND DISTANCE
C IS NOT FOUND
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      REAL X(3),X1(3),X2(3),C,ORTH(3,3),SYMM(4,4),DX(3),DX1(3)
      REAL XD(3)
C The distance routine is based on that in Rollett p27.
C However, this routine assumes that, since C is the connectivity radius
C and is therefore small there will not be more than one connecting
C distance possible for each symmetry operator.
C Also, as this routine does not generate more atoms, once one
C connection is found the routine is ended.
      CALL ZMOVE (RSTORE(ICRYST+6),ORTH,9)
      DD = -1.0
C Loop over the symmetry operators.
      DO 5 II = 1,NSYMM
        NS = II
        CALL ZMOVE (RSTORE(ITOT-(II*16)),SYMM,16)
        DO 7 K = 1,3
          X2(K) = SYMM(K,1)*X1(1) + SYMM(K,2)*X1(2) + SYMM(K,3)*X1(3)
     c  + SYMM(K,4)
7       CONTINUE
        DO 10 K = 1,3
20        CONTINUE
          DIST = (X(K)-X2(K))*D000(K)
          IF (DIST.LE.C) THEN
            X2(K) = X2(K) - 1.0
            GOTO 20
          ENDIF
          X2(K) = X2(K) + 1.0
          DIST = (X(K)-X2(K))*D000(K)
          IF ((DIST.GE.-C).AND.(DIST.LE.C)) THEN
C FOUND DISTANCE MOVE TO NEXT  AXIS.
            GOTO 10
          ELSE
C DISTANCE NOT FOUND. DO NEXT SYMMETRY OPERATOR.
            GOTO 5
          ENDIF
10      CONTINUE
C NOW CALCULATE THE ACTUAL DISTANCE.
        DO 40 K = 1,3
         DX(K) = X2(K) - X(K)
40      CONTINUE
        CALL ZMATV (ORTH,DX,DX1)
        DIST = DX1(1)**2 + DX1(2)**2 + DX1(3)**2
        IF (DIST.LT.C**2) THEN
C YES WE HAVE A CONNECTION.
          CALL ZMOVE (X2,X1,3)
          LGNDST = 1
          RETURN                         
        ENDIF
        IF (DIST.LT.DD) THEN
          DD = DIST
          ND = NS
          CALL ZMOVE(X2,XD,3)
        ENDIF
C NO CONNECTION - GET NEXT SYMMETRY OPERATOR.
5     CONTINUE
      LGNDST = 0
      RETURN
      END

CODE FOR ZRING
      SUBROUTINE ZRING(IATNO)
C This subroutine draws the filled ring representation.
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

C FIRST WE HAVE TO WORK OUT THE ATOMS IN THE RING
      INTEGER IX(50),IY(50)
      INTEGER IPOS
      INTEGER IAT
      LOGICAL LFOUND
      IPOS = IRLAST
      RSTORE(IRLAST) = IATNO
      IAT = IATNO
      ZPOS = RSTORE(IATNO+IXYZO+2)
10    CONTINUE
C GET THE CONNECTIVITY
      LFOUND = .FALSE.
      NBNDST = NINT(RSTORE(IAT+IBOND))
      NBONDS = NINT(RSTORE(IAT+IBOND+1))
      DO 20 I = NBNDST , NBNDST - (NBONDS-1)*2 , -2
        J = NINT(RSTORE(I))
        IF (NINT(RSTORE(J)).NE.6) GOTO 20
C DO WE HAVE THIS ATOM ALREADY?
        KKK = 0
        DO 30 K = IRLAST , IPOS
          IF (NINT(RSTORE(K)).EQ.J) KKK = 1
30      CONTINUE
        IF (KKK.EQ.0) THEN
C STORE THE ATOM
C CHECK THE ATOMS Z COORDINATE
          IF (RSTORE(J+IXYZO+2).LT.ZPOS) RETURN
          IPOS = IPOS + 1
          RSTORE(IPOS) = J
          IAT = J
          LFOUND = .TRUE.
          GOTO 40
        ENDIF
20    CONTINUE
40    CONTINUE
C NOTE THAT WE ARE ONLY GOING TO STORE ONE NEW ATOM SO THAT WE MOVE
C AROUND THE RING
      IF (LFOUND) GOTO 10
C NOW BUILD UP THE POLYHEDRON
      DO 50 I = 1 , IPOS-IRLAST+1
        J = NINT(RSTORE(I+IRLAST-1))
        IX(I) =  NINT((RSTORE(J+IXYZO)-XCP)*SCALE)
        IY(I) = NINT((RSTORE(J+IXYZO+1)-YCP)*SCALE)
50    CONTINUE
      IX(IPOS-IRLAST+2) = IX(1)
      IY(IPOS-IRLAST+2) = IY(1)
C DRAW THE POLYGON
      ICOL = NINT(RSTORE(IATNO+IATTYP+1))
      CALL ZDRLIN (2,IX,IY,IPOS-IRLAST+2,ICOL,0)
      RETURN
      END

CODE FOR ZMNCOM [ COMMUNICATION ]
C THIS ROUTINE CREATES THE STRING THAT WILL BE USED TO COMMUNICATE WITH
C THE MAIN PROGRAM.
      SUBROUTINE ZMNCOM(CTEXT,ITYPE)
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      INTEGER IX1,IY1,IX2,IY2
      INTEGER ERROR
      CHARACTER*(ICLEN) CDUMP
      CHARACTER*(ICLEN) CTEXT
C ITYPE = 0 NO ARGUMENTS (PROCESS)
C ITYPE = 1 ARGUMENTS (DON'T PROCESS)
C ITYPE = -1 SECOND CLICK ON ARGUMENT COMMAND (PROCESS).
C ITYPE = 3 VIEW
       IF (ITYPE.EQ.3) THEN
         CALL ZCOMDO
         CALL ZABAND(2)
         LINE(ILINE)(1:4) = 'VIEW'
         IEND = 0
         CALL ZCANAL
         CALL ZCANAL
         CALL ZCOMDO
         CALL ZABAND(2)
         CALL ZRETST(IBUFF)
         IX1 = 0
         IY1 = 0
         IX2 = 2*XCEN - 1
         IY2 = 2*YCEN - 1
         CALL ZGTSCN(IX1,IY1,IX2,IY2,IBUFF)
         CALL ZABAND(2)
         CALL ZMNRED(1)
         RETURN
       ENDIF
        IF (ITYPE.EQ.-1) THEN
        IX1 = 0
        IY1 = 0
        CALL ZRTSBL(IX1,IY1,IBUFF,0,ERROR)
        CALL ZCOMDO
        CALL ZABAND(2)
        IF (ICAMER.EQ.-1) RETURN
C RESET FLAGS
C ALSO LOOP ALONG IMOLD TO RESET FLAGS
          DO 40 I = 1 , 10
            IF (IMOLD(I).GT.1) THEN
              RSTORE(IMOLD(I)+3) = ABS(RSTORE(IMOLD(I)+3))
            ENDIF
40        CONTINUE
        RSTORE(IMENU(IMENVT,3)+3) = ABS(RSTORE(IMENU(IMENVT,3)+3))
        CALL ZRETST(IBUFF)
        IX1 = 0
        IY1 = 0
        IX2 = 2*XCEN - 1
        IY2 = 2*YCEN - 1
        CALL ZGTSCN(IX1,IY1,IX2,IY2,IBUFF)
        CALL ZABAND(2)
        RETURN
      ENDIF
C CHECK THAT THE OLD PATHS MEET PROPERLY
      IX = 0
      DO 5 I = 2 , IMENVT-1
C JUMP OUT IF WE HAVE REACHED THE END OF THE OLD PATH
C BRANCHING ONLY ALLOWED AT THE CURRENT MENU LEVEL.
        IF (IMOLD(I).EQ.0) GOTO 7
        IF (IMOLD(I).NE.IMENU(I,3)) IX = 1
5     CONTINUE
7     CONTINUE
      IF ((IX.EQ.0).AND.(IMOLD(IMENVT).NE.IMENU(IMENVT,3)).AND.
     c  (IMOLD(IMENVT).NE.0)) IX = 2
C IF WE HAVE MOVED TO ANOTHER COMMAND - RESET FLAGS FOR THE LAST ONE.
      IF (IX.EQ.2) THEN
        RSTORE(IMOLD(IMENVT)+3) = ABS(RSTORE(IMOLD(IMENVT)+3))
      ENDIF
C WE NEED TO LOOP DOWN THE CURRENT MENU 'PATH'
      IL = 1
      DO 10 I = 2 , IMENVT-1
        IF (NINT(RSTORE(IMENU(I,3)+3)).EQ.-3) IL = I
10    CONTINUE
C THE -3 WILL ONLY OCCUR IF A PREVIOUS MENU ITEM HAS HAD INFO ENTERED
C FOR IT.
C SEND THE INFO FROM IL DOWN TO THE CURRENT VALUE OF IMENVT-1.
      IF (IX.EQ.1) IL = 1
      IF (IX.EQ.2) IL = IMENVT-1
      IIC = 1
      ILINE = ILINE + 1
      IF (ILINE.GE.8) ILINE=1
      DO 20 I = IL+1 , IMENVT
        N = NINT(RSTORE(IMENU(I,3)))
C DO NOT OUTPUT A DUMMY NAME
        IF (NINT(RSTORE(IMENU(I,3)+3)).EQ.-2) GOTO 20
        IF (IIC.EQ.1) THEN
          LINE(ILINE) = CSTORE(N)//CSTORE(N+1)
        ELSE
          CDUMP = LINE(ILINE)(1:IIC)//CSTORE(N)//CSTORE(N+1)
          LINE(ILINE) = CDUMP
        ENDIF
        IIC = IIC + 2*ILEN
20    CONTINUE
C NOW WE NEED TO PASS THIS INFO TO CAMERON
      IEND = 0
      CALL ZCANAL
C SEND DOWN THE ARGUMENTS IF THEY EXIST.
      IF (ITYPE.EQ.1) THEN
        LINE(ILINE+1) = CTEXT
        ILINE = ILINE + 1
        IEND = 0
        CALL ZCANAL
        IF (IPROC.EQ.3) THEN
C FORCE STORAGE OF INFO
          INFCMD(ICINPS) = IC*100 + IN*10 + IR
          ICINPS = ICINPS + 1
          ISTORE = 1
        ENDIF
      ENDIF
      IF (ITYPE.EQ.0) THEN
C NEED TO FORCE PROCESSING OF THE COMMAND
        IF (IPROC.EQ.3) THEN
          CALL ZCANAL
        ENDIF
        IF (IBEG.NE.-1) THEN
          IEND = 0
          CALL ZCANAL
        ENDIF
        IF (IPROC.EQ.3) THEN
C FORCE STORAGE OF INFO
          INFCMD(ICINPS) = IC*100 + IN*10 + IR
          ICINPS = ICINPS + 1
          ISTORE = 1
        ENDIF
        IX1 = 0
        IY1 = 0
        CALL ZRTSBL(IX1,IY1,IBUFF,0,ERROR)
        CALL ZCOMDO
        CALL ZABAND(2)
        IF (ICAMER.EQ.-1) RETURN
C RESET THE FLAGS
        CALL ZABAND(2)
C ALSO LOOP ALONG IMOLD TO RESET FLAGS
          DO 50 I = 1 , 10
            IF (IMOLD(I).GT.1) THEN
              RSTORE(IMOLD(I)+3) = ABS(RSTORE(IMOLD(I)+3))
            ENDIF
50        CONTINUE
        CALL ZRETST(IBUFF)
        IX1 = 0
        IY1 = 0
        IX2 = 2*XCEN - 1
        IY2 = 2*YCEN - 1
        CALL ZGTSCN(IX1,IY1,IX2,IY2,IBUFF)
        RETURN
      ENDIF
      IF ((IPROC.EQ.0).OR.(IPROC.EQ.2)) THEN
C THERE IS AN ERROR - ABANDON
C ALSO LOOP ALONG IMOLD TO RESET FLAGS
          DO 30 I = 1 , 10
            IF (IMOLD(I).GT.1) THEN
              RSTORE(IMOLD(I)+3) = ABS(RSTORE(IMOLD(I)+3))
            ENDIF
30        CONTINUE
          RSTORE(IMENU(IMENVT,3)+3) = ABS(RSTORE(IMENU(IMENVT,3)+3))
          CALL ZABAND(2)
        RETURN
      ENDIF
      RETURN
      END

CODE FOR ZZMNINI [ DO MENU - NOW A DUMMY - SEE BUTTON 1996 ]
      SUBROUTINE ZZMNINI
C THIS ROUTINE SETS UP THE MENU CONTROL DATA AND ALSO THE NAMES OF
C THE COMMANDS - SUB-COMMANDS IN THE RELEVANT MENUS.
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

C      INTEGER IMENU (10,3)
C IMENU IS THE CONTROLLING ARRAY FOR GENERATING THE MENU LISTS.
      ISMEN = IRLAST
      CALL ZZEROI (IMENU,30)
      IMST = ISMEN
      IMFIN = ISMEN
      ISTEP = 4
      IMEN = 1
C SET UP THE LIST FOR THE TOP MENU BAR.
      DO 10 I = ISHEAD , ISHEAD + (IHNUM-1)*IHMAX , IHMAX
        RSTORE(IMFIN) = NINT (RSTORE (I))
        IMFIN = IMFIN + 4
10    CONTINUE
      IMENU ( IMEN , 1) = IMST
      IMENU ( IMEN , 2 ) = IMFIN - 4
      IMENU ( IMEN , 3) = IMST
      IMST = IMFIN
      IMEN = 2
      IMENU (IMEN,1 ) = IMST
      IMENU (IMEN,3 ) = IMST
C SET UP THE DATA FOR THE TOP MENU BAR
      DO 20 I = ISHEAD, ISHEAD + (IHNUM - 1)*IHMAX , IHMAX
C GET THE NUMBER OF COMMANDS IN THIS GROUP
      IS = IMENU (IMEN-1,1)
C      IP = IMENU (IMEN-1,3)
        RSTORE (IS + (I-ISHEAD)*ISTEP/IHMAX + 1 ) = IMST
        IH = NINT ( RSTORE ( I + 1 ))
        DO 30 L = 2 , IH + 1
C GET THE NUMBER OF THE COMMAND GROUP
          IGCOM = NINT (RSTORE (I+L) )
C LOOK FOR THIS GROUP IN THE MAIN LIST
          DO 40 J = ICOM , ISHEAD-1 , ISRCOM
            IF (ABS(NINT(RSTORE(J))).EQ.IGCOM) GOTO 50
40        CONTINUE
50        CONTINUE
C NOW SEARCH TO FIND ALL HEADER COMMANDS IN THIS LIST.
          DO 60 K = J , J+30*ISRCOM , ISRCOM
            IF (K.GE.ISHEAD) GOTO 61
            ID = ABS(NINT ( RSTORE ( K ) ))
            IF (ID/100.EQ.IGCOM/100) THEN
C WE HAVE A COMMAND IN THE SAME GROUP - IS IT A HEADER COMMAND?
              IF (NINT(RSTORE(K+1)).EQ.0) THEN
C YES IT IS - STORE IT IN THE ARRAY
                IMNPOS = ICOM + ( K - ICOM )*ISCOM/ISRCOM
                RSTORE(IMFIN) = IMNPOS
                IMFIN = IMFIN + ISTEP
              ENDIF
            ENDIF
60        CONTINUE
61        CONTINUE
30      CONTINUE
        RSTORE ( IS + (I-ISHEAD)*ISTEP/IHMAX + 2 ) = (IMFIN-IMST)/ISTEP
        RSTORE ( IS + (I-ISHEAD)*ISTEP/IHMAX + 3 ) = 0
        IMST = IMFIN
20    CONTINUE
C NOW WE HAVE SET UP THE LIST - WE NEED TO GENERATE THE REMAINING
C MENUS
      IMENU (IMEN , 2) = IMFIN - 4
C      IMENU ( IMEN , 3) = IMST
70    CONTINUE
C LOOP OVER THE LEVEL OF MENU THAT WE ARE CURRENTLY ON.
      IFIND = 0
      IMENU (IMEN+1,1) = IMST
      IMENU (IMEN+1, 3 ) = IMST
      DO 80 I = IMENU (IMEN,1) , IMENU (IMEN,2) , ISTEP
C CHECK THAT WE HAVE A 'REAL' COMMAND
        IF (NINT(RSTORE(I+3)).EQ.2) GOTO 80
C GET THE COMMAND NUMBER
        ICP = ICOM + (NINT(RSTORE(I))-ICOM)*ISRCOM/ISCOM
        ICNO = NINT (RSTORE (ICP))
C GET THE SUB-COMMAND INFO
        ICSUB = NINT (RSTORE (ICP + 5) )
C WE CAN HAVE FOLLOWING INFO
        ISS = RSTORE(ICP+2)+RSTORE(ICP+3)+RSTORE(ICP+4)
        IF ((ABS(ICSUB).LT.10).AND.(ISS.GT.0)) RSTORE(I+3) = 1.0
        IF ((MOD(ABS(ICSUB),10).EQ.4).OR.(ICNO.LT.0)) THEN
C WE MAY HAVE TO ADD IN AN ADDITIONAL MENU ITEM FOR THE CHARACTER INPUT.
          IF (ABS(ICSUB).GT.9) THEN
C GET THE CHARACTER EQUIVALENT
            IF (ABS(ICSUB).GT.9) N = ABS(ICSUB)/10
C            IF (ICNO.LT.0) N = ICSUB
            IMNPOS = IMCHAR + (N-1)*2
            RSTORE(IMFIN) = IMNPOS
C SET FLAG FOR INFO CREATED
C            IF (ICNO.LT.0) THEN
C              RSTORE(IMFIN+3) = 3.0
C            ELSE
              RSTORE(IMFIN+3) = 2.0
C            ENDIF
            IMFIN = IMFIN + ISTEP
            IFIND = 1
          ELSE
            ISS = RSTORE(ICP+2)+RSTORE(ICP+3)+RSTORE(ICP+4)
C SET THE COMMAND SO THAT WE HAVE INFO BEFORE THE SUB-COMMAND.
            IF (ISS.GT.0.0) RSTORE(I+3)=3.0
          ENDIF
C WE HAVE A SUB-COMMAND POSSIBLE.
C LOOP OVER THE SUB-COMMANDS
          IST = ICP - 20*ISRCOM
          IF (IST.LT.ICOM) IST=ICOM
          IFN = ICP + 20*ISRCOM
          DO 90 J = IST , IFN , ISRCOM
C GET THE NUMBER OF THE COMMAND
            ICSNO = ABS(NINT (RSTORE(J)))
            IF (ICSNO/100.NE.ABS(ICNO/100)) GOTO 90
C MUST BE OF THE SAME GROUP
C GET THE PREVIOUS COMMAND NUMBER
            ISPR = NINT (RSTORE (J+1))
            IF (ICSUB.GT.0) THEN
C 4 type sub-command n, -n and 1 valid.
              IF (ISPR.EQ.1) THEN
C THIS IS 'SPECIAL' - NEED TO GET PREVIOUS NUMBER FOR ABOVE COMMAND.
                IF (IMEN.GT.3) GOTO 90
                ICPR = NINT (RSTORE (ICP+1))
                IF (ABS(ICPR).GT.1) THEN
C WE HAVE A n or -n COMMAND AT LEVEL 2 PUT 1'S HERE
                  IF (IMEN.EQ.3) THEN
C SUB-COMMAND IS VALID
                    IMNPOS = ICOM + (J-ICOM)*ISCOM/ISRCOM
                    RSTORE(IMFIN) = IMNPOS
                    IMFIN = IMFIN + ISTEP
                    IFIND = 1
                  ENDIF
                ELSE
                  IF (IMEN.EQ.2) THEN
C SUB-COMMAND IS VALID
                    IMNPOS = ICOM + (J-ICOM)*ISCOM/ISRCOM
                    RSTORE(IMFIN) = IMNPOS
                    IMFIN = IMFIN + ISTEP
                    IFIND = 1
                  ENDIF
                ENDIF
              ELSE IF (ABS(ISPR).EQ.ABS(ICNO)) THEN
C SUB-COMMAND IS VALID
                IMNPOS = ICOM + (J-ICOM)*ISCOM/ISRCOM
                RSTORE(IMFIN) = IMNPOS
                IMFIN = IMFIN + ISTEP
                IFIND = 1
              ENDIF
            ELSE
C -4 type sub-command n and -n are valid
              IF (ABS(ISPR).EQ.ABS(ICNO)) THEN
                IMNPOS = ICOM + (J-ICOM)*ISCOM/ISRCOM
                RSTORE(IMFIN) = IMNPOS
                IMFIN = IMFIN + ISTEP
                IFIND = 1
              ENDIF
            ENDIF
90        CONTINUE
C IF ANY COMMANDS HAVE BEEN FOUND - STORE THE INFO
          IF (IMFIN.NE.IMST) THEN
            RSTORE(I+1) = IMST
            RSTORE(I+2) = (IMFIN - IMST) / ISTEP
            IMST = IMFIN
          ENDIF
        ENDIF
80    CONTINUE
C IFIND WILL HAVE BEEN SET IF WE HAVE FOUND A SUB-COMMAND MENU
      IF (IFIND.EQ.1) THEN
        IMEN = IMEN + 1
        IMENU (IMEN , 2 ) = IMFIN - 4
C        IMENU (IMEN , 3 ) = IMENU (IMEN,1)
        GOTO 70
      ENDIF
      IRLAST = IMFIN
C      CALL ZMENU
      RETURN
      END
 
CODE FOR ZDOWN
      SUBROUTINE ZDOWN
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

C FIRST OF ALL - ARE WE WITHIN A VERTICAL MENU?
      IF (IMENVT.EQ.1) THEN
C NO WE AREN'T
        IMENX(2) = IMPOS(IMNTOP)
        IMENY(2) = 20
        IMENVT = 2
        CALL ZMNVET(1)
        RETURN
      ENDIF
C OTHERWISE - WE MUST BE ALREADY IN A MENU - DO DOWN WITHIN THIS.
      N = IMENU ( IMENVT,3 )
      M = N + 4
C      IVERT(IMENVT) = IVERT(IMENVT) + 1
      IMENU (IMENVT,3) = IMENU (IMENVT,3) + 4
      IF (M.GT.IMENU(IMENVT,2)) THEN
        M = IMENU(IMENVT,2)
C        IVERT(IMENVT) = IVITEM
        IMENU(IMENVT,3) = IMENU(IMENVT,2)
      ENDIF
      CALL ZMNVHI (N , M)
      RETURN
      END
 
CODE FOR ZESCP
C ESCAPE KEY PRESSED
      SUBROUTINE ZESCP
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      IMENVT = 1
      CALL ZMNRED(1)
      RETURN
      END

CODE FOR IBCHCK
      INTEGER FUNCTION IBCHCK (IMX,IMY)
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

C^^^      INCLUDE 'BUTTON.INC'
      IBCHCK = -1
C THIS CHECKS THE BUTTONS TO SEE WHETHER ONE HAS BEEN ACTIVATED
      DO 10 I = 1 , IBUTNO
        IF (IMX.LT.IBUTTS(1,I)) GOTO 10
        IF (IMY.LT.IBUTTS(2,I)) GOTO 10
        IF (IMX.GT.IBUTTS(3,I)) GOTO 10
        IF (IMY.GT.IBUTTS(4,I)) GOTO 10
        IBCHCK = I
        RETURN
10    CONTINUE
      RETURN
      END

CODE FOR ZRETST
      SUBROUTINE ZRETST (IBUFF)
      INTEGER IBUFF
C      CALL RETURN_STORAGE@(IBUFF)
#if defined(DOS) 
      call release_screen_block@
#endif
      RETURN
      END
 
CODE FOR ZGTSCN
      SUBROUTINE ZGTSCN (IX1,IY1,IX2,IY2,IBUFF)
#if defined(DOS) 
      INCLUDE 'CAMWIN.INC'
#endif
      INTEGER IX1,IY1,IX2,IY2
#if defined(DOS) 
      INTEGER*2 IXX1,IYY1,IXX2,IYY2
#endif
      INTEGER IBUFF
#if defined(DOS) 
      ixx1 = nint(float(ix1)*scale_X)
      iyy1 = nint(float(iy1)*scale_Y)
      ixx2 = nint(float(ix2)*scale_X)
      iyy2 = nint(float(iy2)*scale_Y)
      CALL GET_SCREEN_BLOCK@(IXX1,IYY1,IXX2,IYY2,IBUFF)
#endif
      RETURN
      END

CODE FOR ZMNRED
      SUBROUTINE ZMNRED(ITYPE)
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      INTEGER IX,IY
      INTEGER ERROR,IFUNCT
C ITYPE = 1
C THIS REDRAWS THE MENUS AT THEIR CURRENT STAGES
C ITYPE = 2
C THIS REDRAWS THE PREVIOUS MENU ONLY
C      IF (ITYPE.EQ.2) THEN
C        IF (IMENVT.EQ.1) THEN
C WORK OUT THE START OF THE MENU
C          IF (IMNTOP.EQ.1) THEN
C            A = IMENU(1,3)
C            B = IMENU(1,3) + (NITEM-1)*4
C          ELSE IF (IMNTOP.EQ.NITEM) THEN
C            B = IMENU(1,3)
C            A = IMENU(1,3) - ( NITEM-1)*4
C          ELSE
C            A = IMENU(1,3) - (IMNTOP-1)*4
C            B = IMENU(1,3) + (NITEM-IMNTOP)*4
C          ENDIF
C          CALL ZMNTOP (A,B)
C          CALL ZMNHI (IMENU(1,3),IMENU(1,3))
C        ELSE
C          CALL ZMNVET(2)
C          RETURN
C        ENDIF
C      ENDIF
C      IF (ITYPE.EQ.1) THEN
C         CALL VGA@
C      ENDIF
      IFUNCT = 0
      IX = 0
      IY = 0
      CALL ZRTSBL(IX,IY,IBUFF,IFUNCT,ERROR)
      IVMEN = IMENVT
      DO 10 IMENVT = 1 , IVMEN
      IF (IMENVT.EQ.1) THEN
C WORK OUT THE START OF THE MENU
        IF (IMNTOP.EQ.1) THEN
          A = IMENU(1,3)
          B = IMENU(1,3) + (NITEM-1)*4
        ELSE IF (IMNTOP.EQ.NITEM) THEN
          B = IMENU(1,3)
          A = IMENU(1,3) - ( NITEM-1)*4
        ELSE
          A = IMENU(1,3) - (IMNTOP-1)*4
          B = IMENU(1,3) + (NITEM-IMNTOP)*4
        ENDIF
        CALL ZMNTOP (A,B)
        CALL ZMNHI (IMENU(1,3),IMENU(1,3))
      ELSE
        CALL ZMNVET(2)
      ENDIF
10    CONTINUE
      IMENVT = IVMEN
      RETURN
      END

CODE FOR ZMNVET [ VERTICAL MENU ]
      SUBROUTINE ZMNVET (ITYPE)
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      INTEGER IXBOX(5), IYBOX(5),ICOL,IHPOS,IVPOS
      CHARACTER*12 CNAME
C ITYPE = 1 CREATE MENU
C ITYPE = -1 DELETE MENU
C ITYPE = 2 REDRAW MENU - DO NOT RESET IVERT VALUES
C FIRST SET UP THE MENU LISTS
      IF (ITYPE.EQ.1) THEN
        II = NINT ( RSTORE ( IMENU ( IMENVT-1,3) + 1) )
C GET START POSITION
        IMENU(IMENVT,1) = II
        IMENU(IMENVT,3) = II
C GET NO OF ITEMS
        II = NINT ( RSTORE ( IMENU ( IMENVT-1,3) + 2) )
        IMENU(IMENVT,2) = IMENU(IMENVT,1) + (II-1)*4
      ENDIF
C CHECK FOR BLANKING OFF OF MENUS
C THIS HAS BEEN REPLACED BY ADDING AN * AT THE END OF COMMANDS NEEDING
C INPUT
C        IBLANK = 0
C      DO 5 I = IMENVT-1 , 2 , -1
C        IJ = NINT(RSTORE ( IMENU (I,3) + 3) )
C        IF (IJ.EQ.3) IBLANK = 1
C5     CONTINUE
C FIRST CALCULATE THE BOX SIZE
      IVITEM = NINT (RSTORE ( IMENU (IMENVT-1,3 ) + 2 ) )
      ISBOX = 15 * IVITEM
C LOOP TO SEE IF THERE ARE ANY FOLLOWING COMMANDS.
      IP = IMENU (IMENVT-1,3 )
      IST = NINT ( RSTORE (IP + 1 ))
      IFN = IST + NINT (RSTORE (IP+2))*4
      INFOLL = 0
      DO 10 I = IST , IFN-1 , 4
        IF (NINT(RSTORE(I+2)).NE.0) INFOLL = 1
10    CONTINUE
C THE BOX WIDTH IS IMENWD
C NOW CALCULATE THE CORNER POSITIONS
      IF (INFOLL.EQ.0) THEN
        IXBOX(1) = IMENX(IMENVT) - 2
        IXBOX(2) = IMENX(IMENVT) + IMENWD - 4
      ELSE
        IF (IMNTOP.GT.NITEM/2) THEN
C OTHER MENUS WILL GO TO THE LEFT
          IXBOX(1) = IMENX(IMENVT) - 2 - 10
          IXBOX(2) = IMENX(IMENVT) + IMENWD - 4
        ELSE
          IXBOX(1) = IMENX(IMENVT) - 2
          IXBOX(2) = IMENX(IMENVT) + IMENWD - 4 + 10
        ENDIF
      ENDIF
      IYBOX(1) = IMENY(IMENVT)
      IYBOX(2) = IMENY(IMENVT)
      IXBOX(3) = IXBOX(2)
      IYBOX(3) = IMENY(IMENVT) + ISBOX
      IXBOX(4) = IXBOX(1)
      IYBOX(4) = IYBOX(3)
      IXBOX(5) = IXBOX(1)
      IYBOX(5) = IYBOX(1)
C FILL IT IN
C      CALL ZCPLGN(IXBOX,IYBOX,5,HANDLE,ERROR)
      IF (ITYPE.EQ.-1) THEN
        ICOL = 0
        CALL ZPOLGN (IXBOX,IYBOX,5,ICOL)
C        CALL ZFPLGN(HANDLE,ICOL,ERROR)
        RETURN
      ENDIF
      ICOL = 1
C      CALL ZFPLGN(HANDLE,ICOL,ERROR)
C      CALL ZDPLGN(HANDLE,ERROR)
      CALL ZPOLGN (IXBOX,IYBOX,5,ICOL)
      ICOL = 7
      CALL ZPLINE(IXBOX,IYBOX,5,ICOL)
C NOW WE NEED TO ADD IN THE MENU ITEMS
C GET THE NAME
      DO 20 I = IST , IFN-1 , 4
        CNAME = ' '//CSTORE(NINT(RSTORE(I)))//CSTORE(NINT(RSTORE(I)+1))
C CHECK IF THIS NEEDS ARGUMENTS
        IF (NINT(RSTORE(I+3)).GT.0) CNAME(1:1)='*'
C GET THE POSITION
        IVPOS = IMENY(IMENVT) + (I-IST)* 15/4
        IF ((INFOLL.EQ.1).AND.(IMNTOP.LE.NITEM/2)) THEN
          IHPOS = IMENX(IMENVT)
        ELSE IF (INFOLL.EQ.0) THEN
          IHPOS = IMENX(IMENVT)
        ELSE
          IHPOS = IMENX(IMENVT) + 10
        ENDIF
        IH = IHPOS
        IV = IVPOS
C        IF (IBLANK.EQ.0) THEN
          ICOL = 15
          CALL ZDTEXT(CNAME,IH,IV,ICOL)
C        ELSE
C          ICOL = 8
C          CALL ZDTEXT(CNAME,IH,IV,ICOL)
C        ENDIF
        IF (RSTORE(I+2).GT.0.0) THEN
C          IF (IBLANK.EQ.1) THEN
C            CALL ZMNARV (IHPOS,IVPOS,2)
C          ELSE IF (NINT(RSTORE(I+3)).EQ.3) THEN
C            CALL ZMNARV (IHPOS,IVPOS,2)
C          ELSE
            CALL ZMNARV (IHPOS,IVPOS,1)
C          ENDIF
        ENDIF
20    CONTINUE
      IF (ITYPE.NE.2) THEN
         IMENU (IMENVT,3) = IMENU (IMENVT,1)
      ENDIF
      N = IMENU(IMENVT,3)
C      IF (IBLANK.EQ.0) THEN
        CALL ZMNVHI (N,N)
C      ENDIF
      RETURN
      END

CODE FOR ZMNARR [ DO ARROW ]
      SUBROUTINE ZMNARR
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      INTEGER IX1(4),IY1(4),IX2(4),IX,IY,ICOL,IXX,IYY
      DATA IX1 /0 , 5 , 5 , 0/
      DATA IY1 /10 , 5 , 15 , 10 /
      DATA IX2 /640 , 635 , 635 , 640 /
      IF ((IMENAR.EQ.1).OR.(IMENAR.EQ.3)) THEN
C LEFT ARROW
        IX = 0
        IXX = 20
        IY = 10
        IYY = 10
        ICOL = 14
        CALL ZDLINE(IX,IY,IXX,IYY,ICOL)
C        CALL ZCPLGN(IX1,IY1,4,HANDLE,ERROR)
C        CALL ZFPLGN(HANDLE,ICOL,ERROR)
C        CALL ZDPLGN(HANDLE,ERROR)
        CALL ZPOLGN (IX1,IY1,4,ICOL)
      ENDIF
      IF (IMENAR.GE.2) THEN
C RIGHT ARROW
        IX = 640
        IY = 10
        IXX = 620
        IYY = 10
        ICOL = 14
        CALL ZDLINE(IX,IY,IXX,IYY,ICOL)
C        CALL ZCPLGN(IX2,IY1,4,HANDLE,ERROR)
C        CALL ZFPLGN(HANDLE,ICOL,ERROR)
C        CALL ZDPLGN(HANDLE,ERROR)
        CALL ZPOLGN (IX2,IY1,4,ICOL)
      ENDIF
      RETURN
      END

CODE FOR ZMNHI [ HIGHLIGHTING ]
      SUBROUTINE ZMNHI (N , M )
C THIS ROUTINE DRAWS A BLUE BOX AROUND THE OLD ITEM - IE REMOVES THE BOX
C AND DRAWS A RED BOX AROUND THE ONE THAT IS CURRENTLY BEING
C HIGHLIGHTED.
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      INTEGER ICOL
      CHARACTER*12 CNAME
      IWID = IMENWD / 8
      IF (IWID.EQ.12) IWID = 12
      J = N
      IF (N.LT.M) THEN
        IT = IMNTOP - 1
      ELSE IF (N.EQ.M) THEN
        IT = IMNTOP
      ELSE
        IT = IMNTOP + 1
      ENDIF
      IF (IT.EQ.0) IT=IMNTOP
      IF (IT.GT.NITEM) IT=NITEM
10    CONTINUE
C THIS DRAWS THE HIGHLIGHTED WORD IN RED AND THE OLD WORD IN WHITE.
C      JJ = ( J - IMENU(1,1) ) / 4 + 1
      IX = IMPOS (IT)
      IY = 2
      CNAME = CSTORE (NINT(RSTORE(J)))//CSTORE(NINT(RSTORE(J)+1))
      IF ((J.EQ.N).AND.(N.NE.M)) THEN
        ICOL = 15
        CALL ZDTEXT(CNAME(1:IWID),IX,IY,ICOL)
      ELSE
        ICOL = 4
        CALL ZDTEXT(CNAME(1:IWID),IX,IY,ICOL)
      ENDIF
      IF ((J.EQ.N).AND.(N.NE.M)) THEN
        J = M
        IT = IMNTOP
        GOTO 10
      ENDIF
      RETURN
      END


CODE FOR ZMNTOP [ MENU TOP BAR ]
      SUBROUTINE ZMNTOP(A,B)
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

C WRITE OUT THE TOP BAR
      CHARACTER*80 CL
      CHARACTER*80 CBLANK
      CHARACTER*12 CNAME
      INTEGER IXBOX(5),IYBOX(5),IX1,IY1,IX2,IY2,ICOL
      DO 5 I = 1 , 80
        CBLANK(I:I) = ' '
5     CONTINUE
C HOW MUCH SPACE ARE WE ALLOCATED PER ITEM?
      IMENWD = 600 / NITEM
C WORK OUT HOW MUCH FRONT SPACE THERE IS
      ISATT = IMENWD/8
      IF (ISATT.GT.12) ISATT = 12
      IFRONT = 20 + ( 600 - IMENWD * NITEM ) / 2
C NOW SET UP THE STRING
      IXBOX(1) = 0
      IYBOX(1) = 0
      IXBOX(2) = 639
      IYBOX(2) = 0
      IXBOX(3) = IXBOX(2)
      IYBOX(3) = 20
      IXBOX(4) = IXBOX(1)
      IYBOX(4) = IYBOX(3)
      IXBOX(5) = IXBOX(1)
      IYBOX(5) = IYBOX(1)
      IX1 = 0
      IY1 = 0
      IX2 = 639
      IY2 = 20
      ICOL = 1
      CALL ZCLRA(IX1,IY1,IX2,IY2,ICOL)
      ICOL = 7
      CALL ZPLINE(IXBOX,IYBOX,5,ICOL)
      CL = CBLANK
      IMNPOS = IFRONT
      CALL ZMNARR
C LOOP OVER THE INFO
      K = 0
C       DO 10 I = IMENU ( 1, 3) , IMENU (1,3)+(NITEM-1)*4 , 4
      DO 10 I = A , B , 4
      K = K + 1
C      DO 10 I = 1 , NITEM
C GET THE NAME
C        CNAME = CSTORE((ISTART-1)*2+1+(I-1)*2)//
C     c  CSTORE((ISTART-1)*2+1+(I-1)*2+1)
        CNAME = CSTORE(NINT(RSTORE(I)))//CSTORE(NINT(RSTORE(I)+1))
        IY = 2
        ICOL = 15
        CALL ZDTEXT(CNAME(1:ISATT),IMNPOS,IY,ICOL)
        IMPOS(K) = IMNPOS
        IMNPOS = IMNPOS + IMENWD
10    CONTINUE
      RETURN
      END


CODE FOR ZMNARV [ VERTICAL MENU ARROWS ]
      SUBROUTINE ZMNARV ( IHPOS , IVPOS ,ITYPE)
      INTEGER IHPOS , IVPOS , IX(4), IY(4), ICOL,ID
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      IF (ITYPE.EQ.2) THEN
        ICOL = 8
      ELSE
        ICOL = 14
      ENDIF
C WORK OUT THE ARROW COORDS
      IF (IMNTOP.LE.NITEM/2) THEN
C LEFT ARROW
        IX(1) = IHPOS + IMENWD -5
        IX(2) = IHPOS + IMENWD
      ELSE
C RIGHT ARROW
        IX(1) = IHPOS -15
        IX(2) = IHPOS - 20
      ENDIF
      IX(3) = IX(1)
      IX(4) = IX(1)
      IY(1) = IVPOS
      IY(2) = IVPOS + 5
      IY(3) = IVPOS + 10
      IY(4) = IY(1)
C DRAW THE ARROW
C      CALL ZCPLGN(IX,IY,4,HANDLE,ERROR)
C      CALL ZFPLGN(HANDLE,ICOL,ERROR)
C      CALL ZDPLGN(HANDLE,ERROR)
      CALL ZPOLGN (IX,IY,4,ICOL)
      ID = 20
      IF (IMNTOP.LE.NITEM/2) THEN
C ADD IN THE LINE
        CALL ZDLINE(IX(2),IY(2),IX(2)-ID,IY(2),ICOL)
      ELSE
        CALL ZDLINE(IX(2),IY(2),IX(2)+ID,IY(2),ICOL)
      ENDIF
      RETURN
      END
 
 
CODE FOR ZMNVHI [ VERTICAL HIGHTLIGHTING ]
      SUBROUTINE ZMNVHI ( N , M )
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      CHARACTER*12 CNAME
      INTEGER ICOL
C THIS ROUTINE DRAWS THE OLD OPTION (N) IN WHITE AND THE NEW OPTION (M)
C IN RED.
C CHECK FOR BLANKING OFF OF MENUS
C        IBLANK = 0
C      DO 5 I = IMENVT-1 , 2 , -1
C        IJ = NINT(RSTORE ( IMENU (I,3) + 3) )
C        IF (IJ.EQ.3) IBLANK = 1
C5     CONTINUE
C      IF (IBLANK.EQ.1) RETURN
      J = N
      IF ((INFOLL.EQ.1).AND.(IMNTOP.LE.NITEM/2)) THEN
        IX = IMENX(IMENVT)
      ELSE IF (INFOLL.EQ.0) THEN
        IX = IMENX(IMENVT)
      ELSE
        IX = IMENX(IMENVT) + 10
      ENDIF
      IY = IMENY(IMENVT)
10    CONTINUE
C GET THE NAME
C      CNAME = CSTORE((IVST-1)*2+(J-1)*2+1)//
C     c CSTORE((IVST-1)*2+(J-1)*2+2)
      JJ = NINT ( RSTORE ( J ) )
      CNAME = ' '//CSTORE(JJ)//CSTORE(JJ+1)
C ADD A STAR FOR FOLLOWING ASTERIX
      IF (RSTORE(J+3).GT.0) CNAME(1:1) = '*'
C GET THE POSITIONS
      IVPOS = IY + (J-IMENU(IMENVT,1))*15/4
      IF ((N.EQ.J).AND.(N.NE.M)) THEN
        ICOL = 15
        CALL ZDTEXT(CNAME,IX,IVPOS,ICOL)
      ELSE
        ICOL = 4
        CALL ZDTEXT(CNAME,IX,IVPOS,ICOL)
      ENDIF
      IF ((N.EQ.J).AND.(N.NE.M)) THEN
        J = M
        GOTO 10
      ENDIF
      RETURN
      END


CODE FOR ZINPUT [COMMAND INPUT]
      SUBROUTINE ZINPUT
C This routine reads the input and sends it to the XCANAL routine
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      CHARACTER*(ICLEN) CTEMP
      CHARACTER*20 CC
      CALL ZINCH(LLINE(ILINE))
C NEED TO GET THE UPPERCASE VERSION FOR ANALYSIS
      CTEMP = LLINE(ILINE)
      CALL ZUPCAS (CTEMP)
      LINE(ILINE) = CTEMP
      IF(CTEMP(1:6).EQ.'LCLICK')THEN
            READ(CTEMP(7:),*) MXPOS, MYPOS
            II=LMOUSE(CC,MXPOS,MYPOS)
            CALL XCTRIM(CC,IIILEN)
            IF(IIILEN.GT.1) THEN
#if defined(GID) 
              CALL ZMORE('^^CO SET _MAINTEXTINPUT APPEND='' '//
     1 CC(1:IIILEN) // '''',0)
#endif
#if defined(DOS) 
              CALL ZMORE('Append atom '//CC(1:IIILEN),0)
#endif
            ENDIF
            LLINE(ILINE)=' '
            CTEMP=' '
            RETURN
      ENDIF

13    CALL ZCANAL
      IF (IPROC.EQ.1) THEN
C SEND THE LINE TO THE LOG FILE
         CALL ZLOGWT(1)
C        IF (ICABAN.GT.1) THEN
C            IF (ILOG.EQ.1) THEN
C              WRITE (IFLOG,'(A)') CLOG (1:ICABAN-1)
C            ENDIF
C RESET THE FLAGS AND MOVE OVER THE REST OF THE LINE
C            IF (ICABAN.NE.ICLOG) THEN
C              CTEMP = CLOG(ICABAN:ICLOG-1)
C              CLOG (1:ICLOG-ICABAN) = CTEMP(1:ICLOG-ICABAN)
C              ICLOG = ICLOG - ICABAN + 1
C            ELSE
C              ICLOG = 1
C            ENDIF
C            ICABAN = 1
C        ENDIF
C PROCESS THE COMMANDS SO FAR
        CALL ZCOMDO
        CALL ZABAND(2)
        IF (ICAMER.EQ.-1) RETURN
      ENDIF
      IF (IPROC.EQ.2) THEN
C REMOVE THE LAST (INCOMPLETE) COMMAND.
        IF (INCOM(1).NE.INCOM(2)) THEN
          ICPOS = ICPOS - 1
          ICCPOS = ICCPOS - IC
          ICNPOS = ICNPOS - IN
          ICRPOS = ICRPOS - IR
        ENDIF
        CALL ZABAND(1)
        CALL ZCOMDO
        CALL ZABAND(2)
        IF (ICAMER.EQ.-1) RETURN
        IBEG = -1
      ENDIF
      IF (IPROC.EQ.0) THEN
C ABANDON
        ILINE = 1
        CALL ZLOGWT(0)
        CALL ZABAND(2)
        IBEG = -1
        IHEAD = 1
C RESET FLAGS FOR LOG FILE
        ICLOG = 1
        ICABAN = 1
      ENDIF
      IF ((ILINE.LT.10).AND.(IBEG.EQ.-1)) THEN
        ILINE = ILINE + 1
        IEND = 0
      ELSE IF ((ILINE.EQ.10).AND.(IBEG.EQ.-1)) THEN
        DO 30 I = 1 , 10
          DO 40 J = 1 , ICLEN
40        LINE(I)(J:J) = ' '
30      CONTINUE
        ILINE = 1
        IEND = 0
      ENDIF
      IF (IBEG.NE.-1) GOTO 13
C      GOTO 10
      RETURN
      END

CODE FOR LBUFF
      FUNCTION LBUFF ()
C THIS ROUTINE READS THE KEYBOARD DURING LONG OPERATIONS
C AND LOOKS FOR THE ESCAPE KEY.
C IF ESCAPE IS PRESSED LBUFF IS RETURNED = 0 AND THE BUFFER
C IS CLEARED. OTHERWISE LBUFF = 1 AND THE KEYS PRESSED ARE ENTERED
C INTO A CHARACTER BUFFER.
C
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      INTEGER K
      LBUFF = 1
      IF (IBUFF.EQ.ICLEN) RETURN
10    CONTINUE
      CALL ZGTKY1(K)
      IF (K.EQ.ICESP) THEN
C ESCAPE KEY HAS BEEN PRESSED
	LBUFF = 0
	IBUFF = 0
	RETURN
      ELSE IF (K.LT.ICHMIN .OR. K. GT. ICHMAX) THEN
	RETURN
      ELSE IF (K.EQ.0) THEN
	RETURN
      ELSE IF (K.EQ.ICDEL .OR. K. EQ. ICBCK) THEN
	IF (IBUFF.GT.0) THEN
	  IBUFF = IBUFF - 1
	ENDIF
      ELSE
	IBUFF = IBUFF + 1
	CBUFF(IBUFF:IBUFF) = CHAR(K)
      ENDIF
      GOTO 10
      END

