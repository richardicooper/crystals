CRYSTALS CODE FOR VANDER.FOR                                                    
C $Log: vander.F,v $
C Revision 1.4  2005/01/23 09:52:53  rich
C Reinstate old history for Cameron files. History for changes since Dec 23 is
C lost, but changes are not!
C
C Revision 1.1.1.1  2004/12/13 11:16:11  rich
C New CRYSTALS repository
C
C Revision 1.3  2002/05/26 11:51:36  richard
C Add log comment to header
C
CODE FOR ZVAND
      SUBROUTINE ZVAND(IATNO)
C THIS IS THE DRAWING ROUTINE FOR THE VAN DER WAALS ATOMS.
      
      INCLUDE 'CAMPAR.INC'
      INCLUDE 'CAMCOM.INC'
      INCLUDE 'CAMANA.INC'
      INCLUDE 'CAMDAT.INC'
      INCLUDE 'CAMCAL.INC'
      INCLUDE 'CAMMSE.INC'
      INCLUDE 'CAMMEN.INC'
      INCLUDE 'CAMCHR.INC'
      INCLUDE 'CAMGRP.INC'
      INCLUDE 'CAMCOL.INC'
      INCLUDE 'CAMFLG.INC'
      INCLUDE 'CAMSHR.INC'
      INCLUDE 'CAMVER.INC'
      INCLUDE 'CAMKEY.INC'
      INCLUDE 'CAMBTN.INC'
      INCLUDE 'CAMBLK.INC'
      INCLUDE 'XIOBUF.INC'

      PARAMETER (NUM=20)
      REAL XPOINT(5000)
      REAL YPOINT(5000)
      INTEGER IPOINT(2,500)
      INTEGER IXX(5000),IYY(5000)
      REAL X1(NUM),Y1(NUM),Z1(NUM)
      REAL RADS(NUM),RADINT(NUM)
      REAL V1(3),V2(3),V3(3),MULT(3,3)
      REAL XXX(3),XXXX(3)
      INTEGER IPOS,IPPOS
      LOGICAL LPOINT
      LOGICAL LNEW,LINSID
      LOGICAL DEBUG
      DEBUG = .TRUE.
C THE VARIABLE ISIDE IS GOING TO BE USED TO FIND OUT IF WE PASSED C2.
C GET THE DRAWING RADIUS
C AINC IS 1 DEGREE IN RADIANS
      AINC = 0.5 * PI / 180.0
      IF (RSTORE(IATNO+IPCK+1).LT.0) RETURN
      ICOL = RSTORE(IATNO+IATTYP+1)
      RAD = RSTORE(NINT(IRELM+(RSTORE(IATNO+IATTYP)-1)*4.0 + 2))
      X = RSTORE(IATNO+IXYZO)
      Y = RSTORE(IATNO+IXYZO+1)
      Z = RSTORE(IATNO+IXYZO+2)
      IXCEN =  ( X- XCP)*SCALE
      IYCEN =  (Y-YCP)*SCALE
C FIND ATOMS WITHIN RANGE.
      IPPOS = ISTACK(1)
      IS = 0
      IF = 0
10    CONTINUE
      IAT = ISVIEW + (IPPOS-2)*IPACKT
      ZZ = RSTORE(IAT+IXYZO+2)
      RR1 = RSTORE(NINT(IRELM+(RSTORE(IAT+IATTYP)-1)*4.0 + 2))
      IF (ZZ.LT.Z .AND. IS .EQ.0) THEN
C ARE WE WITHIN RANGE YET? WE ARE ONLY INTERESTED IN INTERSECTION
C OCCURING IN THE TOP HEMISPHERE OF IATNO
        IF (Z-ZZ.LE.RR1) THEN
          IS = IPPOS
        ENDIF
      ENDIF
      IF (ZZ.GE.Z) THEN
        IF (Z-ZZ.LE.RAD+RR1) THEN
          IF = IF + 1
        ENDIF
      ENDIF
      IF (IPPOS.GT.0) IPPOS = ISTACK(IPPOS)
      IF (IPPOS.NE.-1) GOTO 10
C WE NOW HAVE THE BEGINNING AND END OF OUR DRAWING LOOP
C NOW LOOP OVER THE ATOMS THAT MAY INTERSECT
      IF (IS.EQ.0) IS = ISTACK(1)
      IPPOS = IS
      IRAD = RAD * SCALE
      IPOS = 0
C NOW WORK OUT THE X,Y,Z COORDS AND RADIUS OF EACH ATOM
      DO 30 I = 1 , IF-1
        IAT = ISVIEW + (IPPOS-2)*IPACKT
c        write (6,*) rstore(iat),iat
        IF (IAT.EQ.IATNO) GOTO 31
        IF (RSTORE(IAT+IPCK+1).LT.0) GOTO 31
        IF (ABS(NINT(RSTORE(IAT))).NE.6) GOTO 31
        X11 = RSTORE(IAT+IXYZO)
        Y11 = RSTORE(IAT+IXYZO+1)
        Z11 = RSTORE(IAT+IXYZO+2)
        RR1 = RSTORE(NINT(IRELM+(RSTORE(IAT+IATTYP)-1)*4.0 + 2))
        D = (X11-X)**2 + (Y11-Y)**2 + (Z11-Z)**2
        IF (D.GT.(RR1+RAD)**2) GOTO 31
C CHECK THE DISTANCE IN THE XY PLANE
C WE WILL IGNORE THIS ATOM IF IT LIES TOTALLY WITHIN THE ATOM CIRCLE
        DXY = SQRT((X11-X)**2 + (Y11-Y)**2)
        IF (DXY.LE.RAD-2.0*RR1) GOTO 31
        IPOS = IPOS + 1
C WORK OUT THE RADIUS OF THE INTERSECTING CIRCLE
        RADINT(IPOS) = SQRT(RAD**2 - (RAD**2-RR1**2+D)**2/(4.0*D))
        X1(IPOS) = X11 - X
        Y1(IPOS) = Y11 - Y
        Z1(IPOS) = Z11 - Z
        RADS(IPOS) = RR1
31      CONTINUE
        IF (IPPOS.GT.0) IPPOS = ISTACK(IPPOS)
30    CONTINUE
C FIRST LOOP AROUND THE MAIN CIRCLE ITSELF.
      ANG = 0
      INCIRC = 0
      IPP = 0
      LPOINT = .TRUE.
      LNEW = .TRUE.
40    CONTINUE
      XX = COS(ANG)*RAD
      YY = SIN(ANG)*RAD
      LINSID = .FALSE.
C LOOP AND CHECK THE OTHER CIRCLES
      DO 50 I = 1 , IPOS
        RRR = SQRT((XX-X1(I))**2 + (YY-Y1(I))**2)
C        RRR = SQRT((XX-X1(I))**2 + (YY-Y1(I))**2 + Z1(I)**2)
        IF (RRR.LT.RADS(I)) THEN
          LINSID = .TRUE.
        ENDIF
50    CONTINUE
C INSIDE THE CIRCLE
      IF (LINSID ) THEN
        IF (IPP.GT.0 .AND. LPOINT.AND.INCIRC.NE.0) THEN
          IPOINT(2,INCIRC) = IPP
          LNEW = .TRUE.
        ENDIF
        LPOINT = .FALSE.
        ANG = ANG + AINC
        IF (ANG*180.0/PI.LT.359.0) GOTO 40
       ELSE
        LPOINT = .TRUE.
      ENDIF
C CHECK THE VALUE OF LPOINT
      IF (LPOINT) THEN
        IPP = IPP + 1
        IF (LNEW) THEN
C THIS POINT LINK HAS NOT BEEN STORED
          INCIRC = INCIRC + 1
          IPOINT(1,INCIRC) = IPP
          LNEW = .FALSE.
        ENDIF
        XPOINT(IPP) = XX
        YPOINT(IPP) = YY
      ENDIF
      IF (ANG*180.0/PI.LT.359.0) THEN
        ANG = ANG + AINC
        GOTO 40
      ENDIF
      IF (LPOINT.AND.INCIRC.GT.0) THEN
        IPOINT(2,INCIRC) = IPP
      ENDIF
      DO 54 I =1 , INCIRC
        DO 58 J = IPOINT(1,I),IPOINT(2,I)
          IXX(J) = NINT (( XPOINT(J)+X-XCP)*SCALE) + XCEN
          IYY(J) = NINT (( YPOINT(J)+Y-YCP)*SCALE) + YCEN
          IF (DEBUG) THEN
C            IF (J.GT.IPOINT(1,I)) THEN
C              CALL DRAW_LINE@(IXX(J-1),IYY(J-1),IXX(J),IYY(J),12+I)
C            ENDIF
          ENDIF
58      CONTINUE
54    CONTINUE
      INCIR1 = INCIRC
C NOW DO THE INTERSECTION POINTS FOR THE SPHERES
      DO 900 II = 1 , IPOS
C WORK OUT THE ROTATION VECTORS
        V1(1) = X1(II)
        V1(2) = Y1(II)
        V1(3) = Z1(II)
C THE LINE PERPENDICULAR TO X,Y,Z IS -Y,X,0
        V2(1) = -V1(2)
        V2(2) = V1(1)
        V2(3) = 0
C NORMALISE THESE AND CALCULATE THE THIRD VECTOR
        III = NORM3(V1)
        III = NORM3(V2)
        III = NCROP3 (V1,V2,V3)
C MAKE UP THE ROTATION MATRIX
        DO 70 J = 1 , 3
          MULT(J,1) = V3(J)
          MULT(J,2) = V2(J)
          MULT(J,3) = V1(J)
70      CONTINUE
        XPOS = SQRT(RAD**2 - RADINT(II)**2)
        XCC = XPOS * V1(1)
        YCC = XPOS * V1(2)
        ZCC = XPOS * V1(3)
C NOW LOOP AROUND THE INTERSECTIONS
        ANG = 0.0
        LPOINT = .TRUE.
        LNEW = .TRUE.
80      CONTINUE
        XXX(1) = COS (ANG) * RADINT(II)
        XXX(2) = SIN (ANG) * RADINT(II)
        XXX(3) = 0.0
C NOW DO THE MULTIPLICATION
        CALL ZMATV(MULT,XXX,XXXX)
        XXXX(1) = XXXX(1) + XCC
        XXXX(2) = XXXX(2) + YCC
C WE ARE ONLY INTERESTED IN THE UPPER PART OF THE CIRCLE
        IF (XXXX(3).LT.0.0) THEN
          IF (LPOINT.AND.INCIRC.GT.0) THEN
C NEED TO FINISH OFF THIS SECTION
            IPOINT(2,INCIRC) = IPP
            LNEW = .TRUE.
          ENDIF
          LPOINT = .FALSE.
          ANG = ANG + AINC
          IF (ANG*180.0/PI.LT.359) GOTO 80
        ELSE IF (.NOT.LPOINT) THEN
          LPOINT = .TRUE.
        ENDIF
        XXXX(3) = XXXX(3) + ZCC
C LOOP AND CHECK THE OTHER CIRCLES
        LINSID = .FALSE.
        DO 90 I = 1 , IPOS
          IF (I.EQ.II) GOTO 90
          RRR = SQRT((XXXX(1)-X1(I))**2
     c      + (XXXX(2)-Y1(I))**2
     c       +(XXXX(3)-Z1(I))**2)
          IF (RRR.LT.RADS(I)) THEN
            LINSID=.TRUE.
          ENDIF
90      CONTINUE
C INSIDE THE CIRCLE
        IF (LINSID) THEN
          IF (LPOINT.AND.INCIRC.GT.0) THEN
            IPOINT(2,INCIRC) = IPP
            LNEW = .TRUE.
          ENDIF
          LPOINT = .FALSE.
          ANG = ANG + AINC
          IF (ANG*180.0/PI.LT.359.0) GOTO 80
        ELSE
          LPOINT = .TRUE.
        ENDIF
C CHECK THE VALUE OF LPOINT
        IF (LPOINT) THEN
          IPP = IPP + 1
          IF (LNEW) THEN
C THIS POINT LINK HAS NOT BEEN STORED
            INCIRC = INCIRC + 1
            IPOINT(1,INCIRC) = IPP
            LNEW = .FALSE.
          ENDIF
          XPOINT(IPP) = XXXX(1)
          YPOINT(IPP) = XXXX(2)
        ENDIF
        IF (ANG*180.0/PI.LT.359.0) THEN
          ANG = ANG + AINC
          GOTO 80
        ENDIF
        IF (LPOINT.AND.INCIRC.GT.0) THEN
          IPOINT(2,INCIRC) = IPP
        ENDIF
        DO 154 I =INCIR1+1 , INCIRC
          DO 158 J = IPOINT(1,I),IPOINT(2,I)
            IXX(J) = NINT (( XPOINT(J)+X-XCP)*SCALE) + XCEN
            IYY(J) = NINT (( YPOINT(J)+Y-YCP)*SCALE) + YCEN
            IF (DEBUG) THEN
C              IF (J.GT.IPOINT(1,I)) THEN
C                CALL DRAW_LINE@(IXX(J-1),IYY(J-1),IXX(J),IYY(J),I)
C              ENDIF
            ENDIF
158       CONTINUE
154     CONTINUE
900   CONTINUE
C NOW NEED TO PUT TOGETHER THE SECTIONS
      IJPOS = 1
C COPY OVER THE FIRST SECTION
      ISECT = 1
180   CONTINUE
      DO 150 I = IPOINT(1,ISECT),IPOINT(2,ISECT)
        IXX(IJPOS) = NINT (( XPOINT(I)+X-XCP)*SCALE) + XCEN
        IYY(IJPOS) = NINT (( YPOINT(I)+Y-YCP)*SCALE) + YCEN
        IF (DEBUG) THEN
C          IF (I.GT.IPOINT(1,ISECT)) THEN
C            CALL DRAW_LINE@(IXX(IJPOS-1),IYY(IJPOS-1),
C     c      IXX(IJPOS),IYY(IJPOS),ICOL)
C          ENDIF
        ENDIF
        IJPOS = IJPOS + 1
150   CONTINUE
C LOOK FOR THE NEAREST POINT
      DMIN = 1.0E+10
      IMIN = 0
      DO 160 I = 1 , INCIRC
        IF (I.EQ.ISECT) GOTO 160
        IF (IPOINT(1,I).LT.0) GOTO 160
        IF (IPOINT(2,I).EQ.IPOINT(1,I)) GOTO 160
        D = (XPOINT(IPOINT(2,ISECT))-XPOINT(IPOINT(1,I)))**2 +
     c  (YPOINT(IPOINT(2,ISECT))-YPOINT(IPOINT(1,I)))**2
        IF (D.LT.DMIN) THEN
          DMIN = D
          IMIN = I
        ENDIF
160   CONTINUE
C      WRITE (6,*) DMIN
      IPOINT(1,ISECT) = -IPOINT(1,ISECT)
      IF (IMIN.EQ.0) THEN
C DRAW THE POLYLINE
       DO 170 J = 2 , IJPOS-1
C         CALL DRAW_LINE@(IXX(J-1),IYY(J-1),IXX(J),IYY(J),ICOL)
170     CONTINUE
C        IF (.NOT.DEBUG) THEN
         CALL ZPOLGN (IXX,IYY,IJPOS-1,ICOL)
         CALL ZPLINE ( IXX,IYY,IJPOS-1,IBACK)
C         ENDIF
      ELSE
        ISECT = IMIN
        GOTO 180
      ENDIF
      RETURN
      END

