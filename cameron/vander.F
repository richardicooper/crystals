CRYSTALS CODE FOR VANDER.FOR                                                    
C $Log: not supported by cvs2svn $
CODE FOR ZVAND
      SUBROUTINE ZVAND(IATNO)
C THIS IS THE DRAWING ROUTINE FOR THE VAN DER WAALS ATOMS.
      
\CAMPAR
\CAMCOM
\CAMANA
\CAMDAT
\CAMCAL
\CAMMSE
\CAMMEN
\CAMCHR
\CAMGRP
\CAMCOL
\CAMFLG
\CAMSHR
\CAMVER
\CAMKEY
\CAMBTN
\CAMBLK
\XIOBUF

      PARAMETER (NUM=20)
      REAL XPOINT(5000)
      REAL YPOINT(5000)
      INTEGER IPOINT(2,500)
      INTEGER IXX(5000),IYY(5000)
      REAL X1(NUM),Y1(NUM),Z1(NUM)
      REAL RADS(NUM),RADINT(NUM)
      REAL V1(3),V2(3),V3(3),MULT(3,3)
      REAL XXX(3),XXXX(3)
      INTEGER IPOS,IPPOS
      LOGICAL LPOINT
      LOGICAL LNEW,LINSID
      LOGICAL DEBUG
      DEBUG = .TRUE.
C THE VARIABLE ISIDE IS GOING TO BE USED TO FIND OUT IF WE PASSED C2.
C GET THE DRAWING RADIUS
C AINC IS 1 DEGREE IN RADIANS
      AINC = 0.5 * PI / 180.0
      IF (RSTORE(IATNO+IPCK+1).LT.0) RETURN
      ICOL = RSTORE(IATNO+IATTYP+1)
      RAD = RSTORE(NINT(IRELM+(RSTORE(IATNO+IATTYP)-1)*4.0 + 2))
      X = RSTORE(IATNO+IXYZO)
      Y = RSTORE(IATNO+IXYZO+1)
      Z = RSTORE(IATNO+IXYZO+2)
      IXCEN =  ( X- XCP)*SCALE
      IYCEN =  (Y-YCP)*SCALE
C FIND ATOMS WITHIN RANGE.
      IPPOS = ISTACK(1)
      IS = 0
      IF = 0
10    CONTINUE
      IAT = ISVIEW + (IPPOS-2)*IPACKT
      ZZ = RSTORE(IAT+IXYZO+2)
      RR1 = RSTORE(NINT(IRELM+(RSTORE(IAT+IATTYP)-1)*4.0 + 2))
      IF (ZZ.LT.Z .AND. IS .EQ.0) THEN
C ARE WE WITHIN RANGE YET? WE ARE ONLY INTERESTED IN INTERSECTION
C OCCURING IN THE TOP HEMISPHERE OF IATNO
        IF (Z-ZZ.LE.RR1) THEN
          IS = IPPOS
        ENDIF
      ENDIF
      IF (ZZ.GE.Z) THEN
        IF (Z-ZZ.LE.RAD+RR1) THEN
          IF = IF + 1
        ENDIF
      ENDIF
      IF (IPPOS.GT.0) IPPOS = ISTACK(IPPOS)
      IF (IPPOS.NE.-1) GOTO 10
C WE NOW HAVE THE BEGINNING AND END OF OUR DRAWING LOOP
C NOW LOOP OVER THE ATOMS THAT MAY INTERSECT
      IF (IS.EQ.0) IS = ISTACK(1)
      IPPOS = IS
      IRAD = RAD * SCALE
      IPOS = 0
C NOW WORK OUT THE X,Y,Z COORDS AND RADIUS OF EACH ATOM
      DO 30 I = 1 , IF-1
        IAT = ISVIEW + (IPPOS-2)*IPACKT
c        write (6,*) rstore(iat),iat
        IF (IAT.EQ.IATNO) GOTO 31
        IF (RSTORE(IAT+IPCK+1).LT.0) GOTO 31
        IF (ABS(NINT(RSTORE(IAT))).NE.6) GOTO 31
        X11 = RSTORE(IAT+IXYZO)
        Y11 = RSTORE(IAT+IXYZO+1)
        Z11 = RSTORE(IAT+IXYZO+2)
        RR1 = RSTORE(NINT(IRELM+(RSTORE(IAT+IATTYP)-1)*4.0 + 2))
        D = (X11-X)**2 + (Y11-Y)**2 + (Z11-Z)**2
        IF (D.GT.(RR1+RAD)**2) GOTO 31
C CHECK THE DISTANCE IN THE XY PLANE
C WE WILL IGNORE THIS ATOM IF IT LIES TOTALLY WITHIN THE ATOM CIRCLE
        DXY = SQRT((X11-X)**2 + (Y11-Y)**2)
        IF (DXY.LE.RAD-2.0*RR1) GOTO 31
        IPOS = IPOS + 1
C WORK OUT THE RADIUS OF THE INTERSECTING CIRCLE
        RADINT(IPOS) = SQRT(RAD**2 - (RAD**2-RR1**2+D)**2/(4.0*D))
        X1(IPOS) = X11 - X
        Y1(IPOS) = Y11 - Y
        Z1(IPOS) = Z11 - Z
        RADS(IPOS) = RR1
31      CONTINUE
        IF (IPPOS.GT.0) IPPOS = ISTACK(IPPOS)
30    CONTINUE
C FIRST LOOP AROUND THE MAIN CIRCLE ITSELF.
      ANG = 0
      INCIRC = 0
      IPP = 0
      LPOINT = .TRUE.
      LNEW = .TRUE.
40    CONTINUE
      XX = COS(ANG)*RAD
      YY = SIN(ANG)*RAD
      LINSID = .FALSE.
C LOOP AND CHECK THE OTHER CIRCLES
      DO 50 I = 1 , IPOS
        RRR = SQRT((XX-X1(I))**2 + (YY-Y1(I))**2)
C        RRR = SQRT((XX-X1(I))**2 + (YY-Y1(I))**2 + Z1(I)**2)
        IF (RRR.LT.RADS(I)) THEN
          LINSID = .TRUE.
        ENDIF
50    CONTINUE
C INSIDE THE CIRCLE
      IF (LINSID ) THEN
        IF (IPP.GT.0 .AND. LPOINT.AND.INCIRC.NE.0) THEN
          IPOINT(2,INCIRC) = IPP
          LNEW = .TRUE.
        ENDIF
        LPOINT = .FALSE.
        ANG = ANG + AINC
        IF (ANG*180.0/PI.LT.359.0) GOTO 40
       ELSE
        LPOINT = .TRUE.
      ENDIF
C CHECK THE VALUE OF LPOINT
      IF (LPOINT) THEN
        IPP = IPP + 1
        IF (LNEW) THEN
C THIS POINT LINK HAS NOT BEEN STORED
          INCIRC = INCIRC + 1
          IPOINT(1,INCIRC) = IPP
          LNEW = .FALSE.
        ENDIF
        XPOINT(IPP) = XX
        YPOINT(IPP) = YY
      ENDIF
      IF (ANG*180.0/PI.LT.359.0) THEN
        ANG = ANG + AINC
        GOTO 40
      ENDIF
      IF (LPOINT.AND.INCIRC.GT.0) THEN
        IPOINT(2,INCIRC) = IPP
      ENDIF
      DO 54 I =1 , INCIRC
        DO 58 J = IPOINT(1,I),IPOINT(2,I)
          IXX(J) = NINT (( XPOINT(J)+X-XCP)*SCALE) + XCEN
          IYY(J) = NINT (( YPOINT(J)+Y-YCP)*SCALE) + YCEN
          IF (DEBUG) THEN
C            IF (J.GT.IPOINT(1,I)) THEN
C              CALL DRAW_LINE@(IXX(J-1),IYY(J-1),IXX(J),IYY(J),12+I)
C            ENDIF
          ENDIF
58      CONTINUE
54    CONTINUE
      INCIR1 = INCIRC
C NOW DO THE INTERSECTION POINTS FOR THE SPHERES
      DO 900 II = 1 , IPOS
C WORK OUT THE ROTATION VECTORS
        V1(1) = X1(II)
        V1(2) = Y1(II)
        V1(3) = Z1(II)
C THE LINE PERPENDICULAR TO X,Y,Z IS -Y,X,0
        V2(1) = -V1(2)
        V2(2) = V1(1)
        V2(3) = 0
C NORMALISE THESE AND CALCULATE THE THIRD VECTOR
        III = NORM3(V1)
        III = NORM3(V2)
        III = NCROP3 (V1,V2,V3)
C MAKE UP THE ROTATION MATRIX
        DO 70 J = 1 , 3
          MULT(J,1) = V3(J)
          MULT(J,2) = V2(J)
          MULT(J,3) = V1(J)
70      CONTINUE
        XPOS = SQRT(RAD**2 - RADINT(II)**2)
        XCC = XPOS * V1(1)
        YCC = XPOS * V1(2)
        ZCC = XPOS * V1(3)
C NOW LOOP AROUND THE INTERSECTIONS
        ANG = 0.0
        LPOINT = .TRUE.
        LNEW = .TRUE.
80      CONTINUE
        XXX(1) = COS (ANG) * RADINT(II)
        XXX(2) = SIN (ANG) * RADINT(II)
        XXX(3) = 0.0
C NOW DO THE MULTIPLICATION
        CALL ZMATV(MULT,XXX,XXXX)
        XXXX(1) = XXXX(1) + XCC
        XXXX(2) = XXXX(2) + YCC
C WE ARE ONLY INTERESTED IN THE UPPER PART OF THE CIRCLE
        IF (XXXX(3).LT.0.0) THEN
          IF (LPOINT.AND.INCIRC.GT.0) THEN
C NEED TO FINISH OFF THIS SECTION
            IPOINT(2,INCIRC) = IPP
            LNEW = .TRUE.
          ENDIF
          LPOINT = .FALSE.
          ANG = ANG + AINC
          IF (ANG*180.0/PI.LT.359) GOTO 80
        ELSE IF (.NOT.LPOINT) THEN
          LPOINT = .TRUE.
        ENDIF
        XXXX(3) = XXXX(3) + ZCC
C LOOP AND CHECK THE OTHER CIRCLES
        LINSID = .FALSE.
        DO 90 I = 1 , IPOS
          IF (I.EQ.II) GOTO 90
          RRR = SQRT((XXXX(1)-X1(I))**2
     c      + (XXXX(2)-Y1(I))**2
     c       +(XXXX(3)-Z1(I))**2)
          IF (RRR.LT.RADS(I)) THEN
            LINSID=.TRUE.
          ENDIF
90      CONTINUE
C INSIDE THE CIRCLE
        IF (LINSID) THEN
          IF (LPOINT.AND.INCIRC.GT.0) THEN
            IPOINT(2,INCIRC) = IPP
            LNEW = .TRUE.
          ENDIF
          LPOINT = .FALSE.
          ANG = ANG + AINC
          IF (ANG*180.0/PI.LT.359.0) GOTO 80
        ELSE
          LPOINT = .TRUE.
        ENDIF
C CHECK THE VALUE OF LPOINT
        IF (LPOINT) THEN
          IPP = IPP + 1
          IF (LNEW) THEN
C THIS POINT LINK HAS NOT BEEN STORED
            INCIRC = INCIRC + 1
            IPOINT(1,INCIRC) = IPP
            LNEW = .FALSE.
          ENDIF
          XPOINT(IPP) = XXXX(1)
          YPOINT(IPP) = XXXX(2)
        ENDIF
        IF (ANG*180.0/PI.LT.359.0) THEN
          ANG = ANG + AINC
          GOTO 80
        ENDIF
        IF (LPOINT.AND.INCIRC.GT.0) THEN
          IPOINT(2,INCIRC) = IPP
        ENDIF
        DO 154 I =INCIR1+1 , INCIRC
          DO 158 J = IPOINT(1,I),IPOINT(2,I)
            IXX(J) = NINT (( XPOINT(J)+X-XCP)*SCALE) + XCEN
            IYY(J) = NINT (( YPOINT(J)+Y-YCP)*SCALE) + YCEN
            IF (DEBUG) THEN
C              IF (J.GT.IPOINT(1,I)) THEN
C                CALL DRAW_LINE@(IXX(J-1),IYY(J-1),IXX(J),IYY(J),I)
C              ENDIF
            ENDIF
158       CONTINUE
154     CONTINUE
900   CONTINUE
C NOW NEED TO PUT TOGETHER THE SECTIONS
      IJPOS = 1
C COPY OVER THE FIRST SECTION
      ISECT = 1
180   CONTINUE
      DO 150 I = IPOINT(1,ISECT),IPOINT(2,ISECT)
        IXX(IJPOS) = NINT (( XPOINT(I)+X-XCP)*SCALE) + XCEN
        IYY(IJPOS) = NINT (( YPOINT(I)+Y-YCP)*SCALE) + YCEN
        IF (DEBUG) THEN
C          IF (I.GT.IPOINT(1,ISECT)) THEN
C            CALL DRAW_LINE@(IXX(IJPOS-1),IYY(IJPOS-1),
C     c      IXX(IJPOS),IYY(IJPOS),ICOL)
C          ENDIF
        ENDIF
        IJPOS = IJPOS + 1
150   CONTINUE
C LOOK FOR THE NEAREST POINT
      DMIN = 1.0E+10
      IMIN = 0
      DO 160 I = 1 , INCIRC
        IF (I.EQ.ISECT) GOTO 160
        IF (IPOINT(1,I).LT.0) GOTO 160
        IF (IPOINT(2,I).EQ.IPOINT(1,I)) GOTO 160
        D = (XPOINT(IPOINT(2,ISECT))-XPOINT(IPOINT(1,I)))**2 +
     c  (YPOINT(IPOINT(2,ISECT))-YPOINT(IPOINT(1,I)))**2
        IF (D.LT.DMIN) THEN
          DMIN = D
          IMIN = I
        ENDIF
160   CONTINUE
C      WRITE (6,*) DMIN
      IPOINT(1,ISECT) = -IPOINT(1,ISECT)
      IF (IMIN.EQ.0) THEN
C DRAW THE POLYLINE
       DO 170 J = 2 , IJPOS-1
C         CALL DRAW_LINE@(IXX(J-1),IYY(J-1),IXX(J),IYY(J),ICOL)
170     CONTINUE
C        IF (.NOT.DEBUG) THEN
         CALL ZPOLGN (IXX,IYY,IJPOS-1,ICOL)
         CALL ZPLINE ( IXX,IYY,IJPOS-1,IBACK)
C         ENDIF
      ELSE
        ISECT = IMIN
        GOTO 180
      ENDIF
      RETURN
      END
