CRYSTALS CODE FOR SIR92
c-- sir code for sir92                          Release 93.02
      program sir92 
      character file*80,line*80
      character fname(9)*80,ext(9)*4
c-- file names and extensions
      common/dotdat/ fname,ext
c-- input/output units, title
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
c-- trigonometric tables and constants
      common/trig/sint(450),pi,twopi,dtor,rtod
c-- implementation specific flags
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
c-- direct access file related commons
      common/xdisu/ncdfu ,ndfle,irecx
      common /xfile/ ifile,jjlist,jjend,infle,nwfle,icfle,lid(4)
      common /xfili/ lfirst,nwblo,lindex(240)
c-- scratch file reflexion arrays
      common /buffer/ vet(6,85),nrpb,idumb(4)
c-- user requests
      common / ureq1/ jpatt,jpunt(501),ksacc,jseteq,jumpp,jmpsie,nsec
c-- coordinats 
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      common /atomo/ xtot(1600)
c-- graphics
      common/screen/ kscreen,iy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
c
c--
      ier = 0
      call pc386(ier)
      if (ier.lt.0) go to 1000
c     set flag for caos environment
      jcaos=0
      ncdfu=jdir
c     set flag for direct execution
      iexec=-1
c
c-- set up the default names for work files
c
      do 10 i=1,4
      file=fname(i)(1:30)//ext(i)
      call xcmprp(file,lfile)
      fname(i)=file
   10 continue
c
c-- define the number of reflections per block in scratch file
c--   nrpb = (number of words in block) / 6
c
      nrpb=knwr/6
   50 call spoolr(jcaos,line,newf,iexec,jfour,ier)
      if (ier.lt.0) go to 1000
c
c-- initialize the graphics
c
      call scr1
c
      call sircom(newf,iexec,jfour,ier)
      if (ier.lt.0) go to 1000
      if (iexec.ge.0) go to 50
 1000 if (ier.lt.0) then
                      write(line,2000)
                    else
                      write(line,3000)
                    endif
c
      lline=20
      if(ier.ne.-2) call scrend(line,lline)
      if (jcaos.eq.0) close (jdir)
      write(lo,4000) line(1:lline)
c
 2000 format(' == SIR92 ends in error')
 3000 format(' == SIR92 ends ok      ')
 4000 format(//,1h ,a)
      
      call xwin(nz(1),nz(101),0,17,'    ',0) 
      
      stop
      end
c-----------------------------------------------------------------------
      subroutine spoolr(jcaos,line,newf,iexec,jfour,ier)
      character line*80,hklf*80,releas*5,com4*4
      character beg,commen,allcom(25)*14,dire*80,defa*7
      character blank,digit*12,card(100)*80,ffile*80
      common /comdir/ icomq(200,2),maxcom,ipcom,ipdir,icomat
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /xfile/ ifile,jjlist,jjend,infle,nwfle,icfle,lid(4)
      common /xfili/ lfirst,nwblo,lindex(240)
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      character*8 itldef
      character fname(9)*80,ext(9)*4
      common/dotdat/ fname,ext
      common /chara/ blank,digit,card,ffile
      common /charas/ beg,commen,allcom
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common / ureq1/ jpatt,jpunt(501),ksacc,jseteq,jumpp,jmpsie,nsec
      common /genob/ irho
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      common /screen/ kscreen,iy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      dimension vet(40),ivet(40)
      data itldef /' sir 92 '/
c
      if (iexec.lt.0) then
                        pi=4.0*atan(1.0)
                        twopi=2.0*pi
                        rtod=180.0/pi
                        dtor=1.0/rtod
c     set up sin/cos table
                        do 50 i=1,450
                        sint(i)=sin(dtor*float(i-1))
   50                   continue
                        allcom(15)(1:1)=beg
                        do 100 i=1,19,2
  100                   read(itldef,'(2a4)') itle(i),itle(i+1)
                        jfour=0
                      endif
      ifper=0
      irefl=0
      kcont=0
      ier=0
      init=0
      nallc=25
      ipcom=0
      icomo=2
      ipdir=0
      nerr=0
      do 120 i=1,maxcom
      do 120 j=1,2
  120 icomq(i,j)=0
      ifli=0
c
      if (jcaos.eq.1) ifli=1
c
c-- read cards
c
  130 format(a)
      if (iexec.gt.0) write(lo,135) beg,beg,beg
  135 format(//,' Please enter commands and directives ( ',a1,a1,' to go
     *, ',a1,'end to stop )')
  140 if (ifli.eq.0) read(ln,130,end=2000) line
      ifli=0
      call shift(line,nchar)
      if (nchar.le.0.or.line(1:1).eq.commen) go to 140
c
c-- if first character is equal to '%' it is a command 
c
      if (line(1:1).eq.beg) then
c
c-- check if the command is an "exec" one
c
            if (line(2:2).eq.beg) then
                                    iexec=iexec+1
c                                   return
                                    go to 165
                                  endif
CCCCCCCCCif (line(2:2).ne.blank) then
c
c-- verify if the command is allowed
c
         icom=0
         com4=line(2:5)
         call lcase(com4)
         do 150 i=1,nallc
         if (com4.eq.allcom(i)(1:4)) icom=i
  150    continue
         jcom=0
c
c-- if %PATTERSON next command must be %END
c
         if (icomo.eq.16) icom=7
c
         if (icom.eq.0) then
                           go to 3000
                         else
                           if (icom.eq.25) then
c
c--       the command is  %window
c
                                    call cutst(line,lenp,dire,lend)
                                    iopt=0
                                    call getnum(line,vet,ivet,iv,iopt)
                                    if (iv.eq.2) then
                                        kscrx=max0(639,ivet(1))
                                        kscry=max0(479,ivet(2))
                                    endif
                                            jcom=1
                                            kscreen=1
                                          endif
                           if (icom.eq.24) then
c
c--       the command is  %nowindow
c
                                            jcom=1
                                            kscreen=0
                                          endif
                           if (icom.eq.8) then
c
c--       the command is  %continue
c
                                            jcom=1
                                            icomo=icomo+1
                                            if (icomo.eq.2) icomo=3
                                            if (icomo.eq.24) icomo=1
                                            do 160 ii=icomo,7
                                            if (ii.eq.2) go to 160
                                            ipcom=ipcom+1
                                            if (ipcom.gt.maxcom) 
     *                                      go to 6000
                                            icomq(ipcom,1)=ii
  160                                       continue            
                                          endif
                           if (icom.eq.9) then
c
c--       the command is  %job
c
                                         jcom=1
                                         call cutst(line,lenp,dire,lend)
                                         read(line,'(20a4)') itle
                                       endif
                           if (icom.eq.10) then
c
c--       the command is  %file
c
                                         jcom=1
      call cutst(line,lenp,dire,lend)
      if (lenp.le.0) go to 1000
      call cutst(line,lenp,dire,lend)
      fname(1)=dire
      if (lenp.gt.0) then
                       call cutst(line,lenp,dire,lend)
                       fname(3)=dire
                     endif
                                       endif
                           if (icom.eq.22) then
c
c--       the command is  %structure
c
                                         jcom=1
      call cutst(line,lenp,dire,lend)
      if (lenp.le.0) go to 1000
      call cutst(line,lenp,dire,lend)
      fname(1)=dire(1:lend)//ext(1)
      fname(2)=dire(1:lend)//ext(2)
      fname(3)=dire(1:lend)//ext(3)
      fname(4)=dire(1:lend)//ext(4)
                                       endif
                           if (icom.eq.12) then
c
c--       the command is %initialize
c
                                            jcom=1
                                            init=1
                                           endif
                           if (jcom.eq.0) then
                                            ipcom=ipcom+1
                                            if (ipcom.gt.200) go to 6000
                                            icomq(ipcom,1)=icom
                                            icomo=icom
                                          endif
                         endif
CCCCCCCCCC               endif
          else
c
c-- it is a directive
c
            if (ipcom.eq.0) go to 4000
            ipdir=ipdir+1
            if (ipdir.gt.100) go to 5000
            card(ipdir)=line
            com4=line(1:4)
            call lcase(com4)
            icomq(ipcom,2)=icomq(ipcom,2)+1
            if (com4.eq.'scha'.or.
     *          com4.eq.'mold'.or.
     *          com4.eq.'molp') then
                                  call cutst(line,lenp,dire,lend)
                                  if (lenp.gt.0) fname(4)=line
                                endif
            if (com4.eq.'refl') then
                        call cutst(line,lenp,dire,lend)
                        irefl=1
                        com4=line(1:4)
                        call lcase(com4)
                        if (com4.eq.'foll') then
                            jfile=ln
                            hklf=' '
                            hklf(1:20) ='card reader         '
                          else 
                            hklf=line
                          endif
                        endif
            if (com4.eq.'cont') kcont=1
          endif
      if (icom.ne.7.and.icom.ne.8) go to 140
      if (nerr.ne.0) go to 9000
  165 if (iexec.gt.0) return
      iexec=iexec+1
      if (jcaos.eq.0) then
c-- initialize history array
      if (kenvir.eq.0) then
                         do 170 i=1,99
  170                    kstory(i)=0
                       endif
c-- set up internal structures
      call star9
      itipe=0
      if (kopen(jdir,fname(1),nlen,itipe,ierr).ge.0) go to 200
      write(lo,190) ierr,fname(1)
  190 format(' error ',i5,'  opening file ',a)
      ier=-2
      return
  200 continue
      call xdwn(lfirst,lindex,10)
      newf=0
      if (init.eq.1) lindex(8)=ifile+1
      if (lindex(8).ne.ifile) then
                                call setfi
                                newf=1
                              endif
      call xlc
      call xcsae
                         endif
c--
      write(lo,215) itle
  215 format(1h ,120('*'),/,20x,20a4,//)
      call wrhead
      write(lo,220)
  220 format(' Used commands & directives:',/)
      jj=0
      do 240 i=1,ipcom
         do 225 j=1,80
  225    line(j:j)=blank
         j=icomq(i,1)
         if (j.eq.6) jfour=1
         write(line(1:26),'(11x,a1,a14)') beg,allcom(j)
         if (icomq(i,2).eq.0) then
                                defa='default'
                                if (icomq(i,1).eq.7) defa='       '
                                write(line(28:34),'(a7)') defa
                                write(lo,'(/,a)') line
                              else
                                do 230 j=1,icomq(i,2)
                                 jj=jj+1
                                 if (j.eq.1) then
                                 write(lo,'(/,a)') line(1:27)//card(jj)
                                             else
                                 write(lo,'(27x,a)') card(jj)
                                             endif
  230                           continue
                              endif
  240 continue
      write(lo,290) ln,lo,jdir,fname(1),iscra,jrel
      if (irefl.ne.0) write(lo,300) jfile,hklf
      if (kcont.eq.1)  then
                         itype=2
                         iform=1
                         jop=jopen(kform,ffile,nlen,itype,iform,ierr)
                         if (jop.lt.0) then
                                         write(lo,270) ierr,ffile
                                         ier=-2
                                       else
                         read(kform,280,iostat=ierr,err=7000) releas
                         write(lo,310) kform,ffile,releas
                         close (kform)
                         if (releas.ne.'92.11') then 
                                                  ier=-2
                                                  write(lo,311) '92.11'
                                                endif
                                       endif
                       endif
      if (jfour.eq.1)  write(lo,320) jhost,fname(3),jgrap,fname(4),ifour
  270 format(' *** error ***  open error, code =',i5,' file is ',a)
  280 format(a5)
  290 format(//,   ' Files used in sir:',//,
     *     '  Channel                                  Name',/,
     1            i6,'    card reader',/,
     2            i6,'    line printer',/,
     3            i6,'    direct access structure file     ',a,/,
     4            i6,'    direct access scratch file',/,
     5            i6,'    sequential scratch file ')
  300 format(     i6,'    reflection input file            ',a)
  310 format(     i6,'    scattering factors file          ',a,
     1     /, 6x,    '    ( Release : ',a5,' )')
  311 format(/,6x,'    *** error ***  Release should be ',a5,' !!',/)
  320 format(     i6,'    fourier peaks file               ',a,/,
     *            i6,'    peaks file to be plotted         ',a,/,
     *            i6,'    sequential scratch file ',//)
      write(lo,'(//)')
      if (newf.eq.1) then
                       write(lo,330)
                     else
                       write(lo,340)
                       call summar
                     endif
  330 format(6x,'Direct access structure file has been initialized'//)
  340 format(6x,'Direct access structure file actually contains:'/)
      return
 1000 continue
      write(lo,1010) 
 1010 format(' No structure name specified ')
      go to 9000
 2000 continue
      write(lo,2010)
 2010 format(' no   %end or %continue   command specified')
      go to 9000
 3000 continue
      write(lo,3010) line(1:nchar)
 3010 format(' error in command ',a)
      go to 9000
 4000 write(lo,4100) line(1:nchar)
 4100 format(' no command specified for directive ',a)
      go to 9000
 5000 write(lo,5100)
 5100 format(' more than 100 directives used ',/,
     *       ' check for missing  %end or %continue')
      go to 9000
 6000 write(lo,6100) maxcom
 6100 format(' more than ',i5,' commands used ',/,
     *       ' check input file or submit two jobs ')
      go to 9000
 7000 nrec=1
      write(lo,7100) ierr,nrec,ffile
 7100 format(' error ',i5,' reading record no. ',i3,' in file ',a)
 9000 ier=-2
      return
      end
c-----------------------------------------------------------------------
      subroutine sircom(newf,iexec,jfour,ier)
c-- main subroutine to handle sir commands
      character beg,commen,allcom(25)*14
      common /charas/ beg,commen,allcom
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      character fname(9)*80,ext(9)*4
      common/dotdat/ fname,ext
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /comdir/ icomq(200,2),maxcom,ipcom,ipdir,icomat
      common /xlimi/ idummy(6),nfls
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common / ureq1/ jpatt,jpunt(501),ksacc,jseteq,jumpp,jmpsie,nsec
      common /genob/ irho
c
      ier=0
Corig if (jfour.eq.1)  then
Corig                    itype=0
Corig                    iform=1
Corig                    jop=jopen(jhost,fname(3),nlen,itype,iform,ier)
Corig                    if (jop.lt.0) go to 7000
Corig                  endif
      ipdir =0
      icomat=0
   80 if (ier.lt.0) return
      nfls=1
      nfl=1
      icomat=icomat+1
      j=icomq(icomat,1)
      if (j.ne.0) then
      jj=kstory(20)+1
      kstory(20)=jj
      jj=jj+20
      if (jj.le.99) kstory(jj)=j
c
      if (j.eq. 4) call scrpd
      if (j.eq. 5) call scrfd
      if (j.eq.13) call scrrd
      call scr2
c
      go to (100,200,300,400,500,600,700,800,900,1000,
     *       1100,1200,1300,1400,1500,1600,1700,1800,
     *       1900,2000,2100,2200,2300,2400,2500),j
c-- normal     routine
  100 continue
      call normal(ier)
      go to 80
c-- seminvariants routine
  200 continue
      call seminv(ier)
      go to 80
c-- invariants routine
  300 continue
      call invar(ier)
      go to 80
c-- phase   routine
  400 continue
      call contan(ier)
      go to 80
c-- fourier routine
  500 continue
      call fourie(fname(3),ier)
      go to 80
c-- export command
  600 continue
      call export(ier)
      go to 80
c-- end command
  700 continue
      go to 1500
c-- continue command
  800 continue
      ier=-1
      go to 3000
c-- job command
  900 continue
      ier=-1
      go to 3000
c-- file command
 1000 continue
      ier=-1
      go to 3000
c-- dummy  command
 1100 continue
      ier=-1
      go to 3000
c-- initialize
 1200 continue
      ier=-1
      go to 3000
c-- restart command
 1300 continue
      call restar(ier)
      go to 80
c-- history command
 1400 continue
      call befor
      go to 80
 1600 continue
      call patter(ier)
      go to 80
c-- quartets command
 1700 continue
      kkk=0
c     call newqua(kkk,ier)
      go to 80
c-- caos command
 1800 continue
      call caosm(ier)
      go to 80
 1900 continue
      ier=-1
      go to 3000
 2000 continue
      ier=-1
      go to 3000
 2100 continue
      ier=-1
      go to 3000
 2200 continue
      ier=-1
      go to 3000
c-- data       routine
 2300 continue
      call datasir(newf,ier)
      go to 80
c--  nowindow command  
 2400 continue
      ier=-1
      go to 3000
c--  window command  
 2500 continue
      ier=-1
      go to 3000
c-- exec command
 1500 iexec=-1
          endif
      return
 3000 write(lo,3100) j,allcom(j)
 3100 format(' wrong command code = ',i5,' for ',a14,' command')
      return
      end
c-----------------------------------------------------------------------
      subroutine befor
      character cff,beg,commen,allcom(25)*14
      common /comdir/ icomq(200,2),maxcom,ipcom,ipdir,icomat
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      common /charas/ beg,commen,allcom
c
      kkff=0     
      write(cff,'(i1)') kkff
      write(lo,100) cff,itle
  100 format(///,a1 ,120('+'),//,
     1 39h SIR92 : History of the structure      ,68x,14hRelease  93.02
     2 ,//,20x,20a4,/,1h ,120('+'),/)
      ifin=kstory(20)-1
      kstory(20)=ifin
      if (ifin.le.0) then
                      write(lo,300)
                     else
                      write(lo,400)
                      do 200 i=1,ifin
                      j=i+20
                      jj=kstory(j)
                      write(lo,500) allcom(jj)
  200                 continue
                     endif
  300 format(/,10x,' The structure has no story',/)
  400 format(/,10x,' List of commands issued in the past',/)
  500 format(11x,a1,a14)
      return
      end

c-----------------------------------------------------------------------
code for cancella
      subroutine cancella(iln)
c
c--clear the entry for a list in the current index table
c--iln = the list type number
c
      common/xfile/ifile,ilist,iend,infle,nwfle,icfle,lid(4)
      common/xfili/lfirst,nwblo,lindex(240)
c
      lista=iln
      mln=lindex(2)
      il =lindex(5)
      if(lista) 2051,2051,2210
 2210 continue
      if(lista-mln) 2220,2220,2051
 2220 continue
      i=lista*il+1
      lindex(i)=0
      i=lindex(6)
      call xup(lindex(3),lindex,i)
      call xdump
 2051 return
      end
c-----------------------------------------------------------------------
      subroutine getnum(linei,vet,ivet,iv,iopt)
      dimension vet(40),ivet(40)
      character blank,digit*12,card(100)*80,ffile*80
      character linei*(*),resto*80,cifre*80
      common /chara/ blank,digit,card,ffile
c
      iv=0
      do 1 i=1,40
    1 vet(i)=0.0
      k=len(linei)
      do 2 i=1,80
    2 resto(i:i)=blank
      do 3 i=1,k
    3 resto(i:i)=linei(i:i)
    5 sum=0.0
      isum=0
      call cutst(resto,ncharl,cifre,nchard)
      if (nchard.le.0) return
      segno=1.0
      isegno=1
      iniz=1
      if (cifre(1:1).eq.digit(12:12)) then
                                       segno=-1.0
                                       isegno=-1
                                       iniz=2
                                     endif
      ipoi=index(cifre(1:nchard),digit(11:11))
      if (ipoi.eq.0) ipoi=nchard+1
      dec=ipoi-1-iniz
      idec=ipoi-1-iniz
      do 10 i=iniz,nchard
      idig=index(digit,cifre(i:i))
      if (idig.ge.1.and.idig.le.11)  then
         if (idig.le.10)  then
                            sum=sum+float(idig-1)*10.0**dec
                            if (idec.ge.0) isum=isum*10+(idig-1)
                            dec=dec-1.0
                            idec=idec-1.0
                          endif
                                     else
                                       iopt=-1
                                       return
                                     endif
   10 continue
      iv=iv+1
      vet(iv)=sum*segno
      ivet(iv)=isum*isegno
      if (ncharl.le.0) then
                         iopt=1
                         return
                       endif
      if (iv.eq.iopt) return
      go to 5
      end
c-----------------------------------------------------------------------
      subroutine shift(string,lenp)
      character string*(*)
      character blank,digit*12,card(100)*80,ffile*80
      common /chara/ blank,digit,card,ffile
c
      k=len(string)
      ifin=1
      do 10 i=1,k
      if (string(i:i).ne.blank) then
                                  iniz=i
                                  go to 20
                                endif
   10 continue
      lenp=-1
      return
   20 do 30 i=k,1,-1
      if (string(i:i).ne.blank) then
                                  ifin=i
                                  go to 40
                                endif
   30 continue
   40 continue
      lenp=ifin-iniz+1
      if (iniz.eq.1) return
      do 50 i=1,lenp
      j=iniz+i-1
   50 string(i:i)=string(j:j)
      if (lenp.eq.k) return
      do 60 i=lenp+1,k
   60 string(i:i)=blank
      return
      end
c-----------------------------------------------------------------------
      subroutine cutst(string,lens,dire,lend)
      character string*(*),dire*(*)
      character blank,digit*12,card(100)*80,ffile*80
      common /chara/ blank,digit,card,ffile
c
      k=len(dire)
      do 5 i=1,k
    5 dire(i:i)=blank
      k=len(string)
      do 10 i=1,k
      if (string(i:i).eq.blank) then
                                  iniz1=i
                                  go to 20
                                endif
   10 continue
   20 continue
      lend=min0(iniz1-1,40)
      do 25 i=1,lend
      dire(i:i)=string(i:i)
   25 string(i:i)=blank
      call shift(string,lens)
      return
      end
c-----------------------------------------------------------------------
      subroutine summar
c
c-- summarize the content of the direct access file
c
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nat,f(9),nalf(8)
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common/c/flgw(30),flgd(30),avr(30),dcv(50),slope,flgk,bt,sc,del,ks
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /xdata/ num(350),dmat(3,500),mat(3,30000),
     * mat1(7,1000),lpseud(12),cfom(302),ipos(302),dumm(60534)
     * ,dummpc(84000)
      integer dmat
c
      call srlin (1,lsn,lixx,ljxx,lkxx,llxx)
      if(lixx.gt.0) then
                      call yfl01
                      write(lo,30)
                    endif
   30 format(32x,' cell parameters ')
      call srlin (2,lsn,lixx,ljxx,lkxx,llxx)
      if(lixx.gt.0) then
                      call yfl02
                      write(lo,50) nsym
   50 format(26x,i6,' symmetry operators ')
                    endif
      call srlin (3,lsn,lixx,ljxx,lkxx,llxx)
      if(lixx.gt.0) then
                      call yfl03
                      write(lo,96) nk
                    endif
   96 format(26x,i6,' atomic species')
      call srlin (7,lsn,lixx,ljxx,lkxx,llxx)
      if(lixx.gt.0) then
                      call ysfl07(nrifl,mmm,mmmz,npseud,iy)
                      if (jpart.gt.0) write(lo,160)
                      if (npseud.gt.0) write(lo,140)
                      if (sc.lt.0.0) then
                                       write(lo,150)nrifl
                                     else
                                       write(lo,155)nrifl
                                     endif
                    endif
  140 format(32x,' pseudotranslational information')
  150 format(26x,i6,' not normalized reflections ')
  155 format(26x,i6,' normalized reflections ')
  160 format(32x,' fragment information')
      iprea=0
      call srlin (26,lsn,lfw,llw,lpb,ll)
      if(lfw.gt.0) then
      call sflxx(iprea,26,nsem1g,nsem1g,nstron,nxxe,iccd,mat)
      write(lo,244) nsem1g
                   endif
  244 format(26x,i6,' one phase seminvariants ')
      call srlin (27,lsn,lfw,llw,lpb,ll)
      if(lfw.gt.0) then
      call sflxx(iprea,27,nsem2,nsem2,nstron,nxxe,iccd,mat)
      write(lo,254) nsem2
                   endif
  254 format(26x,i6,' two phase seminvariants')
      call srlin (9,lsn,lfw,llw,lpb,ll)
      if(lfw.gt.0) then
      call sflxx(iprea,9,nps,nps,nrefp,nxxe,iccd,mat)
      write(lo,2500) nps
 2500 format(26x,i6,' psi-zero triplets ')
                   endif
      call srlin (24,lsn,lfw,llw,lpb,ll)
      if(lfw.gt.0) then
      call sflxx(iprea,24,ntot,ntrp,nreft,nxxe,iccd,mat)
      write(lo,6010) ntot
                   endif
 6010 format(26x,i6,' psi-e triplets')
      call srlin (8,lsn,lfw,llw,lpb,ll)
      if(lfw.gt.0) then
      call sflxx(iprea,8,ntot,ntrp,nreft,nxxe,iccd,mat)
      write(lo,4010) ntrp
                   endif
 4010 format(26x,i6,' positive triplets')
      call srlin (11,lsn,lfw,llw,lpb,ll)
      if(lfw.gt.0) then
      call sflxx(iprea,11,ntre,ntre,nreft,nxxe,iccd,mat)
      write(lo,4510) ntre
                   endif
 4510 format(26x,i6,' enantiomorph sensitive triplets')
      call srlin (10,lsn,lfw,llw,lpb,ll)
      if(lfw.gt.0) then
      call sflxx(iprea,10,ntrn,ntrn,nreft,nxxe,iccd,mat)
      write(lo,5010) ntrn
                   endif
 5010 format(26x,i6,' negative triplets')
      call srlin (20,lsn,lfw,llw,lpb,ll)
      if(lfw.gt.0) then
      call sflxx(iprea,20,nqn,nqn,nrefp,nxxe,iccd,mat)
      write(lo,5020) nqn
                   endif
 5020 format(26x,i6,' negative quartets ')
      call srlin (21,lsn,lfw,llw,lpb,ll)
      if(lfw.gt.0) then
      call sflxx(iprea,21,nqen,nqen,nrefp,nxxe,iccd,mat)
      write(lo,5030) nqen
                   endif
 5030 format(26x,i6,' enantiomorph sensitive quartets ')
      call srlin (16,lsn,lfw,llw,lpb,ll)
      if(lfw.gt.0) then
      call ysfl16(cfom,ipos,nset)
      write(lo,5040) nset
                   endif
 5040 format(26x,i6,' sets of phases')
      call srlin (15,lsn,lfw,llw,lpb,ll)
      if(lfw.gt.0) then
      idisp=1
      call sfl15(nats,idisp,numset,interp)
      if (numset.gt.0) then
                         write(lo,5050) nats,numset
                       else
                         write(lo,5060) nats
                       endif
                   endif
 5050 format(26x,i6,' coordinates related to set no.',i4)
 5060 format(26x,i6,' Patterson''s peaks')
      return
      end
c-----------------------------------------------------------------------
      subroutine histor(nfield,ivalue,ier)
c
c-- this subroutine is used to get the story of different
c-- attemps solving the actual structure
c
c     nfield = 1   information about pseudotranslational symmetry
c                  ( ivalue=0 if absent, ivalue= n if it exists with
c                    a percentage value of n , ivalue = -n if used )
c            = 2   information about partial procedure
c                  ( ivalue=1 if used , ivalue=0 otherwise )
c            = 3   number of symbols used
c            = 4   information about the use of seminvariants
c                  ( ivalue=1 if used , ivalue=0 otherwise )
c            = 5   information about the use of mess
c                  ( ivalue=1 if used , ivalue=0 otherwise )
c            = 6 - 16   not used
c
      character*80 filen
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
              if (kenvir.eq.0) then  
c-- standard sir91 environment
                                 kstory(nfield)=ivalue
         else if (kenvir.eq.1) then  
c-- enraf-nonius environment
c-- update the 170-th record (16 words lenght)
c-- in the master file for enraf-nonius implementation
c-- the record is red into kstory array, updated and rewritten
                                 namel=9
                                 filen(1:namel)='struc.nme'
                                 nrec=170
                                 jnon=30
                                 itipe=0
                                 nonius=16
         if (kopen(jnon,filen(1:namel),nonius,itipe,ierr).ge.0) then    
            read (jnon,rec=nrec,err=100,iostat=ierr) (kstory(i),i=1,16)
                                    kstory(nfield)=ivalue
            write(jnon,rec=nrec,err=120,iostat=ierr) (kstory(i),i=1,16)
                                    close(jnon)
                                  else
                                    ier=-1
                                    write(lo,90) ierr,filen(1:namel)
                                  endif
         else if (kenvir.eq.2) then  
                                 kstory(nfield)=ivalue
                               endif
      return
   90 format(' error ',i5,'  opening file ',a)
  100 ier=-1
      write(lo,110) ierr,nrec,filen(1:namel)
  110 format(' error ',i5,' reading record no. ',i3,' in file ',a)
      return
  120 ier=-1
      write(lo,130) ierr,nrec,filen(1:namel)
  130 format(' error ',i5,' writing record no. ',i3,' in file ',a)
      return
      end
c--------------------------------------------------------------------
      subroutine unpak3(index,kod1,kod2,ifaz)
      isave=index/32
      ifaz=index-isave*32 -1
      kod1=isave/4096
      kod2=isave-4096*kod1-2048
      kod1=kod1-2048
      return
      end
c-----------------------------------------------------
      subroutine besse(xx,vec)
c--bessel function
c
      x=abs(xx)
      vec=amin1((x+0.4807)*x/((x+0.8636)*x+1.3943),1.0)
      if (xx.lt.0.0) vec=-vec
      return
      end
c     ------------------------------------------------------------------
      subroutine musym(smat,tmat,n2,is,ts)
      integer is(2,3,24),smat(48,3,3)
      dimension ts(3,24),tmat(48,3)
c
c-----------------------------------------------------------------------
c
c     purpose
c             conversion of matricies in multan notation
c
c     usage
c             call musym(smat,tmat,n2,is,ts)
c
c     description of parameters
c
c             smat - 3-dimensionale array containing the rotational
c                    matricies computed by subroutine symm
c             tmat - bidimensional array containing the traslational
c                    matricies computed by subroutine symm
c             n2   - number of symmetry operators not related by
c                    a centre of symmetry
c             is   - 3-dimensional array containing the rotational
c                    matricies in multan notation
c             ts   - bidimensional array containing the traslational
c                    matricies in multan notation
c
c-----------------------------------------------------------------------
c
      do 10  j=1,2
      do 10 ja=1,3
      do 10 jb=1,n2
      is(j,ja,jb)=0
      ts(  ja,jb)=0
   10 continue
      do 50 jc=1,n2
      do 30  l=1,3
      m=1
      do 20  i=1,3
      if (smat(jc,l,i).eq.0) go to 20
      is(m,l,jc)=smat(jc,l,i)*i
      m=2
   20 continue
   30 continue
      do 40 ja=1,3
      ts(ja,jc)=tmat(jc,ja)
   40 continue
   50 continue
      return
      end
c-----------------------------------------------------------------------
      subroutine sir_unpack (index,ih,kk,il)
      ih = index/262144
      is = index - 262144*ih
      kk = is/512-256
      il = is-512*(kk+256)-256
      return
      end
c ----------------------------------------------------------------------
      function bes(x)
      is=1
      if(x.lt.0.0) is=-1
      x1=abs(x)
      if(x1.lt.0.000001)  go to 200
      if(x1.le.2.9) go to 180
      if(x1.le.7.5) go to 160
      if(x1.le.20.) go to 140
      if(x1.le.39.) go to 120
      if(x1.le.45.) go to 100
      if(x1.le.55.) go to  80
      if(x1.le.65.) go to  60
      if(x1.le.80.) go to  40
      if(x1.le.99.) go to  20
      bes=1.*is
      return
   20 bes=0.0000631*x1+.988652
      bes=abs(bes)*is
      return
   40 bes=0.0000933*x1+.9862355
      bes=abs(bes)*is
      return
   60 bes=0.00014*x1+.9832
      bes=abs(bes)*is
      return
   80 bes=0.00021*x1+.97935
      bes=abs(bes)*is
      return
  100 bes=0.0000666*x1+.9858026
      bes=abs(bes)*is
      return
  120 bes=0.9459 +0.00187*x1-0.00002*x1*x1
      bes=abs(bes)*is
      return
  140 bes=0.82227+0.02189*x1-0.00114*x1*x1+0.00002*x1*x1*x1
      bes=abs(bes)*is
      return
  160 bes=0.444+0.19096*x1-0.02697*x1*x1+0.00135*x1*x1*x1
      bes=abs(bes)*is
      return
  180 bes=-0.00718+0.5668*x1-0.12287*x1*x1 +0.008*x1*x1*x1
      bes=abs(bes)*is
      return
  200 bes=0.
      return
      end
c ----------------------------------------------------------------------
      function besinv(y)
      if (abs(y).lt.0.000001)  go to  200
      if (y.le.0.6989)  go to 180
      if (y.le.0.8666) go to 160
      if (y.le.0.9259)  go to 140
      if (y.le.0.9553)  go to 120
      if (y.le.0.9635)  go to 100
      if (y.le.0.9884) go to 90
      if (y.le.0.9888) go to 80
      if (y.le.0.9909) go to 70
      if (y.le.0.9923) go to 60
      if (y.le.0.9937) go to 50
      if (y.le.0.9949) go to 40
      besinv=100.
      return
   40 besinv=15833.333*y-15653.583
      return
   50 besinv=10714.285*y-10566.785
      return
   60 besinv=7142.8571*y-7022.8571
      return
   70 besinv=4761.9047*y-4663.5713
      return
   80 besinv=15000*y-14787
      return
   90 besinv=49773.46954-102737.23532*y+53033.83171*y*y
      return
  100 besinv=77576.4096-162332.52722*y+84935.62155*y*y
      return
  120 besinv=3117.15834-6767.58257*y+3681.64105*y*y
      return
  140 besinv=486.69735-1127.7574*y+658.80603*y*y
      return
  160 besinv=-82.06253+344.25645*y-478.71058*y*y+226.35886*y*y*y
      return
  180 besinv=-0.00252+2.1065*y-1.12674*y*y+3.09414*y*y*y
      return
  200 besinv=0
      return
      end
c-----------------------------------------------------------------------
code for sortz
      subroutine sortz(lind,numb,iblk,jump)
c--sort the data in store
c
c  lind  addres in store
c  numb  number of block of data to be sorted
c  iblk  block lenght of the data (i.e. number of items per block)
c  jump  < 0 sort in decreasing order
c  jump  > 0 sort in increasing order
c  iabs(jump) = relative addres of the key of sort
c
      common /xdata/ store(244000)
c
      jsig=1
      if (jump.lt.0) then
                       jump=iabs(jump)
                       jsig=-1
                     endif
      if (numb.eq.1) return
      jump=jump-1
      ja=2
2010  continue
      jb=numb/ja
      if(jb) 2020,2020,2030
2020  continue
      jb=1
2030  continue
      jc=numb-jb
2040  continue
      jd=0
      m=lind
      do 2070 i=1,jc
      mk=m+jb*iblk
      if ((store(m+jump)-store(mk+jump))*jsig) 2060,2060,2050
 2050 continue
      mm=m
      mmk=mk
      do 2055 je=1,iblk
      f=store(mm)
      store(mm)=store(mmk)
      store(mmk)=f
      mm=mm+1
      mmk=mmk+1
 2055 continue
      jd=1
 2060 continue
      m=m+iblk
 2070 continue
      if (jd) 2080,2080,2040
 2080 continue
      if (jb-1) 2100,2100,2090
 2090 continue
      ja=ja*2
      go to 2010
 2100 continue
      return
      end
c-----------------------------------------------------
      subroutine stst
c--print the test (centro)
      common/tst/nt,ar(26),nn(11,26,3),pp(11,26,3)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common /inp/  natom,fnat,satm,atoms
      common/prin/ ipt,ip0,ip10,ipq
      common /pseud/ kmat(48,3,3),emme,patom,qatom,npseud,lpseud(4,3)
     1         ,scale,jmme,prod,prod2,mjn(5,11),njn,coef,nw(8),no(8)
      dimension pa(11,26,3)
c
      write(lo,1000)
 1000 format(/,' number of relations(nr),number of correct rel.',
     2'(nc) and percentage(%) of correct relationship ')
      write(lo,1001)
 1001 format(///)
      write(lo,1010)
 1010 format(14x,'rel.posit.',20x,'rel.negat.',//,
     2 1x,5h arg.,2(9x,3hnr.,4x,3hnc.,4x,1h%,2x),/)
      do 1030 l=1,2
      do 1020 i=1,nt
      if (nn(1,i,l).gt.0) then
                            fn=float(nn(1,i,l))
                            pa(1,i,l)=pp(1,i,l)*100.0/fn
                          else
                            pa(1,i,l)=0.0
                          endif
 1020 continue
 1030 continue
      do 1050 i=1,nt
      if (nn(1,i,1).eq.0.and.nn(1,i,2).eq.0) go to 1050
      write(lo,1040)ar(i),(nn(1,i,l),pp(1,i,l),pa(1,i,l),l=1,2)
 1040 format(f5.1,2(5x,i7,2f7.1))
 1050 continue
      return
      end
c--------------------------------------------------
      subroutine nstst
c--print the test (non-centro)
c
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common /inp/  natom,fnat,satm,atoms
      common/prin/ ipt,ip0,ip10,ipq
      common /pseud/ kmat(48,3,3),emme,patom,qatom,npseud,lpseud(4,3)
     1         ,scale,jmme,prod,prod2,mjn(5,11),njn,coef,nw(8),no(8)
      common /nctst/ ns,br(15),nb(11,15,3),fnb(11,15,3),bcm(11,15,3),
     *                        acm(11,15,3)
c
      write(lo,1000)
1000  format(' number of relationships(nr), percentages(%) of correct si
     *gns',/,' average errors in relationships')
      write(lo,1001)
 1001 format(///)
      en=float(mjn(1,1))/10.0
      write(lo,1010)
 1010 format(20x, 'positive rel.',25x,'negative rel.')
      write(lo,1020)
 1020 format(3x,2hg ,1x,2(8x,'nr.    %     <|phi|>         '),//)
      do 1100 j=1,3
      do 1090 i=1,ns
      if(nb(1,i,j)) 1090,1090,1030
 1030 continue
      fn=1.0/float(nb(1,i,j))
      fnb(1,i,j)=fnb(1,i,j)*fn*100.0
      bcm(1,i,j)=bcm(1,i,j)*fn
 1090 continue
 1100 continue
      do 1110 i=1,ns
*     do 1105 j=1,2
*     if (nb(1,i,j).gt.0) then
*                   arg=rtod*atan2( acm(1,i,j) , bcm(1,i,j))
*                   arg=rtod*atan( acm(1,i,j) / bcm(1,i,j))
*                   arg=amod(arg+3600.0,360.0)
*                   if (arg.gt.180.0) arg=360-arg
*                   bcm(1,i,j)=arg
*                 endif
*1105 continue
      write(lo,1120) br(i),(nb(1,i,j),fnb(1,i,j),bcm(1,i,j),j=1,2)
 1120 format(f5.1,3(5x,i7,f7.1,f9.3,9x))
 1110 continue
      return
      end
c------------------------------------------------------
      subroutine nctet(aa,cc,ang,j)
c--test for the correct coincidence (non-centro)
c
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /nctst/ ns,br(15),nb(11,15,3),fnb(11,15,3),bcm(11,15,3),
     *                        acm(11,15,3)
c
      if (aa.lt.0.0) then
                       kk=2
                     else
                       kk=1
                     endif
      bb=abs(aa)
      do 1100 i=1,ns
      ii=i
      if(br(i)-bb) 1020,1020,1200
1020  continue
       nb(j,ii,kk)= nb(j,ii,kk)+1
      bcm(j,ii,kk)=bcm(j,ii,kk)+ang
      a=aa*cc
      if(a) 1100,1030,1030
1030  continue
      fnb(j,ii,kk)=fnb(j,ii,kk)+1.0
1100  continue
1200  continue
      return
      end
c--------------------------------------------------------
      subroutine nclrt
c--prepare the test buffer (non-centro)
c
      common /nctst/ ns,br(15),nb(11,15,3),fnb(11,15,3),bcm(11,15,3),
     *                        acm(11,15,3)
c
      ns=15
      br(1)=0.0
      do 1100 i=2,6
      br(i)=br(i-1)+0.4
1100  continue
      do 1110 i=7,10
      br(i)=br(i-1)+0.6
1110  continue
      br(11)=5.5
      br(12)=6.5
      br(13)=9.0
      br(14)=15.0
      br(15)=20.0
      do 1140 k=1,11
      do 1140 j=1,3
      do 1150 i=1,ns
      nb (k,i,j)=0
      fnb(k,i,j)=0.0
      bcm(k,i,j)=0.0
      acm(k,i,j)=0.0
1150  continue
1140  continue
      return
      end
c-----------------------------------------------------
      subroutine clrt
c--prepare the test buffer (centro)
      common/tst/nt,ar(26),nn(11,26,3),pp(11,26,3)
      ar( 1)=.0
      ar( 2)=.2
      ar( 3)=.4
      ar( 4)=.6
      ar( 5)=.8
      ar( 6)=1.
      ar( 7)=1.2
      ar( 8)=1.4
      ar( 9)=1.6
      ar(10)=2.
      ar(11)=2.4
      ar(12)=2.8
      ar(13)=3.2
      ar(14)=3.4
      ar(15)=3.8
      ar(16)=4.2
      ar(17)=4.6
      ar(18)=5.0
      ar(19)=5.5
      ar(20)=6.0
      ar(21)=6.5
      ar(22)=7.
      ar(23)=7.5
      ar(24)=8.0
      ar(25)=8.5
      ar(26)=9.0
      nt=26
      do 100 k=1,11
      do 100 l=1,3
      do 200 i=1,nt
      nn(k,i,l)=0
      pp(k,i,l)=0
 200  continue
 100  continue
      return
      end
c----------------------------------------------------------
      subroutine sctst(aa,cc,j)
c--test for the correct coincidence (centro)
      common/tst/nt,ar(26),nn(11,26,3),pp(11,26,3)
c
      if(aa.lt.0) then
                    k=2
                  else
                    k=1
                  endif
      bb=abs(aa)
      do 1100 i=1,nt
      if(ar(i)-bb)1020,1020,1200
 1020 continue
      nn(j,i,k)=nn(j,i,k)+1
      if(cc)1100,1030,1030
 1030 continue
      pp(j,i,k)=pp(j,i,k)+1.0
 1100 continue
 1200 continue
      return
      end
c----------------------------------------------------------------------
      subroutine ucase(line)
      character*(*) line
      character*52 ulc
      common /ulcase/ ulc
      character a
c
      k=len(line)
      do 20 i=1,k
      a=line(i:i)
      l=0
      do 10 j=1,26
      if (a.eq.ulc(j:j)) l=j
   10 continue
      if (l.ne.0) line(i:i)=ulc(l+26:l+26)
   20 continue
      return
      end
c----------------------------------------------------------------------
      subroutine lcase(line)
      character*(*) line
      character*52 ulc
      common /ulcase/ ulc
      character a
c
      k=len(line)
      do 20 i=1,k
      a=line(i:i)
      l=0
      do 10 j=27,52
      if (a.eq.ulc(j:j)) l=j
   10 continue
      if (l.ne.0) line(i:i)=ulc(l-26:l-26)
   20 continue
      return
      end
c-----------------------------------------------------------------------
      subroutine wrhead
      character str*80,messh*80
      character fname(9)*80,ext(9)*4
      common/dotdat/ fname,ext
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
c
c-- write the Header
c
      k=index(fname(1),'.')
      call sirdate(str,icod)
      if (icod.eq.0) then
          messh=' SIR92 exec on:   '//fname(1)(1:k-1)
        else
          messh=str(1:icod)//' SIR92 exec on:   '//fname(1)(1:k-1)
        endif
c
      write(lo,10) messh
   10 format(1h ,a,//)
c
      return
      end

CRYSTALS CODE FOR XWIN
      subroutine xwin(ixv,iyv,iiz,ind,string,iicol )
      
      
c--   ind : action
c--    0  : close the window
c--    1  : open Xwindow(0: *x, 0: *y )
c--    2  : draw to *x, *y
c--    3  : reset menu and top window                      ++++++++++++
c--    5  : eventloop (mouse)
c--    6  : clear screen
c--    7  : xflush
c--    8  : set switches to default value                  ++++++++++++
c--    9  : draw string (iiz chars) in position iix,iiy
c--   10  : draw circle (iiz radius) center in iix,iiy
c--   11  : fill circle (iiz radius) center in iix,iiy
c--   12  : set foreground color to iicol
c--   13  : draw iiz-points polygon using color iicol
c--   14  : fill iiz-points polygon using color iicol
c--   15  : print a message at the bottom of the window
c--   16  : store atomic species in static array
CHANGE RIC-OX-98:
c--   17  : close window.
#if defined(_DVF_) || defined (_GID_)
      USE DFLIB
      USE DFWIN
      INTEGER*2 RES
      logical*4 status
      type (windowconfig)wc
      type (qwinfo)win
      TYPE (xycoord) xy
      TYPE (xycoord) poly(100)
#endif
      integer GraphicsHandle
      save  GraphicsHandle
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_)
      integer CreateRootWindow
#endif

      character *(*) string
      character messaggio*80 ,Species(8)*2, File*12
      character *80 Titolo
      character*14 strbox, strapp
      character fname(9)*80,ext(9)*4
      common/dotdat/ fname,ext
      common /screen/ kscreen,jy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      COMMON /Contr/ NF,iFirstTime,Titolo,Ratio,IfCont,IfEdge,IfScale,
     *               kplty,radii(8),IfScaleB
      common/xwi/ color,xo,yo,khead,Species,NumSpec,ihcopy,ipres,jpres
      common /cmenu/ xbox(78),ybox(78),lbox(78),strbox(78),nbox,nboxt,
     +               nbox0,nboxn,ColTast,strapp(11)
      common /scale/ x11scale(2),x11disp(2),ragmed,deltax,deltay
      common /mess/ Message,ifMess,lMess
      character *80 Message
c
      real*4 size,rot,ita
      integer*2 type,ix,iy,iz,ix1,iy1,icol,font,color,xo,yo,iz1
      integer*2 ixv2(100),iyv2(100),err,khead,widb,heib
#if defined(_DOS_) 
      integer*2 handle
#endif
      
      integer ixv(100),iyv(100)
      integer *2 cursor_def(32),button_status,ColTast
      integer *2 ix2,iy2,iwid,ihei, idev, error_code
      common /cmouse/ cursor_def
#if defined(_DOS_) 
      include <windows.ins>
#endif
c
CHANGE Assign further down, when we're sure it will be used:  icol=iicol
c
      ix=ixv(1)
      iy=iyv(1)
      iz=iiz
c
      if (ind.eq.-1) then
                     ind=-1
      else if (ind.eq.0) then
#if defined(_DOS_) 
         call text_mode@
#endif
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_) 
         call closedisplay
#endif
      else if (ind.eq.1) then
c         call screen_type@(type)
c         if (type.eq.3) then
c            call vga@
c         else
c            if (type.eq.2) then
c               call ega@
c               kscrx=639
c               kscry=349
c            else
c               call text_mode@
c               iiz=-1
c               return
c            endif
c         endif
      GraphicsHandle=-1
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_) 
      GraphicsHandle = CreateRootWindow(30, 30, ix, iy, 1, 
     1    'Sir92')
      call selectwindow(GraphicsHandle)
#endif
#if defined(_DOS_) 
      i=winio@('%ca[Sir92 Native 32-bit]&')
      i=winio@('%sp&',0,0)
      i=winio@('%bg[black]&')
      i=winio@('%gr[black]%lw',ixv,iyv, GraphicsHandle)
#endif
#if defined(_DVF_) || defined (_GID_)
      wc.numtextcols=80
      wc.numtextrows=30
      wc.title='Altomare et al. (1994) J. Appl. Cryst. 27, 435'
      wc.numxpixels=650
      wc.numypixels=480
      i = GetWindowLong( GetHWndQQ(QWIN$FRAMEWINDOW), GWL_STYLE )
      i = ior( iand( i, not(WS_THICKFRAME) ), WS_BORDER )
      i = iand( i, not(WS_SYSMENU) )
      k = SetWindowLong( GetHWndQQ(QWIN$FRAMEWINDOW), GWL_STYLE, i )    
      i = GetWindowLong( GetHWndQQ(0), GWL_STYLE )
      i=ior(iand(i,not(WS_CAPTION.or.WS_SYSMENU.or.WS_THICKFRAME)),
     1    WS_BORDER)
      k = SetWindowLong( GetHWndQQ(0), GWL_STYLE, i )     
11    DO I = 7,1,-1
         II = DELETEMENUQQ(I, 0)
      END DO
      win.x = 0
      win.y = 0
      win.w = 640
      win.h = 480
      win.type=qwin$set
      dummy4 = setwsizeqq(qwin$framewindow,win)
      status = getwsizeqq(QWIN$FRAMEWINDOW,QWIN$SIZECURR, win)
      status=setwindowconfig(wc)
      if(.not.status)status=setwindowconfig(wc)
      i = MoveWindow( GetHWndQQ(0), 0, 0, 740, 590, .TRUE.) 
      call clearscreen($GCLEARSCREEN)
      status = UpdateWindow(GETHANDLEFRAMEQQ())    
      I=SETEXITQQ(QWIN$EXITNOPERSIST)
      RES = INITIALIZEFONTS()
      RES = SETFONT('t''Courier''efh14w8b')
#endif

         Titolo = string
         deltax = 80
         deltay = 20
         size=1.0
         font=1
         rot=0.0
         ita=0
c         call set_text_attribute@(font,size,rot,ita)
c         call clear_screen@
c         call initialise_mouse@
c         call set_mouse_position@(kscrx/2+40,kscry/2+10)
         ix = 81
         iy = 0
         ix1 = kscrx
         iy1 = 20
         iwid = kscrx-ix
         ihei = iy1
         icol = 3
         ColTast = icol
#if defined(_DOS_) 
         call fill_rectangle@(ix,iy,ix1,iy1,icol)
#endif
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_) 
         call fill_rectangle(ix,iy,ix1,iy1,icol)
#endif
#if defined(_DVF_) || defined (_GID_)
         RES= SETCOLOR ( icol )
         RES= RECTANGLE ($GFILLINTERIOR,ix,iy,ix1,iy1)
#endif
         kact = 1
         call Tasto (ix,iy,iwid,ihei,kact,1)
         ix = 0
         ix1 = 80
         iy = 0
#if defined(_DOS_) 
         call fill_rectangle@(ix,iy,ix1,iy1,icol)
#endif
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_) 
         call fill_rectangle(ix,iy,ix1,iy1,icol)
#endif
#if defined(_DVF_) || defined (_GID_)
         RES= SETCOLOR ( icol )
         RES= RECTANGLE ($GFILLINTERIOR,ix,iy,ix1,iy1)
#endif
         iwid = 80
         call Tasto (ix,iy,iwid,ihei,kact,1)
         icol = 4
         ix = 4
         iy = 4
         kkprog = mod ( kprog , 10 )
         if (kkprog.eq.1) then
            messaggio = '  SIR92'
            lm = 7
         else
            messaggio = 'SIRPOW.92'
            lm = 9
         end if
#if defined(_DOS_) 
          call draw_text@(messaggio(1:lm),ix,iy,icol)
#endif
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_) 
          call draw_text(messaggio(1:lm),ix,iy,icol)
#endif
#if defined(_DVF_) || defined (_GID_)
          RES= SETCOLOR ( icol )
          CALL MOVETO(ix,iy,xy)
          CALL OUTGTEXT(messaggio(1:lm))
#endif
         ix = 84
         iy = 4
         messaggio = string(1:iz)
#if defined(_DOS_) 
         call draw_text@(messaggio(1:iz),ix,iy,icol)
#endif
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_) 
         call draw_text(messaggio(1:iz),ix,iy,icol)
#endif
#if defined(_DVF_) || defined (_GID_)
          RES= SETCOLOR ( icol )
          CALL MOVETO(ix,iy,xy)
          CALL OUTGTEXT(messaggio(1:iz))
#endif
         khead = 1
         kact = 1
      else if (ind.eq.2) then
         ix1=ixv(2)
         iy1=iyv(2)
         if (ix.le.deltax.or.ix1.le.deltax) khead = 1
         if (iy.le.deltay.or.iy1.le.deltay) khead = 1
#if defined(_DOS_) 
         call draw_line@(ix,iy,ix1,iy1,color)
#endif
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_) 
         call draw_line(ix,iy,ix1,iy1,color)
#endif
#if defined(_DVF_) || defined (_GID_)
         RES= SETCOLOR ( color )
         CALL MOVETO(ix,iy,xy)
         RES= LINETO(ix1,iy1)
#endif

      else if (ind.eq.3) then
         ix = 81
         iy = 0
         ix1 = kscrx
         iy1 = 20
         iwid = kscrx-ix
         ihei = iy1
         icol = 3
         ColTast = icol
#if defined(_DOS_) 
         call fill_rectangle@(ix,iy,ix1,iy1,icol)
#endif
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_) 
         call fill_rectangle(ix,iy,ix1,iy1,icol)
#endif
#if defined(_DVF_) || defined (_GID_)
         RES= SETCOLOR ( icol )
         RES= RECTANGLE ($GFILLINTERIOR,ix,iy,ix1,iy1)
#endif
         kact = 1
         call Tasto (ix,iy,iwid,ihei,kact,1)
         icol = 4
         ix = 84
         iy = 4
#if defined(_DOS_) 
         call draw_text@(Titolo,ix,iy,icol)
#endif
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_) 
         call draw_text(Titolo,ix,iy,icol)
#endif
#if defined(_DVF_) || defined (_GID_)
         RES= SETCOLOR ( icol )
         CALL MOVETO(ix,iy,xy)
         CALL OUTGTEXT(Titolo)
#endif
      else if (ind.eq.5) then
         if (khead.eq.1 .and. ihcopy.ne.1 .and. ipres.eq.0) then
            call DrawMenu(Iz)
         end if
         if (ihcopy.eq.1) then
#if defined(_DOS_) 
            call NEW_PAGE@
            call CLOSE_GRAPHICS_PRINTER@
#endif
            ihcopy = 0
            kscrx = 639
            kscry = 479
            Ratio = float(kscrx - 80) / float(kscry - 20)
            iiz = -(nbox - 10)
            call ClearMessage
            return
         end if
         call display_mouse_cursor
         khead = 0
         if (ipres.gt.0) then
            i = ipres
            goto 210
         end if
 200     call Sorcio(ix,iy,button_status)

         i = kebox(ix,iy)
         iz = i
         if (i.lt.0) go to 200
c
          call drawtasto(i+10)
*        ix = xbox(i+10) - 10+1
*        iy = ybox(i+10) - 30+1
*        widb = lbox(i+10)-2
*        heib = 20-2
*        kact = 1
*        call Tasto (ix,iy,widb,heib,kact,2)
*         icol=1
*         ix=ix-1
*         iy=iy-1
*         ix1=ix+widb+2
*         iy1=iy+heib+2
*         call rectangle@(ix,iy,ix1,iy1,icol)
*         call rectangle(ix,iy,ix1,iy1,icol)
c
  210    iiz=Iz
         if ( i .eq. 19 ) then        !  Cell edges on/off
            if ( IfEdge .eq. 0 ) then
               strbox(29) = strapp(1)
            else
               strbox(29) = strapp(2)
            endif
            call drawtasto(29)
         endif
         if ( i .eq. 20 ) then        !  Cell content on/off
            if ( IfCont .eq. 0 ) then
               strbox(30) = strapp(3)
               call ClearMessage
               messaggio = 'Running. Please wait...'
               Iz = 23
               icol = 14
               ix = 85
               iy = kscry - 20
#if defined(_DOS_) 
               call draw_text@(messaggio(1:Iz),ix,iy,icol)
#endif
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_) 
               call draw_text(messaggio(1:Iz),ix,iy,icol)
#endif
#if defined(_DVF_) || defined (_GID_)
               RES= SETCOLOR ( icol )
               CALL MOVETO(ix,iy,xy)
               CALL OUTGTEXT(messaggio(1:Iz))
#endif
            else
               strbox(30) = strapp(4)
            endif
            call drawtasto(30)
         endif
         if ( i .eq. 21 ) then
            if ( IfScale .eq. 3 ) then
               strbox(31) = strapp(5)
            else
               strbox(31) = strapp(6)
            endif
            call drawtasto(31)
         endif
         if ( i .eq. 22 )  then       !  Delete atom
#if defined(_DOS_) 
            call sleep@(0.1)
#endif
            NumMsg = 1
            iact = 0
            call SelectAtms(ixv,iyv,iact,NumMsg)
            if(iact.lt.0) goto 200
            goto 555
         endif
         if ( i .eq. 23 ) then     !  Select
            Call Seleziona (ixv,iyv,iact)
            if (iact.lt.0) goto 200
            if (iact.eq.1) iiz = -23
            if (iact.eq.3) iiz = 223
            if (iact.eq.4) iiz = 123
         end if
         if ( i .eq. 24 ) then     !  View plane
            iz = 4
2423        call DrawMenu(iz)
            call display_mouse_cursor
c
            color = 7
 2424       call Sorcio(ix,iy,button_status)
c
            j = kebox(ix,iy)
            iiz = j - 7
            if (j.lt.0) goto 2424
            call drawtasto(j+10)
            if(j.eq.(nbox-10)+ 16) then
               call hide_mouse_cursor        ! More ...
               call ClearMessage
               iz = 4
               goto 2423
            else if(j.eq.(nbox-10) + 11) then
               call hide_mouse_cursor        ! More ...
               call ClearMessage
               iz = 5
               goto 2423
            else if(j.eq.(nbox-10) + 12 .or. j.eq.(nbox-10) + 17) then
               call hide_mouse_cursor        ! Cancel
               call ClearMessage
               khead = 0
               nbox0  = 1
               nboxn  = nbox
               ColTast = 3
c               iz = 0
c               call DrawMenu(iz)
               call display_mouse_cursor
               goto 200
            end if
            nbox0  = 1
            nboxn  = nbox
            ColTast = 3
c            iz = 0
c            call DrawMenu(iz)
         end if
         if ( i .eq. 25 ) then        !  Relabel
#if defined(_DOS_) 
            call sleep@(0.1)
            call ClearMessage
            messaggio = 'Click on atom to Relabel'
#endif
            Iz = 24
            icol = 14
            ix = 85
            iy = kscry - 20
#if defined(_DOS_) 
            call draw_text@(messaggio(1:Iz),ix,iy,icol)
#endif
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_) 
            call draw_text(messaggio(1:Iz),ix,iy,icol)
#endif
#if defined(_DVF_) || defined (_GID_)
            RES= SETCOLOR ( icol )
            CALL MOVETO(ix,iy,xy)
            CALL OUTGTEXT(messaggio(1:Iz))
#endif
            iz = 6
            call DrawMenu(iz)
            call display_mouse_cursor
            
            color = 7
            call Sorcio(ix,iy,button_status)
c
            i = kebox(ix,iy)
            iz = i
            if (i.gt.0) then
               call ClearMessage
               nbox0  = 1
               nboxn  = nbox
               ColTast = 3
c              iz = 0
c              call DrawMenu(iz)
               goto 200
            end if
c
            ixv(1) = ix
            iyv(1) = iy
            call ClearMessage
            messaggio = 'Select new atomic Specie'
            Iz = 24
            icol = 14
            ix = 85
            iy = kscry - 20
#if defined(_DOS_) 
            call draw_text@(messaggio(1:Iz),ix,iy,icol)
#endif
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_) 
            call draw_text(messaggio(1:Iz),ix,iy,icol)
#endif
#if defined(_DVF_) || defined (_GID_)
            RES= SETCOLOR ( icol )
            CALL MOVETO(ix,iy,xy)
            CALL OUTGTEXT(messaggio(1:Iz))
#endif
            size=1.0
            font=1
            rot=0.0
            ita=0
#if defined(_DOS_) 
            call set_text_attribute@(font,size,rot,ita)
#endif
            kact = 0
            widb=25
            heib=20
            ix = 300
            iy = kscry - 25
            iy1 = iy + heib
            do 500 i = 1 , NumSpec
               ix = ix + widb + 10
               ix1 = ix + widb
               icol = i
               ColTast = icol
#if defined(_DOS_) 
               call fill_rectangle@(ix,iy,ix1,iy1,icol)
#endif
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_) 
               call fill_rectangle(ix,iy,ix1,iy1,icol)
#endif
#if defined(_DVF_) || defined (_GID_)
               RES= SETCOLOR ( icol )
               RES= RECTANGLE ($GFILLINTERIOR,ix,iy,ix1,iy1)
#endif
               call Tasto (ix,iy,widb,heib,kact,3)
               icol=1
#if defined(_DOS_) 
               call rectangle@(ix,iy,ix1,iy1,icol)
#endif
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_) 
               call rectangle(ix,iy,ix1,iy1,icol)
#endif
#if defined(_DVF_) || defined (_GID_)
               RES= SETCOLOR ( icol )
               RES= RECTANGLE ($GBORDER,ix,iy,ix1,iy1)
#endif
               if(ColTast.ne.4 .and. ColTast.ne.1) then
                  icol=4
               else
                  icol=7
               end if
               ix2=ix+4
               iy2=iy+2
#if defined(_DOS_) 
               call draw_text@(Species(i),ix2,iy2,icol)
#endif
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_) 
               call draw_text(Species(i),ix2,iy2,icol)
#endif
#if defined(_DVF_) || defined (_GID_) 
               RES= SETCOLOR ( icol )
               CALL MOVETO(ix2,iy2,xy)
               CALL OUTGTEXT(Species(i))
#endif
  500       continue
            size=1.0
            font=1
            rot=0.0
            ita=0
#if defined(_DOS_) 
            call set_text_attribute@(font,size,rot,ita)
#endif
  600       call Sorcio(ix,iy,button_status)
 
            i = kespec(ix,iy,NumSpec)
            if (i.lt.0) go to 600
            iyv(2) = i
c
            ix = 300
            iy = kscry - 25
            iy1 = iy + heib
            do 700 j = 1 , i
               ix = ix + widb + 10
               ix1 = ix + widb
  700       continue
            kact = 1
            call Tasto (ix,iy,widb,heib,kact,2)
            nbox0  = 1
            nboxn  = nbox
            ColTast = 3
c            iz = 0
c            call DrawMenu(iz)
            goto 555
         endif
         if ( i .eq. 26 ) then        !  Regroup
            call ClearMessage
            messaggio = 'Running. Please wait...'
            Iz = 23
            icol = 14
            ix = 85
            iy = kscry - 20
#if defined(_DOS_) 
            call draw_text@(messaggio(1:Iz),ix,iy,icol)
#endif
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_) 
            call draw_text(messaggio(1:Iz),ix,iy,icol)
#endif
#if defined(_DVF_) || defined (_GID_) 
            RES= SETCOLOR ( icol )
            CALL MOVETO(ix,iy,xy)
            CALL OUTGTEXT(messaggio(1:Iz))
#endif
         endif
         if ( i .eq. 29 ) then        !  Help window
            call CreateHelp
         endif
         if ( i .eq. 30 ) then        !  Hard Copy
            iz = 8
            call DrawMenu(iz)
            call display_mouse_cursor
c
            color = 7
 2524       call Sorcio(ix,iy,button_status)
c
            j = kebox(ix,iy)
            if (j.lt.0) goto 2524
            call drawtasto(j+10)
            call ClearMessage
            nbox0  = 1
            nboxn  = nbox
            ColTast = 3
            if (j.eq.(nbox-10)+18) then
               write(Message,'(a)') ' Running. Please wait ...'
               lMess = 25
               call PrintMess
               idev = 1
#if defined(_DOS_) 
               call OPEN_GPRINT_DEVICE@(idev,error_code)
#endif
               ihcopy = 1
               kscrx = 959
               kscry = 575
               Ratio = 1.0
            elseif (j.eq.(nbox-10)+19) then
c              ix1 = 81
c              iy1 = 21
               ix1=0
               iy1=0
               ix2 = kscrx
               iy2 = kscry
#if defined(_DOS_) 
               call GET_SCREEN_BLOCK@(ix1,iy1,ix2,iy2,iBuffer)
               if (iBuffer.ne.-1) then
#endif
                  k=index(fname(1),'.')
#if defined(_DOS_) 
                  File = fname(1)(1:k-1)//'.pcx'
#endif
#if defined(_DVF_) || defined (_GID_) 
                  File = fname(1)(1:k-1)//'.bmp'
#endif
#if defined(_DOS_) 
                  call SCREEN_BLOCK_TO_PCX@(File, iBuffer, Error_Code)
#endif
#if defined(_DVF_) || defined (_GID_) 
                  res = SAVEIMAGE(File,ix1,iy1,ix2,iy2)
#endif
c                  return
#if defined(_DOS_) 
               else
                write(Message,'(a)') ' Sorry. Not enough memory ...'
                  lMess = 29
                  call PrintMess
#endif
c                  return
#if defined(_DOS_) 
               end if
#endif
            end if
         endif
         if ( i .eq. 31 ) then        !  Geometry
            if (jpres .gt. 0) then
               j = jpres
               goto 2625
            end if
            strbox(nbox + 34) = strapp(11)
            iz = 9
 2623       call DrawMenu(iz)
            call display_mouse_cursor
c
            color = 7
 2624       call Sorcio(ix,iy,button_status)
c
            j = kebox(ix,iy)
            if (j.lt.0) goto 2624
            call drawtasto(j+10)
            call ClearMessage
            nbox0  = 1
            nboxn  = nbox
            ColTast = 3
 2625       if(j.eq.(nbox-10)+ 24) then
               call hide_mouse_cursor        ! More ...
               call ClearMessage
               iz = 10
               goto 2623
            else if(j.eq.(nbox-10) + 29) then
               call hide_mouse_cursor        ! More ...
               call ClearMessage
               iz = 9
               goto 2623
            else if(j.eq.(nbox-10) + 25 .or. j.eq.(nbox-10) + 30) then
               call hide_mouse_cursor        ! Cancel
               call ClearMessage
               khead = 0
               nbox0  = 1
               nboxn  = nbox
               ColTast = 3
               call display_mouse_cursor
               goto 200
            else if (j.ge.(nbox-10)+21 .and. j.le.(nbox-10)+27) then
c--   Distances/Angles/Torsion Angles/Add & Delete Bonds
               NumMsg = j - (nbox-10) - 19
               if (jpres.gt.0) then
                  iact = 1
               else
                  iact = 0
               end if
               call SelectAtms(ixv,iyv,iact,NumMsg)
               if(iact.lt.0) then
                  ipres = 0
                  jpres = 0
                  goto 200
               end if
               iiz = (j - (nbox-10) - 20) * 100 + i
               goto 555
            else if (j.eq.(nbox-10)+28) then
c--   Info
               iiz = (j - (nbox-10) - 20) * 100 + i
            end if
         end if
         if (i .eq. (nbox-10) + 31 .or. i .eq. (nbox-10) + 35) then
             iiz = -1                           !  UP (DispDist)
         end if
         if (i .eq. (nbox-10) + 32 .or. i .eq. (nbox-10) + 36) then
             iiz = 1                            ! DOWN (DispDist)
         end if
         if (i .eq. (nbox-10) + 33 .or. i .eq. (nbox-10) + 37) then
             khead = 0                          ! CANCEL (DispDist)
             nbox0 = 1
             nboxn = nbox
             iiz = 0
             ColTast = 3
             call ClearMessage
         end if
         if (i .eq. (nbox-10) + 34) then       ! Bar  chart/Num.Table
             iiz = 2
             if (strbox(nbox + 34) .eq. strapp(10)) then
                 strbox(nbox + 34) = strapp(11)
             else
                 strbox(nbox + 34) = strapp(10)
             end if
         end if
555      call hide_mouse_cursor
         return
      else if (ind.eq.6) then
         if (ihcopy.eq.0) then
            ix=81
            iy=21
            ix1=kscrx
            iy1=kscry
            icol=0
#if defined(_DOS_) 
            call clear_screen_area@(ix,iy,ix1,iy1,icol)
#endif
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_) 
            call clear_screen_area(ix,iy,ix1,iy1,icol)
#endif
#if defined(_DVF_) || defined (_GID_) 
            RES= SETCOLOR ( icol )
            RES= RECTANGLE ($GFILLINTERIOR,ix,iy,ix1,iy1)
#endif
         end if
      else if (ind.eq.7) then
c        call clear_screen@
         ix=0
         iy=21
         ix1=kscrx
         iy1=kscry
         icol=0
#if defined(_DOS_) 
         call clear_screen_area@(ix,iy,ix1,iy1,icol)
#endif
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_) 
         call clear_screen_area(ix,iy,ix1,iy1,icol)
#endif
#if defined(_DVF_) || defined (_GID_) 
         RES= SETCOLOR ( icol )
         RES= RECTANGLE ($GFILLINTERIOR,ix,iy,ix1,iy1)
#endif
      else if (ind.eq.8) then
      else if (ind.eq.9) then
         iarrow = 0
         if (ix.lt.0) then
            iarrow = 1
            ix = abs(ix)
            ix1 = 0
            iy1 = 21
            ix2 = 80
            iy2 = kscry
            icol = 0
#if defined(_DOS_) 
            call clear_screen_area@(ix1,iy1,ix2,iy2,icol)
#endif
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_) 
            call clear_screen_area(ix1,iy1,ix2,iy2,icol)
#endif
#if defined(_DVF_) || defined (_GID_) 
            RES= SETCOLOR ( icol )
            RES= RECTANGLE ($GFILLINTERIOR,ix1,iy1,ix2,iy2)
#endif
         end if
         ix=ix+deltax
c        iy=iy+40
         if (iy.gt.kscry) iy=kscry-7
         ix1=kscrx
c        iy1=iy-ivd+15
         iy1=iy+ivd-5
         icol=0
#if defined(_DOS_) 
         call fill_rectangle@(ix,iy,ix1,iy1,icol)
#endif
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_) 
         call fill_rectangle(ix,iy,ix1,iy1,icol)
#endif
#if defined(_DVF_) || defined (_GID_) 
         RES= SETCOLOR ( icol )
         RES= RECTANGLE ($GFILLINTERIOR,ix,iy,ix1,iy1)
#endif

#if defined(_DOS_) 
         call draw_text@(string(1:iz),ix,iy,color)
#endif
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_) 
         call draw_text(string(1:iz),ix,iy,color)
#endif
#if defined(_DVF_) || defined (_GID_) 
         RES= SETCOLOR ( color )
         CALL MOVETO(ix,iy,xy)
         CALL OUTGTEXT(string(1:iz))
#endif
         if (iarrow.eq.1) then
#if defined(_DOS_) || defined(_LIN_) || defined(_GIL_) || defined(_MAC_)
            ixv2(1) = ix - 30
            iyv2(1) = iy + 5
            ixv2(2) = ixv2(1) + 15
            iyv2(2) = iyv2(1)
            ixv2(3) = ixv2(2)
            iyv2(3) = iyv2(2) - 5
            ixv2(4) = ixv2(3) + 8
            iyv2(4) = iyv2(3) + 8
            ixv2(5) = ixv2(4) - 8
            iyv2(5) = iyv2(4) + 8
            ixv2(6) = ixv2(5)
            iyv2(6) = iyv2(5) - 5
            ixv2(7) = ixv2(6) - 15
            iyv2(7) = iyv2(6)
            ixv2(8) = ixv2(1)
            iyv2(8) = iyv2(1)
#endif

#if defined(_DVF_) || defined (_GID_) 
            poly(1)%xcoord = ix - 30
            poly(1)%ycoord = iy + 5
            poly(2)%xcoord = poly(1)%xcoord + 15
            poly(2)%ycoord = poly(1)%ycoord
            poly(3)%xcoord = poly(2)%xcoord
            poly(3)%ycoord = poly(2)%ycoord - 5
            poly(4)%xcoord = poly(3)%xcoord + 8
            poly(4)%ycoord = poly(3)%ycoord + 8
            poly(5)%xcoord = poly(4)%xcoord - 8
            poly(5)%ycoord = poly(4)%ycoord + 8
            poly(6)%xcoord = poly(5)%xcoord
            poly(6)%ycoord = poly(5)%ycoord - 5
            poly(7)%xcoord = poly(6)%xcoord - 15
            poly(7)%ycoord = poly(6)%ycoord
            poly(8)%xcoord = poly(1)%xcoord
            poly(8)%ycoord = poly(1)%ycoord
#endif
            iz = 8

#if defined(_DOS_) 
            call polyline@(ixv2,iyv2,iz,color)
#endif
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_) 
            call fill_polygon(ixv2,iyv2,iz, color)
            call polyline(ixv2,iyv2,iz,color)
#endif
#if defined(_DOS_) 
            call create_polygon@(ixv2,iyv2,iz,handle,err)
            call fill_polygon@(handle,color,err)
            call delete_polygon_definition@(handle,err)
#endif
#if defined(_DVF_) || defined (_GID_) 
            RES= SETCOLOR ( color )
            res = POLYGON($GBORDER, poly, iz)
            res = POLYGON($GFILLINTERIOR, poly, iz)
#endif
         end if
      else if (ind.eq.10)then
         if (ix.le.80.or.iy.le.20) khead = 1
         iz=iz/2
         iz1=iz
         if (ihcopy.ne.0) then
            iz1=2.0000 * iz
         end if
         ix=ix+iz
         iy=iy+iz
#if defined(_DOS_) 
         call ellipse@(ix,iy,iz1,iz,color)
#endif
#if defined(_LIN_) || defined(_GIL_) || defined(_MAC_)
         call ellipse(ix,iy,iz1,iz,color)
#endif
#if defined(_DVF_) || defined (_GID_) 
         IF ((color.eq.0).or.(color.gt.7)) then
            RES= SETCOLOR ( color )
         ELSE
            RES= SETCOLOR ( color + 8 )
         END IF
         res = ELLIPSE($GBORDER,ix-iz1,iy-iz,ix+iz1,iy+iz)
#endif
      else if (ind.eq.11)then
         if (ix.le.80.or.iy.le.20) khead = 1
         iz=iz/2
         iz1=iz
         if (ihcopy.ne.0) then
            iz1=2.0000 * iz
         end if
         ix=ix+iz
         iy=iy+iz
#if defined(_DOS_) 
         call fill_ellipse@(ix,iy,iz1,iz,color)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_) || defined (_MAC_) 
         call fill_ellipse(ix,iy,iz1,iz,color)
#endif
#if defined(_DVF_) || defined (_GID_) 
         IF ((color.eq.0).or.(color.gt.7)) then
            RES= SETCOLOR ( color )
         ELSE
            RES= SETCOLOR ( color + 8 )
         END IF
         res = ELLIPSE($GFILLINTERIOR,ix-iz1,iy-iz,ix+iz1,iy+iz)
#endif
      else if (ind.eq.12)then
         icol = iicol
         color=icol
      else if (ind.eq.13)then
         do i=1,iz
#if defined(_DOS_) || defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
            ixv2(i)=ixv(i)
            iyv2(i)=iyv(i)
#endif
#if defined(_DVF_) || defined (_GID_) 
            poly(i)%xcoord = ixv(i)
            poly(i)%ycoord = iyv(i)
#endif
         enddo
         icol = iicol
#if defined(_DOS_) 
         call polyline@(ixv2,iyv2,iz,icol)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
         call polyline(ixv2,iyv2,iz,icol)
#endif
#if defined(_DVF_) || defined (_GID_) 
         IF ((icol.eq.0).or.(icol.gt.7)) then
            RES= SETCOLOR ( icol )
         ELSE
            RES= SETCOLOR ( icol + 8 )
         END IF
         res = POLYGON($GBORDER, poly, iz)
#endif
      else if (ind.eq.14)then
         do i=1,iz
#if defined(_DOS_) || defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
            ixv2(i)=ixv(i)
            iyv2(i)=iyv(i)
#endif
#if defined(_DVF_) || defined (_GID_) 
            poly(i)%xcoord = ixv(i)
            poly(i)%ycoord = iyv(i)
#endif
         enddo
         icol = iicol
#if defined(_DOS_) 
         call create_polygon@(ixv2,iyv2,iz,handle,err)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
         call fill_polygon(ixv2,iyv2,iz,icol)
#endif
#if defined(_DOS_) 
         call fill_polygon@(handle,icol,err)
         call delete_polygon_definition@(handle,err)
#endif
#if defined(_DVF_) || defined (_GID_) 
         IF ((icol.eq.0).or.(icol.gt.7)) then
            RES= SETCOLOR ( icol )
         ELSE
            RES= SETCOLOR ( icol + 8 )
         END IF
         res = POLYGON($GFILLINTERIOR, poly, iz)
#endif
      else if (ind.eq.15)then
         ix=81
         iy=kscry-13
         ix1=kscrx
c        iy1=iy-ivd+15
         iy1=kscry
         icol=0
#if defined(_DOS_) 
         call fill_rectangle@(ix,iy,ix1,iy1,icol)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
         call fill_rectangle(ix,iy,ix1,iy1,icol)
#endif
#if defined(_DVF_) || defined (_GID_) 
         RES= SETCOLOR ( icol )
         RES= RECTANGLE ($GFILLINTERIOR,ix,iy,ix1,iy1)
#endif
#if defined(_DOS_) 
         call draw_text@(string(1:iz),ix,iy,color)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
         call draw_text(string(1:iz),ix,iy,color)
#endif
#if defined(_DVF_) || defined (_GID_) 
         RES= SETCOLOR ( color )
         CALL MOVETO(ix,iy,xy)
         CALL OUTGTEXT(string(1:iz))
#endif
      else if (ind.eq.16)then
         NumSpec = iiz
         do 1000 i = 1 , NumSpec
            j = ( i - 1 ) * 3 + 1
            Species(i) = string(j:j+1)
 1000    continue
      else if (ind.eq.17)then
            GraphicsHandle=0
#if defined(_DOS_) 
                CALL window_update@(GraphicsHandle)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
         call closedisplay
#endif
      else
         stop 'xwin'
      endif
c
      return
      end

c-----------------------------------------------------------------------
      block data menu
      character*14 strbox, strapp
      integer*2 ColTast
      common /cmenu/ xbox(78),ybox(78),lbox(78),strbox(78),nbox,nboxt,
     +               nbox0,nboxn,ColTast,strapp(11)
      data nbox,nboxt /41,68/
      data xbox / 10, 10, 30, 30, 30, 10, 30, 30, 30, 10, 10, 37, 64,
     *            10, 37, 64, 10, 63, 10, 63, 10, 63, 10, 63, 10, 63,
     *            10, 63, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
     *           590, 10, 100, 200, 300, 410, 510, 400, 530, 100, 230,
     *            360, 480, 560, 100, 230, 360, 480, 560, 400, 480,
     *            570, 100, 220, 340, 480, 560, 100, 230, 360, 480,560,
     *            330, 400, 470, 540, 420, 490, 560/
      data ybox / 50, 110, 130, 150, 170, 190, 210, 230, 250,  30,  70,
     *            70,  70,  90,  90,  90, 130, 130, 150, 150, 170, 170,
     *           210, 210, 230, 230, 250, 250, 270, 290, 310, 330, 350,
     *           370, 390, 430, 450, 470, 490,  30, 410, 490, 490, 490,
     *           490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490,
     *           490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490,
     *           490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490,
     *           490 /
      data lbox / 80, 80, 40, 40, 40, 80, 40, 40, 40, 80, 27, 27, 26,
     *            27, 27, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
     *            27, 27, 80, 80, 80, 80, 80, 80, 80, 80, 80 ,80, 80,
     *            60, 80, 80, 80, 90, 80, 80,110, 80,120,120,110, 70,
     *            60,120,120,110, 70, 60, 70, 80, 60,110,110,130, 70,
     *            60,120,120,110, 70, 60, 60, 60, 60, 90, 60, 60, 60/
      data strbox / 'Plot Style', '  Rotate  ', '  X', '  Y', '  Z',
     *     'Translate ', '  X', '  Y', '  Z', '  Quit  ',
     *     ' 1', ' 2', ' 3', ' 4', ' 5', ' 6', ' -', ' +', ' -', ' +',
     *     ' -', ' +', ' -', ' +', ' -', ' +', ' -', ' +',
     *     'Edges on ', 'Symm  on ', 'Scale off ','Delete  ',
     *     'Select  ','View pl.', 'Relabel  ', 'Regroup ',
     *     'Refine  ', 'Complete ', '   Help  ',' HCopy','Geometry',
     *     'To delete', 'To hide  ','To display','Show all','Cancel',
     *     'Close Polygon','Cancel',
     *     'Least Sqare P.','Norm. to L.& M.','Most Sqare P.' ,
     *     'More...','Cancel',
     *     '  Normal to A','  Normal to B',' Normal to C',
     *     'More...','Cancel','Printer','.PCX file','Cancel',
     *     ' Distances','   Angles','Torsion Angles','More...',
     *     'Cancel','  Add Bonds',' Delete Bonds','   Info',
     *     'More...','Cancel','  Up',' Down','Cancel','Bar  chart',
     *     '  Up',' Down','Cancel'/
      data strapp /'Edges off', 'Edges on ', 'Symm  off',
     *     'Symm  on ', 'Scale off ', 'Scale on  ','Cancel  ',
     *     'Close Polygon','    Done','Num. Table','Bar  chart'/
c
      end
c-----------------------------------------------------------------------
      subroutine DrawMenu(Iz)
#if defined(_DVF_) || defined (_GID_) 
      USE DFLIB
      USE DFWIN
      INTEGER*2 RES
      logical*4 status
      type (windowconfig)wc
      type (qwinfo)win
      TYPE (xycoord) xy
#endif
      character*14 strbox, strapp
      character *80 Titolo,messaggio,MessB
      COMMON /Contr/ NF,iFirstTime,Titolo,Ratio,IfCont,IfEdge,IfScale,
     *               kplty,radii(8),IfScaleB
      common /cmenu/ xbox(78),ybox(78),lbox(78),strbox(78),nbox,nboxt,
     +               nbox0,nboxn,ColTast,strapp(11)
      common /screen/ kscreen,jy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      integer*2 ix,iy,ix1,iy1,icol,widb,heib,Iz,iiz,iy2
      real*4 size,rot,ita
      integer*2 font,iwid,ihei,ColTast
c
      ColTast = 3
      if ( Iz .eq. 0 )  then
         nbox0  = 1
         nboxn  = nbox
      elseif (Iz.eq.-1) then
         nbox0  = 10
         nboxn  = 10
      elseif (Iz.eq.2) then
         nbox0  = nbox + 1
         nboxn  = nbox + 5
         ColTast = 7
      elseif (Iz.eq.3) then
         nbox0  = nbox + 6
         nboxn  = nbox + 7
         ColTast = 7
      elseif (Iz.eq.4) then
         nbox0  = nbox + 8
         nboxn  = nbox + 12
         ColTast = 7
      elseif (Iz.eq.5) then
         nbox0  = nbox + 13
         nboxn  = nbox + 17
         ColTast = 7
      elseif (Iz.eq.6) then
         nbox0  = nbox + 12
         nboxn  = nbox + 12
         ColTast = 7
      elseif (Iz.eq.7) then
         nbox0  = nbox + 11
         nboxn  = nbox + 12
         ColTast = 7
      elseif (Iz.eq.8) then
         nbox0  = nbox + 18
         nboxn  = nbox + 20
         ColTast = 7
      elseif (Iz.eq.9) then
         nbox0  = nbox + 21
         nboxn  = nbox + 25
         ColTast = 7
      elseif (Iz.eq.10) then
         nbox0  = nbox + 26
         nboxn  = nbox + 30
         ColTast = 7
      elseif (Iz.eq.11) then
         nbox0  = nbox + 35
         nboxn  = nbox + 37
         ColTast = 7
      elseif (Iz.eq.12) then
         nbox0  = nbox + 31
         nboxn  = nbox + 34
         ColTast = 7
      elseif (Iz.eq.13) then
         nbox0  = nbox + 33
         nboxn  = nbox + 34
         ColTast = 7
      endif
c
c-- scrive il titolo
c
      if (Iz.eq.0) then
         ix = 81
         iy = 0
         ix1 = kscrx
         iy1 = 20
         iwid = kscrx-ix
         ihei = iy1
         icol = 3
#if defined(_DOS_) 
         call fill_rectangle@(ix,iy,ix1,iy1,icol)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
         call fill_rectangle(ix,iy,ix1,iy1,icol)
#endif
#if defined(_DVF_) || defined (_GID_) 
         RES= SETCOLOR ( icol )
         RES= RECTANGLE ($GFILLINTERIOR,ix,iy,ix1,iy1)
#endif

         kact = 1
         call Tasto (ix,iy,iwid,ihei,kact,1)
         icol = 4
         ix = 84
         iy = 4
         kkprog = mod ( kprog , 10 )
         if (kkprog.eq.1) then
            MessB = ' SIR92 : '
            lm = 9
         else
            MessB = ' SIRPOW.92 : '
            lm = 13
         end if
         messaggio = MessB(1:lm)//Titolo
         iiz = Lung(messaggio)
#if defined(_DOS_) 
         call draw_text@(messaggio(1:iiz),ix,iy,icol)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
         call draw_text(messaggio(1:iiz),ix,iy,icol)
#endif
#if defined(_DVF_) || defined (_GID_) 
         RES= SETCOLOR ( icol )
         CALL MOVETO(ix,iy,xy)
         CALL OUTGTEXT(messaggio(1:iiz))
#endif
      elseif (iz.eq.2 .or. iz.eq.4 .or. iz.eq.9) then
         call ClearMessage
      end if
c
c-- disegna i rettangoli per i tastini e crea le regioni associate
c
      size=1.0
      font=1
      rot=0.0
      ita=0
#if defined(_DOS_) 
      call set_text_attribute@(font,size,rot,ita)
#endif
      kact = 0
      do 100 i = nbox0 , nboxn
         widb=lbox(i)-2
         heib=20-2
         ix = xbox(i) -10+1
         iy = ybox(i) -30+1
         ix1 = ix + widb
         iy1 = iy + heib
         icol=ColTast
#if defined(_DOS_) 
         call fill_rectangle@(ix,iy,ix1,iy1,icol)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
         call fill_rectangle(ix,iy,ix1,iy1,icol)
#endif
#if defined(_DVF_) || defined (_GID_) 
         RES= SETCOLOR ( icol )
         RES= RECTANGLE ($GFILLINTERIOR,ix,iy,ix1,iy1)
#endif

         if ( i.gt.9 ) then
            call Tasto (ix,iy,widb,heib,kact,2)
         endif
         icol=1
         ix=ix-1
         iy=iy-1
         ix1=ix1+1
         iy1=iy1+1
#if defined(_DOS_) 
         call rectangle@(ix,iy,ix1,iy1,icol)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
         call rectangle(ix,iy,ix1,iy1,icol)
#endif
#if defined(_DVF_) || defined (_GID_) 
         RES= SETCOLOR ( icol )
         RES= RECTANGLE ($GBORDER,ix,iy,ix1,iy1)
#endif
         iiz = Lung(strbox(i))
         if (i.gt.9) then
            ix=ix+5
         end if
         iy2=iy1-17
#if defined(_DOS_) 
         call draw_text@(strbox(i)(1:iiz),ix,iy2,icol)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
         call draw_text(strbox(i)(1:iiz),ix,iy2,icol)
#endif
#if defined(_DVF_) || defined (_GID_) 
         RES= SETCOLOR ( icol )
         CALL MOVETO(ix,iy2,xy)
         CALL OUTGTEXT(strbox(i)(1:iiz))
#endif
  100 continue
      size=1.0
#if defined(_DOS_) 
      call set_text_attribute@(font,size,rot,ita)
#endif
c
      return
      end
c-----------------------------------------------------------------------
      subroutine Tasto (ix,iy,widb,heib,jact,ideep)
#if defined(_DVF_) || defined (_GID_) 
      USE DFLIB
      INTEGER*2 RES
      TYPE (xycoord) poly(6)
#endif
      character*14 strbox, strapp
      common /cmenu/ xbox(78),ybox(78),lbox(78),strbox(78),nbox,nboxt,
     +               nbox0,nboxn,ColTast,strapp(11)
      integer*2 ix,iy,icol1,icol2,widb,heib,ColTast
      integer*2 handle,err,ixv(100),iyv(100),iz

      call hide_mouse_cursor
      kact = jact
   10 continue
      if (kact.eq.1) then
         icol1 = ColTast + 8
         icol2 = 8
      else
         icol1 = 8
         icol2 = ColTast + 8
      endif
      iz=6
#if defined(_DOS_) || defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
      ixv(1) = ix
      iyv(1) = iy+heib
      ixv(2) = ix+ideep
      iyv(2) = iy+heib-ideep
      ixv(3) = ix+widb-ideep
      iyv(3) = iy+heib-ideep
      ixv(4) = ix+widb-ideep
      iyv(4) = iy+ideep
      ixv(5) = ix+widb
      iyv(5) = iy
      ixv(6) = ix+widb
      iyv(6) = iy+heib
#endif

#if defined(_DVF_) || defined (_GID_) 
      poly(1)%xcoord = ix
      poly(1)%ycoord = iy+heib
      poly(2)%xcoord = ix+ideep
      poly(2)%ycoord = iy+heib-ideep
      poly(3)%xcoord = ix+widb-ideep
      poly(3)%ycoord = iy+heib-ideep
      poly(4)%xcoord = ix+widb-ideep
      poly(4)%ycoord = iy+ideep
      poly(5)%xcoord = ix+widb
      poly(5)%ycoord = iy
      poly(6)%xcoord = ix+widb
      poly(6)%ycoord = iy+heib
#endif


#if defined(_DOS_) 
      call create_polygon@(ixv,iyv,iz,handle,err)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
      call fill_polygon(ixv,iyv,iz, icol1)
#endif
#if defined(_DOS_) 
      call fill_polygon@(handle,icol1,err)
      call delete_polygon_definition@(handle,err)
#endif
#if defined(_DVF_) || defined (_GID_) 
      RES= SETCOLOR ( icol1 )
      res = POLYGON($GFILLINTERIOR, poly, iz)
#endif

#if defined(_DOS_) || defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
      ixv(3) = ix+ideep
      iyv(3) = iy+ideep
      ixv(6) = ix
      iyv(6) = iy
#endif
#if defined(_DVF_) || defined (_GID_) 
      poly(3)%xcoord = ix+ideep
      poly(3)%ycoord = iy+ideep
      poly(6)%xcoord = ix
      poly(6)%ycoord = iy
#endif

#if defined(_DOS_) 
      call create_polygon@(ixv,iyv,iz,handle,err)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
      call fill_polygon(ixv,iyv,iz,icol2)
#endif
#if defined(_DOS_) 
      call fill_polygon@(handle,icol2,err)
      call delete_polygon_definition@(handle,err)
#endif
#if defined(_DVF_) || defined (_GID_) 
      RES= SETCOLOR ( icol2 )
      res = POLYGON($GFILLINTERIOR, poly, iz)
#endif
c
      if (kact.eq.0) goto 20
      kact = kact -1
#if defined(_DOS_) 
      call sleep@ (0.1)
#endif
      go to 10
20    call display_mouse_cursor
      return
      end
c-----------------------------------------------------------------------
      function kebox(ix,iy)
      character*14 strbox, strapp
      common /cmenu/ xbox(78),ybox(78),lbox(78),strbox(78),nbox,nboxt,
     +               nbox0,nboxn,ColTast,strapp(11)
      integer*2 ix,iy,ix1,iy1,widb,heib,ColTast
c
      kebox = -1
c     if (ix.ge.80) return
      heib = 20
      do 100 i = nbox0 , nboxn
         widb = lbox(i)
         ix1 = xbox(i) - 10
         ix2 = xbox(i) + widb - 10
         iy1 = ybox(i) - 30
         iy2 = ybox(i) + heib - 30
         if (ix.gt.ix1.and.ix.lt.ix2.and.
     *       iy.gt.iy1.and.iy.lt.iy2) then
                 kebox = i - 10
                 return
         endif
  100 continue
c
      return
      end
c-----------------------------------------------------------------------
      function kespec(ix,iy,NumSpec)
      character*14 strbox, strapp
      common /cmenu/ xbox(78),ybox(78),lbox(78),strbox(78),nbox,nboxt,
     +               nbox0,nboxn,ColTast,strapp(11)
      common /screen/ kscreen,jy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      integer*2 ix,iy,widb,heib,ColTast
c
      kespec = -1
      widb=25
      heib=20
      iyb = kscry - 25
      iy1b = iyb + heib
      if (iy.lt.iyb) return
      ixb = 300
      do 100 i = 1 , NumSpec
      ixb = ixb + widb + 10
      ix1b = ixb + widb
      if (ix.gt.ixb.and.ix.lt.ix1b.and.
     *    iy.gt.iyb.and.iy.lt.iy1b) then
                                     kespec = i
                                     return
                                    endif
  100 continue
c
      return
      end
c-----------------------------------------------------------------------
      subroutine ClearMessage
#if defined(_DVF_) || defined (_GID_) 
      USE DFLIB
      INTEGER*2 RES
#endif
      common /screen/ kscreen,jy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      integer*2 ix,iy,ix1,iy1,icol
c
      icol = 0
      ix = 81
      iy = kscry - 20
      ix1 = kscrx
      iy1 = kscry
      call hide_mouse_cursor
#if defined(_DOS_) 
      call fill_rectangle@(ix,iy,ix1,iy1,icol)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
      call fill_rectangle(ix,iy,ix1,iy1,icol)
#endif
#if defined(_DVF_) || defined (_GID_) 
      RES= SETCOLOR ( icol )
      RES= RECTANGLE ($GFILLINTERIOR,ix,iy,ix1,iy1)
#endif
      call display_mouse_cursor
c
      return
      end
c -----------------------------------------------------
      subroutine Sorcio(ix,iy,button_status)
#if defined(_DVF_) || defined (_GID_) 
      USE DFLIB
      INTEGER*2 RES
      INTEGER*4 MX,MY
#endif
      common /screen/ kscreen,jy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      integer*2 ix,iy,button_status
      integer*2 ib,ic
      character *12 File
#if defined(_DOS_) 
      include <windows.ins>
#endif
c
c flush the mouse button buffer (if there is such a thing).
      ib = 0
#if defined(_DOS_) 
      call get_mouse_button_press_count@(ib,ic)
#endif

      button_status=0
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined(_MAC_)
  300 call waitonmousepress_(IX, IY, button_status)
#endif

#if defined(_DVF_) || defined (_GID_)
  300 RES=WAITONMOUSEEVENT(MOUSE$LBUTTONUP,k,mx,my)
      IF ( RES .EQ. MOUSE$BADEVENT ) STOP
      IX=MX
      IY=MY
#endif

#if defined(_DOS_) 
  300 call get_mouse_position@(ix,iy,button_status)
      call temporary_yield@
#endif
#if defined(_DOS_) || defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
      if (button_status.ne.1) go to 300
#endif
      if (ix.gt.81.and.ix.lt.400 .and. iy.lt.21) then
          ix1=0
          iy1=0
          ix2 = kscrx
          iy2 = kscry
#if defined(_DVF_) || defined (_GID_) 
          res = SAVEIMAGE('hcopy.bmp',ix1,iy1,ix2,iy2)
#endif
#if defined(_DOS_) 
          call GET_SCREEN_BLOCK@(ix1,iy1,ix2,iy2,iBuffer)
          File = 'hcopy.pcx'
          call SCREEN_BLOCK_TO_PCX@(File, iBuffer, Error_Code)
#endif
          goto 300
      end if
c
      return
      end
c -----------------------------------------------------
      subroutine CreateHelp
#if defined(_DVF_) || defined (_GID_) 
      USE DFLIB
      INTEGER*2 RES
      TYPE (xycoord) xy
#endif
      common /cmenu/ xbox(78),ybox(78),lbox(78),strbox(78),nbox,nboxt,
     +               nbox0,nboxn,ColTast,strapp(11)
      common /screen/ kscreen,jy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      common /sirtxt/ sirtx, jhelp
c     real*4 size,rot,ita
      integer*2 ix,iy,iz,ix1,iy1,icol    !,font
      integer*2 button_status, ColTast
      character*14 strbox, strapp
      character * 80 messaggio, sirtx
c
      jop = jopen(jhelp, sirtx, nlen, 2, 1, ier)
      if (jop.lt.0) then
          ier=-1
          return
      end if
c
      LastPage = 1
c
   10 ix=81
      iy=21
      ix1=kscrx
      iy1=kscry
      icol=0
      call hide_mouse_cursor
#if defined(_DOS_) 
      call clear_screen_area@(ix,iy,ix1,iy1,icol)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
      call clear_screen_area(ix,iy,ix1,iy1,icol)
#endif
#if defined(_DVF_) || defined (_GID_) 
      RES= SETCOLOR ( icol )
      RES= RECTANGLE ($GFILLINTERIOR,ix,iy,ix1,iy1)
#endif
c
c--   Create message to display.
c
      icol = 14
      ix = 85
      iy = 40
c
      if (LastPage.eq.0) goto 20
c
      rewind jhelp
      LastPage = 0
      read(jhelp,'(a)') messaggio
20    do 30 i = 1, 21
         read(jhelp, '(a)', end = 40) messaggio
         iz = Lung(messaggio)
         if (iz .gt. 0) then
#if defined(_DOS_) 
            call draw_text@(messaggio(1:iz),ix,iy,icol)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
            call draw_text(messaggio(1:iz),ix,iy,icol)
#endif
#if defined(_DVF_) || defined (_GID_) 
            RES= SETCOLOR ( icol )
            CALL MOVETO(ix,iy,xy)
            CALL OUTGTEXT(messaggio(1:iz))
#endif
         end if
         iy=iy+20
30    continue
      goto 50
40    LastPage = 1
c
c--   Create and manage More and Cancel Buttons
c
50    iz = 7
      call DrawMenu(iz)
      call display_mouse_cursor
c
      color = 7
  300 call Sorcio(ix,iy,button_status)
c
      i = kebox(ix,iy)
      iz = i
      if (i.lt.0) goto 300
c
      if (i.eq.(nbox - 10) + 11) then
c          NumPage = NumPage + 1
c          if (NumPage.gt.2) NumPage = 1
          goto 10
      end if
c
      close (jhelp)
      nbox0  = 1
      nboxn  = nbox
      ColTast = 3
c
      return
      end
c-----------------------------------------------------------------------
      subroutine drawtasto(ntasto)
#if defined(_DVF_) || defined (_GID_) 
      USE DFLIB
      INTEGER*2 RES
      TYPE (xycoord) xy
#endif
      character*14 strbox, strapp
      character *80 Titolo
      COMMON /Contr/ NF,iFirstTime,Titolo,Ratio,IfCont,IfEdge,IfScale,
     *               kplty,radii(8),IfScaleB
      common /cmenu/ xbox(78),ybox(78),lbox(78),strbox(78),nbox,nboxt,
     +               nbox0,nboxn,ColTast,strapp(11)
      common /screen/ kscreen,jy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      integer*2 ix,iy,ix1,iy1,icol,widb,heib,iiz,iy2
      integer*2 ColTast
      real*4 size,rot,ita
      integer*2 font
c
 
      size=1.0
      font=1
      rot=0.0
      ita=0
#if defined(_DOS_) 
      call set_text_attribute@(font,size,rot,ita)
#endif
c
      kact = 1
      i = ntasto
      widb=lbox(i)-2
      heib=20-2
      ix = xbox(i) -10+1
      iy = ybox(i) -30+1
      ix1 = ix + widb
      iy1 = iy + heib
      icol=ColTast
      call hide_mouse_cursor
#if defined(_DOS_) 
      call fill_rectangle@(ix,iy,ix1,iy1,icol)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
      call fill_rectangle(ix,iy,ix1,iy1,icol)
#endif
#if defined(_DVF_) || defined (_GID_) 
      RES= SETCOLOR ( icol )
      RES= RECTANGLE ($GFILLINTERIOR,ix,iy,ix1,iy1)
#endif
      call display_mouse_cursor
      call Tasto (ix,iy,widb,heib,kact,2)
      icol=1
      ix=ix-1
      iy=iy-1
      ix1=ix1+1
      iy1=iy1+1
      call hide_mouse_cursor
#if defined(_DOS_) 
      call rectangle@(ix,iy,ix1,iy1,icol)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
      call rectangle(ix,iy,ix1,iy1,icol)
#endif
#if defined(_DVF_) || defined (_GID_) 
      RES= SETCOLOR ( icol )
      RES= RECTANGLE ($GBORDER,ix,iy,ix1,iy1)
#endif
      iiz = Lung(strbox(i))
      if (iiz.gt.0) then
         if (i.gt.9) then
            ix=ix+5
         end if
         iy2 = iy1 - 17
         icol=1
#if defined(_DOS_) 
         call draw_text@(strbox(i)(1:iiz),ix,iy2,icol)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
         call draw_text(strbox(i)(1:iiz),ix,iy2,icol)
#endif
#if defined(_DVF_) || defined (_GID_) 
         RES= SETCOLOR ( icol )
         CALL MOVETO(ix,iy2,xy)
         CALL OUTGTEXT(strbox(i)(1:iiz))
#endif
      end if
      call display_mouse_cursor
c
      size=1.0
#if defined(_DOS_) 
      call set_text_attribute@(font,size,rot,ita)
#endif
      return
      end
c-----------------------------------------------------------------------
      SUBROUTINE Seleziona(ixv,iyv,iact)
#if defined(_DVF_) || defined (_GID_) 
      USE DFLIB
      INTEGER*2 RES
      TYPE (xycoord) xy
#endif
      common /cmenu/ xbox(78),ybox(78),lbox(78),strbox(78),nbox,nboxt,
     +               nbox0,nboxn,ColTast,strapp(11)
      common /screen/ kscreen,jy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      dimension ixv(100),iyv(100)
      character*14 strbox, strapp
      character*80 messaggio
      integer *2 iz,iiz,ColTast,ix,iy,ix1,iy1,color,button_status
c
      iiz = 2
      call DrawMenu(iiz)
 
  200 call Sorcio(ix,iy,button_status)
c
      i = kebox(ix,iy)
      iz = i
      if (i.lt.0) go to 200
c
      call drawtasto(i+10)
      iact = i + 10 - nbox
c
c     iact = 1 : cancella gli atomi selezionati
c     iact = 2 : nascondi gli atomi selezionati
c     iact = 3 : disegna solo gli atomi selezionati
c     iact = 4 : ridisegna gli atomi che erano nascosti
c     iact = 5 : annulla tutta l'operazione
c
      if (iact.eq.4) goto 500
      if (iact.eq.5) then
         iact = -1
         goto 500
      end if
c
      call ClearMessage
      messaggio = 'Draw a polygon around atoms ...'
      Iz = 31
      icol = 14
      ix = 85
      iy = kscry - 20
      call hide_mouse_cursor
#if defined(_DOS_) 
      call draw_text@(messaggio(1:Iz),ix,iy,icol)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
      call draw_text(messaggio(1:Iz),ix,iy,icol)
#endif
#if defined(_DVF_) || defined (_GID_) 
      RES= SETCOLOR ( icol )
      CALL MOVETO(ix,iy,xy)
      CALL OUTGTEXT(messaggio(1:Iz))
#endif
c
      strbox(nbox+6)= strapp(8)
      iiz = 3
      call DrawMenu(iiz)
      call display_mouse_cursor
c
      nel = 0
      color = 7
  300 call Sorcio(ix,iy,button_status)
c
      i = kebox(ix,iy)
      iz = i
      if (i.lt.0) then
         nel = nel + 1
         ixv(nel) = ix
         iyv(nel) = iy
         call hide_mouse_cursor
         if (nel.gt.1) then
#if defined(_DOS_) 
            call draw_line@(ix,iy,ix1,iy1,color)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
            call draw_line(ix,iy,ix1,iy1,color)
#endif
#if defined(_DVF_) || defined (_GID_) 
            RES= SETCOLOR ( color )
            CALL MOVETO(ix,iy,xy)
            RES= LINETO(ix1,iy1)
#endif
         else
#if defined(_DOS_) 
            call draw_line@(ix,iy,ix,iy,color)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
            call draw_line(ix,iy,ix,iy,color)
#endif
#if defined(_DVF_) || defined (_GID_) 
            RES= SETCOLOR ( color )
            CALL MOVETO(ix,iy,xy)
            RES= LINETO(ix+1,iy+1)
#endif
         end if
            call display_mouse_cursor
         ix1 = ix
         iy1 = iy
         go to 300
      end if
c
      call drawtasto(i+10)
      if (i.eq.(nbox-10) + 7) then
         iact = -1             ! Cancel Butt.
      else
         ixv(nel+1) = ixv(1)   ! Close Polygon
         iyv(nel+1) = iyv(1)
         ixv(nel+2) = -1
         iyv(nel+2) = -1
      end if
c
  500 call ClearMessage
c      iiz = 0
      call hide_mouse_cursor
c      call DrawMenu(iiz)
      nbox0  = 1
      nboxn  = nbox
      ColTast = 3
      call display_mouse_cursor
 
      return
      end
c-----------------------------------------------------------------------
      SUBROUTINE SelectAtms(ixv,iyv,iact,NumMsg)
#if defined(_DVF_) || defined (_GID_) 
      USE DFLIB
      INTEGER*2 RES
      TYPE (xycoord) xy
#endif
      common /cmenu/ xbox(78),ybox(78),lbox(78),strbox(78),nbox,nboxt,
     +               nbox0,nboxn,ColTast,strapp(11)
      common /screen/ kscreen,jy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      dimension ixv(100),iyv(100)
      character*14 strbox, strapp
      character*80 messaggio
      integer *2  iz, iiz, ColTast, ix, iy, button_status
c
      call hide_mouse_cursor
      if (iact.eq.0) then
         call ClearMessage
         if (NumMsg.eq.1) then
            messaggio = 'Click on atoms to delete'
         elseif (NumMsg.eq.2) then
            messaggio = 'Click on wanted atom(s)'
         elseif (NumMsg.eq.3) then
            messaggio = 'Click on three atoms'
         elseif (NumMsg.eq.4) then
            messaggio = 'Click on four atoms'
         elseif (NumMsg.eq.7 .or. NumMsg.eq.8) then
            messaggio = 'Click on couples of atoms'
         end if
         Iz = 24
         icol = 14
         ix = 85
         iy = kscry - 20
#if defined(_DOS_) 
         call draw_text@(messaggio(1:Iz),ix,iy,icol)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
         call draw_text(messaggio(1:Iz),ix,iy,icol)
#endif
#if defined(_DVF_) || defined (_GID_) 
         RES= SETCOLOR ( icol )
         CALL MOVETO(ix,iy,xy)
         CALL OUTGTEXT(messaggio(1:Iz))
#endif
      end if
      iact = 0
      strbox(nbox+6)= strapp(9)
      iiz = 3
      if (NumMsg.eq.3.or.NumMsg.eq.4) iiz = 6
c     if (NumMsg.eq.7.or.NumMsg.eq.8) iiz = 7
      call DrawMenu(iiz)
      call display_mouse_cursor
c
      nel = 0
      ixv(1) = -1
  100 call Sorcio(ix,iy,button_status)
      i = kebox(ix,iy)
      iz = i
      if (i.lt.0) then
         nel = nel + 1
         ixv(nel) = ix
         iyv(nel) = iy
         if ((NumMsg.ge.2 .and. NumMsg.le.4) .and. nel.eq.NumMsg) then
            ixv(nel+1) = -1
            goto 200
         end if
         goto 100
      end if
      ixv(nel+1) = -1
c     if (i.eq.nbox+7-10) iact = -1
      if (i.eq.nboxn-10) iact = -1
c
      call drawtasto(i+10)
  200 call ClearMessage
c
      nbox0  = 1
      nboxn  = nbox
      ColTast = 3
      return
      end   
      
CRYSTALS CODE FOR SPECIFIC.OLD
c---------------------------------------------------
c--- This file contains compiler-dependent code  ---
c---       Search for the string "CHANGE"        ---
c---       in order to modify the program        ---
c---------------------------------------------------
      subroutine pc386(ier)
#if defined(_DVF_) || defined (_GID_) 
      USE DFPORT
#endif
      character*80 cmnam,file1,file2
c-- input/output units, title
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
c-- trigonometric tables and constants
      common/trig/sint(450),pi,twopi,dtor,rtod
c-- implementation specific flags
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
c-- direct access file related commons
      common/xdisu/ncdfu ,ndfle,irecx
      common /xfile/ ifile,jjlist,jjend,infle,nwfle,icfle,lid(4)
      common /xfili/ lfirst,nwblo,lindex(240)
c-- scratch file reflexion arrays
      common /buffer/ vet(6,85),nrpb,idumb(4)
c-- graphics
      common/screen/ kscreen,iy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
c
CHANGE
c-- P.C./386 version

      ln = 1
      lo = 2
c--
#if defined(_DOS_) 
     file1=cmnam()
     file2=cmnam()
#endif

#if defined(_DVF_) || defined (_GID_) 
      CALL GetArg(1,file1,optlen)
      CALL GetArg(2,file2,optlen)
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
      call GetArg(1, file1)
      call GetArg(2, file2)      
#endif
      if (file1(1:1).ne.' ') then
         if (file1(1:3).ne.'con'.and.file1(1:3).ne.'CON') then
            itype=2
            iform=1
            jop=jopen(ln,file1,nlen,itype,iform,ier1)
            if (jop.lt.0) then
               ier=-1
               write(lo,5) ier1,file1
               return
            endif
         endif
         if (file2(1:1).ne.' ') then
            if (file2(1:3).ne.'con'.and.file2(1:3).ne.'CON') then
                itype=0
                iform=1
                jop=jopen(lo,file2,nlen,itype,iform,ier2)
                if (jop.lt.0) then
                        ier=-1
                        write(lo,5) ier2,file2
                        return
                      endif
                kscreen=1
              else
                kscreen=0
                lo=6
              endif
            endif
              endif
    5 format(' *** error ***  open error, code =',i5,' file is ',a)
c--
c
      return
      end
c-----------------------------------------------------------------------
      subroutine display_mouse_cursor
c
CHANGE
c-- P.C./386 version
#if defined(_DOS_) 
     call display_mouse_cursor@
#endif
c
      return
      end
c-----------------------------------------------------------------------
      subroutine hide_mouse_cursor
c
CHANGE
c-- P.C./386 version
#if defined(_DOS_) 
     call hide_mouse_cursor@
#endif
c
      return
      end
c-----------------------------------------------------------------------
      function if_mouse_there()
c
      common /screen/ kscreen,iy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      logical instal
c
      if (IfMouse .lt. 0) then
CHANGE
c-- P.C./386 version
c       call mouse_soft_reset@(instal)
c         if (instal) then
        if_mouse_there = 1
            IfMouse = If_mouse_there
c         else
c           if_mouse_there = 0
c         end if
      else
      if_mouse_there = 1
      end if
c
      return
      end
c-----------------------------------------------------------------------
      subroutine sirtime(string,lstring)
#if defined(_DVF_) || defined (_GID_) 
      USE DFPORT
#endif
      character *(*) string
c
c-- if a TIME function is not available 
c-- tranform this subroutine in a dummy one
c-- leaving only the following lines
c--
C              character *(*) string
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
              lstring=0
#endif
c--              return
c--              end
c
CHANGE
c----- code for P.C. - DOS
#if defined(_DOS_) 
     character time@*8
#endif

#if !defined(_DVF_) || defined (_GID_) && !defined(_LIN_) && !defined(_GIL_) && !defined(_MAC_)
      string( 1:3)='At '
#endif

#if defined(_DOS_) 
     string( 4:11)=time@()
     string(12:12)=' '
     lstring=12
#endif

#if defined(_DVF_) || defined (_GID_) 
      string( 1:27)=CTIME(TIME())
      string( 1:3)='On '
      string(18:28)=' '
      lstring=28
C&LIN      character time(10), date(8)
#endif
c&LIN      call date_and_time(date, time)
c&LIN      string(1:2) = time(1:2)
c&LIN      string(3:3) = ':'
c&LIN      STRING(4:5) = time(3:4)
c&LIN      string(6:6) = ':'
c&LIN      string(7:8) = time(5:6)
c&LIN      lstring=6
      return
      end
c-----------------------------------------------------------------------
      subroutine sirdate(string,lstring)
#if defined(_DVF_) || defined (_GID_) 
      USE DFPORT
#endif
      character *(*) string
c
c-- if a DATE function is not available 
c-- tranform this subroutine in a dummy one
c-- leaving only the following lines
c--
c--              character *(*) string
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
              lstring=0
#endif
c--              return
c--              end
c
CHANGE
c----- code for P.C. - DOS
#if defined(_DOS_) 
     character time@*8, fdate@*30
     string( 1:30)=fdate@()
     k=0
     do 10 i=30,1,-1
     if (k.eq.0.and.string(i:i).ne.' ') k=i
  10 continue
     k=k+1
     string(k  :k+ 3)=' at ' 
     string(k+4:k+11)=time@()
     lstring=k+11
#endif

#if defined(_DVF_) || defined (_GID_) 
      string=CTIME(TIME())
      lstring=LEN_TRIM(string)
#endif
c
c&LIN      character date(8)
c&LIN      call date_and_time(date)
c&LIN      string(1:2) = date(7:8)
c&LIN      string(3:3) = '/'
c&LIN      string(4:5) = date(5:6)
c&LIN      string(6:6) = '/'
c&LIN      string(7:10) = date(1:4)
c&LIN      lstring=10
      return
      end
c-----------------------------------------------------------------------
      subroutine graphs( ixv,iyv,iz,ind,str,icolor)
CHANGE <RIC-OX-98>
#if defined(_DOS_) 
     include <windows.ins>
CHANGE </RIC-OX-98>
#endif
      common/xwi/ color,xo,yo,khead,Species,NumSpec,ihcopy,ipres,jpres
      common /screen/ kscreen,iy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      common /scale/ x11scale(2),x11disp(2),ragmed,deltax,deltay
      common /string/ x11string

      character Species(8)*2,x11string*80
      integer *2 color, xo, yo, khead
      integer izv(100)
      integer ixv(100),iyv(100)
      character str*(*)
c
      if (ind.eq.0.or.ind.eq.2.or.ind.eq.3.or.ind.eq.6.or.
     *    ind.eq.7.or.ind.eq.8.or.ind.eq.12) iz = 0
      if (ind.eq.-1.or.
     *    ind.eq. 1.or.
     *    ind.eq. 9.or.
     *    ind.eq.15.or.
     *    ind.eq.16) then
               str(80:80) = char(0)
               x11string(1:80) = str(1:80)
             endif
CHANGE
c----- code for P.C. - DOS
      call xwin(ixv, iyv, iz, ind, str, icolor)
CHANGE <RIC-OX-98>
c----- allow screen updates while running.
#if defined(_DOS_) 
     call temporary_yield@
#endif
#if defined(_LIN_) || defined (_GIL_) || defined (_WXS_)  || defined (_MAC_) 
      call update   ! Update the screen output.
CHANGE </RIC-OX-98>
#endif
c
      return
      end
c-----------------------------------------------------------------------
code for jopen
      function jopen(ncsu,name,nlen,istat,iform,ier)
c--connect a unit to an external file
c  file properties:
c  sequential
c  formatted
c  ncsu = number identifies the unit
c  name = file name
c  nlen = maximum length in bytes for formatted records
c  istat = 0 means status unknown
c        = 1 means status scratch
c        = 2 means status old
c  iform = 1 means formatted
c        = 2 means unformatted
c  ier  = integer variable to receive a status indicator
c--
      character name*(*),form(2)*11
      character *256 clocal
c
      clocal = name
      form(1)='formatted  '
      form(2)='unformatted'
      jopen=0
      jump=istat+1
      if(iform.eq.2)go to 5000
      go to (1000,2000,3000),jump
 1000 continue
c-- status = 'unknown'
cibm**machine specific open file (ibm)
      call mtrnlg(clocal, 'UNKNOWN', len)
      open(unit=ncsu,file=clocal,iostat=ier,err=9000,
     1 status='unknown',form=form(iform))
      go to 8000
 2000 continue
c-- status = 'scratch'
cibm**machine specific open file (ibm)
      open(unit=ncsu,iostat=ier,err=9000,
     1 status='scratch',form=form(iform))
      go to 8000
 3000 continue
c-- status = 'old'
cibm**machine specific open file (ibm)
      call mtrnlg(clocal, 'OLD', len)
      open(unit=ncsu,file=clocal,iostat=ier,err=9000,
     1 status='old',form=form(iform))
      go to 8000
5000  continue
      go to (1100,2100,3100),jump
 1100 continue
c-- status = 'unknown'
cibm**machine specific open file (ibm)
      call mtrnlg(name, 'UNKNOWN', len)
      open(unit=ncsu,file=clocal,iostat=ier,err=9000,
     1 status='unknown',form=form(iform))
      go to 8000
 2100 continue
c-- status = 'scratch'
cibm**machine specific open file (ibm)
      open(unit=ncsu,iostat=ier,err=9000,
     1 status='scratch',form=form(iform))
      go to 8000
 3100 continue
c-- status = 'old'
cibm**machine specific open file (ibm)
      call mtrnlg(clocal, 'OLD', len)
      open(unit=ncsu,file=clocal,iostat=ier,err=9000,
     1 status='old',form=form(iform))
 8000 continue
      rewind ncsu
      return
9000  jopen=-1
      return
      end
c-----------------------------------------------------------------------
code for kopen
      function kopen(ncsu,name,nlen,itype,ier)
c--connect a unit to an external file
c  file properties:
c  direct
c  unformatted
c  ncsu = number identifies the unit
c  name = file name
c  nlen = length in bytes for the records
c  itype = 0 means status unknown
c        = 1 means status scratch
c  ier  = integer variable to receive a status indicator
c--
      character name*(*)
      kopen=0
      itype=itype+1
      goto(1000,2000),itype
1000  continue
c  **machine specific open file 
      open(unit=ncsu,file=name,iostat=ier,err=9000,
     * status='unknown',access='direct',
cvax 1 recordtype='fixed',
     2 form='unformatted',recl=nlen)
      return
2000  continue
c  **machine specific open file 
cdg  file name is given by the compiler
      open(unit=ncsu,iostat=ier,err=9000,
     * status='scratch',access='direct',
cvax 1 recordtype='fixed',
     2 form='unformatted',recl=nlen)
      return
9000  kopen=-1
      return
      end
c-----------------------------------------------------------------------
      block data sirblk
      character beg,commen,allcom(25)*14
      common /charas/ beg,commen,allcom
      character blank,digit*12,card(100)*80,ffile*80
      common /chara/ blank,digit,card,ffile
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      character fname(9)*80,ext(9)*4
      common/dotdat/ fname,ext
      common /comdir/ icomq(200,2),maxcom,ipcom,ipdir,icomat
      common / ureq1/ jpatt,jpunt(501),ksacc,jseteq,jumpp,jmpsie,nsec
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common /screen/ kscreen,iy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      common /scale/ x11scale(2),x11disp(2),ragmed,deltax,deltay
      common /neutro/ neutro,bmat(2,98),neuwei,vetint(200)
      common/xwi/ color,xo,yo,khead,Species,NumSpec,ihcopy,ipres,jpres
      character Species(8)*2
      integer *2 color, xo, yo, khead
      character*52 ulc
      common /ulcase/ ulc
      character*80 Titolo
      COMMON /Contr/ NF,iFirstTime,Titolo,Ratio,IfCont,IfEdge,IfScale,
     *               kplty,radii(8), IfScaleB
      character*80 sirtx
      common /sirtxt/ sirtx,jhelp
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      data ulc/'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'/
c    
      data blank/' '/
      data digit/'0123456789.-'/
      data beg,commen /'%','>'/
      data maxcom/200/
      data allcom/'normal        ','seminvariants ','invariants    ',
     *            'phase         ','fourier       ','export        ',
     *            'end           ','continue      ','job           ',
     *            '              ','              ','initialize    ',
     *            'restart       ','history       ','%             ',
     *            'patterson     ','quartets      ','caos          ',
     *            '              ','              ','              ',
     *            'structure     ','data          ','nowindow      ',
     *            'window        '/
c    
CHANGE
c     jout  =  0  peaks coordinates in shelx-92 format 
c           =  1  peaks coordinates in crystals format
      data jout / 1 /
c
c**machine specific -
CHANGE
c
c-- name of the scattering factors file
c-- and of the help file
c
cdjwnov98      data ffile/        'crsir92:form.dat'        /
cdjwnov98      data sirtx/        'crsir92:xsir92.txt' /
      data ffile/        'crysdir:form.dat'        /
      data sirtx/        'crysdir:xsir92.txt' /
cdos  data ffile/        'c:\util\form.dat'          /
cvax  data ffile/        '$1$dia1:[user1.sir]$form$.dat'   /
cdg   data ffile/        ':udd:progr:forma.sir88'  /
c-- default name for work files 
      data fname(1)/        'struct'            /
      data fname(2)/        'struct'            /
      data fname(3)/        'struct'            /
      data fname(4)/        'struct'            /
      data fname(5)/        '      '            /
      data fname(6)/        '      '            /
      data fname(7)/        '      '            /
      data fname(8)/        '      '            /
      data fname(9)/        '      '            /
cibm  data fname(1)/        'direct'            /
cibm  data fname(2)/        'host  '            /
cibm  data fname(3)/        'refl  '            /
cibm  data fname(4)/        'plot  '            /
c-- default extension for work files
      data ext(1)/        '.bin'            /
      data ext(2)/        '.hkl'            /
      data ext(3)/        '.ins'            /
      data ext(4)/        '.plt'            /
      data ext(5)/        '    '            /
      data ext(6)/        '    '            /
      data ext(7)/        '    '            /
      data ext(8)/        '    '            /
      data ext(9)/        '    '            /
cibm  data ext(1)/        '    '            /
cibm  data ext(2)/        '    '            /
cibm  data ext(3)/        '    '            /
cibm  data ext(4)/        '    '            /
cibm  data ext/        '    '            /
c     *** warning *** if the user wants to change the length of these
c                     default name and/or extension he must modify
c                     also in the subroutine 'spoolr' the relative
c                     assignement statements
c**machine specific -
c
c     define input and output channels
c     ln    = card reader
c     lo    = line printer
c     jdir  = direct access structure file
c     iscra = direct access scratch file
c     jrel  = sequential scratch file
c     ifour = sequential scratch file
c     jfile = reflection input file ( could be equal to ln if no 'refl'  
c                                    directive is used in normal)
c     jhost = fourier peaks file
c     jgrap = peaks coordinates file in moldraw/schakal/molplot format
c     kform = scattering factors file
      data    ln,   lo, jdir,iscra, jrel,ifour,jfile,jhost,jgrap,kform
     *    /    5,    6,   30,   31,   32,   33,   34,   35,   36,   41/
c
c**machine specific -
c     nlen  =  record lenght for direct access file expressed in bytes
c              *** warning *** for VAX/VMS implementation the record 
c              lenght is expressed in integer words (i.e. nlen=nlen/4)
      data nlen/2048/
CHANGE
cvms  data nlen/ 512/
c**machine specific -
c     knwr   =  number of integer words in direct access file record
c              *** warning *** for VAX/VMS implementation the record 
c              lenght and the number of words have the same value
c              (i.e. nlen=knwr)
      data knwr/512/
c     kenvir =  0 for standard implementation
c     kenvir =  1 for enraf-nonius environment
c     kenvir =  2 for m.s.c.       environment
      data kenvir/0/
c     kff    =  1 form-feeds are inserted to separate important things
c     kff    =  0 form-feeds are not inserted to save paper
      data kff/1/
c     fourier recycling common
      data jrecyc,krecy,nemap /6*0/
      data erre,erreo,bfac /202*0.0/
c     graphics common - define default behaviour of the window
c                     - kscreen = 1  window used
c                     - kscreen = 0  no window
c     graphics common - jscreen = 0  window closed
c                     - jscreen = 1  window already opened
c                     - jscreen = 2  window already opened 
c                                    & atomic species defined
      data kscreen,jscreen/0,0/
c     graphics common - define dimension of the window
      data kscrx,kscry/639,479/
*     data kscrx,kscry/720,500/
      data IfCont,IfEdge,IfScale /0,0,1/
      data deltax,deltay /80.0 , 20.0/
      data jhelp /44/
      data ihcopy,ipres,jpres / 0, 0, 0/
CHANGE
c-- P.C./386 version
      data IfMouse /-1/
*     data IfMouse / 1/
CHANGE
c     Environment
c     kprog =  1     SIR92      ( DOS )
c     kprog =  2     SIRPOW.92  ( DOS )
c     kprog =  3     MOLPLO     ( DOS )
c     kprog = 11     SIR92      ( NON DOS )
c     kprog = 12     SIRPOW.92  ( NON DOS )
c     kprog = 13     MOLPLO     ( NON DOS )
      data kprog/ 1/
c
      data neutro /0/
c     
      data iprin/0/
c
      end
c-----------------------------------------------------------------------
CODE FOR MTRNLG
      SUBROUTINE MTRNLG(FILNAM,STATUS,LENNAM)
#if defined(_DVF_) || defined (_GID_) 
      USE DFLIB
C
C----- EXPAND LOGICAL NAMES (ENVIRONMENT VARIABLES) IF THEY
C      ARE PART OF THE FILE NAME.
C
C      CODE BY MARTIN KRETSCHMAR, TUBINGEN, 1991
C
C FILNAM CONTAINS THE OLD FILE NAME AND WILL PASS BACK THE NEW ONE.
C
C STATUS IS THE THE WAY THE FILE IS INTENDED TO BE OPENED. IF SEARCH-
C LISTS LIKE THE VAX/VMS LOGICAL NAMES ARE TO BE EMULATED, IT IS
C IMPORTANT TO KNOW THIS.
C
C LENNAM USEFUL LENGTH OF FILENAME
C
C      IMPLICIT NONE
#endif
      INTEGER MAXLVL
      PARAMETER (MAXLVL=30)
      CHARACTER*(*) FILNAM,STATUS
      LOGICAL LEXIST
      INTEGER KSTRLN
      INTEGER I,J,K,LEVEL,IWHAT
      INTEGER NAMLEN(MAXLVL),COLPOS(MAXLVL)
      INTEGER LSTLEN(MAXLVL),LSTPOS(MAXLVL)
      CHARACTER*256 INQNAM,NAME(MAXLVL),LIST(MAXLVL),CTEMP
C
C
C NOW WE SEARCH FOR THE LENGTH OF OUR FILE NAME AND REMOVE BLANKS.
C
C      WRITE(*,*) 'MTRNLG:  Input="',FILNAM(1:KSTRLN(FILNAM)),
C     & '":',LEN(FILNAM),', Status="',STATUS(1:KSTRLN(STATUS)),'"'
      NCAWU = 6
      NCWU = 6
      LEVEL=1
      J=0
      DO 1 I=LEN(FILNAM),1,-1
        IF(FILNAM(I:I).NE.' ') THEN
          J = I
          GOTO 9
        ENDIF
1     CONTINUE
9     CONTINUE
      IF(J.LE.LEN(NAME(1))) NAME(1)(1:J)=FILNAM(1:J)
      NAMLEN(1)=J
      LSTPOS(1)=0
      LSTLEN(1)=-1
C
C CHECK ON FILE NAME NAMLEN OVERFLOW
C
      IF(J.GT.LEN(NAME(LEVEL))) THEN
      WRITE ( NCAWU, '(// '' MTRNLG: Filename too long ''//)')
      STOP
      ENDIF
C
      IWHAT=0
      IF(STATUS.EQ.'OLD') IWHAT=1
      IF(STATUS.EQ.'NEW') IWHAT=2
      IF(STATUS.EQ.'FRESH') IWHAT=2
      IF(STATUS.EQ.'UNKNOWN') IWHAT=3
      IF(IWHAT.EQ.0) THEN
      WRITE ( NCAWU, '(// '' MTRNLG: Unknown status ''//)')
      STOP
      END IF
C
C HERE COMES THE BIG SEARCH LOOP. IT IS GUIDED BY THE LEVEL AND THE IWHA
C VARIABLE.
C
C SEARCH FOR THE FIRST ':' IF THERE IS ANY
C
2     COLPOS(LEVEL)=INDEX(NAME(LEVEL)(1:NAMLEN(LEVEL)),':')
C
C TEST IF SOMETHING CAN BE DONE
C
      IF(COLPOS(LEVEL).LT.3) THEN
C        WRITE(NCAWU,*) 'Inquiring "',NAME(LEVEL)(1:NAMLEN(LEVEL)),'"'
        IF(IWHAT.EQ.2) GOTO 9999
        INQNAM=NAME(LEVEL)(1:NAMLEN(LEVEL))
        DO 6666 I=NAMLEN(LEVEL)+1,LEN(INQNAM)
          INQNAM(I:I)=' '
6666    CONTINUE
        INQUIRE(FILE=INQNAM,EXIST=LEXIST)
        IF(LEXIST) GOTO 9999
        LEVEL=LEVEL-1
        IF(LEVEL.GE.1) GOTO 3
        LEVEL=1
        GOTO 9999
      ENDIF
C
C LOOK FOR AN ENVIRONMENT STRING IF NONE WAS ASSIGNED UP TO NOW
C
      IF(LSTLEN(LEVEL).LT.0) THEN
CHANGE RIC-OX-98: The next statement is invalid FORTRAN...
C        CALL XCCUPC(NAME(LEVEL)(1:COLPOS(LEVEL)-1),
C     &              NAME(LEVEL)(1:COLPOS(LEVEL)-1))
CHANGE RIC-OX-98: Use this instead.
        CALL XCCUPC(NAME(LEVEL)(1:COLPOS(LEVEL)-1),CTEMP)
        NAME(LEVEL)(1:COLPOS(LEVEL)-1) = CTEMP(1:COLPOS(LEVEL)-1)


        LIST(LEVEL) = ' '
C&DOSC----- DOSPARAM@ ( CPARAM, CVALUE) RETURNS THE CVALUE OF THE PARAMET
C&DOSC      CPARAM, INITIALISED WITH THE DOS COMMAND
C&DOSC      SET CPARAM=CVALUE
#if defined(_DOS_) 
        CALL DOSPARAM@(NAME(LEVEL)(1:COLPOS(LEVEL)-1),LIST(LEVEL))
#else
        CALL GETENV(NAME(LEVEL)(1:COLPOS(LEVEL)-1),LIST(LEVEL))
#endif
        LSTPOS(LEVEL)=0
        LSTLEN(LEVEL)=KSTRLN(LIST(LEVEL))
C        WRITE(*,*) 'Environment ',LEVEL,'  "',
C     &    NAME(LEVEL)(1:COLPOS(LEVEL)-1),'"  = "',
C     &    LIST(LEVEL)(1:LSTLEN(LEVEL)),'"'
      ENDIF
C
C TEST LIST FOR SOMETHING TO PROCESS
C
3     CONTINUE
C      WRITE(*,*) 'Testing ',LEVEL,'  "',
C     &  NAME(LEVEL)(1:NAMLEN(LEVEL)),'"'
      IF((LSTPOS(LEVEL).GE.LSTLEN(LEVEL))
     &  .OR.((LSTPOS(LEVEL).GT.0).AND.(IWHAT.EQ.2))) THEN
        LEVEL=LEVEL-1
        IF(LEVEL.GE.1) GOTO 3
        LEVEL=1
        IF(IWHAT.EQ.3) THEN
          IWHAT=2
          LEVEL=1
          LSTPOS(1)=0
          LSTLEN(1)=-1
          GOTO 2
        ENDIF
        GOTO 9999
      ELSE
        IF(LEVEL.GE.MAXLVL) THEN
      WRITE ( NCAWU, '(// '' MTRNLG: Out of levels ''//)')
      STOP
        END IF
        J=LSTPOS(LEVEL)+1
        LSTPOS(LEVEL)=INDEX(LIST(LEVEL)(J:LSTLEN(LEVEL)),',')+J-1
        IF(LSTPOS(LEVEL).EQ.(J-1)) LSTPOS(LEVEL)=LSTLEN(LEVEL)+1
C         WRITE(*,*)
C     1 'Extracted     "',LIST(LEVEL)(J:LSTPOS(LEVEL)-1),'"'
        K=LSTPOS(LEVEL)-J
        NAME(LEVEL+1)(1:K)=LIST(LEVEL)(J:LSTPOS(LEVEL)-1)
C          WRITE(*,*)'Name="',NAME(LEVEL+1)(1:K),'"',J,K
        J=COLPOS(LEVEL)
C
C IF SOME 'REST' OF THE ORIGINAL FILE NAME REMAINDED
C
        IF(J.LT.NAMLEN(LEVEL)) THEN
C
C IF THE 'REST' CAN BE ADDED TO THE STRING WE GOT, DO SO
C
          IF((K+(NAMLEN(LEVEL)-J)).LE.LEN(NAME(LEVEL+1))) THEN
            NAME(LEVEL+1)(K+1:K+(NAMLEN(LEVEL)-J))
     &        =NAME(LEVEL)(J+1:NAMLEN(LEVEL))
            NAMLEN(LEVEL+1)=K+(NAMLEN(LEVEL)-J)
            DO 4 I=NAMLEN(LEVEL+1)+1,LEN(NAME(LEVEL+1))
              NAME(LEVEL+1)(I:I)=' '
4           CONTINUE
          ELSE
            NAME(LEVEL+1)(K+1:LEN(NAME(LEVEL+1)))
     &        =NAME(LEVEL)(J+1:J+(LEN(NAME(LEVEL+1))-K))
            NAMLEN(LEVEL+1)=LEN(NAME(LEVEL+1))
C           ...
          ENDIF
        ELSE
          NAMLEN(LEVEL+1)=K
        ENDIF
        LEVEL = LEVEL+1
        LSTPOS(LEVEL) = 0
        LSTLEN(LEVEL) = 0
        GOTO 2
      ENDIF
9999  CONTINUE
      IF(LEN(FILNAM).LT.NAMLEN(LEVEL)) THEN
          WRITE ( NCAWU, '(// '' MTRNLG: Filename too small ''//)')
          STOP
       END IF
C
      FILNAM(1:NAMLEN(LEVEL))=NAME(LEVEL)(1:NAMLEN(LEVEL))
      DO 8888 I=NAMLEN(LEVEL)+1,LEN(FILNAM)
        FILNAM(I:I)=' '
8888  CONTINUE
      LENNAM = KSTRLN(FILNAM)
C      WRITE(NCAWU,*) 'MTRNLG: Output="',FILNAM(1:LENNAM),'"'
      RETURN
      END
C
CODE FOR KSTRLN
      FUNCTION KSTRLN(STRING)
      CHARACTER*(*) STRING
      INTEGER I,J
      J=0
      DO 1 I=1,LEN(STRING)
        IF((STRING(I:I).NE.CHAR(32)).AND.(STRING(I:I).NE.' ')) J=I
1     CONTINUE
      KSTRLN=J
      RETURN
      END
C
CODE FOR XCCUPC
      SUBROUTINE XCCUPC ( CLOWER , CUPPER )
C
C -- CONVERT STRING TO UPPERCASE
C
C      CLOWER      SOURCE STRING TO BE CONVERTED
C      CUPPER      RESULTANT STRING
C
C
      CHARACTER*(*) CLOWER , CUPPER
C
      CHARACTER*26 CALPHA , CEQUIV
C
      DATA CALPHA / 'abcdefghijklmnopqrstuvwxyz' /
      DATA CEQUIV / 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' /
C
C
C -- MOVE WHOLE STRING.
CHANGE RIC-OX-98: Invalid assignment sometimes.
C      CUPPER = CLOWER
       WRITE(CUPPER,'(A)')CLOWER
C
      LENGTH = MIN0 ( LEN ( CLOWER ) , LEN ( CUPPER ) )
C
C -- SEARCH FOR LOWERCASE CHARACTERS AND CONVERT TO UPPERCASE
      DO 2000 I = 1 , LENGTH
        IPOS = INDEX ( CALPHA , CLOWER(I:I) )
        IF ( IPOS .GT. 0 ) CUPPER(I:I) = CEQUIV(IPOS:IPOS)
2000  CONTINUE
C
C
      RETURN
      END
CRYSTALS CODE FOR BUILD94
c--versione  1.9.92
c
c
code for maincl
      subroutine maincl(izpk,kaction,iprin)
c--main subroutine for peaks management
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/inpcl/ntype,ttype(10,5),nproj,nbond,dmaxi,radnew(8)
      common /neutro/ neutro,bmat(2,98),neuwei,vetint(200)
      dimension ivet(12),izpk(500),vett(3,4),istmp(5),zatom(10)
c                                                    
c-- izpk(i)= (100*numero d'ordine del elem.)+nfrag : picco accettato
c-- izpk(i)=-(100*numero d'ordine del elem.)+nfrag : picco non accettato
c-- izpk(i)= -99990  : picco incompatibile con uno accettato
c-- izpk(i)= -99999 : picco negleted
c
c-- kaction        azione           stampa
c      1          npk,icl,scl    dst,ang,plt,con  (istat2=3)
c      2          npk,icl,scl          -      (istat2=0)
c      3          npk,icl,scl        plt,con     (istat2=1)
c      4              npk,icl,scl       dst,ang,plt,con  (istat2=3)
c      5              npk,icl,scl             -          (istat2=0)
c
c      tipo di azione
c      npk: sub. namepk
c      rpk: sub. readpk
c      icl: sub. intcl
c      scl: sub. storcl
c      clustin: readpk+interpret. senza rifiuto
c
c      tipo di stampa
c      dst: tabella distanze
c      ang: tabella angoli
c      plt: plot
c      con: tabella connettivita
c
cc
c      write(6,*) 'MAINCL kaction = ',kaction
      ksorted=0
c      if (kaction.gt.3) call sortsp(ksorted)
      istmp(1)=3
      istmp(2)=0
      istmp(3)=1
      istmp(4)=3
      istmp(5)=0
      jstmp=istmp(kaction)
      nproj=1
      call clupar(ivet,ic,n2p,vett,lfl,izpk,focc,focct,
     *         jpkint,jumpcl,kaction,jaction,neutro,
     *           l15fin,l15con,iprin,zatom)
      l150=ivet(1)
      call clust(ivet,ic,n2p,vett,lfl,izpk,focc,jpkint,
     *         lbuf,jumpcl,kaction,neutro,
     *           l15fin,l15con,zatom)
      call cluend(ivet,lbuf,jumpcl,izpk,neutro,l15fin,l15con,
     *           jaction)
       if(jaction.ne.-1)kaction=jaction
c      if (ksorted.eq.1) call restsp(izpk,kaction)
      return
      end
c
code for clupar                                        
      subroutine clupar(ivet,iic,nn2p,vett,llfl,izpk,focc,focct
     1,jpkint,jumpcl,kaction,jaction,neutro,l15fin,l15con,iprin,zatom)
c-- interface subroutine for peaks management
c                                                                      
      dimension ivet(12),zatom(10),katom(2,10)  
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common/xfour/ itype,iprint,numero,iw,il  ,im  ,iv  ,ix
      common/lst01/l1p1,l1p2,l1m1,l1m2,l1o1,l1o2,l1a,l1c,l1s
      common/lst02/ic,ill,g2,isys,ngen,l2,m2,md2,n2,l2s,m2s,md2s,n2s,
     2 l2t,m2t,md2t,n2t,l2p,m2p,md2p,n2p,l2i,m2i,md2i,n2i
      common/lst03/l3,m3,md3,n3,l3t,m3t,l3ti,m3ti,l3g,n3g,sys03
      common/inpcl/ntype,ttype(10,5),nproj,nbond,dmaxi,radnew(8)
      common/xlimi/nfl,lfl,idummy(4),nfls
      common/xnclu/ncmu,nctu,ncau,ncsu
      character*80 iscr
      common/xscru/ iscr
      common/xcons/pii,twopis,twopi,rtd,dtr,xnx
      common/xbuil/ift1,ift2,ift3,knfl,npeak,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mconn,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)
     5,icopk(9),icoel(9),icogr(500)
      common/workb/ja,jb,jc,jd,je,jf,jg,jh,ji,jj,jk,jl,jm,jn,
     2             jo,jp,jq,jr,js,jt,ju,jv,jw,jx,jy,jz
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent,
     *             kpol,jsys,lat,indv(32),mpv(64),dummy(4)
      common /misc/ t(3,3),dxmax(3),mcon,iwt,fom(11),pts
      common /atoms/ x(5,200),nz(200),idumx(21)
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),nno(8),nk,nat,f(9),nalf(8)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopix,dtor,rtod
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /sdir/ dm,npc,nprojx,nojoin
      common /xdata/ xstore(244000)
      common / data/  store (5000)
c
      dimension istore(5000),jstore(244000),ixx(5,200),izpk(500)
      equivalence(x,ixx)
      equivalence(store,istore)
      equivalence(xstore,jstore)
      dimension vett(3,4),istmp(5)
      dimension ltype(10,5)
      equivalence (ltype(1,1),ttype(1,1))
c
c-- sir sir sir
c
c--Posizione iniziale sul common /xdata/ : nflbld=161001
      nflbld=161001
c
      istmp(1)=3
      istmp(2)=0
      istmp(3)=1
      istmp(4)=3
      istmp(5)=0
      jstmp=istmp(kaction)
      jumpcl=0
      if (dmaxi.gt.0.5) then
                          dmax=dmaxi
                        else
                          dmax=0.0
                        endif
      n2=noper
      ncwu=lo
      istat2=max0(jstmp,iprin)
      nfl=1
      call yfl01
      do 10 i=1,9
      g(i)   =store(l1m1+i-1)
   10 g(i+9)=store(l1m2+i-1)
      nfl=1
      call yfl02
      focc=1.0/(g2*n2)
      call xlat(vett)
c -- save list 2 at the bottom of store
      ifin=l2+n2*md2
      j=5000-24*md2
      do 15 i=l2,ifin
      store(j)=store(i)
   15 j=j+1
      nfl=1
      zneutro=1
      call yfl03
      ll3=l3
      m3=l3
      do 151 i=1,n3
      katom(1,i)=istore(m3)                
      katom(2,i)=int(store(m3+13))              
151   m3=m3+md3                          
      if(neutro.eq.1)then
               m3=l3
               do 16 i=1,n3
               store(m3+13)=abs(bs(1,i))
               m3=m3+md3            
  16               continue
                       zneutro=0
             endif
      ih=0                  
      if(store(l3+13).lt.1.5.and.neutro.eq.0)ih=1
      m3=l3
      nn3=0
      izmin=9999
      do 24  i= 1,n3
      if (radnew(i).gt.0.0) store(m3+15)=radnew(i)
      if(store(m3+13).gt.8)nn3=nn3+1
      izz=int(store(m3+13))
      if(store(m3+13).gt.zneutro.and.izz.lt.izmin)then
      izmin=izz
      niz=i
      jtype=istore(m3)
      endif
      if (istat2.gt.3)
     *write(ncwu,42) i,istore(m3),store(m3+12),store(m3+13),store(m3+15)
      m3=m3+md3
   24 continue
   42 format(i5,1h),1x,a2,3f10.3)
      nfl=m3+1
c -- restore list 2 in store
      ifin=n2*md2
      l2=nfl
      j=nfl
      k=5000-24*md2
      do 25 i=1,ifin
      store(j)=store(k)
      k=k+1
   25 j=j+1
      nfl=j
      idid=1
      jpkint=1
      l15=nfl
      n15=nats
      md15=8
      l15a=l15
      if(kaction.gt.3)then
c      iz=0
      iz=ih  
       do 5 i=1,nats
      if(nz(i).ne.0.and.iz.eq.0) then
                                      iz=iabs(nz(i))/100
                                     endif  
  5   continue
                      else
       iz=1+ih
                      endif
      nghost=0
      do 20 i=1,nats
      if(nz(i).eq.0.and.kaction.gt.3)then
      izpk(i)=-99999
      nghost=nghost+1
      go to 28
      endif
      if(nz(i).ne.0.and.kaction.gt.3)then
        iz=iabs(nz(i))/100
        endif
c
      izp = n3 - iz + 1
c
      izpk(i)=izp
c      write(ncwu,*)' II,i,nz(i),x(i, ),izpk(i) ',
c     * i,nz(i),(x(ii,i),ii=1,5),izpk(i)
28    continue
      if(x(5,i).le.0)x(5,i)=1
      if(x(4,i).le.0)then
      x(4,i)=iz*100.
      jpkint=0
      endif                 
      jtype=istore(l3+(iz-1)*md3)
      istore(l15a  )=jtype
      store(l15a+1)=i
      store(l15a+2)=x(1,i)
      store(l15a+3)=x(2,i)
      store(l15a+4)=x(3,i)
      store(l15a+5)=x(5,i)
      store(l15a+6)=1.
      store(l15a+7)=x(4,i)
c      write(lo,1)i,istore(l15a),(store(m15a),m15a=l15a+1,l15a+7)
c     write(ncwu,*)'fine  i,nz(i),x(i, ),izpk(i) ',
c    * i,nz(i),(x(ii,i),ii=1,5),izpk(i)
20    l15a=l15a+md15
      jaction=-1
      if(nghost.eq.n15.and.kaction.gt.3)then
      jaction=kaction
      kaction=2
      endif
1     format(i4,1h),1x,a2,7f10.4)
11     format(a2,2x,7f12.5)
c                               
      l15=l15+nflbld
      l3 =l3 +nflbld
      l2 =l2 +nflbld
      nfl=nfl+nflbld
      do 30 i=1,5000
   30 xstore(i+nflbld)=store(i)
c--header-buffer addresses
c
c--header-buffer for final list 15
      l15a=l15+n15*md15
      l15fin=l15a
      nfl=l15a+n15*md15
c      write(ncwu,*)' clupar, l15,li15fin',l15,l15fin
      m15=l15
      do 29 i=1,n15
      do 26 jj=1,md15
26    xstore(l15a+jj-1)=xstore(m15+jj-1)
      if(istat2.gt.3)
     1 write(ncwu,11)jstore(l15a),(xstore(m15a),m15a=l15a+1,l15a+7)
      m15=m15+md15
29    l15a=l15a+md15
      nfl=l15fin+5*n15*md15
c--header-buffer for conectivity table
      l15con=nfl
      nfl=nfl+4*n15*md15
      do 31 i=l15a,nfl
31    xstore(i)=0
c
      nfl=nfl+min0(100,n15)*md15
c
      ivet(1)=l15
      ivet(2)=n15
      ivet(3)=md15
      ivet(4)=l3
      ivet(5)=n3
      ivet(6)=md3
      ivet(7)=l3
      ivet(8)=n3
      ivet(9)=md3
      ivet(10)=l2
      ivet(11)=n2
      ivet(12)=md2
c--sort list 3 in decreasing-z mode    (utile a sir)
      jump=-14
      call sortz(l3,n3,md3,jump)
      m3=l3           
      do 105 i=1,n3  
      do 106 j=1,n3                                                       
      if(jstore(m3).eq.katom(1,j))then
      zatom(i)=float(katom(2,j))
      go to 105
      endif   
106   continue                    
105   m3=m3+md3
      if (istat2.gt.3)   then
       write(ncwu,*) 'c--sort decrease-z mode' ,l3,n3,md3
      m3=l3
      do 108  i= 1,n3
      write(ncwu,42) i,jstore(m3),
     * xstore(m3+12),xstore(m3+13),xstore(m3+15)
      m3=m3+md3
  108 continue
                        endif
c--is it possible to run clust?
      if (n15.le.2) then
                     jumpcl=1
                     do 51 i=1,n15
                     izpk(i)=niz*100
  51                 continue
                    endif
      if (ntype.gt.0) then
                        do 100 i =1,ntype
                        m3=l3
                        do 110 j=1,n3
                        if(ltype(i,1).eq.jstore(m3))ltype(i,5)=j
110                     m3=m3+md3
100                     continue
                        i0=nfl-1
                        do  200 i=1,ntype
                        ii=i0+(i-1)*5
                        do 210 j=1,4
                        iii=ii+j
210                     xstore(iii)=ttype(i,j)
                        iii=ii+5
                        xstore(iii)=ltype(i,5)
200                     continue
                        i0=nfl
                        jump=5
                        ii=5
                        call sortz(i0,ntype,ii,jump)
                        m=i0
                        do 300 i=1,ntype
                        do 310 j=1,4
                        ttype(i,j)=xstore(m)
310                     m=m+1
                        ltype(i,5)=xstore(m)
300                     m=m+1
              endif
c      write(ncwu,*)' izpk clupar ',(izpk(i),i=1,n15)
      knfl=nfl
      llfl=lfl
      iic=icent
      nn2p=n2p
c     nproj=nprojx
c     nproj=2
      return
      end
c
code for cluend
      subroutine cluend(ivet,lbuf,jumpcl,izpk,neutro,l15fin,l15con,
     * jaction)
c
c-- final interface subroutine for peaks management
c
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /atoms/ x(5,200),nz(200),idumx(21)
      common /xdata/ store(244000)
      common /temp/ buffer(5000),dummpc(4800)
      dimension istore(244000)
      equivalence(store,istore)
      dimension ivet(12),izpk(500)
c
      l15=ivet(1)
      n15=ivet(2)
      md15=ivet(3)
      lbuf0=lbuf
c      write(ncwu,*) 'cluend l15'
      l15a=l15fin
      do 10 i=1,n15
      x(1,i)=store(l15a+2)
      x(2,i)=store(l15a+3)
      x(3,i)=store(l15a+4)
      x(4,i)=store(l15a+7)
      l15a=l15a+md15
   10 continue
      l15a=l15+n15*md15
c      write(ncwu,*)' izpk cluend ',(izpk(i),i=1,n15)
      if(jumpcl.eq.1)return
c   50 format(3i10,2f10.3)
c-- connectivity
c
      ibx=1
      nfin=l15con+2*istore(l15con)
      do 90 j=l15con,nfin
      buffer(ibx)=istore(j)
90    ibx=ibx+1
      return
      end
c
code for xneqp
      subroutine xneqp(g,gr,m25,n25,md25,m28,tmab,bard
     1                ,ivar,gamba)
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
c      dimension x(84000),wgt(84000)
      common/xdata/store(244000)
c      equivalence (store(161001),x(1))
c     2         ,(store(161001),wgt(1))
      dimension tmab(3,3),barr(3),bard(3),xd(3),xr(3)
      dimension g(9),gr(9),gamba(3,3)
      mdx=md25
      nx=n25
      twgt= 0.0
      do 130 i=1,3
      bard(i) = 0.0
      barr(i) = 0.0
      do 130 j=1,3
      tmab(i,j) = 0.0
      gamba(i,j) = 0.0
  130 continue
      m=m25
      do 100 i= 1,nx
      lj = m28-1+i
c      twgt = twgt+wgt(lj)
      twgt = twgt+store(lj)
      bard(1) = bard(1)+store(m+2)*store(lj)
      bard(2) = bard(2)+store(m+3)*store(lj)
      bard(3) = bard(3)+store(m+4)*store(lj)
      m= m+mdx
  100 continue
       bard(1)=bard(1)/twgt
       bard(2)=bard(2)/twgt
       bard(3)=bard(3)/twgt
      call mave(g,bard,barr)
      m=m25
      do 200 i=1,nx
c      x(m+2)= x(m+2)-bard(1)
c      x(m+3)= x(m+3)-bard(2)
c      x(m+4)= x(m+4)-bard(3)
      store(m+2)= store(m+2)-bard(1)
      store(m+3)= store(m+3)-bard(2)
      store(m+4)= store(m+4)-bard(3)
      m= m+mdx                                                                  
  200 continue                                                                  
      m=m25                                                                     
      do 400 i=1,nx                                                             
c      xd(1)=x(m+2)
c      xd(2)=x(m+3)
c      xd(3)=x(m+4)
      xd(1)=store(m+2)
      xd(2)=store(m+3)
      xd(3)=store(m+4)
      call mave(g,xd,xr)                                                        
      call ospr(xr,xd,xx)                                                       
      lj=m28-1+i                                                                
      do 500 k=1,3                                                              
      do 500 l=1,3                                                              
c      tmab(k,l) =tmab(k,l)+xd(k)*xr(l)*wgt(lj)
      tmab(k,l) =tmab(k,l)+xd(k)*xr(l)*store(lj)
  500 continue                                                                  
      m= m+mdx                                                                  
  400 continue                                                                  
      return                                                                    
      end                                                                       
c                                                                               
code for eignv3                                                                 
      subroutine eignv3(g,gr,tm,eival,eivec,reivec)                             
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2                              
      dimension g(3,3),gr(3,3),tm(3,3),eival(3),eivec(3,3)                      
      dimension reivec(3,3)                                                     
      dimension tx(3,3)                                                         
      double precision a,atrem,b,bimez,discr,p,q,r                              
      pi=3.14159                                                                
c     eigenvalues and eigenvectors of                                           
c     a 3x3 matrix in the mixed-indices                                         
c     representation                                                            
c     first index in contravariant position                                     
c     second index in covariant position                                        
c     referred to unitary axes                                                  
c                                                                               
c     set up the  coefficients of secular equation                              
c     y**3+p*y**2+q*y+r=0                                                       
c     which is then reduced in the form                                         
c                                                                               
c     x**3+a*x+b=0                                                              
c     with y=x-p/3                                                              
c          a=1/3(3q-p**2)                                                       
c          b=1/27(2p**3-9p*q+27r)                                               
c                                                                               
      p=tm(1,1)+tm(2,2)+tm(3,3)                                                 
      q=tm(1,1)*tm(2,2)-tm(1,2)*tm(2,1)                                         
     1 +tm(1,1)*tm(3,3)-tm(1,3)*tm(3,1)                                         
     2 +tm(2,2)*tm(3,3)-tm(2,3)*tm(3,2)                                         
      r=tm(1,1)*tm(2,2)*tm(3,3)                                                 
     1 +tm(1,2)*tm(2,3)*tm(3,1)                                                 
     2 +tm(2,1)*tm(3,2)*tm(1,3)                                                 
     3 -tm(3,1)*tm(2,2)*tm(1,3)                                                 
     4 -tm(3,2)*tm(2,3)*tm(1,1)                                                 
     5 -tm(2,1)*tm(1,2)*tm(3,3)                                                 
      p=-p                                                                      
      r = -r                                                                    
      a=(3.*q-p**2)/3.                                                          
      b=(2.*p**3-9.*p*q+27.*r)/27.                                              
      bimez=b/2.                                                                
      atrem=-a**3/27.                                                           
      discr=bimez**2-atrem                                                      
c---                                                                            
      if(discr) 100,100,900                                                     
  100 continue                                                                  
      csfi=-bimez/dsqrt(atrem)                                                  
      fi=acos(csfi)                                                             
      fistre=fi/3.                                                              
      csfi1=cos(fistre)                                                         
      csfi2=cos(fistre+2.*pi/3.)                                                
      csfi3=cos(fistre+4.*pi/3.)                                                
      a3sq=dsqrt(-a/3.)                                                         
c---                                                                            
      root1=2.*csfi1*a3sq                                                       
      root2=2.*csfi2*a3sq                                                       
      root3=2.*csfi3*a3sq                                                       
      root1=root1-p/3.                                                          
      root2=root2-p/3.                                                          
      root3=root3-p/3.                                                          
c---                                                                            
      eival(1)=amin1(root1,root2,root3)                                         
      eival(3)=amax1(root1,root2,root3)                                         
      eival(2)=root1+root2+root3-eival(1)-eival(3)                              
      do 200 i=1,3                                                              
      tx(1,1)=tm(1,1)-eival(i)                                                  
      tx(2,2)=tm(2,2)-eival(i)                                                  
      tx(3,3)=tm(3,3)-eival(i)                                                  
      do 210 j=1,3                                                              
      eivec(i,j)=0.0                                                            
  210 continue                                                                  
      go to (201,202,203) ,i                                                    
  201 continue                                                                  
      eivec(1,1)=tx(2,2)*tx(3,3)-tm(2,3)*tm(3,2)                                
      eivec(1,2)=tm(3,1)*tm(2,3)-tm(2,1)*tx(3,3)                                
      eivec(1,3)=tm(2,1)*tm(3,2)-tm(3,1)*tx(2,2)                                
      go to 204                                                                 
  202 continue                                                                  
      eivec(2,1)=tm(1,3)*tm(3,2)-tm(1,2)*tx(3,3)                                
      eivec(2,2)=tx(1,1)*tx(3,3)-tm(1,3)*tm(3,1)                                
      eivec(2,3)=tm(1,2)*tm(3,1)-tm(3,2)*tx(1,1)                                
      go to 204                                                                 
  203 continue                                                                  
      eivec(3,1)=tm(1,2)*tm(2,3)-tm(1,3)*tx(2,2)                                
      eivec(3,2)=tm(2,1)*tm(1,3)-tm(2,3)*tx(1,1)                                
      eivec(3,3)=tx(1,1)*tx(2,2)-tm(1,2)*tm(2,1)                                
  204 continue                                                                  
      fll=0.0                                                                   
      do 250 j=1,3                                                              
      do 250 k=1,3                                                              
c----- g(i,j) is not an unitary metric                                          
      fll =  g(j,k)*eivec(i,k)*eivec(i,j)                                       
     1    +fll                                                                  
  250 continue                                                                  
      fll=sqrt(fll)                                                             
c                                                                               
c     contravariant components                                                  
c     of eigenvectors                                                           
c                                                                               
      eivec(i,1)=eivec(i,1)/fll                                                 
      eivec(i,2)=eivec(i,2)/fll                                                 
      eivec(i,3)=eivec(i,3)/fll                                                 
  200 continue                                                                  
c----
c
c     covariant components
c     of eigenvectors
c
      do 300 i=1,3
      do 310 j=1,3
      reivec(i,j) = 0.0                                                         
      do 310 k=1,3                                                              
      reivec(i,j) = reivec(i,j)+g(j,k)*eivec(i,k)                               
  310 continue                                                                  
      flr = 0.0                                                                 
      do 350 j=1,3                                                              
      do 350 k=1,3                                                              
      flr = gr(j,k)*reivec(i,j)*reivec(i,k)+flr                                 
  350 continue                                                                  
      flr = sqrt(flr)                                                           
      reivec(i,1) = reivec(i,1)/flr                                             
      reivec(i,2) = reivec(i,2)/flr                                             
      reivec(i,3) = reivec(i,3)/flr                                             
  300 continue                                                                  
900   continue                                                                  
      return                                                                    
      end                                                                       
c
code for m1m3                                                                   
      subroutine m1m3 (udm,tdm)                                                 
      dimension udm(9), tdm(3,3)                                                
      do 100 i = 1,3                                                            
      do 200 j= 1,3                                                             
      k = (i-1)*3+j                                                             
      tdm(i,j) = udm(k)                                                         
  200 continue                                                                  
  100 continue                                                                  
      return                                                                    
      end                                                                       
c                                                                               
code for ospr                                                                   
      subroutine ospr( a,b,c)                                                   
c-----                                                                          
c----- orthogonal scalar product                                                
c-----                                                                          
      dimension a(3),b(3)                                                       
      c=0.0                                                                     
      idm = 3                                                                   
      do 10 i=1,idm                                                             
      c = c+a(i)*b(i)                                                           
   10 continue                                                                  
      return                                                                    
      end                                                                       
c                                                                               
code for xlat                                                                   
      subroutine xlat(hl)                                                       
c--set up in hl the unit cell shifts for the non-primitive lattice              
c                                                                               
c  hl  the array in which the operators are set up                              
c                                                                               
c--this subroutine also sets some variables as well as 'hl'                     
c                                                                               
c  n2p  the number of speararte shift vectors needed to describe                
c       this lattice                                                            
c  md2p number of words per shift vectors                                       
c                                                                               
c--                                                                             
      common/lst02/ ic,il,g2,isys,ngen,l2,m2,md2,n2,l2s,m2s,md2s,n2s,           
     2 l2t,m2t,md2t,n2t,l2p,m2p,md2p,n2p,l2i,m2i,md2i,n2i                       
      dimension hl(12)                                                          
c                                                                               
      md2p=3                                                                    
      n2p=il                                                                    
      if(il-4)1410,1410,1400                                                    
1400  continue                                                                  
      n2p=2                                                                     
1410  continue                                                                  
      do 1520 i=1,3                                                             
      hl(i)=0.                                                                  
1520  continue                                                                  
      go to (1700,1600,1630,1650,1600,1600,1600),il                             
c--'i' , 'a' , 'b' or 'c' centred lattice                                       
1600  continue                                                                  
      do 1610 i=4,6                                                             
      hl(i)=0.5                                                                 
1610  continue                                                                  
      if(il-4) 1700,1700,1620                                                   
1620  continue                                                                  
      hl(il-1)=0.                                                               
      go to 1700                                                                
c--'r' centred lattice                                                          
1630  continue                                                                  
      do 1640 i=5,6                                                             
      hl(i  )=0.66666667                                                        
      hl(i+3)=0.33333333                                                        
1640  continue                                                                  
      hl(4)=hl(8)                                                               
      hl(7)=hl(5)                                                               
      go to 1700                                                                
c--'f' centred lattice                                                          
1650  continue                                                                  
      k=4                                                                       
      do 1670 i=4,12,4                                                          
      do 1660 j=1,3                                                             
      hl(k)=0.5                                                                 
      k=k+1                                                                     
1660  continue                                                                  
      hl(i)=0.                                                                  
1670  continue                                                                  
1700  continue                                                                  
      return                                                                    
      end                                                                       
c
c build --- versione  1.9.92 ---
c                                                            
code for clust                                                 
      subroutine clust(ivet,ic,n2p,vett,lfl,izpk,focc,jpkint,
     *            lbuf,jumpcl,kaction,neutro,l15fin,l15con,zatom)
c--cluster searching routine
      character ib*1,str2*2
      character*6 wgrup            
      character*15 line,any,ibb,dd(9),inpco,iwr
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common/inpcl/ntype,ttype(10,5),nproj,nbond,dmaxi,radnew(8)
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)
     5,icopk(9),icoel(9),icogr(500)
c
c                                                                         
      dimension ltype(10,5),xinte(500),includ(9)
      equivalence(ttype,ltype)
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(store,istore)
      dimension izpk(500),ivet(12),numfr(100)  
      dimension vett(3,4),lindr(50),inp(9),dim(15),dax(15)
      dimension dist(100),yyy(3,100),sss(3,100),d(3,100),nop(100)
      dimension ilclus(50),figmr(50),coefmr(50),zatom(10)
      data ibb/'               '/
c      data inpco/'user condition '/
      data inpco/'* '/
      data any/'    any        '/
      data wgrup/' group'/
      data  ib/' '/
c                                
c--set the input parameters
      l15=ivet(1)
      n15=ivet(2)
      md15=ivet(3)
      l3  =ivet(4)
      n3  =ivet(5)
      md3 =ivet(6)
      l3  =ivet(7)
      n3  =ivet(8)
      md3 =ivet(9)
      l2  =ivet(10)
      n2  =ivet(11)
      md2 =ivet(12)
      l150=ivet(1)
      lfl=244000
      if(jumpcl.eq.1)then
      lbuf=l150
      return
      endif
      do 50 j=1,50
      ilclus(j)=0
      figmr(j)=0.
      coefmr(j)=0.
      lindr(j)=0
50    continue
c-- compute the sum of the relative squared intensities
      totint=0.0
      do 90 j=1,n15
c     write(ncwu,*)(store(jj),jj=l15+1+md15*(j-1),l15+md15-1+md15*(j-1))
      xinte(j)=store(l15+(j-1)*md15+7)/store(l15+7)
   90 totint=totint+xinte(j)*xinte(j)
c     write(ncwu,92)(xinte(j),j=1,n15)
c92    format (10f10.4)
      angi(1)=55. 
      angi(2)=85.
      angi(3)=55.
      angs(1)=180.
      angs(2)=145.
      angs(3)=180.
Corig if(neutro.gt.0)then
c      if(neutro.gt.0.and.kaction.lt.3)then
c              angi(1)=55.
c              angi(2)=55.
c               angi(3)=55.
c              angs(1)=180.
c              angs(2)=180.
c              angs(3)=180.
c            endif
      rtd=45.0/atan(1.0)
      if (kaction.le.3) then
          call namepk(ivet,focc,n3n,izpk,inp,neutro,zatom)
                        else
           call readpk(ivet,focc,n3n,izpk,inp,neutro,zatom)
                        endif
      jfrag=1                                
c-- print limits for interatomic bonds
      if (istat2.gt.1) then
          if (neutro.eq.0) then
                             write(ncwu,155)
                           else
                             write(ncwu,156)
                           endif
                       endif
  155 format(/,1x,'Assumed atomic parameters and limits for',
     *           ' interatomic bonds and angles',/,
     *       16x,'   (interspecies and intraspecies)'   ,//,
     1       23x,'distances',12x,'angles',7x,
     1        '  atomic  ',4x,'user',/,                                    
     1           1x,'type',3x,'radius',4x,'minimum   maximum',4x,
     1      'minimum  maximum',4x,'number',4x,'conditions',/)
  156 format(/,1x,'Assumed atomic parameters and limits for',
     *           ' interatomic bonds and angles',/,
     *       16x,'   (interspecies and intraspecies)'   ,//,
     1       23x,'distances',12x,'angles',7x,
     1        ' scattering',4x,'user',/,                                    
     1           1x,'type',3x,'radius',4x,'minimum   maximum',4x,
     1      'minimum  maximum',4x,'lenght',4x,'conditions',/)
      do 165 i=1,n3n                              
      m3=l3+(i-1)*md3
      jjj=l3dum+4+(i-1)*md
      ii=1
      do 166 ij=1,ngrup
      iii=ij-1
      if(10**iii.gt.icoel(i))go to 167
      ii=ij
166   continue
167   continue
      iwr=ibb              
      if(inp(ii).eq.i.or.radnew(n3-i+1).gt.0.0) iwr=inpco
      ijj=int(store(jjj+3))
      write(str2,'(a2)') istore(m3)
      call ucase(str2(1:1))
      if (istat2.gt.1)
     *write(ncwu,180) str2,store(jjj-3),store(jjj),store(jjj+1),
     1angi(ijj),angs(ijj) ,store(m3+13),iwr          
  165 continue                                                                 
  180 format(2x,a2,f9.3,1x,2f10.2,1x,2f10.2,f10.3,8x,a2)
c--set the addresses                                                     
      lclus=nfl
      laddr=lclus+n15
      ldis=laddr+n15
      mddis=5
      do 105 i=lclus,ldis
105   istore(i)=0
c--calculate the distances
      ddmin=dmin
      ddmax=dmax
      if (dmax.lt.5.76) dmax=5.76
      dddmax=dmax
      do 106 i=1,100
      do 107 j=1,3
      d(j,i)=0
      yyy(j,i)=0
107   sss(j,i)=0
      nop(i)=0
106   dist(i)=0
      m=ldis
      ma=laddr
      mc=lclus
c     write(ncwu,*)' clust do 150'
      do 150 j=1,n15
      ntott=0
      npk=j
      mt=m
      istore(mt)=j
      istore(mt+1)=0
c     istore(ma)=0
      istore(ma)=m
      m=m+2
      legan=0
      do 160 i=1,n15
c     if(i.eq.j)go to 160
      npk2=i
      ichng=0
      idista=idst(ivet,ic,n2p,npk,npk2,vett,nop,ntot,dist,d,yyy,sss)
      if(ntot.eq.0)go to 160
      legan=1
      ntott=ntott+ntot
      do 120 nn=1,ntot
      mer=m
      istore(m)=nop(nn)
      store(m+1)=sqrt(dist(nn))
      store(m+2)=d(1,nn)
      store(m+3)=d(2,nn)
      store(m+4)=d(3,nn)
120   m=m+mddis
160   continue
c     if(legan.eq.0)go to 149
      istore(mt+1)=ntott
      istore(ma)=mt
c149  ma=ma+1
      ma=ma+1
150   continue
      nfl=m
      lll=laddr
c     write(ncwu,*)'laddr',(ij,ij=laddr,laddr+n15-1)
      mdd=mddis
      dmi=sqrt(dmin)
      dma=sqrt(dmax)
      dmax=ddmax
      dmin=ddmin
c--create the incompatible peak table
      ladinc=nfl
      linc=ladinc+n15
      minc=linc
      mdinc=1
      do 200 ij=1,ngrup
      j=ij                  
  200 call   aninc(j,kaction,n15)
      nfl=minc
c--create the neglected peak table
      lnegl=nfl
      mnegl=lnegl
      nnegl=0
      if(kaction.gt.3)then
      do 202 ij=1,n15
      if(izpk(ij).eq.-99999)then
      istore(mnegl)=ij
      nnegl=nnegl+1
      mnegl=mnegl+1
      endif
202   continue
      endif
      nfl=lnegl+n15
c--create the addresses-conectivity table
      ladcon=nfl
      nfl=ladcon+n15
c--create the conectivity table
      lcon=nfl
      mcon=lcon
      mdcon=3
      ncon=0
      mclus=lclus
      lf=lcon+n15*30*mdcon
      do 203 jjj=mnegl,lf
203   istore(jjj)=0
c--stampa tab.
      if (istat2.gt.2) then
      do 204 jjj=1,9
204   includ(jjj)=0
      do 210 i=1,n15
      ii=icogr(i)
210   includ(ii)=includ(ii)+1
      write(ncwu,185)
      write(ncwu,185)
      write(ncwu,*)' Tentative of peak labelling in terms of atomic',
     1' species'
c          if (ngrup.gt.4) then
                            write(ncwu,4106)
                            write(ncwu,4107)
c                          else
c                            write(ncwu,4104)
c                            write(ncwu,4105)(wgrup,j,j=1,ngrup)
c                          endif
c                       endif
      ng=ngrup
      if(ng.gt.4)ng=4      
      do 4000 j=1,ngrup
      m1=ive3i(j)
      m2=ive3s(j)
      write(line(1:15),4101)(istore(l3+(m-1)*md3),ib,m=m1,m2)
      do 5148 i=1,13,3
 5148 call ucase(line(i:i))
      iang=ive(j)
      inam=istore(l3+(m2-1)*md3)
      write(str2,'(a2)') inam
      call ucase(str2(1:1))
      if(ive(j).eq.3)then
      line=any
      endif
c----------       
      do 5150 i=1,9
5150  dd(i)=ibb
      do 5200 i=1,ngrup
      if(i.lt.j)go to 5200
      dim(i)=dmnmx(i,j,1)
      dax(i)=dmnmx(i,j,2)
      write(dd(i)(1:15),4203)dim(i),dax(i)
5200  continue
c      do 5210 i=1,n15
c      ii=icogr(i)
c5210  includ(ii)=includ(ii)+1
c----------
c      if (istat2.gt.2)then         
c           if (ngrup.gt.4) then
                            write(ncwu,5103)j,includ(j),line,
     *                                      str2,angi(iang),angs(iang)
c                            else                                   
c                            write(ncwu,5102)j,includ(j),line,
c     *                str2,angi(iang),angs(iang),(dd(ij),ij=1,ngrup)
c                            endif
c                        endif
c
c                            write(ncwu,5103)j,ive15i(j),ive15s(j),line,
c     *                                      str2,angi(iang),angs(iang)
c                            else
c                            write(ncwu,5102)j,ive15i(j),ive15s(j),line,
c     *                str2,angi(iang),angs(iang),(dd(ij),ij=1,ngrup)
      line=ibb
4000  continue
c      if(ngrup.gt.4)then
c      if (istat2.gt.2) write(ncwu,5105)
c      if (istat2.gt.2) write(ncwu,4108)(wgrup,j,j=1,ngrup)
      ng1=1
      ng2=ng
      write(ncwu,5105)
5000  write(ncwu,4108)(wgrup,j,j=ng1,ng2)
      do 4300 j=ng1,ng2
      do 5160 k=1,8
5160  dd(k)=ibb
      do 4400 i=ng1,ng2    
      if(i.lt.j)go to 4400
      dim(i)=dmnmx(i,j,1)
      dax(i)=dmnmx(i,j,2)
      write(dd(i)(1:15),4203)dim(i),dax(i)
4400  continue
      write(ncwu,5104)j,(dd(ij),ij=ng1,ng2)
4300  continue
      if(ng2.lt.ngrup)then
      write(ncwu,4108)(wgrup,j,j=ng2+1,ngrup)
      do 4301 j=ng1,ng2
      do 5161 k=1,8
5161  dd(k)=ibb
      do 4401 i=ng2+1,ngrup    
      dim(i)=dmnmx(i,j,1)
      dax(i)=dmnmx(i,j,2)
      write(dd(i)(1:15),4203)dim(i),dax(i)
4401  continue
      write(ncwu,5104)j,(dd(ij),ij=ng2+1,ngrup)
4301  continue
      ng1=ng1+1
      ng2=ngrup
      go to 5000
                     endif
                     endif
      if (istat2.gt.1) write(ncwu,4102)
4101  format(5(a2,a1))
4102  format(1x,78('-'))
4104  format(//,
     *'  group',3x,'   peaks',3x,'   possible    ',3x,' species',3x,
     *'  range of ',4x,
     *'range of bond distances used to build fragments')
4105  format(' number',3x,'included',2x,'chemical species',3x,
     3  'assigned',3x,'bond angles',4(6x,a6,i2,1x))
4107  format(' number',3x,'included',2x,'chemical species',3x,
     3  'assigned',3x,'bond angles')
4106  format(/,
     *'  group',3x,'   peaks',3x,'   possible    ',3x,' species',3x,
     *'  range of ')
4108  format(3x,'group',8(6x,a6,i2,1x))
5103  format(1x,i4,4x,3x,i3,6x,a15,3x,2x,a2,3x,4x,f4.0,' - ',f4.0)
c5102  format(1x,i4,4x,3x,i3,6x,a15,3x,2x,a2,3x,4x,f4.0,' - ',f4.0,
c     *                       2x,8a15)
c5102  format(1x,i4,4x,i3,' - ',i3,3x,a15,3x,2x,a2,3x,4x,f4.0,' - ',f4.0,
c     *                      2x,8a15)
c5103  format(1x,i4,4x,i3,' - ',i3,3x,a15,3x,2x,a2,3x,4x,f4.0,' - ',f4.0)
5104  format(2x,i4,2x,8a15)
5105  format(/,' range of bond distances used to build fragments')
 4203 format(2x,'(',f4.1,' -',f4.1,' )')
c
c
c     write(ncwu,185) itle
c 185 format(//,20x,20a4,//)
 185  format(1h )
      lll=laddr  
      mdd=mddis
      ddmax=dmax
      dmax=dddmax
      dma=sqrt(dmax)
      if (istat2.gt.1) write(ncwu,1) dma
1     format(2x,'interpeak distances up to ',f5.2,/)
      call sttab(lll,mdd,n15)
      dmax=ddmax
c
      do 300 jjj=1,ngrup
      jj=jjj              
      call andis(jj,kaction,n15)
300   continue
      nfl=mcon
      lang=nfl
      lll=-ladcon
      mdd=mdcon
      if(istat2.gt.2) then
      write(ncwu,4004)
      write(ncwu,'(44h  accepted distances in this interpretation ,/)')
      call sttab(lll,mdd,n15)
4004  format(1h )
      endif
      if (istat2.gt.1) write(ncwu,4004)
      madinc=ladinc
      nnn=0
      do 222 j=1,n15
      minc=istore(madinc)
      numb=istore(minc)
      if(numb.eq.0)go to 222
      if(nnn.eq.0.and.istat2.gt.1) write(ncwu,220)
      nnn=1
      if (istat2.gt.1) write(ncwu,221)j,(istore(minc+m),m=1,numb)
222   madinc=madinc+1
220   format(' list of unconsistent peaks  ')
221   format(1x,i4,' with ',18i4)
      if(nnegl.gt.0.and.istat2.gt.1)
     *write(ncwu,310)(istore(jjj),jjj=lnegl,lnegl+nnegl-1)
310   format(/,' the following peaks have been neglected: ',
     *9i4,/,5(20i4,/))
      call calang(ivet,rtd)
      icodpr=0
      if(istat2.eq.0)icodpr=-1
      ilclus(1)=lclus
      l=ilclus(1)
      jj=1
      do 9003 i=l,l+n15-1
      if (izpk(jj).ne.-99999) then
                                istore(i)=100
                              else
                                istore(i)=-101
                              endif
      jj=jj+1
 9003 continue
      introk=0
      ntent=1
      iloop=1
      lclus=ilclus(1)
      call intclu(ivet,numfr,n3n,iloop,ntent,ilclus,fgmr,totint,xinte,
     ,kaction)                                                       
c      write(ncwu,*)'lclus ',lclus,(istore(jjj),jjj=lclus,lclus+n15-1)
c      write(ncwu,*)'nfrag ',nfrag
9000  introk=introk+nfrag
      nfl0=nfl
      lbuf=l150
      icodpr0=icodpr
      nproj0=nproj
      if (introk.eq.0) then
                         l15a=l15fin
                         do 9045 j=1,n15
                         if(izpk(j).ge.0)
     1                   izpk(j)=-1*(iabs(izpk(j))*100+1)
                         do 9044 jj=2,4
                         xxx=amod(store(l15a+jj),1.0)
                         if (xxx.lt.0.0) xxx=xxx+1.0
                         store(l15a+jj)=xxx
9044                     continue
                         l15a=l15a+md15
9045                     continue
                         return
                       endif
      nstpmx=1
      icodpr=icodpr0
      nproj=nproj0
      nfl=nfl0
      ivet(1)=l150
      m=ivet(1)
      do 9060 i=nfl,lfl
9060  store(i)=0.
      ix=1
      lclus=ilclus(ix)
      mclus=lclus
      do 9150 i=1,100
9150  numfr(i)=0
      nfrag=0
      do 9200 i=1,n15
      if(jcod(istore(mclus)).ne.3)go to 9200
      ii=jordfr(istore(mclus))
      numfr(ii)=numfr(ii)+1
      if(nfrag.le.ii)nfrag=ii
9200  mclus=mclus+1
      introk=0
      if(nfrag.eq.0)go to 9000
c      write(ncwu,*)' nfrag,numfr  ',nfrag,( numfr(ii),ii=1,nfrag)
c      if(j.gt.1)go to 699
      mclus=lclus
      do 600 i=1,n15
      m=istore(mclus)
      jfrag=jordfr(m)
      if (izpk(i).ne.-99999) izpk(i)=iabs(izpk(i))*100+jfrag
      if(jcod(m).eq.3)go to 600
      if (izpk(i).ne.-99999) izpk(i)=-izpk(i)
600   mclus=mclus+1
      if(nnegl.eq.0)go to 699
      do 650 i=1,nnegl
      m=istore(lnegl+i-1)
650   izpk(m)=-99999
699   mclus=lclus
      if (istat2.gt.0) then
      write(ncwu,4102)
      write(ncwu,4102)
      write(ncwu,4004)
                       endif
      do 9300 i=1,50
9300  lindr(i)=0
c      jstor=j
      jstor=1
c      write(ncwu,*)'storcl,lclus',(istore(lc),lc=lclus,lclus+n15-1)
      call storcl(jstor,ivet,numfr,lindr,n3n,ic,n2p,vett,dddx,lbuf,
     *          izpk,l15con)
      if(nproj.ne.0.or.icodpr.ne.-1)then
      if(nbond.eq.1)
     *      call bonder(ivet,lcon1,numfr,lindr,nn15,ll15,l15con)
          call cluprz(ivet,g,icodpr,nn15,ll15,lbuf)
        endif
      call stclu(ivet,numfr,lindr,icodpr,nn15,ll15,lbuf)
      ivet(1)=l150
      ivet(1)=ll15
c      write(ncwu,601)(izpk(i),i=1,n15)
c601   format(1x,' izpk ',10i7)
      return
      end
c
code for aninc                         
      subroutine aninc(n,kaction,n15)
c--analize little distances
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)
     5,icopk(9),icoel(9),icogr(500)
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(store,istore)
c
c       write(ncwu,*)'icogr',(icogr(j),j=1, 15)
      limi15=ive15i(n)
      lims15=ive15s(n)
      if(kaction.ge.3)then
      limi15=1            
      lims15=n15    
      endif
      maddr=laddr+limi15-1
      madinc=ladinc+limi15-1
      do 210  j=limi15,lims15
c      write(ncwu,*) 'j,icogr(j),n,madinc ',j,icogr(j),n,madinc
      if(icogr(j).ne.n)go to 211
      m=istore(maddr)
      ni=istore(m+1)
      numb=0
      minc1=minc
      istore(madinc)=minc1
c      write(ncwu,*) 'm,ni,istore(m+2)',m,ni,istore(m+2)
      istore(minc1  )=0
      minc=minc+1
      if(ni.eq.0)go to 211
      m=m+2
      do 220 i=1,ni
c     write(ncwu,*)' m,i,istore(m) ',m,i,istore(m)
      call iorop(m,icentr,itx,ity,itz,nord,nop,kkk)
      ng2=icogr(nord)
      dmxh =dmnmx(n,ng2,2)
      dmnh =dmnmx(n,ng2,1)
      if(dmnh.gt.store(m+1).and.istore(minc-1).ne.nord)then
c--store   the peak
                              numb=numb+1
                              istore(minc)=nord
                              minc=minc+mdinc
                            endif
      m=m+mddis
220   continue
      istore(minc1  )=numb
211   maddr=maddr+1
      madinc=madinc+1
210   continue
      return
      end
c
code for namepk
      subroutine namepk(ivet,focc,n3n,izpk,inp,neutro,zatom)
c--gives  name to the peaks
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common/inpcl/ntype,ttype(10,5),nproj,nbond,dmaxi,radnew(8)
      dimension ltype(10,5)
      equivalence(ttype,ltype)
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)
     5,icopk(9),icoel(9),icogr(500)
      common /xdata/ store(244000)
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      dimension istore(244000)
      equivalence(store,istore)
      dimension izpk(500),ivet(12)
      dimension pic(9),npic15(9),rapic(9),rap(9),inp(9),zatom(10)
c
      l15=ivet(1)
      n15=ivet(2)
      md15=ivet(3)
      l3  =ivet(4)
      n3  =ivet(5)
      md3 =ivet(6)
      l3  =ivet(7)
      n3  =ivet(8)
      md3 =ivet(9)
      l2  =ivet(10)
      n2  =ivet(11)
      md2 =ivet(12)
c
      epsmin = 0.35
      epsmax = 0.41
      if(erre.lt.0.15.and.erre.gt.0.0) epsmin = 0.54
c
      ngh=0
      ngl=0
      nok=0
      ngrup=1
      do 40 i=1,9
      inp(i)=0
      dmn(i)=0
      dmx(i)=0
      ive(i)=0
      pic(i)=0
      npic15(i)=0
      rapic(i)=0
      rap(i)=0
      icopk(i)=0
      icoel(i)=0
      ive3i(i)=0
      ive3s(i)=0
      ive15i(i)=0
40    ive15s(i)=0
      do 41 i=1,500
41    icogr(i)=0
C41   izpk(i)=0
      do 42 i=1,9
      do 42 j=1,9
      dmnmx(i,j,1)=0.
42    dmnmx(i,j,2)=0.
c--
      l3dum=nfl
      md=8
      m=l3dum
      m3=l3
      n3n=n3
      if(store(l3+(n3-1)*md3+13).lt.1.5.and.neutro.eq.0)n3n=n3-1
      n3=n3n
      a=0.
      do  50 i= 1,n3
      if(store(m3+13).ge.11.and.neutro.eq.0)ngh=ngh+1
      store(m  )=store(m3+12)*focc
      store(m+1)=store(m3+15)
      store(m+2)=store(m3+13)
      store(m+3)=0
      store(m+4)=0
      store(m+5)=0
      store(m+6)=i
      store(m+7)=2
c      write(ncwu,*) 'l3dum  ',i,(store(nn),nn=m,m+md-1)
      a=a+store(m)
      if(a.lt.n15)go  to 49
      if(nint(a).eq.n15.and.i.eq.n3)go to 49
      nn=n3-n3n
      n3=i
      n3n=n3-nn
      store(m)=n15-a+store(m)
      write(ncwu,48)store(m3),store(m)
48    format(/,1x,'not enought peaks present . the lightest ',
     1'specie considered is ',a2,', asymetric unit content = ',f9.2)
      m=m+md
      go to 55
49    m=m+md
50    m3=m3+md3
55    n3=n3n
      l=l3dum
      nfl=m
      ngl=n3n-ngh
c--sort decreasing radius  mode
      jump=-2
      call sortz(l3dum,n3,md,jump)
      dmi=store(l+1+(n3n-1)*md)
      dma=store(l+1)
      dmin=2*dmi-epsmin
      if (dmax.lt.0.5) dmax=2*dma+epsmax
      dmin=dmin*dmin
      dmax=dmax*dmax
c--sort decrease-z mode
      jump=-3
      call sortz(l3dum,n3,md,jump)
      lm=nfl
      mm=lm
      m=l3dum
      do 60 i=1,n3
      store(m+3)=0
      if(i.le.ngh)then
      if(i.lt.n3n)store(m+3)=store(m+2)/store(m+2+md)
      if(i.ge.n3n)store(m+3)=store(m+2)
      endif                        
      store(m+4)=dmi+store(m+1)-epsmin
      if(store(m+4).lt.0.8)store(m+4)=.8
      store(m+5)=dma+store(m+1)+epsmax
      if(store(m+5).lt.store(m+4))store(m+5)=store(m+4)
      if(zatom(i).gt.18)store(m+7)=1
      store(mm)=store(m)
      store(mm+1)=store(m+1)
      store(mm+2)=store(m+2)
      store(mm+3)=store(m+3)
      store(mm+4)=store(m+4)
      dmn(i)=store(m+4)
      store(mm+5)=store(m+5)
      dmx(i)=store(m+5)
      store(mm+6)=store(m+6)
      store(mm+7)=store(m+7)
c     write(ncwu,*) 'l3dum  ',i,(store(nn),nn=mm,mm+md-1)
c     write(ncwu,*) 'l3dum  ',i,(store(nn),nn=m,m+md-1)
      mm=mm+md
60    m=m+md
      ive3i(1)=1
      ive3s(1)=n3n
      ive15i(1)=1
      ive15s(1)=n15
      ive(1)=2
      if(ngh.eq.0)go to 560
      a=0.
      mlm=l3dum
      do 100  i=1,ngh
      pic(i)=a+store(mlm)
      a=pic(i)
      ifin=i
      call pic15(ivet,focc,a,np)
      npic15(i)=np
c      write(ncwu,*)' i,a,npic  ',i,a,npic15(i)
      if(store(mlm+3).lt.1.35)go to 100
      m15=l15+(npic15(i)-1)*md15+7
      mm15=m15+md15
      rapic(i)=store(m15)/store(mm15)
      rap(i)=store(mlm+3)*.222+1.167
c      write(ncwu,*)' i,rapic,rap ',i,rapic(i),rap(i)
      if(rapic(i).lt.rap(i))go to 100
      ifin=0
      nok=1
      ive3s(ngrup)=i
c      write(ncwu,*)' ngrup,i,store(l3dum+(i-1)*md+6) ',
c     1 ngrup,i,store(l3dum+(i-1)*md+6)
      ive15s(ngrup)=npic15(i)
      if (ive15s(ngrup).lt.ive15i(ngrup)) then
                                          if (istat2.gt.1) write(ncwu,*)
     * ' Possible error in the unit cell content'
                                            ive15s(ngrup)=ive15i(ngrup)
                                          endif
      ij=ive3i(ngrup)
      ive(ngrup)=1
c     write(ncwu,*)'163,ngrup,ive(ngrup),ive3i(ngrup),ive15i(ngrup),',
c    1'ive3s(ngrup),ive15s(ngrup)',
c    2ngrup,ive(ngrup),ive3i(ngrup),ive15i(ngrup),
c    3ive3s(ngrup),ive15s(ngrup)
      ngrup=ngrup+1
      ive3i(ngrup)=i+1
      ive15i(ngrup)=npic15(i)+1
100   mlm=mlm+md
c--
c      write(ncwu,*)'172,ngrup,ive(ngrup),ive3i(ngrup),ive15i(ngrup),',
c     1'ive3s(ngrup),ive15s(ngrup)',
c     2ngrup,ive(ngrup),ive3i(ngrup),ive15i(ngrup),
c     3ive3s(ngrup),ive15s(ngrup)
      if(ifin.ne.0)go to 200
      if(n3n.eq.ngh)then
      ive3i(ngrup)=0
      ive15i(ngrup)=0
      ngrup=ngrup-1
      ive15s(ngrup)=n15
      go to 590
      else
      ive3s(ngrup)=n3n
      ive15s(ngrup)=n15
      ive(ngrup)=2
      go to 560
      endif
200   continue
c-- procedura nok=0
c      write(ncwu,*)'190,ngrup,ive(ngrup),ive3i(ngrup),ive15i(ngrup),',
c     1'ive3s(ngrup),ive15s(ngrup)',
c     2ngrup,ive(ngrup),ive3i(ngrup),ive15i(ngrup),
c     3ive3s(ngrup),ive15s(ngrup)
      inf=ive3i(ngrup)
      infg=inf
c     mlm=l3dum+3
      mlm=l3dum+3+(inf-1)*md
      a=0.
      do 300 i=inf,ngh
      if(a.ge.store(mlm))go to 300
      if(npic15(i).le.1)go to 300
      a=store(mlm)
      ml=mlm
      infg=i
300   mlm=mlm+md
      inf=ive15i(ngrup)
      isup=npic15(infg)
c     isup=npic15(ngh)
      ive(ngrup)=3
      ive3s(ngrup)=ngh
c     ive15s(ngrup)=npic15(ngh)
      mm=npic15(infg)
      mm15=l15+mm*md15+7
      ff=store(mm15)*rap(infg)
      m15=l15+(ive15i(ngrup)-1)*md15+7
      do 400 i=inf,isup
      ij=i-1
      if(store(m15).le.ff)go to 450
400   m15=m15+md15
c      write(ncwu,*)'220,ngrup,ive(ngrup),ive3i(ngrup),ive15i(ngrup),',
c     1'ive3s(ngrup),ive15s(ngrup)',
c     2ngrup,ive(ngrup),ive3i(ngrup),ive15i(ngrup),
c     3ive3s(ngrup),ive15s(ngrup)
      if(ive15s(ngrup).lt.n15)go to 500
      ive3s(ngrup)=n3n
      go to 590
c--peaks like heavy
450   continue
      if(ij.lt.inf)go to 470
      ive3s(ngrup)=infg
      ii=ive3i(ngrup)
c     do 460 l=ii,infg
c460   icoel(l)=icoel(l)+10**(ngrup-1)
c460   icoel(l)=ngrup
      ive15s(ngrup)=ij
      ive(ngrup)=1
c     if(ij.eq.isup)go to 500
c--peak like ambigui
      ngrup=ngrup+1
470   ive(ngrup)=3
      ive15i(ngrup)=ij+1
      ive15s(ngrup)=npic15(ngh)
      if(ngh.eq.n3n)ive15s(ngrup)=n15
      ive3i(ngrup)=1
      if(ngrup.gt.1)ive3i(ngrup)=ive3i(ngrup-1)
      ive3s(ngrup)=ngh
      if(n3n.gt.ngh)ive3s(ngrup)=ngh+1
      ii=ive3i(ngrup)
c     do 480 i=ii,ngh
c480   icoel(i)=icoel(i)+10**(ngrup-1)
c      write(ncwu,*)'248,ngrup,ive(ngrup),ive3i(ngrup),ive15i(ngrup),',
c     1'ive3s(ngrup),ive15s(ngrup)',
c     2ngrup,ive(ngrup),ive3i(ngrup),ive15i(ngrup),
c     3ive3s(ngrup),ive15s(ngrup)
500   if(n3n.eq.ngh)go to 590
c-- carboni
      ngrup=ngrup+1
      ive3i(ngrup)=ngh+1
      ive3s(ngrup)=n3n
      ive15i(ngrup)=ive15s(ngrup-1)+1
      ive15s(ngrup)=n15
      ive(ngrup)=2
c      write(ncwu,*)'260,ngrup,ive(ngrup),ive3i(ngrup),ive15i(ngrup),',
c     1'ive3s(ngrup),ive15s(ngrup)',
c     2ngrup,ive(ngrup),ive3i(ngrup),ive15i(ngrup),
c     3ive3s(ngrup),ive15s(ngrup)
560   ii=ive3i(ngrup)
c     do 570 i=ii,n3n
c570   icoel(i)=icoel(i)+10**(ngrup-1)
c--set distances
590   continue
c      write(ncwu,*)'269,ngrup,ive(ngrup),ive3i(ngrup),ive15i(ngrup),',
c     1'ive3s(ngrup),ive15s(ngrup)',
c     2ngrup,ive(ngrup),ive3i(ngrup),ive15i(ngrup),
c     3ive3s(ngrup),ive15s(ngrup)
      do 900 i=1,ngrup
      inf=ive15i(i)
      isup=ive15s(i)
      inf2=ive3i(i)
      isup2=ive3s(i)
      do 910 j=inf2,isup2
910   icoel(j)=icoel(j)+10**(i-1)
      do 900 j=inf,isup
      if (izpk(j).ne.-99999) izpk(j)=ive3s(i)
      icogr(j)=i
c      write(ncwu,*)' inf2,isup2,icogr(j),j',inf2,isup2,icogr(j),j
900   continue
      npeahi=1
      do 950 i=1,ngrup
      if(ive(i).eq.1)npeahi=ive15s(i)
950   continue
      ive15s(ngrup)=n15
      do 600 i=1,ngrup
      inf=ive3i(i)
      isup=ive3s(i)
      mlm=l3dum+(inf-1)*md+1
      dmn(i)=1000.
      dmx(i)=0.
      do 650 j=inf,isup
      if(store(mlm).le.dmn(i))dmn(i)=store(mlm)
      if(store(mlm).lt.dmx(i))go to 650
      dmx(i)=store(mlm)
c      icopk(i)=store(mlm+6)
650   mlm=mlm+md
600   continue
      do 700 i=1,ngrup
      do 710 j=1,ngrup
      dmnmx(i,j,1)=dmn(i)+dmn(j)-epsmin
      if(dmnmx(i,j,1).lt.0.8) dmnmx(i,j,1)=0.8
      dmnmx(i,j,2)=dmx(i)+dmx(j)+epsmax
      if(dmnmx(i,j,2).lt.dmnmx(i,j,1)) dmnmx(i,j,2)=dmnmx(i,j,1)    
710   continue
700   continue
c--set the limits from input
      if(ntype.eq.0)go to 850
      do 800 k=1,ntype
      do 810 i=1,n3n
      if(ltype(k,5).ne.i)go to 810
      mlm=l3dum+(i-1)*md+4
      do 820  n=1,ngrup
      ll=icoel(i)/10**(n-1)
      l=ll-(ll/10**n)*10**n
      if(l.eq.0)go to 820
      if(inp(n).eq.0)go to 828
      if(inp(n).le.ltype(k,5))then
      mml=l3+(i-1)*md3
      write(ncwu,826)istore(mml)
826   format(1x,'input conditions about the ',a2,' specie can not be '
     1,'applied',/)
      go to 800
      else
      mml=l3+(inp(n)-1)*md3
      write(ncwu,826)istore(mml)
      endif
828   inp(n)=ltype(k,5)
      if(ttype(k,2).gt.0.3)store(mlm)=ttype(k,2)
      if(ttype(k,3).gt.0.3)store(mlm+1)=ttype(k,3)
c      if(ltype(k,4).gt.0  )icopk(n)=ltype(k,4)
      if(ltype(k,4).gt.0  )ive(n)=ltype(k,4)
      do 830 m=1,2
      do 830 j=1,ngrup
      if(ttype(k,m+1).le.0.3)go to 830
      dx=sqrt(dmax)
      if(dmnmx(n,j,2).gt.dx)dmax=dmnmx(n,j,2)**2
      dmnmx(n,j,m)=ttype(k,m+1)
      dmnmx(j,n,m)=ttype(k,m+1)
830   continue
820   continue
810   continue
800   continue
850   continue
c
c--redefinisce ive solo per neutro=1
c  ive(i)=1 al meno un elemento del gruppo ha z maggiore di 18
c  ive(i)=2 sono tutti non metallici       
      if(neutro.eq.1)then         
      do 851 j=1,ngrup     
      inf =ive3i(j)
      isup =ive3s(j)
      do 852 i=inf,isup         
      if(zatom(i).gt.18)ive(j)=1
852   continue
851   continue
      endif
c       write(ncwu,*)'namepk,icogr ',(icogr(i),i=1,n15)
c       write(ncwu,*)'namepk,icopk ',(icopk(i),i=1,n3n)
c      write(ncwu,*)'namepk,ive   ',(ive(i),i=1,n3n)
c      write(ncwu,*)'namepk ,icogr',(icogr(i),i=1,n15)
c      write(ncwu,*)'n15,ngrup,izpk  ',n15,ngrup,(izpk(i),i=1,n15)
      return
      end
c
code for readpk
      subroutine readpk(ivet,focc,n3n,izpk,inp,neutro,zatom)
c--gives  name to the peaks
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common/inpcl/ntype,ttype(10,5),nproj,nbond,dmaxi,radnew(8)
      dimension ltype(10,5)
      equivalence(ttype,ltype)
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)
     5,icopk(9),icoel(9),icogr(500)
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(store,istore)
      dimension izpk(500),ivet(12)                     
      dimension pic(9),npic15(9),rapic(9),rap(9),inp(9),zatom(10)
c                                                      
      epsmin = 0.35
      epsmax = 0.41
      if(erre.lt.0.15.and.erre.gt.0.0) epsmin = 0.54
c
      l15=ivet(1)
      n15=ivet(2)
      md15=ivet(3)
      l3  =ivet(4)
      n3  =ivet(5)
      md3 =ivet(6)
      l3  =ivet(7)
      n3  =ivet(8)
      md3 =ivet(9)
      l2  =ivet(10)
      n2  =ivet(11)
      md2 =ivet(12)
      ngh=0
      ngl=0
      nok=1
      ngrup=1
      do 40 i=1,9
      inp(i)=0
      dmn(i)=100
      dmx(i)=0
      ive(i)=0
      pic(i)=0
      npic15(i)=0
      rapic(i)=0
      rap(i)=0
      icopk(i)=0
      icoel(i)=0
      ive3i(i)=0
      ive3s(i)=0
      ive15i(i)=0
40    ive15s(i)=0
      do 41 i=1,500
41    icogr(i)=0
C41   izpk(i)=0
      do 42 i=1,9
      do 42 j=1,9
      dmnmx(i,j,1)=0.
42    dmnmx(i,j,2)=0.
c--
      n3n=n3
      if(store(l3+(n3-1)*md3+13).lt.1.5.and.neutro.eq.0)n3n=n3-1
      n3=n3n
      l3dum=nfl
      md=8
      m=l3dum
      m3=l3
      dma=0.
      dmi=100.
      ive3i(1)=1
      ive15i(1)=1
      i=0
c56    format(1x,2i10,2a10,2i5)
      acum=0.
      do  50 ii= 1,n3n
      store(m)=0
      m15=l15
      j0=0         
       do 55 j=1,n15                            
c1     format(5x,2i3,1x,i2,2x,a2)
c       write(ncwu,*)' ii,j,j0 ',ii,j,istore(m15),istore(m3),j0
      if(istore(m15).ne.istore(m3))go to 55
      if(j0.eq.0) then
                    j0=j
            i=i+1
                    icoel(ii)=10**(i-1)+icoel(ii)
                  endif
      store(m)=store(m)+store(m15+6)
      icogr(j)=i 
c      if (izpk(j).ne.-99999) izpk(j)=i
      ive15s(i)=j
      acum=acum+store(m)
55    m15=m15+md15
      if(acum.le.0)then
      ive3i(1)=ii+1
      else
      if(store(m3+13).ge.11.and.neutro.eq.0)ngh=ngh+1
      if(store(m3+15).ge.dma)dma=store(m3+15)
      if(store(m3+15).le.dmi)dmi=store(m3+15)
      endif
      store(m+1)=store(m3+15)
      store(m+2)=store(m3+13)
      store(m+3)=0
      store(m+4)=0
      store(m+5)=0
      store(m+6)=ii
      store(m+7)=2                                
c      write(ncwu,*)' n3,n15,             ',n3,n15             
c      write(ncwu,*)' ii,i,j0 ,ive15i(i)',ii,i,j0,ive15i(i)
      if(j0.eq.0)go to 49
      ive15i(i)=j0
      ive(i)=2                       
c      if(store(m+2).gt.8 )ive(i)=1
      if(zatom(ii).gt.18)ive(i)=1           
c      if(store(m+2).gt.18)store(m+7)=1
      if(zatom(ii).gt.18)store(m+7)=1
      ive3s(i)=ii
      ive3i(i+1)=ii+1
c      icopk(i)=int(store(m+7))
c      icopk(i)=int(store(m+6))
49    m=m+md
50    m3=m3+md3
      ngrup=i
      if(ngrup.eq.0)then
      write(ncwu,*)' Given peaks cannot be recognized '
      stop
      endif
      l=l3dum
      nfl=m
      ngl=n3n-ngh
      dmin=2*dmi-epsmin
      dmax=2*dma+epsmax
      dmin=dmin*dmin
      dmax=dmax*dmax
      m=l3dum
      do 60 i=1,n3
      store(m+4)=dmi+store(m+1)-epsmin
      if(store(m+4).lt.0.8)store(m+4)=.8
      store(m+5)=dma+store(m+1)+epsmax
      if(store(m+5).lt.store(m+4))store(m+5)=store(m+4)
      dmn(i)=store(m+1)
      dmx(i)=store(m+1)
60    m=m+md
c--da namepk
      do 600 i=1,ngrup
      inf=ive3i(i)
      isup=ive3s(i)
      mlm=l3dum+(inf-1)*md+1
      dmn(i)=1000.
      dmx(i)=0.
      do 650 j=inf,isup
      if(store(mlm).le.dmn(i))dmn(i)=store(mlm)
      if(store(mlm).lt.dmx(i))go to 650
      dmx(i)=store(mlm)
c      icopk(i)=store(mlm+6)
650   mlm=mlm+md
600   continue
      do 700 i=1,ngrup
      do 710 j=1,ngrup
      dmnmx(i,j,1)=dmn(i)+dmn(j)-epsmin
      if(dmnmx(i,j,1).lt.0.8) dmnmx(i,j,1)=0.8
      dmnmx(i,j,2)=dmx(i)+dmx(j)+epsmax
      if(dmnmx(i,j,2).lt.dmnmx(i,j,1)) dmnmx(i,j,2)=dmnmx(i,j,1)    
710   continue
700   continue
      npeahi=1
      do 950 i=1,ngrup
      if(ive(i).eq.1)npeahi=ive15s(i)
950   continue
c--set the limits from input
      if(ntype.eq.0)go to 850
      do 800 k=1,ntype
      do 810 i=1,n3n
      if(ltype(k,5).ne.i)go to 810
      mlm=l3dum+(i-1)*md+4
      do 820  n=1,ngrup
      ll=icoel(i)/10**(n-1)
      l=ll-(ll/10**n)*10**n
      if(l.ne.1)go to 820
      inp(n)=ltype(k,5)
      if(ttype(k,2).gt.0.3)store(mlm)=ttype(k,2)
      if(ttype(k,3).gt.0.3)store(mlm+1)=ttype(k,3)
c      if(ltype(k,4).gt.0  )icopk(n)=ltype(k,4)
      if(ltype(k,4).gt.0  )ive(n)=ltype(k,4)
      do 830 m=1,2
      do 830 j=1,ngrup
      if(ttype(k,m+1).le.0.3)go to 830
      dx=sqrt(dmax)
      if(dmnmx(n,j,2).gt.dx)dmax=dmnmx(n,j,2)**2
      dmnmx(n,j,m)=ttype(k,m+1)
      dmnmx(j,n,m)=ttype(k,m+1)
830   continue
820   continue
810   continue
800   continue
850   continue
c       write(ncwu,*)'readpk,icogr ',(icogr(i),i=1,n15)
c       write(ncwu,*)'readpk,icopk ',(icopk(i),i=1,n3n)
c      write(ncwu,*)'n15,ngrup,izpk  ',n15,ngrup,(izpk(i),i=1,n15)
      return
      end
c     
code for andis           
      subroutine andis(n,kaction,n15)
c--analyze distances
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)
     5,icopk(9),icoel(9),icogr(500)
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(store,istore)
c
c      write(ncwu, *)' andis kaction ',  kaction
      limi15=ive15i(n)
      lims15=ive15s(n)
      if(kaction.ge.3)then
      limi15=1            
      lims15=n15    
      endif
      maddr=laddr+limi15-1
      madcon=ladcon+limi15-1
c     mclus=lclus
      do 210  j=limi15,lims15
      if(icogr(j).ne.n)go to 211
      m=istore(maddr)
      ni=istore(m+1)
      mnegl=lnegl
      if(nnegl.eq.0)go to 213
      do 212 ji=1,nnegl
      if(istore(mnegl).eq.j)then
      istore(madcon)=0
      go to 211
      endif
212   mnegl=mnegl+1
213   numb=0
      m1con=mcon
      istore(madcon)=m1con
      istore(m1con)=j
      istore(m1con+1)=0
      mcon=mcon+2
      if(ni.eq.0)go to 211
      m=m+2
      do 220 i=1,ni
      call iorop(m,icentr,itx,ity,itz,nord,nop,kkk)
      if(nnegl.eq.0)go to 223
      mnegl=lnegl
      do 222 ji=1,nnegl
      if(nord.eq.istore(mnegl))go to 219
      mnegl=mnegl+1
222   continue
223   continue
      mg1=icogr(j)
      mg2=icogr(nord)
      dmxh =dmnmx(mg1,mg2,2)
      dmnh =dmnmx(mg1,mg2,1)
      if(dmnh.gt.store(m+1))then
      if(j.gt.nord.or.ive(n).gt.1)go to 219
c--eliminate the peak
      mnegl=lnegl
      if(nnegl.eq.0)go to 226
      do 225 ji=1,nnegl
      if(nord.eq.istore(mnegl))go to 228
225   mnegl=mnegl+1
226   istore(mnegl)=nord
      nnegl=nnegl+1
228   continue
      if(j.eq.1)go to 219
      madc=ladcon
      do 230 ji=1,j-1
      nn0=0
      mm=istore(madc)
      if(mm.eq.0)go to 230
      mm0=mm+1
      nn=istore(mm0)
      mm=mm+2
      if (nn.eq.0.or.istore(mm0-1).eq.0) go to 230
      do 240 jj=1,nn
      if (jj.gt.100) stop 1313
      if (istore(mm+1).ne.nord) go to 240
      istore(mm)=0
      istore(mm0)=nn-1
      if(jj.eq.nn)go to 230
      do 245 jk=jj,nn-1
      istore(mm  )=istore(mm  +mdcon)
      istore(mm+1)=istore(mm+1+mdcon)
      istore(mm+2)=istore(mm+2+mdcon)
245   mm=mm+mdcon
      go to 230
240   mm=mm+mdcon
230   madc=madc+1
      go to 219
      endif
      if(dmxh.lt.store(m+1))go to 219
      numb=numb+1
      istore(mcon)=m
      istore(mcon+1)=istore(m)
c     istore(mcon+1)=nord
      istore(mcon+2)=0
      mcon=mcon+mdcon
219   m=m+mddis
220   continue
      istore(m1con+1)=numb
      if(numb.eq.0)go to 211
      ncon=ncon+1
c     istore(mclus)=j
      mclus=mclus+1
211   maddr=maddr+1
      madcon=madcon+1
210   continue
      return
      end
c
code for idst
      function idst(ivet,ic,n2p,npk,npk2,vett,nop,ntot,dist,dd,yyy,ss)
c--check if two peaks are closer than dmax (idst=1, ntot=1)
c--check if two peaks are farther than dmax (idst=0, ntot=0)
c--check if two peaks are closer than dm angstroms (idst=0 , ntot=1)
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)
     5,icopk(9),icoel(9),icogr(500)
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(store,istore)
      dimension dist(100),nop(100),yx(3,100),d2(3)
      dimension dd(3,100),d(3),ivet(12),yyy(3,100),ddd(3),ss(3,100)
      dimension x(3),y(3),yy(3),z(3),vett(3,4),iss(3),sss(3)
c--
c     write(ncwu,* )'  idst'
      l15=ivet(1)
      n15=ivet(2)
      md15=ivet(3)
      l3  =ivet(4)
      n3  =ivet(5)
      md3 =ivet(6)
      l3  =ivet(7)
      n3  =ivet(8)
      md3 =ivet(9)
      l2  =ivet(10)
      n2  =ivet(11)
      md2 =ivet(12)
      ift1=400*49*10
      ift2=49*10
      ift3=10
      e10=1.0e-10
      idst=0
      istras=0
      dm=dmin
      ntot=0
      do 99 j=1,3
      if(npk.lt.0)z(j)=dist(j)
99    continue
      do 100 j=1,3
      d(j)=0.
      do 100 n=1,100
      dist(n)=0.
      dd(j,n)=0.
      yyy(j,n)=0.
      ss(j,n)=0.
100   continue
      if(npk.gt.0)m=l15+(npk-1)*md15 +2
      mm=l15+(npk2-1)*md15 +2
      mmm=mm
      do 1000 n=1,3
      if(npk.gt.0)z(n)=store(m)
      x(n)=store(mm)
      mm=mm+1
 1000 m=m+1
      mm0=0
      i0=1
c     if(npk.eq.npk2)i0=2
      m2=l2+(i0-1)*md2
      do 1100 i=i0,n2
      y(1)=x(1)*store(m2  )+x(2)*store(m2+1)+x(3)*store(m2+2)
      y(2)=x(1)*store(m2+3)+x(2)*store(m2+4)+x(3)*store(m2+5)
      y(3)=x(1)*store(m2+6)+x(2)*store(m2+7)+x(3)*store(m2+8)
      y(1)=y(1)+store(m2+9)
      y(2)=y(2)+store(m2+10)
      y(3)=y(3)+store(m2+11)
      m2=m2+md2
      seg=1.0
      do 1050 ii=1,ic+1
      do 1055 jj=1,3
      y(jj)=seg*y(jj)
1055  continue
      seg=-seg
      do 1060 kkk=1,n2p
      do 1065 nnn=1,3
      yy(nnn)=y(nnn)+vett(nnn,kkk)
1065  continue
      mm0=mm0+1
      do 1070 n=1,3
1070  yx(n,mm0)=yy(n)
      mm=mm0-1
      if(mm.eq.0)go to 1081
      do 1080 n=1,mm
      do 1075 jj=1,3
c      sss(jj)=0
      d2(jj)=yy(jj)-yx(jj,n)
 2011 if(abs(d2(jj)).le.0.5) go to 1075
c      sss(jj)=sign(1.0,d2(jj))+sss(jj)
         d2(jj)=d2(jj)-sign(1.0,d2(jj))
      go to 2011
1075  continue
      distt=g(1)*d2(1)*d2(1)
     1    +g(5)*d2(2)*d2(2)
     2    +g(9)*d2(3)*d2(3)
     3    +g(2)*d2(1)*d2(2)*2.0
     4    +g(3)*d2(1)*d2(3)*2.0
     5      +g(6)*d2(2)*d2(3)*2.0
c     if(distt.lt.0.1)then
      if(distt.lt.0.6)then
      mm0=mm0-1
      go to 1060
      endif
1080  continue
1081  continue
c
      do 1020 n=1,3
      sss(n)=0
      iss(n)=0
      d(n)=z(n)-yy(n)
 1011 if(abs(d(n)).le.0.5) go to 1020
         sss(n)=sign(1.0,d(n))+sss(n)
         d(n)=d(n)-sign(1.0,d(n))
         ddd(n)=d(n)
         iss(n)=int(-sign(1.0,d(n))+2 )
      go to 1011
c
1020  continue
      distt=g(1)*d(1)*d(1)
     1    +g(5)*d(2)*d(2)
     2    +g(9)*d(3)*d(3)
     3    +g(2)*d(1)*d(2)*2.0
     4    +g(3)*d(1)*d(3)*2.0
     5    +g(6)*d(2)*d(3)*2.0
      if(distt.lt.0.001.and.npk.eq.npk2)go to 1060
      dist0=sqrt(distt)
      istras=iss(1)*100+iss(2)*10+iss(3)
      if(distt.le.dm) go to 1025
      idst=0
      if(distt.gt.dmax)go to 1060
1025  continue
      ntot=ntot+1
      do 1026 nnn=1,3
      if(abs(d(nnn)).lt.e10)d(nnn)=sign(e10,d(nnn))
1026  dd(nnn,ntot)=d(nnn)
      dist(ntot)=distt
      ici=1
      if(ii.eq.2)ici=-1
      nop(ntot)=ici*(istras*ift1+npk2*ift2+i*ift3+kkk)
      do 1027 nyy=1,3
      ss(nyy,ntot)=sss(nyy)
      yyy(nyy,ntot)=yy(nyy)+sss(nyy)
      aa=yyy(nyy,ntot)
*     if(abs(aa).gt.2.)then
*     write(ncwu,*)' coord grande,ntot ',npk,npk2,ntot
*     write(ncwu,*)' npk ',(yyy(nyk2,ntot),nyk2=1,3)
*     write(ncwu,*)' n2p,vett ',n2p,vett
*     endif
1027  continue
      if (distt.le.dm) return
      idst=1
1060  continue
1050  continue
1100  continue
      return
      end
c
code for iorop
      subroutine iorop(m,icentr,itx,ity,itz,nord,nop,kkk)
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)
     5,icopk(9),icoel(9),icogr(500)
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(store,istore)
c
c     if (m.gt.244000) then
c                        return
c                      endif
      icentr=isign(1,istore(m))
      isto=iabs(istore(m))
      ici=isto/ift1
      itx=ici/100
      icj=ici-itx*100
      ity=icj/10
      itz=icj-ity*10
      icj=isto-ici*ift1
      nord=icj/ift2
      ici=icj-nord*ift2
      nop=ici/ift3
      kkk=ici-nop*ift3
      return
      end
c
code for norop
      subroutine norop(m,icentr,itx,ity,itz,nord,nop,kkk)
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)
     5,icopk(9),icoel(9),icogr(500)
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(store,istore)
c
      icentr=isign(1,m)
      isto=iabs(m)
      ici=isto/ift1
      itx=ici/100
      icj=ici-itx*100
      ity=icj/10
      itz=icj-ity*10
      icj=isto-ici*ift1
      nord=icj/ift2
      ici=icj-nord*ift2
      nop=ici/ift3
      kkk=ici-nop*ift3
      return
      end
c
code for kord
      function    kord(m)
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)
     5,icopk(9),icoel(9),icogr(500)
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(store,istore)
c
      isto=iabs(m)
      ici=isto/ift1
      icj=isto-ici*ift1
      kord=icj/ift2
      return
      end
c
code for sttab                                                                  
      subroutine sttab(l,mdd,n15)                                               
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2                              
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl                
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)               
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl             
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc                       
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)                             
     5,icopk(9),icoel(9),icogr(500)                                             
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(istore,store)                                                 
      dimension iprnt(30),prnt(30)                                              
      equivalence(prnt,iprnt)                                                   
c                                                                               
      ncolmx=5
      nn=0                                                                      
      if(l.lt.0)nn=1                                                            
      maddr=iabs(l)                                                             
      do 100  j=1,n15                                                           
      m=istore(maddr)                                                           
      if(m.eq.0)go to 101                                                       
      jprnt=istore(m)                                                           
      ni=istore(m+1)                                                            
      if(ni.eq.0)go to 101                                                      
      m=m+2                                                                     
      n=1                                                                       
      nline=0                                                                   
      ncol=0                                                                    
      do 200 i=1,ni                                                             
      m0=m                                                                      
      if(nn.eq.1)m0=istore(m)                                                   
      if(m0.eq.0)go to 199                                                      
      call iorop(m0,icentr,itx,ity,itz,nord,nop,kkk)                            
      ncol=ncol+1                                                               
      iprnt(n  )=nord                                                           
      iprnt(n+1)=nop*icentr                                                     
      prnt(n+2)=store(m0+1)                                                     
c     if(i.ne.ni.and.ncol.ne.8)go to 198                                        
      if(i.ne.ni.and.ncol.ne.ncolmx)go to 198                                        
      if(nline.eq.0)then                                                        
      if (istat2.gt.1) write(ncwu,2)jprnt,
     1(iprnt(k),iprnt(k+1),prnt(k+2),k=1,n,3)                                   
      go to 197                                                                 
      endif                                                                     
      if (istat2.gt.1) write(ncwu,1)     
     1(iprnt(k),iprnt(k+1),prnt(k+2),k=1,n,3)                                   
197   nline=nline+1                                                             
      ncol=0                                                                    
      n=-2                                                                      
198   n=n+3                                                                     
199   m=m+mdd                                                                   
200   continue                                                                  
      jprnt=0                                                                   
      do 300 i=1,30,3                                                           
      iprnt(i+1)=0                                                              
      iprnt(i+2)=0                                                              
300   prnt(i)=0.                                                                
101   maddr=maddr+1                                                             
100   continue                                                                  
2     format(i3,')',5(i5,'(',i2,')',f6.2))                                   
1     format(4x,5(i5,'(',i2,')',f6.2))                                          
c2    format(1x,i4,')',8(i5,'(',i2,')',f6.2))                                   
c1    format(6x,6(i5,'(',i2,')',f6.2))                                          
      return                                                                    
      end                                                                       
c                                                                               
code for pic15
      subroutine pic15(ivet,focc,a,nb)
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(istore,store)
      dimension ivet(12)
      l15=ivet(1)
      n15=ivet(2)
      md15=ivet(3)
      l3  =ivet(4)
      n3  =ivet(5)
      md3 =ivet(6)
      l3  =ivet(7)
      n3  =ivet(8)
      md3 =ivet(9)
      l2  =ivet(10)
      n2  =ivet(11)
      md2 =ivet(12)
      m15=l15
      som=a
      erro=.5*focc
      do 100 i=1,n15
      som=som-store(m15+5)
      nb=i
c      write(ncwu,*) 'pic15 ,focc,erro,som,nb ',focc,erro,som,nb
      if(som.gt.erro.or.som.gt.0)go to  99
      if(abs(som).le.erro)return
c--error
c         write(ncwu,1)erro,som,n15,nb
c   1     format(1x,' possible error in the cell content',
c        1   2f10.4,2i5)
      return
99    m15=m15+md15
100   continue
      return
      end
c
code for ang
      subroutine ang(a,b,c)
c--
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)                             
     5,icopk(9),icoel(9),icogr(500)                                             
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(istore,store)                                                 
      dimension a(3),b(3)                                                       
      c=0.0                                                                     
      idm = 3                                                                   
      do 10 i=1,idm                                                             
      j=(i-1)*idm                                                               
      do 20 l=1,idm                                                             
      c=c+g(j+l)*a(i)*b(l)                                                      
   20 continue                                                                  
   10 continue                                                                  
      return                                                                    
      end                                                                       
c
code for calang
      subroutine calang(ivet,rtd)                                               
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2                              
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl                
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)               
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl             
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc                       
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)                             
     5,icopk(9),icoel(9),icogr(500)                                             
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(istore,store)                                                 
Corig dimension d1(3),d2(3),ist(3,5),gt(5),ivet(12)                             
      dimension d1(3),d2(3),ist(5,5),gt(5),ivet(12)                             
c                                                                               
      l15=ivet(1)                                                               
      n15=ivet(2)                                                               
      md15=ivet(3)                                                              
      l3  =ivet(4)                                                              
      n3  =ivet(5)                                                              
      md3 =ivet(6)
      l3  =ivet(7)                                                              
      n3  =ivet(8)                                                              
      md3 =ivet(9)                                                              
      l2  =ivet(10)
      n2  =ivet(11)                                                             
      md2 =ivet(12)                                                             
      if (istat2.gt.1) write(ncwu,5)
      ja=0                                                                      
      madcon=ladcon                                                             
      mangl=lang                                                                
      do 100 i=1,n15                                                            
      mcon=istore(madcon)                                                       
      if(mcon.eq.0)go to 100                                                    
      nord1=istore(mcon  )                                                      
      nor1=nord1
      nleg=istore(mcon+1)                                                       
      mcon=mcon+2                                                               
      mcon0=mcon                                                                
      if(nleg.le.1)go to 100                                                    
      do 200 j=1,nleg                                                           
      maddr=istore(mcon)                                                        
      nord2=istore(mcon+1)                                                      
      call norop(nord2,icentr2,itx,ity,itz,nor2,nop2,kkk)                        
      istore(mcon+2)=mangl                                                      
      m=istore(mcon)+1                                                          
      do 201 j1=1,3                                                             
201   d1(j1)=store(m+j1)                                                        
      mmcon=mcon0                                                               
      do 300 k=1,nleg                                                           
      mm=istore(mmcon)
      nord3=istore(mmcon+1)                                                     
      call norop(nord3,icentr3,itx,ity,itz,nor3,nop3,kkk)                        
      if(nord3.eq.nord2)go to 300                                               
      mm=mm+1                                                                   
      do 301 k1=1,3                                                             
301   d2(k1)=store(mm+k1)
c      write(ncwu,*)' nord1,nord2,nord3 ',nord1,nord2,nord3
c      write(ncwu,*)' d1,d2 ',d1,d2
      call ang(d1,d2,angle)                                                     
      deno=store(m)*store(mm)                                                   
      if(deno.gt.1.0e-35) goto 302                                              
      deno=1.0e-5                                                               
302   angle=angle/deno                                                          
      if(angle.gt.1.and.angle.le.1.1)angle=1.0                                  
      if(angle.lt.-1.and.angle.ge.-1.1)angle=-1.0                               
      angle=acos(angle)*rtd                                                     
      iangle=int(angle)
c     iangle=int(angle*10)                                                      
      istore(mangl)=nord3                                                       
      istore(mangl+1)=iangle                                                    
      mangl=mangl+2                                                             
c--print                                                                        
      if (nor3.lt.nor2) go to 300                                               
      ja=ja+1                                                                   
      ist(1,ja)=nor2                                                            
      ist(2,ja)=nop2*icentr2                                                            
      ist(3,ja)=nor1                                                            
      ist(4,ja)=nor3                                                            
      ist(5,ja)=nop3*icentr3                                                            
      gt(ja)=angle                                                              
      if(ja.ne.2)go to 300                                                      
      if (istat2.gt.1) 
     *    write(ncwu,2)((ist(jg,jji),jg=1,5),gt(jji),jji=1,2)
      ja=0                                                                      
300   mmcon=mmcon+mdcon
200   mcon=mcon+mdcon                                                           
100   madcon=madcon+1                                                           
      nfl=mangl                                                                 
      if (istat2.le.1) return
      if (ja.eq.0)go to  9998                                                   
c--print                                                                        
c      go to(401)ja                                                  
401   write(ncwu,1)((ist(jg,ji),jg=1,5),gt(ji),ji=1,ja)
      return                                                                    
c402   write(ncwu,2)((ist(jg,ji),jg=1,3),gt(ji),ji=1,ja)
c      return                                                                 
c403   write(ncwu,3)((ist(jg,ji),jg=1,3),gt(ji),ji=1,ja)
c      return                                                                  
c404   write(ncwu,4)((ist(jg,ji),jg=1,3),gt(ji),ji=1,ja)
c1     format(1x,'(',i3,' - ',i3,' - ',i3,')',f6.1,3x)                        
c2     format(1x,2('(',i3,' - ',i3,' - ',i3,')',f6.1,3x))
c3     format(1x,3('(',i3,' - ',i3,' - ',i3,')',f6.1,3x))                       
c4     format(1x,4('(',i3,' - ',i3,' - ',i3,')',f6.1,3x))                      
1     format(1x,('(',i3,'(',i3,')',
     1' - ',i3,' - ',i3,'(',i3,'))',f6.1,5x))                        
2     format(1x,2('(',i3,'(',i3,')',                        
     1' - ',i3,' - ',i3,'(',i3,'))',f6.1,5x))                        
5     format(/,1x,' bond angles in this interpretation',/)                      
9998  continue                                                                  
      return
      end                                
c                                  
code for intclu                     
      subroutine intclu(ivet,numfr,n3n,iloop,ntent,ilclus,fgmr,
     *                  totint,xinte,kaction)
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)
     5,icopk(9),icoel(9),icogr(500)
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(istore,store)
      dimension numfr(100),figm(100),ivet(12),ilclus(50)
      dimension kor2(30),nor2(30),nor3(30,30),jcod3(30),inor3(30)
      dimension znor3(30),xinte(500),weig(30),xint2(30)
      l15=ivet(1)
      n15=ivet(2)
      md15=ivet(3)
      l3  =ivet(4)
      n3  =ivet(5)
      md3 =ivet(6)
      l3  =ivet(7)
      n3  =ivet(8)
      md3 =ivet(9)
      l2  =ivet(10)
      n2  =ivet(11)
      md2 =ivet(12)
      fgmr=0.
      limi=1
      lims=n15
      mnegl=lnegl
      if(iloop.eq.1)itent=1
      ngiri1=1
      if(iloop.gt.1)then
      ngiri=1
      go to 1000
      endif
      kfrag=1
      ngiri=0
      idummy=0
1000  continue
      jnn=0
      ngiri=ngiri+1
c      write(ncwu,*)' intcl ngiri1,ngiri= ',ngiri1,ngiri
c      write(ncwu,*)' intcl limi= ',limi
c      write(ncwu,*)' intcl kfrag= ',kfrag
c      write(ncwu,*)' lclus ',(istore(i),i=lclus,lclus+n15-1)
      madcon=ladcon+limi-1
      i1000=0
      kcode=0
      do 1100 i=limi,lims
c      write(ncwu,*)' i,limi,ngiri1,ngiri ',i,limi,ngiri1,ngiri
      mcon=istore(madcon)
c      write(ncwu,*)' i,mcon,madcon,ladcon ',i,mcon,madcon,ladcon
c      write(ncwu,*)'istore(mcon)',istore(mcon)
c     if(mcon.eq.0)go to 1100
      if(mcon.eq.0)then
      istore(lclus+i-1)=-(100+kfrag)
c      write(ncwu,*)'i,istore(lclus+i-1)',i,istore(lclus+i-1)
      go to 1100
      endif
      nord1=istore(mcon)
      mclus1=lclus+nord1-1
      jc1=jcod(istore(mclus1))
      if(jc1.le.0)go to 1100
      madinc=ladinc+nord1-1
c--picchi non isolati
c--controlla gli incompatibili
c      write(ncwu,*)'i,istore(madinc)',i,istore(madinc)
c      write(ncwu,*)'i,nleg',i,istore(mcon+1)
        if (istore(madinc).gt.0)then
        minc0=istore(madinc)
        jinc=istore(minc0)
        minc=minc0+1
        do  901 jjj=1,jinc
        mcl2=lclus+istore(minc)-1
        if(istore(mcl2).le.300)go to 901
        istore(mclus1)=-(istore(minc)*100+kfrag)
        go to 1100
901     minc=minc+1
        endif
      nleg =istore(mcon+1)
      init=0
      if (ngiri.eq.ngiri1.and.i.eq.limi) then
c-----solo primo picco nel loop
         if(nleg.gt.0)go to 1010
c--------isolato
         istore(mclus1)=300+kfrag
         if(i.gt.npeahi.and.ngh.lt.n3n)then
         istore(mclus1)=0
         go to 1100
         endif
         if(istore(madinc).eq.0)go to 1111
c--------elimina gli incompatibili
         minc=istore(madinc)
         jinc=istore(minc)
         minc=minc+1
         do  902 jin=1,jinc
         nrd2=istore(minc)
         if(nrd2.le.nord1)then
         mcl=lclus+nrd2-1
         if(istore(mcl).lt.0)go to 902
         istore(mclus1)=-(nrd2*100+kfrag)
         go to 1100
         endif
         mcl=lclus+nrd2-1
         if(istore(mcl).gt.0)istore(mcl)=-(nord1*100+kfrag)
902      minc=minc+1
1010  istore(mclus1)=200+kfrag
      jc1=2
      init=1
      endif
c jcod(istore(mclus))= -n picco escluso perche l'n-esimo e' migliore
c jcod(istore(mclus))= 0 picco spureo
c jcod(istore(mclus))= 1 picco non ancora analizzato
c jcod(istore(mclus))= 2 picco da analizzare
c jcod(istore(mclus))= 3 picco analizzato e accettato
      if (jc1.ne.2) go to 1100
c--prende il primo picco da analizzare (jcod(nord1)=2)
      jofr1=jordfr(istore(mclus1))
      if(jofr1.ne.0)kfrag=jofr1
      kcode=kcode+1
      mcon0=mcon
      istore(mclus1)=300+kfrag
      mcon=mcon+2
      jin0=0
      do 1102 jin=1,nleg
      kord2=istore(mcon+1)
      nord2=kord(istore(mcon+1))
      mclus2=lclus+nord2-1
      if(istore(mclus2).lt.0)go to 1102
      jc2=jcod(istore(mclus2))
c------solo per il primo picco del do 1100
       if(init.eq.1.and.jin0.eq.0)then
c-------controlla se nord2 e' incompatibile con qualcuno gia' accettato
        madinc=ladinc+nord2-1
        if(istore(madinc).gt.0)then
        minc0=istore(madinc)
        jinc=istore(minc0)
        minc=minc0+1
        do  903 jjj=1,jinc
        mcl2=lclus+istore(minc)-1
        if(istore(mcl2).le.300)go to 903
        istore(mclus2)=-(istore(minc)*100+kfrag)
        go to 1102
903     minc=minc+1
        endif
       jin0=1
       if(iloop.gt.1)then
       if(istore(mclus2).gt.300)go to 1102
       endif
       istore(mclus2)=200+kfrag
       if(nleg.eq.1)go to 1100
       jc2=3
       endif
      if(jc2.ne.3)go to 1102
c--prende il primo nord2 gia' accettato  (jcod(nord2)=3)
      jofr2=jordfr(istore(mclus2))
      if(jofr2.ne.kfrag)then
      mcl=lclus
      do 1020 j2 =1,n15
      if(istore(mcl).le.0)go to 1020
      if(jordfr(istore(mcl)).eq.kfrag)
     ,istore(mcl)=(istore(mcl)/100)*100+jofr2
1020  mcl=mcl+1
      endif
      kfrag=jofr2
      mangl=istore(mcon+2)
      if(nleg.lt.1)go to 1102
      if(nleg.eq.1)then
      istore(mclus2)=300+kfrag
      go to 1100
      endif
c--cerca il terzo picco (nord3) e controlla l'angolo nord2-nord1-nord3
      do 1130 j2=1,30
      jcod3(j2)=0
      inor3(j2)=0
      weig(j2)=0
      kor2(j2)=0
      nor2(j2)=0
      znor3(j2)=0
      xint2(j2)=0
      do 1130 j=1,30
1130  nor3(j,j2)=0
      jk=0
      do 1200 j=1,nleg-1
      kord3=istore(mangl)
      nord3=kord(istore(mangl))
c      if(iloop.eq.1)
c     1write(ncwu,*)'nord1,nord2,nord3 ',nord1,nord2,nord3,
c     1(istore(iu),iu=lclus,lclus+n15-1)
      mclus3=lclus+nord3-1
      jc3=jcod(istore(mclus3))
      jofr3=jordfr(istore(mclus3))
      if(jc3.le.0)go to 1201
      madinc=ladinc+nord3-1
      if (istore(madinc).gt.0)then
      minc0=istore(madinc)
      jinc=istore(minc0)
      minc=minc0+1
      do 1210 jjj=1,jinc
      mcl2=lclus+istore(minc)-1
      if(istore(mcl2).le.300)go to 1210
      istore(mclus3)=0
      go to 1201
1210  minc=minc+1
      endif
      angle=float(istore(mangl+1))
c     angle=float(istore(mangl)-(istore(mangl)/2000)*2000)/10.
c--control angle
c     cntang(n1,n2,n3,angle)= 2 angle between the limits of  nord1
c     cntang(n1,n2,n3,angle)=-1 angle out  of the limits of  nord1
      in=cntang(nord1,nord2,nord3,angle,kaction)
      if(in.gt.0)go to 1140
      if(jc3.eq.3)then
      istore(mclus1)=-(nord2*100+kfrag)
      go to 1100
      endif
      istore(mclus3)=-(nord2*100+kfrag)
      go to 1201
1140  jk=jk+1
      kor2(jk)=kord3
      nor2(jk)=nord3
      jcod3(jk)=jc3
c---calcola la somma delle intensita dei picchi legati ad ogni nord3
      madcn3=ladcon+nord3-1
      mcn3=istore(madcn3)
      if(mcn3.le.0)go to 1201
      nlg3=istore(mcn3+1)
      mcn3=mcn3+3
      do 1141  j2=1,nlg3
      knn=istore(mcn3)
      nn=kord(istore(mcn3))
      xint2(jk)=xint2(jk)+xinte(nn)
1141  mcn3=mcn3+mdcon
 1201 continue
1200  mangl=mangl+2
c     if (ngiri.eq.ngiri1.and.i.eq.limi)
c    1write(ncwu,*)'lclus ',(istore(iu),iu=lclus,lclus+n15-1)
      jk0=jk
      jnn=jnn+jk0
      if(jk0.eq.0)go to 1101
      i1000=0
      if(jk0.gt.1)go to 1150
      mclusx=lclus+nor2(1)-1
      if(jcod3(1).ne.3)istore(mclusx)=200+kfrag
      i1000=1
      go to 1101
1150  continue
      mcn=mcon0+3
      do 1160 j=1,nleg
      kn=istore(mcn)
      n=kord(istore(mcn))
      do 1165 j2=1,jk0
      if(kn.ne.kor2(j2))go to 1165
      mcn0=mcn+1
      m=istore(mcn0)
      do 1170 jj2=1,nleg-1
      knn=istore(m)
      nn=kord(knn)
      do 1180 j3=1,jk0
      if(knn.ne.kor2(j3))go to 1180
      angl2=float(istore(m+1))
      in2=cntang(nord1,n,nn,angl2,kaction)
      if (in2.ne.2) then
             if (jcod3(j2).eq.3.and.jcod3(j3).eq.3) then
                          istore(mclus1)=-(nord2*100+kfrag)
                          go to 1100
                        endif
                     endif
      nor3(j2,j3)=in2/2
      inor3(j2)=inor3(j2)+in2/2
      if(in2.eq.2)
     1znor3(j2)=znor3(j2)+xinte(nn)
1180  continue
1170  m=m+2
1165  continue
1160  mcn=mcn+mdcon
      do 2000 j=1,jk0
2000  weig(j)=10*jcod3(j)+2.00*xinte(nor2(j))+znor3(j)+.33*xint2(j)
2500  continue
      imax=0
      zmax=0
      i1000=0
      do 2100 j=1,jk0
      if(weig(j).le.zmax)go to 2100
      zmax=weig(j)
      jm=j
2100  continue
      if(zmax.lt.0.001)then
      i1000=1
      go to 1101
      endif
      weig(jm)=0
      mclusx=lclus+nor2(jm)-1
      if(jcod3(jm).ne.3)istore(mclusx)=200+kfrag
      do 2200 j=1,jk0
      if(j.eq.jm)go to 2200
      if(nor3(jm,j).ne.0)go to 2200
      weig(j)=0
      mclusx=lclus+nor2(j)-1
      istore(mclusx)=-(nor2(jm)*100+kfrag)
2200  continue
      go to 2500
1102  mcon=mcon+mdcon
      istore(mclus1)=0
      if(nord1.le.npeahi.or.ngh.eq.n3n)istore(mclus1)=300+kfrag
1101  madinc=ladinc+nord1-1
      if (istore(mclus1).gt.300.and.istore(madinc).gt.0)then
      minc=istore(madinc)
      jinc=istore(minc)
      minc=minc+1
      do  904 jin=1,jinc
      nrd2=istore(minc)
      mcl=lclus+nrd2-1
      if(nrd2.le.nord1)then
      if(istore(mcl).lt.300)go to 904
      istore(mclus1)=-(nrd2*100+kfrag)
      go to 1100
      endif
      if(istore(mcl).gt.0)then
      istore(mcl)=-(nord1*100+kfrag)
      endif
904   minc=minc+1
      if(i1000.eq.1)go to 1000
      endif
1100  madcon=madcon+1
      if(jnn.ne.0)go to 1000
1111  continue
      i1=1
      mc=lclus+limi-1
      if(istore(mc).eq.100)then
      istore(mc)=300+kfrag
      if(limi.gt.npeahi.and.ngh.lt.n3n)istore(mc)=0
      if(limi.ge.n15)go to 1500
      i1=limi+1
      endif
      mclus=lclus+i1-1
      do 1300 i=i1,n15
      ii=i
      if(jcod(istore(mclus)).eq.1)go to 1310
      if(jcod(istore(mclus)).eq.2)then
           limi=ii
               kfrag=jordfr(istore(mclus))
               go to 1000
             endif
1300  mclus=mclus+1
      go to 1500
1310  ngiri=0
      if(iloop.gt.1)then
      imm=0
      mclus=lclus
      do 1320 i=1,n15
      if(istore(mclus).le.0)go to 1320
      if(imm.lt.jordfr(istore(mclus)))imm=jordfr(istore(mclus))
1320  mclus=mclus+1
      kfrag=imm
      endif
c     if(iloop.gt.1)ngiri=1
      kfrag=kfrag+1
      limi=ii
      go to 1000
1500  continue
      do 1600 i=1,100
      figm(i)=0
1600  numfr(i)=0
      inmx=0
      mclus=lclus
      m15=l15+5
      lnumfr=100
c      if(iloop.eq.1)
c      write(ncwu,*)'lclus  1600 ',(istore(iu),iu=lclus,lclus+n15-1)
      do 1620 i=1,n15
      if(jcod(istore(mclus)).ne.3)go to 1620
      in=jordfr(istore(mclus))
      if(in.le.lnumfr)go to 1618
      in=lnumfr
1618  continue
      figm(in)=figm(in)+xinte(i)*xinte(i)
      numfr(in)=numfr(in)+1
      inmx=max(in,inmx)
1620  mclus=mclus+1
      nfrag=inmx
c      write(ncwu,*)'nfrag,numfr(n) ',nfrag,(numfr(i),i=1,nfrag)
      if(nfrag.eq.0) return
      if(nfrag.eq.1)go to 1649
      kkf=nfrag-1
1631  kfrag=0
c      if(iloop.eq.1)
c     1write(ncwu,*)'1631 lclus ',(istore(i),i=lclus,lclus+n15-1)
c      do 1630 i=1,kkf
      do 1630 i=1,kkf+1
      if(numfr(i).gt.1)go to 1630
      if(numfr(i).eq.1)then
      mclus=lclus
      do 1634 j=1,n15
      is=istore(mclus)
      if(jordfr(is).ne.i)go to 1634
      jj=j-1
c      write(ncwu,*)'i,j,jj,npeahi ',i,j,jj,npeahi
c      if(jj.le.npeahi)go to 1630
      if(jj.le.npeahi.and.is.gt.300)go to 1630
      if(is.le.0)go to 1634
      istore(mclus)=0
      numfr(i)=0
c      go to 1632
1634  mclus=mclus+1
      if(i.eq.kkf+1)then
      kkf=kkf-1
      go to 1630
      endif
      endif
1632  continue
      kkf=kkf-1
      kfrag=1
      i0=i
      do 1633 jin=i0,kkf+1
      if(numfr(jin).ne.0)go to 1633
      i1=jin+1
      i2=jin
      jn=numfr(i2)
      numfr(i2)=numfr(i1)
      numfr(i1)=jn
      mclus=lclus
c      write(ncwu,*)'1635 lclus1',(istore(j),j=lclus,lclus+n15-1)
      do 1635 j=1,n15
      is=istore(mclus)
      if(jordfr(is).ne.i1)go to 1635
      js1=isign(1,is)
      istore(mclus)=js1*((iabs(is/100)*100)+i2)
1635  mclus=mclus+1
c      write(ncwu,*)'1635 lclus2',(istore(j),j=lclus,lclus+n15-1)
1633  continue
      goto 1631
1630  continue
      nfrag=kkf+1
c     write(ncwu,*)'nfrag,kkf,nfr  ',nfrag,kkf,nfr
      if(nfrag.eq.0)return
      kkf=0
      do 1640 i=1,nfrag
      if(kkf.gt.numfr(i))go to 1640
      kkf=numfr(i)
      i1=i
1640  continue
      if(i1.eq.1)go  to 1649
      numfr(i1)=numfr(1)
      numfr(1)=kkf
      mclus=lclus
      do 1645 j=1,n15
      is=istore(mclus)
      js1=isign(1,is)
      if(jordfr(is).eq.1)
     1istore(mclus)=js1*((iabs(is/100)*100)+i1)
      if(jordfr(is).eq.i1)
     1istore(mclus)=js1*((iabs(is/100)*100)+1)
1645  mclus=mclus+1
1649  continue
c      write(ncwu,1648)(istore(j),j=lclus,lclus+n15-1)
c1648  format(1x,'lclus finale ',/,10(1x,10i5,/))
c      write(ncwu,*)'nfrag,numfr ',nfrag,numfr
      nf=0
      fm=0
      kfrag=0
      do 1650 i=1,nfrag
      if(numfr(i).le.4)go  to 1650
      nf=nf+numfr(i)
      fm=fm+figm(i)
      kfrag=kfrag+1
1650  continue
      if(kfrag.eq.0)return
c     fm=nf*fm/kfrag
      fm=fm/totint
      fgmr=fm
      return
      end
c
code for jordfr
      function jordfr(m)                                                        
      mm=iabs(m)                                                                
      jordfr=mm-(mm/100)*100                                                    
      return                                                                    
      end                                                                       
c                                                                               
code for jcod                                                                   
      function jcod(m)                                                          
      jcod=m/100                                                                
      return                                                                    
      end                                                                       
c                                                                                   
code for cntang                                                                 
      function cntang(nord1,nord2,nord3,angle,kaction)                          
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2                              
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl                
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)               
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl             
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc                       
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)                             
     5,icopk(9),icoel(9),icogr(500)                                             
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(istore,store)                                                 
      cntang=2                                                                  
       ii=icogr(nord1)                                                           
c      i=icopk(ii)     
      i=ive(ii)                                                               
      if(i.ge.1.and.i.le.3)go to 100                                            
      write(ncwu,*)i,nord1,nord2,nord3
      stop                                                                      
100   continue                                                                  
      if(angle.ge.angi(i).and.angle.le.angs(i))return                           
      cntang=-1
      return
      end
c
code for stclu
      subroutine stclu(ivet,numfr,lindr,icodpr,nn15,ll15,lb)
      character*1 ibb,iapi,iop
      character*5 line(13),ib,iring(13),ia
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)
     5,icopk(9),icoel(9),icogr(500)
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(istore,store)
      dimension jfrag(200),isol(50),iop(13,10)
      dimension nord(13,10),numfr(100),lindr(50),ianel(500),ivet(12)
      data ib/'     '/ ,ia/'   * '/
      data ibb/' '/,iapi/''''/
      n15=ivet(2)
      istam=1
      jpic=0
      jisol=0
      if (istat2.gt.0) write(ncwu,770)
      do 1000 k=1,nfrag
      ifin=numfr(k)
      if (ifin.le.0) then
      write(ncwu,*)k,numfr(k),nfrag
      stop 7777
      endif
      if (ifin.eq.1) then
                       lind=lindr(k)+n15
                       nn=istore(lind)
                       jisol=jisol+1
                       isol(jisol)=nn
                       go to 1000
                     else
                       if(ifin.le.4)then
                       jpic=jpic+1
                       jfrag(jpic)=k
                       go to 1000
                       endif
                       if(icodpr.eq.-1)goto 25
                       icodpr=k
                       call cluprz(ivet,g,icodpr,nn15,ll15,lb)
25                     continue
                       if (istat2.gt.0) write(ncwu,1) k,numfr(k)
                       nnm=0
                       lindd=lindr(k)
                       lind=lindr(k)+n15
                       jring=0
                       do 20 i=1,13
                       iring(i)=ib
                       do 20 j=1,10
   20                  nord(i,j)=0
                       jj=0
                       mindr=lind
                       kch=k
         call chanel(kch,n15,lindr,numfr,nanel,ianel,lanel,nrami,istam)
                       jprint=0
                       do 1100 kk=1,ifin
                       if(jj.ge.13)go to 1300
                       nn1=1
                       jj=jj+1
                       mindr0=mindr
                       kj=istore(mindr)
                       nord(jj,nn1)=kj
                       if (nanel.le.0) go to 1102
                       do 1101 ii=1,nanel
                       i=ianel(ii)
                       if(i.ne.kj)go to 1101
                       iring(jj)=ia
                       jring=1
1101                   continue
1102                   continue
                       mindr=mindr+1
                       nleg=istore(mindr)
                       nleg1=nleg+1
                       nnm=max(nnm,nleg1)
                       mindr=mindr+1
                       do 1200 jk=1,nleg
                       nn1=nn1+1
                       nord(jj,nn1)=istore(mindr)/10
                       iop(jj,nn1)=ibb
                       if(mod(istore(mindr),10).ne.0.or.
     *                        istore(mindr).lt.0)iop(jj,nn1)=iapi
 1200                  mindr=mindr+1
                       if(jj.lt.13)go to 1100
 1300                  continue
                       if (istat2.gt.0)write(ncwu,600)(nord(i,1),i=1,jj)
                       nline=0
                       do 1500 i=2,nnm
                       do 1400 j=1,13
                       line(j)=ib
                       if(nord(j,i).ne.0.and.istat2.gt.0)
     *                         write(line(j),550)nord(j,i),iop(j,i)
 1400                  continue
                       nline=nline+1
                       if (istat2.gt.0) then
                           if (nline.eq.1) then
                               write(ncwu,700)(line(j),j=1,13)
                             else
                               write(ncwu,750)(line(j),j=1,13)
                             endif
                         endif
 1500                  continue
                       if(jring.eq.1.and.istat2.gt.0)
     1                 write(ncwu,710)(iring(j),j=1,13)
                       nnm=0
                       jj=0
                       jring=0
                       do 30 i1=1,13
                       iring(i1)=ib
                       do 30 j1=1,10
   30                  nord(i1,j1)=0
 1100                  continue
                       if (jj.eq.0) go to 3000
                       if (istat2.gt.0)write(ncwu,600)(nord(i,1),i=1,jj)
                       nline=0
                       do 1700 i=2,nnm
                       do 1600 j=1,13
                       line(j)=ib
                       if(nord(j,i).ne.0.and.istat2.gt.0)
     *                    write(line(j),550)nord(j,i),iop(j,i)
 1600                  continue
                       nline=nline+1
                       if (istat2.gt.0) then
                           if (nline.eq.1) then
                               write(ncwu,700)(line(j),j=1,13)
                             else
                               write(ncwu,750)(line(j),j=1,13)
                             endif
                         endif
 1700                  continue
                       if(jring.eq.1.and.istat2.gt.0)
     1                 write(ncwu,710)(iring(j),j=1,13)
 3000                continue
                     endif
 1000 continue
      if(jpic.eq.0)go to 6000
      if (istat2.gt.0) write(ncwu,2)
      do 5020 i=1,13
      iring(i)=ib
      do 5020 ii=1,10
5020  nord(i,ii)=0
      jj=0
      nnm=0
      do 5000 j=1,jpic
      k=jfrag(j)
      ifin=numfr(k)
                       lind=lindr(k)+n15
                       mindr=lind
c                      jprint=0
                       do 5100 kk=1,ifin
                       if(jj.ge.13)go to 5300
                       nn1=1
                       jj=jj+1
c                      mindr0=mindr
                       kj=istore(mindr)
                       if (kj.le.0) go to 5100
                       nord(jj,nn1)=kj
                       write(iring(jj),550)k
                       mindr=mindr+1
                       nleg=istore(mindr)
                       nleg1=nleg+1
                       nnm=max(nnm,nleg1)
                       mindr=mindr+1
                       do 5200 jk=1,nleg
                       nn1=nn1+1
                       nord(jj,nn1)=istore(mindr)/10
                       iop(jj,nn1)=ibb
                       if(mod(istore(mindr),10).ne.0)iop(jj,nn1)=iapi
5200                   mindr=mindr+1
                       if(jj.lt.13)go to 5100
5300                   continue
                       if (istat2.gt.0)write(ncwu,600)(nord(i,1),i=1,jj)
                       nline=0
                       do 5500 i=2,nnm
                       do 5400 ii=1,13
                       line(ii)=ib
                       if(nord(ii,i).ne.0.and.istat2.gt.0)
     *                    write(line(ii),550)nord(ii,i),iop(ii,i)
5400                   continue
                       nline=nline+1
                       if (istat2.gt.0) then
                          if (nline.eq.1) then
                              write(ncwu,700)(line(ii),ii=1,13)
                            else
                              write(ncwu,750)(line(ii),ii=1,13)
                            endif
                         endif
5500                   continue
                       if(istat2.gt.0)write(ncwu,711)(iring(ii),ii=1,13)
                       nnm=0
                       jj=0
                       jring=0
                       do 5030 i1=1,13
                       iring(i1)=ib
                       do 5030 j1=1,10
5030                   nord(i1,j1)=0
5100                   continue
5000                   continue
                       if (jj.eq.0)go to 6000
                       if (istat2.gt.0)write(ncwu,600)(nord(i,1),i=1,jj)
                       nline=0
                       do 5700 i=2,nnm
                       do 5600 ii=1,13
                       line(ii)=ib
                       if(nord(ii,i).ne.0.and.istat2.gt.0)
     *                    write(line(ii),550)nord(ii,i),iop(ii,i)
5600                   continue
                       nline=nline+1
                       if (istat2.gt.0) then
                          if (nline.eq.1) then
                              write(ncwu,700)(line(ii),ii=1,13)
                            else
                              write(ncwu,750)(line(ii),ii=1,13)
                            endif
                         endif
 5700                  continue
                       if(istat2.gt.0)write(ncwu,711)(iring(ii),ii=1,13)
6000  if(jisol.eq.0)return
      if (istat2.gt.0) then
         if (jisol.eq.1) then
                           write(ncwu,3)isol(1)
                         else
                           write(ncwu,4)(isol(i),i=1,jisol)
                         endif
                      endif
                                             
    1 format(/,1h , 76('-'),/,
     *1x,'fragment number ',i3,' ,',i5,' peaks included')
    2 format(/,1h , 76('-'),/,
     *1x,' fragments with less than five peaks')
    3 format(/,1h , 76('-'),/,                  
     *1x,' peak number ',i5,' is isolated')
    4 format(/,1h , 76('-'),/,                            
     *1x,'the following peaks are isolated : ',8i5,/,5(36x,8i5,/))
  550 format(i4,a1)                                            
  600 format(//,1x,'     peak',13(i4,1x))
  700 format(1x,'linked to',13a5)
  710 format(1x,' ring    ',13a5)
  711 format(1x,' fragment',13a5)
  750 format(10x,13a5)
  770 format(1h )
      return
      end
c
code for storcl
      subroutine storcl(jtent,ivet,numfr,lindr,n3n,ic,n2p,vett,dddx,
     *            lbuff0,izpk,l15con)
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)
     5,icopk(9),icoel(9),icogr(500)
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(istore,store)
      dimension numfr(100),lindr(50),vett(3,4),ivet(12)
      dimension nord(20),izpk(500)
c
      n15=ivet(2)
c    write(ncwu,*)' storcl n15 = ',n15
c      write(ncwu,*)' storcl lclus ',(istore(i),i=lclus,lclus+n15-1)
      llfl=244000-n15
      lcon1=nfl
      lcon2=lcon1+n15
      lindr(1)=lcon1
      mcon2=lcon2
      kfrag=1
      limi=1
      lims=n15
100   continue
      madcon=ladcon
c     nnm=0
      numb=0
      i=lindr(kfrag)
      do 30 j=1,n15
      istore(i)=0
30    i=i+1
      nfind=0
      do 1100 i=limi,lims
      nleg=0
      nn1=1
      mcon=istore(madcon)
      if(mcon.gt.0)go to 997
c      write(ncwu,*)' storcl : mcon,i  ',mcon,i
      if(i.gt.npeahi.and.ngh.lt.n3n)go to 1100
      nord1=i
      mclus1=lclus+nord1-1
      mi=istore(mclus1)
c     write(ncwu,*)' storcl:mcon,i,istore(mclus1)  ',mcon,i,mi
      go to 998
997   continue
      nord1=istore(mcon)
      mclus1=lclus+nord1-1
998   if(istore(mclus1).le.300) go to 1100
      ll=jordfr(istore(mclus1))
      if(ll.ne.kfrag)go to 1100
c     if(jcod(istore(mclus1)).ne.3)go to 1100
      if(mcon.ne.0) nleg=istore(mcon+1)
      if(numfr(kfrag).eq.1)go to 1130
      if(nleg.eq.0)go to 1100
      do 999 k=1,20
999   nord(k)=0
      nord(nn1)=nord1*10
      if(mcon.eq.0) go to 1130
      mcon=mcon+2
      do 1200 j=1,nleg
      maddr=istore(mcon)
      if(maddr.eq.0)go to 1200
      call iorop(maddr,icentr,itx,ity,itz,nord2,nop,kkk)
      mclus2=lclus+nord2-1
      if(istore(mclus2).le.300)go to 1200
      if(jordfr(istore(mclus2)).ne.ll)go to 1200
      if(jcod(istore(mclus2)).ne.3)go to 1200
      kop=0
      do 1220   k=1,nn1
      if(nord2.eq.(nord(k)/10))kop=kop+1
1220  continue
      nn1=nn1+1
      nord(nn1)=nord2*10+kop
1200  mcon=mcon+mdcon
1130  mc0=mcon2
      mcon1=lindr(kfrag)+nord1-1
      istore(mcon1)=mc0
      istore(mcon2)=nord1
      istore(mcon2+1)=nn1-1
      nfind=nfind+1
c      write(ncwu,*)' mc0,nord1,nn1   ',mc0,nord1,nn1
      mcon2=mcon2+2
      if(nn1.eq.1)go to 1099
      do 1120 j=2,nn1
      istore(mcon2)=nord(j)
1120  mcon2=mcon2+1
1099  if(nfind.eq.numfr(kfrag))go to 1400
1100  madcon=madcon+1
1400  continue
c750   format(i5)
660   continue
c      write(ncwu,*)'nfrag,kfrag,numfr(kfrag),nfind  ',
c     1nfrag,kfrag,numfr(kfrag),nfind
c      nnnn=-lcon2+mcon2+1
c      write(ncwu,*)'lcon2:nnnn  ',nnnn,(istore(mc),mc=lcon2,mcon2)
      if(kfrag.eq.nfrag)go to 800
      kfrag=kfrag+1
      if(numfr(kfrag).eq.0) go to 660
      lindr(kfrag)=mcon2
      mcon2=mcon2+n15
c     write(ncwu,*)'  storcl : lcon2,mcon2  ',lcon2,mcon2
      if(mcon2.ge.llfl)then
       write(ncwu,*)' storcl mcon2,n15,llfl = ',n15,llfl,mcon2
      stop 'store overflow'
      endif
      do 666 i=lindr(kfrag),mcon2
666   istore(i)=0
      if(numfr(kfrag).ge.1)then
                             go to 100
                           else
                             go to 660
                           endif
800   continue
      nfl=mcon2+n15
      lindr(nfrag+1)=mcon2
      if(jtent.gt.1)return
      ddmax=dmax
      dmax=dddx
c      write(ncwu,*)'iniz chgxyz'
      call chgxyz(ivet,lcon1,ic,n2p,vett,numfr,lindr,lanel,
     1lbuff0,izpk)
      dmax=ddmax                                                     
      return
      end
c
code for chanel
      subroutine chanel(ifrag,n15,lindr,numfr,nanel,ianel,lanel,nrami
     1,ist)
c-- cerca 'profumati' anelli
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)
     5,icopk(9),icoel(9),icogr(500)
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(istore,store)
      dimension ianel(500),lindr(50),numfr(100)
c
      nanel=0
      nrami=0
      do 1 i=1,500
1     ianel(i)=0
      ifin=numfr(ifrag)
      if (ifin.le.1) return
      lanel=nfl
      nfl=lanel+n15
      manel=lanel
      lind=lindr(ifrag)
      mindr=lind
      do 10 i=1,n15
      istore(manel)=0
      if(istore(mindr).eq.0)go to 9
      n=istore(mindr)
      istore(manel)=istore(n+1)
9     manel=manel+1
10    mindr=mindr+1
      lanell=lanel-1
      mprint=manel
c      write(ncwu,*)' manel) ',(istore(i),i=lanel,mprint)
c      write(ncwu,*)' manel) ',(istore(i),i=lind,lind+n15-1)
      icheck=1
1000  continue
      mindr=lind
      manel=lanel
      if(icheck.eq.0)go to 3000
      icheck=0
      do 200 i=1,n15
      m=istore(mindr)
      if(m.eq.0)go to 199
      if(istore(manel).gt.1.or.istore(manel).le.0)go to 199
      istore(manel)=0
      nleg=istore(m+1)
      mm=m+2
      do 300 k=1,nleg
      mpeak=istore(mm)/10
      manel2=lanell+mpeak
      mindr2=lind+mpeak-1
      mn=istore(mindr2)
      if(mn.eq.0)go to 300
      nleg2=istore(mn+1)
      mn2=mn+2
      do 310 k2=1,nleg2
      if(istore(mn2)/10.eq.i)istore(manel2)=istore(manel2)-1
310   mn2=mn2+1
300   mm=mm+1
      icheck=1
      go to 1000
199   manel=manel+1
200   mindr=mindr+1
3000  continue
c--look for rings or fused rings
      manel=lanel
      lrami=nfl
      nanel=0
      mrami=lrami
      do 3099 i=1,n15
      istore(mrami)=0
3099  mrami=mrami+1
      mrami=lrami
      nrami=0
      do 3100 i=1,n15
      if(istore(manel)-2)3100,3110,3120
3120  continue
      nrami=nrami+1
      istore(mrami)=i
c      write(ncwu,*) 'istore(mrami),nrami,i  ',istore(mrami),nrami,i
      mrami=mrami+1
3110  continue
      nanel=nanel+1
      ianel(nanel)=i
c      write(ncwu,*) 'ianel(nanel),nanel  ',ianel(nanel),nanel
3100  manel=manel+1
      nfl=mrami
c      write(ncwu,*)' nanel,nrami ',nanel,nrami
      if(nanel.eq.0)nrami=0
      if (istat2.gt.0) then
      if (nanel.ne.0.and.ist.ne.1) then
                if (nrami.ne.0) then
             write(ncwu,3004)ifrag
                     write(ncwu,3003)
     *               (istore(mrami),mrami=lrami,lrami+nrami-1)
                                endif
                                   endif
                        endif
      return    
3003  format(1x,19i4)
3004  format(/,1x,'fragment n.',i2,
     1 ' ,fused rings could be found around peaks ')
      end
c
code for cluprz
      subroutine cluprz(ivet,gg1,icodpr,nn15,ll15,llb)
c--interface between cluster and projection routine
c
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common/inpcl/ntype,ttype(10,5),nproj,nbond,dmaxi,radnew(8)
c
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)
     5,icopk(9),icoel(9),icogr(500)
c
      common/workc/ggg(9),ggr(9),x1(6),x2(6),x3(6),x4(6),x5(6),x6(6),
     1          eval(3),eve(3,3),ever(3,3),
     2          ainer(3,3),vv(3),vr(3),
     3          caa(3,3),xb(3),varxb(3,3),
     4          gg(3,3),gr(3,3),varian(4),l28,m28,md28,n28
     5          ,l25,m25,md25,n25
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(store,istore)
      dimension ivet(12),gg1(18)
c--
      if(icodpr.eq.-1) return
      istat3=istat2
      do 1040 i=1,9
      ggg(i)=gg1(i)
1040  ggr(i)=gg1(i+9)
c      lbuf=llb+2*ivet(2)*ivet(3)
c      mdbuf=ivet(3)
      n015=ivet(2)
      n15=nn15
      l15=ll15
      md15=ivet(3)
c     write(ncwu,*) ' cluprz   icodpr,n15,n015  ',icodpr,n15,n015
      if(n15.le.3) go to 4000
      l25=nfl
      md25=9
      n25=0
      n025=0
      m25=l25
      m15=l15
c      write(ncwu,*)' laddr ',laddr
      maddr=laddr
      do 1000 n=1,n15
      if(n.gt.n015)then
      j=int(store(m15+1))
      if(icodpr.eq.0.or.j.eq.icodpr)go to 1030
      go to 1020
      endif
      j=istore(maddr)
c      write(ncwu,*)' laddr,ladcon,l15,l25 ',laddr,ladcon,l15,l25
      store(m25+1)=0.0
      j=istore(j+1)
      if (j.eq.0) go to 1020
      if(icodpr.eq.0) goto 1031
      mclus=lclus+n-1
      j=mod(istore(mclus),100)
      if(iabs(j).ne.icodpr) go to 1020
1031  n025=n025+1
1030  m=m15
      l=m25
      ll=l+1
      do 1010 i=1,5
      store(l)=store(m)
      if(i.eq.2)store(l)=n
c     if(i.eq.2.and.n.le.n015)store(l)=n
      l=l+1
1010  m=m+1
      n25=n25+1
c     write(ncwu,*)n25,n025,(store(mm),mm=m25,m25+md25-1)
      m25=m25+md25
 1020 m15=m15+md15
      maddr=maddr+1
1000  continue
c     write(ncwu,*)(istore(mm),mm=lclus,lclus+n15-1)
      nfl=m25
      l28=nfl
      idev=0
      call xpqmm(idev)
      if(icodpr.ne.0) nproj=1
      nfld=l28+n15*md25
      call sprzsm(nproj,icodpr,n015,nfld)
4000  continue
      istat2=istat3
      return
      end
c
code for sprzsm
      subroutine sprzsm(iplo,icodpr,n015,nfld)
c--plot the atoms on the lpt device
c  iplo = 1  on least squares plane
c       = 2  on least and on most squares plane
c  icodpr = -1 non fa la proiezione
c            0 proietta tutti gli atomi e controlla
c              scala
c            n proietta l'n-esimo frammento
c
      integer*4 ifmt(120)
      dimension  xmax(3), xmin(3),ind(3)
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common/workc/ggg(9),ggr(9),x1(6),x2(6),x3(6),x4(6),x5(6),x6(6),
     1          eval(3),eve(3,3),ever(3,3),
     2          ainer(3,3),vv(3),vr(3),
     3          caa(3,3),xb(3),varxb(3,3),
     4          gg(3,3),gr(3,3),varian(4),l28,m28,md28,n28
     5          ,l25,m25,md25,n25
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(store,istore)
      dimension line(78)
      data ifmt(1)/X'2831682b'/
      data ifmt(2)/X'2c316820'/
      data ib/X'20202020'/
      data inus/X'2d2d2d2d'/
c--
c      mbuf=lbuf
      do 1020 i=1,3
      xmax(i)=-100000.
1020  xmin(i)= 100000.
      ind(1)=3
      ind(2)=2
      ind(3)=1
      m25=l25
      do 100 k=1,n25
      lc=m25+2
      jx =lc
      do 101 l=1,3
      x2(l)=store(jx)
101   jx=jx+1
      do 1000 i=1,3
      x3(i)=0.0
      l=ind(i)
      do 1010 j=1,3
      x3(i)=x3(i)+x2(j)*ever(l,j)
1010  continue
      xmax(i)=amax1(xmax(i),x3(i))
      xmin(i)=amin1(xmin(i),x3(i))
1000  continue
      jx =lc
      do 102 l=1,3
      store(jx)=x3(l)
102   jx=jx+1
c      write(ncwu,*)' k, store(m25+1),x2 ',k,store(m25+1),x2
      m25 = m25+md25
  100 continue
      iex=0
c--number of lines per inch on lineprinter
      aln=6
      nnn=0
      orizmx=78.0
      n1 = 2
      n2 = 1
      if (orizmx/(xmax(1)-xmin(1)) .ge. 2.0/0.254) go to 1190
      n1 = 1
      n2 = 2
c--calculate scale factor to fill page or give 2.5 cms/a
1190  amax = amax1(xmax(n2)-xmin(n2), xmax(n2+1)-xmin(n2+1))
      scale = amin1(orizmx/amax, 2.5/0.254)
      scl = 0.254 * scale
      if(icodpr.gt.0) goto 1200
      if (scl.gt.2.0) icodpr=-1
c--sort peaks in order of plotting
 1200 jump=-(n1+2)
      call sortz(l25,n25,md25,jump)
c--output heading and plot peaks
      nnn=nnn+1
      if (icodpr.le.0) then
                         write(ncwu,1214)
                       else
                         write(ncwu,1215) icodpr
                       endif                                
 1214 format(//,1h ,21(1h-),' overall plot of the structure  ',
     125(1h-))                                          
 1215 format(//,1h ,21(1h-),'  partial plot for fragment ',i3,
     1 1x,25(1h-))        
      if (iex.eq.0) then
                      write(ncwu,1035) scl
                    else
                      write(ncwu,1036) scl
                    endif                                        
 1035 format(1h ,12(1h-),' projection on l.s.q. plane ---- scale :'
     *,f6.2,' cms/a  ',12(1h-))
 1036 format(1h ,12(1h-),'projection on m.s.q. plane ---- scale :'
     *,f6.2,' cms/a  ',12(1h-))
      do 1401 j=1,3
 1401 write(ncwu,1380)
 1380 format(2h  )
      ix=0
      offset = 0.5 * (orizmx - (xmax(n2) - xmin(n2)) * scale) + 1.5
c      write(ncwu,*) 'offset= ',offset
      norizmx=int(orizmx)
      nord=nfld
      do 104 j=nord,nord+norizmx-1
      line(j-nord+1)=ib
      store(j)=0
104   store(j+norizmx)=0
      nord=nfld
      m25=l25
      do 1460 i=1,n25
      if(store(m25+1).lt.0.5) goto 1390
      lc=m25+2
      jx =lc
      do 103 l=1,3
      x2(l)=store(jx)
103   jx=jx+1
c      write(ncwu,*)' i, store(m25+1),x2 ',i,store(m25+1),x2
      ixrel = 0.1 * aln * scale * (xmax(n1)-x2(n1)) - float(ix) + 0.5
      if(ixrel.le.0)go to 1420
      ndat=(nord-nfld)/2
c      write(ncwu,*)' stline,nfld,ndat,line',nfld,ndat,line
      call stline(nfld,ndat,n015,line,scl)
      nord=nfld
      do 1400 j=nord,nord+norizmx-1
      line(j-nord+1)=ib
      store(j)=0
1400  store(j+norizmx)=0
1420  continue
      ix2=scale*(x2(n2)-xmin(n2))+offset
      if(ix2.gt.norizmx)ix2=norizmx
      if(ix2.le.0)ix2=1
      store(nord  )=ix2
      store(nord+1)=store(m25+1)
c      write(ncwu,*)' nord,store(nord),store(nord+1)',
c     1 nord,store(nord),store(nord+1)
      nord=nord+2
      ix=ix+ixrel
c      write(ncwu,1385)
c 1385 format(2h+ )
1390  m25=m25+md25
 1460 continue
      ndat=(nord-nfld)/2
      call stline(nfld,ndat,n015,line,scl)
      nord=nfld
      do 1402 j=nord,nord+norizmx-1
      line(j-nord+1)=ib
      store(j)=0
1402  store(j+norizmx)=0
      do 1403 j=1,2
 1403 write(ncwu,1380)
      if(iplo.eq.1.or.iex.eq.1) return
      iex=1
      n2 = 2
      n1 = 3
      goto 1200
      end
c
code for stline
      subroutine stline(lf,n,n015,line,scale)
      character *2 blank,star,minus
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common /xdata/ store(244000)
      dimension istore(244000)
      dimension line(78),itab(78,4)
      equivalence(store,istore)
c     data iast/1h*/,inus/1h-/
c
      blank = ' '
      star  = '*'
      minus = '-'
      read(minus,'(a1)') inus
      if (scale.gt.2.0) then
                          read(star ,'(a1)') iast
                        else
                          read(blank,'(a1)') iast
                        endif
c 
c-- sort the peaks in decreasing horizontal order
      jump=-1
      call sortz(lf,n,2,jump)
      jlast=78
      mlf=lf
      do 100 i=1,n
      itab(i,1)=int(store(mlf  ))
      itab(i,2)=int(store(mlf+1))
      itab(i,3)=jlast
      k1=itab(i,2)
      ncif=1
      if (k1.gt.n015) go to 110
      if (k1.ge.10) ncif=2
      if (k1.ge.100) ncif=3
  110 itab(i,4)=ncif
      if (itab(i,1).gt.jlast) itab(i,1)=jlast
      jlast=itab(i,1)-ncif
      if (jlast.ge.0) go to 100
      if (itab(i,3).ge.itab(i,1)+ncif-1) then
          itab(i,1)=itab(i,1)+ncif-1
          jlast=itab(i,1)-ncif
          go to 100
        endif
      if (i.eq.1) go to 101
      i0=i
      do 150 ll=1,i0-1
      l=i0-ll
      if ((itab(l,1)-itab(l,3)).ge.jlast) go to 150
      itab(l,1)=itab(l,1)-jlast
      l0=l
      do 160 k=l0+1,i
      itab(k,1)=itab(k,1)-jlast
      itab(k,3)=itab(k,3)-jlast
  160 continue
      jlast=itab(i0,1)
      go to 100
  150 continue
  101 itab(i,1)=0
  100 mlf=mlf+2
      do 200 i=1,n
      j=itab(i,1)
      k=itab(i,2)
      if (j.le.0) go to 200
      if (k.gt.n015) then
                   line(j)=iast
                     else
                       call salf0(j,k,line)
                     endif
  200 mlf=mlf+2
      write(ncwu,111)line
111   format(1x,79a1)
      return
      end
c
code for salf0
      subroutine salf0(j,iarg,ivet)
c--trasform integer number to alphanumeric characters
c  j     last address in ivet
c  iarg  integer number
c  ivet  vector for printing
c
      dimension ivet(78),numb(10)
      data numb/'0', '1', '2', '3', '4', '5', '6', '7', 
     1     '8', '9'/
      data inus/1h-/
c
      iar=iabs(iarg)
 1000 continue
      iar1=iar
      iar=iar/10
      i=iar1-iar*10+1
      ivet(j)=numb(i)
      j=j-1
      if(iar)  1010,1010,1000
 1010 continue
      if(iarg)    1020,1030,1030
 1020 continue
      ivet(j)= inus
      j=j-1
 1030 continue
      return
      end
c
code for xpqmm
      subroutine xpqmm(idev)
c--main routine for l.s. plane calculation
c
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common/workc/ggg(9),ggr(9),x1(6),x2(6),x3(6),x4(6),x5(6),x6(6),
     1          eval(3),eve(3,3),ever(3,3),
     2          ainer(3,3),vv(3),vr(3),
     3          caa(3,3),xb(3),varxb(3,3),
     4          gg(3,3),gr(3,3),varian(4),l28,m28,md28,n28
     5          ,l25,m25,md25,n25
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(store,istore)
c--set unitary weights in list 28
      md28 = 1
      n28 = n25
      mnfl = l28+n28*md28+1
      m28 = l28
      do 400 l=m28,m28+n28
      store(l) = 1.0
  400 continue
      call m1m3 (ggg,gg)
      call m1m3 (ggr,gr)
c---- set normal equations matrix for the best plane
      call xneqp(ggg,ggr,l25,n25,md25,m28,ainer,xb,idev,varxb)
      if(istat2.gt.4) write(ncwu,1020) ((ainer(i,j),j=1,3),i=1,3)
 1020 format(15x,'normal equat. matrix          ',/
     2,3(10x,3f10.5,/))
c--search for the eigenvalues and eigenvectors
      call eignv3(gg,gr,ainer,eval,eve,ever)
      do 100 i=1,3
      vv(1) = eve(i,1)
      vv(2) = eve(i,2)
      vv(3) = eve(i,3)
      call mave(ggg,vv,vr)
      ever(i,1)= vr(1)
      ever(i,2)= vr(2)
      ever(i,3)= vr(3)
  100 continue
      if(istat2.gt.4) then
      write(ncwu,1070) (i,eval(i),(eve(i,j),j=1,3)
     1,                (ever(i,j),j=1,3),i=1,3)
1070  format(/,'eigenvalue'
     2,5x,'real eigenvectors'
     3,5x,'dual eigenvectors',/
     4,5x,i5,2x,7f9.4)
      cin32=eval(3)/eval(2)
      cin31=eval(3)/eval(1)
      cin21=eval(2)/eval(1)
      write(ncwu,1080) cin32,cin31,cin21
 1080 format (/,5x,'indici di confidenza '
     1,/,5x,3(f8.2,2x),/)
                     endif
      return
      end
c
code for mave
      subroutine mave(g,a,b)
c-----
c----- matrix * vector multiplicatio
c-----
      dimension g(9)
      dimension a(3),b(3)
      idm =3
      do 10 i=1,idm
      j=(i-1)*idm
      b(i)=0.0
      do 20 l=1,idm
      b(i)=b(i)+g(j+l)*a(l)
   20 continue
   10 continue
      return
      end
c
code for bonder
      subroutine bonder(ivet,lcon1,numfr,lindr,nn15,ll15,l15con)
c
c-- create peaks  to obtain bonds
c
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)
     5,icopk(9),icoel(9),icogr(500)
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(store,istore)
      dimension ivet(12),numfr(100),lindr(50)
      dimension d(3),d2(3)
c
      l15=ivet(1)
      n15=ivet(2)
      md15=ivet(3)
      l2  =ivet(10)
      n2  =ivet(11)
      md2 =ivet(12)
c
      mbuf=l15con+1
      ncopie=0
      numb=3
      ll15=nfl
      nn15=n15
      m15=l15
      ml15=ll15
      do 100 i=1,n15
      istore(ml15)=istore(m15)
      store(ml15+1)=store(m15+1)
      store(ml15+2)=store(m15+2)
      store(ml15+3)=store(m15+3)
      store(ml15+4)=store(m15+4)
      store(ml15+5)=store(m15+5)
      store(ml15+6)=store(m15+6)
      store(ml15+7)=store(m15+7)
      m15=m15+md15
      ml15=ml15+md15
100   continue
      kk=ml15+1
c
      do 2100 kkk=1,nfrag
      laddx=lindr(kkk)
      m=laddx
      do 1800 k=1,n15
      mm=istore(m)
      if(mm.eq.0)go to 1800
c     write(ncwu,*)'mm,istore(mm)  ',mm,istore(mm)
      nord1=istore(mm)
      nleg=istore(mm+1)
      ll1=l15+(nord1-1)*md15+1
c     write(ncwu,*)'nord1,ll1 ',nord1,ll1
      if (nleg.eq.0) go to 1800
      nfr=jordfr(istore(lclus+nord1-1))
      mm=mm+2
      do 1750 j=1,nleg
      nord2=istore(mm)/10
      if(nord2.le.nord1)go to 1750
      iop=istore(mm)-nord2*10
      if(iop.ne.0)go to 1750
      ll2=l15+(nord2-1)*md15+1
      do 1720  i=1,3
      d2(i)=store(ll1+i)-store(ll2+i)
1720  d(i)=d2(i)/numb
      distt=g(1)*d2(1)*d2(1)
     1    +g(5)*d2(2)*d2(2)
     2    +g(9)*d2(3)*d2(3)
     3    +g(2)*d2(1)*d2(2)*2.0
     4    +g(3)*d2(1)*d2(3)*2.0
     5    +g(6)*d2(2)*d2(3)*2.0
      distt=sqrt(distt)
      no1=icogr(nord1)
      no2=icogr(nord2)
      if(distt.gt.dmnmx(no1,no2,2))go to 1750
c-- connectivity
Corig istore(mbuf)=nord1
Corig istore(mbuf+1)=nord2
      istore(mbuf)=store(ll1)
      istore(mbuf+1)=store(ll2)
c     write(6,*) 'Connettivita ',nord1,store(ll1),nord2,store(ll2)
      ncopie=ncopie+1
      mbuf=mbuf+2
      ll=ll1
      do 1700 ii=1,numb-1
      nn15=nn15+1
      istore(kk-1)=istore(l15)
      store(kk)=nfr
      store(kk+4)=-9999
      do 1680 i=1,3
1680  store(kk+i)=store(ll+i)-d(i)
      ll=kk
      kk=kk+md15
1700  continue
1750  mm=mm+1
1800  m=m+1
2100  continue
      istore(l15con)=ncopie
c      write(ncwu,*)'conect ',(istore(m),m=l15con,mbuf)
      nfl=kk
      return
      end
c
code for sorda
      subroutine sorda(ifrag,ivet,lindr,numfr,nanel,lanel,kanel,nrami,
     *lorda,numb,ic,n2p,vett)
c-- ordina gli  anelli
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)
     5,icopk(9),icoel(9),icogr(500)
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(istore,store)
      dimension lindr(50),numfr(100),yyy(3),vett(3,4),ivet(12)
      dimension ipol(2,200),jcontr(500)
c
      l15=ivet(1)
      n15=ivet(2)
      md15=ivet(3)
      l2  =ivet(10)
      n2  =ivet(11)
      md2 =ivet(12)
c      write(ncwu,*)(istore(i),i=lclus,lclus+n15-1)
      kanel=nfl
      m=kanel
      mm=lanel
      do 1 i=1,n15
      jcontr(i)=0
      istore(m)=istore(mm)
      mm=mm+1
1     m = m+1
      i=kanel
      kanel=lanel
      lanel=i
      nfl=m
      lorda=nfl
      nfl=lorda+n15
      numb=lorda
      manel=lanel
      lind=lindr(ifrag)
      mindr=lind
      ipolim=0
      do 2 i=1,20
      ipol(1,i)=0
2     ipol(2,i)=0
      nn4=40
      nnn=2
      if(nrami.gt.0)nnn=3
c      write(ncwu,*)'   nrami,nnn   ',nrami,nnn
c      write(ncwu,*)(istore(i),i=lanel,lanel+n15-1)
      do 3  i=1,n15
      istore(numb)=0
      if(istore(manel).le.1)istore(manel)=0
      if(istore(manel).gt.nnn)nnn=istore(manel)
      numb=numb+1
3     manel=manel+1
c      write(ncwu,*)(istore(i),i=lanel,lanel+n15-1)
      numb=lorda
10    i0=1
11    manel=lanel+i0-1
      do 4   i=i0,n15
c      write(ncwu,*)'i,ist(manel),nnn,nn4 ',i,istore(manel),nnn,nn4
      if(istore(manel).ne.nnn)go to 4
      in0=i
      if(nnn.eq.nn4)then
      istore(manel)=-3
      istore(numb)=-in0
      numb=numb+1
      endif
      if(nnn.ge.3.and.nnn.lt.nn4)then
      nnn=nn4
      istore(manel)=nn4
      istore(numb)=in0
      numb=numb+1
      endif
      if(nnn.eq.2)then
      istore(manel)=-2
      istore(numb)=in0
      numb=numb+1
      endif
      inn0=in0
      nn0=0
      go to 27
4     manel=manel+1
      if(nnn.eq.-3)go to 35
      if(nnn.eq.nn4)nnn=-3
      if(nnn.ge.3.and.nnn.lt.nn4)nnn=nn4
      go to 10
c
27    ml=lind+in0-1
c      write(ncwu,*)'lorda',(istore(i),i=lorda,numb)
      mn=mndst(ivet,ic,n2p
     1,vett,ipol,ipolim,inn0,in0,lanel,lind,nord2,numb,lorda,nn4)
      if(mn.eq.0)then
      if(nnn.eq.-3)then
      if(i0.ge.n15)go to 35
      i0=i0+1
      go to 11
      endif
      if(nnn.eq.2)go to 35
      go to 10
      endif
      if(nnn.eq.-3)nnn=nn4
      jcontr(nord2)=jcontr(nord2)+1
      iupx=jupxyz(ivet,ic,n2p,vett,in0,nord2,yyy,dummy)
c      write(ncwu,*)'in0,nord2,yyy,iupx,istore(lanel+nord2-1)',
c     1in0,nord2,yyy,iupx,istore(lanel+nord2-1)
      if(istore(lanel+nord2-1).lt.0) then
        if(iupx.eq.0.or.ipolim.eq.200) goto 10
        ipolim=ipolim+iupx
        ipol(1,ipolim)=in0
        ipol(2,ipolim)=nord2
        goto 10
      endif
      if(istore(lanel+nord2-1).eq.nn4)then
      istore(lanel+nord2-1)=-3
      go to 10
      endif
c      if(jcontr(nord2).gt.1)go to 27
      call chcoo(ivet,nord2,yyy)
c      write(ncwu,*)'jcontr ',(jcontr(i),i=1,n15)
      if(istore(lanel+nord2-1).ge.3.and
     1.istore(lanel+nord2-1).lt.nn4)then
      istore(lanel+nord2-1)=nn4
      in0=nord2
      istore(numb)=in0
      numb=numb+1
      go to 27
      endif
      if(istore(lanel+nord2-1).eq.2)then
      in0=nord2
      istore(lanel+nord2-1)=-2
      istore(numb)=in0
      numb=numb+1
      go to 27
      endif
35    continue
      numb=numb-1
      manel=lanel
      kanem=kanel
      do 40 i=1,n15
      if(istore(manel).le.-2)istore(kanem)=2
      manel=manel+1
40    kanem=kanem+1
      i=lanel
      lanel=kanel
      kanel=i
      if(ipolim.eq.1)go to 60
      ipoli=ipolim
49    continue
      do 50 ii=1,ipoli-1
      do 50 iii=ii+1,ipoli
      if(ipol(1,ii).ne.ipol(1,iii).and.ipol(1,ii).ne.ipol(2,iii))goto 50
      if(ipol(1,ii).eq.ipol(1,iii).and.ipol(2,ii).ne.ipol(2,iii))goto 50
      if(ipol(1,ii).eq.ipol(2,iii).and.ipol(2,ii).ne.ipol(1,iii))goto 50
      ipol(1,iii)=0
      ipol(2,iii)=0
      ipoli=ipoli-1
      do 55  i=iii,ipolim-1
      ipol(1,i)=ipol(1,i+1)
      ipol(2,i)=ipol(2,i+1)
      ipol(1,i+1)=0
      ipol(2,i+1)=0
55    continue
      go to 49
50    continue
      ipolim=ipoli
60    continue
      if(ipolim.gt.0.and.istat2.gt.0)
     *   write(ncwu,70)(ipol(1,i),ipol(2,i),i=1,ipolim)
70    format(1x,'interpretation finds a polimeric structure through',
     1 ' bond(s) ',3(2i3,4x),/,3(8(2i3,4x),/))
      return
      end
c
code for jupxyz
      function jupxyz(ivet,ic,n2p,vett,nord1,nord2,yyy,dist)
c
c-- control if the coordinates of nord2 must be change (0=no ,1=yes)
c
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)
     5,icopk(9),icoel(9),icogr(500)
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(store,istore)
      dimension ivet(12),vett(3,4)
      dimension yyy(3),sss(3)
      dimension ssx(3,100),yyx(3,100),d(3,100),dst(100),npp(100)
c
      l15=ivet(1)
      n15=ivet(2)
      md15=ivet(3)
      l2  =ivet(10)
      n2  =ivet(11)
      md2 =ivet(12)
      jupxyz=0
c-- modify x,y,z
      idista=idst(ivet,ic,n2p,nord1,nord2,vett,npp,ntot,dst,d,yyx,ssx)
      if(ntot.eq.0)return
      dist=100000.
      do 120 jj=1,ntot
      if(dist.lt.dst(jj))go to 120
      dist=dst(jj)
      nop=npp(jj)
      do 130 jjj=1,3
      yyy(jjj)=yyx(jjj,jj)
130   sss(jjj)=ssx(jjj,jj)
120   continue
      dist=sqrt(dist)
      l=l15+(nord2-1)*md15+2
      ll1=l
      do 140  ll=1,3
      if(abs(store(l)-yyy(ll)).le.0.001)go to 140
      jupxyz=1
      go to 145
140   l=l+1
      return
145   continue
      return
      end
c
code for chcoo
      subroutine chcoo(ivet,nord2,yyy)
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(store,istore)
      dimension yyy(3),ivet(12)
      l15=ivet(1)
      n15=ivet(2)
      md15=ivet(3)
      l2  =ivet(10)
      n2  =ivet(11)
      n2  =ivet(11)
      md2 =ivet(12)
      l=l15+(nord2-1)*md15+2
      ll1=l
      do 100  ll=1,3
      store(l)=yyy(ll)
100   l=l+1
c      write(ncwu,*) 'chcoo  ',nord2,(store(lll),lll=ll1,ll1+2),yyy
      return
      end
c
code for mndst
      function mndst(ivet,ic,n2p,vett,ipol,ip,jn0,in0,lanel,lind,n,
     1          numb,lorda,nn4)
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)
     5,icopk(9),icoel(9),icogr(500)
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(istore,store)
      dimension ivet(12),d(50),yyy(3),ipol(2,200),vett(3,4)
c      write(ncwu,*)'mndst ',(istore(ii),ii=lorda,numb-1)
      mndst=0
      n=0
      do 10 j=1,50
10    d(j)=0.
      ml=lind+in0-1
c      write(ncwu,*)'  mndst,in0,ml      ',in0,ml
      m=istore(ml)
      if(m.eq.0)return
      nleg=istore(m+1)
      if(nleg.eq.0)return
      m=m+2
      ij=0
      kn0=jn0
c      write(ncwu,*)'  mndst,in0,m,nleg  ',in0,m,nleg
      do 100 i=1,nleg
      i4=0
      nord2=istore(m)/10
      if(istore(lanel+nord2-1).eq.0)go to 100
c      write(ncwu,*)
c     1' in0,jn0,nord2,istore(lanel+in0-1),istore(lanel+nord2-1) ',
c     1in0,jn0,nord2,istore(lanel+in0-1),istore(lanel+nord2-1)
      num=numb-lorda
      if(num.ge.2.and.iabs(istore(numb-2)).eq.nord2)go to 100
      if(jn0.eq.nord2)kn0=in0
      if(in0.eq.nord2)then
      iupx=1
      go to 111
      endif
      iupx=jupxyz(ivet,ic,n2p,vett,kn0,nord2,yyy,dist)
c      write(ncwu,*)' iupx,kn0,nord2  ',iupx,kn0,nord2
111   if(iupx.eq.1.and.istore(lanel+nord2-1).lt.0)then
       if(ip.eq.200)go to 113
        do 112  iip=1,ip
        if(in0.eq.ipol(1,iip).and.nord2.eq.ipol(2,iip))
     1go to 113
        if(in0.eq.ipol(2,iip).and.nord2.eq.ipol(1,iip))
     1go to 113
112   continue
        ip=ip+iupx
        ipol(1,ip)=in0
        ipol(2,ip)=nord2
113   continue
      endif
      if(istore(lanel+nord2-1).eq.nn4.or.nord2.eq.in0)then
      if(istore(lanel+nord2-1).eq.nn4)i4=100
      if(nord2.eq.in0)go to 100
      endif
      if(istore(lanel+nord2-1).le.0)go to 100
      mndst=1
c     call chcoo(ivet,nord2,yyy)
      if(ij.ge.1.and.i4.eq.100)go to 100
      ij=ij+1
c      write(ncwu,*)' ij,d,dist  ',ij,(d(iij),iij=1,ij-1),dist
      do 110 j=1,3
110   d(ij)=i4+dist
      if(ij.eq.1)then
      n=nord2
      go to 100
      endif
      do 120 j=1,ij-1
      if(d(ij).ge.d(j))go to 120
      n=nord2
120   continue
100   m=m+1
      return
      end
c
code for chgxyz
      subroutine chgxyz(ivet,lcon1,ic,n2p,vett,numfr,lindr
     1,lanel,lbb,izpk)
c
c-- change peaks coordinates to obtain the best plot
c
      common/xunit/ncru,ncwu,ncpu,ncpt,itty,istat2
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)
     5,icopk(9),icoel(9),icogr(500)
      common /xdata/ store(244000)
      dimension istore(244000)
      equivalence(store,istore)
      dimension ivet(12),vett(3,4),baric(3),numfr(100),lindr(50)
      dimension yyy(3),sss(3),ianel(500),izpk(500)
      dimension yy(3),ssx(3,100),yyx(3,100),d(3,100),dst(100),npp(100)
c
      l15=ivet(1)
      n15=ivet(2)
      md15=ivet(3)
      l2  =ivet(10)
      n2  =ivet(11)
      md2 =ivet(12)
      l15buf=lbb+n15*md15
      istam=0
      lcon3=nfl
      nfl=lcon3+n15
      ll15=l15
      l15=nfl
      m15=l15
      mm15=ll15
      mn15=n15*md15
      do 10  j=1,mn15
10    store(l15+j-1)=store(ll15+j-1)
      lbari=l15+n15*md15
      lbarj=lbari
      nfl=lbari+n15*md15
      dsave=dmax
      dmax=10000.0
      ivet(1)=l15
c      write(ncwu,*)(istore(lll),lll=lclus,lclus+n15-1)
c
c-- initialize work array
c
      do 2000 kkk=1,nfrag
c      write(ncwu,*) '    ----------- frammento #',kkk,'  -----------'
      laddx=lindr(kkk)
      m=laddx
      k=lcon3
      l=lclus
c      write(ncwu,*)'laddx,lcon3,lclus,numfr(nfrag),n15   ',
c     1laddx,lcon3,lclus,numfr(kkk),n15
      kk3=0
      do 20  j=1,n15
      istore(k)=0
      kk1=istore(l)
      kk2=mod(kk1,100)
      if (kk2.eq.kkk)then
      istore(k)=1
      kk3=kk3+1
      endif
      l=l+1
20    k=k+1
c      write(ncwu,*)(istore(lll),lll=lcon3,lcon3+n15-1)
c
c-- first pass : analize the ringed peaks
c
      denom=0
      do 30  j=1,3
30    baric(j)=0
      kch=kkk
      call chanel(kch,n15,lindr,numfr,nanel,ianel,lanel,nrami,istam)
      k0=0
c      write(ncwu,*)' nanel,nrami ',nanel,nrami
      if(nanel.eq.0)go to 1950
      k0=1
      call sorda(kch,ivet,lindr,numfr,nanel,lanel,kanel,nrami,lorda,
     *numb,ic,n2p,vett)
c     write(ncwu,*) ' riprende chxyz   '
      manel=lanel
      kanem=lcon3
      m15=l15+1
      do 40 i=1,n15
      if(istore(manel).eq.2)then
      istore(kanem)=2
      do 41 j=1,3
41    baric(j)=baric(j)+store(m15+j)
      denom=denom+1
      endif
      m15=m15+md15
      manel=manel+1
40    kanem=kanem+1
c-- move the other peaks
1950  k=lcon3
      m=laddx
      iflag=0
      do 1900 i=1,n15
      if (k0.eq.0.and.istore(k).eq.1) then
                                        istore(k)=2
                                        k0=1
                                              l=l15+(i-1)*md15+2
                                             do 1901 ll=1,3
                                              baric(ll)=store(l)
 1901                                        l=l+1
c     write(ncwu,*)' 1901  kkk, i,baric denom  ',kkk,i,baric,denom
                                      endif
      if (istore(k).ne.2) go to 1800
      mm=istore(m)
c      write(ncwu,*)' mm  ',mm
      if(mm.eq.0)go to 1800
      nord1=i
      nleg=istore(mm+1)
      l=l15+(nord1-1)*md15+1
c      write(ncwu,*) 'l15,laddx,nord1, nleg ',l15,laddx,nord1,nleg
      if (nleg.eq.0) go to 1800
      mm=mm+2
      do 1750 j=1,nleg
      nord2=istore(mm+j-1)/10
      kk=istore(mm+j-1)-nord2*10
      km=kk
      if(kk.gt.0)go to 1750
c      write(ncwu,*)'nord2 kk',nord2,km
      kk=istore(lcon3+nord2-1)
c      write(ncwu,*)'nord2 kk,mcon3 ',nord2,km,kk
      if (kk.ne.1) go to 1750
c-- modify x,y,z
      iupx=jupxyz(ivet,ic,n2p,vett,nord1,nord2,yyy,dummy)
      if(iupx.eq.1)call chcoo(ivet,nord2,yyy)
      l=l15+(nord2-1)*md15+2
      do 1700 ll=1,3
      baric(ll)=baric(ll)+yyy(ll)
 1700 l=l+1
c-- modified
      l=l15+(nord2-1)*md15+2
      istore(lcon3+nord2-1)=2
      iflag=1
 1750 continue
 1800 k=k+1
      m=m+1
 1900 continue
      if(iflag.eq.1)go to 1950
c     if (nfrag.eq.1) go to 2000
      denom=float(numfr(kkk))
      baric(1)=baric(1)/denom
      baric(2)=baric(2)/denom
      baric(3)=baric(3)/denom
c     write(ncwu,*)'kkk,baric   ',kkk,baric
      istore(lbarj  )=kkk
      store(lbarj+1)=n15+kkk
      store(lbarj+2)=baric(1)
      store(lbarj+3)=baric(2)
      store(lbarj+4)=baric(3)
      store(lbarj+5)=0.0
      store(lbarj+6)=0.0
      lbarj=lbarj+md15
 2000 continue
c
c-- second pass : move fragments
c
      if (nfrag.eq.1) go to 2700
      do 2600 j1=2,nfrag
      nord1=n15+j1
      distt=dmax
      nord=0
      dist=1000000.
c
      do 2650 j=1,j1-1
      nord2=n15+j
      idista=idst(ivet,ic,n2p,nord2,nord1,vett,npp,ntot,dst,d,yyx,ssx)
      if(ntot.eq.0) stop 'ntot=0'       ! go to 2600
      do 2650 jj=1,ntot
      if(dist.lt.dst(jj))go to 2650
      dist=dst(jj)
      nopp=npp(jj)
      do 2660 jjj=1,3
      yyy(jjj)=yyx(jjj,jj)
2660  sss(jjj)=ssx(jjj,jj)
2650  continue
c
c     write(ncwu,*)'ifrag,yyy,sss',j,yyy,sss
      m0=lbari+(j1-1)*md15
      istore(m0 )=nopp
      call iorop(m0,icentr,itx,ity,itz,nord,nop,kk1)
c     write(ncwu,*)'iorop,icentr,itx,ity,itz,nord,nop,kk1 '  ,
c    1icentr,itx,ity,itz,nord,nop,kk1
      m2=l2+(nop-1)*md2
      l=lclus
      baric(1)=0.0
      baric(2)=0.0
      baric(3)=0.0
      do 2500 jj=1,n15
      kk2=mod(istore(l),100)
      if (kk2.eq.j1) then
         kk4=l15+(jj-1)*md15+2
         do  2200 kk3=1,3
         yyy(kk3)=store(kk4)
 2200    kk4=kk4+1
         yy(1)=yyy(1)*store(m2  )+yyy(2)*store(m2+1)+yyy(3)*store(m2+2)
         yy(2)=yyy(1)*store(m2+3)+yyy(2)*store(m2+4)+yyy(3)*store(m2+5)
         yy(3)=yyy(1)*store(m2+6)+yyy(2)*store(m2+7)+yyy(3)*store(m2+8)
         yy(1)=yy(1)+store(m2+ 9)
         yy(2)=yy(2)+store(m2+10)
         yy(3)=yy(3)+store(m2+11)
c        write(ncwu,*)'2200 ',yyy,yy
         do 2300 jjj=1,3
         yy(jjj)=yy(jjj)*icentr+vett(jjj,kk1) + sss(jjj)
 2300    continue
c        write(ncwu,*)'2300 ',yy
         kk4=l15+(jj-1)*md15+2
         do 2400 kk3=1,3
         baric(kk3)=baric(kk3)+yy(kk3)
         store(kk4)=yy(kk3)
         kk4=kk4+1
 2400    continue
       endif
      l=l+1
 2500 continue
         kk4=l15+(n15+j1-1)*md15+2
         do  2550 kk3=1,3
         store(kk4)=baric(kk3)/float(numfr(j1))
         kk4=kk4+1
 2550    continue
 2600 continue
c
c-- third  pass : analize unlinked peaks
c
 2700 continue
c
c-- find out unlinked peaks in order to move them 
c-- at minimun distance from other peaks
c
      l=lclus
      laddx=laddr
      m=laddx
      do 3400 i=1,n15
      if (istore(l).gt.0) go to 3300
c
      mm=istore(m)
      nord2=istore(mm)
      nleg=istore(mm+1)
      nord1=0
      dist=1000000.
      if (nleg.le.0) go to 3100
      mm=mm+2
      do 3000 j=1,nleg
      m0=mm
      call iorop(m0,icentr,itx,ity,itz,nord,nop,kk1)
      ddist=store(m0+1)
      kk=istore(lcon3+nord-1)
      if (kk.ne.2) go to 2900
      if (ddist.lt.dist) then
                            nord1=nord
                            dist=ddist
                          endif
 2900 mm=mm+mddis
 3000 continue
 3100 continue
      mclus1=lclus+nord1-1
      mclus2=lclus+nord2-1
      ntot=0
c     write(ncwu,*)' ntot,i     ',ntot,i
      if (nord1.ne.0) then
c-- modify x,y,z according to another peak
          izpk2=iabs(istore(mclus2))
          izpk2=izpk2/100
          izpk1=iabs(istore(mclus1))
          izpk1=mod(izpk1,100)
          istore(mclus2)=-(izpk2*100+izpk1)
       idista=idst(ivet,ic,n2p,nord1,nord2,vett,npp,ntot,dst,d,yyx,ssx)
          dist=1000000.
          do 3650 jj=1,ntot
          if(dist.lt.dst(jj))go to 3650
          dist=dst(jj)
          nop=npp(jj)
          do 3660 jjj=1,3
          yyy(jjj)=yyx(jjj,jj)
 3660     sss(jjj)=ssx(jjj,jj)
 3650     continue
        else
c-- modify x,y,z according to the baricentrum of the closest fragment
          izpk2=iabs(istore(mclus2))/100
          dist=1000000.
          ibari=0
          do 4700 j1=1,nfrag
          nord1=n15+j1
       idista=idst(ivet,ic,n2p,nord1,nord2,vett,npp,ntot,dst,d,yyx,ssx)
          if(ntot.eq.0) stop 'ntot=0'       ! go to 2600
          do 4650 jj=1,ntot
          if(dist.lt.dst(jj))go to 4650
          ibari=j1
          dist=dst(jj)
          nopp=npp(jj)
          do 4660 jjj=1,3
          yyy(jjj)=yyx(jjj,jj)
 4660     sss(jjj)=ssx(jjj,jj)
 4650     continue
 4700     continue
          istore(mclus2)=-(izpk2*100+ibari)
        endif
      k=l15+(nord2-1)*md15+2
      do 4680 ll=1,3
      store(k)=yyy(ll)
 4680 k=k+1
 3300 l=l+1
 3400 m=m+1
c
      ll=n15*md15
      do 5000 jj=1,ll
 5000 store(l15buf+jj-1)=store(l15+jj-1)
c
      ivet(1)=l15
      dmax=dsave
      return
      end
CRYSTALS CODE FOR EXPANDX
c     generate complete hemisphere of reflexion data
      subroutine expand(numb2,mode,ccfom,ier)
      character space*16
      dimension cfom(2250),ep(31000),i1(3),i2(3),kind(24),tab(15)
      dimension ipos(302),lh(60),lk(60),ll(60),ew(60),ed(60)
      common /erl/ kmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common /xdata/ ihkl(31000),e(31000),iphaz(31000),iphb(31000)
     *              ,wt(31000),nzsav(500),occsav(500),duma(4000)
     *              ,dummpc(84000)
      common /atomo/ xyzo(5,200),nzo(200),dold(400)
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      common/rc/p(6),cx(9),nref,nb,rhomax,mm,en,mz,er,th,rhomin
      common /refl/ ih(100),g(2,100)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
      common / ureq1/ jpatt,jpunt(501),ksacc,jseteq,jumpp,jmpsie,nsec 
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /kuse/ kuser1,kuser2,kuser3
      common /tran/ scale,mh(3),level,it4,xlim(3)
      common /tape/ cell(6),neqv,icent,lat,natm,ts(3,24),is(2,3,24),nsym
     *             ,dumb(3)
      common /misc/ t(3,3),dxmax(3),mcon,iwt,fom(11),pts
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common/sf/al(4,8),bs(4,8),cl(8),nnw(8),nno(8),nk,nat,f(9),nalf(8)
      dimension vet(12),ivet(12)
      equivalence (vet(1),ivet(1))
      equivalence (iphaz(1),ep(1),cfom(1))
      equivalence (ih(1),lh(1)),(ih(61),lk(1)),(g(1,11),ll(1)),
     1  (g(1,41),ew(1)),(g(1,71),ed(1))
c
      nexp=0
      call inptf(npseud,numb)
      if (mode.ne.1) numb=numb2
      if (mode.ne.1) numb=nref
      if (numb.gt.31000) numb=31000
      if (jpatt.eq.0) call getref(ratio,mode,npseud,numb,ep)
c
c     temporary call to prepare common area
c     to manage atoms in special position
c
      call xspinb
      if (jpatt.eq.0) then
c
c     examine sets of phases in order of combined figure of merit unless
c     set is specified by the user
c
      if (mode.eq.1) then
      call srlin (16,lsn,lfw,llw,lpb,ll16)
      if(lfw.gt.0) then
                     call ysfl16(cfom,ipos,nset)
                   else
                     write(lo,140)
                     ier=-1
                     return
                   endif
  140 format(/,' *** error ***  no sets of phases available')
      if (numset.ge.1000) numset=nset-(numset-1000)
      if(numset.gt.0.and.numset.le.nset) goto 170
      if(numset.gt.0.and.numset.gt.nset) then
                                           write(lo,150) numset,nset
                                           ier=-1
                                           return
                                         endif
  150 format(/,' *** error ***  set ',i3,' has been required',/,
     *         '                but only ',i3,' sets are available')
      npos = 1
      do 160 j=1,nset
      if (cfom(j) .gt. cfom(npos)) npos = j
  160 continue
c     mark selected set
      cfom(npos) = cfom(npos)-100.0
      call ysup16(cfom,ipos,nset)
c   select set
  170 if (numset.gt.0) then
         no=numset
         nono=ipos(numset)
      else
         no=npos
         nono=ipos(npos)
      endif
      numset = no
      call snr16(nono,fom,ep,iphb)
      endif
  431 format(//,1h1, 79('+'),//,12x,
     1       '***   E-map interpretation  ***',//)
  432 format(//,1h , 79('+'),//,20x,
     1       '***   Fourier recycling section  ***',//, 9x,20a4)
  433 format(//,1h , 79('+'),//,19x,
     1       '***   Intermediate interpretation  ***',//)
  434 format(//,1h , 79('+'),//,20x,
     1 '***   Fourier recycling restarted  ***',//, 9x,
     3 '  In step B scale factor, atomic coordinates and isotropic',
     * /,13x,' thermal factors are refined via diagonal matrix.',
     4 //,23x,'Step      cycle       residual',/)
  435 format(//,1h , 79('+'),//,19x,
     1       '***   Final interpretation  ***',//,
     2       //, 9x,20a4,//)
  436 format(/,10x,i5,' (',i3,'% of total ) reflections used with Fo > '
     4   ,f8.2,//,23x,'Step      cycle       residual',/)
  437 format(/,10x,i5,' (',i3,'% of total ) reflections used with Fo > '
     4   ,f4.2,' * sigma(Fo)',//,23x,'Step      cycle       residual',/)
c
      if(mode.ne.1)then
                     if (mode.eq.2) then
                                      write(lo,432) itle
                                      perc=100.0*float(numb)/float(nref)
                                      iperc=nint(perc)
                                      if (ratio.lt.0.0) then
                                      write(lo,436) numb,iperc,fosog
                                                        else
                                      write(lo,437) numb,iperc,ratio
                                                        endif
                                    endif
                     idisp=1
                     call sfl15(natsn,idisp,idumm,interp)
      if (krecy.eq.1) write(lo,434) 
      if (krecy.gt.0) then
                        nemap(1)=nats
                        jlig=1
                        if (nno(1).eq.1) jlig=2
                        jlig=jlig*100+1
                        do 438 i=1,nats
                        if (nz(i).ne.0.and.jrest.eq.0) nz(i)=jlig
  438                   continue
                      endif
                     call pkl15(nats)
                     if (jrest.eq.0) then
                        if (krecy.eq.0) then
                        call sftra(mode,numb,ep)
                                        else
                        call sftrb(mode,numb,ep)
                        krecy=krecy+1
                                        endif
                                     else
                        call sftrc(mode,numb,ep)
                        krecy=krecy+1
                                     endif
                     rfac=erre*100.0
                     if (mode.eq.jrecyc+1) then
                                             write(lo,435) itle
                                             ier=1
                                             return
                                           endif
                     deltar=erreo-erre
                     if (krecy.le.0) then
                     if (deltar.lt.0.0025) then
                         write(lo,433)
Corig                    if (deltar.lt.0.0) 
Corig*                       call cp3015
                         if (deltar.lt.0.0) then
                             call cp3015
                             call sfl15(nats,idisp,idumm,interp)
                           endif
                         krecy=1
                         ier=1
                         return
                       endif
                                       else
                     if (deltar.lt.0.0) then
                               if (krecy.gt.3) then
      if (iprin.gt.2) write(lo,*) ' r-fac stop %',krecy
                                             write(lo,435) itle
                             call cp3015
                             call sfl15(nats,idisp,idumm,interp)
                                                 ier=1
                                                 return
                                               endif
                                        endif
                                       endif
                     erreo=erre
                     call cp1530 
                   endif
      do 185 i=1,numb
      wt(i)   = ep(i)
      e(i)    = e(i)*ep(i)
      iphaz(i)= iphb(i)
  185 continue
c
c-- richiamo subr. gestione psi-e
      if (mode.eq.1.and.jmpsie.eq.0) call gpsie(numb,error,dalfa,nexp)
      if (mode.eq.1) numb2=numb
c
      if (mode.ne.1.or.jpatt.ne.0) go to 195
      write(lo,187)
      write(lo,188)
      write(lo,189)
      write(lo,191)
      write(lo,193)
      write(lo,192) no,(fom(i),i=1,5)
      ccfom=fom(5)
      write(lo,187)
  187 format( 6x,'+------------',54('-'),'+')
  188 format( 6x,'i           i        F i g u r e s      o f     '
     1 ,' m e r i t         i')
  189 format( 6x,'i  Set no.  i',54('-'),'i')
  191 format( 6x,'i           i   mabs   i  alcomb  i  R(x,y)  i'
     1 ,'  cphase  i   cfom   i')
  192 format( 6x,'i ',i6,'    i',5(f8.4,'  i'))
  193 format( 6x,'i-----------i',5('          i'))
  195 continue
      endif 
      if (numb.eq.0) then
         write(lo,196)
         ier=-1
         return
      endif
  196 format(/,' *** error *** no reflections supplied')
      if (mode.eq.1) then
c-- psi-e informations
      if (nexp.ne.0) then
      if (knw.eq.0) then
                      write(lo,4500) nexp
                    else
                      write(lo,4510) error,dalfa,nexp
                    endif
                    else 
                      write(lo,281)
                    endif
                    endif
 4500 format(/,19x,' number of added psi-e reflections  ',i6,/)
 4510 format(/,19x,'                  mean phase error  ',f9.2,/
     *         19x,'         weighted mean phase error  ',f9.2,/,
     *         19x,' number of added psi-e reflections  ',i6,/)
      if (jpatt.eq.0) then
                        do 199 i=1,numb
                        phase=dtor*float(iphaz(i))
                        ep(i)=e(i)*sin(phase)
                        e(i)=e(i)*cos(phase)
  199                   continue
                      endif
c
c     set default values of program parameters unless specified by user
c
c
c     calculate number of grid points for fourier map
c
  248 continue
      do 280 i=1,3
         np(i)=cell(i)/factr+0.5
         if(i.eq.3) np(i)=np(i)+mod(np(i),2)
  250    ntest=np(i)
         do 270 j=2,5
  260       if(ntest.ne.(ntest/j)*j) go to 270
            ntest=ntest/j
            if(ntest.eq.1) go to 280
            go to 260
  270    continue
         np(i)=np(i)+1
         if(i.eq.3) np(i)=np(i)+1
         go to 250
  280 continue
      if (np(1).le.150) go to 282
      factr=factr+0.02
      go to 248
  282 if (mode.ne.1) go to 315
      write(lo,292)
      write(space,'(16a1)') (nt(i),i=1,16)
      call ucase(space(1:1))
      write(lo,284) space,cell
  284 format( 6x,
     * 'i                           Space group symbol  i',
     * 2h  ,a16,1hi,/, 6x,
     1 'i                     Unit cell parameters   a  i',
     2 f10.3,8x,'i',/, 6x,'i',44x,'b  i',f10.3,8x,'i',/, 6x,'i',
     3 44x,'c  i',f10.3,8x,'i',/, 6x,'i',40x,'alpha  i',f10.3,8x,'i',/
     4 , 6x,'i',41x,'beta  i',f10.3,8x,'i',/, 6x,'i',40x,'gamma  i',
     5 f10.3,8x,'i',/, 6x,'i',47x,'i',18x,'i')
  281 format(///)
  292 format( 6x,'+',47('-'),'+------------------+')
      write(lo,294) factr,np,mh
  294 format( 6x,
     1 'i  Grid spacing (in angstrom) is approximately  i',
     2 f10.3,8x,1hi,/, 6x,'i',47x,'i',18x,'i',/, 6x,
     3 'i    Number of grid points in fourier map   nx  i',
     4 i6,12x,'i',/, 6x,'i',43x,'ny  i',i6,12x,'i',/, 6x,
     5 'i',43x,'nz  i',i6,12x,'i',/, 6x,'i',47x,'i',18x,'i',/, 6x,
     6 'i                   Maximum indices value    h  i',
     7 i6,12x,'i',/, 6x,'i',44x,'k  i',i6,12x,'i',/, 6x,
     5 'i',44x,'l  i',i6,12x,'i',/, 6x,'i',47x,'i',18x,'i')
  315 if (np(1) .le. 150) go to 400
      write(lo,320)
  320 format (/,22x,'nx greater than 150. increase array inut in subro
     1utine outpuf of fft modul',/,
     2            22x,'or increase the grid value')
      ier=-1
      return
  400 continue
      if (mode.eq.1) write(lo,460) numb
      rewind jrel
  460 format ( 6x,
     1 'i      Number of independent reflections input  i',
     2 i6,12x,'i',/, 6x,'i',47x,'i',18x,'i')
c
c     generate one complete hemisphere of reflexions
c
      do 470 i=1,15
         tab(i)=sin(float(30*i)*dtor)
  470 continue
      nex = 0
      fsum=0.0
      ip5=256*(262144+512+1)
      nbatch=0
      if (jpatt.ne.0) then
                        if (npseud.eq.0) then
                                           jind=4
                                         else
                                           jind=6
                                         endif
                        if (jpatt.eq.2) jind=5
                      endif
      do 800 jn=1,numb
      if (jpatt.eq.0) then
                        i1(1)=ihkl(jn)/262144
                        j=ihkl(jn)-262144*i1(1)
                        i1(2)=j/512-256
                        i1(3)=j-512*(i1(2)+256)-256
                        eep=ep(jn)
                        ee =e (jn)
                      else
                        eep=0.0
                        call snr07(vet)
                        i1(1)=ivet(1)
                        i1(2)=ivet(2)
                        i1(3)=ivet(3)
                        if (jpatt.eq.3) then
                                          ee=vet(jind)*vet(jind+1)
                                        else
                                          ee=vet(jind)*vet(jind)
                                        endif
                      endif
      do 700 j=1,neqv
      do 540 i=1,3
  540 i2(i)=0
      do 560 i=1,3
      do 550 k=1,2
      m=iabs(is(k,i,j))
      if(m.ne.0) i2(m)=i2(m)+i1(i)*isign(1,is(k,i,j))
  550 continue
  560 continue
      b1=1.0
      js=1
      if(i2(3)) 590,570,600
  570 if(i2(1)) 590,580,600
  580 if(i2(2)) 590,600,600
  590 b1=-1.0
      js=-1
  600 kind(j)=ip5+js*(262144*i2(1)+512*i2(2)+i2(3))
      do 610 i=1,3
      if(iabs(i2(i)).ge.np(i)/2) go to 700
      if(i2(i).gt.mh(i)) mh(i)=i2(i)
  610 continue
      if(j.eq.1) go to 630
      nd=j-1
      do 620 i=1,nd
      if(kind(j).eq.kind(i)) go to 700
  620 continue
  630 nbatch=nbatch+1
      nex=nex+1
      nu=0
      do 640 i=1,3
  640 nu=nu-i1(i)*int(ts(i,j)*12.0+0.1)
      nu=mod(nu,12)
      if(nu.le.0) nu=nu+12
      xc=tab(nu+3)
      xs=tab(nu)
      gr=xc*ee-xs*eep
      gi=(xs*ee+xc*eep)*b1
      fsum=fsum+sqrt(gr*gr+gi*gi)
      g(1,nbatch)=gr
      g(2,nbatch)=gi
      ih(nbatch)=kind(j)
      if(nbatch.lt.100) go to 700
      write(jrel) ih,g
      nbatch=0
  700 continue
  800 continue
      if(nbatch.ne.0) write(jrel) ih,g
      scale=3000.0/fsum
      if (mode.eq.1) write(lo,990) nex,scale
  990 format( 6x,
     1 'i      Number of reflections in one hemisphere  i',
     2 i6,12x,'i',/, 6x,'i',47x,'i',18x,'i',/, 6x,
     3 'i                                        Scale  i',
     4 f10.3,8x,'i',/, 6x,'+',47('-'),'+------------------+')
      if(mode.eq.1) write(lo,431)
      if (it4 .gt. 0) write(lo,410) xlim,level
  410 format (///13x,43hfourier map to be printed from x =  0.0  to,
     1  f7.3, 15h,  y =  0.0  to, f7.3, 15h,  z =  0.0  to, f7.3,//,
     1 40x,33hpoints underlined if greater than,i5)
      return
      end
c--------------------------------------------------------------------------
      subroutine getref(ratio,mode,npseud,numb,ep)
      common /xdata/ ihkl(31000),e(31000),iphaz(31000),iphb(31000)
     *              ,wt(31000),duma(5000)
     *              ,dummpc(84000)
      common/c/flgw(30),flgd(30),avr(30),dcv(50),slope,flgk,bt,sc,del,ks
      common/rc/p(6),cx(9),nref,nb,rhomax,mm,en,mz,er,th,rhomin
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nat,f(9),nalf(8)
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      dimension ep(31000)
      dimension vet(12),ivet(12)
      equivalence(vet(1),ivet(1))
c
c-- if pseudo exists the file  normalized e's are used
c-- ( not the renormalized e's used for invariants )
c
      if (ksigma.gt.0.and.
     *    tsigma.gt.0.0) then
                           ratio=tsigma
                         else
                           ratio=-1.0
                           if (fomin.gt.0.0) fosog=fomin
                           fsog=sqrt(fosog*fosog*sc)
                         endif
      if (npseud.eq.0) then
                         jps=4
                       else
                         jps=6
                       endif
      icont=0
      do 100 i=1,numb
      call snr07(vet)
      if (mode.eq.1) then
                       icont=icont+1
                       e(icont)=vet(jps)
                       ihkl(icont) = 262144*ivet(1) +512*ivet(2) 
     *                              +ivet(3) +131328
                     else
                       fo=vet(5)
                       iuse=0
                       if (ratio.gt.0.0) then
                                          sigma=vet(9)
                                          a=ratio*sigma
                                          if (fo.gt.a) iuse=1
                                        else
                                          if (fo.gt.fsog) iuse=1
                                        endif
                       if (iuse.eq.1) then
                          icont=icont+1
                          rho=rhof(p,ivet(1),ivet(2),ivet(3))
                          rho=rho*rho
                          e(icont)=fo
                          wt(icont)=rho
                          ep(icont)=vet(jps)
                          ihkl(icont) = 262144*ivet(1) +512*ivet(2) 
     *                                 +ivet(3) +131328
                       endif
                     endif
  100 continue
      numb=icont
      return
      end
c--------------------------------------------------------------------------
      subroutine sftra(mode,numb,ep)
c     structure factor and phases for fourier refinement 
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nat,f(9),nalf(8)
      common/rc/p(6),cx(9),nref,nb,rhomax,mm,en,mz,er,th,rhomin
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      common/c/flgw(30),flgd(30),avr(30),dcv(50),slope,flgk,bt,sc,del,ks
      common /erl/ kmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)
     5,icopk(9),icoel(9),icogr(500)
      common/xdata/ ihkl(31000),e(31000),iphaz(31000),iphb(31000)
     *              ,wt(31000),nzsav(500),occsav(500),
     *               fvar(500),q(500),qq(500),dummy(2500)
     *              ,dummpc(84000)
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
c
      dimension ep(31000)
c
      jlig=1
      if (no(1).eq.1) jlig=2
      anatm=0.0
      do 12 i=jlig,nk
   12 anatm=anatm+float(nw(i))
      anat=anatm
      kfrag=nemap(4)
c
c-- compute the number of peaks to consider
c
      totop=(icent+1)*nsym*pts
      delta=1.0/12.0
      sum=0.0
      enne=0.0
      jnats=0
      do 99 i=1,nats
      nzsav(i)=nz(i)
      occsav(i)=x(5,i)
      if (nz(i).eq.0) then
                        jnats=jnats+1
                        else
                         occ=x(5,i)
                         sum=sum+occ*totop
                         if ((sum-anat).lt.delta) enne=enne+1.0
                        endif
  99  continue
      bnats=float(nats-jnats)
      nenne=nint(enne)
      jnats=0
      j=nats
      do 991 i=1,nats
      if (nz(i).eq.0) go to 991
      if (jnats.ge.nenne) go to 991
      j=i
      jnats=jnats+1
  991 continue
      jnats=j
      denom=x(4,jnats)
      ii=0
      do 111 i=1,nats
      fvar(i)=1.0
      if (nz(i).eq.0) go to 111
      ii=ii+1
      b667=bnats-ii+1
      a667=b667/bnats
      a667=0.8*sqrt(a667)
      if (i.le.jnats) then
                        if (nz(i).lt.0) fvar(i)=a667
                      else
                        fvar(i)=0.667*x(4,i)/denom
                        if (nz(i).lt.0) fvar(i)=fvar(i)*a667
                      endif
  111 continue
      c=x(4,1) 
      jfirst=iabs(nz(   1)/100)
      jnats=nats+1
  115 jnats=jnats-1
      jlast =iabs(nz(jnats)/100)
      if (jlast.eq.0) go to 115
      sog=float(no(jlast))/float(no(jfirst))
      sog=sog*0.667
      iflag=0
      do 102 i=1,nats
      if (nz(i).eq.0) go to 102
      if (iflag.eq.0) then
                        qq(i)=x(4,i)/c
                        if (qq(i).lt.sog) then
                                            rife=x(4,i)
                                            iflag=1
                                            qq(i)=sog
                                          endif
                      else
                        qq(i)=sqrt(x(4,i)/rife)*sog
                      endif
      nz(i)=iabs(nz(i)/100)
      if (kfrag.ne.0.and.mode.eq.2) go to 102
      q(i)=fvar(i)
      x(5,i)=x(5,i)*qq(i)*q(i)
      if (nz(i).gt.0) nz(i)=nk
Corig sogz=x(5,i)*no(nk)

      sogz=qq(i)*q(i)*no(nk)

      if (sogz.lt.1.0) then
                         nz(i)=0
                         if (iprin.gt.2) write(lo,101) 
     *                       i,occsav(i),x(4,i),q(i),qq(i),sog,sogz
                       endif
  101 format(' atom ',i3,' rejected',6f10.5)
  102 continue
      call pkl15(nats)
      nlsm=1
      iref=0
      call sftryyy(iref,mode,nlsm,numb,ep,scalan)
      do 300 i=1,nats
      if (nz(i).ne.0) nz(i)=nzsav(i)
      x(5,i)=occsav(i)
  300 continue    
      interp=1
      call frm15(nats,numset,interp)
c
c-- plot
c
      mode1=mode-1
      call scrf(numset,mode1,1)
c
      return
      end
c---------------------------------------------------------------------
      subroutine sftrb(mode,numb,ep)
c     structure factor and phases for fourier refinement 
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nat,f(9),nalf(8)
      common/rc/p(6),cx(9),nref,nb,rhomax,mm,en,mz,er,th,rhomin
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      common/c/flgw(30),flgd(30),avr(30),dcv(50),slope,flgk,bt,sc,del,ks
      common /erl/ kmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)
     5,icopk(9),icoel(9),icogr(500)
      common/xdata/ ihkl(31000),e(31000),iphaz(31000),iphb(31000)
     *             ,wt(31000),nzsav(500),occsav(500),
     *              fvar(500),q(500),qq(500),dummy(2500)
     *              ,dummpc(84000)
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      integer izpk(500)
      dimension vet(8),ivet(8)
      dimension ep(31000)
      equivalence(vet,ivet)
c
      coef=1.35
      coefr=1.0/3.0
      call ysfl07(nrifl,nstr,mmmz,npseud,iy)
c
      delta=1.0/12.0
c-- compute the numer of peaks to consider
      totop=(icent+1)*nsym*pts
      jlig=1
      if (no(1).eq.1) jlig=2
      anat=0.0
      do 12 i=jlig,nk
   12 anat=anat+float(nw(i))
c
c-- azzero il vettore contenente un flag (0=atomo escluso,1=preso)
c
      sum=0.0
      nne=0.0
      do 99 i=1,nats
      if (krecy.ge.1) nz(i)=jlig*100+1
      if (nz(i).eq.0) go to 99
      if (sum.le.anat) then
                         occ=x(5,i)
                         sum=sum+occ*totop
                         if ((sum-anat).lt.delta) nne=nne+1
                      endif
   99 continue
      jnats=0
      j=nats
      do 991 i=1,nats
      if (nz(i).eq.0) go to 991
      if (jnats.ge.nne) go to 991
      j=i
      jnats=jnats+1
  991 continue
      nne=j
      call label(nne)
      call muovi
      if (krecy.ne.1) call assbty
      hei=x(4,nne)
      kzo=iabs(nz(nne)/100)
      sum=1.0
      do 97 i=1,nne-1
      if(sum.gt.2.5) go to 992
      j=nne-i
      kz=iabs(nz(j)/100)
      if (kz.eq.kzo) then
                       hei=hei+x(4,j)
                       sum=sum+1.0
                     endif
   97 continue
  992 continue
      hei=sum/hei
c
      do 98 i=1,nats
      nzsav(i)=nz(i)
      occsav(i)=x(5,i)
      if (nz(i).eq.0) go to 98
      xleg=1.000
      if (i.le.nne) then
                      ww=1.00
                      wws=1.00
                    else
                      ww=x(4,i)*hei*erre**coefr
                      wws=ww*xleg
Corig                 if (wws.le.0.2) then
                      if (wws.le.0.3) then
                                        ww=0.0
                                        nz(i)=0
                                      endif
                    endif
      x(5,i)=x(5,i)*xleg*ww
      nz(i)=iabs(nz(i)/100)
      if (iprin.gt.1) then
      if(nz(i).gt.0) then
      write(lo,9999) i,nalf(nz(i)),x(4,i),xleg,hei,erre*100.0,
     *              coefr,ww,occsav(i),x(5,i),wws
                      else
      write(lo,9998) i,x(4,i),xleg,hei,erre*100.0,
     *              coefr,ww,occsav(i),x(5,i),wws
                      endif
                      endif
   98 continue
 9999 format(i4,1h),2x,a2,2x,f8.1,4f10.3,f10.8,f6.2,f8.4,3f8.4)
 9998 format(i4,1h),6x,f8.1,4f10.3,f10.8,f6.2,f8.4,3f8.4)
c
      call pkl15(nats)
      nlsm=7
      iref=3
      call sftryyy(iref,mode,nlsm,numb,ep,scalan)
      do 300 i=1,nats
      kfrag=mod(nzsav(i),100)
      if (nzsav(i).gt.0) then
                           isg=1
                         else
                           isg=-1
                         endif
      if (nz(i).ne.0) nz(i)=isg*(nz(i)*100+kfrag)
      x(5,i)=occsav(i)
  300 continue    
c--- bisogna riassemblare la molecola.
      kact=5
      call maincl(izpk,kact,iprin)
c
      maxcyc=mode-1
      interp=1
      call frm15(nats,numset,interp)
c
c-- plot
c
      mode1=mode-1
      call scrf(numset,mode1,2)
      return
      end
c---------------------------------------------------------------------
      subroutine label(nne)
c
c-- subroutine to re-label peaks according only to
c-- the relative peak height and to the cell content
c-- if jall = 0 only heavy atoms (z=>11) are labelled
c-- if jall = 1 all atoms are labelled
c
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common /atoms/ x(5,200),nz(200),idumx(21)
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common /xdata/ ihkl(31000),e(31000),iphaz(31000),iphb(31000)
     *              ,wt(31000),izpk(500),duma(4500)
     *              ,dummpc(84000)
c-- nw(i) = number of atoms of the i-th specie
c-- no(i) = Z of atom of the i-th specie
c-- nkl   = number of non-hydrogen species
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nat,f(9),nalf(8)
c
      dimension number(8,2)
C
      rap1s=0.6
      rap2s=1.4
      if (erre.lt.0.2) then
                         rap1s=0.4
                         rap2s=10000
                       endif
      do 100 i=1,nne 
      if (nz(i).eq.0) then
                        izpk(i)=0
                      else
                        izpki=iabs(nz(i))/100
                        izpk(i)=nk-izpki+1
                      endif
  100 continue
      jall=1
      t2=(icent+1)*nsym*pts
      jlig=0
      if (no(1).eq.1) jlig=1
c--NEW
      nkl=nk-jlig
c--NEW
      j=nk+1
      do 1000 i=1,nk
      j=j-1
      number(i,1)=nw(j)
      kz=no(j)
      if (kz.gt.1 ) then
                      number(i,2)=kz
                    else
                      number(i,2)=0
                    endif
 1000 continue
c
      k=1
      heig1=x(4,1)
      z1  =float(number(1,2))
c
      do 1100 i=1,nne 
      if(izpk(i).eq.0) go to 1100
c
      do 1090 j=1,nkl
      if (number(j,1).eq.0) go to 1090
      k=j
      lasth=i-1
      numb=nint(x(5,i)*t2)
 1120 number(k,1)=number(k,1)-numb
      kz=number(k,2)
      heign=x(4,i)
      zn  =float(number(k,2))
      if (jall.eq.0.and.kz.lt.11) go to 1400
      if (number(k,1).ge.0) then
         rap=heig1*zn/z1
         rap1=rap*rap1s
         rap2=rap*rap2s
         if ((heign.gt.rap1.and.heign.lt.rap2).or.kz.eq.0) then
Cnew     if ((heign.gt.rap1                  ).or.kz.eq.0) then
                                             izpk(i)=k
                                             if (number(k,1).eq.0) k=k+1
                                             go to 1100
                                              else
                                            number(k,1)=number(k,1)+numb
                                              endif
                            else
                              number(k,1)=number(k,1)+numb
                              k=k+1
                              if (k.le.nkl) then
                                             go to 1120
                                           else
                                             go to 1400
                                           endif
                            endif
 1090 continue
 1100 continue
      go to 1900
 1400 continue
 1900 continue
      do 2000 i=1,nne 
      if(izpk(i).eq.0) go to 2000
      if (nz(i).gt.0) then
                           isg=1
                         else
                           isg=-1
                         endif
      izpki=izpk(i)
      izpki=nk-izpki+1
      kfrag=mod(nz(i),100)
      nz(i)=isg*(izpki*100+kfrag)
 2000 continue
      return
      end
c---------------------------------------------------------------------
      subroutine pkl15(nats)
c
c-- deletes ghost peaks from atom list
c
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
c
      j=0
      do 200 i=1,nats
      if (nz(i).ne.0) j=j+1
  200 continue
      if (j.eq.0) return
      k=nemap(1)-j
      nemap(1)=j
      if (k.gt.0.and.iprin.gt.1) write(lo,*) k,' ghost(s) rejected'
      return
      end
c---------------------------------------------------------------------
      subroutine stopr(host,izpk,mode)
c
c-- terminates the recycling procedure
c
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      common /atomo/ xyzo(5,200),nzo(200),dold(400)
      common/sf/al(4,8),bs(4,8),cl(8),nnw(8),nno(8),nk,nat,f(9),nalf(8)
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      dimension izpk(500)
      character*80 host
c
      idisp=1
      call sfl15(nats,idisp,idumm,interp)
      iprsav=iprin
      if (iprin.eq.0) iprin=2
      do 100 i=1,nats
c
c
      nz(i) = iabs( nz(i) )
c
c
      nzo(i)=nz(i)
      do 100 j=1,4
      xyzo(j,i)=x(j,i)
  100 continue
      natsav=nats
      k=0
      do 200 i=nats,1,-1
      if (nz(i).ne.0) then
                        k=i
                        rife=x(4,i)
                        go to 210
                      endif
  200 continue
  210 continue
      rife=0.5*rife
      if (k.ne.0) then
                    iniz=k+1
                    do 300 i=iniz,nats
                    if (x(4,i).gt.rife) k=k+1
  300               continue
                    nats=k
                  endif
      kaction=4
      call maincl(izpk,kaction,iprin)
      do 500 i=1,nats
      izpki=izpk(i)
      if (izpki.gt.0) then
                        isg= 1
                      else
                        isg=-1
                        izpki=-izpki
                       endif
      kfrag=mod(izpki,100)
      if (kfrag.eq.99) kfrag=0
      if (nzo(i).ne.0) then
                         nzz=nzo(i)/100
                         nzz=nk-nzz+1
                         izpk(i)=nzz*100+kfrag
                         izpk(i)=isg*izpk(i)
                       endif
  500 continue
      if (natsav.gt.nats) then
                            do 510 i=nats+1,natsav
                            nz(i)=0
                            izpk(i)=-1
  510                       continue
                          endif
      nats=natsav
      krecy=2000
      kact=4
      call outpea(host,izpk,kact)
c
c-- prepare atom list for future use
c
      do 600 i=1,nats
      if (nzo(i).eq.0) nz(i)=0
  600 continue
      errem=erre
      interp=1
      call frm15(nats,numset,interp)
      mode=0
      iprin=iprsav
      return
      end
c--------------------------------------------------------------------------
      subroutine sftryyy(iref,mode,nlsm,numb,ep,scalan)
c----
c     structure factor least squares
c
c     iref = 0 only structure factor computation
c     iref = 1 only B has to be refined
c     iref = 2 only X's have to be refined
c     iref = 3 B and X's have to be refined

      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nat,f(9),nalf(8)
      common/rc/p(6),cx(9),nref,nb,rhomax,mm,en,mz,er,th,rhomin
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      common /atomo/ apd(4,200),bpd(4,200)
      common/c/flgw(30),flgd(30),avr(30),dcv(50),slope,flgk,bt,sc,del,ks
      common /erl/ kmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/xdata/ ihkl(31000),e(31000),iphaz(31000),iphb(31000)
     *      ,wt(31000),nzsav(500),occsav(500),hkle(4,24)
     *      ,deltaf(4,200),qvet(4,200),kcond(4,200),newvet(48,3)
     *      ,duma(1360)
     *      ,dummpc(84000)
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icett,
     *         kpol,jsyt,lat,indv(32),mpv(64),jspini,ddmin,ncawu,ncwu
      integer i1(3)
      dimension ep(31000),xo(11),xn(11),keyx(10)
      character jstep
c


      mode1=mode-1
      if (iref.ge.2) then
      iactn=2
      do 130 i=1,nats
         do 100 j=1,3
            xo(j)=x(j,i)
  100    continue
         k=kspecb(newvet,xo,xn,keyx,itype,iser,khead,iactn)
         iflk=0
         do 110 j=1,3
            ke=keyx(j)
            if (ke.ne.0.and.ke.ne.j) iflk=1
            kcond(j,i)=keyx(j)
  110    continue
         if (iflk.eq.1) then
             do 120 j=1,3
                kcond(j,i)=0
  120        continue
             endif
  130 continue
      if (kpol.ne.0) then 
                       jpol=kpol
                       i100=100
                       do 140 i=1,3
                       k=jpol/i100
                       if (k.ne.0) kcond(i,1)=0
                       jpol=jpol-k*i100
                       i100=i100/10
  140                  continue
                     endif
c
                   endif
c
c     if (krecy.le.1) oscale=1.0
      if (jrest.eq.0) then
      if (mode1.eq.1) oscale=1.0
                      endif
      uno=1
      gof=100.0
      gofold=gof
      gofsold=gof
      gofmin=0.5
      bt3=3.0*biso
      dump=0.5
      jlig=1
      if (no(1).eq.1) jlig=2
           if (iref.eq.1) then
                            k1=4
                            k2=4
                            jstep='B'
      else if (iref.eq.2) then
                            k1=1
                            k2=3
                            jstep='C'
      else if (iref.eq.3) then
                            k1=1
                            k2=4
                            jstep='B'
                          else
                            jstep='A'
                          endif
      if (iref.eq.1.or.iref.eq.3) then
                                    do 150 i=1,nats
                                    kcond(4,i)=1
  150                               continue
                                  endif
c
      jstop=0
      do 3000 nls=1,nlsm
      if (nls.eq.nlsm) iref=0
      scale=1.0/oscale
      if (gof.lt.gofmin) jstop=1
      if (jstop.eq.1.and.nls.ne.nlsm) go to 3000
      gof =0.0
      agof=0.0
      gofs=0.0
      sumfo=0.0
      sumfor=0.0
      sumfc=0.0
      sumdf=0.0
      bison=0.0
      bisod=0.0
      if (iref.ge.1) then
                       df1=0.0
                       df2=0.0
                       b11=0.0
                       b22=0.0
                       b12=0.0
                       do 200 jj=1,nats
                       do 200 k=k1,k2
                       deltaf(k,jj)=0.0
  200                  qvet(k,jj)=0.0
                     endif
      do 500 i=1,numb
      i1(1)=ihkl(i)/262144
      j=ihkl(i)-262144*i1(1)
      i1(2)=j/512-256
      i1(3)=j-512*(i1(2)+256)-256
c
c-- compute H*R and H*T
c
      do 250 j=1,nsym
      t=1000.0
      do 230 l=1,3
      t=t+float(i1(l))*tmat(j,l)
      hkle(l,j)=0
c------------
      do 240 k=1,3
  240 hkle(l,j)=hkle(l,j)+i1(k)*kmat(j,k,l)
c------------
  230 continue
      hkle(4,j)=t
  250 continue
      fo=e(i)
      rho=wt(i)
      act=0.0
      bct=0.0
      do 300 ij=1,nk
      f(ij)=cl(ij)
      do 300 ii=1,4
      f(ij)=f(ij)+al(ii,ij)*exp(-bs(ii,ij)*rho)
  300 continue
      if (iref.ge.1) then
                       do 350 jj=1,nats
                       do 350 k=k1,k2
                       apd(k,jj)=0.0
                       bpd(k,jj)=0.0
  350                  continue
                     endif
      do 400 jj=1,nats
      if (nz(jj).eq.0) go to 400
      kz=nz(jj)
      fkz=f(kz)
      arg=-bfac(jj)*rho
      effe=pts*fkz*exp(arg)
      tfocc=effe*x(5,jj)
      tfocp=tfocc*twopi*float(icent+1)
      call sfacyyy(hkle,jj,contc,conts,tfocp,iref,rho,kcond)
      contc=contc*tfocc
      conts=conts*tfocc
      act=act+contc
      bct=bct+conts
      if (kcond(4,jj).eq.1) then
                              apd(4,jj)=-rho*contc
                              bpd(4,jj)=-rho*conts
                            endif
  400 continue
      args=act*act+bct*bct
      if (args.gt.0.000001) then
                              fc=sqrt(args)
                              if(nls.eq.nlsm)
     *                        faze=rtod*atan2(bct,act)+360.0
                              ac=act/fc
                              bc=bct/fc
                            else
                              fc=0.0
                              if(nls.eq.nlsm)
     *                        faze=0.0
                              ac=0.0
                              bc=0.0
                            endif
      ep(i)=fc
      sumfor=sumfor+fo
      fo=fo*scale
      df=fo-fc
      sumfo=sumfo+fo
      sumfc=sumfc+fc
      sumdf=sumdf+abs(df)
      if (iref.ge.1) then
c
c--  accumulation of l.s. normal equations
c
                       fcs=fc*scale
                       sw=-rho*fc
                       b11=b11+fcs*fcs
                       b22=b22+sw *sw
                       b12=b12+fcs*sw
                       df1=df1+df*fcs
                       df2=df2+df*sw
                       do 450 jj=1,nats
                       do 450 k=k1,k2
                       if (kcond(k,jj).eq.0) go to 450
                       if (nz(jj).eq.0) go to 450
                       dfdb=apd(k,jj)*ac+bpd(k,jj)*bc
                       qvet(k,jj)=qvet(k,jj)+dfdb*dfdb
                       deltaf(k,jj)=deltaf(k,jj)+dfdb*df
  450                  continue
                     else
c
c-- compute stuff for fourier
c
                       iphap=mod(int(faze+0.5),360)
                       if(iphap.eq.0) iphap=360
                       iphb(i)=iphap
                     endif
  500 continue
c
c--  compute r-factor
c
      scalan=sumfc/sumfor
      ksca=0
      if (jrest.eq.0) then
                        if (krecy.eq.0) ksca=1
                      else
                        if (krecy.eq.1) ksca=1
                      endif
Corig if (krecy.eq.0) then
      if (ksca.eq.1) then
                        oscale=1.0/scalan
                        sumdf=0.0
                        sumfo=0.0
                        do 510 i=1,numb
                        sumdf=sumdf+abs(ep(i)-scalan*e(i))
                        sumfo=sumfo+scalan*e(i)
  510                   continue
                      endif
      erre=sumdf/sumfo
      rfac=100.0*erre
      if (iprin.gt.2) then
      write(lo,540) mode1,rfac,nemap(1),nemap(2),nemap(3),
     *              scale,gofold,gofsold,scalan,dg,biso,bt3
                      else
      if (iref.eq.0) write(lo,545) jstep,mode1,rfac
                      endif
  540 format(' cycle #',i3,' r-fac.=',f7.2,'%, ',
     *       i3,1h/,i3,1h/,i3,' atoms, ',7f9.4)
  545 format(25x,a1,i10,8x,f7.2,'%',4i5)
c
      if (iref.eq.0) go to 3000
c
c--  compute correction for scale factor
c
      denom =  b11 * b22 - b12 * b12        
      dbm=(b11*df2-b12*df1)/denom
      dbs=df2/b22
      dg =(b22*df1-b12*df2)/denom
      corr= dbm- dbs
c     
c--  compute new scale-factor
c
      oscale=oscale+dg
c
      nesub=nats-nemap(3)
      nrej=0
      do 600 jj=1,nats
      if (nz(jj).eq.0) go to 600
      kz=nz(jj)
      do 550 k=k1,k2
      if (kcond(k,jj).eq.0) go to 550
      shift=deltaf(k,jj)/qvet(k,jj)
      if (k.le.3) then
                    xnew=x(k,jj)+shift*dump
                    if (iprin.gt.2) write(lo,2000) nalf(nz(jj)),jj,
     *                x(k,jj),shift,xnew,deltaf(k,jj),qvet(k,jj),x(5,jj)
                    x(k,jj)=xnew
                  else
                    ashift=(shift+corr)*dump
                    bnew=bfac(jj)+ashift
                    if (iprin.gt.2) write(lo,2001) nalf(nz(jj)),jj,
     *                bfac(jj),shift,ashift,bnew,dbm,dbs,corr
c
c-- reset occupancy factor if thermal factor is negative
c
                    if (bnew.lt.0.0) bnew=0.1
c
c-- reject atom if thermal factor is too large
c
                    if (nls.gt.1) then
                        if (bnew.gt.bt3) then
                                   if (kz.eq.jlig.and.nesub.gt.0) then
                                                   nesub=nesub-1
                                                   nrej=nrej+1
                                                   nz(jj)=0
                                                 endif
                                         endif
                                  endif
                    if (nz(jj).ne.0) then
                                       bison=bison+bnew*no(nz(jj))
                                       bisod=bisod+no(nz(jj))
                                       gof=gof+abs(ashift)
                                       gofs=gofs+ashift
                                       agof=agof+1.0
                                     endif
                    bfac(jj)=bnew
                  endif
  550 continue
  600 continue
 2000 format(2x,a2,i3,3f10.5,2f12.1,f8.3)
 2001 format(2x,a2,i3,7f10.5)
      if (iref.eq.2) go to 3000
      gof =gof /agof
      gofs=gofs/agof
      if (nls.eq.1) gof=10+gof
      biso=bison/bisod
c
c     bt3=3.0*biso
c
      if (nrej.gt.0) call pkl15(nats)
      if (gof.gt.gofold) then
                           gofold=gof
                           gofsold=gofs
                           gof=0.0
                         else
                           gofold=gof
                           gofsold=gofs
                         endif
 3000 continue
c
c-- compute fourier coefficients and weights
c
      do 3015 i=1,numb
      fo=e(i)*scalan
      fc=ep(i)
c
c-- new: coeff.= 2 Fo - Fc
c--      weight= 1
c
      e(i)= 2.0*fo - fc
      ep(i)=1.0
 3015 continue
      return
      end
c------------------------------------------------------------
c     structure factor calculation
      subroutine sfacyyy(hkle,jj,contc,conts,tfocp,iref,rho,kcond)
c
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      common /atomo/ apd(4,200),bpd(4,200)
      common/trig/sint(450),pi,twopi,dtor,rtod
      dimension cost(360),hkle(4,24),kcond(4,200)
      equivalence (sint(91),cost(1))
c
      at=0.0
      bt=0.0
      do 1000 j=1,nsym
      arg=amod(hkle(1,j)*x(1,jj)
     *        +hkle(2,j)*x(2,jj)
     *        +hkle(3,j)*x(3,jj)
     *        +hkle(4,j),1.0)
      iarg=int(360.0*arg+0.5)+1
      if(iarg.eq.361) iarg=1
      at=at+cost(iarg)
      bt=bt+sint(iarg)
      if (iref.ge.2) then
                       do 900 k=1,3
                                 hkltf=hkle(k,j)*tfocp
                                 apd(k,jj)=apd(k,jj)-hkltf*sint(iarg)
                                 if (icent.eq.0) 
     *                           bpd(k,jj)=bpd(k,jj)+hkltf*cost(iarg)
  900                  continue
                     endif
 1000 continue
      if (icent.eq.0) then
                        contc=at
                        conts=bt
                      else
                        contc=2.0*at
                        conts=0.0
                      endif
      return
      end
c--------------------------------------------------------------------------
      subroutine assbty
c
c  assign to atoms the thermal factor list according to previous atom list
c
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nat,f(9),nalf(8)
      common/c/flgw(30),flgd(30),avr(30),dcv(50),slope,flgk,bt,sc,del,ks
      common/xdata/ ihkl(31000),e(31000),iphaz(31000),iphb(31000)
     *              ,wt(31000),nzsav(500),occsav(500),
     *               fvar(500),q(500),bnew(500),dummy(2500)
     *              ,dummpc(84000)
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      common /atomo/ xyzo(5,200),nzo(200),dold(400)
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent
     *        ,kpol,jsys,latx,indv(32),mpv(64),jspini,ddmin,ncawu,ncwu
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      dimension xn(3),xo(3),xeq(3),vet(2),s(3)
c
      idisp=1
      call sfl30(natso,idisp,idumm,interp)
              if (iprin.gt.2) then
      write(lo,*) ' vecchia lista '
      do 1 i=1,natso
      nzzo=iabs(nzo(i)/100)
      if (nzzo.eq.0) then
      write(lo,'(2x,2x,i5,f8.1,3f10.3)')
     *          i,xyzo(4,i),(xyzo(j,i),j=1,3)
                     else
      write(lo,'(2x,a2,i5,f8.1,3f10.3)')
     *          nalf(nzzo),i,xyzo(4,i),(xyzo(j,i),j=1,3)
                     endif
    1 continue
      write(lo,*) ' nuova lista '
                          endif
      do 5 j=1,nats
          if (iprin.gt.2) then
          nzzo=iabs(nz(j)/100)
          if (nzzo.gt.0) then
      write(lo,'(2x,a2,i5,f8.1,3f10.3)')
     *    nalf(nzzo),j,x(4,j),(x(k,j),k=1,3)
                         else
      write(lo,'(2x,2x,i5,f8.1,3f10.3)')
     *               j,x(4,j),(x(k,j),k=1,3)
                         endif
                          endif
      q(j)=0.0
   5  bnew(j)=biso
      vet(1)= 1.0
      vet(2)=-1.0
      ifin=icent+1
      do 100 i=1,natso
      if (nzo(i).eq.0) go to 100
      nzo(i)=iabs(nzo(i)/100)
      do 10 j=1,3
   10 xo(j)=xyzo(j,i)
      distm=9999
      jpunt=0
      do 90 j=1,nats
      if (nz(j).eq.0) go to 90
      if (q(j).gt.0.5) go to 90
      do 20 k=1,3
   20 xn(k)=x(k,j)
      do 50 kt=1,ncentr
        do 50 ifi=1,ifin
          coef=vet(ifi)
          do 50 k=1,noper
            call xequi(xo,k,coef,xeq,kt)
            call xdist(xn,xeq,d,s)
            if (d.lt.distm.and.d.lt.ddmin) then
                                             distm=d
                                             jpunt=j
                                           endif
   50 continue
   90 continue
c
      if (jpunt.ne.0) then
                        q(jpunt)=i
                        nzn=iabs(nz(jpunt)/100)
                        if (nzo(i).eq.nzn) then
                                             bnew(jpunt)=bfac(i)
                                           else
                                             z1=no(nzo(i))
                                             z2=no(nzn)
                                             bmod=bfac(i)*z1/z2
                                             bmod=(bmod+biso)/2.0
                                             bnew(jpunt)=bmod
c
c-- proviamo ad assegnare il b medio calcolato
c
                                             bnew(jpunt)=biso
c
              if (iprin.gt.2)
     *  write(lo,98) nalf(nzo(i)),i    ,z1,bfac(i),(xyzo(jj,i),jj=1,5),
     *               nalf(nzn)   ,jpunt,z2,bmod   ,(x(jj,jpunt),jj=1,5)
   98 format(' Era ',a2,i4,f5.0,f7.3,5f8.3,'  e sara'' ' ,
     *                       a2,i4,f5.0,f7.3,5f8.3)        
                                           endif
                      endif
c
  100 continue
      if (iprin.gt.2) then
      do 110 j=1,nats
      if (nz(j).eq.0) go to 110
      nzn=iabs(nz(j)/100)
      i=nint(q(j))
      if (i.gt.0) then
                    write(lo,92) nalf(nzn),j,(x(k,j),k=1,3),bnew(j),
     *                          nalf(nzo(i)),i,(xyzo(k,i),k=1,3),bfac(i)
                       else
                    write(lo,92) nalf(nzn),j,(x(k,j),k=1,3),bnew(j)
                       endif
  110 continue
                      endif
      do 120 j=1,nats
      bfac(j)=bnew(j)
c
c-- assign old coordinates to new peaks
c
      i=q(j)
      if (i.gt.0) then
                    do 115 jj=1,3
  115               x(jj,j)=xyzo(jj,i)
                    x(5,j)=xyzo(5,i)
                  endif
  120 continue
   92 format(2x,a2,i4,4f10.3,10x,a2,i4,4f10.3,10x)
      return
      end
c--------------------------------------------------------------------------
      subroutine muovi
c
c  assign to atoms the thermal factor list according to previous atom list
c
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nat,f(9),nalf(8)
      common/c/flgw(30),flgd(30),avr(30),dcv(50),slope,flgk,bt,sc,del,ks
      common/xdata/ ihkl(31000),e(31000),iphaz(31000),iphb(31000)
     *              ,wt(31000),nzsav(500),occsav(500),
     *               fvar(500),q(500),bnew(500),dummy(2500)
     *              ,dummpc(84000)
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      common /atomo/ xyzo(5,200),nzo(200),dold(400)
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent
     *        ,kpol,jsys,latx,indv(32),mpv(64),jspini,ddmin,ncawu,ncwu
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common/lst03/l3,m3,md3,n3,l3t,m3t,l3ti,m3ti,l3g,n3g,sys03
      common / data/  store (5000)
      dimension xn(3),xo(3),xeq(3),vet(2),s(3),radii(8)
      character*8 reject
c
c-- get informations about radii
c
      call yfl03
      m3=l3
      do 24  i= 1,n3
      radii(i) = store(m3+15)
      m3=m3+md3
   24 continue

c
      vet(1)= 1.0
      vet(2)=-1.0
      ifin=icent+1
      do 100 i=1,nats-1
      if (nz(i).eq.0) go to 100
      nzi=iabs(nz(i)/100)
      do 10 j=1,3
   10 xo(j)=x(j,i)
      distm=9999
      jpunt=0
      do 90 j=i+1,nats
      if (nz(j).eq.0) go to 90
      do 20 k=1,3
   20 xn(k)=x(k,j)
      do 50 kt=1,ncentr
        do 50 ifi=1,ifin
          coef=vet(ifi)
          do 50 k=1,noper
            call xequi(xo,k,coef,xeq,kt)
            call xdist(xn,xeq,d,s)
            if (d.lt.distm) then
                              distm=d
                              jpunt=j
                            endif
   50 continue
   90 continue
c
      if (jpunt.ne.0) then
                        nzj=iabs(nz(jpunt)/100)
                        reject='        '
                        drej=radii(nzi)+radii(nzj)-0.5
                        if (distm.lt.drej) then
                                             nz(jpunt)=0
                                             reject='rejected'
                                           endif
                      else
                      endif
      if (iprin.gt.0)
     *write(lo,91) nalf(nzi),i,nalf(nzj),jpunt,drej,distm,reject
   91 format(2(1h ,a2,i4),2f10.4,2x,a8)
c
  100 continue
      if (iprin.gt.0)
     *write(lo,'(5(i4,1h),i5,5x))') (i,nz(i),i=1,nats)
      return
      end
c--------------------------------------------------------------------------
CRYSTALS CODE FOR EXPORT
c------------------------------------------------------------------
c     prepare coordinate file to use in other programs
c           output code(jout)          meaning
c                        0             standard shelx output 
c                        1             standard crystals output
c
      subroutine export(ier)
      character cff
      character fname(9)*80,ext(9)*4,line*80
      common/dotdat/ fname,ext
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      common /comdir/ icomq(200,2),maxcom,ipcom,ipdir,icomat
      common /xdata/ store(244000)
      common /dd/ a2,b2,c2,ab,ac,bc,bterm,wscale
      common/c/flgw(30),flgd(30),avr(30),dcv(50),slope,flgk,bt,sc,del,ks
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
      common /atoms/ x(5,200),nz(200),idumx(21)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
*     common /misc/ t(3,3),dxmax(3),mconx,iwt,fom(11),ptss
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nasu,f(9),nalf(8)
*     common /tab3/ ijt(6,2),iit(6),numpr(29),ktlsq(28)
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent,
     *        kpol,jsys,lat,indv(32),mpv(64),jspini,dmins,ncawu,ncwu
      common/sym/isn(2,3,24),tsn(3,24),nnsym,pts,ksys,ncent,latt,s3s2,
     *          emme,s3s2p
      common/rc/p(6),cx(9),dumm(9)
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
*     dimension xo(11),xn(11),key(10),newvet(48,3)
c
      if (icomat.eq.1) then
                         write(cff,'(i1)') kff
                         write(lo,10) cff,itle
                       else
                         write(lo,15) itle
                       endif
c
      call lastplot(rfac)
c
      if (jrest.ne.0) then
                        lline=7
                        line(1:7)='restart'
                        call modque(line,lline)
                        return
                       endif
c
   10 format(///,a1 ,120('+'),//,
     1 39h SIR92 : Export routine                ,68x,14hRelease  93.02
     2 ,//,20x,20a4,/,1h ,120('+'),/)
   15 format(///,1h ,120('-'),/,
     1 39h SIR92 : Export routine                ,68x,14hRelease  93.02
     2 ,//,20x,20a4,//)
      call srlin (15,lsn,lixx,ljxx,lkxx,llxx)
      if(lixx.gt.0) then
                    call xspinb
                    idisp=1
                    call sfl15(nats,idisp,numset,interp)
                  else
                    write(lo,20)
                    ier=-1
                    return
                  endif
      call direxp(igraph,numset,kcompl,ier)
      if (ier.lt.0) return
  20  format(/,' *** error *** No coordinates in direct access file',/)
c----
      call srlin (7,lsn,lixx,ljxx,lkxx,llxx)
      if(lixx.gt.0) then
                      call ysfl07(nrifl,mmm,mmmz,npseud,iy)
                      bterm=bt
                      wscale=sc
                    else
                      write(lo,30)
                      ier=-1
                      return
                    endif
  30  format(/,' *** error *** No reflections in direct access file',/)
c-- if m.s.c. environment ..........(kenvir = 2)
c-- if enraf-nonius environment ....(kenvir = 1) 
      itype=0
      iform=1
      jop=jopen(jhost,fname(3),nlen,itype,iform,ierr)
      if (jop.lt.0) go to 9000
c
      rfac=errem*100.0
      if (rfac.gt.0.0) write(lo,35) nats,rfac,maxcyc
      if (kenvir.ne.0) then
                         if (kenvir.eq.1) then
                                            call outenr(izpk)
                                            write(lo,80) fname(3)
                                          endif
                         if (kenvir.eq.2) then
                                            call outmsc(izpk)
                                            write(lo,85) fname(3)
                                          endif
                       else
                         if (jout.ge.0) then
                       endif
c
      write(lo,40)
      if (jout.eq.0) then
                        call outshe
                        write(lo,70) fname(3)
                     else
                        call outcry(kcompl)
                        write(lo,75) fname(3)
                     endif
      if (igraph.eq.1) then
                         write(lo,50) fname(4)
                         call outmold
                       endif
      if (igraph.eq.2) then
                         write(lo,60) fname(4)
                         call outsha
                       endif
      if (igraph.eq.3) then
                         write(lo,65) fname(4)
                         call outmolp
                       endif
      if (igraph.eq.4) then
                         write(lo,68) fname(4)
                         call outxyz
                       endif
                       endif
      return
c
   35 format(//,3x,'Final R value using',i4,' atoms is ',f7.2,'%',
     *             '  after ',i2,'  cycles.')
   40 format(///,'   Atoms informations files produced:',//,
     *           '   Format        File Name ',/)
   50 format(    '   MOLDRAW       ',a)
   60 format(    '   SCHAKAL       ',a)
   65 format(    '   MOLPLO        ',a)
   68 format(    '   Cartesian     ',a)
   70 format(    '   SHELX-92      ',a)
   75 format(    '   CRYSTALS      ',a)
   80 format(    '   MolEN         ',a)
   85 format(    '   TeXan         ',a)
 9000 write(lo,9010) ierr,fname(3)
 9010 format(' *** error ***  open error, code =',i5,' file is ',a)
      end
c
c---------------------------------------------------------------------
      subroutine direxp(igraph,numset,kcompl,ier)
      character line*80,dire*80,diret*80
      character blank,digit*12,card(100)*80,ffile*80
      common /comdir/ icomq(200,2),maxcom,ipcom,ipdir,icomat
      common /chara/ blank,digit,card,ffile
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      character fname(9)*80,ext(9)*4
      common/dotdat/ fname,ext
c 
c-- set default values
c
      kcompl=0
      igraph=3
      mset=numset
      ic=0
      icmax=icomq(icomat,2)
c
  100 continue
      ic=ic+1
      if (ic.gt.icmax) go to 8000
      ipdir=ipdir+1
      line=card(ipdir)
      diret=line
      call cutst(line,lenp,dire,lend)
      call lcase(dire)
c-- directives with alphanumeric parameters
      if (dire(1:4).eq.'crys') then
          jout=1
          if (lenp.gt.0) fname(3)=line
          go to 100
          endif
      if (dire(1:4).eq.'comp') then
          jout=1
          kcompl=1
          go to 100
          endif
      if (dire(1:4).eq.'shel') then
          jout=0
          if (lenp.gt.0) fname(3)=line
          go to 100
          endif
      if (dire(1:4).eq.'texa') then
          jout=-1
          kenvir= 2
          if (lenp.gt.0) fname(3)=line
          go to 100
          endif
      if (dire(1:4).eq.'mole') then
          jout=-1
          kenvir= 1
          if (lenp.gt.0) fname(3)=line
          go to 100
          endif
      if (dire(1:4).eq.'mold') then
          igraph=1
          if (lenp.gt.0) fname(4)=line
          go to 100
          endif
      if (dire(1:4).eq.'scha') then
          igraph=2
          if (lenp.gt.0) fname(4)=line
          go to 100
          endif
      if (dire(1:4).eq.'molp') then
          igraph=3
          if (lenp.gt.0) fname(4)=line
          go to 100
          endif
      if (dire(1:3).eq.'xyz' ) then
          igraph=4
          if (lenp.gt.0) fname(4)=line
          go to 100
          endif
      ier=-1
      write(lo,'(22h error in directive : ,a80)') diret
 8000 continue
      return
      end
c-------------------------------------------------------------------
c-- crystals output 
c
      subroutine outcry(kcompl)
      character fname(9)*80,ext(9)*4
      common/dotdat/ fname,ext
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      common /atoms/ x(5,200),nz(200),idumx(21)
      common /xdata/ store(244000)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /misc/ t(3,3),dxmax(3),mconx,iwt,fom(11),pts
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent,
     *        kpol,jsys,lat,indv(32),mpv(64),jspini,dmins,ncawu,ncwu
      common /erl/ kmat(48,3,3),tmat(48,3),nt(16),lsys,ngen
     *,irot(48,48),kvet(10),jvet(8),nori,modul(3),nss(3)
      common/rc/p(6),cx(9),dumm(9)
      common/c/flgw(30),flgd(30),avr(30),dcv(50),slope,flgk,bt,sc,del,ks
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nasu,f(9),nalf(8)
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
c
      if (kcompl.eq.1) then
                         write(jhost,20) itle
                         write(jhost,30) (cx(i),i=1,6)
                         write(jhost,40) (nt(i),i=1,16)
                         write(jhost,50) (nalf(i),nw(i),i=1,nk)
                         write(jhost,60) fname(2)
                         rfac=errem*100.0
                         write(jhost,70) (itle(i),i=1,19),nats,
     *                                   numset,rfac,fosog
                       endif
   20 format('#title ',20a4)
   30 format('#quickstart ',/,'cell ',3f8.3,3f8.2)
   40 format('spacegroup ',16a1)
   50 format('content ',8(a2,i4,2x))
   60 format('file ',a,/,'format (3f4.0,2f8.2) ',/,'end')
   70 format('# ',19a4,/,'# number of atoms = ',i5,' for set no. ',i5,
     *'  final R value = ',f7.2,'%',
     *       /,'# ',/,'#list 28 ',/,'minima /fo/ = ',f10.3,/,'end ')
c
c-- crystals output  -  list 5
c
      write(jhost,80) 
   80 format('#list 5 ',/,
     *       'read natom = 0',/,
     *       'end',/,
     *       '#edit ')
      denom=8.0*pi*pi
      isel=0
      do 110 i=1,nats
      itp=iabs(nz(i)/100)
      if (itp.ne.0) then
                      itp=nalf(itp)
                      uiso=bfac(i)/denom
                      write(jhost,90) itp,i,x(5,i),uiso,(x(j,i),j=1,3)
                    else
                      isel=1
                      uiso=bt/denom
                      write(jhost,100) i,x(5,i),uiso,(x(j,i),j=1,3)
                    endif
   90 format('atom ',a2,i4,5x,5f10.4)
  100 format('atom q ', i4,5x,5f10.4)
  110 continue
      if (isel.eq.1) write(jhost,'(18hselect type ne q  )')
c
c-- crystals output  -  list 12
c
      if (kcompl.eq.1) write(jhost,120)
  120 format(3hend,/,8h#list 12,/,18hblock x's  u[iso]  )
      write(jhost,130)
  130 format('end ',/,'#use last')
      return
      end
c
c---------------------------------------------------------------------
c-- shelx output
      subroutine outshe
      character fmt*4,line*4,linl*80,xyz(3)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /atoms/ x(5,200),nz(200),idumx(21)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent,
     *        kpol,jsys,lat,indv(32),mpv(64),jspini,dmins,ncawu,ncwu
      common /erl/ kmat(48,3,3),tmat(48,3),nt(16),lsys,ngen
     *,irot(48,48),kvet(10),jvet(8),nori,modul(3),nss(3)
      common/rc/p(6),cx(9),dumm(9)
      common/c/flgw(30),flgd(30),avr(30),dcv(50),slope,flgk,bt,sc,del,ks
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nasu,f(9),nalf(8)
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      dimension x2(5),kpunt(8,2)
      dimension abc(3),ang(3),latsx(7)
      data xyz/'X','Y','Z'/
      data latsx / 1,5,6,7,2,4,3 /
c
c
      write(jhost,100) (itle(i),i=1,18)
  100 format('TITL    ',18a4)
      do 110 i=1,3
         abc(i)=cx(i)
         ang(i)=cx(i+3)
  110 continue
      ilat=latsx(lat)
      if (icent.eq.0) then
                        ilat=-ilat
                        nop2=noper
                      else
                        nop2=noper*2
                      endif
      wl=0.71069
      p005=0.005
      write(jhost,120) wl,abc,ang,nop2,(p005,i=1,6)
  120 format('CELL  ',f8.5,2x,6f9.3,/,
     *       'ZERR  ',i8,2x,6f9.3)
      write(jhost,130) ilat
  130 format('LATT ',2i2)
c
c procedura che scrive la parte relativa alla simmetria del file
c di input a shelx
      if (noper.gt.1) then
        do 170  k=2,noper
             linl(1:4)='SYMM' 
               do 140 i=5,80
  140             linl(i:i)=' '
               ip=6
               do 160 j=1,3
                 iplus=0
                 if (tmat(k,j).gt.0.001) then
                   write(linl(ip:),'(f8.5)') tmat(k,j)
                   ip=ip+8
                   iplus=1
                 endif
                 do 150 i=1,3
                   ii=kmat(k,j,i)
                   if (ii.ne.0) then
                     if (ii.lt.0) then
                         linl(ip:ip)='-'
                         ip=ip+1
                     else
                         if (iplus.eq.1) then
                           linl(ip:ip)='+'
                           ip=ip+1
                         endif
                     endif
                     write(linl(ip:ip),'(a1)') xyz(i)
                     ip=ip+1
                     iplus=1
                   endif
 150             continue
                 if (j.lt.3) then
                  write(linl(ip:ip),'(a1)') ','
                  ip=ip+1
                  iplus=0
                 endif
 160           continue
               write(jhost,'(a)') linl(1:79)
               ip=1
               iplus=0
 170  continue
      endif
      do 180 i=1,nk
      do 180 j=1,2
  180 kpunt(i,j)=0
      ish=0
      do 190 i=1,nk
      if (no(i).eq.6) then
                        ish=ish+1
                        kpunt(ish,1)=i
                        kpunt(i,2)=ish
                      endif
  190 continue
      do 200 i=1,nk
      if (no(i).eq.1) then
                        ish=ish+1
                        kpunt(ish,1)=i
                        kpunt(i,2)=ish
                      endif
  200 continue
      do 205 i=1,nk
      if (kpunt(i,1).eq.0) then
                             ish=ish+1
                             kpunt(ish,1)=i
                             kpunt(i,2)=ish
                           endif
  205 continue
      write(linl(1:38),210) (nalf(kpunt(i,1)),i=1,nk)
      call ucase(linl(1:38))
      write(jhost,'(a)') linl(1:38)
  210 format('SFAC  ',8(2x,a2))
      write(jhost,220) (nw(kpunt(i,1)),i=1,nk)
  220 format('UNIT  ',8i4)
      write(jhost,240)
  240 format('MERG      2',/,
     *       'OMIT      4',/,
     *       'L.S.      4',/,
     *       'LIST      1',/,
     *       'FMAP      2',/,
     *       'PLAN     25',/,
     *       'FVAR    1.0')
      denom=8.0*pi*pi
      do 260 i=1,nats
      izpki=iabs(nz(i))/100
      if (izpki.ne.0) then
                        izpki=kpunt(izpki,1)
                        izpk2=kpunt(izpki,2)
                        uiso=bfac(i)/denom
                        do 245 j=1,3
  245                   x2(j)=x(j,i)
                        write(line(1:2),270) nalf(izpk2)
                        line(3:4)='  '
                        x2(4)=x(5,i)+10.0
                        in=2
                        if (i.gt.99) in=3
                        write(fmt,280) in
                        write(line(5-in:4),fmt) i
                        do 250 j=1,4
                        if (line(j:j).eq.' ') line(j:j)='0'
  250                   continue
                        call ucase(line)
                        write(jhost,290) line,izpki,(x2(j),j=1,4),uiso
                      endif
  260 continue
  270 format(a2)
  280 format(2h(i,i1,1h))
  290 format(a4,i5,5f10.5)
      write(jhost,300)
  300 format('           ',/,
     *       'HKLF      4',/,
     *       'END        ')
      uiso=bt/denom
      do 360 i=1,nats
      izpki=iabs(nz(i))/100
      if (izpki.eq.0) then
                        izpki=1
                        do 345 j=1,3
  345                   x2(j)=x(j,i)
                        line(1:2)='Q '
                        line(3:4)='  '
                        x2(4)=x(5,i)+10.0
                        in=2
                        if (i.gt.99) in=3
                        write(fmt,280) in
                        write(line(5-in:4),fmt) i
                        do 350 j=1,4
                        if (line(j:j).eq.' ') line(j:j)='0'
  350                   continue
                        write(jhost,290) line,izpki,(x2(j),j=1,4),uiso
                      endif
  360 continue
      return
      end
c---------------------------------------------------------------------
c
c subroutine for m.s.c. environment
      subroutine outmsc(izpk)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common /impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      common /atoms/ x(5,200),nz(200),idumx(21)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nasu,f(9),nalf(8)
      dimension izpk(500)
   
      write(jhost,75)nats,numset,(kstory(i),i=1,5)
   75 format(20h SIR88 Release 93.02,i5,20h  peaks for set no. ,i5,5i5)
      do 80 i=1,nats
      kheig=nint(x(4,i))
      izpki=izpk(i)
      if (izpki.gt.0) 
     *write(jhost,78) nalf(izpki),i,
     *(x(j,i),j=1,3),kheig
   78 format(a2,i5,3f10.5,i7)
   80 continue
      return
      end
c
c---------------------------------------------------------------------
c-- subroutine for enraf-nonius environment .....
      subroutine outenr(izpk)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      common /atoms/ x(5,200),nz(200),idumx(21)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nasu,f(9),nalf(8)
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      dimension xo(11),xn(11),key(10),newvet(48,3),izpk(500)
c
      write(jhost,75)nats,numset
   75 format(20h SIR88 Release 93.02,i5,20h  peaks for set no. ,i5,5i5)
      denom=8.0*pi*pi
      do 90 i=1,nats
      do 81 j=1,3
   81 xo(j)=x(j,i)
      iser=i
      itype=nalf(izpk(i))
      if (itype.eq.0) go to 90
      k=kspecb(newvet,xo,xn,key,itype,iser,khead,iactn)
      occ=1.0/float(key(10))
      kheig=nint(x(4,i))
      izpki=izpk(i)
      uiso=bfac(i)/denom
      if (izpki.gt.0) 
     *   write(jhost,85) nalf(izpki),i,occ,uiso,
     *   (x(j,i),j=1,3),kheig,(key(j),j=1,9)
   85 format(1h ,a2,i3,5f8.5,i7,9i3)
   90 continue
      return
      end
c----------------------------------------------------------------------
c     prepare input file for MOLDRAW
c
      subroutine outmold
      character line*5,space*16
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      character fname(9)*80,ext(9)*4
      common/dotdat/ fname,ext
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /xdata/ store(160000),dummpc(84000)
      common /atoms/ x(5,200),nz(200),idumx(21)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/rc/p(6),cx(9),dumm(9)
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nasu,f(9),nalf(8)
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),lsys,ngen
     *,irot(48,48),kvet(10),jvet(8),nori,modul(3),nss(3)
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent,
     *        kpol,jsys,lat,indv(32),mpv(64),jspini,dmins,ncawu,ncwu
      dimension ivet(9)
      dimension istore(160000)
      equivalence (store(1),istore(1))
c
      itype=0
      iform=1
      jop=jopen(jgrap,fname(4),nlen,itype,iform,ier)
      if (jop.lt.0) go to 9000
      write(jgrap,1040) (itle(i),i=1,17),(cx(i),i=1,6)
 1040 format('TITLE',/,17a4,/,'CELL',/,6f10.3,/,'COSYMB')
      ind=1
      mdm=6
      do 1030 i=1,nats
      icveti=nz(i)
      if (nz(i).lt.0) then
                           kfrag=10000+i
                           icveti=0
                        else
                           kfrag=mod(icveti,100)*1000+i
                        endif
      iz=icveti/100
      istore(ind)=iz
      istore(ind+1)=i
      store(ind+2)=x(1,i)
      store(ind+3)=x(2,i)
      store(ind+4)=x(3,i)
      store(ind+5)=kfrag
      ind=ind+mdm
 1030 continue
      ind=1
      jump=6
      call sortz(ind,nats,mdm,jump)
      do 1100 i=1,nats
      do 1105 n=1,5
      line(n:n)=' '
 1105 continue
      if (istore(ind).ne.0) then
                               write(line(1:2),'(a2)') nalf(istore(ind))
                               call ucase(line)
                             else
                               line(1:1)='H'
                             endif
      write(line(3:5),'(i3)') istore(ind+1)
      call xcmprp(line,k)
      write(jgrap,1120) i,line,(store(ind+j),j=2,4)
 1120 format(i4,2x,a5,3f10.3)
      ind=ind+mdm
 1100 continue
      write(space,'(16a1)') nt
      call ucase(space)
      call xcmprp(space,k)
      write(jgrap,1110) space
 1110 format('   0  0         0         0         0',/,
     *       'GROUP',/,a16,/,'SYMNUM')
      iss=-1
      do 1180 ii=1,icent+1
      iss=-iss
      do 1170 k=1,noper
      l=0
      do 1160 i=1,3
      do 1160 j=1,3
      l=l+1
 1160 ivet(l)=nint(soper(i,j,k))*iss
      write(jgrap,1190) (soper(i,4,k),i=1,3),ivet
 1170 continue
 1180 continue
 1190 format(3f10.5,3(3i4,4x))
      write(jgrap,1200)
 1200 format('  -1.       -1.       -1.        0   0   0       0   0   0
     *       0   0   0 ')
      close (jgrap)
      return
 9000 write(lo,9010) ier,fname(4)
 9010 format(' *** error ***  open error, code =',i5,' file is ',a)
      return
      end
c-----------------------------------------------------------------------
c     prepare input file for MOLPLO
c
      subroutine outmolp
      character line*6, reticoli*7
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      character fname(9)*80,ext(9)*4
      common/dotdat/ fname,ext
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /atoms/ x(5,200),nz(200),idumx(21)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/rc/p(6),cx(9),dumm(9)
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nasu,f(9),nalf(8)
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),lsys,ngen
     *,irot(48,48),kvet(10),jvet(8),nori,modul(3),nss(3)
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent,
     *        kpol,jsys,lat,indv(32),mpv(64),jspini,dmins,ncawu,ncwu
      dimension ivet(9)
      common/lst03/l3,m3,md3,n3,l3t,m3t,l3ti,m3ti,l3g,n3g,sys03
      common / data/  store (5000)
      dimension radii(8)
c
      reticoli='pabcifr'
      call yfl03
      m3=l3
      do 24  i= 1,n3
      radii(i) = store(m3+15)
      m3=m3+md3
   24 continue
      if (no(1).eq.1) then
                        jlig=1
                      else
                        jlig=0
                      endif
c
      itype=0
      iform=1
      jop=jopen(jgrap,fname(4),nlen,itype,iform,ier)
      if (jop.lt.0) go to 9000
      write(jgrap,1040) (itle(i),i=1,20),(cx(i),i=1,6),nats
 1040 format(20a4,/,6f10.3,/,i5)
      ind=1
      mdm=6
      do 1030 i=1,nats
      icveti=iabs(nz(i))
      iz=icveti/100
      line(1:6)='      '
      if (iz.gt.0) then
          write(line(1:2),'(a2)') nalf(iz)
      else
          line(1:2)='Q '
      endif
      call ucase(line)
      write(line(3:5),'(i3)') i
      call xcmprp(line,k)
      if (iz.gt.0) then
          Bond=2*radii(iz)+0.3
          Radius=radii(iz) / 3.0
          iCol=iz - jlig
      else
          Bond=0.1
          Radius=0.1
          iCol=7
      endif
      line(6:6)=','
      write(jgrap,1120) line,(x(j,i),j=1,3),Bond,Radius,iCol
 1120 format(a6,5f10.5,i4)
 1030 continue
      write(jgrap,1130) noper*(icent+1)
 1130 format(i5)
      iss=-1
      do 1180 ii=1,icent+1
      iss=-iss
      do 1170 k=1,noper
      l=0
      do 1160 i=1,3
      do 1160 j=1,3
      l=l+1
 1160 ivet(l)=nint(soper(i,j,k))*iss
      write(jgrap,1190) (soper(i,4,k),i=1,3),ivet
 1170 continue
 1180 continue
 1190 format(3f10.5,3(3i4,4x))
      write(jgrap,2000) reticoli(lat:lat)
 2000 format(a1)
      close (jgrap)
      return
 9000 write(lo,9010) ier,fname(4)
 9010 format(' *** error ***  open error, code =',i5,' file is ',a)
      return
      end
c-----------------------------------------------------------------------
c     prepare input file for SCHAKAL
c
      subroutine outsha
      character line*5
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      character fname(9)*80,ext(9)*4
      common/dotdat/ fname,ext
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /data/ store(5000)
      common /atoms/ x(5,200),nz(200),idumx(21)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/rc/p(6),cx(9),dumm(9)
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nasu,f(9),nalf(8)
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),lsys,ngen
     *,irot(48,48),kvet(10),jvet(8),nori,modul(3),nss(3)
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent,
     *        kpol,jsys,lat,indv(32),mpv(64),jspini,dmins,ncawu,ncwu
      dimension ivet(12),vet(12)
      dimension istore(5000)
      equivalence (store(1),istore(1))
      equivalence (vet(1),ivet(1))
c
      itype=0
      iform=1
      jop=jopen(jgrap,fname(4),nlen,itype,iform,ier)
      if (jop.lt.0) go to 9000
      write(jgrap,1040) (itle(i),i=1,17),(cx(i),i=1,6)
 1040 format('TITLE',3x,17a4,/,'CELL',3x,6f10.3)
      ind=1
      mdm=6
      do 1030 i=1,nats
      icveti=nz(i)
      if (icveti.eq.0) go to 1030
      if (nz(i).le.0) icveti=0
      iz=icveti/100
      istore(ind)=iz
      istore(ind+1)=i
      store(ind+2)=x(1,i)
      store(ind+3)=x(2,i)
      store(ind+4)=x(3,i)
      do 1105 n=1,5
      line(n:n)=' '
 1105 continue
      if (icveti.gt.0) then
                         write(line(1:2),'(a2)') nalf(istore(ind))
                       else
                         write(line(1:2),'(2hH )') 
                       endif
      call ucase(line)
      write(line(3:5),'(i3)') istore(ind+1)
      call xcmprp(line,k)
      write(jgrap,1120) line,(store(ind+j),j=2,4)
 1120 format('ATOM',3x,a5,3f10.3)
      ind=ind+mdm
 1030 continue
      write(jgrap,'(a3)') 'END'
      close (jgrap)
      return
 9000 write(lo,9010) ier,fname(4)
 9010 format(' *** error ***  open error, code =',i5,' file is ',a)
      return
      end
c---------------------------------------------------------------------
c     prepare input file for XYZ
c
      subroutine outxyz
      character line*5
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      character fname(9)*80,ext(9)*4
      common/dotdat/ fname,ext
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /data/ store(5000)
      common /atoms/ x(5,200),nz(200),idumx(21)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/rc/p(6),cx(9),dumm(9)
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nasu,f(9),nalf(8)
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),lsys,ngen
     *,irot(48,48),kvet(10),jvet(8),nori,modul(3),nss(3)
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent,
     *        kpol,jsys,lat,indv(32),mpv(64),jspini,dmins,ncawu,ncwu
      dimension ivet(12),vet(12),amat(3,3),xyz(3),r(3)
      dimension istore(5000)
      equivalence (store(1),istore(1))
      equivalence (vet(1),ivet(1))
c
      itype=0
      iform=1
      jop=jopen(jgrap,fname(4),nlen,itype,iform,ier)
      if (jop.lt.0) go to 9000
      write(jgrap,100) nats,(itle(i),i=1,20)
  100 format(i5,/,20a4)
      alfa=cx(4)*dtor
      beta=cx(5)*dtor
      gamm=cx(6)*dtor
      a1=cos(alfa)
      a2=cos(beta)
      a3=cos(gamm)
      b1=sin(alfa)
      b2=sin(beta)
      b3=sin(gamm)
      amat(1,1) =  cx(1) * b2
      amat(1,2) = -cx(2) * b1 * a3
      amat(1,3) =  0.0
      amat(2,1) =  0.0
      amat(2,2) =  cx(2) * b1 * b3
      amat(2,3) =  0.0
      amat(3,1) =  cx(1) * a2
      amat(3,2) =  cx(2) * a1
      amat(3,3) =  cx(3)
      do 400 i=1,nats
      do 200 j=1,3
  200 r(j)=x(j,i)
      call molt1(amat,r,xyz)
      icveti=iabs(nz(i))/100
      if (icveti.eq.0) then
                          line(1:2)='q '
                        else
                          write(line(1:2),'(a2)') nalf(icveti)
                        endif
      call ucase(line(1:2))
      write(jgrap,300) line(1:2),(xyz(k),k=1,3)
  300 format(a2,3x,3f15.7)
  400 continue
      close (jgrap)
      return
 9000 write(lo,9010) ier,fname(4)
 9010 format(' *** error ***  open error, code =',i5,' file is ',a)
      return
      end
c---------------------------------------------------------------------
      subroutine modque(line,lline)
      character line*80
      character blank,digit*12,card(100)*80,ffile*80
      character beg,commen,allcom(25)*14
      common /comdir/ icomq(200,2),maxcom,ipcom,ipdir,icomat
      common /chara/ blank,digit,card,ffile
      common /charas/ beg,commen,allcom
c
      jfound=0
      do 10 i=1,25
      if (line(1:lline).eq.allcom(i)(1:lline)) jfound=i
   10 continue
      if (jfound.eq.0) stop 'Programming error #1'
      jline=3
      line(1:3)='end'
      jend=0
      do 20 i=1,25
      if (line(1:jline).eq.allcom(i)(1:jline)) jend=i
   20 continue
      jlast=0
      do 30 i=1,200
      if (icomq(i,1).eq.jend) jlast=i
   30 continue
      if (jlast.eq.0) stop 'Programming error #2'
      ncomm=jlast-icomat+1
      j=jlast
      do 40 i=1,ncomm
      icomq(j+1,1)=icomq(j,1)
      icomq(j+1,2)=icomq(j,2)
      j=j-1
   40 continue
      icomq(icomat,1)=jfound
      icomq(icomat,2)=0
      icomat=icomat-1
      ipcom = ipcom + 1
c
      return
      end
c------------------------------------------------------------------
      subroutine restar(ier)
CHANGE-RIC-OX-98: Declare host as a character variable.
      character*80 name, host
      character cff
c
      character blank,digit*12,card(100)*80,ffile*80
      common /chara/ blank,digit,card,ffile
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      common/inpcl/ntype,ttype(10,5),nprojx,nbond,dmaxi,radnew(8)
      common /xdata/ ihkl(31000),e(31000),iphaz(31000),iphb(31000)
     *              ,wt(31000),duma(5000),dummpc(84000)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /atoms/ x(5,200),nz(200),idumx(21)
      common /erl/ kmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isn(2,3,24),tsn(3,24),nnsym,pts,ksys,ncent,latt,s3s2,
     *          emme,s3s2p
      common /ureq1/ jpatt,jpunt(501),ksacc,jseteq,jumpp,jmpsie,nsec
      common /buffer/ ndel(200),niz(200),nop,dummr(114)
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      dimension izpk(500)
c
      nbond=1
      krecy=1
      write(cff,'(i1)') kff
      write(lo,10) cff,itle
   10 format(///,a1 ,120('+'),//,
     1 39h Restart routine                       ,68x,14hRelease  93.02
     2 ,//,20x,20a4)
c++++++
      itype=1
      iform=2
      jop=jopen(jrel ,name,nlen,itype,iform,ier)
      if (jop.lt.0) go to 9000
      jop=jopen(ifour,name,nlen,itype,iform,ier)
      if (jop.lt.0) go to 9010
c
      call dirres(jcompl,ier)
      if (ier.lt.0) return
      erreo=errem
      if (jrest.eq.0) then
                        call change0(ier)
                        if (ier.lt.0) return
                        call change1(ier)
                        if (ier.lt.0) return
                      endif
c
      numb2=0
      istop=0
      jrest=max0(jrest,jcompl)
      erreo = errem
      if (jrest.eq.1) then
                        modef = maxcyc + 3
                      else 
                        modef = maxcyc + 50
                      endif 
      jrecyc = modef - 1
      do 200 mode=maxcyc+2,modef
           if (istop.eq.1) go to 200
           if (mode.eq.modef) istop=1
           call defco(nsize)
           call fft(numb2,mode,anat,ccfom,nsize,ier)
           if (ier.ne.0) istop=1 
  200 continue
      if (ier.lt.0) return
c
c-- stop recycling
c
      call stopr(host,izpk,mode)
c
      if (ier.lt.0) return
      close(jrel )
      close(ifour)
      return
 9000 continue
      write(lo,9020) ier,jrel
      ier=-1
      return
 9010 continue
      write(lo,9030) ier,ifour
      ier=-1
 9020 format(' *** error ***  open error on scratch file jrel, code ='
     *,i5,',  channel =',i5)
 9030 format(' *** error ***  open error on scratch file ifour, code ='
     *,i5,',  channel =',i5)
      return
      end
c----------------------------------------------------------------------
      subroutine dirres(jcompl,ier)
      character line*80,dire*80,diret*80
      character blank,digit*12,card(100)*80,ffile*80
      common /comdir/ icomq(200,2),maxcom,ipcom,ipdir,icomat
      common /chara/ blank,digit,card,ffile
      common /tran/ scale,mh(3),level,it4,xlim(3)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common /ureq1/ jpatt,jpunt(501),ksacc,jseteq,jumpp,jmpsie,nsec
      common /buffer/ ndel(200),niz(200),nop,dummr(114)
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
c-- set default values
c
      jcompl=0
      nsec=1
      jmpsie=1
      jpatt=0
      npc=0
      factr= 1.0/3.0
      it4=0
      level = 100
      xlim(1)=1.0
      xlim(2)=1.0
      xlim(3)=1.0
      do 10 i=1,200
      ndel(i) = 0
      niz (i) = 0
   10 continue
      call sfl15(nats,idisp,idumm,interp)
c
      ic=0
      icmax=icomq(icomat,2)
c
  100 continue
      ic=ic+1
      if (ic.gt.icmax) go to 8000
      ipdir=ipdir+1
      line=card(ipdir)
      diret=line
      call lcase(line)
      call cutst(line,lenp,dire,lend)
      if (dire(1:3).eq.'com') then
          jcompl=2
          go to 100
          endif
      if (dire(1:3).eq.'pri') then
          iprin=4
          go to 100
          endif
      if (dire(1:3).eq.'del') then
          kjump=0
          call getcod(line,ncod,iz,kjump,ier) 
          if (ier.lt.0) go to 9000
          ndel(ncod)=-1
          niz (ncod)=iz
          jrest=0
          go to 100
          endif
      if (dire(1:3).eq.'ren'.or.dire(1:3).eq.'rel') then
          kjump=0
          call getcod(line,ncod,iz,kjump,ier)
          if (ier.lt.0) go to 9000
          niz (ncod)=iz
          kjump=1
          call getcod(line,ncod,iz,kjump,ier)
          if (ier.lt.0) go to 9000
          ndel(ncod)=iz
          jrest=0
          go to 100
          endif
      write(lo,6500) diret
 6500 format(' wrong directive on following line:',/a)
      ier=-1
      return
 8000 continue
      return
 9000 continue
      ier=-1
      write(lo,'(22h error in directive : ,a80)') diret
      return
      end
c----------------------------------------------------------------------
      subroutine getcod(line,ncod,iz,kjump,ier)
      character line*80,dire*80,buf1*2,buf2*2
      character blank,digit*12,card(100)*80,ffile*80
      common /chara/ blank,digit,card,ffile
      common /atoms/ x(5,200),nz(200),idumx(21)
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,kat,f(9),nalf(8)
      dimension vet(40),ivet(40)
c
      call lcase(line)
      call cutst(line,lenp,dire,lend)
c
      j=2
      do 10 i=1,10
      if (digit(i:i).eq.dire(2:2)) j=1
   10 continue
      buf2(1:2)=blank//blank
      buf2(1:j)=dire(1:j)
      iz=0
      do 20 i=1,nk
      write(buf1,'(a2)') nalf(i)
      if (buf1.eq.buf2) iz=i
   20 continue
      if (iz.eq.0) then
                     if (buf2(1:1).eq.'q') then
                                             iz=9
                                           else
                                             ier=-1
                                           endif
                   endif
      if (kjump.eq.0) then
                        do 30 i=1,j
                        dire(i:i)=blank
   30                   continue
                        call shift(dire,lend)
                        iopt=0
                        call getnum(dire,vet,ivet,iv,iopt)
                        if (iopt.eq.-1.or.iv.eq.0) ier=-1
                        ncod=ivet(1)
                      endif
c
      return
      end
c----------------------------------------------------------------------
      subroutine change0(ier)
      character buf1*2,buf2*2,buf3*2
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common /atoms/ x(5,200),nz(200),idumx(21)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,kat,f(9),nalf(8)
      common /buffer/ ndel(200),niz(200),nop,dummr(114)
c
      nchange=0
      do 100 i=1,nats
      if (ndel(i).lt.0) then
         iz=iabs(nz(i)/100)
         iz1=niz(i)
         if (iz.eq.0) then
                        iz=9
                        buf1(1:2)='q '
                      else
                        write(buf1,'(a2)') nalf(iz)
                      endif
         if (iz1.eq.9) then
                        buf2(1:2)='q '
                      else
                        write(buf2,'(a2)') nalf(iz1)
                      endif
         call ucase(buf1(1:1))
         call ucase(buf2(1:1))
         if (iz.eq.iz1) then
                           nchange=nchange+1
                           write(lo,800) buf2,i
                         else
                           ndel(i)=0
                           write(lo,810) buf2,i
                         endif
                        endif
  100 continue
      do 200 i=1,nats
      if (ndel(i).gt.0) then
         iz=iabs(nz(i)/100)
         iz1=niz(i)
         iz2=ndel(i)
         if (iz.eq.0) then
                        iz=9
                        buf1(1:2)='q '
                      else
                        write(buf1,'(a2)') nalf(iz)
                      endif
         if (iz1.eq.9) then
                        buf2(1:2)='q '
                      else
                        write(buf2,'(a2)') nalf(iz1)
                      endif
         write(buf3,'(a2)') nalf(iz2)
         call ucase(buf1(1:1))
         call ucase(buf2(1:1))
         call ucase(buf3(1:1))
         if (iz.eq.iz1.or.iz.eq.9) then
                          nchange=nchange+1
                          write(lo,820) buf2,i,buf3,i
                        else
                          ndel(i)=0
                          write(lo,830) buf2,i
                        endif
                        endif
  200 continue
      if (nchange.eq.0) write(lo,900)
  800 format('     Atom ',a2,i3,' has been deleted')
  810 format(' *** Atom ',a2,i3,' does not exist. Cannot be deleted')
  820 format('     Atom ',a2,i3,' has been renamed as ',a2,i3)
  830 format(' *** Atom ',a2,i3,' does not exist. Cannot be renamed')
  900 format(//,' *** warning *** No changes applied to atom list',//)
c
      return
      end
c----------------------------------------------------------------------
      subroutine change1(ier)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common /atoms/ x(5,200),nz(200),idumx(21)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,kat,f(9),nalf(8)
      common /buffer/ ndel(200),niz(200),nop,dummr(114)
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
c
      j=0
      do 100 i=1,nats
      nd=ndel(i)
      if (nd.ge.0) then
                     j=j+1
                     do 10 k=1,5
   10                x(k,j)=x(k,i)
                     bfac(j)=bfac(i)
                     if (nd.gt.0) then
                                    nz(j)=ndel(i)*100+1
                                  else
                                    nz(j)=nz(i)
                                  endif
                   endif
  100 continue
      nats=j
      interp=0
      jrest=1
      call frm15(nats,numset,interp)
      call cp1530
c
      return
      end
c---------------------------------------------------------------------
      subroutine sftrc(mode,numb,ep)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nat,f(9),nalf(8)
      common/rc/p(6),cx(9),nref,nb,rhomax,mm,en,mz,er,th,rhomin
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      common /atomo/ xyzo(5,200),nzo(200),bold(400)
      common/c/flgw(30),flgd(30),avr(30),dcv(50),slope,flgk,bt,sc,del,ks
      common /erl/ kmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/xbuil/ift1,ift2,ift3,nfl,npeahi,ngrup,nfrag,ngh,ngl
     1,dmax,dmin,g(18),dmn(9),dmx(9),dmnmx(9,9,2),angi(3),angs(3)
     2,l3dum,md,lclus,mclus,laddr,ldis,mddis,lang,lnegl,mnegl,nnegl
     3,ladcon,lcon,mcon,ncon,mdcon,ladinc,linc,minc,mdinc
     4,ive(9),ive3i(9),ive3s(9),ive15i(9),ive15s(9)
     5,icopk(9),icoel(9),icogr(500)
      common/xdata/ ihkl(31000),e(31000),iphaz(31000),iphb(31000)
     *             ,wt(31000),nzsav(500),occsav(500),
     *              fvar(500),q(500),qq(500),dummy(2500)
     *              ,dummpc(84000)
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      integer izpk(500)
      dimension vet(8),ivet(8)
      dimension ep(31000)
      equivalence(vet,ivet)
c
      coef=1.35
      coefr=1.0/3.0
      call ysfl07(nrifl,nstr,mmmz,npseud,iy)
c
      delta=1.0/12.0
c-- compute the numer of peaks to consider
      totop=(icent+1)*nsym*pts
      jlig=1
      if (no(1).eq.1) jlig=2
      anat=0.0
      do 12 i=jlig,nk
   12 anat=anat+float(nw(i))
c
c-- azzero il vettore contenente un flag (0=atomo escluso,1=preso)
c
      sum=0.0
      nne=0.0
      do 99 i=1,nats
      if (sum.le.anat) then
                         occ=x(5,i)
                         sum=sum+occ*totop
                         if ((sum-anat).lt.delta) nne=nne+1
                      endif
   99 continue
      jnats=0
      j=nats
      do 991 i=1,nats
      if (jnats.ge.nne) go to 991
      j=i
      jnats=jnats+1
  991 continue
      nne=j
      if (krecy.ne.1) then
                        call assbtl
                        call labe2(nne)
                      endif
      hei=x(4,nne)
      kzo=iabs(nz(nne)/100)
      sum=1.0
      do 97 i=1,nne-1
      if(sum.gt.2.5) go to 992
      j=nne-i
      kz=iabs(nz(j)/100)
      if (kz.eq.kzo) then
                       hei=hei+x(4,j)
                       sum=sum+1.0
                     endif
   97 continue
  992 continue
      hei=sum/hei
c
      do 98 i=1,nats
      occsav(i)=x(5,i)
      xleg=1.000
      if (i.le.nne) then
                      ww=1.00
                      wws=1.00
                    else
                      ww=x(4,i)*hei*erre**coefr
                      wws=ww*xleg
                      if (wws.le.0.3) then
                                        ww=0.0
                                        nz(i)=0
                                      endif
                    endif
      x(5,i)=x(5,i)*xleg*ww
      nz(i)=iabs(nz(i)/100)
      nzsav(i)=nz(i)
      if (iprin.gt.1) then
      if(nz(i).gt.0) then
      write(lo,9999) i,nalf(nz(i)),x(4,i),xleg,hei,erre*100.0,
     *              coefr,ww,occsav(i),x(5,i),wws
                      else
      write(lo,9998) i,x(4,i),xleg,hei,erre*100.0,
     *              coefr,ww,occsav(i),x(5,i),wws
                      endif
                      endif
   98 continue
 9999 format(i4,1h),2x,a2,2x,f8.1,4f10.3,f10.8,f6.2,f8.4,3f8.4)
 9998 format(i4,1h),6x,f8.1,4f10.3,f10.8,f6.2,f8.4,3f8.4)
c
      call pkl15(nats)
      nlsm=7
      iref=3
      call sftryyy(iref,mode,nlsm,numb,ep,scalan)
c
      do 450 i=1,nats
      nz(i)=nz(i)*100
  450 continue    
      kact=5
      call maincl(izpk,kact,iprin)
c
      maxcyc=mode-1
      interp=1
      call frm15(nats,numset,interp)
c
c-- plot
c
      mode1=mode-1
      call scrf(numset,mode1,2)
      return
      end
c-----------------------------------------------------------------------
      subroutine assbtl
c
c-- assign to atoms the thermal factor and the atomic specie 
c-- according to previous atom list
c
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nat,f(9),nalf(8)
      common/c/flgw(30),flgd(30),avr(30),dcv(50),slope,flgk,bt,sc,del,ks
      common/xdata/ ihkl(31000),e(31000),iphaz(31000),iphb(31000)
     *              ,wt(31000),nzsav(500),occsav(500),
     *               fvar(500),q(500),bnew(500),dummy(2500)
     *              ,dummpc(84000)
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      common /atomo/ xyzo(5,200),nzo(200),dold(400)
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent
     *        ,kpol,jsys,latx,indv(32),mpv(64),jspini,ddmin,ncawu,ncwu
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      dimension xn(3),xo(3),xeq(3),vet(2),s(3)
c
      iprsav = iprin 
      idisp=1
      call sfl30(natso,idisp,idumm,interp)
              if (iprin.gt.2) then
      write(lo,*) ' vecchia lista '
      do 1 i=1,natso
      nzzo=iabs(nzo(i)/100)
      if (nzzo.eq.0) then
      write(lo,'(2x,2x,i5,f8.1,3f10.3)')
     *          i,xyzo(4,i),(xyzo(j,i),j=1,3)
                     else
      write(lo,'(2x,a2,i5,f8.1,3f10.3)')
     *          nalf(nzzo),i,xyzo(4,i),(xyzo(j,i),j=1,3)
                     endif
    1 continue
      write(lo,*) ' nuova lista '
                          endif
      do 5 j=1,nats
          if (iprin.gt.2) then
          nzzo=iabs(nz(j)/100)
          if (nzzo.gt.0) then
      write(lo,'(2x,a2,i5,f8.1,3f10.3)')
     *    nalf(nzzo),j,x(4,j),(x(k,j),k=1,3)
                         else
      write(lo,'(2x,2x,i5,f8.1,3f10.3)')
     *               j,x(4,j),(x(k,j),k=1,3)
                         endif
                          endif
      q(j)=0.0
   5  bnew(j)=biso
      vet(1)= 1.0
      vet(2)=-1.0
      ifin=icent+1
      do 100 i=1,natso
      if (nzo(i).eq.0) go to 100
      nzo(i)=iabs(nzo(i)/100)
      do 10 j=1,3
   10 xo(j)=xyzo(j,i)
      distm=9999
      jpunt=0
      do 90 j=1,nats
      if (q(j).gt.0.5) go to 90
      do 20 k=1,3
   20 xn(k)=x(k,j)
      do 50 kt=1,ncentr
        do 50 ifi=1,ifin
          coef=vet(ifi)
          do 50 k=1,noper
            call xequi(xo,k,coef,xeq,kt)
            call xdist(xn,xeq,d,s)
            if (d.lt.distm.and.d.lt.ddmin) then
                                             distm=d
                                             jpunt=j
                                           endif
   50 continue
   90 continue
c
      if (jpunt.ne.0) then
                        q(jpunt)=i
                        nzn=iabs(nz(jpunt)/100)
                        bnew(jpunt)=bfac(i)
                        nz(jpunt)=nzo(i)
                      endif
c
  100 continue
      if (iprin.gt.2) then
      do 110 j=1,nats
      if (nz(j).eq.0) go to 110
      nzn=iabs(nz(j))
      i=nint(q(j))
      if (i.gt.0) then
                    write(lo,92) nalf(nzn),j,(x(k,j),k=1,3),bnew(j),
c    *                          nalf(nzo(i)),i,(xyzo(k,i),k=1,3),bfac(i)
     *                               nzo(i),i,(xyzo(k,i),k=1,3),bfac(i)
                       else
                    write(lo,92) nalf(nzn),j,(x(k,j),k=1,3),bnew(j)
                       endif
  110 continue
                      endif
      do 120 j=1,nats
      bfac(j)=bnew(j)
c
c-- assign old coordinates to new peaks
c
      i=q(j)
      if (i.gt.0) then
                    do 115 jj=1,3
  115               x(jj,j)=xyzo(jj,i)
                    x(5,j)=xyzo(5,i)
                  endif
  120 continue
c  92 format(2x,a2,i4,4f10.3,10x,a2,i4,4f10.3,10x)
   92 format(2x,a2,i4,4f10.3,10x,' nalf(',i2,')',i4,4f10.3,10x)
      iprin = iprsav 
      return
      end
c--------------------------------------------------------------------------
      subroutine labe2(nne)
c
c-- subroutine to label peaks according only to
c-- the relative peak height and to the cell content
c-- ( only those atoms not previously labelled )
c
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common /atoms/ x(5,200),nz(200),idumx(21)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common /xdata/ ihkl(31000),e(31000),iphaz(31000),iphb(31000)
     *              ,wt(31000),izpk(500),duma(4500)
     *              ,dummpc(84000)
c-- nw(i) = number of atoms of the i-th specie
c-- no(i) = Z of atom of the i-th specie
c-- nkl   = number of non-hydrogen species
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nat,f(9),nalf(8)
c
      dimension number(8,2)
C
      do 100 i=1,nne 
      if (nz(i).eq.0) then
                        izpk(i)=0
                      else
                        izpk(i)=nk-nz(i)+1
                      endif
  100 continue
      jall=1
      t2=(icent+1)*nsym*pts
      jlig=0
      if (no(1).eq.1) jlig=1
c--NEW
      nkl=nk-jlig
c--NEW
      j=nk+1
      do 1000 i=1,nk
      j=j-1
      number(i,1)=nw(j)
      kz=no(j)
      if (kz.gt.1 ) then
                      number(i,2)=kz
                    else
                      number(i,2)=0
                    endif
 1000 continue
      do 1050 i=1,nne
      k=izpk(i)
      if (k.ne.0) then
                    numb=nint(x(5,i)*t2)
                    number(k,1)=number(k,1)-numb
                  endif
 1050 continue
c
      k=1
      heig1=x(4,1)
      z1  =float(number(1,2))
c
      do 1100 i=1,nne 
      if (izpk(i).ne.0) go to 1100
c
      do 1090 j=1,nkl
      if (number(j,1).eq.0) go to 1090
      k=j
      lasth=i-1
      numb=nint(x(5,i)*t2)
 1120 number(k,1)=number(k,1)-numb
      kz=number(k,2)
      heign=x(4,i)
      zn  =float(number(k,2))
      if (jall.eq.0.and.kz.lt.11) go to 1400
      if (number(k,1).ge.0) then
         rap=heig1*zn/z1
         rap1=rap*0.6
         rap2=rap*1.4
         if ((heign.gt.rap1.and.heign.lt.rap2).or.kz.eq.0) then
                                             izpk(i)=k
                                             if (number(k,1).eq.0) k=k+1
                                             go to 1100
                                              else
                                            number(k,1)=number(k,1)+numb
                                              endif
                            else
                              number(k,1)=number(k,1)+numb
                              k=k+1
                              if (k.le.nkl) then
                                             go to 1120
                                           else
                                             go to 1400
                                           endif
                            endif
 1090 continue
 1100 continue
      go to 1900
 1400 continue
 1900 continue
      do 2000 i=1,nne 
      if (izpk(i).eq.0) then
                          nz(i)=(jlig+1)*100 + 1
                        else
                          nz(i)=(nk-izpk(i)+1)*100 + 1
                        endif
 2000 continue
      if (nne.lt.nats) then
                         do 2100 i=nne+1,nats
                         if (nz(i).eq.0) nz(i)=(jlig+1)*100 + 1
 2100                    continue
                       endif
c
      return
      end
c--------------------------------------------------------------------------
CRYSTALS CODE FOR FOURIER
c-- sir code for fourier                         Release 93.02
      subroutine fourie(host,ier)
      character*80 host,name
      character cff
c
c     *************************** exfft ********************************
c     fast fourier transform program   -    january  1980
c     modification of program by l. f. ten eyck
c     *************************** exfft ********************************
c     read output tape from multan and expand data to space group p1
c     before calling fourier transform routines
      common /misc/ t(3,3),dxmax(3),mconx,iwt,fom(11),pts
      common /xdata/ x(30000),dumm1(15000),dumm2(15000),dumd(100000),
     *               dummpc(84000)
      common /atoms/ xyz(5,200),icvet(200),idumx(21)
      common /atomo/ xyzo(5,200),nzo(200),dold(400)
      common /refl/ ih(100),g(2,100)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nat,f(9),nalf(8)
      common /kuse/ kuser1,kuser2,kuser3
      common /tran/ scale,mh(3),level,it4,xlim(3)
      common /tape/ cell(6),neqv,icent,lat,natm,ts(3,24),is(2,3,24),nsym
     *             ,dumb(3)
      common /sdir/ dm,npc,nproj,nojoin
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icentx
     *        ,kpol,jsys,latx,indv(32),mpv(64),jspini,ddmin,ncawu,ncwu
      common /dd/ a2,b2,c2,ab,ac,bc,bterm,wscale
      common/xfour/ itype,iprint,numero,iw,il  ,im  ,iv  ,ix
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
      common/inpcl/ntype,ttype(10,5),nprojx,nbond,dmaxi,radnew(8)
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common/c/flgw(30),flgd(30),avr(30),dcv(50),slope,flgk,bt,sc,del,ks
      dimension izpk(500)
c
      jrest = 0
      write(cff,'(i1)') kff
      write(lo,10) cff,itle
   10 format(///,a1 ,120('+'),//,
     1 39h fourier routine                       ,68x,14hRelease  93.02
     2 ,//,20x,20a4)
c
c     preliminary section        define all necessary program parameters
c
      itype=1
      iform=2
      jop=jopen(jrel ,name,nlen,itype,iform,ier)
      if (jop.lt.0) go to 9000
      jop=jopen(ifour,name,nlen,itype,iform,ier)
      if (jop.lt.0) go to 9010
c
      erreo=999999.9
      erre =1.0
      krecy=0
      call defco(nsize)
      call dirfou(jpfile,ier)
      if (ier.lt.0) return
      if (jpfile.eq.0) write(lo,20)
   20 format(1h ,120('+'),//,
     *       19x,'***  fast fourier transform section   ***',/)
      if (bt.lt.0.0) bt=0.1
      do 190 i=1,200
  190 bfac(i)=bt
      biso=bt
      iprint=iprin
      if (jpfile.ne.0) then
                         iprsav=iprin
                         if (iprin.eq.0) iprin=2
                         call getplt(jpfile,ier)
                         if (ier.lt.0) return
                         call xspinb
                         interp=0
                         if (nemap(4).gt.0) then
                                      kact=1
                                      call outpea(host,izpk,kact)
                                           interp=1
                                          endif
                         call frm15(nats,numset,interp)
                         iprin=iprsav
                         jrecyc=100
                       endif
c
c    mode = 1  primo calcolo fourier
c    mode = 2  secondo calcolo fourier
c    mode = 3  terzo   calcolo fourier
c
      numb2=0
      mode=1
      if (jrecyc.eq.0) then
                         erreo=-1.0
                         erre =-1.0
                       endif
      if (jrecyc.le.0) then
                         iprsav=iprin
                         if (iprin.eq.0) iprin=1
                         call fft(numb2,mode,anat,ccfom,nsize,ier)
                         if (ier.lt.0) return
                         kact=3
                         call outpea(host,izpk,kact)
                         interp=1
                         call frm15(nats,numset,interp)
                         if (jrecyc.lt.0) jrecyc = - jrecyc
                         iprin=iprsav
                       endif
      if (jrecyc.gt.0) then
                         call cp1530
                         modef=jrecyc+1
                         istop=-1
                         do 200 mode=2,modef
                            if (istop.eq.1) go to 200
                            if (mode.eq.modef) istop=1
                            call defco(nsize)
                            call fft(numb2,mode,anat,ccfom,nsize,ier)
                            if (ier.eq.0) then
                                      if (istop.eq.0) then
*                                                       kact=5
                                                      else
                                                        kact=2
                                      call outpea(host,izpk,kact)
                                                      endif
                                          interp=1
                                          call frm15(nats,numset,interp)
                       else if (ier.gt.0) then
                                          ier=0
                                          istop=istop+1
CCCCCCCC                                  if (istop.ne.1) then
                                          if (istop.eq.0) then
                                             iprsav=iprin
                                             if (iprin.eq.0) iprin=1
                                             kresav=krecy
                                             krecy=1000
                                      kact=3
                                      call outpea(host,izpk,kact)
                                             iprin=iprsav
                                             krecy=kresav
                                           else
                                           endif
                                        endif
  200                    continue
                         if (ier.lt.0) return
c
c-- stop recycling
c
                         call stopr(host,izpk,mode)
                       endif
      if (ier.lt.0) return
      close(jrel )
      close(ifour)
c--
      return
 9000 continue
      write(lo,9020) ier,jrel
      ier=-1
      return
 9010 continue
      write(lo,9030) ier,ifour
      ier=-1
 9020 format(' *** error ***  open error on scratch file jrel, code ='
     *,i5,',  channel =',i5)
 9030 format(' *** error ***  open error on scratch file ifour, code ='
     *,i5,',  channel =',i5)
      ier=-1
      return
      end
c     ----------------------------------------------------------------
      subroutine defco(nsize)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /kuse/ kuser1,kuser2,kuser3
      common /sdir/ dm,npc,nproj,nojoin
c     define constants
c     kuser1 = dimension of arrays ihkl,e,iphaz,ep = maximum number
c     of independent reflections which can be input  (kuser1 .ge. numb)
c     dimension of x = 3 * kuser1
      kuser1 = 10000
corig nsize = 3 * kuser1 - 1
      nsize = 160000
c     kuser2 = maximum number of peaks to be found + 20, also maximum
c     number of peaks for interpretation and dimension of several arrays
      kuser2 = 200
c     kuser3 = size of array nstore for storing 3 sections of e-map
      kuser3 = 159856
c     if 2 e-map peaks are closer than dm the smaller is eliminated
      dm=0.85
      return
      end
c     ----------------------------------------------------------------
      subroutine fft(numb2,mode,anat,ccfom,nsize,ier)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nat,f(9),nalf(8)
      common /xdata/ x(160000),dummpc(84000)
c
      call expand(numb2,mode,ccfom,ier)
      if (ier.ne.0) return
      call pp1(x,nsize,np(1),np(2),np(3),ier)
      if (ier.lt.0) return
      call search(mode,anat,ier)
      if (ier.lt.0) return
      return
      end
c----------------------------------------------------------------------
      subroutine search(mode,anat,ier)
c     ************************** search ********************************
c       routine for the automatic search of e-maps
c     original version    january   1980           university of york
c     ------------------------------------------------------------------
      common /xdata/ nstore(159856),is(2,3,24),dummpc(84000)
      common /atoms/ x(5,200),icvet(200),idumx(21)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      common /sdir/ dm,npc,nproj,nojoin
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nat,f(9),nalf(8)
      common /kuse/ kuser1,kuser2,kuser3
      common /misc/ t(3,3),dxmax(3),mconx,iwt,fom(11),pts
      common /cent/ tl(3,4),fs(3,3,24),mlat
      common /tape/ cell(6),neqv,icent,lat,natm,ts(3,24),kj(2,3,24),nsym
     *             ,dumb(3)
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
c
      npc = min0(npc, kuser2-20)
c     input data from fft file
      rewind jrel
      read (jrel) itle,numset,cell,neqv,icent,lat,natm,ts,is
      if(numset.lt.0) go to 2000
      anat=float(nat)/(pts*float((icent+1)*neqv))
      if (mode.eq.1) write(lo,720) anat
  720 format(10x,'a  number  of  atoms  has to be found'
     *    ,/,10x,'such that the sum of site occupancies'
     *    ,/,10x,'( occ. ) is equal to ',f8.3,/)
      if (npc .le. 0) go to 760
      nats = npc
      npic = npc
      write(lo,740) npc
  740 format(/31x,35hnumber of peaks to be considered is,i6)
      go to 800
  760 nats =  min0(2*(int(11.0*anat+13.0))/9, kuser2-20)
Corig npic = min0(int(3.0*anat+1.0), kuser2-20)
      npic = min0(int(3.0*anat+3.0), kuser2-20)
c
c
c
      if (nats.lt.20) nats=20
      if (npic.lt.20) npic=20
c
c
c
  800 continue
      if (nproj .gt. 0) write(lo,860) nproj
  860 format(/9x,55hnumber of projections  of each  cluster to be output
     1 is,i3)
c     halve y-axis by c.of.s. or lattice type if possible
      ihalf=0
      if (icent.eq.1) ihalf=-1
      if (ihalf.ne.0) goto 888
      goto (888,886,888,886,886,886,888), lat
  886 ihalf = 1
  888 call centre (1,1)
c     expand to full space group symmetry
c     put centring translations in tl(i,j)
      go to (940,890,890,890,890,910,920),lat
  890 call centre(2,lat)
      go to 940
  910 call centre(2,2)
      call centre(3,3)
      call centre(4,4)
      go to 940
  920 call centre(2,6)
      call centre(3,7)
  940 do 1000 i=1,neqv
      do 970 j=1,3
      do 950 k=1,3
      fs(k,j,i)=0.0
  950 continue
      do 960 k=1,2
      m=iabs(is(k,j,i))
      if(m.gt.0) fs(m,j,i)=float(isign(1,is(k,j,i)))
  960 continue
  970 continue
      if (i.eq.1.or.ihalf.ne.0) goto 1000
c     halve y-axis by symmetry op. if possible
      do 980 j=1,3
      if (iabs(is(1,j,i)).ne.j.or.is(2,j,i).ne.0) goto 1000
  980 continue
      if(is(1,2,i).eq.(-2).and.abs(ts(2,i)).lt.1e-6) ihalf= -1
      if(is(1,2,i).eq.2.and.abs(ts(2,i)-0.5).lt.1e-6) ihalf=1
 1000 continue
      nsym=neqv*(icent+1)*mlat
c     set up constants
      ca=cos(dtor*cell(4))
      cb=cos(dtor*cell(5))
      cc=cos(dtor*cell(6))
      v=cell(1)*cell(2)*cell(3)*sqrt(1.0-ca*ca-cb*cb-cc*cc+2.0*ca*cb*cc)
      dxmax(1)=dm*cell(2)*cell(3)*sin(dtor*cell(4))/v
      dxmax(2)=dm*cell(3)*cell(1)*sin(dtor*cell(5))/v
      dxmax(3)=dm*cell(1)*cell(2)*sin(dtor*cell(6))/v
      dm=dm*dm
c     set up matrix to calculate distances and angles
      do 1020 i=4,6
      j=8/i
      k=15/i
      t(j,k)=cos(dtor*cell(i))
      t(k,j)=t(j,k)
 1020 continue
      do 1060 i=1,3
      t(i,i)=1.0
      do 1040 j=1,3
      t(i,j)=t(i,j)*cell(i)*cell(j)
 1040 continue
 1060 continue
c     if (ihalf.ne.0) write(lo,1080)
c1080 format (/22x,76h** since space group symmetry permits, only half t
c    1he map will be searched **)
c     search map for peak positions and record peak heights
      call pksrch(anat,nstore,ihalf,mode,ier)
 2000 return
      end
c     ------------------------------------------------------------------
c     retrieve centring translations
      subroutine centre(j,l)
      common /cent/ tl(3,4),fs(216),mlat
      dimension tst(21)
      data tst/0.,0.,0., 0.,0.5,0.5, 0.5,0.,0.5, 0.5,0.5,0., 0.5,0.5,0.5
     1 , 0.333333,0.666667,0.666667, 0.666667,0.333333,0.333333/
      mlat=j
      m=3*l-2
      tl(1,j)=tst(m)
      tl(2,j)=tst(m+1)
      tl(3,j)=tst(m+2)
      return
      end
c     ------------------------------------------------------------------
      subroutine rdsect(nr3d,max,nnxp2,nnz,nxz3)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /sdir/ dm,npc,nproj,nojoin
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /kuse/ kuser1,kuser2,kuser3
      dimension  nr3d(kuser3)
      if (max .ge. nxz3) max = 0
      mx = max
      max = max - 2
      do 1320 iz=1,nnz
      min = max + 3
      max = max + nnxp2
      read (jrel)(nr3d(ix),ix=min,max)
      nr3d(max+1) = nr3d(min)
      nr3d(max+2) = nr3d(min+1)
 1320 continue
      min = max + 3
      max = max + nnxp2 + nnxp2 + 2
      do 1340 ix=min,max
      mx = mx + 1
      nr3d(ix) = nr3d(mx)
 1340 continue
      return
      end
c     ------------------------------------------------------------------
c     sort peaks in order of peak height or in order of plotting
      subroutine sortf(x,nats,n)
      common /kuse/ kuser1,kuser2,kuser3
      dimension x(5,kuser2),t(5)
      int=2
 1000 int=int+int
      if(int.lt.nats)go to 1000
      int=min0(nats,(3*int)/4-1)
 1020 int=int/2
      ifin=nats-int
      do 1200 ii=1,ifin
      i=ii
      j=i+int
      if(x(n,i).ge.x(n,j))go to 1200
      do 1060 k=1,5
      t(k)=x(k,j)
 1060 continue
 1080 do 1100 k=1,5
      x(k,j)=x(k,i)
 1100 continue
      j=i
      i=i-int
      if(i)1140,1140,1120
 1120 if(x(n,i).lt.t(n))go to 1080
 1140 do 1160 k=1,5
      x(k,j)=t(k)
 1160 continue
 1200 continue
      if(int.ne.1)go to 1020
      return
      end
c     ------------------------------------------------------------------
c     function used in the calculation of distances and angles
      function quadr(x1,x2,t)
      dimension x1(3),x2(3),t(3,3)
      quadr=0.0
      sum=0.0
      do 1000 i=1,3
      q1    = t(i,1)*x1(1)
      q2    = t(i,2)*x1(2)
      q3    = t(i,3)*x1(3)
      qq    = q1+q2+q3
      qqp   = x2(i)*qq
      sum=sum+qqp
c     quadr = quadr+x2(i)*(t(i,1)*x1(1)+t(i,2)*x1(2)+t(i,3)*x1(3))
 1000 continue
      quadr = sum
      return
      end
c     ------------------------------------------------------------------
c     apply j'th symmetry element to x,y,z & put result in xn
      subroutine oper(j,xn,x,y,z)
      dimension xn(3)
      common /cent/ tl(12),fs(216),mlat
      common /tape/ cell(6),neqv,icent,lat,natm,ts(72  ),is(2,3,24),nsym
     *             ,dumb(3)
      isym=mod(j,neqv)
      if(isym.eq.0) isym=neqv
      ip=(j-1)/neqv
      ilat=3*mod(ip,mlat)
      jt=3*(isym-1)
      jj=9*isym-8
      do 20 l=1,3
      ind1=jt+l
      ind2=ilat+l
      xn(l)=x*fs(jj)+y*fs(jj+1)+z*fs(jj+2)
      if(ip.ge.mlat) xn(l)=-xn(l)
      xn(l)=xn(l)+ts(ind1)+tl(ind2)
      jj=jj+3
   20 continue
      return
      end
c----------------------------------------------------------------------
c     find positions of peaks by fitting quadratic function to 19 points
      subroutine pksrch(anat,nr3d,ihalf,mode,ier)
      common /atoms/ x(5,200),icvet(200),idumx(21)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /sdir/ dm,npc,nproj,nojoin
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /kuse/ kuser1,kuser2,kuser3
      common /misc/ t(3,3),dxmax(3),mconx,iwt,fom(11),pts
      common /tape/ cell(6),neqv,icent,lat,natm,ts(3,24),is(2,3,24),nsym
     *             ,dumb(3)
      common /ureq1/ jpatt,jpunt(501),ksacc,jseteq,jumpp,jmpsie,nsec
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      dimension  nr3d(kuser3), xs(3), x1(3), idiff(19), b(19)
      dimension xo(11),xn(11),key(10),newvet(48,3)
c
c     input dimensions of e-map and check array size
      read (jrel) nnx,nnz,nny
c     halve y-axis if possible
      nnyold=nny
      if (ihalf.ne.0) nny=nny-nny/2
      nnxp2 = nnx + 2
      nxz = nnxp2 * (nnz + 2)
      nxz3 = 3 * nxz
      if (nxz3 .le. kuser3) go to 1020
      write (lo,940) kuser3, nxz3
  940 format(//33h not enough room in array nstore.,10x,18hspace availab
     1le  =,i7,10x,17hspace required  =,i7)
      ier=-1
      return
c     initialise constants
 1020 dx = 1.0 / float(nnx)
      dy = 1.0/float(nnyold)
      dz = 1.0/float(nnz)
      level = 0
      limit = min0(kuser2, 2*nats)
c     set up table of offsets to look up 19 points in e-map
 1100 idiff(1) = -nxz - 1
      idiff(2) = -nxz - nnxp2
      idiff(3) = -nxz
      idiff(4) = -nxz + nnxp2
      idiff(5) = -nxz + 1
      idiff(6) = -nnxp2 - 1
      idiff(7) = -1
      idiff(8) = nnxp2 - 1
      idiff(9) = -nnxp2
      idiff(10) = 0
      do 1120 i=1,9
      j=20-i
      idiff(j) = -idiff(i)
 1120 continue
c     initialise variables
      no = 0
      iy = -1
      ny = 0
c     if (level .eq. 0) go to 1300
c     reposition file to read in first two sections again
 1200 rewind jrel
      read(jrel)
      read(jrel)
      if (iy+2.eq.nnyold) goto 1400
c     read in first section (end of last unit cell)
 1300 max=nxz
      iskip=nnyold-1
      do 1305 i=1,iskip
      read (jrel)
 1305 continue
      call rdsect(nr3d,max,nnxp2,nnz,nxz3)
      rewind jrel
c     read second section (start of unit cell)
      read(jrel)
      read(jrel)
      call rdsect(nr3d,max,nnxp2,nnz,nxz3)
c     read in the next section
 1400 mx = max - nxz + nnx + 1
      call rdsect(nr3d,max,nnxp2,nnz,nxz3)
      iy = iy + 1
      ny = mod(ny+2, 3) - 1
      kk = nxz3
      if (ny) 1440,1460,1500
 1440 kk = -nxz3
 1460 do 1480 i=1,5
      idiff(i) = idiff(i) - kk
 1480 continue
      if (ny .eq. 0) go to 1540
 1500 do 1520 i=15,19
      idiff(i) = idiff(i) - kk
 1520 continue
c     search one section of the e-map
 1540 do 2000 iz=1,nnz
      mn = mx + 3
      mx = mx + nnxp2
      do 1980 ix=mn,mx
      if (nr3d(ix) .lt. level) go to 1980
c     locate grid point with maximum density
      do 1560 i=1,9
      j = idiff(i) + ix
      if (nr3d(ix) .le. nr3d(j)) go to 1980
 1560 continue
      do 1580 i=11,19
      j = idiff(i) + ix
      if (nr3d(ix) .lt. nr3d(j)) go to 1980
 1580 continue
c     fit quadratic function to 19 points
c     dens = a + c*x + d*y + e*z - 0.5*f*(x*x + y*y + z*z)
      do 1600 i=1,19
      j = idiff(i) + ix
      b(i) = nr3d(j)
 1600 continue
      b1 = b(3) + b(7) + b(9) + b(11) + b(13) + b(17)
      b2 = b(1) + b(2) + b(4) + b(5) + b(6) + b(8) + b(12) + b(14) +
     1  b(15) + b(16) + b(18) + b(19)
      f = (30.0 * b(10) + 11.0 * b1 - 8.0 * b2) / 63.0
      c = (b(5)+b(12)+b(13)+b(14)+b(19)-b(1)-b(6)-b(7)-b(8)-b(15))/10.0
      deltax = c / f
      if (abs(deltax) .gt. 1.0) go to 1620
      d = (b(15)+b(16)+b(17)+b(18)+b(19)-b(1)-b(2)-b(3)-b(4)-b(5))/10.0
      deltay = d / f
      if (abs(deltay) .gt. 1.0) go to 1620
      e = (b(4)+b(8)+b(11)+b(14)+b(18)-b(2)-b(6)-b(9)-b(12)-b(16))/10.0
      deltaz = e / f
      if (abs(deltaz) .le. 1.0) go to 1640
 1620 deltax = 0.0
      deltay = 0.0
      deltaz = 0.0
 1640 xx = (float(ix-mn+1) + deltax) * dx
      yy = (float(iy) + deltay) * dy
      zz = (float(iz) + deltaz) * dz
c     peak height interpolation - not suitable if peak shape is poor
c     a = (9.0 * b(10) + 4.0 * b1 - b2) / 21.0
c     b(10) = amax1(a+0.5*(c*deltax+d*deltay+e*deltaz), b(10))
      nop1 = no+1
      x(1,nop1) = xx
      x(2,nop1) = yy
      x(3,nop1) = zz
      x(4,nop1) = b(10)
      if (no .eq. 0) go to 1820
      ir=0
c     if two peaks are closer than dm angstroms eliminate the smaller
      do 1800 k=1,nsym
      call oper(k,xs,xx,yy,zz)
      do 1780 i=1,no
      do 1720 l=1,3
      x1(l) = x(l,i) - xs(l)
 1680 if (abs(x1(l)) .le. 0.5) go to 1700
      x1(l) = x1(l) - sign(1.0, x1(l))
      go to 1680
 1700 if (abs(x1(l)) .gt. dxmax(l)) go to 1780
 1720 continue
      if (quadr(x1,x1,t) .gt. dm) go to 1780
      if(ir.gt.0) x(4,ir)=0.0
      ir=0
      if (b(10) .le. x(4,i)) go to 1980
      x(1,i) = xx
      x(2,i) = yy
      x(3,i) = zz
      x(4,i) = b(10)
      ir=i
 1780 continue
 1800 continue
      if(ir.gt.0) go to 1980
 1820 no = nop1
      if (no .lt. limit) go to 1980
      call sortf(x,no,4)
      no = npic
      level = x(4,npic) + 0.5
 1980 continue
 2000 continue
      if (iy .ge. nny) go to 2100
      if (iy - nnyold + 2) 1400,1200,1400
c     sort peaks in order of peak height
 2100 continue
      call sortf(x,no,4)
      nnn = min0(no,npic)
      if (nnn .eq. npic) go to 2200
c     insufficient peaks found - lower scan level and try again
      level = level - 100
      if(level.ge.(-200)) go to 1100
      npic=no
 2200 continue
c     analize special position to fix the correct number
c     of peaks to consider in interpretation
      fnatm=float(natm)
      fnatm=amax1(anat,fnatm)
      focct=0.2*anat+anat
      tot=0.0
      itot=0
      iactn=1
      non=1
      nbad=0
      do 2250 i=1,no
      xo(1)=x(1,i)
      xo(2)=x(2,i)
      xo(3)=x(3,i)
      iser=i
      iactn=1
      khead=0
      ksp=kspecb(newvet,xo,xn,key,itype,iser,khead,iactn)
      occ=1.0/float(key(10))
      if (occ.gt.focct) then
                          x(4,i)=-999999
                          nbad=nbad+1
                        endif
 2250 continue
      if (nbad.gt.0) then
                       call sortf(x,no,4)
                       no=no-nbad
                     endif
      do 2300 i=1,no
      xo(1)=x(1,i)
      xo(2)=x(2,i)
      xo(3)=x(3,i)
      hei =x(4,i)
      iser=i
      iactn=1    ! da modificare 
      khead=0
      ksp=kspecb(newvet,xo,xn,key,itype,iser,khead,iactn)
      occ=1.0/float(key(10))
      x(5,i) = occ
c     write(6,'(i3,1h),6x,5f8.5)') i,(x(iii,i),iii=1,5)
      tot=tot+occ
      icvet(i)=0
      if (x(4,i).gt.0.001) non=i
      if (tot.gt.fnatm) go to 2300
      itot=i
 2300 continue
c     write(6,*) no,non
c--NEW--
      no=non
c--NEW--
c
      if (jpatt.ne.0) then
                       nats=itot
                     else
                       if (npc.le.0) then
                               nats =  min0((11*itot+13)/9, kuser2-20)
                               npic =  min0((3*itot+1)/2  , kuser2-20)
                                     endif
c
c--NEW--
      if (no.lt.5) then
                     nats=no
                   else
                     if (nats.lt.5) nats=5
                   endif
      if (itot.eq.0) itot=nats
c--NEW--
c     write(6,*) no,itot,npic,nats
      npic=min0(npic,no)
      nats=min0(nats,no)
c
      if (npic.gt.nats) nats=npic
c     write(6,*) no,itot,npic,nats
      if (jrest.ne.0) nemap(3)=itot
      if(jrecyc.eq.0) then
                        nemap(2)=nats
                      else
      if(krecy.ne.0) then
                       nemap(2)=nemap(3)+(nats-nemap(3))*erre**0.5
                       if(nemap(2).gt.nats) nemap(2)=nats
                       nats=nemap(2)
                     else
                       nemap(2)=nemap(3)+(nats-nemap(3))*erre**0.2
                       if(nemap(2).gt.nats) nemap(2)=nats
                       nats=nemap(2)
                     endif
                      endif
      nemap(4)=0
      nemap(1)=nats
      nemap(3)=itot
                     endif
c-- create list 15 ( E-map peaks )
c     write(6,*) no,itot,npic,nats
c
c-- move coordinates of first peak 
c-- if it is in special position
*     if (x(5,1).lt.0.95) then
*         xo(1)=x(1,1)
*         xo(2)=x(2,1)
*         xo(3)=x(3,1)
*         iser=1
*         iactn=2    ! da modificare 
*         khead=0
*         ksp=kspecb(newvet,xo,xn,key,itype,iser,khead,iactn)
*         x(1,1)=xn(1)
*         x(2,1)=xn(2)
*         x(3,1)=xn(3)
*       endif
      interp=0
      call frm15(nats,numset,interp)
      return
      end
c-----------------------------------------------------------------------
      subroutine inptf(npseud,numb)
c--
c-- input subroutine
c--
      common /atoms/ xyz(5,200),icvet(200),idumx(21)
      common /refl/ ih(100),g(2,100)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /kuse/ kuser1,kuser2,kuser3
      common /tran/ scale,mh(3),level,it4,xlim(3)
      common /tape/ cell(6),neqv,icent,lat,natm,ts(3,24),is(2,3,24),nsym
     *             ,dumb(3)
      common /sdir/ dm,npc,nproj,nojoin
c
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
      common /ureq1/ jpatt,jpunt(501),ksacc,jseteq,jumpp,jmpsie,nsec
      common/rc/p(6),cx(9),nref,nb,rhomax,mm,en,mz,er,th,rhomin
      common/c/flgw(30),flgd(30),avr(30),dcv(50),slope,flgk,bt,sc,del,ks
      common /erl/ kmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isn(2,3,24),tsn(3,24),nnsym,pts,ksys,ncent,latt,s3s2,
     *          emme,s3s2p
      common /misc/ t(3,3),dxmax(3),mconx,iwt,fom(11),ptsnew
      common /dd/ a2,b2,c2,ab,ac,bc,bterm,wscale
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nat,f(9),nalf(8)
      dimension abc(3),ang(3)
c
      call yfl01
      if (jpatt.eq.0) then
      call yfl02
                endif
      do 10 i=1,24
      do 10 j=1,3
      ts(j,i)=tsn(j,i)
      do 10 k=1,2
      is(k,j,i)=isn(k,j,i)
   10 continue
      call yfl03
      call ysfl07(nref,mm,idum1,npseud,idum3)
      if (jpatt.eq.0) then
      numb=mm
      else 
      numb=nref
      endif
      do 20 i=1,3
         abc(i)=cx(i)
         cell(i)=cx(i)
         ang(i)=cx(i+3)*pi/180.0
         cell(i+3)=cx(i+3)
         mh(i)=ihx(i)
   20 continue
      a2=abc(1)*abc(1)
      b2=abc(2)*abc(2)
      c2=abc(3)*abc(3)
      ab=2.0*abc(1)*abc(2)*cos(ang(3))
      ac=2.0*abc(1)*abc(3)*cos(ang(2))
      bc=2.0*abc(2)*abc(3)*cos(ang(1))
      bterm=bt
      wscale=sc
      ptsnew=pts
      neqv = nnsym
      icent=ncent
      lat=latt
      anat=float(nat)/(pts*float((icent+1)*nnsym))
      natm=int(anat+0.5)
c
      nsym2=neqv
      if (icent.eq.1) then
c--
c-- generation of matricies deriving from -1
c--
                        nsym2=2*neqv
                        do 30 k=1,neqv
                           do 30 i=1,3
                              tmat(k+neqv,i)=tmat(k,i)
                              do 30 j=1,3
                                 kmat(k+neqv,i,j)=-kmat(k,i,j)
   30                         continue
                      endif
      return
      end
c--------------------------------------------------------------------
      subroutine dirfou(jpfile,ier)
      character line*80,dire*80,diret*80,buff*2,filet*80
      character blank,digit*12,card(100)*80,ffile*80
      common /comdir/ icomq(200,2),maxcom,ipcom,ipdir,icomat
      common /chara/ blank,digit,card,ffile
      common /tran/ scale,mh(3),level,it4,xlim(3)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
      common /ureq1/ jpatt,jpunt(501),ksacc,jseteq,jumpp,jmpsie,nsec
      common /sdir/ dm,npc,nproj,nojoin
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /misc/ t(3,3),dxmax(3),mconx,iwt,fom(11),pts
      common/inpcl/ntype,ttype(10,5),nprojx,nbond,dmaxi,radnew(8)
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nat,f(9),nalf(8)
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icentx
     *        ,kpol,jsys,latx,indv(32),mpv(64),jspini,ddmin,ncawu,ncwu
      dimension vet(40),ivet(40)
      dimension ltype(10,5)
      equivalence (ltype(1,1),ttype(1,1))
c-- set default values
c
      jspini = -1
      do 10 i=1,nk
   10 radnew(i)=-1.0
      fomin=-1.0
      tsigma=-1.0
      nsec=1
      jrecyc=-100
      dmaxi=0.0
      jpfile=0
      ntype=0
      do 20 i=1,5
      do 20 j=1,10
   20 ttype(j,i)=0
      jmpsie= 0
      iprin = 0
      ibl   = 0
      nproj = 0
      nbond = 1
      npc   = 0
      nojoin= 0
      it4   = 0
      numset= 0
      factr= 1.0/3.0
      level = 100
      xlim(1)=1.0
      xlim(2)=1.0
      xlim(3)=1.0
      ks    = 1
      ic=0
      icmax=icomq(icomat,2)
c
  100 continue
      ic=ic+1
      if (ic.gt.icmax) go to 8000
      ipdir=ipdir+1
      line=card(ipdir)
      diret=line
      call cutst(line,lenp,dire,lend)
      call lcase(dire)
      if (dire(1:4).eq.'layy') then
          nsec=1
          go to 100
          endif
      if (dire(1:4).eq.'layx') then
          nsec=2
          go to 100
          endif
      if (dire(1:4).eq.'layz') then
          nsec=3
          go to 100
          endif
C     if (dire(1:4).eq.'plot') then
c
c 1-st card : keys for following coordinates
c             6 = atomic specie
c             7 = serial number
c             5 = peak intensity
c         1-2-3 = x-y-z
c             4 = occupancy factor
c             8 = dummy
c
C         jpfile=kform
C         read(line,'(a)') filet
C         nlen=80
C         istat=2
C         iform=1
C         if (jopen(jpfile,filet,nlen,istat,iform,ier).ne.0) go to 9100
C         go to 100
C         endif
      if (dire(1:4).eq.'frag') then
          jpfile=kform
          read(line,'(a)') filet
          nlen=80
          istat=2
          iform=1
          if (jopen(jpfile,filet,nlen,istat,iform,ier).ne.0) go to 9100
          jpfile=-jpfile
          go to 100
          endif
c     if (dire(1:4).eq.'form') then
c         write(7,*) lenp,line
c         if (lenp.le.0) go to  9000
c         pfmt=line
c         go to 100
c         endif
      if (dire(1:4).eq.'radi') then
          call cutst(line,lenp,dire,lend)
          if (lend.le.0) go to 9000
          call lcase(dire(1:2))
          read(dire(1:2),'(a2)') irad
          j=0
          do 150 i=1,nk
          if (nalf(i).eq.irad) j=i
  150     continue
          if (j.eq.0) then
                        write(lo,8030) irad
                        go to 9000
                      endif
          iopt=0
          call getnum(line,vet,ivet,iv,iopt)
          if (iv.ne.1) go to 9000
          radnew(j)=vet(1)
          go to 100
          endif
      if (dire(1:4).eq.'coor') then
          ntype=ntype+1
          call cutst(line,lenp,dire,lend)
          if (lend.le.0) go to 9000
          call lcase(dire(1:2))
          read(dire(1:2),'(a2)') ttype(ntype,1)
          iopt=0
          call getnum(line,vet,ivet,iv,iopt)
          if ((vet(2)-vet(1)).gt.0.0001) then
                                           ttype(ntype,2)=vet(1)
                                           ttype(ntype,3)=vet(2)
                                         else
                             write(lo,6000) diret,ttype(ntype,1)
                                           ntype=ntype-1
                                         endif
 6000 format(' *** warning ***  minimum and maximum are zero or wrong',
     *     /,'                  in directive ',a80,
     *     /,'                  default values',
     *       ' for element ',a2,' will be used')
          if (iv.le.2) go to 100
          itype=ivet(3)
          if (itype.ge.0.and.itype.le.3) then
                                           ltype(ntype,4)=itype
                                         else
                                           write(lo,7000) itype
                                           go to 9000
                                         endif
 7000 format(' coordination type = ',i5,'  not expected')
          go to 100
          endif
c-- directives with numeric parameters
      iopt=0
      call getnum(line,vet,ivet,iv,iopt)
      if (iopt.eq.-1) go to 9000
      if (dire(1:4).eq.'fomi') then
          if (iv.ne.1) go to 9000
          fomin=vet(1)
          go to 100
          endif
      if (dire(1:4).eq.'sigm') then
          if (iv.ne.1) go to 9000
          tsigma=vet(1)
          go to 100
          endif
      if (dire(1:2).eq.'ls') then
          if (iv.ne.1) go to 9000
          lsx=ivet(1)
          go to 100
          endif
      if (dire(1:4).eq.'peak') then
          if (iv.ne.1) go to 9000
          npc=ivet(1)
          go to 100
          endif
      if (dire(1:4).eq.'prin') then
          if (iv.ne.1) go to 9000
          iprin = ivet(1)
          go to 100
          endif
      if (dire(1:4).eq.'dmax') then
          if (iv.ne.1) go to 9000
          dmaxi=vet(1)
          go to 100
          endif
      if (dire(1:4).eq.'proj') then
          if (iv.ne.1) go to 9000
          nproj=ivet(1)
          go to 100
          endif
      if (dire(1:4).eq.'noin') then
          if (iv.ne.0) go to 9000
          nojoin=1
          go to 100
          endif
      if (dire(1:4).eq.'psej') then
          if (iv.ne.0) go to 9000
          jmpsie= 1
          go to 100
          endif
      if (dire(1:3).eq.'set' ) then
          if (iv.ne.1) go to 9000
          numset=ivet(1)
          go to 100
          endif
      if (dire(1:3).eq.'tan' ) then
          if (iv.ne.0) go to 9000
          numset=1001
          go to 100
          endif
      if (dire(1:3).eq.'kno' ) then
          if (iv.ne.0) go to 9000
          numset=1000
          go to 100
          endif
      if (dire(1:3).eq.'rec' ) then
          if (iv.eq.1) jrecyc=-ivet(1)
          go to 100
          endif
      if (dire(1:4).eq.'leve') then
          if (iv.ne.1) go to 9000
          level=ivet(1)
          go to 100
          endif
      if (dire(1:4).eq.'grid') then
          if (iv.ne.1) go to 9000
          factr=vet(1)
          go to 100
          endif
      if (dire(1:4).eq.'limi') then
          if (iv.ne.3) go to 9000
          do 7500 i=1,3
 7500     xlim(i)=amin1(vet(i),1.0)
          go to 100
          endif
      if (dire(1:3).eq.'map' ) then
          if (iv.ne.0) go to 9000
          it4=lo
          go to 100
          endif
      write(lo,6500) diret
 6500 format(' wrong directive on following line:',/a)
      ier=-1
      return
 8000 continue
      if (tsigma.gt.0.0.and.ksigma.eq.0) then
                                           write(lo,8005)
                                           tsigma=-1.0
                                         endif
 8005 format(' *** warning ***  no suitable sigma(F) in data',/,
     *       '                  SIGMA directive ignored')
      nprojj=nproj
      if (ntype.gt.0) then
                        do 8020 i=1,ntype
                        write(buff,'(a2)') ttype(i,1)
                        read (buff,'(a2)') itype
                        do 8010 j=1,nk
                           if (itype.ne.nalf(j)) go to 8010
                           go to 8020
 8010                   continue
                        write(lo,8030) ttype(i,1)
                        go to 9000
 8020                   continue
                      endif
 8030 format(' Element ',a2,' not present in the declared content')
      return
 9000 continue
      ier=-1
      write(lo,'(22h error in directive : ,a80)') diret
      return
 9100 continue
      write(lo,9110) ier,filet
 9110 format(' *** error ***  open error - code =',i5,
     *'.  Fragment file name is ',a)
      ier=-1
      return
      end
c-----------------------------------------------------------------------
c     get peaks to plot
      subroutine getplt(jpfile,ier)
      character*2 diret
      character*80  line,dire
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common /atoms/ x(5,200),nz(200),idumx(21)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nat,f(9),nalf(8)
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent,
     *         kpol,jsys,lat,indv(32),mpv(64),jspini,ddmin,ncawu,ncwu
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common /temp/ conn(9800)
      dimension itype(80),i(20),vi(40),vet(40) ,lini(40),iv(40)
      dimension ix(5,200)
      dimension xo(11),xn(11),key(10),newvet(48,3)
      equivalence (ix,x)
c
c--parameter   x y z occ int ty serial
c--code number 1 2 3  5   4  6     7
c
c
      conn(1)=-1
      if (jpfile.gt.0) then
                         kfrag= jpfile
                       else
                         kfrag=-jpfile
                       endif
      nats=0
      do 1 j=1,40
    1 lini(j)=0
      do 2 j=1,200
      do 2 ij=1,5
2     x(ij,j)=0
      if (jpfile.gt.0) then
                         read(kfrag,'(a)',end=300)line
                         iopt=0
                         call shift(line,nn)
                         call getnum(line,vet,lini,in,iopt)
                         if (iopt.eq.-1) go to 650
                       else
                         in=4
                         lini(1)=6
                         lini(2)=1
                         lini(3)=2
                         lini(4)=3
                       endif
      do 5 j=1,in
      i(j)=0
      nn=j
      i(j)=lini(j)
      if(lini(j).gt.0.and.lini(j).le.7) go to 5
      nn=j-1
    5 continue
      jtype=0
      if (i(1).eq.6) then
                       jtype=1
                       do 10 j=1,nn-1
   10                  i(j)=i(j+1)
                       i(nn)=0
                       nn=nn-1
                     endif
  100 nats=nats+1
      izz=6
      read(kfrag,'(a)',end=300)line
      call shift(line,kk)
      if (jtype.eq.1) then
                        call cutst(line,lenp,dire,lend)
                        call lcase(dire)
                        if (lend.gt.2) go to 106
                        do 105 j=1,nk
                        write(diret,'(a2)')nalf(j)
                        if (dire.eq.diret) then
                                             izz=no(j)
                                             go  to 106
                                           endif
  105                   continue
                        go to 650
  106                   continue
                      endif
      nz(nats)=izz*100+1
      iopt=0
      call getnum(line,vi,iv,in,iopt)
      do 110 j=1,nn
      if (i(j).eq.0) go to 110
      if (i(j).lt.6) x(i(j),nats)=vi(j)
  110 continue
      go to 100
  300 nats=nats-1
      close(kfrag)
      call xspinb
      if (jpfile.lt.0) then
                         iactn=1
                         do 400 j=1,nats
                         izz=nz(j)/100
                         do 350 k=1,nk
                         if (izz.eq.no(k)) then
                                             nz(j)=k*100+1
                                             x(4,j)=izz*100+k
                                           endif
  350                    continue
                         xo(1)=x(1,j)
                         xo(2)=x(2,j)
                         xo(3)=x(3,j)
                         iser=j
                         iactn=1
                         khead=0
             ksp=kspecb(newvet,xo,xn,key,itype,iser,khead,iactn)
                         x(5,j) = 1.0/float(key(10))
  400                    continue
                       endif
      call sortf(x,nats,4)
      do 430 j=1,nats
      k=x(4,j)
      k=mod(k,100)
      nz(j)=k*100+1
  430 continue
      numset=1
      interp=0
      call frm15(nats,numset,interp)
      call inptf(npseud,numb)
      nemap(4)=jpfile
c
      if (jpfile.lt.0) jpfile=-jpfile
c
      pop=ncentr*(float((icent+1)*noper))
      write(lo,450) nats,pop
  450 format(//,
     * 25x,30hFragment : known positions for,i5,
     1 29h  atoms having multiplicity =,f5.1,//,
     2 28x,'type',12x,'x',14x,'y',14x,'z',12x,'occ',/)
      do 600 j=1,nats
      k=nz(j)/100
      write(diret,'(a2)') nalf(k)
      call ucase(diret(1:1))
      write(lo,550) diret,(x(jj,j),jj=1,3),x(5,j)
  550 format(1h ,28x,a2,4f15.4)
  600 continue
      return
  650 continue
      write(lo,700)
  700 format(//,' *** error ***  check coordinate file ',/)
      ier=-1
      return
      end
c-----------------------------------------------------------------------
      subroutine pp1 (x, nsize, nx, ny, nz,ier)
      real x(nsize)
      integer  p1, p2, r, skip, recs,  d(5)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /kuse/ kuser1,kuser2,kuser3
      common /tran/ scale,mh(3),level,it4,xlim(3)
      common /tape/ cell(6),neqv,icent,lat,natm,ts(3,24),is(2,3,24),nsym
     *             ,dumb(3)
      common /pollo/ nuva(800),numr
      common /new/ ntime
c
      do 10 i=1,800
   10 nuva(i)=0
      p1 = nsize/(2*ny*(mh(3) + 1))
      p2 = nsize/(nx*nz)
      if (p1 .le. 0 .or. p2 .le. 0) go to 300
c
c     pass one. transform on k and write intermediate results on ifour
c
      rewind ifour
      numr=0
      r = -mh(1)
  100 if (r + p1 .gt. mh(1)) p1 = mh(1) + 1 - r
      call read kln(x, ny, mh(3)+1, p1, r)
      d(1) = 2*(ny*p1*(mh(3)+1))
      d(2) = 2
      d(3) = d(1)
      d(4) = d(1)
      d(5) = 2*ny
      call cmplftn(x(1), x(2), nsize, ny, d,ier)
      if (ier.lt.0) return
      call write yn(x, ny, mh(3)+1, p1, p2)
      r = r + p1
      if (r .le. mh(1)) go to 100
c
c     end of pass 1.  pass 2 reads back the intermediate results,
c     calculates the transforms on h and l, and writes out the final
c     y sections.
c
      rewind jrel
      write(jrel) itle,numset,cell,neqv,icent,lat,natm,ts,is
      write(jrel) nx,nz,ny
c
      rewind ifour
      numr=0
      skip = 0
      r = 0
      p1 = nsize/(2*ny*(mh(3) + 1))
      recs = (ny - 1)/p2
      ntime=0
  200 if (r + p2 .gt. ny) p2 = ny - r
      call read hln(x, nx, nz/2, p2, mh(1), mh(3), p1, skip, recs)
      if (r + p2 .lt. ny) rewind ifour
      if(r + p2 .lt. ny) numr=0
      skip = skip + 1
c
c     x now contains intermediate results stored with l down the
c     columns and h across the rows.
c
      d(1) = nx*nz*p2
      d(2) = nz
      d(3) = nz*nx
      d(4) = 2*(mh(3) + 1)
      d(5) = 2
      call cmplftn(x(1), x(2), nsize, nx, d,ier)
      if (ier.lt.0) return
      d(2) = 2
      d(3) = d(1)
      d(4) = d(1)
      d(5) = nz
      call hermftn(x(1), x(2), nsize, nz/2, d,ier)
      if (ier.lt.0) return
      call outpufn(x, nz, nx, p2, r, ny)
      ntime =ntime+1
      r = r + p2
      if (r .lt. ny) go to 200
c
c     end of job
c
      return
c
  300 p1 = 2*ny*(mh(3)+1)
      p2 = nx * nz
      write(lo,350) nsize, p1, p2
  350 format(/,8x,37hrequest too large. space available is,i10,
     1 33h and space requested is larger of,i10,4h and,i10)
      ier=-1
      return
      end
c     ------------------------------------------------------------------
      subroutine cmplftn(x, y, nsize, n, d,ier)
      real x(nsize), y(nsize)
      integer d(5),pmax,psym,twogrp,factor(15),sym(15),unsym(15)
c
c     complex finite discrete fourier transform
c     transforms one dimension of multi-dimensional data
c     modified by l. f. ten eyck from a one-dimensional version written
c     by g. t. sande, 1969.
c
c     this program calculates the transform
c               (x(t) + i*y(t))*(cos(2*pi*t/n) - i*sin(2*pi*t/n))
c
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      p max = 5
      two grp = 4
c
      call s r fpn(n, p max, two grp, factor, sym, p sym, un sym,ier)
      if (ier.lt.0) return
      call mdftkdn(n, factor, d, x, y, nsize)
      call diprpn(n, sym, p sym, un sym, d, x, y, nsize)
      return
      end
c     ------------------------------------------------------------------
      subroutine s r fpn(pts,pmax,two grp,factor,sym,p sym,un sym,ier)
c     symmetrized reordering factoring program
c
      integer pts,pmax,two grp,p sym, factor (10), sym (10), un sym (10)
      integer pp(14), qq (7), f,p,p two,q,r
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
c
      nest=14
c
      n=pts
      p sym=1
      f=2
      p=0
      q=0
  100 if (n.le.1) go to 500
      do 200 j=f,pmax
      if (n.eq.(n/j)*j) go to 300
  200 continue
      ier=-1
      return
  300 f=j
      n=n/f
      if (n.eq.(n/f)*f) go to 400
      q=q+1
      qq(q)=f
      go to 100
  400 n=n/f
      p=p+1
      pp(p)=f
      p sym=p sym*f
      go to 100
c
  500 r=1
      if (q.eq.0) r=0
      if (p.lt.1) go to 700
      do 600 j=1,p
      jj=p+1-j
      sym(j)=pp(jj)
      factor(j)=pp(jj)
      jj=p+q+j
      factor(jj)=pp(j)
      jj=p+r+j
      sym(jj)=pp(j)
  600 continue
  700 if (q.lt.1) go to 900
      do 800 j=1,q
      jj=p+j
      un sym(j)=qq(j)
      factor(jj)=qq(j)
  800 continue
      sym(p+1)=pts/p sym**2
  900 jj=2*p+q
      factor(jj+1)=0
      p two=1
      j=0
 1000 j=j+1
      if (factor(j).eq.0) go to 1200
      if (factor(j).ne.2) go to 1000
      p two=p two*2
      factor(j)=1
      if (p two.ge.two grp) go to 1100
      if (factor(j+1).eq.2) go to 1000
 1100 factor(j)=p two
      p two=1
      go to 1000
 1200 if (p.eq.0) r=0
      jj=2*p+r
      sym(jj+1)=0
      if (q.le.1) q=0
      un sym(q+1)=0
      return
      end
c     ------------------------------------------------------------------
      subroutine diprpn(pts, sym, p sym, un sym, dim, x, y, nsize)
c     double in place reordering program
c
      real x(nsize), y(nsize)
      integer sym(10), un sym(10), dim(5), pts, psym, dk, p un sym, test
      logical one mod
      integer sep, delta, p, p0, p1, p2, p3, p4, p5, size
cdjw99      integer v(14), modulo(14), s(14), u(14)
      integer v(14), modula(14), s(14), u(14)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
c
      nest=14
c
      nt = dim(1)
      sep = dim(2)
      p2 = dim(3)
      size = dim(4) - 1
      p4 = dim(5)
      if (sym(1).eq.0) go to 500
      do 100 j=1,nest
      u(j)=1
      s(j)=1
  100 continue
      n=pts
      do 200 j=1,nest
      if (sym(j).eq.0) go to 300
      jj=nest+1-j
      u(jj)=n
      n=n/sym(j)
      s(jj)=n
  200 continue
  300 jj=0
      l=1
      v(1)=1
  310 l=l+1
      v(l)=v(l-1)
  320 if(l.lt.nest) go to 310
      n=v(nest)
      jj=jj+1
      if (jj.ge.n) go to 400
      delta = (n-jj)*sep
      p1 = (jj-1)*sep + 1
      do 350 p0 = p1, nt, p2
      p3 = p0 + size
      do 350 p = p0, p3, p4
      p5 = p + delta
      t = x(p)
      x(p) = x(p5)
      x(p5) = t
      t = y(p)
      y(p) = y(p5)
      y(p5) = t
  350 continue
  400 v(l)=v(l)+s(l)
      if(v(l).le.u(l)) go to 320
      l=l-1
      if(l.ne.0) go to 400
c
  500 if (un sym(1).eq.0) go to 1900
      p un sym=pts/p sym**2
      mult=p un sym/un sym(1)
      test=(un sym(1)*un sym(2)-1)*mult*p sym
      lk=mult
      dk=mult
      do 600 k=2,nest
      if (un sym(k).eq.0) go to 700
      lk=lk*un sym(k-1)
      dk=dk/un sym(k)
      u(k)=(lk-dk)*p sym
      mods=k
  600 continue
  700 one mod=mods.lt.3
      if (one mod) go to 900
      do 800 j=3,mods
      jj=mods+3-j
cdjw99      modulo(jj)=u(j)
      modula(jj)=u(j)
  800 continue
cdjw99  900 modulo(2)=u(2)
  900 modula(2)=u(2)
      jl=(p un sym-3)*p sym
      ms=p un sym*p sym
c
      do 1800 j=p sym,jl,p sym
      k=j
c
 1000 k=k*mult
      if (one mod) go to 1200
      do 1100 i=3,mods
cdjw99      k=k-(k/modulo(i))*modulo(i)
      k=k-(k/modula(i))*modula(i)
 1100 continue
 1200 if (k.ge.test) go to 1300
cdjw99      k=k-(k/modulo(2))*modulo(2)
      k=k-(k/modula(2))*modula(2)
      go to 1400
cdjw99 1300 k=k-(k/modulo(2))*modulo(2)+modulo(2)
 1300 k=k-(k/modula(2))*modula(2)+modula(2)
 1400 if (k.lt.j) go to 1000
c
      if (k.eq.j) go to 1800
      delta = (k-j)*sep
      do 1600 l=1,p sym
      do 1500 m=l,pts,ms
      p1 = (m+j-1)*sep + 1
      do 1500 p0 = p1, nt, p2
      p3 = p0 + size
      do 1500 jj = p0, p3, p4
      kk = jj + delta
      t=x(jj)
      x(jj)=x(kk)
      x(kk)=t
      t=y(jj)
      y(jj)=y(kk)
      y(kk)=t
 1500 continue
 1600 continue
 1800 continue
 1900 return
      end
c     ------------------------------------------------------------------
      subroutine mdftkdn(n, factor, dim, x, y, nsize)
c     multi-dimensional complex fourier transform kernel driver
c
      integer factor(10), dim(5), f, p, r, s
      real x(nsize), y(nsize)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
c
      s = dim(2)
      f = 0
      m = n
  100 f = f + 1
      p = factor(f)
      if (p.eq.0) return
      m = m/p
      r = m*s
      go to (100, 200, 300, 400, 500), p
c
  200 call r2cftkn(n,m,x(1),y(1),x(r+1),y(r+1),dim,nsize)
      go to 100
c
  300 continue
      call r3 cftkn(n, m, x(1), y(1), x(r+1), y(r+1), x(2*r+1), y(2*r+1)
     ., dim ,nsize )
      go to 100
c
  400 call r4 cftkn(n, m, x(1), y(1), x(r+1), y(r+1), x(2*r+1), y(2*r+1)
     ., x(3*r+1), y(3*r+1), dim, nsize)
      go to 100
c
  500 call r5 cftkn(n, m, x(1), y(1), x(r+1), y(r+1), x(2*r+1), y(2*r+1)
     ., x(3*r+1), y(3*r+1), x(4*r+1), y(4*r+1), dim, nsize)
      go to 100
c
      end
c     ------------------------------------------------------------------
      subroutine r2 cftkn(n, m, x0, y0, x1, y1, dim, ms)
c     radix 2 multi-dimensional complex fourier transform kernel
c
      integer dim(5), size, sep
      real x0(ms), y0(ms), x1(ms), y1(ms), is, iu
      logical fold,zero
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /kuse/ kuser1,kuser2,kuser3
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
c
      nt = dim(1)
      sep = dim(2)
      l1 = dim(3)
      size = dim(4) - 1
      k2 = dim(5)
      ns = n*sep
      m2=m*2
      fm2 = float(m2)
      m over 2=m/2+1
      mm2 = sep*m2
c
      fjm1 = -1.0
      do 600 j=1,m over 2
      fold=j.gt.1 .and. 2*j.lt.m+2
      k0 = (j-1)*sep + 1
      fjm1 = fjm1 + 1.0
      angle = two pi*fjm1/fm2
      zero=angle.eq.0.0
      if (zero) go to 200
      c=cos(angle)
      s=sin(angle)
      go to 200
  100 fold=.false.
      k0 = (m+1-j)*sep + 1
      c=-c
  200 do 500 kk = k0, ns, mm2
      do 440 l = kk, nt, l1
      k1 = l + size
      do 420 k = l, k1, k2
      rs=x0(k)+x1(k)
      is=y0(k)+y1(k)
      ru=x0(k)-x1(k)
      iu=y0(k)-y1(k)
      x0(k)=rs
      y0(k)=is
      if (zero) go to 300
      x1(k)=ru*c+iu*s
      y1(k)=iu*c-ru*s
      go to 420
  300 x1(k)=ru
      y1(k)=iu
  420 continue
  440 continue
  500 continue
      if (fold) go to 100
  600 continue
      return
      end
c     ------------------------------------------------------------------
      subroutine r3 cftkn(n, m, x0, y0, x1, y1, x2, y2, dim, ms)
c     radix 3 multi-dimensional complex fourier transform kernel
c
      integer dim(5), size, sep
      real x0(ms),y0(ms),x1(ms),y1(ms),x2(ms),y2(ms), i0,i1,i2,ia,ib,is
      logical fold,zero
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /kuse/ kuser1,kuser2,kuser3
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      data a/-0.5/, b/0.86602540/
c
      nt = dim(1)
      sep = dim(2)
      l1 = dim(3)
      size = dim(4) - 1
      k2 = dim(5)
      ns = n*sep
      m3=m*3
      fm3 = float(m3)
      mm3 = sep*m3
      m over 2=m/2+1
c
      fjm1 = -1.0
      do 600 j=1,m over 2
      fold=j.gt.1 .and. 2*j.lt.m+2
      k0 = (j-1)*sep + 1
      fjm1 = fjm1 + 1.0
      angle = two pi*fjm1/fm3
      zero=angle.eq.0.0
      if (zero) go to 200
      c1=cos(angle)
      s1=sin(angle)
      c2=c1*c1-s1*s1
      s2=s1*c1+c1*s1
      go to 200
  100 fold=.false.
      k0 = (m+1-j)*sep + 1
      t=c1*a+s1*b
      s1=c1*b-s1*a
      c1=t
      t=c2*a-s2*b
      s2=-c2*b-s2*a
      c2=t
  200 do 500 kk = k0, ns, mm3
      do 440 l = kk, nt, l1
      k1 = l + size
      do 420 k = l, k1, k2
      r0=x0(k)
      i0=y0(k)
      rs=x1(k)+x2(k)
      is=y1(k)+y2(k)
      x0(k)=r0+rs
      y0(k)=i0+is
      ra=r0+rs*a
      ia=i0+is*a
      rb=(x1(k)-x2(k))*b
      ib=(y1(k)-y2(k))*b
      if (zero) go to 300
      r1=ra+ib
      i1=ia-rb
      r2=ra-ib
      i2=ia+rb
      x1(k)=r1*c1+i1*s1
      y1(k)=i1*c1-r1*s1
      x2(k)=r2*c2+i2*s2
      y2(k)=i2*c2-r2*s2
      go to 420
  300 x1(k)=ra+ib
      y1(k)=ia-rb
      x2(k)=ra-ib
      y2(k)=ia+rb
  420 continue
  440 continue
  500 continue
      if (fold) go to 100
  600 continue
      return
      end
c     ------------------------------------------------------------------
      subroutine r4 cftkn(n, m, x0, y0, x1, y1, x2, y2, x3, y3, dim,ms)
c     radix 4 multi-dimensional complex fourier transform kernel
c
      integer dim(5), size, sep
      real x0(ms),y0(ms),x1(ms),y1(ms),x2(ms),y2(ms),x3(ms),y3(ms)
      logical fold,zero
      real i1,i2,i3,is0,is1,iu0,iu1
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /kuse/ kuser1,kuser2,kuser3
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
c
      nt = dim(1)
      sep = dim(2)
      l1 = dim(3)
      size = dim(4) - 1
      k2 = dim(5)
      ns = n*sep
      m4=m*4
      fm4 = float(m4)
      mm4 = sep*m4
      m over 2=m/2+1
c
      fjm1 = -1.0
      do 600 j=1,m over 2
      fold=j.gt.1 .and. 2*j.lt.m+2
      k0 = (j-1)*sep + 1
      fjm1 = fjm1 + 1.0
      angle = two pi*fjm1/fm4
      zero=angle.eq.0.0
      if (zero) go to 200
      c1=cos(angle)
      s1=sin(angle)
      c2=c1*c1-s1*s1
      s2=s1*c1+c1*s1
      c3=c2*c1-s2*s1
      s3=s2*c1+c2*s1
      go to 200
  100 fold=.false.
      k0 = (m+1-j)*sep + 1
      t=c1
      c1=s1
      s1=t
      c2=-c2
      t=c3
      c3=-s3
      s3=-t
  200 do 500 kk = k0, ns, mm4
      do 440 l = kk, nt, l1
      k1 = l + size
      do 420 k = l, k1, k2
      rs0=x0(k)+x2(k)
      is0=y0(k)+y2(k)
      ru0=x0(k)-x2(k)
      iu0=y0(k)-y2(k)
      rs1=x1(k)+x3(k)
      is1=y1(k)+y3(k)
      ru1=x1(k)-x3(k)
      iu1=y1(k)-y3(k)
      x0(k)=rs0+rs1
      y0(k)=is0+is1
      if (zero) go to 300
      r1=ru0+iu1
      i1=iu0-ru1
      r2=rs0-rs1
      i2=is0-is1
      r3=ru0-iu1
      i3=iu0+ru1
      x2(k)=r1*c1+i1*s1
      y2(k)=i1*c1-r1*s1
      x1(k)=r2*c2+i2*s2
      y1(k)=i2*c2-r2*s2
      x3(k)=r3*c3+i3*s3
      y3(k)=i3*c3-r3*s3
      go to 420
  300 x2(k)=ru0+iu1
      y2(k)=iu0-ru1
      x1(k)=rs0-rs1
      y1(k)=is0-is1
      x3(k)=ru0-iu1
      y3(k)=iu0+ru1
  420 continue
  440 continue
  500 continue
      if (fold) go to 100
  600 continue
      return
      end
c     ------------------------------------------------------------------
      subroutine r5 cftkn(n,m,x0,y0,x1,y1,x2,y2,x3,y3,x4,y4,dim,ms)
c     radix 5 multi-dimensional complex fourier transform kernel
c
      integer dim(5), size, sep
      real x0(ms),y0(ms),x1(ms),y1(ms),x2(ms),y2(ms),x3(ms),y3(ms),
     1 x4(ms),y4(ms),i0,i1,i2,i3,i4,ia1,ia2,ib1,ib2,is1,is2,iu1,iu2
      logical fold,zero
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /kuse/ kuser1,kuser2,kuser3
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      data a1/0.30901699/,b1/0.95105652/,a2/-0.80901699/,b2/0.58778525/
c
      nt = dim(1)
      sep = dim(2)
      l1 = dim(3)
      size = dim(4) - 1
      k2 = dim(5)
      ns = n*sep
      m5=m*5
      fm5 = float(m5)
      mm5 = sep*m5
      m over 2=m/2+1
c
      fjm1 = -1.0
      do 600 j=1,m over 2
      fold=j.gt.1 .and. 2*j.lt.m+2
      k0 = (j-1)*sep + 1
      fjm1 = fjm1 + 1.0
      angle = two pi*fjm1/fm5
      zero=angle.eq.0.0
      if (zero) go to 200
      c1=cos(angle)
      s1=sin(angle)
      c2=c1*c1-s1*s1
      s2=s1*c1+c1*s1
      c3=c2*c1-s2*s1
      s3=s2*c1+c2*s1
      c4=c2*c2-s2*s2
      s4=s2*c2+c2*s2
      go to 200
  100 fold=.false.
      k0 = (m+1-j)*sep + 1
      t=c1*a1+s1*b1
      s1=c1*b1-s1*a1
      c1=t
      t=c2*a2+s2*b2
      s2=c2*b2-s2*a2
      c2=t
      t=c3*a2-s3*b2
      s3=-c3*b2-s3*a2
      c3=t
      t=c4*a1-s4*b1
      s4=-c4*b1-s4*a1
      c4=t
  200 do 500 kk = k0, ns, mm5
      do 440 l = kk, nt, l1
      k1 = l + size
      do 420 k = l, k1, k2
      r0=x0(k)
      i0=y0(k)
      rs1=x1(k)+x4(k)
      is1=y1(k)+y4(k)
      ru1=x1(k)-x4(k)
      iu1=y1(k)-y4(k)
      rs2=x2(k)+x3(k)
      is2=y2(k)+y3(k)
      ru2=x2(k)-x3(k)
      iu2=y2(k)-y3(k)
      x0(k)=r0+rs1+rs2
      y0(k)=i0+is1+is2
      ra1=r0+rs1*a1+rs2*a2
      ia1=i0+is1*a1+is2*a2
      ra2=r0+rs1*a2+rs2*a1
      ia2=i0+is1*a2+is2*a1
      rb1=ru1*b1+ru2*b2
      ib1=iu1*b1+iu2*b2
      rb2=ru1*b2-ru2*b1
      ib2=iu1*b2-iu2*b1
      if (zero) go to 300
      r1=ra1+ib1
      i1=ia1-rb1
      r2=ra2+ib2
      i2=ia2-rb2
      r3=ra2-ib2
      i3=ia2+rb2
      r4=ra1-ib1
      i4=ia1+rb1
      x1(k)=r1*c1+i1*s1
      y1(k)=i1*c1-r1*s1
      x2(k)=r2*c2+i2*s2
      y2(k)=i2*c2-r2*s2
      x3(k)=r3*c3+i3*s3
      y3(k)=i3*c3-r3*s3
      x4(k)=r4*c4+i4*s4
      y4(k)=i4*c4-r4*s4
      go to 420
  300 x1(k)=ra1+ib1
      y1(k)=ia1-rb1
      x2(k)=ra2+ib2
      y2(k)=ia2-rb2
      x3(k)=ra2-ib2
      y3(k)=ia2+rb2
      x4(k)=ra1-ib1
      y4(k)=ia1+rb1
  420 continue
  440 continue
  500 continue
      if (fold) go to 100
  600 continue
      return
      end
c     ------------------------------------------------------------------
      subroutine hermftn(x, y, nsize, n, dim,ier)
      real x(nsize), y(nsize)
      integer dim(5), d2, d3, d4, d5
c
c     hermitian symmetric fourier transform
c
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /kuse/ kuser1,kuser2,kuser3
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
c
      two n = float(2*n)
      nt = dim(1)
      d2 = dim(2)
      d3 = dim(3)
      d4 = dim(4) - 1
      d5 = dim(5)
c
      do 100 i0 = 1, nt, d3
      i1 = i0 + d4
      do 100 i = i0, i1, d5
      a = x(i)
      b = y(i)
      x(i) = a + b
      y(i) = a - b
  100 continue
c
      n over 2 = n/2 + 1
      if (n over 2 .lt. 2) go to 500
      do 400 i0 = 2, n over 2
      angle = two pi*float(i0-1)/two n
      co = cos(angle)
      si = sin(angle)
      k = (n + 2 - 2*i0)*d2
      k1 = (i0 - 1)*d2 + 1
      do 300 i1 = k1, nt, d3
      i2 = i1 + d4
      do 200 i = i1, i2, d5
      j = i + k
      a = x(i) + x(j)
      b = x(i) - x(j)
      c = y(i) + y(j)
      d = y(i) - y(j)
      e = b*co + c*si
      f = b*si - c*co
      x(i) = a + f
      x(j) = a - f
      y(i) = e + d
      y(j) = e - d
  200 continue
  300 continue
  400 continue
c
      call cmplftn(x, y, nsize, n, dim,ier)
c
  500 return
      end
c     ------------------------------------------------------------------
      subroutine read kln(x, ny, nz, nx, hs)
      integer hs, h, hm, hl
      complex x(ny,nz,nx)
      common /refl/ ih(100), g(2,100)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /kuse/ kuser1,kuser2,kuser3
c
      rewind jrel
      nblock = nex/100+1
      hm=262144*(hs+nx-1+256)+(512+1)*(2*256-1)
      hl=262144*(hs+256)
      do 100 h = 1, nx
      do 100 l = 1, nz
      do 100 k = 1, ny
      x(k,l,h) = cmplx(0.0,0.0)
  100 continue
c
      m=100
      do 500 ib=1,nblock
      if(ib.eq.nblock) m=mod(nex,100)
      if(m.eq.0) go to 500
      read(jrel) ih,g
      do 300 j = 1, m
      ihj=ih(j)
      if(ihj.gt.hm.or.ihj.lt.hl) go to 300
      h=ihj/262144-256
      l=ihj-262144*(h+256)
      k=l/512-256
      l=l-512*(k+256)-256
      noko = 0
      if (h.eq.0.and.l.eq.0.and.k.ne.0) noko = ny-k+1
      h = h - hs + 1
      if(k.lt.0)k=ny+k
      k = k + 1
      l = l + 1
      x(k,l,h) = cmplx(g(1,j),g(2,j))
      if (noko.ne.0) x(noko,l,h) = conjg(x(k,l,h))
  300 continue
  500 continue
      return
      end
c     ------------------------------------------------------------------
      subroutine write yn(x, ny, nz, nx, size)
      integer size, h, p, q, r
      complex x(ny,nz,nx)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common /pollo/ nuva(800),numr
c
      p = size
      q = 0
  100 r = q + 1
      if (q + p .gt. ny) p = ny - q
      q = q + p
      write (ifour) (((x(k,l,h), h = 1, nx), k = r, q), l = 1, nz)
      nuvar=nx*(q-r+1)*nz
      numr=numr+1
      nuva(numr)=nuvar
      if (q .lt. ny) go to 100
      return
      end
c     ------------------------------------------------------------------
      subroutine read hln(x, nx, nz, ny, hmax, lmax, size, skip, recs)
      integer hmax, size, skip ,recs, h, hl, hu, p, q
      complex x(nz,nx,ny)
c
c     reads in intermediate results for all h and l for a block of k.
c     the input is stored with l down the columns and h on the rows.
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
c
      common /pollo/ nuva(800),numr
      common /xdata/ duma(160000),vet(42000)
      complex vet
c
      lm = lmax + 1
      p = size
      hu = nx - hmax
      if (skip .le. 0) go to 200
      do 100 q = 1, skip
      numr=numr+1
      nuvar=nuva(numr)
Corig read (ifour)(vet(i),i=1,nuvar)
      read (ifour)(vet(1),i=1,nuvar)
  100 continue
c
c     read data for negative h
c
  200 if (hu + p .gt. nx) go to 400
      hl = hu + 1
      hu = hu + p
      read (ifour) (((x(l,h,k), h = hl, hu), k = 1, ny), l = 1, lm)
      numr=numr+1
      if (recs .le. 0) go to 200
      do 300 q = 1, recs
      numr=numr+1
      nuvar=nuva(numr)
      read (ifour)(vet(i),i=1,nuvar)
  300 continue
      go to 200
c
c     go pick up record which spans h = 0 if necessary
c
  400 if (hu .ne. nx) go to 700
      hu = 0
c
c     read records for positive h
c
  500 if (hu + p .gt. hmax + 1) p = hmax + 1 - hu
      hl = hu + 1
      hu = hu + p
      read (ifour) (((x(l,h,k), h = hl, hu), k = 1, ny), l = 1, lm)
      numr=numr+1
  550 if (hu .eq. hmax + 1) go to 800
      if (recs .le. 0) go to 500
      do 600 q = 1, recs
      numr=numr+1
      nuvar=nuva(numr)
      read (ifour)(vet(i),i=1,nuvar)
  600 continue
      go to 500
c
c     section to read a record spanning h = 0
c
  700 hl = hu + 1
      hu = hu + p - nx
      if (hu .gt. hmax + 1) hu = hmax + 1
      read (ifour) (((x(l,h,k), h = hl, nx), (x(l,h,k), h = 1, hu),
     .   k = 1, ny), l = 1, lm)
      numr=numr+1
      go to 550
c
c     pad the array with zero where there are no data, and fill in the
c     -h k 0 results by symmetry.
c
  800 do 900 h = 2, hu
      hl = nx + 2 - h
      do 900 k = 1, ny
      x(1,hl,k) = conjg(x(1,h,k))
  900 continue
      hl = hmax + 2
      hu = nx - hmax
      if (hu .lt. hl) go to 920
      do 910 l = 1, lm
      do 910 k = 1, ny
      do 910 h = hl, hu
      x(l,h,k) = cmplx(0.0,0.0)
  910 continue
c
  920 if (lm .ge. nz) go to 940
      p = lm + 1
      do 930 k = 1, ny
      do 930 l = p, nz
      do 930 h = 1, nx
      x(l,h,k) = cmplx(0.0,0.0)
  930 continue
c
c     end of input
c
  940 return
      end
c     ------------------------------------------------------------------
      subroutine outpufn(x, nz, nx, ny, y, nyt)
      real x(nz,nx,ny)
      integer star,blank,y,sec,xl,xu
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common /tran/ scale,mh(3),level,it4,xlim(3)
      common /tape/ inut(180),line(50)
      common / ureq1/ jpatt,jpunt(501),ksacc,jseteq,jumpp,jmpsie,nsec
      common /new/ ntime
      dimension ndx(200),ndz(200),nxyz(200,200),ndy(200)
      data star/2h**/,blank/4h    /,ncol/36/
c
c     put out scaled y-sections or x-sections or z-sections
c
c in the following file a section of the map is written if the directive
c 'map' is given in input
      if(it4.eq.0) go to 250
      nxm=min0(nx,int(xlim(1)*float(nx))+1)
      nym=min0(nyt,int(xlim(2)*float(nyt))+1)
      if(ny.le.nyt.and.nsec.ne.1)nym=min0(ny,int(xlim(2)*float(ny))+1)
      nzm=min0(nz,int(xlim(3)*float(nz))+1)
      asc=1000.0/float(nx)
c
  250 continue
c  put  out scaled y-sections
      if (nsec.eq.1) then
                       nn1=ny
                       nn2=nz
                       nn3=nx
                       nnm1=nxm
                       nnm2=nym
                       nnm3=nzm
                     end if
c  put  out scaled x-sections
      if (nsec.eq.2) then
                       nn1=nx
                       nn2=nz
                       nn3=ny
                       nnm1=nym
                       nnm2=nxm
                       nnm3=nzm
                     end if
c  put  out scaled z-sections
      if (nsec.eq.3) then
                       nn1=nz
                       nn2=nx
                       nn3=ny
                       nnm1=nym
                       nnm2=nzm
                       nnm3=nxm
                     end if
      do 100 k = 1, ny
      isum1=0
      do 150 j=1,nz
      do 130 i=1,nx
      xx=x(j,i,k)*scale
      inut(i)=0
      if(xx.ne.0.0) inut(i)=xx+sign(0.5,xx)
      isum1=isum1+inut(i)
  130 continue
      write(jrel)(inut(i),i=1,nx)
  150 continue
c     write(6,*) 'Section #',k,'  sum=',isum1
  100 continue
      asc=1000.0/float(nn3)
      do 900 k = 1, nn1
      sec = y + k - 1
      do 350 j=1,nn2
      do 330 i=1,nn3
           if (nsec.eq.1) then
                            xx=x(j,i,k)*scale
                            x(j,i,k)=xx
      else if (nsec.eq.2) then
                            xx=x(j,k,i)*scale
                            x(j,k,i)=xx
      else if (nsec.eq.3) then
                            xx=x(k,j,i)*scale
                            x(k,j,i)=xx
                          end if
  330 continue
  350 continue
      if (it4 .eq. 0) go to 900
      if (ntime .gt. 1) go to 900
      nec=1000.*(float(sec))/(float(nn1))+0.5
c     if(nec.le.470.or.nec.ge.510) go to 900
c     if(nec.ne.500) go to 900
      ntime=1
      do 351 i=1,200
      do 352 j=1,200
      ndx(i)=0
      ndz(i)=0
      nxyz(i,j)=0
  352 continue
  351 continue
      xu = 0
  450 xl = xu + 1
      xu = xu + ncol
      if(xu.gt.nnm1) xu=nnm1
      do 460 l=xl,xu
      inut(l)=float((l-1))*asc+0.5
      ndx(l)=inut(l)
  460 continue
      ndy(k)=nec
      ndyk=ndy(k)
      if(nsec.eq.1) write (it4,480) itle,nec
      if(nsec.eq.2) write (it4,481) itle,nec
      if(nsec.eq.3) write (it4,482) itle,nec
  480 format(1h1,7x,20a4,8x,12hsection  y =,i4/)
  481 format(1h1,7x,20a4,8x,12hsection  x =,i4/)
  482 format(1h1,7x,20a4,8x,12hsection  z =,i4/)
      if(nsec.eq.1) write (it4,500) (inut(nn),nn=xl,xu,2)
      if(nsec.eq.2) write (it4,501) (inut(nn),nn=xl,xu,2)
      if(nsec.eq.3) write (it4,502) (inut(nn),nn=xl,xu,2)
  500 format(8x,3hx =,i4,17i6)
  501 format(8x,3hy =,i4,17i6)
  502 format(8x,3hy =,i4,17i6)
      ilim = xl + 1
      write (it4,520) (inut(nn),nn=ilim,xu,2)
  520 format(12x,18i6)
      write(it4,530)
  530 format(/)
      do 700 i = 1,nnm3
      line(1)=float((i-1))*1000./float(nn2)+0.5
      ndz(i)=line(1)
      l = 1
      do 600 j = xl, xu
      l = l + 1
      inut(l)=blank
      if(nsec.eq.1) xx=x(i,j,k)
      if(nsec.eq.2) xx=x(i,k,j)
      if(nsec.eq.3) xx=x(k,i,j)
      line(l)=0
      if(xx.ne.0.0) line(l)=int(0.1*xx+sign(0.5,xx))
      if (iabs(line(l)) .gt. 99) line(l) = isign(99,line(l))
      nxyz(i,j)=line(l)
      if (10 * line(l) .gt. level) inut(l) = star
  600 continue
      if(nsec.eq.1) write (it4,630) (line(j), j = 1, l)
      if(nsec.eq.2) write (it4,631) (line(j), j = 1, l)
      if(nsec.eq.3) write (it4,632) (line(j), j = 1, l)
  630 format(4h z =,i4,4h *  ,36i3)
  631 format(4h z =,i4,4h *  ,36i3)
  632 format(4h x =,i4,4h *  ,36i3)
      write(it4,660) (inut(j),j=2,l)
  660 format(12x,36(1x,a2))
  700 continue
      if(xu.lt.nnm1) go to 450
      if(sec.ge.nnm2) it4=0
  900 continue
      return
      end
c-----------------------------------------------------------------------
c        special position library flow diagram
c
c --->-----+---------------------------+--------------->----
c        xspinb(*)                  kspecb
c        xflori       +-----------+----+-----+----------+
c                  xnuova       xelles      xtherm    xprint
c            +--------+---------+
c          xequi    xdist     xdepa
c                             xcmat
c
c   also available xwrifl to print information about float. origin
c                  xcmprp      to compress a string
c
c   (*) this subroutine is the only package-specific one
c
c**********************************************************************
c-----------------------------------------------------
      subroutine xspinb
c--
c-- initialization subroutine for special positions
c--
c-- soper  symmetry operators matrix
c-- centrt translation matrix for non primitive lattice
c-- aaa    constants to compute atoms distances
c-- noper  number of symmetri operators
c-- ncentr number of translation matricies
c-- icent  = 0  noncentrosymmetric space group
c--        = 1  centrosymmetric space group
c-- kpol   = 0  no floating origin
c--        > 0  floating origin (see subr. florig)
c-- jsys   crystal family
c-- lat    =  1   2   3   4   5   6   7   (erlangen)
c--           p   a   b   c   f   i   r
c-- lat    =  p   a   b   c   i   f   r   (multan)
c--           *** warning ***  multan notation is used
c-- indv,mpv  utility array
c-- jspini = +1 common /spec/ already filled  (crystals)
c-- jspini = +2 common /spec/ already filled  (sir)
c--        = -1 common /spec/ actually not initialized
c--        =  0  sir environment - do not mind about initialization
c-- ddmin  minimun distance to define a peak
c--        being in general position
      dimension kcentr(7),abc(3),ang(3)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent,
     *         kpol,jsys,lat,indv(32),mpv(64),jspini,ddmin,ncawu,ncwu
      common /erl/ kmat(48,3,3),tmat(48,3),nt(16),jsysx,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icentx,latx,s3s2,emme
     *          ,s3s2p
      common/rc/p(6),cx(9),dumm(9)
      dimension latxv(7)
Corig data latxv/1,2,3,4,6,5,7/
      data latxv/1,2,3,4,5,6,7/
c
      if (jspini.gt.0) return
c
c-- initialize output channels
c
      ncawu=lo
      ncwu =lo
c
c-- cell parameters, cent and lattice code needed
c
      lat=latxv(latx)
      icent=icentx
      jsys=jsysx
      do 10 i=2,6
   10 kcentr(i)=2
      kcentr(1)=1
Corig kcentr(5)=4
      kcentr(6)=4
      kcentr(7)=3
      do 20 i=1,3
         abc(i)=cx(i)
         ang(i)=cx(i+3)
   20 continue
      aaa(1)=abc(1)*abc(1)
      aaa(2)=abc(2)*abc(2)
      aaa(3)=abc(3)*abc(3)
      aaa(4)=2.0*abc(1)*abc(2)*cos(ang(3)*dtor)
      aaa(5)=2.0*abc(1)*abc(3)*cos(ang(2)*dtor)
      aaa(6)=2.0*abc(2)*abc(3)*cos(ang(1)*dtor)
c
      ncentr=kcentr(lat)
c
c-- at this point i need matricies to fill 'soper'
c
      noper=nsym
      do 15 k=1,nsym
      do 15 i=1,3
      soper(i,4,k)=tmat(k,i)
      do 15 j=1,3
      soper(i,j,k)=kmat(k,i,j)
   15 continue
c-- compute floating origin code
      call xflori
      jspini=2
      return
      end
code for xcmprp
c------------------------------------------------------------------
      subroutine xcmprp(string,lstri)
c
      character*(*) string
      character ib,string1*120
c
      ib=' '
      string1=ib
      k=len(string)
      j=1
      do 10 i=1,k
      if (string(i:i).ne.ib) then
                               string1(j:j)=string(i:i)
                               j=j+1
                             endif
   10 continue
      lstri=j-1
      string(1:lstri)=string1(1:lstri)
      if (j.le.k) then
                    do 20 i=j,k
   20               string(i:i)=ib
                  endif
      return
      end
c----------------------------------------------------------------------
      block data utiblk
c
c--utility tables initialization
c
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent,
     *         kpol,jsys,lat,indv(32),mpv(64),jspini,ddmin,ncawu,ncwu
      data centrt/
     * .0000,.0000,.0000,.0000,.0000,.0000,.0000,.0000,.0000,.0000,.0000
     *,.0000,.0000,.0000,.0000,.0000,.0000,.0000,.0000,.0000,.0000,.0000
     *,.0000,.5000,.5000,.5000,.5000,.6666,.0000,.5000,.0000,.5000,.5000
     *,.5000,.3333,.0000,.5000,.5000,.0000,.5000,.0000,.3333,.0000,.0000
     *,.0000,.0000,.0000,.0000,.3333,.0000,.0000,.0000,.0000,.0000,.5000
     *,.6666,.0000,.0000,.0000,.0000,.0000,.5000,.6666,.0000,.0000,.0000
     *,.0000,.0000,.5000,.0000,.0000,.0000,.0000,.0000,.0000,.0000,.0000
     *,.0000,.0000,.0000,.0000,.0000,.5000,.0000/
      data mpv/
     *        273,139537,140563, 65697, 16545,131857,135961,  2132,
     *      32852,  8977,  9498,  4875,  1290,  4362,  1291,  4378,
     *     131338,136458,   673,  8276, 43092, 82593,   140,    98,
     *      33890,  6284, 17506, 69772, 49250, 67724,139545,131859,
     *     140049,   785,   787, 17057, 66209,  8465,  8473, 41044,
     *      10324,131345,135450,132363,135434,132362,135947,140570,
     *       5386,   266, 82081, 34900,    84,   161, 71820, 50274,
     *      16482, 65676, 32866,  2188,  1122,  4236,  4889,  9491/
 
      data indv/1,2,2,4,4,2,2,4,4,2,3,3,4,4,6,6,
     *          2,2,2,2,2,2,3,3,3,3,3,3,3,3,2,2/
      data jspini,ddmin /-1 , 0.6 /
      end
code for xflori
c-----------------------------------------------------------------------
      subroutine xflori
c
c-- floating origin subroutine
c
c-- kpol code is computed to take
c-- into account floating origin.
c-- if kpol.eq.0 then no floating origin
c-- if kpol.ne.0 then the floating direction
c--                   corresponds to 1's in the code
c                     e.g.   kpol=001 float. origin along z
c                            kpol=100 float. origin along x
c
      dimension jfl(3)
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent,
     *         kpol,jsys,lat,indv(32),mpv(64),jspini,ddmin,ncawu,ncwu
      if (icent.eq.1) then
                        kpol=0
                      else
                        do 60 k=1,3
                          jfl(k)=0
                          do 50 i=1,noper
                            do 40 j=1,3
                              jfl(k)=jfl(k)+soper(j,k,i)
   40                       continue
   50                     continue
                          if (jfl(k).ne.noper) then
c--  non - floating direction
                                                 jfl(k)=0
                                               else
c--  floating direction
                                                 jfl(k)=1
                                               endif
   60                   continue
                        mult=100
                        kpol=0
                        do 70 i=1,3
                        kpol=kpol+jfl(i)*mult
                        mult=mult/10
   70                   continue
                      endif
      return
      end
code for kspecb
c----------------------------------------------------------------------
      function kspecb(newvet,xo,xn,key,itype,iser,khead,iactn)
c
c-- function to handle atoms in special position
c
c   return value
c          kspecb = +1 atom in general position
c                 = -1 atom in special position
c-- meaning of parameters
c     xo    = array containing original values for x,y,z,occ,u's,c-occ
c     xn    = array containing modified values for x,y,z,occ,u's,c-occ
c    key    = array containing conditions for      x,y,z,    u's,c-occ
c  itype    = type of atom
c   iser    = serial number
c  khead    =  0  heading for special position to be print
c           =  1  heading not to be printed
c     iactn =     action to be taken :
c           =  1  compute crystallographic occupation
c           =  2  generate key array and update x's and u's
c           =  3  print information
c    newvet = matrix containing information about 
c             the symmetry operators involved
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent,
     *         kpol,jsys,lat,indv(32),mpv(64),jspini,ddmin,ncawu,ncwu
      dimension xo(11),xn(11),key(10),newvet(48,3)
c
      do 10 i=1,9
   10 key(i)=i
      key(10)=1
      call xnuova(xo,xn,key,n,newvet,iser)
      kspecb=1
      if (key(10).gt.1) then
         kspecb=-1
         if (iactn.gt.1) then
            if (key(10).ne.1) then
                                call xelles(newvet,n,key)
                                call xtherm(newvet,n,key)
                              endif
             if (iactn.gt.2) call xprint(key,itype,iser,xn,khead)
                         endif
                        endif
c
      return
      end
code for xnuova
c------------------------------------------------------------------
      subroutine xnuova(xo,xn,key,nr,newvet,iser)
c--
c-- subroutines to recognize if a peak is in a special position.
c-- if it is very close to it, the peak is "moved" in it.
c--
c-- check if atoms are in special position
c-- computing the distance between an atom
c-- and its symmetry equivalents
c--
      dimension xo(11),xn(11),key(10),vet(2)
      dimension xeq(3),m(3,3),s(3),xb1(3),xb2(3),newvet(48,3)
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent,
     *         kpol,jsys,lat,indv(32),mpv(64),jspini,ddmin,ncawu,ncwu
c
      vet(1)= 1.0
      vet(2)=-1.0
      do 20 i=1,11
   20 xn(i)=xo(i)
      do 30 i=1,3
      xb1(i)=xo(i)
   30 xb2(i)=xo(i)
      ifin=icent+1
      nr=0
      do 50 kt=1,ncentr
        do 50 ifi=1,ifin
          coef=vet(ifi)
          do 50 k=1,noper
            if (k.eq.1.and.ifi.eq.1.and.kt.eq.1) go to 50
            call xequi(xb2,k,coef,xeq,kt)
            call xdist(xb2,xeq,d,s)
            if (d.le.ddmin) then
                              nr=nr+1
                              newvet(nr,3)=k*coef
                              do 40 j=1,3
                                xb1(j)=xb1(j)+xb2(j)+s(j)
   40                         continue
                            endif
   50 continue
      if (nr.ne.0) then
                do 70 l=1,nr
                   k=newvet(l,3)
                   coef=1.0
                   if (k.lt.0) then
                                 k=-k
                                 coef=-1.0
                               endif
                   do 60 ii=1,3
                      do 60 j=1,3
                         m(ii,j)=coef*soper(ii,j,k)
   60              continue
                   call xdepac(m,ind,inew)
                   newvet(l,1)=inew
                   newvet(l,2)=ind
   70           continue
                do 80 j=1,3
                   xb1(j)=xb1(j)/float(nr+1)
   80           continue
                else
                do 90 j=1,3
                   newvet(1,j)=1
   90           continue
                endif
c
      kcond=nr+1
      do 100 i=1,3
  100 xn(i)=xb1(i)
      xn(11)=1.0/float(kcond)
      key(10)=kcond
      return
      end
code for xequi
c--------------------------------------------------------------------
      subroutine xequi(xb2,k,coef,xeq,kt)
c--
c-- computes the symmetry equivalent of an atom
c--
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent,
     *         kpol,jsys,lat,indv(32),mpv(64),jspini,ddmin,ncawu,ncwu
      dimension xb2(3),xeq(3)
c
      do 10 l=1,3
      ktl=(kt-1)*3+l
      xeq(l)=soper(l,4,k)+centrt(lat,ktl)
      do 10 j=1,3
   10 xeq(l)=xeq(l)+xb2(j)*coef*soper(l,j,k)
      return
      end
code for xdist
c----------------------------------------------------------------------
      subroutine xdist(xb2,xeq,d,s)
c--
c-- subroutine used to compute the distance between
c-- an atom and its equivalent
c--
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent,
     *         kpol,jsys,lat,indv(32),mpv(64),jspini,ddmin,ncawu,ncwu
      dimension xeq(3),xb2(3),delta(8,3),dp(3),ds(3),s(3)
c
      do 20 i=1,3
         d=xeq(i)-xb2(i)
         dp(i)=d-int(d)
         if (dp(i).le.0.0) then
                           ds(i)=dp(i)+1.0
                           else
                           ds(i)=dp(i)-1.0
                           endif
   20 continue
      delta(1,1)=dp(1)
      delta(1,2)=dp(2)
      delta(1,3)=dp(3)
      delta(2,1)=dp(1)
      delta(2,2)=dp(2)
      delta(2,3)=ds(3)
      delta(3,1)=dp(1)
      delta(3,2)=ds(2)
      delta(3,3)=dp(3)
      delta(4,1)=dp(1)
      delta(4,2)=ds(2)
      delta(4,3)=ds(3)
      delta(5,1)=ds(1)
      delta(5,2)=dp(2)
      delta(5,3)=dp(3)
      delta(6,1)=ds(1)
      delta(6,2)=dp(2)
      delta(6,3)=ds(3)
      delta(7,1)=ds(1)
      delta(7,2)=ds(2)
      delta(7,3)=dp(3)
      delta(8,1)=ds(1)
      delta(8,2)=ds(2)
      delta(8,3)=ds(3)
      dimi=99999.9
      do 40 i=1,8
         d2=delta(i,1)*delta(i,1)*aaa(1)
     &     +delta(i,2)*delta(i,2)*aaa(2)
     &     +delta(i,3)*delta(i,3)*aaa(3)
     &     +delta(i,1)*delta(i,2)*aaa(4)
     &     +delta(i,1)*delta(i,3)*aaa(5)
     &     +delta(i,2)*delta(i,3)*aaa(6)
         d=sqrt(d2)
         if (d.lt.dimi) then
                        dimi=d
                        do 30 j=1,3
                           s(j)=delta(i,j)
   30                   continue
                        endif
   40 continue
      d=dimi
      return
      end
code for xdepac
c-----------------------------------------------------------------------
      subroutine xdepac(m,ind,inew)
c--
c-- using a code associated to the matrix in use
c-- finds out which kind of symmetry operator
c-- is involved
c--
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent,
     *         kpol,jsys,lat,indv(32),mpv(64),jspini,ddmin,ncawu,ncwu
      dimension m(3,3)
c
      call xcmat(m,mp)
c
      in=0
      do 10 i=1,64
         if (mp.eq.mpv(i)) in=i
   10 continue
c
      if (in.eq.0) then
                      write(ncwu,*) 'stop speclib - xdepac '
                      write(ncwu,'(3i4)') ((m(i,j),j=1,3),i=1,3)
                      write(ncwu,'(i10)')      mp
                      stop 'speclib - xdepac '
                    endif
c
      ind=in
      inw=1
      if (in.gt.32) then
                      inw=-1
                      in=in-32
                     endif
      inew=inw*indv(in)
      return
      end
code for xcmat
c------------------------------------------------------------------
      subroutine xcmat(m,mp)
c--
c-- this subroutine is used to transform a rotational
c-- matrix in a unique number to use like a pointer
c-- to recognize which kind of operator is involved
c-- ( mirror , 2-fold axis etc. )
c--
      dimension m(3,3)
c
      mp=0
      iexp=-1
      do 10 i=1,3
         do 10 j=1,3
            iexp=iexp+1
            if (m(i,j).ge.0) then
                               mp=mp+m(i,j)*2**iexp
                             else
                               mp=mp+2**iexp+2**(iexp+9)
                             endif
   10 continue
      return
      end
code for xwrifl
c----------------------------------------------------------------------
      subroutine xwrifl
c
c-- write information about freely floating origin
c
      character*3 xyz,xyzfr
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent,
     *         kpol,jsys,lat,indv(32),mpv(64),jspini,ddmin,ncawu,ncwu
c
      kdummy=kpol
      xyz='xyz'
      do 10 i=1,3
      j=4-i
      ipr=mod(kdummy,10)
      kdummy=kdummy/10
      xyzfr(j:j)=' '
      if (ipr.eq.1) xyzfr(j:j)=xyz(j:j)
   10 continue
      if (kpol.ne.0) write(ncwu,30) xyzfr
   30 format(/' *** warning *** freely floating origin along ',a3,/)
      return
      end
code for xelles
c------------------------------------------------------------------
      subroutine xelles(newvet,n,key)
c
c-- this subroutine computes the
c-- conditions for least squares shifts
c
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent,
     *         kpol,jsys,lat,indv(32),mpv(64),jspini,ddmin,ncawu,ncwu
 
      integer xeq(3),xyz(3),xyo(3),iflc(3),key(10)
      integer mult(3),newvet(48,3)
c
      nn=n+1
      mult(1)=-1
      mult(2)= 1
      mult(3)= 2
      xyo(1)=3
      xyo(2)=11
      xyo(3)=13
      do 10 i=1,3
         xyz(i)=xyo(i)
   10 continue
      do 30 m=1,n
         coef=1.0
         k=newvet(m,3)
         if (k.lt.0) then
                       k=-k
                       coef=-1
                     endif
         do 20 l=1,3
            xeq(l)=0
            do 20 j=1,3
   20          xeq(l)=xeq(l)+xyo(j)*soper(l,j,k)*coef
         do 25 j=1,3
            if (xyz(j).ne.0) then
                               xyz(j)=xyz(j)+xeq(j)
                             endif
   25 continue
   30 continue
      ifl=0
      do 35 i=1,3
      if (xyz(i).ne.0) then
                         if (mod(xyz(i),nn).ne.0) ifl=1
                       endif
   35 continue
      if (ifl.eq.0) then
                      do 38 i=1,3
   38                 xyz(i)=xyz(i)/nn
                    endif
c
      do 40 i=1,3
         iflc(i)=0
   40 continue
      k=0
      do 60 i=1,3
      if (xyz(i).ne.0) then
      if (k.eq.0) then
                    k=1
                    if (xyz(i).lt.0) then
                                       do 50 j=1,3
                                          xyz(j)=-xyz(j)
   50                                  continue
                                     endif
                  endif
                  endif
   60 continue
      do 110 i=1,2
         if (iflc(i).eq.0) then
            if (xyz(i).ne.0) then
               k=1
               ifl2=0
               do 80 j=i+1,3
                  ifl1=0
                  do 70 l=1,3
                     if (xyz(i)*mult(l).eq.xyz(j)) then
                                                     iflc(j)=mult(l)
                                                     iflc(i)=1
                                                     ifl1=1
                                                   endif
                     if (ifl1.eq.0) then
                     if (xyz(i).eq.xyz(j)*mult(l)) then
                                                     iflc(i)=mult(l)
                                                     iflc(j)=1
                                                     ifl1=1
                                                   endif
                                    endif
   70             continue
               ifl2=ifl2+ifl1
   80          continue
                  if (ifl2.ne.0) then
                                  l=0
                                  do 90 j=1,3
                                     if (iflc(j).ne.0) then
                                                         if (l.eq.0) l=j
                                                       endif
   90                             continue
                                  do 100 j=1,3
                           if (iflc(j).ne.0) xyz(j)=xyo(l)*iflc(j)
  100                             continue
                                 endif
                             endif
                       endif
  110 continue
      do 130 i=1,3
         ifl=0
         if (xyz(i).ne.0) then
                          do 120 j=1,3
                             do 120 k=1,3
                                if (xyz(i).eq.xyo(j)*mult(k)) ifl=1
  120                     continue
                          if (ifl.eq.0) xyz(i)=xyo(i)
                          endif
  130 continue
      do 150 j=1,3
         if (xyz(j).ne.0) then
            do 140 k=1,3
                    if (xyz(j).eq.xyo(k))   then
                                              xyz(j)=k
               else if (xyz(j).eq.2*xyo(k)) then
                                              xyz(j)=20+k
               else if (xyz(j).eq.-xyo(k))  then
                                              xyz(j)=-k
                                             endif
  140       continue
         endif
  150 continue
      do 155 i=1,3
        ix=xyz(i)
        ifl=0
        if (ix.lt.0) then
                       do 153 j=1,3
                          if (xyz(j).eq.-ix) ifl=1
  153                  continue
                       if (ifl.eq.0) xyz(i)=-xyz(i)
                     endif
  155 continue
      do 160 i=1,3
  160 key(i)=xyz(i)
      if (key(3).eq.23.or.key(3).eq.-3) key(3)=3
      return
      end
code for xprint
c----------------------------------------------------------------------
      subroutine xprint(key,itype,iser,xn,khead)
c
c-- print symmetry restrictions on atomic parametrs
c
c--   key  array containing symmetry restrictions
c   itype  atom type (hollerith*4)
c    iser  serial
c      xn  array containing values for atomic parameters
c
      character line*42,keyc(9)*2
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent,
     *         kpol,jsys,lat,indv(32),mpv(64),jspini,ddmin,ncawu,ncwu
      character cbuff*124
      common /atpos/ cbuff
      dimension key(10),xn(11)
      data keyc/' x',' y',' z','11','22','33','23','13','12'/
c
      k=1
      mm=5
      do 80 j=1,9
      if (j.le.4) then
                    mm=4
                  else
                    mm=5
                  endif
       kj=key(j)
       l=k+5
       if (kj.ge.0) then
            if (kj.eq.0) then
                           write(line(k:l),'(5h  0  )')
       else if (kj.le.j) then
                           write(line(k:l),'(1h ,a2,3h   )') keyc(kj)
       else if (kj.gt.9) then
            if (kj.gt.20) then
                          kj=kj-20
                          write(line(k:l),'(a2,3h*2 )') keyc(kj)
                          else
                          kj=kj-10
                          write(line(k:l),'(a2,3h/2 )') keyc(kj)
                          endif
       else if (kj.lt.j) then
                           write(line(k:l),'(1h ,a2,2h  )') keyc(kj)
                         endif
                    else
                      kj=-kj
                      if (j.le.3) then
                          write(line(k:l),'(2h -,a1,2h  )')keyc(kj)(2:2)
                                  else
                          write(line(k:l),'(1h-,a2,2h  )') keyc(kj)
                                  endif
                    endif
       k=k+mm
   80 continue
c
      if (jspini.eq.1) then
c
c-- crystals output 
c
         if (khead.eq.0) then
                           write(ncwu,100)
                           khead=1
  100 format(
     *' type serial    symmetry restrictions on atomic parameters')
                         endif
         write(ncwu,200) itype,iser,line
  200 format(2x,a4,i4,4x,a42)
                       else
c
c-- sir output
c
         write(cbuff(47:124),300) (xn(i),i=1,3),xn(11),line
c 300 format(1h+,45x,3f7.3,f8.4,1x,a42)
  300 format(3f7.3,f8.4,1x,a42)
                       endif
      return
      end
code for xtherm
c-----------------------------------------------------------------------
      subroutine xtherm(newvet,nr,key)
c
c-- this subroutine computes the conditions for
c-- thermal parameters according to:
c
c           w.j.a.m. peterse and j.h. palme
c           acta cryst. (1966). 20, 147
c
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent,
     *         kpol,jsys,lat,indv(32),mpv(64),jspini,ddmin,ncawu,ncwu
 
      integer newvet(48,3),ivet(48),s,q(3,3),binv(9,6),ijt(6,2),itt(6)
      integer q12,q13,q23,vterm(6),bin1(6,6),key(10)
c
      do 10 i=1,6
         vterm(i)=99
   10 continue
      itt(1)=1
      itt(2)=5
      itt(3)=9
      itt(4)=6
      itt(5)=3
      itt(6)=2
      do 18 k=1,6
      ict=0
      do 15 i=1,3
      do 15 j=1,3
      ict=ict+1
      if (ict.eq.itt(k)) then
                           ijt(k,1)=i
                           ijt(k,2)=j
                         endif
   15 continue
   18 continue
      ivet(1)=1
      do 20 i=1,nr
         ivet(i+1)=newvet(i,3)
   20 continue
      n=nr+1
      kk=0
      do 50 i=1,3
         do 50 j=1,3
            do 30 k=1,3
               do 30 l=1,3
                  q(k,l)=0
                  do 30 js=1,n
                     coef=1.0
                     s=ivet(js)
                     if (s.lt.0) then
                                   s=-s
                                   coef=-1
                                 endif
                     q(k,l)=q(k,l)+soper(i,k,s)*soper(j,l,s)
   30             continue
         q12=q(1,2)+q(2,1)
         q13=q(1,3)+q(3,1)
         q23=q(2,3)+q(3,2)
         kk=kk+1
         do 40 k=1,3
            binv(kk,k)=q(k,k)
   40    continue
         binv(kk,4)=q12
         binv(kk,5)=q13
         binv(kk,6)=q23
   50 continue
      do 60 k=1,6
         isk=0
         i=ijt(k,1)
         j=ijt(k,2)
         kk=itt(k)
         do 60 l=1,6
            bin1(k,l)=binv(kk,l)
   60 continue
      if (jsys.eq.5) then
                       do 70 i=4,6
                          do 70 l=1,6
                             bin1(i,l)=2*bin1(i,l)
   70                  continue
                     endif
      do 90 i=1,6
         ki=ijt(i,1)
         kj=ijt(i,2)
         ifl=0
         do 80 j=1,6
            if (bin1(i,j).ne.0) ifl=1
   80    continue
         if (ifl.eq.0) vterm(i)=0
   90 continue
      kk=1
      do 120 i=1,5
         ich=0
         if (vterm(i).eq.99) then
                               do 110 k=i+1,6
                                     do 110 is=-1,1,2
                                      do 110 js=0,1
                                        jsc=mod(js+1,2)
                                        do 110 ls=0,1
                                        lsc=mod(ls+1,2)
                                        mi=ls*2**js+lsc
                                        mk=ls*2**jsc+lsc
                                        ifls=0
                                        do 100 j=1,6
                                           ibi=bin1(i,j)*mi
                                           ibk=bin1(k,j)*is*mk
                                           if (ibi.ne.ibk) ifls=1
  100                                   continue
                                        if (ifls.eq.0) then
                                            if (ich.eq.0) kk=kk+1
                                            ich=1
                                            vterm(i)=kk*mk
                                            vterm(k)=kk*is*mi
                                            endif
  110                          continue
                               if (vterm(i).eq.99) vterm(i)=1
                             endif
  120 continue
      if (vterm(6).eq.99) vterm(6)=1
      jpreva=0
      jprevb=0
      do 150 i=1,6
         vterm(i)=6-vterm(i)
               if (vterm(i).eq.0) then
                                    if (jprevb.eq.0) then
                                                 vterm(i)=20+i
                                                 jprevb=i
                                                else
                                                  vterm(i)=20+jprevb
                                                endif
          else if (vterm(i).eq.3) then
                                    if (jprevb.eq.0) then
                                                  vterm(i)=i
                                                  jprevb=i
                                                else
                                                  vterm(i)=jprevb
                                                endif
          else if (vterm(i).eq.4) then
                                    if (jpreva.eq.0) then
                                                  vterm(i)=i
                                                  jpreva=i
                                                else
                                                  vterm(i)=jpreva
                                                endif
          else if (vterm(i).eq.5) then
                                    vterm(i)=i
          else if (vterm(i).eq.6) then
                                    vterm(i)=0
          else if (vterm(i).eq.9) then
                                    if (jprevb.eq.0) then
                                                  vterm(i)=-i
                                                  jprevb=i
                                                else
                                                  vterm(i)=-jprevb
                                                endif
                                  endif
  150 continue
      do 170 j=4,9
      i=j-3
      jv=vterm(i)
      if (jv.ne.0) then
         if (jv.le.9) then
                        jv=jv+3*isign(1,jv)
                      else
                        jv=(mod(jv,20)+3)+20
                      endif
                   endif
  170 key(j)=jv
      if (key(9).le.6.and.key(9).ge.4) key(9)=key(9)+10
      return
      end
c----------------------------------------------------------------------
      block data utabli
c
c--utility tables initialization
c
      character lsqt(28)*6,itrt(30)*12,sitin(85)*6
      integer jsiti(194),cvet(194),vcoll(25,2),mpv(64),ksiti(64)
      common /tab1/ jsiti,vcoll,cvet,ksiti,mpv
      common /tab2/ sitin,lsqt,itrt
      common /tab3/ ijt(6,2),iit(6),numpr(29),ktlsq(28)
      common /tab4/ lsqv(28),ktlsn(28)  
      data ijt/1,2,3,1,1,2,1,2,3,2,3,3/
      data iit/1,5,9,2,3,6/
      data numpr/   555656,555566,555665,555666,445566,445533,445539,
     *445666,544665,544335,544935,544666,545456,545466,545430,445466,
     *444666,444333,555555,455403,455465,455466,444393,444339,444399,
     *454359,454353,454666,454656/
      data ktlsq/535050,506150,505063,506163,535063,536150,505050,
     *           535350,534750,535363,534763,536163,535650,565350,
     *           535663,565363,506161,506139,535053,535047,536139,
     *           536161,536153,536147,535353,535347,534753,534747/
      data ksiti/1219,103,115,112,112,201,220,228,228,302,316,316,308,
     *308,316,316,807,906,1711,1926,2027,1810,2518,2518,2824,2824,2723,
     *2723,2625,2625,1421,1313,719,403,1515,712,712,501,1620,728,728,
     *602,716,716,708,708,716,716,1107,1006,2111,2426,2327,2210,718,718,
     *724,724,723,723,725,725,421,513/
      data mpv/
     *        273,139537,140563, 65697, 16545,131857,135961,  2132,
     *      32852,  8977,  9498,  4875,  1290,  4362,  1291,  4378,
     *     131338,136458,   673,  8276, 43092, 82593,   140,    98,
     *      33890,  6284, 17506, 69772, 49250, 67724,139545,131859,
     *     140049,   785,   787, 17057, 66209,  8465,  8473, 41044,
     *      10324,131345,135450,132363,135434,132362,135947,140570,
     *       5386,   266, 82081, 34900,    84,   161, 71820, 50274,
     *      16482, 65676, 32866,  2188,  1122,  4236,  4889,  9491/
      data jsiti/0,11417,16666,16906,17170,17434,17674,17938,20826,21074
     *,21458,21722,21850,22098,22490,22738,34570,34578,34586,16667,16907
     *,17171,17435,17675,17939,33059,33315,33571,34571,34579,34587,34595
     *,67363,-16668,-16908,17172,17436,17676,17940,18492,18740,18996
     *,19260,33316,33572,33580,33604,34580,34596,34604,34612,34620,34628
     *,34860,35116,66372,67364,67372,-67396,67404,132932,16765,17061
     *,17173,17581,17773,17941,18493,18741,18997,19261,19821,20141,20349
     *,20645,25477,33141,33461,33581,33653,33717,34581,34605,34613,34621
     *,34669,34677,34685,34725,34733,34741,34861,35117,36213,36533
     *,-50053,-51077,67445,99205,-100229,198533,16670,16910,18494,18742
     *,20830,21078,21462,21726,31126,31438,31678,31942,33102,33518,34590
     *,34598,34606,34638,34790,-34798,34862,35118,37198,37454,37870
     *,38126,-51094,-51134,-51142,-51150,55702,56014,56254,56518,65894
     *,66278,66374,-67398,67406,-67430,-67558,67566,-100238,100246
     *,100286,100294,100302,132934,132966,133094,-198542,395150,16767
     *,17063,18495,25479,-51079,18329,17678,17438,17942,33062,33318
     *,33574,33126,33510,33606,18998,19262,22102,22494,22742,17174,67509
     *,67373,67366,34574,34582,67374,34588,34572,33582,34662,34630,19263
     *,20351,34623,34687,34727,50055,100231,20647,21854/
c
      data lsqt/' x 0 0',' 0 y 0',' 0 0 z',' 0 y z',' x 0 z',
     *          ' x y 0',' 0 0 0',' x x 0',' x-x 0',' x x z',
     *          ' x-x z',' x y z',' x2x 0','2x x 0',' x2x z',
     *          '2x x z',' 0 y y',' 0 y-y',' x 0 x',' x 0-x',
     *          ' x y-y',' x y y',' x y x',' x y-x',' x x x',
     *          ' x x-x',' x-x x',' x-x-x'/
      data itrt/
     *' - - - 0 - 0' , ' - - - - 0 0' , ' - - - 0 0 -' , ' - - - 0 0 0',
     *' a a - - 0 0' , ' a a - - b b' , ' a a - - b-b' , ' a a - 0 0 0',
     *' - a a 0 0 -' , ' - a a b b -' , ' - a a-b b -' , ' - a a 0 0 0',
     *' - a - a - 0' , ' - a - a 0 0' , ' - a - a b2b' , ' a a - a 0 0',
     *' a a a 0 0 0' , ' a a a b b b' , ' - - - - - -' , ' a - - a2b b',
     *' a - - a 0 -' , ' a - - a 0 0' , ' a a a b-b b' , ' a a a b b-b',
     *' a a a b-b-b' , ' a - a b --b' , ' a - a b - b' , ' a - a 0 0 0',
     *' a - a 0 - 0' , ' ? ? ? ? ? ?'/
c
      data sitin/        'h.y.s.'
     *,'1     ','-1    ','2..   ','.2.   ','..2   ','..2   ','..2   '    8
     *,'..2   ','..2   ','m 011 ','m 101 ','m -101','m 01-1','m..   '   15
     *,'.m.   ','..m   ','2/m.. ','.2/m. ','..2/m ','222   ','222.  '   22
     *,'222.. ','2mm   ','m2m   ','mm2   ','mmm   ','2.mm  ','2.22  '   29
     *,'m.2m  ','m.m2  ','m.mm  ','4..   ','-4..  ','422   ','42.2  '   36
     *,'4m2   ','-42m  ','-4m2  ','4m.m  ','-42.m ','-4m.2 ','4/m.. '   43
     *,'4/mmm ','4/mm.m','3..   ','-3..  ','.3.   ','32.   ','3.2   '   50
     *,'.32   ','3m.   ','.3m   ','.-3m  ','-3m.  ','-3.m  ','.-3m  '   57
     *,'m-3.  ','m-3m  ','6..   ','-6..  ','6mm   ','-6m2  ','6/m.. '   63
     *,'622   ','6/mmm ','23.   ','-43m  ','432   ','mmm.  ','2mm.  '   71
     *,'m2m.  ','.-3.  ','32    ','3.    ','.2    ','4mm   ','3.m   '   78
     *,'-3m   ','3m    ','mm2.. ','mmm.. ','.m    ','.2/m  ','-3.   '/
      data cvet/1, 2, 4, 5, 6,15,16,17, 7,10, 8, 9,11,14,13,12,19,20,18,
     * 4, 5, 6,15,16,17,24,25,26,19,20,18,21,27, 5, 5, 4,16,16,15, 6, 6,
     *17,17,72,71,28,33,18,22,29,20,20,34,30,30,77,70,32,38,32,44, 5, 5,
     * 4,17,17,15, 5, 6,17,16, 6, 6,16,16,46,25,25,24,24,24,18,21,20,19,
     *20,21,19,19,20,21,25,26,26,26,49,50,27,62,55,66, 4, 4, 6, 6, 6, 6,
     * 6, 6,48,48,48,48,28,28,18,23,29,29,34,29,31,31,31,31,31,31,51,51,
     *73,51,53,53,53,53,40,40,40,43,32,41,41,32,54,54,54,54,54,45,45,45,
     *68,59,76,76,76,75,74, 3,15,15,15,81,81,81,33,33,33,17,17,17,17,17,
     * 4,27,27,82,18,18,32,19,19,28,34,34,83,83,84,84,84,80,79,83,17/
c
      data vcoll/64208,56006,56106,44208,-53312,53306,53006,63012,-53006
     *,44008,42002,62004,-63324,-44108,64024,-63006,-64108,63006,64008,
     *56412,56012,-56112,64624,-73006,73006,42,60,61,39,79,80,74,67,47,
     *35,5,29,58,43,69,73,43,51,36,63,65,64,68,85,74/
      data lsqv/    111010,101210,101013,101213,111013,111210,101010,
     *111110,110910,111113,110913,111213,113110,311110,113113,311113,
     *101212,101208,111011,111009,111208,111212,111211,111209,111111,
     *111109,110911,110909/
      data ktlsn/0144,0414,0441,0411,0141,0114,0444,
     *           1224,1204,1221,1201,0111,1234,1324,
     *           1231,1321,2422,2420,1242,1240,2120,
     *           2122,1212,1210,1222,1220,1202,1200/
      end
c-----------------------------------------------------------------------
      subroutine gpsie(numb,error,dalfa,nexp)
c
c++ sostituito nreft con npse in sflxx
c++ spostato nexp=.. dopo 4060
c
c-- subroutine to determine phases of not so strong
c-- reflections
      common /xdata/ ihkl(31000),e(31000),iphaz(31000),iphb(31000)
     *              ,wt(31000),duma(5000),dummpc(84000)
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/xfour/ jtype,iprint,numero,iw,ilx ,imx ,iv  ,ix
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      dimension mat(3,8000),vet(12),ivet(12),iphi(300),itype(300)
Corig dimension cost(400)
      dimension cost(360)
      equivalence (sint(91),cost(1))
      equivalence (vet(1),ivet(1))
c
c     cutoff=5.0
      cutoff=0.0
      iprea=0
      if (iprin.gt.2) then
                        write(lo,26)
                        write(lo,28)(i,wt(i),i=1,numb)
                      endif
 26   format(//10x,'tabella pesi'/)
 28   format(7(3x,i5,f9.2))
      call srlin (24,lsn,lfw,llw,lpb,ll)
c-- check if list 24 exists
      if(lfw) 4500,4500,4002
 4002 if (iprin.gt.2) write(lo,4005)
 4005 format(//,'  lettura  relazioni psi-e       ',/)
c**** call sub. lettura lista 24:  relazioni psi-e
      call sflxx(iprea,24,ntot,ntrp,npse,nxxe,iccd,mat)
      if(ntrp.eq.0) goto 4500
      numb0=numb
c**** call sub. lettura preambolo lista 7
      call ysfl07(nrifl,mmm,mmmz,npseud,iy)
      if (iprin.gt.2) write(lo,150)nrifl,mmm,mmmz
  150 format(/,10x,' num. rif. tot. ',i5,5x,' num. rif. forti ',i5,5x,
     * ' num. rif. deboli ',i5,/)
      if (iprin.gt.2) write(lo,4010) ntot,npse
 4010 format('   n. relazioni psi-e  = ',i6,' formate da',i4,' riflessi'
     * ,' con e<e(min)')
      ifin=numb+npse
      do 160 i=numb+1,ifin
  160 iphaz(i)=0
      ic=0
      do 190 i=1,ifin
c**** call sub. lettura lista 7  per riflessi psi-e
      call snr07(vet)
      if(i.le.numb) go to 190
      ih=ivet(1)
      ik=ivet(2)
      il=ivet(3)
      e(i)=vet(4)
      ihkl(i)=262144*ih +512*ik +il +131328
      wt(i)=0.0
      iph=mod(ivet(8),2**15)
      ic=ic+1
      itype(ic)=mod(iph,32)
      iph=iph/32
      iphi(ic)=iph
  190 continue
      wgt=0.0
      snum=0.0
      sden=0.0
      snu=0.0
      sde=0.0
      alfmed=0.0
      var=0.0
      nctr=0
      tom=0.0
      error=0.0
      dalfa=0.0
      numb1=0
      if (iprin.gt.2) write(lo,200)
200   format(////10x,'lista riflessi psi-e con fasi determinate',//
     * '    num  kode  ( h  k  l )     e       w     ',
     * ' type  phi(p) phi(t)   diff  ncontr   alpha  alf(g)  alf(w)'/)
      ntr1=ntrp+1
      do 4050 i=1,ntr1
      if(i.eq.ntr1) then
                    kod1=9999
                    go to 4035
          endif
      call unpak3(mat(1,i),lod1,lod2,ifaz)
      call unpak3(mat(2,i),lod3,ig,ifaz)
      call unpak3(mat(3,i),kod,igg,idum)
      kod1=iabs(lod1)
      kod2=iabs(lod2)
      kod3=iabs(lod3)
c  kod1,kod2,kod3 = serial number of reflections
c  ig,ifaz = g*100,phase shift
      g=abs(float(ig)*0.01)
      if (i.eq.1) kod1o=kod1
4035  if (kod1.ne.kod1o) then
c  parte relativa ai riflessi speciali
      ic=kod1o-numb0
      if(itype(ic).eq.1) go to 4045
      idv = 15*mod(iabs(itype(ic))-1,12) + 1
      ssn=sint(idv)
      ccs=cost(idv)
      t2 = snum*ssn + sden*ccs
      snum = t2*ssn
      sden = t2*ccs
      t2 = snu*ssn + sde*ccs
      snu = t2*ssn
      sde = t2*ccs
 4045 continue
                         alfw=snum*snum+sden*sden
                         alfg=snu*snu+sde*sde
                         if (alfw.lt.0.0001) then
                         if (iprin.gt.2) 
     *                   write(lo,4046)kod1o,kod2,wt(kod2),kod3,wt(kod3)
 4046 format(5x,'reflection ',i5,' has no sign. contributors,   k2 ='
     * ,i5,'  wt(k2)=',f10.3,'  k3=',i5,'  wt(k3)=',f10.3/)
                             go to 3090
                           endif
                         pha=atan2(snum,sden)*rtod
                         aiu=sqrt(alfg)
                         aiu1=sqrt(alfw)
                         if(nctr.lt.4) go to 3080
                         if (var.lt.0.001) go to 3080
                         if(aiu.le.alfmed) go to 3080
                         d3=(aiu-alfmed)*(aiu-alfmed)
                         d2=d3/var
                         wh=exp(-d2)**(1./3.)
                         if(wh.lt.0.2) wh=0.2
                         d2=alfmed*wh
                         alfw=d2*d2




 3080                    alf=sqrt(alfw)





c3080                    alf=sqrt(alfg)



                         wgt=bes(alf)
                         wgt=wgt*wgt
                         if (aiu.lt.cutoff) wgt=0.0
                         ip=pha+sign(0.5,pha)
                         ip=mod(ip+3600,360)
                         if(ip.eq.0) ip=360
                         iphaz(kod1o)=ip
                 ih=ihkl(kod1o)/262144
                 ik=mod(ihkl(kod1o),262144)
                 il=mod(ik,512)-256
                 ik=ik/512-256
c                   tom=tom+alf
                    tom=tom+wgt
                    icb=iabs(ip-iphi(ic))
                    icb=min0(icb,360-icb)
                    t2=icb
                    error=error+t2
c                   dalfa=dalfa+t2*alf
                    dalfa=dalfa+t2*wgt
                    numb1=numb1+1
      if (iprin.gt.2) write(lo,185) numb1,kod1o,ih,ik,il,e(kod1o),
     *              wgt,itype(ic),
     *              iphi(ic),ip,icb,nctr,alf,aiu,aiu1,alfmed
  185 format(2i6,'*  (',3i3,')',2f8.2,5i8,4f8.2)
 3090                    snum=0.0
                         wt(kod1o)=wgt
c                        wt(kod1o)=wgt**2
                         if(kod1.gt.9000) go to 4060
                         sden=0.0
                         snu=0.0
                         sde=0.0
                         alfmed=0.0
                         var=0.0
                         kod1o=kod1
                         nctr=0
                         wgt=0.0
                         endif
          a1=bes(g)
          aa1=wt(kod2)*wt(kod3)*a1
          weig=besinv(aa1)
          idv=-iphaz(kod2)*isign(1,lod2) -
     *         iphaz(kod3)*isign(1,lod3) - 15*ifaz
          idv = mod(idv+36000,360) + 1
          snum=snum+weig*sint(idv)
          sden=sden+weig*cost(idv)
          snu=snu+g*sint(idv)
          sde=sde+g*cost(idv)
          alfmed=alfmed+g*a1
          d2=1.0-(2.0/g)*a1
          d3=1+d2-2.0*a1*a1
          var=var+g*g*d3
          nctr=nctr+1
 4050 continue
 4060 nexp=numb1
      if(numb1.gt.0) error=error/float(numb1)
      if(tom.gt.0.0001) dalfa=dalfa/tom
      numb1=numb+1
      do 4200 i=numb1,ifin
      e(i)=e(i)*wt(i)
 4200 continue
      numb=ifin
      nexp=ifin-numb1+1
c4500 stop
 4500 return
      end
c-----------------------------------------------------------------------
c     output peak heights, peak coordinates and cluster numbers
c     and special positions information
      subroutine outpea(host,izpk,kaction)
      character host*80,specie*2,cbuff*124
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),nno(8),nk,nat,f(9),nalf(8)
      common /atoms/ x(5,200),nz(200),idumx(21)
      common /atomo/ xyzo(5,200),nzo(200),dold(400)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      common /sdir/ dm,npc,nproj,nojoin
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common /atpos/ cbuff
      dimension xo(11),xn(11),keyx(10),newvet(48,3),izpk(500)
c
c-- label and interpret peaks
c
      if (jrecyc.eq.0) iprin=3
c
              if (krecy.eq.0) then
                                do 600 i=1,nats
  600                           izpk(i)=0
                                call maincl(izpk,kaction,iprin)
                                if (izpk(1).eq.-99999) izpk(1)=100
      else if (krecy.eq.1000) then
                                kaction=3
                                do 650 i=1,nats
  650                           izpk(i)=0
                                call maincl(izpk,kaction,iprin)
      else if (kaction.eq.5) then
                                kaction=5
      else if (krecy.ne.2000) then
                                jlig=nk
                                if (nno(1).eq.1) jlig=nk-1
                                jlig=jlig*100+1
                                do 800 i=1,nats
  800                           izpk(i)=jlig
                              endif
C     if (jrest.ne.1) then
C                       if (jrecyc.eq.100) then
C                                            errem=erreo
C                                            erre =erreo
C                                          else
C                                            errem=erre
C                                            erreo=erre
C                                          endif
C                       rfac=erreo*100.0
C                     else
C                       errem=erre
C                       rfac=erre*100.0
C                     endif
           if (jrest.eq.0) then
                        if (jrecyc.eq.100) then
                                             errem=erreo
                                             erre =erreo
                                           else
                                             errem=erre
                                             erreo=erre
                                           endif
      else if (jrest.eq.1) then
                             errem=erre
      else if (jrest.eq.2) then
                             erre=erreo
                             errem=erre
                           endif
      if (iprin.le.1) go to 915
      write(lo,810) itle
  810 format(//,1h , 79('+'),//,26x,
     1 '***   Output section  ***',//,2x,20a4,//)
      rfac=erre*100.0
      if (rfac.gt.0.0) write(lo,820) maxcyc,rfac
  820 format(/,' After ',i2,'  cycles final residual value ='
     *       ,f7.2,'% ',4i4,///)
      call xwrifl
      khead=0
      iactn=2
      ifspec=0
      do 840 i=1,nats
      do 830 k=1,3
  830 xo(k)=x(k,i)
      iser=i
      k=kspecb(newvet,xo,xn,keyx,itype,iser,khead,iactn)
      if (keyx(10).gt.1) ifspec=1
  840 continue
      if (ifspec.eq.0) then
                         write(lo,910)
                       else
                         write(lo,912)
                       endif
  910 format(/,' Atom  Height',5x,1hx,6x,1hy,6x,1hz,2x,'  B(iso) Frag',
     *        /)
  912 format(
     *  49x,1hi,18(1h-),'   special positions information   ',
     *  18(1h-),1hi,//,
     *  16x,'i--- found  in ---i',14x,'i--- moved  to ---i',
     4   9x,'i---------  restrictions  on  ---------i',/,
     1  ' Atom  Height',5x,1hx,6x,1hy,6x,1hz,2x,'  B(iso) Frag',
     3  2x,1hx,6x,1hy,6x,1hz,6x,'Occ.',5x,
     4  ' L.Sq. shifts & thermal parameters    Site',/)
  915 continue
      khead=0
      if (iprin.gt.1) then
                        iactn=3
                      else
                        iactn=2
                      endif
      do 950 i=1,nats
      izpki=izpk(i)
      is=1
      if (izpk(i).lt.0) then
                          is=-1
                          kfrag=0
                          izpki=iabs(izpki)
                          if (izpki/100.gt.nk) then
                                                 izpki=0
                                                 is=0
                                               endif
                        else
                          kfrag=mod(izpki,100)
                        endif
      izpki=izpki/100
      kk=nk-izpki+1
      izpk(i)=kk*is
      nz(i)=is*(kk*100+kfrag)
      k=x(4,i)+0.5
      if (iprin.gt.1) then
      do 918 j=1,124
  918 cbuff(j:j)=' '
      if (kk.le.nk) then
          write(specie,'(a2)') nalf(kk)
          call ucase(specie(1:1))
          write(cbuff,920) specie,i,k,(x(j,i),j=1,3),bfac(i),kfrag
        else
          write(cbuff,922)        i,k,(x(j,i),j=1,3)
        endif
                      endif
  920 format(1h ,  a2,i3,i6,2x,3f7.3,f7.2,i4)
  922 format(1h ,'Q ',i3,i6,2x,3f7.3,  7x,4h    )
      iser=i
      do 930 k=1,3
  930 xo(k)=x(k,i)
      do 940 k=4,11
  940 xo(k)=0.0
      k=kspecb(newvet,xo,xn,keyx,itype,iser,khead,iactn)
      if (keyx(10).gt.1) then
                           if (iprin.gt.1) then
                                             jump=1
                                           else
                                             jump=0
                                           endif
                           call site(newvet,keyx,jump,k)
                           do 945 k=1,3
  945                      x(k,i)=xn(k)
                         endif
      if (iprin.gt.1) then
          if (ifspec.eq.0) then
                             write(lo,'(a)') cbuff(1:50)
                           else
                             write(lo,'(a)') cbuff
                           endif
                      endif
  950 continue
      return
      end
c-----------------------------------------------------------------------
      subroutine site(newvet,key,jump,k)
c
      character*80 buff
      character*124 cbuff
c
      dimension newvet(48,3),key(10),lsqv(28),lterm(2,30)
      character         string*6
      character lsqt(28)*6,itrt(30)*12,sitin(85)*6
      integer jsiti(194),cvet(194),vcoll(25,2),mpv(64),ksiti(64)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /tab1/ jsiti,vcoll,cvet,ksiti,mpv
      common /tab2/ sitin,lsqt,itrt
      common /tab4/ lsqvx(28),ktlsn(28)
      common /tape/ cell(6),neqv,icent,lat,natm,ts(3,24),is(2,3,24),nsym
     *             ,dumb(3)
      common /erl/ kmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common /atpos/ cbuff
c
c
c--   lsq shifts  code           therm. param. restr.  code
c--
c--
c--      x 0 0      110000             - - - 0 - 0      1
c--      0 y 0      001200             - - - - 0 0      2
c--      0 0 z      000013             - - - 0 0 -      3
c--      0 y z      001213             - - - 0 0 0      4
c--      x 0 z      110013             a a - - 0 0      5
c--      x y 0      111200             a a - - b b      6
c--      0 0 0      000000             a a - - b-b      7
c--      x x 0      111100             a a - 0 0 0      8
c--      x-x 0      110900             - a a 0 0 -      9
c--      x x z      111113             - a a b b -     10
c--      x-x z      110913             - a a-b b -     11
c--      x y z      111213             - a a 0 0 0     12
c--      x2x 0      113100             - a - a - 0     13
c--     2x x 0      311100             - a - a 0 0     14
c--      x2x z      113113             - a - a b2b     15
c--     2x x z      311113             a a - a 0 0     16
c--      0 y y      001212             a a a 0 0 0     17
c--      0 y-y      001208             a a a b b b     18
c--      x 0 x      110011             - - - - - -     19
c--      x 0-x      110009             a - - a2b b     20
c--      x y-y      111208             a - - a 0 -     21
c--      x y y      111212             a - - a 0 0     22
c--      x y x      111211             a a a b-b b     23
c--      x y-x      111209             a a a b b-b     24
c--      x x x      111111             a a a b-b-b     25
c--      x x-x      111109             a - a b --b     26
c--      x-x x      110911             a - a b - b     27
c--      x-x-x      110909             a - a 0 0 0     28
c--
      data lsqv/    111010,101210,101013,101213,111013,111210,101010,
     *111110,110910,111113,110913,111213,113110,311110,113113,311113,
     *101212,101208,111011,111009,111208,111212,111211,111209,111111,
     *111109,110911,110909/
      data lterm/141516,101810,141516,101019,141516,171010,141516,101010
     *          ,141416,101019,141416,171719,141416,170319,141416,101010
     *          ,141515,171010,141515,171818,141515,171802,141515,101010
     *          ,141516,101825,141516,101025,141516,371725,141416,101024
     *          ,141414,101010,141414,171717,141516,171819,141516,173724
     *          ,141516,171024,141516,101024,141414,170317,141414,170303
     *          ,141414,171703,141514,171803,141514,171817,141514,101010
     *          ,141514,101810,101010,101010/
c 
      mult=10000
      ilsq=0
      do 10 i=1,3
      ilsq=ilsq+(key(i)+10)*mult
   10 mult=mult/100
      k=0
      do 20 i=1,28
      lsqvx(i)=lsqv(i)
      if (ilsq.eq.lsqv(i)) k=i
   20 continue
      mult=10000
      it1=0
      it2=0
      do 30 i=1,3
      i1=i+3
      i2=i+6
      it1=it1+(key(i1)+10)*mult
      it2=it2+(key(i2)+10)*mult
   30 mult=mult/100
      kk=0
      do 40 i=1,30
      if (it1.eq.lterm(1,i).and.it2.eq.lterm(2,i)) kk=i
   40 continue
      ibuff=0
      if (k.eq.0.or.kk.eq.0) then
                               ibuff=1
                               write(buff,2000) key,ilsq,it1,it2,k,kk
                             endif
 2000 format(' errore ',10i3,3i8,5x,2i4)
      ilsqs=k
      iterm=kk
      nm=key(10)
      k=nm*10000+ilsqs*100+iterm
      ifin=194
      msys=jsys
      if (lat.eq.7) msys=7
      kkk=msys*1000000+k
      kcoll=0
      icont=0
      ks=1
      jj=msys
      if (k.eq.11219.or.k.eq.20719) jj=1
      num=nm*8192+ilsqs*256+iterm*8+jj
      do 50 i=2,ifin
         if (num.eq.iabs(jsiti(i))) then
                             icont=icont+1
                             ks=i
                                    endif
   50 continue
      if (jsiti(ks).ge.0) then
                            kkss=cvet(ks)
                            string=sitin(kkss)
                          else
          maxo =0
          meno1=1
          mm   =0
c -- look for the maximum order operator, for -1 and for mirrors
          do 60 i=1,nm-1
             if (iabs(newvet(i,1)).gt.maxo) maxo=iabs(newvet(i,1))
             if (newvet(i,1).eq.-1) meno1=-1
             if (newvet(i,1).eq.-2) mm=mm+1
   60     continue
          kcoll=meno1*(msys*10000+maxo*1000+mm*100+nm)
          kkss=1
          do 70 i=1,25
             if (vcoll(i,1).eq.kcoll) kkss=vcoll(i,2)
   70     continue
          string=sitin(kkss)
      endif
      if (jump.ne.0) then
          write(cbuff(119:124),'(a6)') string
          if (ibuff.eq.1) then
                            write(lo,'(a)') buff
                            write(lo,'(1h )')
                          endif
                      endif
c  90 format(1h+,117x,a6)
      if (kkss.eq.1) k=-1
      return
      end
CRYSTALS CODE FOR INVAR92
c-- sir code for invariants                      Release 93.02
       subroutine invar(ier)
c
c-- invariant main routine
c
      character cff
      common/sinte/ abc(3),ang(3),astar,bstar,cstar,cosas,cosbs,coscs
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common/rc/p(6),cx(9),dumc(9)
c
      common /inp/  natom,fnat,satm,atoms
      common /prin/ ipt,ip0,ip10,ipq
      common /proc/ iftr,ifp10,ifnq,ifps,ifcoc,ifweig
      common/param/ifat1,ifat2,ifatx,lreci,idx,icst1,icst2,icst3,duma(3)
      common/dirtr/nreft,emin,ntra,ntrt,ntrmx,nref,nweak,sgg,nstr,nzro
      common/dirps/nrefp,emax,npsa,nrefpl,npsmx
      common/dir10/numk,ntrs,ntr10,sogpo,sogen,sogne,nupos,nuena,nuneg,
     1 indpo,inden,indne,nmxte,nmxtn
      common/dirqn/ecros,iecros,ncode,icody,nquar
     1 ,nsog,sqes,nquam,nquat,nqenm,nqent,ecr1,iecr1
      common /cp10/ nor(3),nop(3),iseg(3),eeb(6),ee(24,6)
      common /tst/ nt,ar(26),nn(11,26,3),pp(11,26,3)
      common /nctst/ ns,br(15),nb(11,15,3),fnb(11,15,3),bcm(11,15,3),
     *                        acm(11,15,3)
      common/esti/ib(3),ih(3,2,24),ii(2,24)
      common/nq/nor1(6),nop1(6),iseg1(6),icodqn,sumc,sums,sume
      common/wrt/icv(4,7),ishf,ifas,eewrt(3),icodx(3),iqua(1000),
     1           itac(5,24,4),eee(3)
      common/lst13/l13,m13,md13,l13f,m13f,n13f
      common/zero/argq(26),ncal(26),nver(26),ntt,fm(26),gt(26)
      common /pseud/ kmat(48,3,3),emme,patom,qatom,npseud,lpseud(4,3)
     1         ,scale,jmme,prod,prod2,mjn(5,11),njn,coef,nw(8),no(8)
c
      common /xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1               isr(100000),isig(3,20000),gq(20000),gv(20000)
      character rescha(7)*32,line(2)*8,fmt*36
      integer result(7,2)
      data rescha/
     *            '     positive estimated triplets',
     *            '     negative estimated triplets',
     *            ' enantiomorph sensitive triplets',
     *            '               psi-zero triplets',
     *            '                  psi-e triplets',
     *            '     negative estimated quartets',
     *            ' enantiomorph sensitive quartets'/
c
      write(cff,'(i1)') kff
      write(lo,10) cff,itle
   10 format(///,a1 ,120('+'),//,
     1 39h SIR92 : Invariants routine            ,68x,14hRelease  93.02
     2 ,//,20x,20a4,/,1h ,120('+'),/)
c-- read directives
      call dirinv(ip10fast,ibig,ifpse,ier)
      if (ier.lt.0) goto 1000
      mode=0
      call inpt9(ier,coefs,mode,npse)
c-- if known structure the statistics are always performed
      if (ifp10.eq.0.and.ifcoc.eq.1) then
                                                    numk=-1
                                                    ifp10=2
                                                  endif
      if (ier.lt.0) goto 1000
      do 100 i=1,7
      do 100 j=1,2
  100 result(i,j)=0
      if (npseud.eq.0) go to 5
      write(lo,1) npseud
    1 format(/,45x,i1,' pseudo-translation(s) provided',/)
      fmt='(54x,i1,2hh+,i1,2hk+,i1,2hl=,i2,1hn)'
      do 2 j=1,npseud
      if (lpseud(1,j).lt.0.or.lpseud(1,j).gt.9) fmt(7:7)='2'
      if (lpseud(2,j).lt.0.or.lpseud(2,j).gt.9) fmt(15:15)='2'
      if (lpseud(3,j).lt.0.or.lpseud(3,j).gt.9) fmt(23:23)='2'
    2 write(lo,fmt) (lpseud(i,j),i=1,4)
      write(lo,4) patom,qatom,coef,coefs
    4 format(//,34x,
     *       ' < E**2 > computed through least squares straight line'
     *,//,50x,' slope =',f8.3,/,47x,'intercept =',f8.3,
     *  /,20x,'   applied coeff. for w-w-w triplets =',f8.3,
     *  /,20x,' subgested coeff. for w-w-w triplets =',f8.3,//)
c-----------------
    5 ipp=ip0+ipt+ip10+ipq
      ili0=0
      if(ipp.gt.0) call outp
      iprin=ip0
      if(ifps.gt.0) call strip9(1,mode,npse,result,ili0,ibig,ip10fast)
      iprin=ipq
      if(ifnq.gt.0) call negq(result)
      iprin=ipt
      ili0=0
      if(iftr.gt.0) then
                      call strip9(0,mode,npse,result,ili0,ibig,ip10fast)
                      iprin=ip10
                      numcoc=result(1,2)
                      if (ifp10.ge.1) then
c                     if (ip10fast.eq.0) call p10(mode,result)
                      if (ip10fast.eq.2) call p10n(mode,result)
                                      endif
           if (ifcoc.eq.0.and.numk.gt.0) then
                             write(lo,1400) numcoc,numk
 1400      format(/,i5,' triplets have been strengthned by ',i3,
     *              '  free vectors using p-10 formula')
                           else
                             call cancella(10)
                             call cancella(11)
                             write(lo,1450)
 1450      format(/,' triplets have been estimated using p-3 formula')
                           endif
                    endif
      if (ifpse.eq.1) then
                       mode=1
                       call inpt9(ier,coefs,mode,npse)
                       if (ier.lt.0) goto 1000
                       if (mode.eq.1)
     *  call strip9(1,mode,npse,result,ili0,ibig,ip10fast)
                     else
                       call cancella(24)
                     endif
c-- final print
      write(lo,1500)
 1500 format(//,41x,'number of relationships',/
     *         ,41x,'  calculated   stored   ')
      do 2000 i=1,7
      do 1800 j=1,2
      if (result(i,j).eq.0) then
                              write(line(j),1600)
                            else
                              write(line(j),1700) result(i,j)
                            endif
 1600 format('       -')
 1700 format(i8)
 1800 continue
      write(lo,2100) rescha(i),(line(j),j=1,2)
 2100 format(/, 9x,a32,a8,3x,a8)
 2000 continue
 1000 return
      end
c -----------------------------------------------------------
      subroutine inpt9(ier,coefs,mode,npse)
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common/rc/p(6),cx(9),dumc(9)
      common/sf/al(4,8),bs(4,8),cl(8),nz(8),ny(8),nk,nat,f(9),nalf(8)
c
      common /inp/  natom,fnat,satm,atoms
      common/sinte/ abc(3),ang(3),astar,bstar,cstar,cosas,cosbs,coscs
      common /proc/ iftr,ifp10,ifnq,ifps,ifcoc,ifweig
      common/prin/ ipt,ip0,ip10,ipq
      common/param/ifat1,ifat2,ifatx,lreci,idx,icst1,icst2,icst3,duma(3)
      common/dirtr/nreft,emin,ntra,ntrt,ntrmx,nref,nweak,sgg,nstr,nzro
      common/dirps/nrefp,emax,npsa,nrefpl,npsmx
      common/dir10/numk,ntrs,ntr10,sogpo,sogen,sogne,nupos,nuena,nuneg,
     1 indpo,inden,indne,nmxte,nmxtn
      common/dirqn/ecros,iecros,ncode,icody,nquar
     1 ,nsog,sqes,nquam,nquat,nqenm,nqent,ecr1,iecr1
c
      common /xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1               isr(100000),isig(3,20000),gq(20000),gv(20000)
      common /pseud/ kmat(48,3,3),emme,patom,qatom,npseud,lpseud(4,3)
     1         ,scale,jmme,prod,prod2,mjn(5,11),njn,coef,nw(8),no(8)
      common /atoms/ x(5,200),nzz(200),ngp,ninf(10),nag(10)
      common /trre/ rho(3),eps(3),sq(3),sn(3),fn(3,8),ipcod(3),msym,
     *              naold(8),nanew(8)
c--
      integer hkl(3)
      dimension vet(12),ivet(12)
      equivalence(vet(1),ivet(1))
c
c -----
c     call sub. per lettura lista 1 : parametri della cella
c -----
      call yfl01
      do 21 i=1,3
   21 abc(i)=cx(i)
      do 22 i=4,6
   22 ang(i-3)=cx(i)
c -----
c     call sub. per lettura lista 2 : simmetria
c -----
      call yfl02
c -----
c     call sub. per lettura lista 3 : contenuto cella
c -----
      call yfl03
      do 23 i=1,8
      nw(i)=nz(i)
   23 no(i)=ny(i)
c -----
c     call sub. per lettura preambolo lista 7
c -----
      call ysfl07(nrefl,nstr,nzro,npseud,iy)
c-- segue il blocco 1 frammento traslato
      fnat=s3s2
c---- compute the number of free vectors
      msym=nsym*(icent+1)
      atoms=(1.0/fnat)**2.0
      natom=int(atoms+0.05)
      if (numk.ne.0) go to 25
      numk=natom/msym+30
      numk=min0(numk,70)
   25 lreci=100000
      icst1=268435456
      icst2=134217728
      icst3=32768
      nupos=0
c -- set the max. numb. of enant. and neg. triplets to write onto jrel
      nmxte=500
      nmxtn=500
c -- set the numb. of neg. quartets to calculate and write onto jrel
      nquam=2000
      nquat=750
c -- set the numb.of enant. quart. to calculate and write onto jrel
      nqenm=500
      nqent=500
c
      ifat1=(2*ihx(3)+1)*(2*ihx(2)+1)
      ifat2=(2*ihx(3)+1)
      ifatx=ihx(1)*ifat1+ihx(2)*ifat2+ihx(3)
      if (ifatx.gt.lreci) go to 1100
      jmme=msym
      emme=float(jmme)
      do 30 m=1,nsym
      do 30 i=1,3
      do 30 j=1,3
      if (icent.ne.0) ksmat(m+nsym,i,j)=-ksmat(m,i,j)
   30 continue
c-- if there are pseudotranslation effects
c-- sigma-2 are calculated using p3 formula
      if (npseud.gt.0) then
                         call sfl19(lpseud,patom,qatom)
                         nreft = nrefl - nzro
                         nreft = min0(499,nreft)
                         if (nreft.gt.nrefl) nreft=nrefl
                         if (nrefpl.eq.0) nrefpl=nreft
                         ifp10=0
                         if (knw.eq.1) ifp10=2
                         numk=-1
                         call prepa(coefs)
                       endif
      ic=0
      ict=0
      alfa=0.0
c ---      set some default values
      if(nreft.eq.0) nreft=nstr
      if(nrefpl.eq.0.or.nrefpl.gt.nreft) nrefpl=nreft
      if(nzro.gt.300) nzro=300
      if(nrefp.eq.0) nrefp=nzro
c
      if (numk.gt.nreft) numk=nreft
c
      nstr=max0(nreft,numk)
      if (nrefl-nrefp.gt.nstr) go to 480
      nrefp=nrefl-nstr
      if (mode.eq.0) go to 500
      write(lo,460)
  460 format(//,' *** warning *** : there are no psi-e reflections ',/)
      mode=-1
      return
  480 if(mode.eq.0) goto 500
      npse=0.5*float(nreft)
      npse=min0(npse,300)
      if(nrefl-nrefp.le.nreft+npse) npse=nrefl-nrefp-nreft
      nrefp=npse
c ---
  500 do 700 i=1,nrefl
      call snr07(vet)
      e=vet(4)
      if (e.lt.emin.or.ict.eq.nreft) go to 750
      ict=ict+1
      em=e
  750 hkl(1)=ivet(1)
      hkl(2)=ivet(2)
      hkl(3)=ivet(3)
      iphi8=mod(ivet(8),2**15)
      iphi=iphi8/32
      jcode=mod(iphi8,32)
      ic=ic+1
      ish(1,ic)=((hkl(1)+64)*128+hkl(2)+64)*128+hkl(3)+64
      ish(2,ic)=int(e*100.+0.5)*512+iphi
      if (npseud.ne.0) call alfas(alfa,hkl)
      ish(3,ic)=int(alfa*1000.0)
      itype(ic)=jcode
      if(ic.eq.nstr) goto 850
  700 continue
  850 nreft=ict
      emin=em
      if(nrefpl.gt.nreft) nrefpl=nreft
      ic=0
      nsup=nrefp
      npsx=idx-nreft
      nstr=max0(nreft,numk)
      if(nsup.le.npsx) goto 860
      nsup=npsx
      nrefp=npsx
  860 if (mode.eq.1) then
                         ifin=nreft+npse
                         nccris=nreft+1
                         emax=999.9
                         ind=nreft
                         mdavi=1
                      else
                        ind=nreft+nsup+1
                        mdavi=-1
                        nccris=nrefl-nsup+1
                        ifin=nrefl
                      endif
      call ysfl07(nrefl,nstr,nzro,npseud,iy)
      do 1000 i=1,ifin
      call snr07(vet)
      if(i.lt.nccris) go to 1000
      ind=ind+mdavi
      e=vet(4)
      if (e.gt.emax) go to 1000
      ic=ic+1
      hkl(1)=ivet(1)
      hkl(2)=ivet(2)
      hkl(3)=ivet(3)
      iphi8=mod(ivet(8),2**15)
      iphi=iphi8/32
      jcode=mod(iphi8,32)
      ish(1,ind)=((hkl(1)+64)*128+hkl(2)+64)*128+hkl(3)+64
      ish(2,ind)=int(e*100.+0.5)*512+iphi
      if (npseud.ne.0) call alfas(alfa,hkl)
      ish(3,ind)=int(alfa*1000.0)
      itype(ind)=jcode
      if(ic.eq.nsup) return
 1000 continue
      nrefp=ic
      return
 1100 write(lo,1200) lreci,ifatx
 1200 format(//,' *** error *** actual size of isr ( =',i8,' ) is less'
     *       ,/,'               then maximum super-index = ',i8
     *      ,//,' Restart the program using in %DATA the directive '
     *       ,/,'                RHOMAX  xx                        '
     *       ,/,' in order to reduce the maximum values of h,k,l.  ')
      ier=-1
      return
      end
c-----------------------------------------------------------------------
      subroutine prepa(coefs)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /inp/  natom,fnat,satm,atoms
      common /pseud/ kmat(48,3,3),emme,patom,qatom,npseud,lpseud(4,3)
     1         ,scale,jmme,prod,prod2,mjn(5,11),njn,coef,nw(8),no(8)
c
      common /xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1               isr(100000),isig(3,20000),gq(20000),gv(20000)
      prod=1.0
      do 20 i=1,npseud
   20 prod=prod*float(lpseud(4,i))
      prod2=prod*prod
      call senti
      nnn=prod*jmme
      i8=8
      do 25 i=1,i8
      isig(1,i)=nw(i)
      isig(2,i)=no(i)
   25 gq(i)=no(i)
      call sortgn(i8)
      do 28 i=1,i8
      nw(i)=isig(1,i)
   28 no(i)=isig(2,i)
      nnc=0
      do 30 i=1,i8
      if (nw(i).eq.0) go to 40
      j=i
      nnc=nnc+nw(i)
      if (nnn.le.nnc) go to 40
   30 continue
   40 z1=no(1)
      z2=no(j)
      dz=(z1-z2)/z1
      coefs=-dz/2.0
      if (coef.gt.99000.0) coef=coefs
      return
      end
c----------------------------------------------------------------------
      subroutine senti
      common/sinte/ abc(3),ang(3),astar,bstar,cstar,cosas,cosbs,coscs
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /inp/  natom,fnat,satm,atoms
      common/param/ifat1,ifat2,ifatx,lreci,idx,icst1,icst2,icst3,duma(3)
c
      do 10 i=1,3
   10 ang(i)=ang(i)*pi/180.0
      a1=cos(ang(1))
      a2=cos(ang(2))
      a3=cos(ang(3))
      s1=sin(ang(1))
      s2=sin(ang(2))
      s3=sin(ang(3))
      arg=1.0-a1*a1
     1       -a2*a2
     2       -a3*a3
     3       +a1*a2*a3*2.0
      v=abc(1)*abc(2)*abc(3)*sqrt(arg)
      astar=abc(2)*abc(3)*s1         /v
      bstar=abc(1)*abc(3)*s2         /v
      cstar=abc(1)*abc(2)*s3         /v
      cosas=(a2*a3-a1)/(s2*s3                 )
      cosbs=(a1*a3-a2)/(s1*s3                 )
      coscs=(a1*a2-a3)/(s1*s2                 )
      return
      end
c -----------------------------------------------
      subroutine outp
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /proc/ iftr,ifp10,ifnq,ifps,ifcoc,ifweig
      common/dirtr/nreft,emin,ntra,ntrt,ntrmx,nref,nweak,sgg,nstr,nzro
      common/dirps/nrefp,emax,npsa,nrefpl,npsmx
      write(lo,10) nstr
   10 format('   list of the',i4,'  strongest reflections'/)
      call outp1 (1,nstr)
      if(iftr.eq.0.and.ifnq.eq.0) return
      iniz=nstr+1
      ifin=nstr+nrefp
      write(lo,40) nrefp
   40 format('0  list of the',i4,'  weakest reflections for psizero and/
     1or negative quartets cross-vectors'/)
      call outp1(iniz,ifin)
      return
      end
c -----------------------------------------------
      subroutine outp1(iniz,ifin)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /proc/ iftr,ifp10,ifnq,ifps,ifcoc,ifweig
      common/dirtr/nreft,emin,ntra,ntrt,ntrmx,nref,nweak,sgg,nstr,nzro
      common/dirps/nrefp,emax,npsa,nrefpl,npsmx
c
      common /xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1               isr(100000),isig(3,20000),gq(20000),gv(20000)
      dimension icod(5),ihkl(3,5),e(5),iphi(5)
      nr=0
      do 30 i=iniz,ifin
      nr=nr+1
      call schkl(i,ihkl(1,nr))
      e(nr)=float(ish(2,i)/512)/100.
      icod(nr)=i
      iphi(nr)=mod(ish(2,i),512)
      if(nr.lt.5.and.i.lt.ifin) goto 30
      write(lo,20)(icod(j),(ihkl(k,j),k=1,3),e(j),iphi(j),j=1,nr)
   20 format(' ',5(i3,'*',3i3,f5.2,i4,2x))
      nr=0
   30 continue
      return
      end
c ------------------------------------------------------
      subroutine strip9(ipsi0,mode,npse,result,ili0,ibig,ip10fast)
c--calculate triplets
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /inp/  natom,fnat,satm,atoms
      common/prin/ ipt,ip0,ip10,ipq
      common/param/ifat1,ifat2,ifatx,lreci,idx,icst1,icst2,icst3,duma(3)
      common/dirtr/nreft,emin,ntra,ntrt,ntrmx,nref,nweak,sgg,nstr,nzro
      common/dirps/nrefp,emax,npsa,nrefpl,npsmx
      common/dir10/numk,ntrs,ntr10,sogpo,sogen,sogne,nupos,nuena,nuneg,
     1 indpo,inden,indne,nmxte,nmxtn
      common/dirqn/ecros,iecros,ncode,icody,nquar
     1 ,nsog,sqes,nquam,nquat,nqenm,nqent,ecr1,iecr1
      common /pseud/ kmat(48,3,3),emme,patom,qatom,npseud,lpseud(4,3)
     1         ,scale,jmme,prod,prod2,mjn(5,11),njn,coef,nw(8),no(8)
c
      common /xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1               isr(100000),isig(3,20000),gq(20000),gv(20000)
      common /cp10/ nor(3),dumd(156)
      common/sf/al(4,8),bs(4,8),cl(8),nwno(16)   ,nk,nat,f(9),nalf(8)
c--
      character rescha(13)*9,linex(3)*9
      dimension ill(3),jvet(3),mh(3),mk(3),ml(3),vet( 7),kvet(16)
      dimension ist(2,3),gt(3),iphit(3),ivet(48)
      integer result(7,2)
      data rescha/'   any   ','         ','  30,210 ','  45,225 ',
     *'  60,240 ','         ','  90,270 ','         ',' 120,300 ',
     *' 135,315 ',' 150,330 ','         ','   0,180 '/
c--
c
c
c--description of some important settings
c
c  h1 = h2 + h3
c  i  h1 code
c  j  h2 code
c in  h3 code
c mh  h,k,l first  reflection
c mk  h,k,l second reflection
c ml  h,k,l third  reflection
c     ipsi0 = 0   ->  sigma2
c     ipsi0 = 1   ->  psi-zero or psi-e
c      mode = 0   ->  sigma2 or psi-zero
c      mode = 1   ->  psi-e
c
c*******************************************************************
c-- segue il blocco 2 frammento traslato
      gdvmn=0.0
      iloop=0
 9999 npsi0=0
      iconts=0
      if (ipsi0.eq.0) write(lo,10) nreft,emin
   10 format(//,' Sigma2 relationships estimated among the ',
     *i4,' strongest reflections - (Emin =',f5.2,')')
      if (ipsi0.eq.1.and.mode.eq.0) write(lo,20) nrefpl,nrefp
   20 format(/,' Psi-zero relationships estimated among the ',
     *i4,' strongest and the ',i4,'  weakest reflections',/)
      if (ipsi0.eq.1.and.mode.eq.1) write(lo,25) nrefpl,nrefp
   25 format(//,' Psi-e relationships among the ',i4,
     1'  strongest and the ',i4,'  following  reflections')
c--clear the areas
      if (icent.eq.1) then
                        call clrt1
                      else
                        call nclrt1
                      endif
      if (npseud.gt.0.and.knw.ne.0) then
                                      do 1002 i=1,5
                                      do 1002 j=1,11
 1002                                 mjn(i,j)=0
                                      njn=0
                                      if (icent.eq.1) then
                                                        call clrt
                                                      else
                                                        call nclrt
                                                      endif
                                    endif
      do 1001 k=1,20000
      itab(k)=0
1001  continue
      do 1004 i=1,ifatx
      isr(i)=0
1004  continue
c--create the list
      ipu=0
      do 1900 j=1,nstr
      call schkl(j,jvet)
      do 1100 i=1,nsym
      do 1111 i1=1,3
      ill(i1)=0
      do 1111 j1=1,3
      ill(i1)=ill(i1)+jvet(j1)*ksmat(i,j1,i1)
 1111 continue
      indr=ill(1)*ifat1+ill(2)*ifat2+ill(3)
      indrr=indr
      if (i.ne.1) then
                    imen1=i-1
                    do 1112 i1=1,imen1
                    if (indr.eq.ivet(i1)) indrr=0
 1112               continue
                  endif
      ipu=ipu+1
      ivet(i)=indrr
      a=jvet(1)*tmat(i,1)+jvet(2)*tmat(i,2)+jvet(3)*tmat(i,3)
      k=nint(a*24.)
      k=mod(k,24)
      if(k.lt.0) k=k+24
      itab(ipu)=indrr
      itab1(ipu)=((ill(2)+64)*128+ill(3)+64)*32+k
      isgn=isign(1,indr)
      indr=iabs(indr)
      if(isr(indr).eq.0)isr(indr)=(j*24+i)*isgn
 1100 continue
 1900 continue
      n8t=8000
      if (npseud.gt.0) n8t=n8t+1000
c--modif 8.5.85 mercedes
      if (ipsi0.gt.0)n8t=4000
      if (mode.ne.0) n8t=8000
      if (ibig.ne.0) then
                       n8t=ibig
                       if (ipsi0.gt.0)n8t=20000
                       if (mode.ne.0) n8t=8000
                     endif
      jsup =nreft-1
      if(ipsi0.ne.0) jsup=nrefpl-1
c--calculate sigma 2
      jt=0
      n8=0
      n8e=0
      sgg=0.0
      if(iprin.gt.0) then
                       if(ipsi0.eq.0)write(lo,1525)
                       if(ipsi0.gt.0)write(lo,1535)
                     endif
1525  format(/,' set up sigma2 relationships')
1535  format(/,' set up psi-zero relationships')
c--first loop
c
      do 50 i=1,3
      do 50 j=1,20000
      isig(i,j)=0
 50   continue
      ninf=1
      nsup=nreft-2
      if(ipsi0.eq.0)go to 1000
      ninf=nreft+1
      nsup=nreft+nrefp
      if(mode.eq.0) go to 1000
      if (iloop.eq.0) then
          if(icent.eq.0) then
                           edv1=float(ish(2,1)/512)*0.01
                           edv2=float(ish(2,nreft)/512)*0.01
                           edv3=float(ish(2,ninf)/512)*0.01
                           edv4=float(ish(2,nsup)/512)*0.01
                           gdvmx=edv1*edv1*edv3
                           gdvmn=edv2*edv2*edv4
                           gdvmn=fnat*(gdvmn+0.40*(gdvmx-gdvmn))
                           gdvmn=amax1(0.6,gdvmn)
                           if (gdvmn.gt.1.0) gdvmn=1.0
                           if (iprin.gt.0)
     *                     write(lo,455) edv1,edv2,edv3,edv4,gdvmn
                         else
                           gdvmn=0.6
c                          if (iprin.gt.0)
                           write(lo,456) gdvmn
                         endif
          jgdv=nint(gdvmn*100.0)
        endif
  455 format(//5x,'efmx =',f8.3,'   efmn =',f8.3,'   eemx =',
     *f8.3,'   eemn =',f8.3,5x,'g(min) for psi-e =',f8.3//)
456   format(//5x, 'centrosymmetric, g(min) for psi-e =',f8.3//)
 1000 inn1=1-nsym
      do 2000 i=ninf,nsup
      js=0
      e1=float(ish(2,i)/512)/100.
      ityp1=itype(i)
      if(n8.lt.n8t) goto 1580
      if(ipsi0.gt.0)go to 1580
      jg=nint(e1*e1*e1*fnat*100.0)
      jc=int(gq(n8)*100.)
      if(jg.lt.jc )go to 2400
 1580 if(iprin.lt.2) goto 2005
      call schkl(i,ill)
      ifi=mod(ish(2,i),512)
      write(lo,2004) (ill(n),n=1,3),i,e1,ifi
 2004 format(/,' reflection ',3i4,10x,
     1 'code = ',i4,10x,
     2 'e = ',f7.2,10x,
     3 'phase =',i7,/)
 2005 if(ipsi0.gt.0)go to 2007
      inn1=inn1+nsym
      it=itab1(inn1)/32
      jk1=it/128-64
      jl1=it-(jk1+64)*128-64
      i1=i
      go to 2008
 2007 call schkl(i,jvet)
      jh1=jvet(1)
      jk1=jvet(2)
      jl1=jvet(3)
      i1=0
c
c--second loop
c
 2008 ins=(i-1)*nsym+1
      ih31=itab(ins)
      if(ipsi0.gt.0) ih31=jh1*ifat1+jk1*ifat2+jl1
      jinf=i1+1
      do 2100 j=jinf,jsup
      e2=float(ish(2,j)/512)/100.
      ityp2=itype(j)
      i0=2*nsym
      do 2110 ii=1,i0
      ivet(ii)=0
 2110 continue
      i0=0
      jn=(j-1)*nsym
      do 2200 k=1,nsym
      jnk=jn+k
      if(itab(jnk).eq.0) goto 2200
      it=itab1(jnk)/32
      jk2=it/128-64
      jl2=it-(jk2+64)*128-64
      do 2300 l=1,3,2
      l1=l-2
      ih32=itab(jnk)
      ih3=ih31+ih32*l1
      l3=1
      if(ih3) 2010,2300,2020
 2010 l3=-1
      ih3=-ih3
 2020 continue
      if(ih3.gt.ifatx) go to 2300
      if(isr(ih3).eq.0) go to 2300
      jk=iabs(jk1+jk2*l1)
      if(jk.gt.ihx(2)) go to 2300
      jl=iabs(jl1+jl2*l1)
      if(jl .gt.ihx(3)) go to 2300
      if(isr(ih3).lt.0) l3=-l3
      isra=isr(ih3)
      isra=iabs(isra)
      in=isra/24
      if(in.le.j) go to 2300
      if(in.gt.jsup+1) goto 2300
      if(i0.eq.0)go to 2030
      do 2040  ii=1,i0
      if(in.eq.ivet(ii))go to 2300
 2040 continue
 2030 i0=i0+1
      ivet(i0)=in
      in3=isra-in*24
      ins=(in-1)*nsym+in3
      ns3=mod(itab1(ins),32)
      ns2=mod(itab1(jnk),32)
      is =-ns2*l1+ns3*l3+48
      is =mod(is ,24)
      iss=is*360/24
c
c  phi(t)=phi(h1)-phi(h2)-phi(h3)+shift(fase)
c  i codici sono per  h1 = h2 + h3
c  cod(h2)= -l1 * j
c  cod(h3)=  l3 * in
c
      iphi= mod(ish(2,i),512)+mod(ish(2,j),512)*l1-mod(ish(2,in),512)*l3
     1  +iss
      if(iphi.lt.0)iphi=iphi+3600
      iphi=mod(iphi,360)
      e3=float(ish(2,in)/512)/100.
      ityp3=itype(in)
c --------------------------------------------------------------------
c
c   routine for triplets symmetry inconsistent
c
c --------------------------------------------------------------------
      if(icent.gt.0) goto 5000
      if(ityp1.eq.1.or.ityp2.eq.1.or.ityp3.eq.1) goto 5000
      isotyp=(ityp1-1) + l1*(ityp2-1) - l3*(ityp3-1)
      isopha=isotyp*15 + iss
      imo=mod(isopha,180)
      if(imo.eq.0) goto 5000
      iconts=iconts+1
      if(iconts.gt.10) goto 2300
      do 4475 ini1=1,3
 4475 linex(ini1)=' ??????? '
      write(linex(1),4485) rescha(ityp1)
      write(linex(2),4485) rescha(ityp2)
      write(linex(3),4485) rescha(ityp3)
 4485 format(a9)
      if(ili0.ne.0) goto 4600
      ili0=1
      write(lo,4500)
 4500 format(//, '  the following triplets are symmetry inconsistent',
     1 ': they have been excluded from the procedure',//,
     2 10x,3('code',2x,'ph.rest.',5x),/)
 4600 write(lo,4700) i,linex(1),j,linex(2),in,linex(3)
 4700 format(10x,3(1x,i3,1x,a9,5x))
      if(iconts.eq.10) write(lo,4710)
 4710 format(10x,' ..... and so on',/)
      goto 2300
 5000 continue
      g=fnat*e1*e2*e3
c-- segue il blocco 3 frammento traslato
      if (npseud.le.0) go to 2033
c
c--------------------------------------------------------------
c
      call pseudt(g,i,j,in,l1,l3,k,in3,mh,mk,ml,e1,e2,e3,vet,kvet)
c
c---- we reject the triplet if weak-weak-weak  (and psi-zero also)
      ireje=kvet(5)+kvet(10)+kvet(15)
      if (ireje.eq.0.and.ipsi0.eq.1) go to 2300
      if (abs(g).lt.0.001.and.ipsi0.eq.0) go to 2300
c
      kvet( 1)=i
      kvet( 6)=j
      kvet(11)=in
c
c--------------------------------------------------------------
c
      if (knw.eq.0) go to 2033
      ljn=kvet(5)+kvet(10)+kvet(15)+kvet(16)/1000
      gg=(2-icent)*g
      if (njn.eq.10) go to 2041
      if (njn.eq.0) go to 2032
      do 2031 jj=1,njn
      if (ljn.eq.mjn(1,jj)) go to 2039
 2031 continue
      go to 2032
 2041 jj=11
      go to 2039
 2032 njn=njn+1
      mjn(1,njn)=ljn
      mjn(2,njn)=kvet( 5)
      mjn(3,njn)=kvet(10)
      mjn(4,njn)=kvet(15)
      mjn(5,njn)=kvet(16)
      jj=njn
 2039 b=float(iphi)*pi/180.0
      a=cos(b)
      an=a*gg
      if (icent.eq.1) go to 2034
      bang=iphi
      if (iphi.gt.180) bang=360.0-bang
      call nctet(gg,a,bang,jj)
      go to 2033
 2034 continue
      call sctst(gg,an,jj)
c
c-----------------------------------------------------------
c
 2033 if(icent.eq.0) g=2.*g
c
c     we reject psi-zero if arg.gt.0.2 ( if pseudotranslation exists )
c
      if (npseud.gt.0.and.g.gt.0.2) npsi0=npsi0+1
      if (mode.eq.0) then
                if (ipsi0.gt.0.and.npseud.gt.0.and.g.gt.0.2) go to 2300
                     else
c
c-- reject psi-e if g.lt.gdvmn (mean g value)
c
                if (g.lt.gdvmn) go to 2300
                     endif
      gb=g
      if(g.gt.20.47) gb=20.47
      jg=nint(gb*100.0)
      js=js+1
      if (mode.eq.0.and.ipsi0.gt.0.and.js.gt.80) go to 2100
      if(iprin.lt.2)go to 2027
      jt=jt+1
      ist(1,jt)=-j*l1
      ist(2,jt)=in*l3
      gt(jt)=g
      iphit(jt)=iphi
      if(jt.ne.3) go to 2027
      write(lo,2026) ((ist(n,nn),n=1,2),gt(nn),iphit(nn),nn=1,3)
 2026 format(3(2x,2i4,f7.2,i5))
      jt=0
 2027 if(n8.eq.n8t) go to 2320
      n8=n8+1
      gq(n8)=g
      sgg=sgg+gq(n8)
c *******************************************************
c **  is   =  d-shift del tripletto
c **  i    =  code del primo riflesso
c **  j    =  code del secondo riflesso
c **  in   =  code del terzo riflesso
c **  k    =  operatore di simm. del secondo riflesso
c **  in3  =  operatore di simm. del terzo riflesso
c **  l1   =  segno del secondo riflesso
c **  l3   =  segno del terzo riflesso
c **  jg   =  int(g*100)
c **  iphi =  fase reale del tripletto
c ********************************************************
      isig(1,n8)=((i+2048)*4096+l1*j+2048)*32+iphi/15+1
      isig(2,n8)=((-l3*in+2048)*4096+jg+2048)*32+is+1
      isig(3,n8)=((k*32+in3)*4096+jg+2048)*32+mod(iphi,15)+1
      go to 2300
 2320 if(ipsi0.gt.0)go to 2400
      if(n8e.ne.0)go to 2330
      call sortgn(n8)
      n8m=n8
      n8l=n8
      gm=gq(n8m)
 2330 n8e=n8e+1
      if(g.lt.gm)go to 2300
      sgg=sgg-gq(n8m)+g
      gq(n8m)=g
      isig(1,n8m)=((i+2048)*4096+l1*j+2048)*32+iphi/15+1
      isig(2,n8m)=((-l3*in+2048)*4096+jg+2048)*32+is+1
      isig(3,n8m)=((k*32+in3)*4096+jg+2048)*32+mod(iphi,15)+1
      gm=100.
      n8lm1=n8l-1
      if(n8lm1.lt.1) n8lm1=1
      do 2340 ii=n8lm1,n8
      ga=gq(ii)
      if(ga.gt.gm)go to 2340
      gm=ga
      n8m=ii
 2340 continue
      n8l=min0(n8l,n8m)
 2300 continue
 2200 continue
 2100 continue
      if(iprin.lt.2) go to 2000
      if(jt.eq.0) go to 2002
      write(lo,2026) ((ist(n,nn),n=1,2),gt(nn),iphit(nn),nn=1,jt)
      jt=0
2002  continue
      write(lo,2101) js
2101  format(' number of contributors =',i6)
      js=0
2000  continue
2400  continue
      n8e=n8e+n8
      if(ipsi0.gt.0) goto 2500
c-- segue il blocco 4 frammento traslato
      if (iprin.gt.0) write(lo,3000)n8e,n8
      result(1,1)=n8e
      result(1,2)=n8
      if (ip10fast.ne.1) call sortgn(n8)
      igm=gq(n8)*1000.
 3000 format(i8,' triplet(s) calculated and',i6,' stored')
 4000 format(i8,' psi-zero triplet(s) calculated and',i6,' stored',
     1 i6,' rejected')
      ntra=n8
      call wrtr9(1,igm,npse)
      if (npseud.le.0.or.knw.eq.0) return
      if (icent.eq.1) call stst
      if (icent.eq.0) call nstst
      return
 2500 if (mode.eq.1) go to 5550
      npsa=n8
      if (iprin.gt.0) write(lo,4000)n8e,n8,npsi0
      result(4,1)=n8e
      result(4,2)=n8
      call wrtr9(2,igm,npse)
      return
 5550 continue
      if (iloop.le.1) then
                        nrap=n8/nrefp
                        if (nrap.le.20.and.jgdv.gt.50) then
                                                  gdvmn=gdvmn-0.20
                                                  gdvmn=amax1(0.5,gdvmn)
                                                  iloop=iloop+1
                                                  write(lo,5555)
 5555 format(' insufficient psi-e found - lower g value and try again')
                                                  go to 9999
                                                endif
                      endif
      ntra=n8
      result(5,1)=n8e
      result(5,2)=n8
      if (ntra.ne.0) then
                       call wrtr9(4,igm,npse)
                      else
                        write(lo,5556)
                      endif
 5556 format(' *** Warning *** : no psi-e found')
      return
      end
c-----------------------------------------------------------------------
      subroutine equit(x,k)
c
c-- calcola il riflesso equivalente per la matrice  k-esima
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common /pseud/ kmat(48,3,3),emme,patom,qatom,npseud,lpseud(4,3)
     1         ,scale,jmme,prod,prod2,mjn(5,11),njn,coef,nw(8),no(8)
      integer x(3),x1(3)
c
      do 10 i=1,3
      x1(i)=0
      do 10 j=1,3
   10 x1(i)=x1(i)+x(j)*ksmat(k,j,i)
      do 20 i=1,3
   20 x(i)=x1(i)
      return
      end
c----------------------------------------------------------------
c
      subroutine pseudt(gnew,nor1,nor2,nor3,is2,is3,nop2,nop3,hkl1,hkl2,
     *                  hkl3,e1,e2,e3,vet,kvet)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /inp/  natom,fnat,satm,atoms
      common/sinte/ abc(3),ang(3),astar,bstar,cstar,cosas,cosbs,coscs
      common /pseud/ kmat(48,3,3),emme,patom,qatom,npseud,lpseud(4,3)
     1         ,scale,jmme,prod,prod2,mjn(5,11),njn,coef,nw(8),no(8)
c
      common /xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1               isr(100000),isig(3,20000),gq(20000),gv(20000)
      integer hkl1(3),hkl2(3),hkl3(3)
      dimension vet( 7),kvet(16)
c
      call schkl(nor1,hkl1)
      call schkl(nor2,hkl2)
      call schkl(nor3,hkl3)
      call equit(hkl2,nop2)
      call equit(hkl3,nop3)
      do 10 i=1,3
      hkl2(i) = hkl2(i)*is2
   10 hkl3(i) =-hkl3(i)*is3
      isum1=0
      do 15 i=1,3
   15 isum1=iabs(hkl1(i)+hkl2(i)+hkl3(i))+isum1
      if (isum1.ne.0) then
                        write(lo,*) nor1,nor2,nor3,nop2,nop3,hkl1,hkl2,
     *                  hkl3
                        write(lo,*) '****  programming  error  ****'
                        write(lo,*) ' sir ends in error'
                        stop 1234
                      endif
      if (npseud.eq.0) go to 20
cccc
c----------   se alfa1 opp. alfa2 opp. alfa3 = 0 allora beta=0
c----------   i valori di sin(theta)/lambda calcolati in testa
cccc
      call sent(hkl1,rho1)
      call sent(hkl2,rho2)
      call sent(hkl3,rho3)
      q1=patom*rho1+qatom
      q2=patom*rho2+qatom
      q3=patom*rho3+qatom
      if (q1.gt.0.99) q1=0.99
      if (q2.gt.0.99) q2=0.99
      if (q3.gt.0.99) q3=0.99
cccc
      qfin=(q1+q2+q3)/3.0
cccc
      alfa1=float(ish(3,nor1))/1000.0
      alfa2=float(ish(3,nor2))/1000.0
      alfa3=float(ish(3,nor3))/1000.0
      call betas(beta,hkl1,hkl2,hkl3)
      com=    (alfa1*(1.0-q1)+q1)
     1   *    (alfa2*(1.0-q2)+q2)
     2   *    (alfa3*(1.0-q3)+q3)
c
      satom=sqrt(atoms)
c
      s3pm =(1.0-qatom)/satom
      s3q  =(    qatom)/satom
      s3ppp=(prod -1.0)*(qfin-qatom)/(satom*prod )
      spp  = s3ppp
      g1=0.0
      g2=0.0
      ig=0
      zer=0.0001
      if (alfa1.lt.zer) ig=ig+1
      if (alfa2.lt.zer) ig=ig+1
      if (alfa3.lt.zer) ig=ig+1
      if (ig.eq.3) g1=1.0
      if (ig.eq.2) g2=1.0
      gn = s3pm*beta*prod2/emme + s3q * ( 1.0 + coef*g1 ) + g2*s3ppp
      gn = gn / sqrt(com)
      gnew=gn*e1*e2*e3
      enhk=gn*gn
      if (abs(enhk).gt.zer) enhk=1.0/enhk
      if (gnew.ge.0.0) go to 20
   20 do 30 i=1,3
      kvet( 1+i)=hkl1(i)
      kvet( 6+i)=hkl2(i)
   30 kvet(11+i)=hkl3(i)
      kvet( 5)=int(alfa1*1000.0)
      kvet(10)=int(alfa2*1000.0)
      kvet(15)=int(alfa3*1000.0)
      kvet(16)=int(beta*1000.0)
      vet(1)=e1
      vet(2)=e2
      vet(3)=e3
      vet(4)=com
      vet(5)=prod
      vet(6)=gnew
      vet(7)=enhk
      return
      end
c---------------------------------------------------------------
      subroutine sent(hh,rho)
      integer hh(3)
      common/sinte/ abc(3),ang(3),astar,bstar,cstar,cosas,cosbs,coscs
c
      q=hh(1)*hh(1)*astar*astar
     1 +hh(2)*hh(2)*bstar*bstar
     2 +hh(3)*hh(3)*cstar*cstar
     3 +2.0*hh(2)*hh(3)*bstar*cstar*cosas
     4 +2.0*hh(3)*hh(1)*cstar*astar*cosbs
     5 +2.0*hh(1)*hh(2)*astar*bstar*coscs
      rho=0.25*q
      return
      end
c----------------------------------------------------------------------
      subroutine betas(beta,hkl1,hkl2,hkl3)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /inp/  natom,fnat,satm,atoms
      common /pseud/ kmat(48,3,3),emme,patom,qatom,npseud,lpseud(4,3)
     1         ,scale,jmme,prod,prod2,mjn(5,11),njn,coef,nw(8),no(8)
      integer hkl(3,3),hkl1(3),hkl2(3),hkl3(3)
c
      beta=0.0
      do 10 i=1,3
      hkl(i,1)=hkl1(i)
      hkl(i,2)=hkl2(i)
      hkl(i,3)=hkl3(i)
   10 continue
      do 100 i=1,jmme
      do  80 j=1,npseud
      do 80 ll=1,3
      isum=0
      do  50 k=1,3
      isum1=0
      do  30 l=1,3
      isum1=isum1+hkl(l,ll)*ksmat(i,l,k)
   30 continue
      isum=isum+isum1*lpseud(k,j)
   50 continue
      if(mod(isum,lpseud(4,j)).ne.0)go to 100
   80 continue
      beta=beta+1.0
  100 continue
      return
      end
c-----------------------------------------------------------------------
      subroutine alfas(alfa,hkl)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /inp/  natom,fnat,satm,atoms
      common /pseud/ kmat(48,3,3),emme,patom,qatom,npseud,lpseud(4,3)
     1         ,scale,jmme,prod,prod2,mjn(5,11),njn,coef,nw(8),no(8)
      integer hkl(3)
c
      gamma=0.0
      do 100 i=1,jmme
      do  80 j=1,npseud
      isum=0
      do  50 k=1,3
      isum1=0
      do  30 l=1,3
      isum1=isum1+hkl(l)*ksmat(i,l,k)
   30 continue
      isum=isum+isum1*lpseud(k,j)
   50 continue
      if(mod(isum,lpseud(4,j)).ne.0)go to 100
   80 continue
      gamma=gamma+1.0
  100 continue
      alfa=prod*gamma/emme
      return
      end
c----------------------------------------------------------
      subroutine decom(i,g,ggv,ishi,iphi)
      common /cp10/ nor(3),nop(3),iseg(3),eeb(6),ee(24,6)
c
      common /xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1               isr(100000),isig(3,20000),gq(20000),gv(20000)
      call unpak3(isig(1,i),nor(1),nor(2),if1)
      call unpak3(isig(2,i),nor(3),ign,ishi)
      call unpak3(isig(3,i),kod,igv,if2)
      g=float(ign)/100.
      ggv=float(igv)/100.
      iphi=if1*15+if2
      kod=kod+2048
      nop(1)=1
      nop(2)=kod/32
      nop(3)=mod(kod,32)
      do 10 j=1,3
      iseg(j)=isign(1,nor(j))
      nor(j)=iabs(nor(j))
      k=nor(j)
      e=float(ish(2,k)/512)/100.
      eeb(j)=e*e-1.
   10 continue
      return
      end
c----------------------------------------------------------
      subroutine schkl(j,hkl)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /inp/  natom,fnat,satm,atoms
      common/prin/ ipt,ip0,ip10,ipq
      common/param/ifat1,ifat2,ifatx,lreci,idx,icst1,icst2,icst3,duma(3)
      common/dirtr/nreft,emin,ntra,ntrt,ntrmx,nref,nweak,sgg,nstr,nzro
      common/dirps/nrefp,emax,npsa,nrefpl,npsmx
      common/dir10/numk,ntrs,ntr10,sogpo,sogen,sogne,nupos,nuena,nuneg,
     1 indpo,inden,indne,nmxte,nmxtn
      common/dirqn/ecros,iecros,ncode,icody,nquar
     1 ,nsog,sqes,nquam,nquat,nqenm,nqent,ecr1,iecr1
c
      common /xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1               isr(100000),isig(3,20000),gq(20000),gv(20000)
      integer hkl(3)
c--decompatta gli indici
c
c--
      k=ish(1,j)
      hkl(1)=k/16384-64
      k=ish(1,j)-(hkl(1)+64)*16384
      hkl(2)=k/128-64
      hkl(3)=mod(k,128)-64
      return
      end
c--------------------------------------------------------------
      subroutine wrtr9(jump1,igm,npse)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/prin/ ipt,ip0,ip10,ipq
      common /proc/ iftr,ifp10,ifnq,ifps,ifcoc,ifweig
      common/param/ifat1,ifat2,ifatx,lreci,idx,icst1,icst2,icst3,duma(3)
      common/dirtr/nreft,emin,ntra,ntrt,ntrmx,nref,nweak,sgg,nstr,nzro
      common/dirps/nrefp,emax,npsa,nrefpl,npsmx
      common/dir10/numk,ntrs,ntr10,sogpo,sogen,sogne,nupos,nuena,nuneg,
     1 indpo,inden,indne,nmxte,nmxtn
      common/dirqn/ecros,iecros,ncode,icody,nquar
     1 ,nsog,sqes,nquam,nquat,nqenm,nqent,ecr1,iecr1
      common /cp10/ nor(3),nop(3),iseg(3),eeb(6),ee(24,6)
c
      common /xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1               isr(100000),isig(3,20000),gq(20000),gv(20000)
      dimension ipu(6)
c--
c-- scrive le triplette su file
c ---  jump1=1   scrive le triplette
c ---  jump1=2   scrive le psi0
c ---  jump1=3 scrive le p10
c ---  jump1=4 scrive le psi-e
c ---  jump1=5 scrive le psi-e rafforzate
c ---
      i230=2**30
      npss=nrefp+nreft
      iz=0
      goto(100,1000,2000,3000,4000),jump1
  100 continue
c -----
c     call sub. scrittura relazioni tripletti positivi : lista  8
c -----
      iprea=0
      call frmxx (iprea,8,ntra,ntra,nreft,ifp10,igm,isig)
      return
c ---  scrive le psi0
 1000 npsfm=0
      n1=0
      do 50 i=1,npsa
      call unpak3(isig(1,i),nor1,nor2,if1)
      itab(i)=isig(1,i)
      itab1(i)=isig(2,i)
      if(nor1.gt.npss) goto 50
      call unpak3(isig(2,i),nor3,id,ishi)
      isig(1,i)=((nor2+2048)*4096+nor3+2048)*32+ishi+1
      isig(2,i)=((nor1+2048)*4096+nor2+2048)*32+ishi+1
      if(nor1.eq.n1) goto 40
      n1=nor1
      isig(1,i)=isig(1,i)+i230
   40 npsfm=npsfm+1
   50 continue
c -----
c     call  sub.  scrittura  relazioni  psi-zero  :  lista  9
c -----
      iprea=0
      call frmxx (iprea,9,npsfm,npsfm,nrefp,nxxe,iccd,isig)
      do 60 i=1,npsa
      isig(1,i)=itab(i)
   60 isig(2,i)=itab1(i)
      return
c ---  scrive le p10
 2000 ipu(1)=indpo
      ipu(2)=nupos
      ipu(3)=inden
      ipu(4)=inden+nuena-1
      ipu(5)=indne
      ipu(6)=indne+nuneg-1
c -----
c     call  sub.  scrittura  tripletti positivi  :  lista  8
c -----
      iprea=0
      if (nupos.ne.0)
     *call frmxx (iprea,8,ntra,nupos,nreft,ifp10,igm,isig(1,indpo))
c -----
c     call  sub.  scrittura  tripletti negativi  :  lista 10
c -----
      if (nuneg.ne.0)
     *call frmxx(iprea,10,nuneg,nuneg,nreft,ifp10,igm,isig(1,indne))
c -----
c     call sub. scrittura tripletti enantiomorfi :  lista 11
c -----
      if(icent.eq.0.and.nuena.ne.0)
     *call frmxx(iprea,11,nuena,nuena,nreft,ifp10,igm,isig(1,inden))
      return
 3000 continue
c -----
c     call sub. scrittura relazioni psi-e              : lista  24
c -----
      iprea=0
      if(ntra.ne.0)
     *call frmxx (iprea,24,ntra,ntra,npse,ifp10,igm,isig)
      return
 4000 continue
c -----
c     call sub. scrittura relazioni psi-e (rafforzate) : lista  24
c -----
c
c-- ci vorrebbe un sort sul numero d'ordine del primo riflesso
      ifp10=1
      iprea=0
      if(ntra.ne.0)
     *call frmxx (iprea,24,ntra,ntra,npse,ifp10,igm,isig)
      return
      end
c -----------------------------------------------
      subroutine recip
c--carica il reciproco
c--
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /inp/  natom,fnat,satm,atoms
      common/prin/ ipt,ip0,ip10,ipq
      common/param/ifat1,ifat2,ifatx,lreci,idx,icst1,icst2,icst3,duma(3)
      common/dirtr/nreft,emin,ntra,ntrt,ntrmx,nref,nweak,sgg,nstr,nzro
      common/dirps/nrefp,emax,npsa,nrefpl,npsmx
      common/dir10/numk,ntrs,ntr10,sogpo,sogen,sogne,nupos,nuena,nuneg,
     1 indpo,inden,indne,nmxte,nmxtn
      common/dirqn/ecros,iecros,ncode,icody,nquar
     1 ,nsog,sqes,nquam,nquat,nqenm,nqent,ecr1,iecr1
      common/enant/ nqenex,n23m,n23l,gm,nqen
      common/esti/ib(3),ih(3,2,24),ii(2,24)
      common/nq/nor1(6),nop1(6),iseg1(6),icodqn,sumc,sums,sume
      common/wrt/icv(4,7),ishf,ifas,ee(3),icodx(3),iqua(1000),
     1           itac(5,24,4),eee(3)
      common/lst13/l13,m13,md13,l13f,m13f,n13f
c
      common/xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1 isr(100000),isig(3,20000),inq(7,750),inq2(7,500),dumm(31250)
c--
      dimension ill(3),jvet(3),ikln(60),ivet(12),vet(12)
      equivalence (ivet(1),vet(1))
c--
c--clear the areas
      do 1001 k=1,20000
      itab(k)=0
1001  continue
      do 1004 i=1,ifatx
      isr(i)=0
1004  continue
c--create the list
      ipu=0
      do 1900 j=1,nrefpl
      kk=ish(1,j)
      ihh=kk/16384-64
      kk=ish(1,j)-(ihh+64)*16384
      ik=kk/128-64
      il=mod(kk,128)-64
      do 1100 i=1,nsym
      if (i.eq.1) then
                    indr=ihh*ifat1+ik*ifat2+il
                    itab1c=((ihh+64)*128+ik+64)*128+il+64
                  else
      ill(1)=ihh*ksmat(i,1,1)+ik*ksmat(i,2,1)+il*ksmat(i,3,1)
      ill(2)=ihh*ksmat(i,1,2)+ik*ksmat(i,2,2)+il*ksmat(i,3,2)
      ill(3)=ihh*ksmat(i,1,3)+ik*ksmat(i,2,3)+il*ksmat(i,3,3)
      indr=ill(1)*ifat1+ill(2)*ifat2+ill(3)
      itab1c=((ill(1)+64)*128+ill(2)+64)*128+ill(3)+64
                  endif
      indrr=indr
      indra=iabs(indr)
      if (i.ne.1) then
c -----   elimina i doppioni
                    imen1=i-1
                    do 1106 i1=1,imen1
                    if (indra.eq.iabs(ikln(i1))) indrr=0
 1106               continue
                  endif
      ipu=ipu+1
      itab(ipu)=indrr
      itab1(ipu)=itab1c
      ikln(i)=indrr
      a=ihh*tmat(i,1)+ik*tmat(i,2)+il*tmat(i,3)
      ia=nint(a*24)+480
      ia=mod(ia,24)
      itab1(ipu)=itab1(ipu)*32+ia
      indr=iabs(indr)
      if(isr(indr).eq.0)isr(indr)=-(icst1+j)
 1100 continue
 1900 continue
c--carica i deboli
      j400a=nreft+1
      j400b=nreft+nrefp
      do 3000 j=j400a,j400b
      call schkl(j,jvet)
      kk=ish(1,j)
      ihh=kk/16384-64
      kk=ish(1,j)-(ihh+64)*16384
      ik=kk/128-64
      il=mod(kk,128)-64
      do 3100 i=1,nsym
      ill(1)=ihh*ksmat(i,1,1)+ik*ksmat(i,2,1)+il*ksmat(i,3,1)
      ill(2)=ihh*ksmat(i,1,2)+ik*ksmat(i,2,2)+il*ksmat(i,3,2)
      ill(3)=ihh*ksmat(i,1,3)+ik*ksmat(i,2,3)+il*ksmat(i,3,3)
      indr=ill( 1)*ifat1+ill( 2)*ifat2+ill( 3)
      isgn=isign(1,indr)
      indr=iabs(indr)
      if(isr(indr).eq.0) isr(indr)=-(2*icst1+j)
3100  continue
3000  continue
c
c--create the isr list
      jord=1
      call ysfl07(nrefl,nstr,nzro,npseud,iy)
      do 2900 i=1,nrefl
      call snr07(vet)
      jh=ivet(1)
      jk=ivet(2)
      jl=ivet(3)
      e=vet(4)
      do 2800 i1=1,nsym
      ill(1)=jh*ksmat(i1,1,1)+jk*ksmat(i1,2,1)+jl*ksmat(i1,3,1)
      ill(2)=jh*ksmat(i1,1,2)+jk*ksmat(i1,2,2)+jl*ksmat(i1,3,2)
      ill(3)=jh*ksmat(i1,1,3)+jk*ksmat(i1,2,3)+jl*ksmat(i1,3,3)
      indr=ill(1)*ifat1+ill(2)*ifat2+ill(3)
      indr=iabs(indr)
      if (e.le.0.0) e=0.01
      if(isr(indr).eq.0) then     
                           isr(indr)=int(e*100.+0.5)*icst3+jord
                         endif
 2800 continue
      jord=jord+1
      if(jord.gt.icst3) then     
                          write(lo,4)jh,jk,jl
    4 format(1x,'too much independent reflections, last reflec',
     ,'tion stored :',3i4)
                        endif
 2900 continue
      if (nsym.eq.1) return
      call geest
      return
      end
c-----------------------------------------------------------
      subroutine negq(result)
c--calculate negative quartet
c  h1 + h2 + h3 + h4 = 0
c  i  h1 code
c  j  h2 code
c jj  h3 code
c in  h4 code
c
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /inp/  natom,fnat,satm,atoms
      common/prin/ ipt,ip0,ip10,ipq
      common/param/ifat1,ifat2,ifatx,lreci,idx,icst1,icst2,icst3,duma(3)
      common/dirtr/nreft,emin,ntra,ntrt,ntrmx,nref,nweak,sgg,nstr,nzro
      common/dirps/nrefp,emax,npsa,nrefpl,npsmx
      common/dir10/numk,ntrs,ntr10,sogpo,sogen,sogne,nupos,nuena,nuneg,
     1 indpo,inden,indne,nmxte,nmxtn
      common /cp10/ nor(3),nop(3),iseg(3),eeb(6),ee2(24,6)
      common/dirqn/ecros,iecros,ncode,icody,nquar
     1 ,nsog,sqes,nquam,nquat,nqenm,nqent,ecr1,iecr1
      common/enant/ nqenex,n23m,n23l,gm,nqen
      common/esti/ib(3),ih(3,2,24),ii(2,24)
      common/nq/nor1(6),nop1(6),iseg1(6),icodqn,sumc,sums,sume
      common/wrt/icv(4,7),ishf,ifas,ee(3),icodx(3),iqua(1000),
     1           itac(5,24,4),eee(3)
      common/lst13/l13,m13,md13,l13f,m13f,n13f
      common/zero/arnq(26),ncal(26),nver(26),ntt,fm(26),gt(26)
c
      common/xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1 isr(100000),isig(3,20000),inq(7,750),inq2(7,500),dumm(31250)
c--
      dimension ev(7)
      integer result(7,2)
c--
c
      zer = 0.1E-10
      call recip
c--new 12/6/92
      if(knw.eq.1) then
                     if (icent.eq.1) then
                                       call clrt
                                     else
                                       call nclrt
                                     endif
                   endif
      if (icent.eq.1) then
                        call clrt1
                      else
                        call nclrt1
                      endif
c--endnew 12/6/92
c
c--calculate negative quartet(s) from psi-zero relationships.
c
c--ncode:codice per definire il tipo di quart.(in funzione dei c.v.)
c        da valutare.
c  ncode=0   tutti
c  ncode=1   1deb+1ass.spec.+1ass.
c  ncode=2   1deb+est.+1ass.
c  ncode=3   2deb+1ass.
c  ncode=4   2deb+1ass.spec.
c  ncode=5   2deb+1est.
c  ncode=6   3deb
c  ncode=7   2deb+1non forte(casi 3,4,5 e 6 insieme)
c  icody=1   valuta solo i quart. con equiv.
      write(lo,1) npsa
    1 format(/,' Negative quartets relationships estimated using ',
     *i6,' psi-zero relationships ')
      iend=0
      niqua=0
      liqua=60
      liqu3=liqua*3
      nquar=0
      nquae=0
      fnatt=fnat*fnat
      atcel=1./fnatt
           if(atcel.lt.70) then
                             sgnq=0.35
      else if(atcel.ge.70.and.atcel.lt.700) then
                             sgnq=0.35*exp(-((atcel-70)/500.))
      else if(atcel.ge.700) then
                             sgnq=0.1
                           endif
      if (icent.eq.1) then
                        sqes=-9999.0
                      else
                        sqes=sgnq
                      endif
      l13=1
      m13=l13
      md13=3
      n13f=1000/md13
      nqen=0
      nqenex=0
      do 101 i=1,7
      do 101 j=1,750
      inq(i,j)=0
 101  continue
      do 102 i=1,7
      do 102 j=1,500
  102 inq2(i,j)=0
      npsm1=npsa-1
      do 1000 i=1, npsm1
      is1=isig(1,i)/131072-2048
      call schkl(is1,nop)
      indr=nop(1)*ifat1+nop(2)*ifat2+nop(3)
      ispec=isr(indr)/icst2
      ispec=mod(ispec,2)
      isr1=isr(indr)
      call decom(i,g1,dum,ishi,iphi)
      do 1100 k=2,3
      k1=k-1
      call xbc9(nor(k),k1,nsym)
      do 1752 jc=1,4
      icv(jc,k1)=itac(jc,nop(k),k1)*iseg(k)
1752  continue
      nop1(k)=nop(k)
      nor1(k)=nor(k)
      iseg1(k)= iseg(k)
 1100 continue
      iplus1=i+1
      do 2000 j=iplus1, npsa
      is2=isig(1,j)/131072-2048
      if(is1.ne.is2) goto 1000
c--quartetto
      do 1290 k=1,3
      icodx(k)=0
 1290 continue
      iflag=0
      do 1291 k=1,4
      do 1291 k1=5,7
      icv(k,k1)=0
      eee(k1-4)=0
 1291 continue
c -- v.b.
      call decom(j,g2,dum,ishi,iphi)
c --
c --  controllo di diversita' dei v.b.
      do 1110  k=2,3
      do 1110  k1=2,3
      if(nor(k).eq.nor1(k1)) goto 2000
 1110 continue
      do 1200 k=2,3
      k1=k+1
      iseg(k)=-iseg(k)
      call xbc9(nor(k),k1,nsym)
      do 1754 jc=1,4
      icv(jc,k1)=itac(jc,nop(k),k1)*iseg(k)
1754  continue
 1200 continue
c-- first c.v.
      do 1250 k=1,4
      icv(k,5)= (icv(k,1)+icv(k,2))
 1250 continue
      eee(1)=float(ish(2,nor (1))/512)/100.
      ee(1)=eee(1)*eee(1)-1
      iqua(l13)=-nor(1)
      if(ispec.ne.0)iflag=iflag+1
c--c.v.
      m13=l13
      iqua(2)=0
      iqua(3)=0
      do 1301 k=2,3
      ied=iedeb(k,nor(1),0)
      if(ied.ne.0) go to 2000
 1301 continue
      do 1300 k1=1,2
      if(icodx(k1).ge.2) goto 2000
 1300 continue
      icont=6-icodx(1)*3-icodx(2)*2-icodx(3)
      if(icont.eq.0) then      
                        write(lo,*) '**** subroutine negq ****'
                        write(lo,*) '**** programming  error ****'
                        write(lo,*) ' sir ends in error'
                        stop 1234
                     endif
      if(icont.lt.3) go to  2000
c--ishf=fase quart. vero (ifass)-fase quart. stan.(iphi)
      is=itac(5,nop1(2),1)*iseg1(2)+itac(5,  nop1(3),2)*iseg1(3)
     ,  +itac(5,  nop (2),3)*iseg(2)+itac(5,  nop (3),4)*iseg(3)
      is=96-is
      is=mod(is,24)
      iss=is*15
      ishf=iss
c--
      sumep=ee(1)+ee(2)+ee(3)
      if(icodx(3).ne.0.or.iflag.ne.0) goto 2650
      if(sumep.gt.-1) goto 2000
 2650 shf=float(is)*twopi/24.
      cosx=cos(shf)
      sinx=sin(shf)
      sumc=sumep*cosx
      sums=sumep*sinx
      iph1=mod(ish(2,nor1(2)),512)*iseg1(2)
      iph2=mod(ish(2,nor1(3)),512)*iseg1(3)
      iph3=mod(ish(2,nor (2)),512)*iseg (2)
      iph4=mod(ish(2,nor (3)),512)*iseg (3)
      iphi=iph1+iph2+iph3+iph4
      if(iphi.lt.0)iphi=iphi+1800
      iphi=mod(iphi,360)
      ifas=iphi
      ifass=ifas+ishf
      if(ifass.lt.0)ifass=ifass+1800
      ifass=mod(ifass,360)
      fass=float(ifass)*pi/180.
      ev(1)=float(ish(2,nor1(2))/512)/100.
      ev(2)=float(ish(2,nor1(3))/512)/100.
      ev(3)=float(ish(2,nor (2))/512)/100.
      ev(4)=float(ish(2,nor (3))/512)/100.
      g=ev(1)*ev(2)*ev(3)*ev(4)
      g=g*fnat*fnat
      do 1764 k1=1,3
      ev(k1+4)=ee(k1)
 1764 continue
      if(iflag.ne.0) then     
                      do 1292 k=4,liqu3
                      iqua(k)=0
 1292                 continue
                      niqua=niqua+1
                      if(iequi(nor(1),liqu3).lt.0) goto 2000
                     endif
      m13=l13
      gb=g
      if(g.gt.20.47) gb=20.47
      jg=nint(gb*100.0)
c--calcolo del gcorr.
      if(icodx(3).eq.0) then     
                           sums=sums+sin(shf)
                           sumc=sumc+cos(shf)
                        endif
      if (abs(sums).lt.zer.and.abs(sumc).lt.zer) go to 2000
c-------
      sum=sumc*sumc+sums*sums
      sum=sqrt(sum)
      gc=(2-icent)*g*sum
      if(gc.gt.20.47)gc=20.47
      jgc=nint(gc*100.0)
      thet =-atan2(sums,sumc)
      if(thet.lt.0)thet=thet+twopi
      theta=thet *360./twopi
      thet=thet+shf
      cost=cos(thet)
      if(gc.gt.sqes.or.icent.eq.1) goto 1430
      if(iend.eq.1) goto 2000
      call enan(jg,jgc,gc,is,thet,ifass,nquae,iend)
      goto 2000
 1430 if(cost.ge.0.or.gc.lt.sgnq) goto 2000
      ith=nint(thet*100.0)
      if (icont.lt.5) then      
                        gc=gc*0.85
                        jgc=nint(gc*100)
                      endif
      if(nquar.ne.nquat) then     
                            nquar=nquar+1
                            inq(1,nquar)=iseg1(2)*(nor1(2)*32+nop1(2))
                            inq(2,nquar)=iseg1(3)*(nor1(3)*32+nop1(3))
                            inq(3,nquar)=iseg (2)*(nor (2)*32+nop (2))
                            inq(4,nquar)=iseg (3)*(nor (3)*32+nop (3))
                            inq(5,nquar)=jg*32+is
                            inq(6,nquar)=jgc*1000+ith
                            inq(7,nquar)=(ifass*10*8+icont)
                            goto 2000
                         endif
      if(nquae.eq.0) then     
                            call sortc(nquar,inq)
                            n13m=nquar
                            n13l=nquar
                            jjgm=inq(6,nquar)/1000
                            gm=float(jjgm)/100.
                     endif
      nquae=nquae+1
      if(nquae.eq.nquam) goto 4000
      if(gc.ge.gm) then      
                     inq(1,n13m)=iseg1(2)*(nor1(2)*32+nop1(2))
                     inq(2,n13m)=iseg1(3)*(nor1(3)*32+nop1(3))
                     inq(3,n13m)=iseg (2)*(nor (2)*32+nop (2))
                     inq(4,n13m)=iseg (3)*(nor (3)*32+nop (3))
                     inq(5,n13m)=jg*32+is
                     inq(6,n13m)=jgc*1000+ith
                     inq(7,n13m)=(ifass*10*8+icont)
                     gm=100.
                     i00=n13l-1
                     if(i00.lt.1) i00=1
                     do 1650 ij=i00,nquar
                     jjga=inq(6,ij)/1000
                     ga=float(jjga)/100.
                     if(ga.le.gm) then          
                                    gm=ga
                                    n13m=ij
                                  endif
 1650                continue
                     n13l=min0(n13l,n13m)
                   endif
 2000 continue
 1000 continue
 4000 call sortc(nquar,inq)
      do 8888 i=1,nquar
      n1=inq(1,i)/32
      n2=inq(2,i)/32
      n3=inq(3,i)/32
      n4=inq(4,i)/32
      jgc=inq(6,i)/1000
      is=mod(inq(5,i),32)
      inq(1,i)=((n1+2048)*4096+n2+2048)*32
      inq(2,i)=((n3+2048)*4096+n4+2048)*32
      inq(3,i)=((1024+2048)*4096+jgc+2048)*32+is+1
c--NEW 12/6/92 introduco statistica quartetti negativi
      ifass=iabs(inq(7,i)/80)
      b=float(ifass)*pi/180.
      a=cos(b)
      gg=-float(jgc)/100
      an=a*gg
      if (icent.eq.1) then
c-- centrosymmetric test
                        if (knw.eq.1) call sctst(gg,an,1)
                        call sctst1(gg,an)
                      else
c-- noncentrosymmetric test
                        g2=jgc/100
                        call besse(g2,coat)
                        g2=gg
                        coat=-coat
                        bang=ifass
                        if (ifass.gt.180) bang=360.0-bang
                        if (knw.eq.1) call nctet(g2,a,bang,1)
                        call nctet1(g2,coat,a)
                      endif
c--endNEW 12/6/92 introduco statistica quartetti negativi
 8888 continue
      do 8899 i=1,nqen
      n1=inq2(1,i)/32
      n2=inq2(2,i)/32
      n3=inq2(3,i)/32
      n4=inq2(4,i)/32
      jgc=inq2(6,i)/1000
      is=mod(inq2(5,i),32)
      inq2(1,i)=((n1+2048)*4096+n2+2048)*32
      inq2(2,i)=((n3+2048)*4096+n4+2048)*32
      inq2(3,i)=((1024+2048)*4096+jgc+2048)*32+is+1
 8899 continue
c -----
c     call  sub.  per  scrittura  quartetti  negativi  :  lista   20
c -----
      iprea=0
      if(nquar.ne.0) then
                     call frmxx(iprea,20,nquar,nquar,nxxd,nxxe,iccd,inq)
                     if(knw.eq.1) then
                                    if (icent.eq.1) then
                                                      call stst
                                                    else
                                                      call nstst
                                                    endif
                                  endif
                              write(lo,2998)
                              if (icent.eq.1) then
                                                call stst1
                                              else
                                                call nstst1
                                              endif
                    endif
 2998 format(/,38x,'         Negative quartets statistic')
c -----
c     call  sub.  per  scrittura  quartetti  enantiom. :  lista   21
c -----
      if(icent.eq.0.and.nqen.ne.0)
     *call frmxx(iprea,21,nqen,nqen,nxxd,nxxe,iccd,inq2)
      nquae=nquae+nquar
      nqenex=nqenex+nqen
      if (iprin.gt.0) then
      write(lo,2999)
 2999 format(1h )
      write(lo,3001)nquae,nquar
 3001 format(i8,' negative quartet(s) calculated and',i6,' stored')
      write(lo,2999)
      if (icent.eq.0) write(lo,3002) nqenex,nqen
 3002 format(i8,' enant.sens. quartet(s) calculated and',i6,' stored')
                      endif
      result(6,1)=nquae
      result(6,2)=nquar
      result(7,1)=nqenex
      result(7,2)=nqen
      write(lo,2999)
      return
      end
c---------------------------------------------------------------------
      function iedeb(i,im,i10)
c
c--controlla esistenza,debolezza ed specialita del ii-esimo c.v.
c--(tabella ies)
c
c--iedeb=0 ok.
c--iedeb=1 rifl. forte
c--iedeb=-1 no. ord. c.v. le n.ord. primo c.v.
c
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /inp/  natom,fnat,satm,atoms
      common /cp10/ nor(3),nop(3),iseg(3),eeb(6),ee2(24,6)
      common/param/ifat1,ifat2,ifatx,lreci,idx,icst1,icst2,icst3,duma(3)
      common/dirqn/ecros,iecros,ncode,icody,nquar
     1 ,nsog,sqes,nquam,nquat,nqenm,nqent,ecr1,iecr1
      common/esti/ib(3),ih(3,2,24),ii(2,24)
      common/nq/nor1(6),nop1(6),iseg1(6),icodqn,sumc,sums,sume
      common/wrt/icv(4,7),ishf,ifas,ee(3),icodx(3),iqua(1000),
     1           itac(5,24,4),eee(3)
      common/lst13/l13,m13,md13,l13f,m13f,n13f
      common/zero/arnq(26),ncal(26),nver(26),ntt,fm(26),gt(26)
c
      common/xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1 isr(100000),isig(3,20000),inq(7,750),inq2(7,500),dumm(31250)
c
      if (i10.eq.0) then
                     ecr=ecros
                     iecr=iecros
                    else
                     ecr=ecr1
                     iecr=iecr1
                    endif
      iedeb=0
      ia=0
      i4=i+4
      i2=i+1
      do 900 jj1=i,3
      eee(jj1)=0
  900 ee(jj1)=0
      do 1000 jj1=1,4
      do 1000 jj2=i4,7
 1000 icv(jj1,jj2)=0
      ihy=icv(1,1)+icv(1,i2)
      ihyx=iabs(ihy)
c
c-- controlla se esiste il riflesso
c
      if (ihyx.gt.ifatx.or.ihyx.le.0)  goto 1900
      jk=icv(3,1)+icv(3,i2)
      if(iabs(jk).gt.ihx(2))  goto 1900
      jl=icv(4,1)+icv(4,i2)
      if(iabs(jl).gt.ihx(3))  goto 1900
c--controllo di debolezza.
      ie=isr(ihyx)
      if(ie.eq.0) goto 1900
      if(ie.ge.0) then      
c--riflesso non speciale forte o debole
                    ia=mod(ie,icst3)
                    eee(i)=float(ie/icst3)/100.
                    ee(i)=eee(i)*eee(i)-1
                    if(eee(i).gt.ecr) iedeb=1-i10
                    goto 1800
                  endif
      if(ie.eq.-4*icst1) then     
c--rifl.estinto
                          icodx(3)=icodx(3)+1
                          eee(i)=0.
                          ee(i)=0
                          iflag=iflag+1
                          goto 1800
                         endif
      if(ie.eq.-5*icst1)  then     
c--riflesso assente ma speciale
                            iflag=iflag+1
                            icodx(2)=icodx(2)+1
                            eee(i)=1.0
                            ee(i)=0.0
                            goto 1800
                          endif
      it=-ie/icst1
      if(it.eq.1) then      
c--rifl. tra i 200 forte (lista 7)
                    ie=-ie
                    ie=mod(ie,icst3)
                    ia=-ie
                    iedeb=1-i10
                    eee(i)=float(ish(2,ie)/512)/100.
                    ee(i)=eee(i)*eee(i)-1
                    goto 1800
                  endif
      if(it.eq.2) then     
c--rifl. tra i 50 piu deboli.
                   ie=-ie
                   ispec=ie/icst2
                   ispec=mod(ie,2)
                   ie=mod(ie,icst3)
                   ia=-ie
                   if(ie.lt.im) then     
                                  iedeb=-1
                                else
                                  eee(i)=float(ish(2,ie)/512)/100.
                                  ee(i)=eee(i)*eee(i)-1
c--rifl. spec.
                                  if(ispec.ne.0) iflag=iflag+1
                                endif
                   goto 1800
                  endif
c--riflesso speciale
      if(it.ne.3)  then
                        write(lo,*) '**** function iedeb  ****'
                        write(lo,*) '**** programming  error ****'
                        write(lo,*) ' sir ends in error'
                        stop 1234
                      endif
      ie=mod(ie,icst2)
      ia=mod(ie,icst3)
      ie=ie/icst3
c--rifl.forte spec
      eee(i)=float(ie)/100.
      ee(i)=eee(i)*eee(i)-1
      if(ie.gt.iecr) iedeb=1-i10
      if(iedeb.eq.0) iflag=iflag+1
 1800 icv(2,i4)=icv(2,1)+icv(2,i2)
      icv(3,i4)=jk
      icv(4,i4)=jl
      icv(1,i4)=icv(2,i4)*ifat1+icv(3,i4)*ifat2+icv(4,i4)
      iqua(m13+i-1)=ia
      return
 1900 icodx(1)=icodx(1)+1
      ee(i)=0
      return
      end
c---------------------------------------------------------------------
      subroutine xbc9(i,k,nn)
      common/wrt/icv(4,7),ishf,ifas,ee(3),icodx(3),iqua(1000),
     1           itac(5,24,4),eee(3)
c
      common/xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1 isr(100000),isig(3,20000),inq(7,750),inq2(7,500),dumm(31250)
c
      in=(i-1)*nn
      do 10 n=1,nn
         inn=in+n
         itac(1,n,k)=itab(inn)
         ita=itab1(inn)/32
         ih=ita/16384-64
         itac(2,n,k)=ih
         ita=ita-(ih+64)*16384
         itac(3,n,k)=ita/128-64
         itac(4,n,k)=mod(ita,128)-64
         itac(5,n,k)=mod(itab1(inn),32)
   10 continue
      return
      end
c-------------------------------------------------------------
      function iequi(im,liqu3)
      character iast(3),iblan,istar
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /inp/  natom,fnat,satm,atoms
      common/prin/ ipt,ip0,ip10,ipq
      common/param/ifat1,ifat2,ifatx,lreci,idx,icst1,icst2,icst3,duma(3)
      common/dirqn/ecros,iecros,ncode,icody,nquar
     1 ,nsog,sqes,nquam,nquat,nqenm,nqent,ecr1,iecr1
      common/esti/ib(3),ih(3,2,24),ii(2,24)
      common/nq/nor1(6),nop1(6),iseg1(6),icodqn,sumc,sums,sume
      common/wrt/icv(4,7),ishf,ifas,ee(3),icodx(3),iqua(1000),
     1           itac(5,24,4),eee(3)
      common/lst13/l13,m13,md13,l13f,m13f,n13f
      common /cp10/ nor(3),nop(3),iseg(3),eeb(6),ee2(24,6)
c
      common/xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1 isr(100000),isig(3,20000),inq(7,750),inq2(7,500),dumm(31250)
      dimension icvv(4,7)
c--
c
      data istar,iblan/'*',' '/
      iequi=0
      iop1=nop1(2)
      do 50 i=1,4
      do 50 j=1,7
   50 icvv(i,j)=icv(i,j)
      do 100 i=1,4
      icv(i,1)=itac(i,iop1,1)*iseg1(2)
 100  continue
c--m13 indirizzo del quart. originale
      n13f=1
      if (icent.eq.0) then
c--  caso non centrosimmetrico
                        lf=1
c--  caso centrosimmetrico
                      else
                        lf=3
                      endif
      m13 =l13+md13
      do 3000 i=1,nsym
      if(itac(1,i,2).eq.0) goto 3000
      do 1800 l=1,lf,2
      do 2000 j=1,nsym
      if(itac(1,j,3).eq.0) goto 2000
      do 1900 ll=1,lf,2
      ll2=2-l
      ll3=2-ll
c -- ih4 = superindice del 4-to vettore base
      ih4=itac(1,iop1, 1)*iseg1(2)+itac(1,i, 2)*ll2*iseg1(3)+
     1    itac(1,j,3)*ll3*iseg(2)
      if(ih4.ne.0) then     
              ih4=-ih4*iseg(3)
              do 1700 k1=1,nsym
              if(ih4.eq.itac(1,k1,4)) then      
                                        ll4=1
                                        go to 1750
                                      else
                                        if(icent.eq.0) goto 1700
                                        ll4=-1
                                    if(ih4.eq.-itac(1,k1,4)) goto 1750
                                      endif
 1700         continue
              goto 1900
 1750         continue
              ishn=itac(5,i, 2)*iseg1(3)*ll2+itac(5,j, 3)*iseg(2)*ll3+
     1        itac(5,k1,4)*iseg(3)*ll4+itac(5,iop1,1)*iseg1(2)
              ishn=-ishn
              ishn=ishn*15+720
              ishn=mod(ishn,360)
              lll2=ll2*iseg1(3)
              lll3=ll3*iseg (2)
              lll4=ll4*iseg (3)
              do 1752 jc=1,4
              icv(jc,2)=itac(jc,i,2)*lll2
 1752         continue
              do 1754 jc=1,4
              icv(jc,3)=itac(jc,j,3)*lll3
 1754         continue
              do 1756 jc=1,4
              icv(jc,4)=itac(jc,k1,4)*lll4
 1756         continue
              do 1760 k=1,3
              ied=iedeb(k,im,1)
              if(ied.ne.0) then     
                            if (iprin.eq.2)     
     *                      write(lo,4)((icv(jj,kkc),jj=2,4),kkc=1,4),
     1                       ((icv(j1,k1),j1=2,4),ee(k1-4),k1=5,7),ied
    4 format(2x,4(3i3,5x),3x,3(3i3,f5.2),'quart. rejected  iedeb=',i3)
                                goto 9000    
                           endif
 1760         continue
              do 1790 k1=1,3
              iast(k1)=iblan
              isto=    (iqua(m13+k1-1))
              if(isto.ne.0) then     
              m13f=l13
              do 1785 k=1,n13f
              do 1780 k2=1,3
              isto1=    (iqua(m13f+k2-1))
              if(isto.eq.isto1) then     
                                  iast(k1)=istar
                                  ee(k1)=0.
                                  iqua(m13+k1-1)=0
                                  goto 1790
                                endif
 1780         continue
              m13f=m13f+md13
 1785         continue
                            endif
 1790         continue
              if(iprin.eq.2)
     1        write(lo,1)((icv(jj,k),jj=2,4),k=1,4)
     2,((icv(j1,k1),j1=2,4),ee(k1-4),iast(k1-4),k1=5,7),ishn 
  1   format(2x,4(3i3,5x),3x,3i3,f5.2,a1,2(3i3,f5.2,a1),i5)
c--quartetto equivalente o.k. con almeno un c.v.
c  in icv(4,7) ho indici
c  in ishn     ho lo shift
c  in ee(3)    ho gli epsilon
c
              shn=ishn*twopi/360.
              sumep=ee(1)+ee(2)+ee(3)
              sume=sumep+sume
              cosx=cos(shn)
              sinx=sin(shn)
              sumc=sumep*cosx+sumc
              sums=sumep*sinx+sums
              if(iprin.eq.2)
     1        write(lo,9)sume,sumep,sumc,sums,cosx,sinx,shn,ishn
 9    format(1x,'sume=',e10.2,'sumeps= ',e10.2,' sumcos= ',e10.2,
     ,' sumsin= ',e10.2,' cos=',e10.2,' sin=',e10.2,f10.2,i10)
              m13=m13+md13
              if(m13.ge.liqu3) then     
              write(lo,10)nor1(2),nor1(3),nor(2),nor(3),liqu3
  10  format(4i6,' quartet with more than ',i4,' equivalents')
                              goto 9000
                               endif
              n13f=n13f+1
              endif
 1900 continue
 2000 continue
 1800 continue
 3000 continue
      goto 9050
 9000 iequi=-1
 9050 do 9060 i=1,4
      do 9060 j=1,7
 9060 icv(i,j)=icvv(i,j)
      return
      end
c----------------------------------------------------------
      subroutine sortc(numb,inq)
c--sort the negative/enantiomorph-sensitive quartet list
c
      dimension inq(7,numb)
c--
      if(numb.eq.1) return
      m=2
 2010 in=numb/m
      if(in.le.0) in=1
      ifin=numb-in
 2040 mark=0
      do 2060 i=1,ifin
      k=i+in
      jn1=inq(6,i)/1000.0
      jn2=inq(6,k)/1000.0
      if(jn1.ge.jn2) goto 2060
      do 2055 n=1,7
      jc=inq(n,i)
      inq (n,i)=inq (n,k)
      inq (n,k)=jc
2055  continue
      mark=1
2060  continue
      if(mark.gt.0) goto 2040
      if(in.le.1) goto 2080
      m=m*2
      goto 2010
 2080 return
      end
c-------------------------------------------------------
      subroutine geest
c--genera gli estinti
c
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /inp/  natom,fnat,satm,atoms
      common/prin/ ipt,ip0,ip10,ipq
      common/param/ifat1,ifat2,ifatx,lreci,idx,icst1,icst2,icst3,duma(3)
      common/dirtr/nreft,emin,ntra,ntrt,ntrmx,nref,nweak,sgg,nstr,nzro
      common/dirps/nrefp,emax,npsa,nrefpl,npsmx
      common/dir10/numk,ntrs,ntr10,sogpo,sogen,sogne,nupos,nuena,nuneg,
     1 indpo,inden,indne,nmxte,nmxtn
      common/dirqn/ecros,iecros,ncode,icody,nquar
     1 ,nsog,sqes,nquam,nquat,nqenm,nqent,ecr1,iecr1
      common/esti/ib(3),ih(3,2,24),ii(2,24)
c
      common/xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1 isr(100000),isig(3,20000),inq(7,750),inq2(7,500),dumm(31250)
c--
      dimension ia(3,3),tras(3),jhk(2,24)
c--
c--definizione della matrice differenza.
c--
      do 1000 k=1,nsym
      icp1=icent+1
      do 1100 k1=1,icp1
      ii(k1,k)=0
      ll1=1
      if(k1.eq.2)ll1=-1
      do 1110 j=1,3
      do 1120 i=1,3
      ll2=0
      if(i.eq.j)ll2=1
      ia(j,i)=ll2-ll1*ksmat(k,j,i)
 1120 continue
 1110 continue
c--analisi della matrice somma e differenza.
c
      do 1200 j=1,3
      ih(j,k1,k)=-1
      if(ia(j,j).eq.0)ih(j,k1,k)=0
      do 1300 i=1,3
      if(i.eq.j) goto 1300
      if(ia(i,j).ne.0) goto 1250
      if(ia(j,i).ne.0) goto 1250
 1300 continue
      ih(j,k1,k)=ih(j,k1,k)+1
 1250 if(ih(j,k1,k).eq.-1)ih(j,k1,k)=3
      ii(k1,k)=ii(k1,k)+ih(j,k1,k)
 1200 continue
c--analiza se ci sono due componenti uguali e diverse da 0
      if(ii(k1,k).lt.6) goto 1150
      do 1400 i=1,2
      i1=i
      if(ih(i,k1,k).ne.3) goto 1400
      iplus1=i+1
      do 1500 j=iplus1,3
      j1=j
      if(ih(i,k1,k).eq.ih(j,k1,k)) goto 1600
 1500 continue
 1400 continue
c--analiza se il determinante e' diverso da 0
 1600 in=ia(i1,i1)*ia(j1,j1)-ia(i1,j1)*ia(j1,i1)
      jhk(k1,k)=1
      im=isign(1,ia(i1,i1))+isign(1,ia(j1,j1))
     1  +isign(1,ia(i1,j1))+isign(1,ia(j1,i1))
      if(im.ne.0)jhk(k1,k)=-1
      if(in.eq.0) goto 1100
      ii(k1,k)=ii(k1,k)-6
      ih(j1,k1,k)=0
      ih(i1,k1,k)=0
c--analiza se c'e' un unica componente uguale a 3
 1150 if(ii(k1,k).ne.4.and.ii(k1,k).ne.3) goto 1100
      do 1160 j=1,3
      j1=j
      if(ih(j,k1,k).eq.3) goto 1161
 1160 continue
      goto 1100
 1161 ih(j1,k1,k)=0
      ii(k1,k)=ii(k1,k)-3
1100  continue
 1000 continue
c--genera gli estinti
      do 2000 k=1,nsym
      mark=0
      do 2200 i=1,3
      tras(i)=tmat(k,i)
      ib(i)=0
      if(tmat(k,i).lt.0.001) goto 2200
      mark=1
      b=1.0/tmat(k,i)
      do 2300 j=1,8
      b1=b*j+.0001
      ib(i)=int(b1)
      b2=float(ib(i))
      if((b1-b2).le..001) goto 2200
 2300 continue
 2200 continue
      icp1=icent+1
      do 2100 k1=1,icp1
      if(ii(k1,k).eq.0) goto 2100
      iik1k=ii(k1,k)
      goto(2500,2600,2100,2100,2100,2700,2700,2100,2100),iik1k
 2500 call screw(k1,k)
      goto 2100
 2600 call glide(k1,k)
      goto 2100
 2700 call tetra(k1,k,tras,jhk)
 2100 continue
 2000 continue
      return
      end
c-------------------------------------------------
      subroutine screw(k1,k)
      dimension ind(3)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /inp/  natom,fnat,satm,atoms
      common/prin/ ipt,ip0,ip10,ipq
      common/param/ifat1,ifat2,ifatx,lreci,idx,icst1,icst2,icst3,duma(3)
      common/dirtr/nreft,emin,ntra,ntrt,ntrmx,nref,nweak,sgg,nstr,nzro
      common/dirps/nrefp,emax,npsa,nrefpl,npsmx
      common/dir10/numk,ntrs,ntr10,sogpo,sogen,sogne,nupos,nuena,nuneg,
     1 indpo,inden,indne,nmxte,nmxtn
      common/dirqn/ecros,iecros,ncode,icody,nquar
     1 ,nsog,sqes,nquam,nquat,nqenm,nqent,ecr1,iecr1
      common/esti/ib(3),ih(3,2,24),ii(2,24)
c
      common/xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1 isr(100000),isig(3,20000),inq(7,750),inq2(7,500),dumm(31250)
c--
      do 100 j=1,3
      j1=j
      if(ih(j,k1,k).ne.0)  goto 200
 100  continue
  200 do 300  l=1,3
      ind(l)=0
 300  continue
      ibb=1
      if(ib(j1).ne.0)ibb=ib(j1)
      ihm=ihx(j1)
      do 400 l=1,ihm
      ind(j1)=l
      mad=mod(l,ibb)
      if(mad.eq.0) goto 350
      indr=iabs(ind(1)*ifat1+ind(2)*ifat2+ind(3) )
      isr(indr)=-4*icst1
      if(iprin.eq.3) write(lo,10)(ind(i),i=1,3)
   10 format(1x,'rifl. estinto  ',3i4)
      goto 400
  350 call specq(ind)
 400  continue
      return
      end
c------------------------------------------------
      subroutine glide(k1,k)
      dimension ind(3)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /inp/  natom,fnat,satm,atoms
      common/prin/ ipt,ip0,ip10,ipq
      common/param/ifat1,ifat2,ifatx,lreci,idx,icst1,icst2,icst3,duma(3)
      common/dirtr/nreft,emin,ntra,ntrt,ntrmx,nref,nweak,sgg,nstr,nzro
      common/dirps/nrefp,emax,npsa,nrefpl,npsmx
      common/dir10/numk,ntrs,ntr10,sogpo,sogen,sogne,nupos,nuena,nuneg,
     1 indpo,inden,indne,nmxte,nmxtn
      common/dirqn/ecros,iecros,ncode,icody,nquar
     1 ,nsog,sqes,nquam,nquat,nqenm,nqent,ecr1,iecr1
      common/esti/ib(3),ih(3,2,24),ii(2,24)
c
      common/xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1 isr(100000),isig(3,20000),inq(7,750),inq2(7,500),dumm(31250)
      mad=1
      m1=0
      m2=0
      jj=0
      mark=0
      ihm1=0
      ihm2=0
      do 100 j=1,3
      ind(j)=0
      if(ih(j,k1,k).eq.0) goto 100
      jj=jj+j
      if(ib(j).ne.0)mark=1+mark
 100  continue
      if(jj.eq.0)return
      goto(500,500,110,120,130),jj
  110 m1=1
      m2=2
      goto 200
  120 m1=1
      m2=3
      goto 200
  130 m1=2
      m2=3
  200 if(ib(m1).ne.0)mad=ib(m1)
      ihm1=ihx(m1)
      if(ib(m2).ne.0)mad=ib(m2)
      ihm2=ihx(m2)
      ih2=-ihm2
      ihm1p1=ihm1+1
      do 300 j=1,ihm1p1
      ind(m1)=j-1
      do 400 i=ih2,ihm2
      ind(m2)=i
      if(mark.eq.0) goto 450
      if(mark.ne.2) goto 410
      in=ind(m1)+ind(m2)
      goto 420
  410 if(ib(m1).ne.0)in=ind(m1)
      if(ib(m2).ne.0)in=ind(m2)
  420 if(mod(in,mad).eq.0) goto 450
      indr=iabs(ind(1)*ifat1+ind(2)*ifat2+ind(3) )
      isr(indr)=-4*icst1
      if(iprin.eq.3) write(lo,10) ind
   10 format(1x,'rifl. estinto  ',3i4)
      goto 400
  450 call specq(ind)
 400  continue
 300  continue
  500 return
      end
c-------------------------------------------------------
      subroutine specq(ind)
c
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /inp/  natom,fnat,satm,atoms
      common/prin/ ipt,ip0,ip10,ipq
      common/param/ifat1,ifat2,ifatx,lreci,idx,icst1,icst2,icst3,duma(3)
      common/dirtr/nreft,emin,ntra,ntrt,ntrmx,nref,nweak,sgg,nstr,nzro
      common/dirps/nrefp,emax,npsa,nrefpl,npsmx
      common/dir10/numk,ntrs,ntr10,sogpo,sogen,sogne,nupos,nuena,nuneg,
     1 indpo,inden,indne,nmxte,nmxtn
      common/dirqn/ecros,iecros,ncode,icody,nquar
     1 ,nsog,sqes,nquam,nquat,nqenm,nqent,ecr1,iecr1
      common/esti/ib(3),ih(3,2,24),ii(2,24)
      common/nq/nor1(6),nop1(6),iseg1(6),icodqn,sumc,sums,sume
c
      common/xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1 isr(100000),isig(3,20000),inq(7,750),inq2(7,500),dumm(31250)
      dimension ind(3)
c
      iecrx=max0(iecros,iecr1)
      indr=ind(1)*ifat1+ind(2)*ifat2+ind(3)
      indr=iabs(indr)
      if(indr.eq.0)return
      i=isr(indr)
      if(i.eq.0)  then    
                   isr(indr)=-5*icst1
                   if(iprin.eq.3) write(lo,30)(ind(i),i=1,3)
   30              format(20x,'rifl. assente speciale  ',3i4)
                    return
                  else
c-- e' tra i 50 piu deboli?
          if(i.lt.0) then     
                   if(i.le.-4*icst1)return
                   ie=i/icst1
                   if(ie.eq.-2) isr(indr)=i-icst2
                   if(iprin.eq.3) write(lo,10)(ind(i),i=1,3)
   10              format(20x,'rifl. spec. debolissimo  ',3i4 )
                   return
                 else
                   ie=i/icst3
                   if (ie.gt.iecrx) return
                   isr(indr)=-(isr(indr)+3*icst1+icst2)
                   if(iprin.eq.3) write(lo,20)(ind(i),i=1,3)
   20              format(20x,'rifl. spec. debole  ',3i4)
                   return
                 endif
                 endif
      end
c-----------------------------------------------------------------------
      subroutine enan(jg,jgc,gc,is,thet,ifass,nquae,iend)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /inp/  natom,fnat,satm,atoms
      common/prin/ ipt,ip0,ip10,ipq
      common/param/ifat1,ifat2,ifatx,lreci,idx,icst1,icst2,icst3,duma(3)
      common /cp10/ nor(3),nop(3),iseg(3),eeb(6),ee2(24,6)
      common/dirqn/ecros,iecros,ncode,icody,nquar
     1 ,nsog,sqes,nquam,nquat,nqenm,nqent,ecr1,iecr1
      common/enant/ nqenex,n23m,n23l,gm,nqen
      common/nq/nor1(6),nop1(6),iseg1(6),icodqn,sumc,sums,sume
c
      common/xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1 isr(100000),isig(3,20000),inq(7,750),inq2(7,500),dumm(31250)
c ----
      icont=0
      ico=1
      iend=0
      if(nqen.lt.nqenm) goto 1000
      iend=1
      return
 1000 ith=nint(thet*100.0)
      if(nqen.eq.nqent) goto 1500
      nqen=nqen+1
      inq2(1,nqen)=iseg1(2)*(nor1(2)*32+nop1(2))
      inq2(2,nqen)=iseg1(3)*(nor1(3)*32+nop1(3))
      inq2(3,nqen)=iseg(2)*(nor(2)*32+nop(2))
      inq2(4,nqen)=iseg(3)*(nor(3)*32+nop(3))
      inq2(5,nqen)=jg*32+is
      inq2(6,nqen)=jgc*1000.0+ith
      inq2(7,nqen)=(ifass*80+icont)*ico
      goto 1690
 1500 if(nqenex.ne.0) goto 1600
      call sortc(nqen,inq2)
      n23m=nqen
      n23l=nqen
      jgm=inq2(6,nqen)/1000
      gm=float(jgm)/100.
 1600 nqenex=nqenex+1
      if(gc.ge.gm) return
      inq2(1,n23m)=iseg1(2)*(nor1(2)*32+nop1(2))
      inq2(2,n23m)=iseg1(3)*(nor1(3)*32+nop1(3))
      inq2(3,n23m)=iseg(2)*(nor(2)*32+nop(2))
      inq2(4,n23m)=iseg(3)*(nor(3)*32+nop(3))
      inq2(5,n23m)=jg*32+is
      inq2(6,n23m)=jgc*1000+ith
      inq2(7,n23m)=(ifass*80+icont)*ico
      gm=100.
      i00=n23l-1
      if(i00.lt.1) i00=1
      do 1650 ij=i00,nqen
      jga=inq2(6,ij)/1000
      ga=float(jga)/100.
      if(ga.gt.gm) goto 1650
      gm=ga
      n23m=ij
 1650 continue
      n23l=min0(n23l,n23m)
 1690 if (iprin.lt.2) return
      theta=thet*360/twopi
      write(lo,3400) gc,theta
 3400 format(1x,'/g/=',f10.2,'  theta=',f10.2,'  --- enantiomorph sensit
     1ive quartet')
      return
      end
c-------------------------------------------------------
      subroutine tetra(k1,k ,tras,jhk)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /inp/  natom,fnat,satm,atoms
      common/prin/ ipt,ip0,ip10,ipq
      common/param/ifat1,ifat2,ifatx,lreci,idx,icst1,icst2,icst3,duma(3)
      common/dirtr/nreft,emin,ntra,ntrt,ntrmx,nref,nweak,sgg,nstr,nzro
      common/dirps/nrefp,emax,npsa,nrefpl,npsmx
      common/dir10/numk,ntrs,ntr10,sogpo,sogen,sogne,nupos,nuena,nuneg,
     1 indpo,inden,indne,nmxte,nmxtn
      common/dirqn/ecros,iecros,ncode,icody,nquar
     1 ,nsog,sqes,nquam,nquat,nqenm,nqent,ecr1,iecr1
      common/esti/ib(3),ih(3,2,24),ii(2,24)
c
      common/xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1 isr(100000),isig(3,20000),inq(7,750),inq2(7,500),dumm(31250)
      dimension ind(3),tras(3),ibi(3),ibc(3),jhk(2,24)
c--
      m1=0
      m2=0
      m3=0
      ihm1=0
      ihm2=0
      ihm3=1
      jj=0
      mark=0
      do 100 j=1,3
      ibc(j)=ib(j)
      ind(j)=0
      if(ih(j,k1,k).ne.3)m3=j
      jj=jj+j
 100  continue
      ih3=1
      ihm3=ihx(m3)
      idif=0
      if(ih(m3,k1,k).ne.0) goto 101
      irr=0
      ihm3=1
      idif=-1
  101 jj=jj-m3
      m1=1
      if(jj-4)110,120,130
  110 m2=2
      goto 150
  120 m2=3
      goto 150
  130 m1=2
      m2=3
  150 tra=tras(m1)+tras(m2)*jhk(k1,k)
      ttra=abs(tra-int(tra))
      if(ttra.le.0.001) goto 155
      if (abs(tras(m1)-tras(m2)).gt.0.001) goto 151
      ibc(m1)=ibc(m1)/2
      goto 160
  151 if(ib(m1).ne.ib(m2)) goto 152
      ibc(m1)=ib(m1)/2
      goto 160
  152 ibc(m1)=max0(ibc(m1),ibc(m2))
      goto 160
  155 if(ibc(m3).eq.0.or.idif.eq.-1) goto 156
      ibi(m1)=0
      ibi(m3)=1
      imm=ibc(m3)
      goto 300
  156 ibi(m1)=0
      ibi(m3)=0
      imm=1
      goto 300
  160 if(ibc(m3).ne.0.and.idif.ne.-1) goto 170
      ibi(m1)=1
      ibi(m3)=0
      imm=ibc(m1)
      goto 300
  170 imm=max0(ibc(m1),ibc(m3))
      im=min0(ibc(m1),ibc(m3))
      ibi(m1)=imm/ibc(m1)
      ibi(m3)=imm/ibc(m3)
  300 ihm1=ihx(m1)+1
      ihm2=ihx(m2)+1
      if(ihm2.gt.ihm1)ihm2=ihm1
      ihm1=ihm2
      do 1000 j=1,ihm1
      ind(m1)=j-1
      ind(m2)=(j-1)*jhk(k1,k)
      do 2000 i=ih3,ihm3
      ind(m3)=i+idif
      indi=ibi(m1)*ind(m1)+ibi(m3)*ind(m3)
      indm=mod(indi,imm)
      if(indm.eq.0) goto 2100
      if(iprin.eq.3) write(lo,2200) (ind(l),l=1,3)
      indr=iabs(ind(1)*ifat1+ind(2)*ifat2+ind(3))
      isr(indr)=-4*icst1
      goto 2000
 2100 call specq(ind)
 2000 continue
 1000 continue
 2200 format(1x,'rifl. estinto  ',3i4)
      return
      end
c-----------------------------------------------------
      subroutine retr9(jump)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /inp/  natom,fnat,satm,atoms
      common/prin/ ipt,ip0,ip10,ipq
      common/param/ifat1,ifat2,ifatx,lreci,idx,icst1,icst2,icst3,duma(3)
      common/dirtr/nreft,emin,ntra,ntrt,ntrmx,nref,nweak,sgg,nstr,nzro
      common/dirps/nrefp,emax,npsa,nrefpl,npsmx
      common/dir10/numk,ntrs,ntr10,sogpo,sogen,sogne,nupos,nuena,nuneg,
     1 indpo,inden,indne,nmxte,nmxtn
      common/dirqn/ecros,iecros,ncode,icody,nquar
     1 ,nsog,sqes,nquam,nquat,nqenm,nqent,ecr1,iecr1
      common /cp10/ nor(3),nop(3),iseg(3),eeb(6),ee(24,6)
c
      common /xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1               isr(100000),isig(3,20000),gq(20000),gv(20000)
c--
c--  jump = 1  reads psi-zero
c--  jump = 2  reads triplets
c--  jump = 3  reads psi-e
c--
      if(jump.ne.1) goto 2000
      return
c -----------   lettura delle sigma2 per p10
 2000 continue
c -----
c     call sub. lettura lista 8 ( 24) : tripletti positivi ( psi-e )
c -----
      if (jump.eq.2) then
                        iln=8
                      else
                        iln=24
                      endif
      iprea=0
      call sflxx(iprea,iln,ntra,ntra,nreft,nxxe,iccd,isig)
      return
      end
c-----------------------------------------------------------------------
      subroutine dirinv(ip10fast,ibig,ifpse,ier)
      character line*80,dire*80,diret*80
      character blank,digit*12,card(100)*80,ffile*80
      common /comdir/ icomq(200,2),maxcom,ipcom,ipdir,icomat
      common /chara/ blank,digit,card,ffile
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/c/flgw(30),flgd(30),avr(30),dcv(50),slope,flgk,bt,sc,del,ks
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /inp/  natom,fnat,satm,atoms
      common/prin/ ipt,ip0,ip10,ipq
      common /proc/ iftr,ifp10,ifnq,ifps,ifcoc,ifweig
      common/param/ifat1,ifat2,ifatx,lreci,idx,icst1,icst2,icst3,duma(3)
      common/dirtr/nreft,emin,ntra,ntrt,ntrmx,nref,nweak,sgg,nstr,nzro
      common/dirps/nrefp,emax,npsa,nrefpl,npsmx
      common/dir10/numk,ntrs,ntr10,sogpo,sogen,sogne,nupos,nuena,nuneg,
     1 indpo,inden,indne,nmxte,nmxtn
      common/dirqn/ecros,iecros,ncode,icody,nquar
     1 ,nsog,sqes,nquam,nquat,nqenm,nqent,ecr1,iecr1
      common /pseud/ kmat(48,3,3),emme,patom,qatom,npseud,lpseud(4,3)
     1         ,scale,jmme,prod,prod2,mjn(5,11),njn,coef,nw(8),no(8)
      dimension vet(40),ivet(40)
c
c-- set default values
      ip10fast=2
      ibig=8000
      ifpse=1
      sogpo=0.6
      sogen=0.2
      sogne=-0.2
      iprin=0
      iftr=1
c-- the default formula used is p-10
      ifp10=1
      ifcoc=0
      call yfl02
      call ysfl07(nrefl,idum1,idum2,idum3,idum4)
      ifps=1
      ifnq=1
      nreft=0
      emin=0.0
      ntr10=0
      numk=0
      ntrt=0
      ntrs=0
      nrefp=0
      emax=0.4
corig ecros=0.75
      ecros=1.00
      ecr1=3.0
corig iecros=75
      iecros=100
      iecr1=300
      nsog=40
      sqes=0.2
      ncode=7
      icody=0
      ier=0
      coef=99999.0
c -- set the size of  ish  matrix
      idx=1000
      ic=0
      icmax=icomq(icomat,2)
c
  100 continue
      ic=ic+1
      if (ic.gt.icmax) go to 9000
      ipdir=ipdir+1
      line=card(ipdir)
      diret=line
      call cutst(line,lenp,dire,lend)
      call lcase(dire)
c-- directives with numeric parameters
      iopt=0
      call getnum(line,vet,ivet,iv,iopt)
      if (iopt.eq.-1) go to 8000
C     if (dire(1:3).eq.'new') then
C         if (iv.gt.1) go to 8000
C         ip10fast=2
C         go to 100
C         endif
C     if (dire(1:3).eq.'old') then
C         if (iv.gt.1) go to 8000
C         ip10fast=0
C         go to 100
C         endif
      if (dire(1:3).eq.'big') then
          if (iv.gt.1) go to 8000
          if (ivet(1).gt.0) then
                              ibig=ivet(1)
                            else
                              ibig=20000
                            endif
          go to 100
          endif
      if (dire(1:4).eq.'nsig') then
          if (iv.ne.0) go to 8000
          iftr=0
          ifp10=0
          go to 100
          endif
      if (dire(1:4).eq.'coch') then
          if (iv.ne.0) go to 8000
          ifcoc=1
          ifp10=0
          go to 100
          endif
      if (dire(1:4).eq.'nqua') then
          if (iv.ne.0) go to 8000
          ifnq=0
          go to 100
          endif
      if (dire(1:4).eq.'npsi') then
          if (iv.ne.0) go to 8000
          ifps=0
          go to 100
          endif
      if (dire(1:4).eq.'emin') then
          if (iv.ne.1) go to 8000
          emin=vet(1)
          go to 100
          endif
      if (dire(1:4).eq.'nrtr') then
          if (iv.ne.1) go to 8000
          nreft=ivet(1)
          go to 100
          endif
      if (dire(1:4).eq.'corr') then
          if (iv.ne.1) go to 8000
          coef=vet(1)
          go to 100
          endif
      if (dire(1:4).eq.'gmin') then
          if (iv.ne.1) go to 8000
          sogpo=vet(1)
          if (sogpo.lt.sogen) sogpo=sogen+0.0001
          go to 100
          endif
      if (dire(1:4).eq.'pten') then
Corig     if (iv.gt.1) go to 8000
Corig     if (iv.eq.1) ntr10=ivet(1)
          if (iv.gt.0) go to 8000
          ifcoc=0
          ifp10=1
          go to 100
          endif
      if (dire(1:4).eq.'prin') then
          if (iv.ne.1) go to 8000
          iprin=ivet(1)
          go to 100
          endif
      if (dire(1:4).eq.'numk') then
          if (iv.ne.1) go to 8000
          numk=ivet(1)
          go to 100
          endif
      if (dire(1:4).eq.'emax') then
          if (iv.ne.1) go to 8000
          emax=vet(1)
          go to 100
          endif
      if (dire(1:4).eq.'nlar') then
          if (iv.ne.1) go to 8000
          nrefpl=ivet(1)
          go to 100
          endif
      if (dire(1:4).eq.'nrps') then
          if (iv.ne.1) go to 8000
          nrefp=ivet(1)
          go to 100
          endif
      if (dire(1:4).eq.'nops') then
          if (iv.ne.0) go to 8000
          ifpse=0
          go to 100
          endif
      write(lo,6000) diret
 6000 format(' wrong directive on following line:',/a)
      go to 100
 8000 continue
      ier=-1
      write(lo,'(22h error in directive : ,a80)') diret
      return
 9000 continue
      if (emin.lt.1.2) emin=1.2
      if (nreft.gt.700) nreft=700
      if (nrefpl.eq.0) nrefpl=nreft
      if (nrefp.gt.300) nrefp=300
      if (ifps.eq.0) ifnq=0
      ipt=iprin
      ip0=iprin
      ip10=iprin
      ipq=iprin
      if (sc.lt.0.0) then
                       write(lo,9100)
                       ier=-1
                     endif
 9100 format(/,' *** error ***  reflections are not normalized')
      return
      end
c-----------------------------------------------------------------------
      subroutine p10n(mode,result)
c
c--p10 calculation
c-- mode = 0  p10 applied to sigma-2 rel.
c-- mode = 1  p10 applied to psi-e   rel.
c
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /inp/  natom,fnat,satm,atoms
      common/prin/ ipt,ip0,ip10,ipq
      common /proc/ iftr,ifp10,ifnq,ifps,ifcoc,ifweig
      common/param/ifat1,ifat2,ifatx,lreci,idx,icst1,icst2,icst3,duma(3)
      common/dirtr/nreft,emin,ntra,ntrt,ntrmx,nref,nweak,sgg,nstr,nzro
      common/dirps/nrefp,emax,npsa,nrefpl,npsmx
      common/dir10/numk,ntrs,ntr10,sogpo,sogen,sogne,nupos,nuena,nuneg,
     1 indpo,inden,indne,nmxte,nmxtn
      common/dirqn/ecros,iecros,ncode,icody,nquar
     1 ,nsog,sqes,nquam,nquat,nqenm,nqent,ecr1,iecr1
      common /cp10/ nor(3),nop(3),iseg(3),eeb(6),ee(24,6)
c
      common /xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1               isr(100000),isig(3,20000),gq(20000),gv(20000)
c--
      dimension ill(3),iche(24),ikln(60)
      dimension vet(12),ivet(12)
      integer result(7,2)
      equivalence (ivet(1),vet(1))
c--
      if (numk.le.0) then
                        sogpo=0.0
                        sogen=-9999.9999
                        sogne=    0.0
                      endif
      if (icent.ne.0) then
                        sogen=-9999.9999
                        sogne=    0.0
                      endif
      call retr9(2)
      if(ntr10.gt.ntra.or.ntr10.eq.0) ntr10=ntra
      if(ntr10.gt.0) ntrs=min0(ntrs,ntr10)
c--clear the areas
      itabmx=min0(20000,nreft*nsym)
      do 1001 k=1,itabmx
      itab(k)=0
 1001 continue
c--  ifatx:superindice massimo
      do 1004 i=1,ifatx
      isr(i)=0
 1004 continue
c--create the list
      ipu=0
      do 1090 j=1,nreft
c-- carica in itab/itab1 le inform. relative ai riflessi forti
      kk=ish(1,j)
      ih=kk/16384-64
      kk=ish(1,j)-(ih+64)*16384
      ik=kk/128-64
      il=mod(kk,128)-64
      do 1080 i=1,nsym
      if (i.eq.1) then
                    indr=ih*ifat1+ik*ifat2+il
                    itab1c=(ik+64)*128+il+64
                  else
      ill(1)=ih*ksmat(i,1,1)+ik*ksmat(i,2,1)+il*ksmat(i,3,1)
      ill(2)=ih*ksmat(i,1,2)+ik*ksmat(i,2,2)+il*ksmat(i,3,2)
      ill(3)=ih*ksmat(i,1,3)+ik*ksmat(i,2,3)+il*ksmat(i,3,3)
      indr=ill(1)*ifat1+ill(2)*ifat2+ill(3)
      itab1c=(ill(2)+64)*128+ill(3)+64
                  endif
      indrr=indr
      indra=iabs(indr)
      if (i.ne.1) then
c -----   elimina i doppioni
                    imen1=i-1
                    do 1086 i1=1,imen1
                    if (indra.eq.iabs(ikln(i1))) indrr=0
 1086               continue
                  endif
      ipu=ipu+1
      ikln(i)=indrr
      itab(ipu)=indrr
      itab1(ipu)=itab1c
      isr(indra)=-j
1080  continue
1090  continue
c
c--create the isr list
c
      call ysfl07(nrefl,nstr,nzro,npseud,iy)
      do 1220 i=1,nrefl
      call snr07(vet)
      if (i.gt.nreft) then
                        ih=ivet(1)
                        ik=ivet(2)
                        il=ivet(3)
                        do 1210 i1=1,nsym
                        if (i1.eq.1) then
                                       indr=ih*ifat1+ik*ifat2+il
                                     else
              ill(1)=ih*ksmat(i1,1,1)+ik*ksmat(i1,2,1)+il*ksmat(i1,3,1)
              ill(2)=ih*ksmat(i1,1,2)+ik*ksmat(i1,2,2)+il*ksmat(i1,3,2)
              ill(3)=ih*ksmat(i1,1,3)+ik*ksmat(i1,2,3)+il*ksmat(i1,3,3)
              indr=ill(1)*ifat1+ill(2)*ifat2+ill(3)
                                     endif
                        indr=iabs(indr)
                        e=vet(4)
                        if (e.lt.0.01) e=0.01
                        isr(indr)=int(e*100+.05)
 1210                   continue
                      endif
 1220 continue
c
c--end of loop
c--calculate p10
      fna2=fnat*fnat
      fna22=fna2/2.0
      somgc=0.
      sgg=0.0
      do 2000 i=1,ntr10
c--  fornisce g e il no.d`ordine,gli operatori,
c     il segno e gli e dei riflessi per ogni tripl.
      call decom(i,dum,g,id1,id2)
      gv(i)=g
      sgg=sgg+g
      iseg(2)=-iseg(2)
      iseg(3)=-iseg(3)
      do 1000 k=1,nsym
      iche(k)=0
      do 1100 j=1,3
c--  nor:no.d`ordine
      nord=nor(j)
      nork=(nord-1)*nsym+k
      if (itab(nork).ne.0) go to 1000
 1100 continue
      iche(k)=k
 1000 continue
      terr=0.
      if (numk.le.0) go to 2110
c
c--  numk:no. di rifl.k-random adoperati.
      do 2100 j=1,numk
c--elimina il quintetto e i suoi equivalenti se il vett.k coincide con
c--un elemento della tripletta.
      do 2101 l =1,3
      if (j.eq.nor(l)) go to 2100
 2101 continue
      jn=(j-1)*nsym
      do 2001 i2=1,nsym
      do 2002 i3=1,6
c--  ee:contiene gli epsylon dei cross-vector.
      ee(i2,i3)=0.
 2002 continue
 2001 continue
      e2=float(ish(2,j)/512)/100.
c--  contiene gli epsylon dei vett. base(tripl.e k-random)
      eeb(4)=e2*e2-1
      ta=0.
      tb=0.
      do 2200 k=1,nsym
c--  controlli sulla ripetizione dei quintetti
c--  elimina l' op. di simm. se tutti i rifl.della
c--  tripl. sono speciali
      if (iche(k).gt.0) goto 2200
c--  elimina il op.di simm. se il k e`speciale
      jnk=jn+k
      if (itab(jnk).eq.0) goto 2200
      jk2=itab1(jnk)/128-64
      jl2=mod(itab1(jnk),128)-64
c--
      do 3000 i1=1,3
      if (i1.eq.1) then
                     mm1=1
                   else
                     mm1=-1
                   endif
      nord=nor(i1)
c--  no. d`ordine  del op.di simm.
      nope=nop(i1)
      mms=mm1*iseg(i1)
      nopd=(nord-1)*nsym+nope
      jk1=(itab1(nopd)/128-64)*mms
      jl1=(mod(itab1(nopd),128)-64)*mms
      ihh1=itab(nopd)*mms
      do 2300 l=1,3,2
      l1=l-2
      ihh2=itab(jnk)*l1
c--  superindice del cross-vector
      ih3=ihh1+ihh2
      if(ih3.ne.0) then
      if(ih3.gt.0) then
                     l3=1
                   else
                     l3=-1
                     ih3=-ih3
                   endif
c--  tre controlli sulla esistenza del vett.-cross
c--  primo controllo sul superindice.
      if (ih3.gt.ifatx) go to 2300
      ie=isr(ih3)
      if (ie.eq.0) go to 2300
      jk=iabs(jk1+jk2*l1)
c--  secondo controllo sull`indice k
      if (jk.gt.ihx(2))go to 2300
      jl=iabs(jl1+jl2*l1)
c--  terzo controllo sull`indice l
      if (jl.gt.ihx(3))go to 2300
      if (ie.lt.0) then
                     il=-ie
c--  due controlli che il vett.-cross sia diverso dai vett. base.
c--  1` rispetto al vett. k e anche se e(cross)>e(k)
c--  la modifica nel seguente controllo cambia leggermente i risultati
                     if (il.le.j) go to 2200
Corig                if (il.eq.j) go to 2200
                     do 2035 n=1,3
c--  2` rispetto ai vett. della trip.
                     if (nor(n).eq.il) go to 2200
 2035                continue
                     ie=ish(2,il)/512
                   endif
      e=float(ie)/100.0
      inde=2*i1-1+(1-l1)/2
      ee(k,inde)=e*e-1.0
Corig if(ee(k,inde).gt.eeb(4)) go to 2200
                   endif
 2300 continue
 3000 continue
c--  in-line coded functions
      aterm=eeb( 4)*( ee(k,1) * ( ee(k,4)+ee(k,6) ) +
     1                ee(k,3) * ( ee(k,2)+ee(k,6) ) +
     2                ee(k,5) * ( ee(k,2)+ee(k,4) ) )
      bterm=eeb( 1)*(eeb( 4)*(ee(k,1)+ee(k,2))+ee(k,3)*ee(k, 6)+
     1      ee(k,4)*ee(k,5))+
     2      eeb( 2)*(eeb( 4)*(ee(k,3)+ee(k,4))+ee(k,1)*ee(k, 6)+
     3      ee(k,2)*ee(k,5))+
     4      eeb( 3)*(eeb( 4)*(ee(k,5)+ee(k, 6))+ee(k,1)*ee(k,4)+
     5      ee(k,2)*ee(k,3))
c--
      ta=ta+aterm*fna2
      tb=tb+bterm*fna22
 2200 continue
      tb=tb+eeb( 1)*eeb( 2)*eeb( 3)*fna22
      if (tb.lt.0.0) tb=0.0
      ter=ta/(1.0+tb)
      terr=terr+ter
 2100 continue
c
 2110 continue
      terr=terr+1
      gcor=g*terr
c ============
      gq(i)=gcor
      somgc=somgc+abs(gcor)
 2000 continue
      sgg=sgg/somgc
      if (numk.le.0) sgg=1
c --   riscala g - corretto
      do 4020 i=1,ntr10
      gq(i)=gq(i)*sgg 
      if (gq(i).gt.20.47) gq(i)=20.47
      if (gq(i).lt.-20.47) gq(i)=-20.47
      ifa=(mod(isig(1,i),32)-1)*15
      ifa=ifa+mod(isig(3,i),32)-1
      ifffa=gq(i)*100.
      iff1=mod(isig(2,i),32)
      iff2=isig(2,i)/131072
      if (ifffa.ge.0) then
                        ii=1
                        iffa=ifffa
                      else
                        ii=-1
                        iffa=-ifffa
                      endif
      isig(2,i)=(iff2*4096+iffa+2048)*32+iff1
 4020 continue
      call sortgn(ntr10)
      indpo=1
      inden=0
      indne=0
      nupos=0
      nuena=0
      nuneg=0
      do 5000 i=1,ntr10
      ggqq=abs(gq(i))
      if (inden.eq.0.and.ggqq.le.sogen) inden=i
      if (indne.eq.0.and.gq(i).le.sogne) indne=i
      if (gq(i).ge.sogpo) nupos=nupos+1
      if (ggqq.le.sogen) nuena=nuena+1
      if (gq(i).le.sogne) nuneg=nuneg+1
 5000 continue
      nuposo=nupos
      nuenao=nuena
      if (nuneg.le.500) then
                          nunego=nuneg
                        else
                          nunego=nuneg
                          indne=indne+nuneg-500
                          nuneg=500
                        endif
 6000 if(nuena.le.nmxte) goto 6020
Corig ifin=inden+nuena
c-new Anto 25/6/92
      ifin=inden+nuena-1
c-endnew Anto 25/6/92
      iniz=inden
      inden=0
      nuena=0
      sogen=sogen-0.05
      do 6010 i=iniz,ifin
      ggqq=abs(gq(i))
      if (ggqq.le.sogen) then
                           if(inden.eq.0) inden=i
                           nuena=nuena+1
                         endif
 6010 continue
      goto 6000
 6020 if(nuneg.le.nmxtn) goto 6040
      iniz=indne
      indne=0
      nuneg=0
      sogne=sogne-0.05
      do 6030 i=iniz,ntr10
      if (gq(i).le.sogne) then
                            if (indne.eq.0) indne=i
                            nuneg=nuneg+1
                          endif
 6030 continue
      goto 6020
 6040 continue
      result(1,1)=nuposo
      result(1,2)=nupos
      result(2,1)=nunego
      result(2,2)=nuneg
      result(3,1)=nuenao
      result(3,2)=nuena
      igm=gq(nupos)*1000.
      call test10n
      call wrtr9(3,igm,npse)
      return
      end
c---------------------------------------------------------
      subroutine test10n
c
c--test on p10 results
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /inp/  natom,fnat,satm,atoms
      common/prin/ ipt,ip0,ip10,ipq
      common/param/ifat1,ifat2,ifatx,lreci,idx,icst1,icst2,icst3,duma(3)
      common/dirtr/nreft,emin,ntra,ntrt,ntrmx,nref,nweak,sgg,nstr,nzro
      common/dirps/nrefp,emax,npsa,nrefpl,npsmx
      common/dir10/numk,ntrs,ntr10,sogpo,sogen,sogne,limit(6),dume(2)
      common /cp10/ nor(3),nop(3),iseg(3),eeb(6),ee(24,6)
      common /nctst/ ns,br(15),nb(11,15,3),fnb(11,15,3),bcm(11,15,3),
     *                        acm(11,15,3)
      common /pseud/ kmat(48,3,3),emme,patom,qatom,npseud,lpseud(4,3)
     1         ,scale,jmme,prod,prod2,mjn(5,11),njn,coef,nw(8),no(8)
c
      common /xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1               isr(100000),isig(3,20000),gq(20000),gv(20000)
c--
      dimension nor1(3),sdc(3),sdca(3)
c--
      njn=1
c--  prepara il buffer per il test 
      if (icent.eq.0) then
                        if (knw.eq.1) call nclrt
                        call  nclrt1
                      else
                        if (knw.eq.1) call  clrt
                        call  clrt1
                      endif
c-- nusba = serial number of the first wrong and positive triplet
      if (ntrs.gt.0) write(lo,5050)
 5050 format(//,10x,'code',14x,
     1      'g(2r)',5x,'g(1r)',3x,'phi(calc)',
     2       4x,'phi(ver)',7x,'dphi',/)
c--loop per eseguire delle stampe utili
      nusba=0
      do 5001 ii=1,3
      if (ii.eq.2.and.icent.eq.1) go to 5001
      mark=0
      if (ii.eq.3) mark=1
      n8w=1
      iniz=limit(ii+3)
      ifin=limit(ii)+iniz-1
      sdc(ii)=0.0
      sdca(ii)=0.0
      do 5000 i=iniz,ifin
      mark1=1
      if(ntrs.lt.n8w)mark1=0
      ia=int(gq(i)*100.)
      call decom(i,g,ggv,ishi,ib)
      b=float(ib)*dtor
      a=cos(b)
      an=a*gq(i)
      if (icent.eq.1) then
c-- centrosymmetric test
                        gg=gq(i)
                        if (knw.eq.1) call sctst(gg,an,1)
                        call sctst1(gg,an)
                        coat=1.0
                        if (gg.lt.0.0) coat=-1.0
                      else
c-- noncentrosymmetric test
                        bb=sin(b)
                        g2=gq(i)
                        call besse(g2,coat)
                        bang=ib
                        if (ib.gt.180) bang=360.0-bang
                        if (knw.eq.1) call nctet(g2,a,bang,1)
                        call nctet1(g2,coat,a)
                        an=coat*a
                      endif
c     if (ii.ne.1) go to 4001
c     if(nusba.ne.0.or.an.ge.0)go to 4001
      nusba=i
      if (ii.eq.1) then
                     if (.not.(nusba.eq.0.or.an.ge.0)) nusba=i
                   endif
      if (knw.ne.0) then
          aa=b
          cc=acos(coat)
          dc=cc-aa
          adc=abs(dc)
          if ((adc-pi).gt.0.0) then
                                 dc=twopi-adc
                                 dc=-dc
                               endif
          sdc(ii) =sdc(ii) +    dc
          sdca(ii)=sdca(ii)+abs(dc)
          do 5080 k=1,3
          nor1(k)=nor(k)*iseg(k)
 5080     continue
          if((mark+mark1).ne.0.and.iprin.ge.1) then
                          cc=cc*180./pi
                          aa=aa*180./pi
                          dc=dc*180./pi
                       write(lo,5100)(nor1(k),k=1,3),gq(i),ggv,cc,aa,dc
                        endif
                    endif
      n8w=n8w+1
 5000 continue
      if (limit(ii).ne.0.and.knw.ne.0) then
                                         xxx=180.0/(pi*float(limit(ii)))
                                         sdc(ii) = sdc(ii) * xxx
                                         sdca(ii)=sdca(ii) * xxx
                                       endif
 5001 continue
      if (knw.eq.1) write(lo,5500) nusba
 5500 format(//,1x,'serial number of the first wrong triplet =',i5)
 5100 format(4x,3i5,4x,2f10.2,3f12.2)
 5200 format(//,49x,6h<dphi>,5x,8h</dphi/>,
     1 /,2x,i6,' positive relationships ',12x,2f10.3,
     2 /,2x,i6,' enantiomorph sensitive rel. ', 7x,2f10.3,
     3 /,2x,i6,' negative relationships ',12x,2f10.3,//)
      write(lo,2998)
 2998 format(/,38x,'            Triplets statistic')
      if (icent.le.0) then
                        if (knw.eq.1) write(lo,5200)
     *                  (limit(ii),sdc(ii),sdca(ii),ii=1,3)
c--  stampa il test (non centro)
                        if (knw.eq.1) call nstst
                        call nstst1
                      else
c--  stampa il test (centro)
                        if (knw.eq.1) call stst
                        call stst1
                      endif
      return
      end
c--------------------------------------------------------------
      subroutine sortgn(numb)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isp(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emv
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /inp/  natom,fnat,satm,atoms
      common/prin/ ipt,ip0,ip10,ipq
      common/param/ifat1,ifat2,ifatx,lreci,idx,icst1,icst2,icst3,duma(3)
      common/dirtr/nreft,emin,ntra,ntrt,ntrmx,nref,nweak,sgg,nstr,nzro
      common/dirps/nrefp,emax,npsa,nrefpl,npsmx
      common/dir10/numk,ntrs,ntr10,sogpo,sogen,sogne,nupos,nuena,nuneg,
     1 indpo,inden,indne,nmxte,nmxtn
      common/dirqn/ecros,iecros,ncode,icody,nquar
     1 ,nsog,sqes,nquam,nquat,nqenm,nqent,ecr1,iecr1
c
      common /xdata/ ish(3,1000),itype(1000),itab(20000),itab1(20000),
     1               isr(100000),isig(3,20000),gq(20000),gv(20000)
c--sort the sigma 2 and the g-correct list
c
c--
      if (numb.eq.1) return
      m=2
 2010 continue
      in=numb/m
      if (in.le.0) in=1
      ifin=numb-in
 2040 continue
      mark=0
      do 2060 i=1,ifin
      k=i+in
      if (gq(i).lt.gq(k)) then
                            do 2055 n=1,3
                            jc=isig(n,i)
                            isig(n,i)=isig(n,k)
                            isig(n,k)=jc
 2055                       continue
                            gg=gq(i)
                            gq(i)=gq(k)
                            gq(k)=gg
                            vg=gv(i)
                            gv(i)=gv(k)
                            gv(k)=vg
                            mark=1
                          endif
 2060 continue
      if (mark.gt.0) go to 2040
      if (in.le.1) return
      m=m*2
      go to 2010
      end
c-----------------------------------------------------------------------
      subroutine clrt1
c--prepare the test buffer (centro)
      common/tst1/nt,ar(19),nn(19),pp(19)
      ar( 1)=.0
      ar( 2)=.2
      ar( 3)=.4
      ar( 4)=.6
      ar( 5)=.8
      ar( 6)=1.
      ar( 7)=1.2
      ar( 8)=1.4
      ar( 9)=1.6
      ar(10)=2.
      ar(11)=2.5
      ar(12)=3.0
      ar(13)=3.5
      ar(14)=4.0
      ar(15)=5.0
      ar(16)=6.0
      ar(17)=8.0
      ar(18)=10.0
      ar(19)=15.0
      nt=19
      do 200 i=1,nt
      nn(i)=0
      pp(i)=0.0
 200  continue
      return
      end
c----------------------------------------------------------
      subroutine sctst1(aa,cc)
c--test for the correct coincidence (centro)
      common/tst1/nt,ar(19),nn(19),pp(19)
      bb=abs(aa)
      do 1100 i=1,nt
      if(ar(i).le.bb) then
                        nn(i)=nn(i)+1
                        if(cc)1100,1030,1030
 1030                   continue
                        pp(i)=pp(i)+1.0
                       endif
 1100 continue
      return
      end
c--------------------------------------------------------
      subroutine nclrt1
c--prepare the test buffer (non-centro)
c
      common /nctst1/ ns,br(19),nb(19),fnb(19)
c
      br( 1)=.0
      br( 2)=.2
      br( 3)=.4
      br( 4)=.6
      br( 5)=.8
      br( 6)=1.
      br( 7)=1.2
      br( 8)=1.4
      br( 9)=1.6
      br(10)=2.
      br(11)=2.5
      br(12)=3.0
      br(13)=3.5
      br(14)=4.0
      br(15)=5.0
      br(16)=6.0
      br(17)=8.0
      br(18)=10.0
      br(19)=15.0
      ns=19
      do 1150 i=1,ns
      nb (i)=0
      fnb(i)=0.0
1150  continue
      return
      end
c------------------------------------------------------
      subroutine nctet1(aa,co,cc)
c--test for the correct coincidence (non-centro)
c
      common /nctst1/ ns,br(19),nb(19),fnb(19)
c
      bb=abs(aa)
      do 1060 i=1,ns
      if(br(i).le.bb)  then
                         nb(i)=nb(i)+1
                         a=cc*co
                         if(a) 1060,1050,1050
1050                     continue
                         fnb(i)=fnb(i)+1.0
                       endif
1060  continue
      return
      end
c-----------------------------------------------------
      subroutine stst1
c--print the test (centro)
      common/tst1/nt,ar(19),nn(19),pp(19)
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
c
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      dimension pa(19)
      data pa /19*0./
c
      write(lo,520)
  520 format(38x,44hdistribution of g - number of g's .gt. limit)
      if (knw.eq.1)  write(lo,530)
  530 format(40x,41hand percentage(%) of correct relationship)
      write(lo,540)(ar(i),i=1,19),(nn(i),i=1,19)
  540 format(/,3x,3hg  ,19f6.1/1h ,1x,4hno. ,19i6)
      if (knw.eq.0) return
      do 1020 i=1,nt
      if(nn(i))1020,1020,1015
 1015 continue
      fn=float(nn(i))
      pa(i)=pp(i)*100.0/fn
 1020 continue
      write(lo,550)(pa(i),i=1,19)
  550 format(1h ,2x,3h%  ,19f6.1)
      return
      end
c--------------------------------------------------
      subroutine nstst1
c--print the test (non-centro)
c
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common /nctst1/ ns,br(19),nb(19),fnb(19)
c
      write(lo,520)
  520 format(38x,44hdistribution of g - number of g's .gt. limit)
c
      if (knw.eq.1)  write(lo,530)
  530 format(40x,41hand percentage(%) of correct relationship)
      write(lo,540)(br(i),i=1,ns),(nb(i),i=1,ns)
  540 format(/,3x,3hg  ,19f6.1/1h ,1x,4hno. ,19i6)
      if (knw.eq.0) return
      do 1020 i=1,ns
      if(nb(i))1020,1020,1015
 1015 continue
      fn=float(nb(i))
      fnb(i)=fnb(i)*100.0/fn
 1020 continue
      write(lo,550)(fnb(i),i=1,ns)
  550 format(1h ,2x,3h%  ,19f6.1)
      return
      end
CRYSTALS CODE FOR LIST92
c-- sir code for list                            Release 93.02
code for bldsc
      block data bldsc
c--define block data for disc routines
c
      common/xbufd/link(1600)
      common/xdisc/iacc,ilss,iadd1,nfwd,nwd,nv,nwb,nwr,i,j,k,l,m,n,nnn
      common/xfile/ifile,ilist,iend,infle,nwfle,icfle,lid(4)
      common/xfili/lfirst,nwblo,lindex(240)
      common/xchar/id,ie,ib,ic,ia,ih
     1 ,numb(10),iplus, inus,ipoint
      common/xcard/nch,image(80),nc,nd,ni,nt,na(3),ncd,idoc(20)
      common/xmate/itdf(9), m1d,m2d,n1d,n2d
      common/lst06/l6,l6a,l6d,ld6p,m6,m6dk,n6dk,md6d,n6d,n6,n6p,
     2 l6rs,l6rk,l6in,l6p,k1,k2,k3
      common/xlimi/nfl,lfl,nl,idummy(3),nfls
      common /data/ store(5000)
c
      data nwblo/50/,ifile/10000/,ilist/11000/,iend/11111/
      data infle/240/,nwfle/6/,icfle/-1/,lfirst/1600/
      data iacc/-1/,ilss/15/,nfl/1/,lfl/5000/,nl/5000/
      data ncd/-1/,nfls/1/
      data id/1h(/,ie/1h)/,ib/1h /,ic/1h,/
      data ia/1h*/,ih/1h#/
      data numb( 1)/1h0/,numb( 2)/1h1/,numb( 3)/1h2/,numb( 4)/1h3/
      data numb( 5)/1h4/,numb( 6)/1h5/,numb( 7)/1h6/,numb( 8)/1h7/
      data numb( 9)/1h8/,numb(10)/1h9/
      data iplus/1h+/, inus/1h-/,ipoint/1h./
      data nch/2/
      data nc/-1/,nd/-1/,ni/-1/
      end
c
code for star9
      subroutine star9
c--initialize the disc routines
c
      li=1
      lf=800
      call xgiv(li,lf,i)
      return
      end
c
code for xup
      subroutine xup(nfw,iadd,nw)
c--transfer from store to disc
c
c  nfw   address of first word to be used on disc
c  iadd  address of first word in core
c  nw    number of words to transfer
c
c--disc routines version iv, using 'link ' array as store
c  the buffers.
c
c--record 0 contains words  0   - (nwr-1)
c  record 1 contains words  nwr - (2*nwr-1)
c  and subsequent records are the same
c
c--
      common/xbufd/link(1600)
      common/xdisc/iacc,ilss,iadd1,nfwd,nwd,nv,nwb,nwr,i,j,k,l,m,n,nnn
c--
      dimension iadd(nw)
c
c--transfer the arguments to the common block
      nfwd=nfw
      nwd=nw
      nv=1
c--check if there are any more words to transfer
1200  continue
      if(nwd)1250,1250,1300
1250  continue
      return
c--calculate the record number etc. for this transfer
1300  continue
      call  xfndb
c--write some numbers
      link(i+3)=-1
      do 2050 m=j,k
      link(m)=iadd(nv)
      nv=nv+1
2050  continue
      go to 1200
      end
c
code for xdwn
      subroutine xdwn(nfw,iadd,nw)
c--transfer from disc to store
c
c  nfw   address of first word to be used on the disc
c  iadd  address of first word in core
c  nw    number of words to transfer
c
c--disc routines version iv, using 'link ' array as store
c  the buffers.
c
c--record 0 contains words  0   - (nwr-1)
c  record 1 contains words  nwr - (2*nwr-1)
c  and subsequent records are the same
c
c--
      common/xbufd/link(1600)
      common/xdisc/iacc,ilss,iadd1,nfwd,nwd,nv,nwb,nwr,i,j,k,l,m,n,nnn
c
      dimension iadd(nw)
c
c--transfer the arguments to the common block
      nfwd=nfw
      nwd=nw
      nv=1
c--check if there are any more words to transfer
1200  continue
      if(nwd) 1250,1250,1300
1250  continue
      return
c--calculate the record number etc. for this transfer
1300  continue
      call xfndb
c--read some numbers
      do 1950 m=j,k
      iadd(nv)=link(m)
      nv=nv+1
1950  continue
      go to 1200
      end
c
code for xgiv
      subroutine xgiv(iadd0,nnl,llu)
c--set up the user defined buffers
c
c  iadd0  first free address in 'link' that can be used
c  nnl    length of user buffer area
c  llu    first word that may be used by the user (set on return)
c
c--
      common/xbufd/link(1600)
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      common/xdisc/iacc,ilss,iadd1,nfwd,nwd,nv,nwb,nwr,i,j,k,l,m,n,nnn
c
c--set the number of words per block equal to the number per record
      nwr=knwr
      nwb=nwr
      l=(nnl-4)/(nwb+4)
      iacc=-1
      llu=iadd0
      if(l) 2500,2500,2300
2300  continue
      l=min0(l,ilss)
      iadd1=iadd0
      link(iadd1)=-10000
      i=iadd1+4
      j=iadd1
      go to 2400
c--link the next buffer
2350  continue
      link(i)=j
      link(j+1)=i
      link(i+2)=-10000
      link(i+3)=0
      j=i
      i=i+nwb+4
      l=l-1
c--check if any more buffers can be link in
2400  continue
      if(l) 2450,2450,2350
c--set the last buffer flag
2450  continue
      link(j+1)=-10000
      iacc=1
      llu=i
2500  continue
      return
      end
c
code for xfndb
      subroutine xfndb
c--find the required disc buffer
c
c--arguments are in the common block :
c
c  iadd1  first buffer word in 'link'
c  nfwd   current disc address
c  nwd    number of words left to transfer
c  nv     current position in the input or output array
c
c--the above variables are set on entry, and reset as necessary on exit.
c
c--the following variables are also set on exit :
c
c  i  address of the current buffer
c  j  address of the first word in the buffer for data
c  k  address of the last word in the buffer for data
c
c--the following variables must not changed :
c
c  l
c  m
c  n
c
c--
      common/unit/lxn,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/xbufd/link(1600)
      common/xdisc/iacc,ilss,iadd1,nfwd,nwd,nv,nwb,nwr,i,j,k,l,m,n,nnn
c
c--check if the buffers have been allocated
      if(iacc)1050,1150,1150
c--attempt to read or write before declaring buffers
1050  continue
      write(lo,1100)
1100  format(' *** error *** no buffers allocated to the disc routines')
      stop 46
c--calculate the record number etc. of transfers to be made
1150  continue
      nr =nfwd/ nwb
      n =nfwd-nr* nwb
c--search through the buffer list for free buffers and/or the buffer
c  containing this record
      i=link(iadd1+1)
      j=iadd1
c--check the first buffer to see if this is the correct one
      if(nr-link(i+2))1400,1750,1400
c--check if this is the correct buffer
1350  continue
      if(nr-link(i+2))1400,1700,1400
c--check for a free buffer wich also indicates the end of the stack
1400  continue
      if(link(i+2))1650,1450,1450
c--check if this is the last buffer
1450  continue
      if(link(i+1)) 1550,1550,1500
c--pick up the next buffer
1500  continue
      j=i
      i=link(i+1)
      go to 1350
c--rewrite the contents of the last buffer to the disc if nec.
1550  continue
      if(link(i+3)) 1600,1650,1650
1600  continue
      m=link(i+2)
      call xstor(m,link(i+4),nwb)
      link(i+3)=0
c--fetch the record of interest
1650  continue
      link(i+2)=nr
      call xftch(nr,link(i+4),nwb)
c--switch this buffer to the top of the buffer stack
c  all other buffers are forced one down the stack, so that the
c  least used one ends up at the end
1700  continue
      link(j+1)=link(i+1)
      link(i+1)=link(iadd1+1)
      link(iadd1+1)=i
1750  continue
c--calculate the number of words that can be transfered from this buffer
      j=i+n+4
      k=j+nwd-1
      l=i+3+nwb
      nwd=k-l
c--check if all the words are in this buffer
      if(nwd)1850,1850,1800
1800  continue
      k=l
      nfwd=nfwd+(k-j+1)
1850  continue
      return
      end
c
code for xdump
      subroutine xdump
c--rewrite all the buffers marked for writing to the disc
c
      common/xbufd/link(1600)
      common/xdisc/iacc,ilss,iadd1,nfwd,nwd,nv,nwb,nwr,i,j,k,l,m,n,nnn
c
c--check if any buffers are allocated
      if(iacc)2800,2550,2550
c--link into the first buffer
2550  continue
      i=link(iadd1+1)
      j=-1
c--check if the buffer required writing
2600  continue
      if(link(i+3))2650,2700,2700
c--write the buffer out
2650  continue
      j=link(i+2)
      call xstor(j,link(i+4),nwb)
      link(i+3)=0
c--check if this is the last buffer
2700  continue
      if(link(i+1)) 2800,2800,2750
2750  continue
      i=link(i+1)
      go to 2600
2800  continue
      return
      end
c
code for xftch
      subroutine xftch(i,j,k)
c--fetch data from the disc  -  this link controls the disc
c
c  i  disc address of the information in user records
c  j  array into which the data goes
c  k  number of words to read
c
c**this link is machine specific as it relates the
c  length of records seen by the user to the length
c  of hardware blocks on the disc
c
c--
      common/xdisu/ncdfu ,ndfle,irecx
      common/unit/lxn,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      dimension j(512)
c
c**machine specific - relates the block length to the user record length
      n=i+1
      read(unit=ncdfu,rec=n,iostat=ier,err=1010)(j(m),m=1,k)
      return
1010  continue
      l=kwlnt(k)
      do 1015 m=1,l
      j(m)=0
1015  continue
      write(unit=ncdfu,rec=n,iostat=ier,err=1030)(j(m),m=1,l)
      return
1030  continue
      write(lo,1020) ier,ncdfu
1020  format(' xftch: ',i5,' error - unit =',i5)
      stop 100
      end
c
code for xstor
      subroutine xstor(i,j,k)
c--store data on the disc - this link controls the disc
c
c  i  disc address of the information in user records
c  j  address in store into which the data goes
c  k  number of words to read
c
c**this link is machine specific as it relates the
c  length of records seen by the user to the length
c  of hardware blocks on the disc
c
c--the transfer is rounded up to fill one or more disc blocks
c
c--
      common/xdisu/ncdfu ,ndfle,irecx
      common/unit/lxn,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      dimension j(512)
c
c**machine specific - relates block length to the user record length
      m=kwlnt(k)
      n=i+1
      write(unit=ncdfu,rec=n,iostat=ier,err=1010) (j(l),l=1,m)
      return
1010  continue
      write(lo,1020) ier
1020  format(' xstor: ',i5,' error')
      stop 200
      end
c
code for kwlnt
      function kwlnt(in)
c--assigns the number of words to complete a record
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      i=knwr
      kwlnt=(in+i-1)/i*i
      return
      end
c
code for setfi
      subroutine setfi
c--initialize the binary disc file
c  by creating the first file index
c
      common/unit/lxn,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/xfile/ifile,ilist,iend,infle,nwfle,icfle,lid(4)
      common/xfili/lfirst,nwblo,lindex(240)
c
c--find the initial constants
      do 990 i=1,nwblo
      lindex(i)=-10000
990   continue
      i=infle
      j=nwblo
      k=j+i
      lindex(1)=lfirst+k
      lindex(2)=i
      lindex(3)=lfirst+j
      lindex(4)=j
      m=11
      lindex(5)=m
      lindex(6)=nwfle
      lindex(8)=ifile
      do 1000 l=1,20
      lindex(m)=itle(l)
      m=m+1
1000  continue
      call xup (lfirst,lindex,j)
      m=infle/nwfle-1
      lindex(1)=ifile
      lindex(2)=m
      lindex(3)=lfirst+j
      lindex(4)=lfirst+k-1
      lindex(5)=nwfle
      lindex(6)=i
      l=nwfle+1
      do 1010 i=1,m
      do 1010 k=1,nwfle
      lindex(l)=0.0
      l=l+1
1010  continue
      i=lindex(6)
      call xup (lindex(3),lindex,i)
      call xdump
      call sldf
      return
      end
c
code for sldf
      subroutine sldf
c--load the  file index
c
      common/unit/lxn,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
c
      if(jsldf(in)) 1010,1005,1005
1005  continue
      return
1010  continue
c--error because the file index has been corrupted
      write(lo,1020)
1020  format(/,34h the file index has been corrupted)
      stop 1111
      end
c
code for jsldf
      function jsldf(in)
c--load the details of the file index when beginning to use a file
c
      common/unit/lxn,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/xfile/ifile,ilist,iend,infle,nwfle,icfle,lid(4)
      common/xfili/lfirst,nwblo,lindex(240)
c--
      jsldf=0
      call xdwn (lfirst,lindex,10)
      i=lindex(4)
      call xdwn (lfirst,lindex,i)
      j=lindex(5)
      do 1000 k=1,20
      itle(k)=lindex(j)
      j=j+1
1000  continue
      i=lindex(2)
      call xdwn (lindex(3),lindex,i)
c--check that the file index is correctly set up or  has been
c  corrupted
      if(lindex(1)-ifile) 1010,1005,1010
1005  continue
      return
1010  continue
      jsldf=-1
      go to 1005
      end
c
code for xlc
      subroutine xlc
c--initial subroutine to load all the file index information
c
      common/xfile/ifile,ilist,iend,infle,nwfle,icfle,lid(4)
c
      if(icfle)1000,1010,1010
1000  continue
      call sldf
      icfle=1
1010  continue
      return
      end
c
code for xnxtf
      subroutine xnxtf(ll)
c--assign the next free location
c
      common/xfili/lfirst,nwblo,lindex(240)
      dimension  loc(1)
      call xdwn (lfirst, loc,1)
      ll= loc(1)
      return
      end
c
code for snxtf
      subroutine snxtf(ll)
c--write the value of ~ll~  as the new next free location
c
      common/xfili/lfirst,nwblo,lindex(240)
      dimension  loc(1)
       loc(1)=ll
      call xup (lfirst,loc,1)
      call xdump
      return
      end
c
code for swlin
      subroutine swlin (iln,lsn,lfw,llw,lpb,ll)
c--write the entry for a newly created list into the file index
c
c  iln  the list type number
c  lsn  the list serial number
c  lfw  first word accupied by the list
c  llw  last word occupied by the list
c  lpb  the lenght of the preamble block for a block type list
c  ll   list lenght
c
      common/unit/lxn,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/xfili/lfirst,nwblo,lindex(240)
c
      call xlc
      if (iln) 1000,1000,1010
1000  continue
      write(lo,1001) iln
1001  format(///,i7,25h is not a valid list type)
      stop  1111
1010  continue
      mln=lindex(2)
      il =lindex(5)
      if(iln-mln) 1030,1030,1000
1030  continue
      i=iln*il+1
      lindex(i  )=iln
      lindex(i+1)=lsn
      lindex(i+2)=lfw
      lindex(i+3)=llw
      lindex(i+4)=lpb
      lindex(i+5)=ll
      j=lindex(6)
      call xup (lindex(3),lindex,j)
      return
      end
c
code for srlin
      subroutine srlin (iln,lsn,lfw,llw,lpb,ll)
c--read the entry  for a list in the current index table
c
c  iln  the list type number
c  lsn  the list serial number
c  lfw  first word occupied by the list
c       'lfw' is set negative if no such list exists
c  llw  last word occupied by the list
c  lpb  the lenght of the preamble block for a block type list
c  ll   list lenght
c
      common/xfili/lfirst,nwblo,lindex(240)
c
      if(iln)1020,1020,1000
1000  continue
      call xlc
      mln=lindex(2)
      il =lindex(5)
      if(iln-mln) 1010,1010,1020
1010  continue
      i=iln*il+1
      if(lindex(i)) 1020,1020,1040
1020  continue
      lfw=-1
1030  continue
      return
1040  continue
      lsn=lindex(i+1)
      lfw=lindex(i+2)
      llw=lindex(i+3)
      lpb=lindex(i+4)
      ll=lindex(i+5)
      go to 1030
      end
c
code for xcln
      subroutine xcln(in)
c--set on the store the first values of the list @in@
c
      common/xlimi/nfl,lfl,nl,nflmx,lflmx,nlmx,nfls
      common/xfile/ifile,ilist,iend,infle,nwfle,icfle,lid(4)
c
      common /data/ store(5000)
c
      store(nfl  )=float(iend)
      store(nfl+1)=float(in)
      store(nfl+2)=1.0
      store(nfl+3)=0.0
      store(nfl+4)=-1.0
      return
      end
c
code for sfrml
      subroutine sfrml (iln, n)
c--form a list
c
c  iln list number
c  n   the lenght of the list
c
c  the list is assumed to begin at @nfl@
c
      common/xlimi/nfl,lfl,nl,nflmx,lflmx,nlmx,nfls
      common /unit/lxn,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
c
      common /data/ store(5000)
      dimension istore(5000)
      equivalence (store(1),istore(1))
c
      ln=n
      call sowl(ln,iln,lsn,lfw,llw,lpb,ll)
      if (iln) 1000,1000,1030
1000  write(lo,1010) iln
1010  format(/,i7,' is not a valid list type')
      return
1030  continue
      store(nfl+2)=lsn
      call xup(lfw,istore(nfl),n )
      call swlin(iln,lsn,lfw,llw,lpb,ln)
      call xdump
      return
      end
c
code for sowl
      subroutine sowl  (lcl,iln,lsn,lfw,llw,lpb,ll)
c--write or overwrite a list on the disc
c
c  lcl  lenght that has to be written
c  iln  list number
c  lsn  list serial number
c  lfw  location of first word on the disc
c  llw  location of the last word on the disc
c  lpb  lenght of the preamble block of the list to be overwritten
c  ll   list lenght
c
c--find the list of this type
      lsn=0
      call srlin (iln,lsn,lfw,llw,lpb,ll)
      if(lfw) 1020,1020,1010
c--check if the current list is of the right lenght
1010  continue
      if(ll-lcl) 1020,1060,1060
c--list can not be overwritten
c--find the next free location
1020  continue
      call xnxtf(ll)
      lfw=ll
      llw=lfw+lcl
      call snxtf(llw)
      llw=llw-1
      lpb=0
1060  continue
      ll=lcl
      lsn=lsn+1
      return
      end
c
code for sldl
      subroutine sldl (iln,lsn,lfw,llw)
c--load list into store
c  iln  list type number
c  lsn  list serial number
c  lfw  location of the first word of the list in store
c  llw  location of the last word of the list in store
c
c--the  list is brought up from the bottom of the store,
c  ~lfw~and~llw~ are set on return
c
      common/xlimi/nfl,lfl,nl,nflmx,lflmx,nlmx,nfls
c
      call srlin (iln,lsn,li,lj,lk,ll)
      lfw=nfl
      llw=lfw+ll-1
      call xsac(iln,lsn,lfw,llw)
      call srdls(iln,lsn,lfw,l)
      return
      end
c
code for srdls
      subroutine srdls(iln,lsn,lfw,lll)
c--read a list from the disc
c
c  iln  list type number
c  lsn  list serial number - set on return
c  doc  array to hold the list
c  lll  number of words to bring down - if zero the whole list
c       is brought down,and@ll@ is set to the number of words read
c
c--for lists with a  reamble block,only the preamble block is read,
c  and @lll@ is set negative on return
c
      common/unit/lxn,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
c
      common /data/ store(5000)
      dimension istore(5000)
      equivalence (store(1),istore(1))
c
      call srlin (iln,lsn,li,lj,lk,ll)
      if(li) 1000,1000,1020
1000  continue
      write(lo,1010) iln
1010  format(///,16h no list of type,i5,8h  stored,/)
1015  continue
      stop 1111
1020  continue
      if(lk) 1040,1040,1030
1030  continue
      ll=lk
1040  continue
      lll=ll
      nll=lll
      call xdwn(li,istore(lfw),nll)
      il=store(lfw+1)
      if(il-iln)1061,1063,1061
1061  continue
      write(lo,1062)iln
1062  format(//,' requested list',i4,' has been corrupted')
      go to 1015
1063  continue
      if(lk) 1080,1080,1070
1070  continue
      lll=-lll
1080  continue
      return
      end
c
code for xsac
      subroutine xsac(iln,lsn,lfw,llw)
c--storage allocation control - this subroutine also
c  checks that the store limits have not been exceeded
c
c  iln list type that is being used for this data type
c  lsn  list serial number
c  lfw  first word used in 'store'
c  llw  last word used in 'store'
c--
      common/xlimi/nfl,lfl,nl,nflmx,lflmx,nlmx,nfls
      common/unit/lxn,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/xsae/ ncl,lis(4,39)
c--
 
      if(ncl) 980,980,950
950   continue
      do 970 i=1,ncl
      if(iln-lis(1,i)) 970,960,970
960   continue
      j=i
      go to 990
970   continue
980   continue
      ncl=ncl+1
      j=ncl
990   continue
      lis(1,j)=iln
      lis(2,j)=lsn
      lis(3,j)=lfw
      lis(4,j)=llw
      if(nfl+5-lfl) 1000,1000,1010
1000  continue
      return
1010  continue
      write(lo,1020)iln
1020  format(32h1***store overflow*** (list type,i5,1h))
      call xpas
      stop
      end
c
code for xcsae
      subroutine xcsae
c--clear storage allocation entries
c
      common/xsae/ ncl,lis(4,39)
      ncl=0
      return
      end
c
code for xpas
      subroutine xpas
c--print allocated store
      common/xlimi/nfl,lfl,nl,nflmx,lflmx,nlmx,nfls
      common/unit/lxn,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/xsae/ ncl,lis(4,39)
c--
c--check if any entries are waiting to be printed
      if(ncl) 1035,1035,990
990   continue
      write(lo,1000)
1000  format(///,18h allocated store :,//,5x,
     2 9hlist type,4x,10hserial no.,9x,7haddress,9x,6hlength,/)
      do 1030 i=1,ncl
      l=lis(4,i)-lis(3,i)+1
      write(lo,1020)(lis(k,i),k=1,4),l
1020  format(    2i13,i14,4h  to,i7,i10)
1030  continue
1035  continue
      l=lfl-nfl+1
      write(lo,1040)nfl,lfl,l
1040  format(//,19h free location(s) : ,i7,4h to ,i7,
     2 2h, ,i7,9h word(s) )
      return
      end
c
code for komp
      function kcomp(nw,itest,iarg,narg,nsarg)
c--standard comparision routine
c
c  nw     number of separate words to be compared
c  itest  vector holding the word(s) to be compared
c  iarg   vector holding the wrods against which the comparision is to
c         be made
c  narg   number of standard words to compare against
c  nsarg  the step beteen successive comparision words
c
c-- on return kcomp holds the position of the find or else -1
c
c--
      dimension itest(nw),iarg(narg)
      i=1
      j=1
1000  continue
      if(narg-i)1010,1030,1030
1010  continue
      kcomp=-1
1020  continue
      return
1030  continue
      k=1
      l=j
1040  continue
      if(itest(k)-iarg(l)) 1080,1050,1080
1050  continue
      if(nw-k)1060,1060,1070
1060  continue
      kcomp=i
      go to 1020
1070  continue
      k=k+1
      l=l+1
      go to 1040
1080  continue
      i=i+1
      j=j+nsarg
      go to 1000
      end
c
code for jrca
      function jrca(ja,n)
c--read an holerith string terminated by a blank or comma
c  into the array 'ia' and put the number of characters read
c  into 'n'
c
c--the input variables are :
c
c  ia the array to hold the character string (a2 format)
c  n  the number of characters read  -  number of words used
c     is equal to (n+1)/2
c
c--
      common/xchar/id,ie,ib,ic,ia,ih
     1 ,numb(10),iplus, inus,ipoint
      dimension ja(40)
c--
      j=jrcx(ja,n,ib,2)
      jrca=j
      return
      end
c
code for jrcx
      function jrcx(ja,n,j,k)
c--read a holerith character string, terminated by one of the
c  characters contained into yhe vector 'j', putting the result
c  into 'ia' and the number of characters into 'n'
c
c-- jrcx is set as follows on return :
c
c  -1  character string not found
c   0  all okay
c
c--input values are :
c
c  ja the array to hold the character string (a2 format)
c  n  the number of characters read  -  number of words used
c     is equal to (n+1)/2
c  j  the vector containing the characters that is to terminate
c     the string (a1 format)
c  k  number of characters in 'j'
c
c--
      common/xchar/id,ie,ib,ic,ia,ih
     1 ,numb(10),iplus, inus,ipoint
      common/xcard/nch,image(80),nc,nd,ni,nt,na(3),ncd,idoc(20)
      dimension ja(40)
      dimension j(k)
c
c--set up the initial constats
      i=0
      jn=0
      jrcx=0
      nd=kne(nc,j,k)
      if(nd) 1010,1010,1020
1010  continue
      jrcx=-1
      go to 1100
1020  continue
c--determine the length of the character string
      nc=keq(nd,j,k)
      if(nc) 1030,1030,1040
1030  continue
      nc=81
1040  continue
      n=nc-nd
      call scomp(image(nd),ja,n)
1100  continue
      return
      end
c
code for kne
      function kne(nc,nd,n)
c--search a card for the character not of type 'nd'
c
c  nc  character position at which to start
c  nd  the vector containing the characters which the current
c      character must not be
c  n   number of characters in 'nd'
c
c--kne returns set to the position of the first character not
c  equal to 'nd', or else to -1.
c
      common/xcard/nch,image(80),idm(3),nt,na(3),ncd,idoc(20)
      dimension nd(n)
c--
      i=nc
      kne=-1
      if(i) 1000,1000,1001
1001  if(i-nt-1) 1002,1000,1000
1002  continue
      do 1004 l=1,n
      if(image(i)-nd(l)) 1004,1006,1004
1004  continue
      go to 1005
1006  continue
      i=i+1
      go to 1001
1005  kne=i
1000  continue
      return
      end
c
code for keq
      function keq(nc,nd,n)
c--find the next character on a card
c
c  nc  character position at which to start
c  nd  the vector containing the characters to search for
c  n   number of characters in 'nd'
c
c--keq is set to the character position , or -1 if the character
c  can not be found
c
      common/xcard/nch,image(80),idm(3),nt,na(3),ncd,idoc(20)
      dimension nd(n)
c--
      i=nc
      keq=-1
      if(i) 1000,1000,1001
1001  if(i-nt-1) 1002,1000,1000
1002  continue
      do 1004 l=1,n
      if(image(i)-nd(l)) 1004,1005,1004
1004  continue
      i=i+1
      go to 1001
1005  keq=i
1000  continue
      return
      end
c
code for jredi
      function jredi(in)
c--like kredi function
c
c--no searching for the first blank character
c
c--
      common/xchar/id,ie,ib,ic,ia,ih
     1 ,numb(10),iplus, inus,ipoint
      common/xcard/nch,image(80),nc,nd,ni,nt,na(3),ncd,idoc(20)
c--set up the initial constants
      i=0
      j=1
c--search for the first non-blank character
      continue
      nc=kne(nc,id,4)
      if(nc) 1010,1010,1020
c--return sequence
1010  continue
      jredi=i*j
      return
c--check if first character is @+@ or @-@
1020  continue
      if(image(nc)-iplus)1030,1050,1030
1030  continue
      if(image(nc)- inus)1060,1040,1060
1040  continue
      j=-j
1050  continue
      nc=nc+1
      if(nc-nt-1) 1060,1010,1010
1060  continue
      do 1080 k=1,10
      if(image(nc)-numb(k)) 1080,1070,1080
1070  continue
      i=i*10+k-1
      go to 1050
1080  continue
c--remove any decimal points and numbers thereafter
      if(image(nc)-ipoint)1010,1090,1010
1090  continue
      nc=nc+1
      if(nc-nt-1) 1100,1010,1010
1100  continue
      do 1110 k=1,10
      if(image(nc)-numb(k)) 1110,1090,1110
1110  continue
      go to 1010
      end
c
code for jredf
      function jredf(a,n)
c--read n floating point number
c
c--jredf is set as follows on return :
c
c  -1  hash function found or spurious character found
c   0  all the numbers read correctly
c   1  not all the number have been read
c
c--
      common/xchar/id,ie,ib,ic,ia,ih
     1 ,numb(10),iplus, inus,ipoint
      common/xcard/nch,image(80),nc,nd,ni,nt,na(3),ncd,idoc(20)
c--
      dimension a(n)
      do 1000 i=1,n
      a(i)=0.0
1000  continue
      jredf=0
      do 1030 i=1,n
      nc=kne(nc,ib,2)
      if(nc) 1010,1010,1020
1010  continue
      jredf=1
      return
1020  continue
      if(kredf(a(i),1)) 1040,1030,1040
1030  continue
      return
1040  continue
      jredf=-1
      return
      end
c
code for kredf
      function kredf(store,non)
c--read floating point numbers
c
c--kreadf is set as follows on return :
c
c  -1  hash function found
c   0  numbers read    correctly
c   1  spurious character found
c
c--input values are :
c
c  store the array in to which the numbers should go
c  non   the number of numbers to read
c
c
c--this routine does not use fortran input processor and is thus
c  able to recover any data errors.
c
c--a number is terminated by one or more spaces,or the end of a card.
c
c--
      common/xchar/id,ie,ib,ic,ia,ih
     1 ,numb(10),iplus, inus,ipoint
      common/xcard/nch,image(80),nc,nd,ni,nt,na(3),ncd,idoc(20)
      dimension store(non)
c--
      kredf=0
      j=non
      k=1
8000  continue
      if(j) 8120,8120,8010
c--search for non-black characters
8010  continue
      nc=kne(nc,ib,2)
      if(nc) 8020,8020,8090
c--card change
8020  continue
c--directive or end of file on this card
      kredf=-1
      go to 8120
c--read a number
8090  continue
      if(kinpt(store(k))) 8100,8110,8100
c--spurious character found
8100  continue
c-----call xspch
      nc=keq(nc,ib,2)
      kredf=1
      go to 8120
8110  continue
      k=k+1
      j=j-1
      go to 8000
8120  continue
      return
      end
c
code for kinpt
      function kinpt(a)
c--read a number from a card
c
c  the numeric value is put in 'a'
c
c--error functions are indicated by the value of kinput on return
c
c  -1  first character does not indicate a number in this position
c   0  number read correctly
c   1  spurious character found after the first character read
c
c--on entry, the card character pointer ('nc') is assumed to be
c  pointing at first character of the number - i.e.  this
c  routine does not skip over blank spaces at the start.
c
c--a number is terminated by one or more spaces or the end  of a card
c
c--
      common/xchar/id,ie,ib,ic,ia,ih
     1 ,numb(10),iplus, inus,ipoint
      common/xcard/nch,image(80),nc,nd,ni,nt,na(3),ncd,idoc(20)
c--
c--set up the initial constants
      j=nc
      t=0.
      s=1.
      r=10.
      q=1.
      p=1.
c--check the first character to be read
      if(image(nc)-iplus)1000,1050,1000
1000  continue
      if(image(nc)- inus) 1020,1010,1020
1010  continue
      s=-1.
      go to 1050
1020  continue
      if (image(nc)-ipoint)1100,1040,1100
c--check if this is  the first '.' found
1030  continue
      if(p-0.5) 1130,1130,1040
c--reset for reading after the '.'
1040  continue
      r=1.
      q=0.1
      p=0.1
1050  continue
      nc=nc+1
c--check if this is end of card
      if(nc-nt-1) 1060,1070,1070
c--check if this is the end of the number - ' '
1060  continue
      if(image(nc)-ib    ) 1090,1070,1090
1070  continue
      kinpt=0
1075  continue
      a=t*s
      return
1090  continue
      if(image(nc)-ipoint)1100,1030,1100
c--find the numeric equivalent of the character and add in
1100  continue
      do 1120  i=1,10
      if(image(nc)-numb(i)) 1120,1110,1120
1110  continue
      t=t*r+float(i-1)*q
      q=q*p
      go to 1050
1120  continue
c--check if an error occurs on the first character read
      if(j-nc) 1130,1140,1130
1130  continue
      kinpt=-1
      go to 1075
1140  continue
      kinpt=1
      go to 1075
      end
c
code for scomp
      subroutine scomp(ja,jb,i)
c--compress two characters in one word
c
c  ja  vector holding the characters
c  jb  vector holding the words
c  i   number of characters to compress
c
c--
      common/xcard/nch,idum(108)
      character*80  ibuf
      dimension ja(i),jb(i)
c
c--clear buffer
      ibuf=' '
      write(ibuf,1000)(ja(j),j=1,i)
1000  format(80a1)
      i1=(i+nch-1)/nch
      read(ibuf,1010)(jb(j),j=1,i1)
1010  format(40a2)
      return
      end
c
code for trasf
      subroutine trasf(store,temp,k)
c--auxiliary subroutine for transfering data
c
c  store output vector
c  temp  input vector
c  k  number of words
c
      dimension temp(k),store(k)
c
      li1=1
      j1=1
      do 1000 n=1,k
      store(li1)=temp(j1)
      li1=li1+1
      j1=j1+1
1000  continue
      return
      end
c
code for xmtmt
      subroutine xmtmt(a,b,c,l,m,n)
c--a(l,m).b(n,m)'=c(l,n)
      common/xmate/itdf(9), m1d,m2d,n1d,n2d
      dimension a(9),b(9),c(9)
      m1d=l
      m2d=1
      n1d=n
      n2d=1
      call xmtmr(a,b,c,l,m,n)
      return
      end
c
code for xmtmr
      subroutine xmtmr(a,b,c,l,m,n)
c--main matrix multiplication routine
      common/xmate/itdf(9), m1d,m2d,n1d,n2d
      dimension a(9),b(9),c(9)
      l1=1
      n2=1
      do 1030 j=1,n
      m2=1
      do 1020 i=1,l
      c(l1)=0.
      m1=m2
      n1=n2
      do 1010 k=1,m
      c(l1)=c(l1)+a(m1)*b(n1)
      m1=m1+m1d
      n1=n1+n1d
1010  continue
      l1=l1+1
      m2=m2+m2d
1020  continue
      n2=n2+n2d
1030  continue
      return
      end
c
      subroutine minv9( a,iv)
c
c---- calcola l'inversa della matrice a e la
c---- memorizza in iv
c---- alfa e' la matrice aggiunta
c
      dimension  a(3,3),iv(9), alfa(3,3)
c
      alfa(1,1)=a(2,2)*a(3,3)-a(2,3)*a(3,2)
      alfa(1,2)=-1*(a(2,1)*a(3,3)-a(2,3)*a(3,1))
      alfa(1,3)=a(2,1)*a(3,2)-a(2,2)*a(3,1)
      alfa(2,1)=-1*(a(1,2)*a(3,3)-a(1,3)*a(3,2))
      alfa(2,2)=a(1,1)*a(3,3)-a(1,3)*a(3,1)
      alfa(2,3)=-1*(a(1,1)*a(3,2)-a(1,2)*a(3,1))
      alfa(3,1)=a(1,2)*a(2,3)-a(1,3)*a(2,2)
      alfa(3,2)=-1*(a(1,1)*a(2,3)-a(1,3)*a(2,1))
      alfa(3,3)=a(1,1)*a(2,2)-a(1,2)*a(2,1)
      det=a(1,1)*alfa(1,1)+a(1,2)*alfa(1,2)+a(1,3)*alfa(1,3)
      l=1
      do 10 i=1,3
      do 10 j=1,3
      iv(l)=alfa(i,j)/det
      l=l+1
10    continue
      return
      end
c
code for frm01
      subroutine frm01(ax)
c--form list 1 , unit cell constants
c
      common/unit/lxn,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      dimension  ad(9),bd(9),cd(9),sd(9),ar(9),br(9),cr(9),sr(9)
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common/xlimi/nfl,lfl,nl,idummy(3),nfls
      common /data/ store(5000)
      dimension istore(5000)
      equivalence(store,istore)
c
      dimension ax(6)
c--
      nfl=nfls
      call xcln(1)
      l=nfl+200
      l1=l
      do 1003 i=1,6
      store(l1)=ax(i)
      l1=l1+1
1003  continue
c--check if the cosines or the angles have been input
      l1=l+3
      l2=l+6
      l3=l+9
      if(store(l+3)-1.5) 1010,1100,1100
1010  continue
      do 1015 i=1,3
      store(l2)=store(l1)
      a=store(l2)
      store(l3)=sqrt(1.0-a*a)
      b=store(l3)
      store(l1)=atan2(b,a)
      l1=l1+1
      l2=l2+1
      l3=l3+1
1015  continue
      go to 1200
1100  continue
      do 1105 i=1,3
      store(l1)=store(l1)*dtor
      b=store(l1)
      store(l2)=cos(b)
      store(l3)=sin(b)
      l1=l1+1
      l2=l2+1
      l3=l3+1
1105  continue
c--calculate the reciprocal parameters
1200  continue
      l1=l
      do 1222 i=1,3
      ad(i)=store(l   )
      bd(i)=store(l+ 3)
      cd(i)=store(l+ 6)
      sd(i)=store(l+ 9)
      l=l+1
1222  continue
      j=2
      k=3
      do 1212 i=1,3
      cr(i)=(cd(j)*cd(k)-cd(i))/(sd(j)*sd(k))
      sr(i)=sqrt(1.0-cr(i)*cr(i))
      br(i)=atan2(sr(i),cr(i))
      j=j+1
      if(j-3) 1112,1112,1122
1122  continue
      j=j-3
1112  continue
      k=k+1
      if(k-3) 1212,1212,1201
1201  continue
      k=k-3
1212  continue
      j=2
      k=3
      do 1312 i=1,3
      ar(i)=1.0/(ad(i)*sd(j)*sr(k))
      j=j+1
      if(j-3) 1232,1232,1221
1221  continue
      j=j-3
1232  continue
      k=k+1
      if(k-3) 1312,1312,1301
1301  continue
      k=k-3
1312  continue
      l=l1
      do 1322 i=1,3
      store(l+12)=ar(i)
      store(l+15)=br(i)
      store(l+18)=cr(i)
      store(l+21)=sr(i)
      l=l+1
1322  continue
      l=l1
      m=l+12
      vr=store(m)*store(m+1)*store(m+2)*
     2  store(m+9)*store(m+10)*store(l+11)
      v=1.0/vr
      lk=nfl+5
      do 1300 i=1,6
      store(lk)=store(l)
      store(lk+7)=store(l+12)
      lk=lk+1
      l=l+1
1300  continue
      store(lk)=v
      store(lk+7)=vr
      l=nfl+200
      lk=nfl+19
      lj=lk+35
      do 1310 li=lk,lj
      store(li)=0.0
1310  continue
      lk=nfl+37
c--calculate orthogonalization matrix for real space
      store(lk  )=store(l  )*store(l+10)*store(l+23)
      store(lk+3)=-store(l  )*store(l+10)*store(l+20)
      store(lk+6)=store(l  )*store(l+7)
      store(lk+4)=store(l+1)*store(l+9)
      store(lk+7)=store(l+1)*store(l+6)
      store(lk+8)=store(l+2)
      lk=lk+9
c--calculate orthogonalization matrix for reciprocal space
      store(lk  )=store(l+12)
      store(lk+1)=store(l+13)*store(l+20)
      store(lk+2)=store(l+14)*store(l+19)
      store(lk+4)=store(l+13)*store(l+23)
      store(lk+5)=-store(l+14)*store(l+22)*store(l+6)
      store(lk+8)=1.0/store(l+2)
c--calculate the real and reciprocal metric tensor
      li=nfl+37
      do 1320 j=1,9
      ad(j)=store(li)
      li=li+1
1320  continue
      call xmtmt (ad,ad,sd,3,3,3)
      li=nfl+19
      lk=nfl+46
      do 1330 j=1,9
      store(li)=sd(j)
      li=li+1
      ad(j)=store(lk)
      lk=lk+1
1330  continue
      call xmtmt(ad,ad,sd,3,3,3)
      li=nfl+28
      do 1340 j=1,9
      store(li)=sd(j)
      li=li+1
1340  continue
c--write the list 1 to the disc
      n =55
      call sfrml (1,n )
      return
      end
code for yfl01
      subroutine yfl01
c--form absolute list 1 in store
c
c--the locations in store are controlled by the following variables
c
c  l1p1  location real cell parameters
c  l1p2  location of the reciprocal parameters
c  l1m1  location of the real metric tensor
c  l1m2  location of the reciprocal metric tensor
c  l1o1  location of the real orthogonalization matrix
c  l1o2  location of the reciprocal orthogonalization matrix
c  l1c   location of the coefficients needed to convert the
c        isotropic temperature factor to the aniso off diagonal
c        terms  (=cos(a*))
c  l1s   terms of the r(ij)=s
c  l1a   coefficients needed for the aniso temperature factor
c
c--
      common/unit/lxn,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/rc/p(6),cx(9),dumm(9)
      common/trig/sint(450),pi,twopi,dtor,rtod
c--
      common/xlimi/ nfl,idummy(5),nfls
      common/lst01/l1p1,l1p2,l1m1,l1m2,l1o1,l1o2,l1a,l1c,l1s
      common /data/ store(5000)
      dimension  istore(5000)
      equivalence(store,istore)
c--
      nfl=nfls
      twopis=2.0*pi*pi
      call srlin(1,lsn,li,lj,lk,ll)
      if(li.le.0) return
      call sldl(1,ly,li,lz)
      lii=li
      l1p1=li+5
      l1p2=l1p1+7
      l1m1=l1p2+7
      l1m2=l1m1+9
      l1o1=l1m2+9
      l1o2=l1o1+9
      l1a =lz+1
      l1c =l1a+6
      l1s =l1c+3
      nfl=l1s+6
      ljj=nfl-1
c--set up the necessary coefficients
      j=l1c
      k=l1p2+3
      l=l1s
      m=l1m2
      n=l1a
      i1=3
      do 1000 i=1,3
      store(j)=cos(store(k))
      store(l)=0.25*store(m)
      store(n)=-twopis*store(m)
      j=j+1
      k=k+1
      l=l+i1
      i1=i1-1
      m=m+4
      n=n+1
1000  continue
c--set up the off diagonal terms
      store(l1s+1)=0.5*store(l1m2+1)
      store(l1s+2)=0.5*store(l1m2+2)
      store(l1s+4)=0.5*store(l1m2+5)
      store(n  )=-2.*twopis*store(l1p2+1)*store(l1p2+2)
      store(n+1)=-2.*twopis*store(l1p2  )*store(l1p2+2)
      store(n+2)=-2.*twopis*store(l1p2  )*store(l1p2+1)
      call xsac(  1,ly,lii,ljj)
      p(1)=store(l1s  )
      p(2)=store(l1s+3)
      p(3)=store(l1s+5)
      p(4)=store(l1s+1)
      p(5)=store(l1s+2)
      p(6)=store(l1s+4)
      cx(1)=store(l1p1  )
      cx(2)=store(l1p1+1)
      cx(3)=store(l1p1+2)
      cx(4)=store(l1p1+3)*rtod
      cx(5)=store(l1p1+4)*rtod
      cx(6)=store(l1p1+5)*rtod
      cx(7)=sin(store(l1p1+3))
      cx(8)=sin(store(l1p1+4))
      cx(9)=sin(store(l1p1+5))
      return
      end
c
code for yfrm02
      subroutine yfrm02
c--form list 2 , symmetry positions
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),lsys,ngen
     *,irot(48,48),ivet(10),jvet(8),nori,modul(3),nss(3)
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
c
      common/xlimi/nfl,lfl,nl,idummy(3),nfls
      common /data/ store(5000)
      dimension istore(5000)
      equivalence(store,istore)
      dimension iv(9)
c--
      nfl=nfls
      call xcln(2)
      if(latt.eq.1) il=1
      if(latt.eq.2) il=5
      if(latt.eq.3) il=6
      if(latt.eq.4) il=7
      if(latt.eq.5) il=2
      if(latt.eq.6) il=4
      if(latt.eq.7) il=3
      mm=13
      l2=nfl+mm
      md2=12
      ngen=0
      ic=icent+1
      ngo=nsym*ic
      n2=nsym
c--
      store(nfl+5)=float(il )
      store(nfl+6)=float(ic)
      store(nfl+7)=float(n2 )
      store(nfl+8)=float(lsys)
      store(nfl+9)=nori
      store(nfl+10)=mm
      store(nfl+11)=float(ngen)
      store(nfl+12)=mm+n2*md2
      l2=nfl+mm
      m2=l2
      do 90 i=1,n2
      do 70 j=1,3
      do 70 k=1,3
      store(m2)=ksmat(i,j,k)
   70 m2=m2+1
      do 80 j=1,3
      store(m2)=tmat(i,j)
   80 m2=m2+1
   90 continue
      m2s=m2
      do 1300 j=1,16
      istore(m2s)=nt(j)
      m2s=m2s+1
1300  continue
      do 1310 j=1,10
      istore(m2s)=ivet(j)
      m2s=m2s+1
1310  continue
      do 1320 j=1,8
      istore(m2s)=jvet(j)
      m2s=m2s+1
1320  continue
      do 1340 i=1,3
      istore(m2s  )=modul(i)
      istore(m2s+3)=nss  (i)
      m2s=m2s+1
1340  continue
      m2s=m2s+3
      istore(m2s)=1
      m2s=m2s+1
      m2=l2+md2
      do 30 i=2,n2
      call minv9(store(m2),iv)
      mm2=l2
      do 20 j=1,n2
      l=mm2
      do 10 k=1,9
      if(store(l).ne.iv(k))go to 19
      l=l+1
10    continue
      istore(m2s)=j
      go to 29
19    continue
      mm2=mm2+md2
20    continue
      stop 333
29    continue
      m2=m2+md2
      m2s=m2s+1
30    continue
      do 1330 j=1,ngo
      do 1330 i=1,ngo
      istore(m2s)=irot(j,i)
      m2s=m2s+1
1330  continue
      nn=m2s-nfl
c--write the list 2 to the disc
      call sfrml(2,nn)
      return
      end
c
code for yfl02
      subroutine yfl02
c--load list 2 in common area
c
c  the variables are used as follows :
c
c  ic     centro (1) or non-centro (0)
c  il     lattice type (1-7)
c  g2     scale constants to convert the /fc/'s onto the absolute scale
c  isys   crystal family
c  ngen   number of generator
c  l2     location of the first word of the first symmetry matrix
c  md2    number of words per matrix  (=12)
c  n2     number of matrices
c  l2s    location of the first word of the space group symbol
c  l2i    location of the first word of the correlation matrix
c         (ngoxngo where ngo=n2x(ic+1) )
c  l2t    location of the temporary storage
c  md2t   number of words per temporary location  (=10)
c  n2t    number of temporary locations (=n2)
c  n2p    the number of speararte shift vectors needed to describe
c         this lattice
c  md2p   number of words per shift vectors
c
      common/unit/lxn,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),lsys,ngen
     *,irot(48,48),ivet(10),jvet(8),nori,modul(3),nss(3)
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/lst02/ic,il,g2,isys,ngex,l2,m2,md2,n2,l2s,m2s,md2s,n2s,
     2 l2t,m2t,md2t,n2t,l2p,m2p,md2p,n2p,l2i,m2i,md2i,n2i
c
      common/xlimi/ nfl,idummy(5),nfls
      common /data/ store(5000)
      common/trig/sint(450),pi,twopi,dtor,rtod
      dimension  istore(5000)
      equivalence(store,istore)
      dimension hl(12)
c
      nfl=nfls
      twopis=2.0*pi*pi
      call srlin(2,lsn,li,lj,lk,ll)
      if(li.le.0) return
      call sldl(2,ly,li,lz)
      l2=     store(li+10) +li
      n2=     store(li+7)
      md2=12
      isys=    store(li+8)
      nsym=n2
      lsys=isys
      nori=    store(li+9)
      ngen=    store(li+11)
      m2s=     store(li+12)+li
      l2s=m2s
      l2a=l2s+16
      l2b=l2a+10
      l2c=l2b+8
      l2d=l2c+6
      l2i=l2d+n2
      n2t=n2
      md2t=10
      l2t=lz+1
      ljj=l2t+n2t*md2t-1
      ic=     store(li+6)
      il=     store(li+5)
      icent=ic  - 1
c
      if(il.eq.1) latt=1
      if(il.eq.5) latt=2
      if(il.eq.6) latt=3
      if(il.eq.7) latt=4
      if(il.eq.2) latt=5
      if(il.eq.4) latt=6
      if(il.eq.3) latt=7
      mm=13
      l2=nfl+mm
      md2=12
      ngo=nsym*ic
c--
      m2=l2
      do 90 i=1,n2
      do 70 j=1,3
      do 70 k=1,3
      ksmat(i,j,k)=store(m2)
   70 m2=m2+1
      do 80 j=1,3
      tmat(i,j)=store(m2)
   80 m2=m2+1
   90 continue
      m2=l2s
      do 1300 j=1,16
      nt(j)=istore(m2)
      m2=m2+1
1300  continue
      m2=l2a
      do 1310 j=1,10
      ivet(j)=istore(m2)
      m2=m2+1
1310  continue
      m2=l2b
      do 1320 j=1,8
      jvet(j)=istore(m2)
      m2=m2+1
1320  continue
      m2=l2c
      do 1340 i=1,3
      modul(i)=istore(m2)
      nss(i)=istore(m2+3)
      m2=m2+1
1340  continue
      m2=l2i
      do 1330 j=1,ngo
      do 1330 i=1,ngo
      irot(j,i)=istore(m2s)
      m2s=m2s+1
1330  continue
c
      md2p=3
      n2p=il
      if(il-4)1410,1410,1400
1400  continue
      n2p=2
1410  continue
      do 1520 i=1,3
      hl(i)=0.
1520  continue
      go to (1700,1600,1630,1650,1600,1600,1600),il
c--'i' , 'a' , 'b' or 'c' centred lattice
1600  continue
      do 1610 i=4,6
      hl(i)=0.5
1610  continue
      if(il-4) 1700,1700,1620
1620  continue
      hl(il-1)=0.
      go to 1700
c--'r' centred lattice
1630  continue
      do 1640 i=5,6
      hl(i  )=0.66666667
      hl(i+3)=0.33333333
1640  continue
      hl(4)=hl(8)
      hl(7)=hl(5)
      go to 1700
c--'f' centred lattice
1650  continue
      k=4
      do 1670 i=4,12,4
      do 1660 j=1,3
      hl(k)=0.5
      k=k+1
1660  continue
      hl(i)=0.
1670  continue
1700  continue
c--define the scale factor to convert the /fc/'s
      g2=store(li+5)
      if(g2-4.5)1030,1030,1020
1020  continue
      g2=2.
1030  continue
      if(g2-0.1)1040,1050,1050
1040  continue
      g2=1.
1050  continue
      pts=g2
      g2=g2*store(li+6)
      call xsac(2,ly,li,ljj)
      call musym(ksmat,tmat,n2,is,ts)
      return
      end
c
code for yfrm03
      subroutine yfrm03(ier)
c--form list 3, form factors
c
      character blank,digit*12,card(100)*80,ffile*80
      common /chara/ blank,digit,card,ffile
      common/unit/lxn,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nat,f(9),nalf(8)
c
      common/xchar/id,ie,ib,ic,ia,ih
     1 ,numb(10),iplus, inus,ipoint
      common/xcard/nch,image(80),nc,nd,ni,nt,na(3),ncd,idoc(20)
      common/xlimi/nfl,lfl,nl,idummy(3),nfls
      common /data/ store(5000)
      dimension istore(5000)
      equivalence(store,istore)
      dimension ibuf(40),fnum(8)
c--
      ierr=0
      iwac=1
      nlenf=136
      itype=2
      iform=1
      if(jopen(kform,ffile,nlenf,itype,iform,ierr)) 9200,1013,1013
1013  continue
      ja=20
      n3=nk
      do 1000 i=1,nk
      fnum(i)=nw (i)
1000  continue
      n3a=n3
c--form list 3
      nfl=nfls
      call xcln(3)
      store(nfl+4)=1.0
      md3=18
      store(nfl+5)=float(n3)
      store(nfl+6)=12.0
      store(nfl+7)=md3
      store(nfl+8)=iwac
      lz=nfl+12
c
c--read the title on the file
      nta=nt
      nt=80
      rewind kform
      do 2005 i=1,40
      ibuf(i)=ib
2005  continue
      read(kform,2006,iostat=ierr,err=9100)(ibuf(i),i=1,40)
2006  format(40a2)
c--read number of records per atomic specie
      if(jrcrd(kform).eq.-1) then
                               write(lo,9110) ffile
                               ier=-1
                               return
                             endif
      ncard=jredi(in)
      if(ncard.ge.iwac+3)goto 2010
      write(lo,9110) ffile
      goto 9300
c--read the contents for each atomic specie
2010  continue
      if(jrcrd(kform).eq.-1) go to 9000
      if(jrca(ibuf,n)) 9100,2030,9100
2030  continue
      i=kcomp(1,ibuf,nalf,n3,1)
      if(i) 2100,2100,2040
2040  continue
      nc=1
      n3a=n3a-1
      if(jst03(lz,md3,fnum(i),ncard,iwac,kform)) 9100,2050,3100
2050  continue
      if(n3a) 3000,3000,2010
2100  continue
      do 2150 i=1,ncard-1
      if(jrcrd(kform).eq.-1) return
2150  continue
      go to 2010
c--close the 'form$' file
3000  continue
      close(kform,iostat=ierr,err=9100)
      n=lz-nfl
      call sfrml(3,n)
3100  continue
      nt=nta
      return
 9000 continue
      write(lo,9010)
 9010 format(' *** error ***  atom type not expected', / ,
     *       '               check content directive ')
      ier=-1
      return
9100  continue
      if (ierr.eq.0) then
                       write(lo,9110) ffile
                     else
                       write(lo,9120) ierr,ffile
                     endif
 9110 format(' *** error ***  possible file corrupted. file is ',a)
 9120 format(' *** error ***  read error, code =',i5,' file is ',a)
      go to 9300
9200  continue
      write(lo,9210) ffile
9210  format(' *** error ***  file not found, file is ',a)
9300  ier=-1
      return
      end
c
code for jrcrd
      function jrcrd(ncsu)
c--read a record from a file
c
      common/unit/lxn,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/xchar/id,ie,ib,ic,ia,ih
     1 ,numb(10),iplus, inus,ipoint
      common/xcard/nch,image(80),nc,nd,ni,nt,na(3),ncd,idoc(20)
c--
      jrcrd=0
      do 2012 i=1,80
      image(i)=ib
2012  continue
      read(ncsu,2013,iostat=ier,err=9100,end=3100) (image(i),i=1,80)
2013  format(80a1)
      nc=1
      return
9100  continue
      write(lo,9110) ier,ncsu
9110  format(' *** error ***  read error ',i5,' on channel ',i2)
3100  continue
      jrcrd=-1
      return
      end
c
code for jst03
      function jst03(lz,md3,fn,ncard,iwac,ncsu)
c--store in list 3 the information contained in the $form$ file
c
      common/unit/lxn,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/xlimi/nfl,lfl,nl,idummy(4)
      dimension temp(40)
c
      common /data/ store(5000)
      dimension istore(5000)
      equivalence(store,istore)
      dimension ibuf(10)
c--
      jst03=0
      ja=1
      if(jrca(ibuf,n)) 9100,2030,9100
2030  continue
      lx=lz
      istore(lx  )=ibuf(1)
      store(lz+12)=fn
      if(jredf(temp(ja),4)) 9100,2050,2050
2050  continue
      call trasf(store(lz+13),temp(ja),3)
      store(lz+17)=temp(ja+3)
      if(jrcrd(ncsu).eq.-1) go to 9000
      if(jrca(ibuf,n)) 9100,2070,9100
2070  continue
      if(istore(lx)-ibuf(1)) 9100,2080,9100
2080  continue
      if(kredf(temp(ja),6)) 9100,2090,9100
2090  continue
      call trasf(store(lz+3),temp(ja),6)
      if(jrcrd(ncsu).eq.-1) goto 9000
      if(jrca(ibuf,n)) 9100,2095,9100
2095  continue
      if(istore(lx)-ibuf(1)) 9100,2097,9100
2097  continue
      if(kredf(temp(ja),3)) 9100,2098,9100
2098  continue
      call trasf(store(lz+9),temp(ja),2)
      store(lz+2)=temp(ja+2)
      goto(2200,2210),iwac
2200  continue
      if(jrcrd(ncsu).eq.-1) goto 9000
      read(ncsu,2007)
      goto 2300
2210  continue
      read(ncsu,2007)
2007  format(1x)
      if(jrcrd(ncsu).eq.-1) goto 9000
2300  continue
      if(jrca(ibuf,n)) 9100,2310,9100
2310  continue
      if(istore(lx)-ibuf(1)) 9100,2320,9100
2320  continue
      if(kredf(temp(ja),3)) 9100,2330,9100
2330  continue
      store(lz+1)=temp(ja)
      store(lz+11)=temp(ja+1)
      store(lz+16)=temp(ja+2)
      lz=lz+md3
      return
9000  continue
      jst03=1
      return
9100  continue
      jst03=-1
      return
      end
c
code for yfl03
      subroutine yfl03
c--form absolute list 3
c
c  l3  location of the information for the first form factor
c  n3  number of form factors
c
c--
      common/lst03/l3,m3,md3,n3,l3t,m3t,l3ti,m3ti,l3g,n3g,sys03
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nat,f(9),nalf(8)
      common/xlimi/ nfl,idummy(5),nfls
      common /data/ store(5000)
      dimension  istore(5000)
      equivalence(store,istore)
c--
      nfl=nfls
      call sldl(3,ly,l3g,lz)
      n3=     store(l3g+5)
      l3=     store(l3g+6) +l3g
      md3=    store(l3g+7)
      l=lz-1
      call xsac(3,ly,li,l)
      nk=n3
      m3=l3
      nat=0
      do 1000 i=1,n3
      nalf(i)=istore(m3)
      nw(i)= store(m3+12)
      no(i)= store(m3+13)
corig cl(i)=store(m3+1)+store(m3+2)
      cl(i)=store(m3+2)
      if (no(i).gt.1) nat=nat+nw(i)
      m3i=m3+3
      do 1100 j=1,4
      al(j,i)=store(m3i )
      bs(j,i)=store(m3i+1)
      m3i=m3i+2
1100  continue
      m3=m3+md3
1000  continue
      return
      end
c
code for yfl06
      subroutine yfl06(in,nrifl)
c--set up list 6 for reading and possibly writing
c
c--the common variables are used as follows
c
c  l6    disc location for writing
c  l6d   disc location for reading
c  m6    location of the core buffer at which the results are found
c  m6dk  location of the input (or output) disc buffer
c  n6dk  number of integer words in the disc buffer
c  md6d  number of real words per reflections on read
c  n6    number of reflections to be read
c  n6d   number of reflections written
c  l6p   address in store of the preamble block
c  n6p   length of the preamble block
c  ld6p  disc location of the preamble block
c  l6rs  location of the first scale factor for writing
c  l6rk  location of the first scale factor for reading
c  l6in  location of the first sorting codex
c
c  in = 0  prima chiamata
c  in = 1  successive letture
c
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/rc/p(6),cx(9),nreg,nb,rhomax,mm,en,mz,er,th,rhomin
c     common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common/c/flgw(30),flgd(30),avr(30),dcv(50),slope,flgk,bt,sc,del,ks
      common/lst06/l6,l6a,l6d,ld6p,m6,m6dk,n6dk,md6d,n6d,n6,n6p,
     2 l6rs,l6rk,l6in,l6p,k1,k2,k3
      common/xlimi/ nfl,idummy(5),nfls
      common /data/ store(5000)
      dimension  istore(5000)
      equivalence(store,istore)
c--
      if(in.ne.0)go to 1000
c--load the preamble of list 6
      nfl=nfls
      k3=128
      k2=128*k3
      k1=128*k2
      inm=6
      call srlin(inm,li,ld6p,lk,ln,lm)
      n6p=ln
      l6p=nfl
      call srdls(inm,l,l6p,lj)
      md6d= store(l6p+5)
      n6dk= store(l6p+6)
      n6d = store(l6p+7)
      n6  = n6d
      nrifl=n6d
      ihx(1)=store(l6p+10)
      ihx(2)=store(l6p+11)
      ihx(3)=store(l6p+12)
c     jpart =store(l6p+15)
c     knw   =store(l6p+16)
c     bt    =store(l6p+17)
c     sc    =store(l6p+18)
c     mm    =store(l6p+19)
c     mz    =store(l6p+20)
c     s3s2  =store(l6p+21)
c     s3s2p =store(l6p+22)
      l6d = ld6p+n6p
      l6a = l6d
      m6dk=l6p+n6p
      m6=m6dk+n6dk
      nfl=m6+md6d
      l6=l6d
      return
1000  l6=l6a
      l6d=l6a
      return
      end
c
code for kkfnr
      function kkfnr(vet)
c--fetch the next reflection
c--return values are :
c  -1  last reflection marker found
c   0  next reflection found
c  m6  location of the core buffer
c
c--
      common/lst06/l6,l6a,l6d,ld6p,m6,m6dk,n6dk,md6d,n6d,n6,n6p,
     2 l6rs,l6rk,l6in,l6p,k1,k2,k3
      dimension vet(12)
c--
1000  continue
      j=kkldnr(vet,in)
c--check for the last reflection
      if(j) 2000,1010,1010
1010  continue
      if(in) 1020,2000,1020
c--reflection deleted
1020  continue
      l6=l6+n6dk
      go to 1000
2000  continue
      kkfnr=j
      return
      end
c
code for kkldnr
      function kkldnr(vett,in)
c--load the next reflection from the disc
c
      common/lst06/l6,l6a,l6d,ld6p,m6,m6dk,n6dk,md6d,n6d,n6,n6p,
     2 l6rs,l6rk,l6in,l6p,k1,k2,k3
      common/xfile/ifile,ilist,iend,infle,nwfle,icfle,lid(4)
c
      common /data/ store(5000)
      dimension  istore(5000)
      equivalence(store,istore)
      dimension vet(12),ivet(12) ,vett(12)
      equivalence (vet,ivet)
c--
      kkldnr=0
      call xdwn(l6d,istore(m6dk),n6dk)
c--check for the last reflection marker
      if(istore(m6dk)-iend)1010,1000,1010
1000  continue
      kkldnr=-1
      return
1010  continue
      l6d=l6d+n6dk
c--unpack the values
      in=istore(m6dk  )/k1
      ihkl=istore(m6dk  )-in*k1
      in=in-1
      ih=ihkl/k2
      ikl=ihkl-ih*k2
      ik=ikl/k3
      il=ikl-ik*k3
      ivet(1   )=ih-64
      ivet(2   )=ik-64
      ivet(3   )=il-64
      vet(4)= store(m6dk+1)
      vet(5)= store(m6dk+2)
      vet(6)= store(m6dk+3)
      vet(7)= store(m6dk+4)
      do 100 i=1,12
100   vett(i)=vet(i)
      return
      end
c
code for spb07
      subroutine spb07(iy)
c--rewrite the preamble block for a list 7
c
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common/lst07/l7,l7a,l7d,ld7p,m7,m7dk,n7dk,md7d,n7d,n7,n7p,
     2 l7rs,l7rk,l7in,l7p,kk1,kk2,kk3
c
      common/xlimi/nfl,lfl,nl,idummy(3),nfls
      common /data/ store(5000)
      dimension istore(5000)
      equivalence(store,istore)
c--
      in=7
      nfl=nfls
      call srlin(in,li,ld7p,lk,ln,lm)
      n7p=ln
      l7p=nfl
      call srdls(in,l,l7p,lj)
      if (iy.eq.-1) then
                      store(l7p+26)=fosog
                     istore(l7p+27)=ksigma
                    else
                      istore(l7p+25)=iy
                    endif
c--rewrite the preamble block
      call xup(ld7p,istore(nfl),n7p)
      call xdump
      return
      end
c
code for ysfl07
      subroutine ysfl07(nrifl,mmm,mmmz,npseud,iy)
c--load list 7
c
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/rc/p(6),cx(9),nref,nb,rhomax,mm,en,mz,er,th,rhomin
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common/c/flgw(30),flgd(30),avr(30),dcv(50),slope,flgk,bt,sc,del,ks
      common/lst07/l7,l7a,l7d,ld7p,m7,m7dk,n7dk,md7d,n7d,n7,n7p,
     2 l7rs,l7rk,l7in,l7p,kk1,kk2,kk3
      common/xlimi/ nfl,idummy(5),nfls
      common /data/ store(5000)
      dimension  istore(5000)
      equivalence(store,istore)
c--load the preamble of list 7
      nfl=nfls
      kk3=128
      kk2=128*kk3
      kk1=128*kk2
      inm=7
      call srlin(inm,li,ld7p,lk,ln,lm)
      n7p=ln
      l7p=nfl
      call srdls(inm,l,l7p,lj)
      md7d= store(l7p+5)
      n7dk= store(l7p+6)
      n7d = store(l7p+7)
      n7  = n7d
      nrifl=n7d
      ihx(1)=store(l7p+10)
      ihx(2)=store(l7p+11)
      ihx(3)=store(l7p+12)
      jpart =store(l7p+15)
      knw   =store(l7p+16)
      bt    =store(l7p+17)
      sc    =store(l7p+18)
      mm    =store(l7p+19)
      mz    =store(l7p+20)
      mmm=mm
      mmmz=mz
      s3s2  =store(l7p+21)
      s3s2p =store(l7p+22)
      jtran =int(store(l7p+23))
      npseud=int(store(l7p+24))
      iy    =istore(l7p+25)
      fosog =    store(l7p+26)
      ksigma=istore(l7p+27)
      l7d   =ld7p+n7p
      m7dk=l7p+n7p
      m7=m7dk+n7dk
      nfl=m7+md7d
      l7=l7d
      return
      end
c
code for snr07
      subroutine snr07(vett)
c--read the next reflections
c
c     common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common/c/flgw(30),flgd(30),avr(30),dcv(50),slope,flgk,bt,sc,del,ks
      common/lst07/l7,l7a,l7d,ld7p,m7,m7dk,n7dk,md7d,n7d,n7,n7p,
     2 l7rs,l7rk,l7in,l7p,kk1,kk2,kk3
      common/xlimi/ nfl,idummy(6)
      common /data/ store(5000)
      dimension  istore(5000)
      equivalence(store,istore)
      dimension vett(9),vet(9),ivet(9)
      equivalence (vet,ivet)
c--
      call xdwn(l7d,istore(m7dk),n7dk)
      l7d=l7d+n7dk
c--unpack the values
      in=istore(m7dk  )/kk1
      ihkl=istore(m7dk  )-in*kk1
      in=in-1
      ih=ihkl/kk2
      ikl=ihkl-ih*kk2
      ik=ikl/kk3
      il=ikl-ik*kk3
      ivet(1   )=ih-64
      ivet(2   )=ik-64
      ivet(3   )=il-64
      vet(4)= store(m7dk+1)
      vet(5)= store(m7dk+2)
      vet(6)= int(store(m7dk+3)/32768)*0.001
      vet(7)= amod(store(m7dk+3),32768.)*0.001
      vet(8)= store(m7dk+4)
      vet(9)= store(m7dk+5)
      continue
      do 2100 i=1,9
2100  vett(i)=vet(i)
      return
      end
c
code for frm19
      subroutine frm19(lpseuv,patom,qatom)
c--form list 19, information for pseudo-symmetry
c
      common/xlimi/nfl,lfl,nl,nflmx,lflmx,nlmx,nfls
      common /data/ store(5000)
      dimension istore(5000),lpseuv(12)
      equivalence(store,istore)
c--
      nfl=nfls
      in=19
      call xcln(in)
      n19p=20
      l=nfl+n19p-1
      do 1000 i=nfl+5,l
1000  store(i)=0.0
      store(nfl+5)=patom
      store(nfl+6)=qatom
      m=nfl+7
      do 2000 i=1,12
      store(m)=lpseuv(i)
2000  m=m+1
      call sfrml(in,n19p)
      return
      end
c
code for sfl19
      subroutine sfl19(lpseuv,patom,qatom)
c--read absolute list 19  (information for pseudo-symmetry)
c
      common/xlimi/nfl,lfl,nl,nflmx,lflmx,nlmx,nfls
      common/data/store(5000)
      dimension  istore(5000),lpseuv(12)
      equivalence (istore,store)
c--
      nfl=nfls
      in=19
      call srlin(in,lsn,li,lj,lk,ll)
      if(li.le.0) return
      call sldl(in,ly,li,lz)
      l19d=nfl
      patom=store(l19d+5)
      qatom=store(l19d+6)
      m=l19d+7
      do 2000 i=1,12
      lpseuv(i)=store(m)
2000  m=m+1
      return
      end
c
code for frmxx
      subroutine frmxx(ixx,iln,nxx,nxxa,nxxd,nxxe,icod,ivet)
c--form list xx (relationships)
c
c  ixx =  0  rewrite completely the list number iln
c      = -1  rewrite the preamble of the list number iln
c  iln =  list number
c          8   positive triplets
c          9   psi zero
c         10   negative triplets
c         11   enantiomorphous triplets
c         24   psi-e triplets
c         20   negative quartets
c         21   enantiomorphous quartets
c         26   one phase seminvariants
c         27   two phases seminvariants
c  nxx =  number of relationships to be stored on disc
c  nxxa=  number of relationships to be regarded
c         ( usually  nxx = nxxa  except positive triplets for p10)
c  nxxd=  value to be stored on the preamble
c  nxxe=  value to be stored on the preamble
c  icod=  value to be stored on the preamble
c  ivet=  array containing the relationships
c
      common/unit/lxn,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/xlimi/nfl,lfl,nl,idummy(3),nfls
      common /data/ store(5000)
      dimension istore(5000)
      equivalence(store,istore)
      dimension ivet(60000)
c--
      if(iln.gt.31.or.iln.lt.1) goto 1
c           1  2  3  4  5  6  7  8  9 10
c          11 12 13 14 15 16 17 18 19 20
c          21 22 23 24 25 26 27
      goto( 1, 1, 1, 1, 1, 1, 1, 8, 9, 8,
     *      8, 8, 1, 1, 1, 1, 1, 1, 1,20,
     *     20, 1, 1, 8, 1,26, 8, 1, 1, 1 ),iln
1     write(lo,1001) iln
1001  format(///,i7,25h is not a valid list type)
      stop  1111
8     mdxx=3
      mdxxc=3
      goto 1000
9     mdxx=2
      mdxxc=3
      goto 1000
20    mdxx=3
      mdxxc=7
      goto 1000
26    mdxx=1
      mdxxc=1
1000  nfl=nfls
      call xcln(iln)
      nxxp=19
      l=nfl+nxxp-1
      do 1010 i=nfl+5,l
1010  store(i)=0.0
      store(nfl+5)=mdxx
      store(nfl+6)=mdxxc
      store(nfl+7)=nxxp
      store(nfl+8)=nxx
      store(nfl+9)=nxxa
      store(nfl+10)=nxxd
      store(nfl+11)=nxxe
      store(nfl+12)=icod
      ln=nxxp+(nxx+1)*mdxx
      call sowl(ln,iln,lsn,ldxxp,lk,lm,lj)
      store(nfl+2)=lsn
      call xup(ldxxp,istore,nxxp)
      llw=ldxxp+ln-1
      call swlin(iln,lsn,ldxxp,llw,nxxp,ln)
      if(ixx.lt.0) return
      lxx=ldxxp+nxxp
      lxxdk=nfl+nxxp
      nfl=lxxdk+mdxx
      l=1
      do 2000 i=1,nxx
      m=l
      mxxdk=lxxdk
      do 2100 j=1,mdxx
      istore(mxxdk)=ivet(m)
      m=m+1
2100  mxxdk=mxxdk+1
      call xup(lxx,istore(lxxdk),mdxx)
      lxx=lxx+mdxx
      l=l+mdxxc
2000  continue
      call xdump
      return
      end
c
code for sflxx
      subroutine sflxx(ixx,iln,nxx,nxxa,nxxd,nxxe,icod,ivet)
c--load  list xx  (relationships)
c  ixx =  0  load completely the list number iln
c      = -1  load the preamble of the list number iln
c
      common/unit/lxn,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/xlimi/nfl,lfl,idummy(4),nfls
      common/data/store(5000)
      dimension  istore(5000)
      equivalence (istore,store)
      dimension ivet(60000)
c--
      nfl=nfls
      call srlin(iln,li,ldxxp,lk,ln,lm)
      nxxp=ln
      call srdls(iln,l,nfl,lj)
      mdxx= store(nfl+5)
      mdxxc=store(nfl+6)
      nxxp= store(nfl+7)
      nxx = store(nfl+8)
      nxxa= store(nfl+9)
      nxxd= store(nfl+10)
      nxxe= store(nfl+11)
      icod= store(nfl+12)
      if(ixx.lt.0) return
      lxx  =ldxxp+nxxp
      lxxdk=nfl+nxxp
      nfl=lxxdk+mdxx
      l=1
      do 2000 i=1,nxx
      call xdwn(lxx,istore(lxxdk),mdxx)
      lxx=lxx+mdxx
      m=l
      mxxdk=lxxdk
      do 2100 j=1,mdxx
      ivet(m)=istore(mxxdk)
      m=m+1
2100  mxxdk=mxxdk+1
      l=l+mdxxc
2000  continue
      return
      end
c
code for nfrm16
      subroutine nfrm16(nset)
c--form an empty list 16, set(s) of phases
c
      common /param/ numb,dum(10)
      common/lst016/l16,ld16p,m16,m16d,md16d,n16,n16p,l16p
     1 ,l16a,l16k,n16k,dumm
      common/xlimi/nfl,lfl,nl,idummy(3),nfls
      common /data/ store(5000)
      dimension istore(5000)
      equivalence(store,istore)
c
      nfl=nfls
      in=16
      call xcln(in)
      l16p=nfl
      md16d=11
      m16d=1
      n16r=15
      n16p=n16r+nset*2
      lj=nfl+n16p-1
      do 1000 i=nfl+5,lj
1000  store(i)=0.0
      store(nfl+5)= md16d
      store(nfl+6)= m16d
      store(nfl+7)= numb
      store(nfl+8)= n16r
      store(nfl+9)= n16p
      store(nfl+10)=nset
      m=n16r+nfl
      do 1010 i=1,nset
      store(m)=0.0
1010  m=m+1
      do 1020 i=1,nset
      istore(m)=0
1020  m=m+1
      n16k=numb*m16d+md16d
      ln=n16p+n16k*nset
      call sowl(ln,in,lsn,ld16p,lk,lm,lj)
      store(nfl+2)=lsn
      call xup(ld16p,istore(l16p),n16p)
      llw=ld16p+ln-1
      call swlin(16,lsn,ld16p,llw,n16p,ln)
      l16=ld16p+n16p
      l16a=nfl+n16p
      l16k=l16a+md16d
      l16b=l16k+numb
      l16c=l16b+numb
      do 3000 k=1,nset
      m16k=l16k
      m16b=l16b
      m16c=l16c
      do 2000 i=1,numb
      istore(m16k  )=0
      m16k=m16k+1
      m16b=m16b+1
      m16c=m16c+1
2000  continue
      call xup(l16,istore(l16a),n16k)
      l16=l16+n16k
3000  continue
      call xdump
      return
      end
c
code for ysfl16
      subroutine ysfl16(cfom,ipos,nset)
c--sir-call for loading list 16 (set of phases)
c
      common/xlimi/ nfl,idummy(5),nfls
      dimension cfom(302),ipos(302)
c--
      nfl=nfls
      call sfl16(cfom,ipos,nset)
      return
      end
c
code for sfl16
      subroutine sfl16(cfom,ipos,nset)
c--load list 16 (set of phases)
c
      common/lst016/l16,ld16p,m16,m16d,md16d,n16,n16p,l16p
     1 ,l16a,l16k,n16k,numb
      common/xlimi/ nfl,idummy(5),nfls
      common /data/ store(5000)
      dimension  istore(5000)
      equivalence(store,istore)
      dimension cfom(302),ipos(302)
c--load the preamble of list 16
      inm=16
      call srlin(inm,li,ld16p,lk,ln,lm)
      n16p=ln
      l16p=nfl
      call srdls(inm,l,l16p,lj)
      md16d= store(l16p+5)
      m16d = store(l16p+6)
      numb = store(l16p+7)
      n16r = store(l16p+8)
      n16p = store(l16p+9)
      nset = store(l16p+10)
      m=n16r+l16p
      do 1010 i=1,nset
      cfom(i)=store(m)
1010  m=m+1
      do 1020 i=1,nset
      ipos(i)=istore(m)
1020  m=m+1
      n16k=numb*m16d+md16d
      l16    =ld16p+n16p
      l16a=l16p+n16p
      l16k=l16a+md16d
      return
      end
c
code for snr16
      subroutine snr16(it,fig,ww,iph)
c--read the required it-th set of phases
c
      common/lst016/l16,ld16p,m16,m16d,md16d,n16,n16p,l16p
     1 ,l16a,l16k,n16k,numb
      common/xlimi/ nfl,idummy(6)
      common /data/ store(5000)
      dimension  istore(5000)
      equivalence(store,istore)
      dimension ww(numb),iph(numb),fig(md16d)
c--
      l16d=l16+(it-1)*n16k
      call xdwn(l16d,istore(l16a),n16k)
c--unpack the values
      m=l16a
      do 1000 i=1,md16d
      fig(i)=store(m)
1000  m=m+1
      m16k=l16k
      do 2000 i=1,numb
      idum=istore(m16k)/512
      idum1=istore(m16k)-idum*512
      ww(i)=float(idum)/1000000.
      iph(i)=idum1
      m16k=m16k+1
2000  continue
      return
      end
c
code for snw16
      subroutine snw16(it,fig,ww,iph)
c--write the it-th set of phases
c
      common/lst016/l16,ld16p,m16,m16d,md16d,n16,n16p,l16p
     1 ,l16a,l16k,n16k,numb
      common/xlimi/ nfl,idummy(6)
      common /data/ store(5000)
      dimension  istore(5000)
      equivalence(store,istore)
      dimension ww(numb),iph(numb),fig(md16d)
c--
      l16d=l16+(it-1)*n16k
c-- pack the values
      m=l16a
      do 1000 i=1,md16d
      store(m)=fig(i)
1000  m=m+1
      m16k=l16k
      do 2000 i=1,numb
      if(ww(i).gt.1.0) ww(i)=1.0
      dum =ww(i)*1000000
      idum=nint(dum)
      istore(m16k  )=iph(i)+idum*512
      m16k=m16k+1
2000  continue
      call xup(l16d,istore(l16a),n16k)
      call xdump
      return
      end
c
code for ysup16
      subroutine ysup16(cfom,ipos,noset)
c--sir-call to update the preamble block of list 16
c
      common/xlimi/nfl,lfl,idummy(4),nfls
      dimension cfom(302),ipos(302)
c--
      nfl=nfls
      call sup16(cfom,ipos,noset)
      return
      end
c
code for sup16
      subroutine sup16(cfom,ipos,noset)
c--update the preamble block of list 16
c
      common/lst016/l16,ld16p,m16,m16d,md16d,n16,n16p,l16p
     1 ,l16a,l16k,n16k,numb
      common/xlimi/nfl,lfl,idummy(4),nfls
      common/data/store(5000)
      dimension  istore(5000)
      equivalence(istore,store)
      dimension cfom(302),ipos(302)
c--
      l16p=nfl
      call srdls(16,li,l16p,l)
      n16r = store(l16p+8)
      n16p = store(l16p+9)
      nset = store(l16p+10)
      if (noset.le.nset) then
                           nset=noset
                           store(l16p+10) = nset
                         endif
      m=n16r+nfl
      do 1010 i=1,nset
      store(m)=cfom(i)
1010  m=m+1
      do 1020 i=1,nset
      istore(m)=ipos(i)
1020  m=m+1
      l=n16p
      call srlin(16,lsn,ln,llw,l,ll)
      call xup(ln,istore(l16p),n16p)
      call xdump
      return
      end
c
code for ysfp07
      subroutine ysfp07(nrifl,npseud,iy)
c--form preamble of the  list 7
c
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/rc/p(6),cx(9),nref,nb,rhomax,mm,en,mz,er,th,rhomin
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
      common/c/flgw(30),flgd(30),avr(30),dcv(50),slope,flgk,bt,sc,del,ks
      common/lst07/l7,l7a,l7d,ld7p,m7,m7dk,n7dk,md7d,n7d,n7,n7p,
     2 l7rs,l7rk,l7in,l7p,kk1,kk2,kk3
c
      common/xlimi/nfl,lfl,nl,idummy(3),nfls
      common /xfile/ ifile,ilist,iend,infle,nwfle,icfle,lid(4)
      common /data/ store(5000)
      dimension istore(5000)
      equivalence(store,istore)
      kk3=128
      kk2=128*kk3
      kk1=128*kk2
      nfl=nfls
      in=7
      call xcln(in)
      l7p=nfl
      md7d=7
      n7dk=6
      nref=nrifl
      n7p=30
      lj=nfl+n7p-1
      do 1000 i=nfl+5,lj
1000  store(i)=0.0
      store(nfl+5)= md7d
      store(nfl+6)= n7dk
      store(nfl+7)= nrifl
      store(nfl+9)= n7p
      store(nfl+10)=ihx(1)
      store(nfl+11)=ihx(2)
      store(nfl+12)=ihx(3)
      store(nfl+15)=float(jpart)
      store(nfl+16)=float(knw)
      store(nfl+17)=bt
      store(nfl+18)=sc
      store(l7p+19)=mm
      store(l7p+20)=mz
      store(l7p+21)=s3s2
      store(l7p+22)=s3s2p
      store(l7p+23)=jtran
      store(l7p+24)=float(npseud)
      istore(l7p+25)=iy
      store(l7p+26)=fosog
      istore(l7p+27)=ksigma
      ln=n7p+(nref+1)*n7dk
      call sowl(ln,in,lsn,ld7p,lk,lm,lj)
      store(nfl+2)=lsn
      call xup(ld7p,istore(l7p),n7p)
      llw=ld7p+ln-1
      call swlin(7,lsn,ld7p,llw,n7p,ln)
      call xdump
      return
      end
code for xslw07
      subroutine xslw07(vett)
c--store the last reflection on the disc
c
      common/lst07/l7,l7a,l7d,ld7p,m7,m7dk,n7dk,md7d,n7d,n7,n7p,
     2 l7rs,l7rk,l7in,l7p,kk1,kk2,kk3
      common /data/ store(5000)
      dimension  istore(5000)
      equivalence(store,istore)
      dimension vet(6),ivet(6),vett(6)
      equivalence (vet,ivet)
c
      do 100 i=1,6
  100 vet(i)=vett(i)
      istore(m7dk  )=ivet(1)
       store(m7dk+1)= vet(2)
       store(m7dk+2)= vet(3)
       store(m7dk+3)= vet(4)
      istore(m7dk+4)=ivet(5)
       store(m7dk+5)= vet(6)
      call xup(l7,istore(m7dk),n7dk)
      l7=l7+n7dk
      return
      end
code for frm15
      subroutine frm15(nats,numset,interp)
c--form list 15, coordinates of the fragments
c
c   nats = number of coordinates
c   numset = number of set
c   interp = 0 if no interpretation of peaks has been performed
c          = 1 if    interpretation of peaks has been performed
c   x       = x y z int occ
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common /atoms/ x(5,200),icvet(200),ngp,ninf(10),nag(10)
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common/xchar/id,ie,ib,ic,ia,ih
     1 ,numb(10),iplus, inus,ipoint
      common/xlimi/nfl,lfl,nl,idummy(3),nfls
      common /data/ store(5000)
      common /temp/ conn(9800)
      dimension istore(5000)
      equivalence(store,istore)
c--
      nfl=nfls
      call xcln(15)
Corig md15=8
      md15=9
      mm=15
c
       store(nfl+ 5) = mm
       store(nfl+ 6) = md15
       store(nfl+ 7) = nats
       store(nfl+ 8) = numset
       store(nfl+ 9) = interp
       store(nfl+10) = errem
      istore(nfl+11) = maxcyc
      istore(nfl+12) = jrest
       store(nfl+13) = biso
       store(nfl+14) = oscale
      l15=nfl+mm
      m15=l15
      do 2000 i=1,nats
      icv=icvet(i)
      kfrag=0
      if (icv.lt.0) then
                      icv=iabs(icv)
                      kfrag=0
                    else
                      kfrag=mod(icv,100)
                    endif
      iz=icv/100
      istore(m15  )=iz
      istore(m15+1)=i
      istore(m15+2)=kfrag
       store(m15+3)=x(1,i)
       store(m15+4)=x(2,i)
       store(m15+5)=x(3,i)
       store(m15+6)=x(4,i)
       store(m15+7)=x(5,i)
       store(m15+8)=bfac(i)
      m15=m15+md15
 2000 continue
c
c-- connectivity
c
      if (interp.eq.1) then
                         nconn=conn(1)
                         store(m15)=-1.0
                         do 2100 i=1,nconn*2+1
                         store(m15)=conn(i)
                         m15=m15+1
 2100                    continue
                       endif
c
      n=5000
c
      iln=15
      call sfrml(iln,n)
      call xdump
      return
      end
c
code for sfl15
      subroutine sfl15(nats,idisp,numset,interp)
c--read absolute list 15  (coordinates of the fragments)
c
c   nats = number of coordinates
c   numset = number of set
c   interp = 0 if no interpretation of peaks has been performed
c          = 1 if    interpretation of peaks has been performed
c  idisp = starting position in x and nz array
c
c
c
c
      common/sf/al(4,8),bs(4,8),cl(8),nnw(8),nno(8),nk,nat,f(9),nalf(8)
c
c
c
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common /atoms/ x(5,200),icvet(200),ngp,ninf(10),nag(10)
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common/xlimi/nfl,lfl,nl,idummy(3),nfls
      common/data/store(5000)
      common /temp/ conn(9800)
      dimension  istore(5000)
      equivalence (istore,store)
c--
      call srlin(15,lsn,li,lj,lk,ll)
      nfl=nfls
      call sldl(15,li,l15d,lj)
      mm     =  store(l15d+ 5)
      md15   =  store(l15d+ 6)
      nats   =  store(l15d+ 7)
      numset =  store(l15d+ 8)
      interp =  store(l15d+ 9)
      errem  =  store(l15d+10)
      maxcyc = istore(l15d+11)
      jrest  = istore(l15d+12)
      biso   =  store(l15d+13)
      oscale =  store(l15d+14)
      l15=l15d+mm
      m15=l15
      if (idisp.lt.1.or.idisp.gt.200) idisp=1
      k=idisp
      do 2000 i=1,nats
      iz     =istore(m15  )
      kfrag  =istore(m15+2)
      icv=iz*100+kfrag
      if (kfrag.eq.0.and.iz.gt.0) icv=-icv
      icvet(k)=icv
      x(1,k) = store(m15+3)
      x(2,k) = store(m15+4)
      x(3,k) = store(m15+5)
      x(4,k) = store(m15+6)
      x(5,k) = store(m15+7)
      bfac(k)= store(m15+8)
      k=k+1
      m15=m15+md15
2000  continue
c
c-- connectivity
c
      if (interp.eq.1) then
                         nconn=store(m15)
                         do 2100 i=1,nconn*2+1
                         conn(i)=store(m15)
                         m15=m15+1
 2100                    continue
                       endif
c
      return
      end
c
code for cp1530
      subroutine cp1530
c
c--save list 15 in list 30
c
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common /atoms/ x(5,200),icvet(200),ngp,ninf(10),nag(10)
      common/xlimi/nfl,lfl,nl,idummy(3),nfls
      common/data/store(5000)
      dimension  istore(5000)
      equivalence (istore,store)
c--
      nfl=nfls
      call srlin(15,lsn,li,lj,lk,ll)
      call sldl(15,li,l15d,lj)
      mm  =store(l15d+5)
      md15=store(l15d+6)
      nats=store(l15d+7)
      numset=store(l15d+8)
      interp=store(l15d+9)
c
      n=5000
      iln=30
      store(l15d+1) = iln
c
      call sfrml(iln,n)
      call xdump
      return
      end
c
code for cp3015
      subroutine cp3015
c
c--restore list 30 in list 15
c
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common /atoms/ x(5,200),icvet(200),ngp,ninf(10),nag(10)
      common/xlimi/nfl,lfl,nl,idummy(3),nfls
      common/data/store(5000)
      dimension  istore(5000)
      equivalence (istore,store)
c--
      nfl=nfls
      call srlin(30,lsn,li,lj,lk,ll)
      call sldl(30,li,l15d,lj)
      mm  =store(l15d+5)
      md15=store(l15d+6)
      nats=store(l15d+7)
      numset=store(l15d+8)
      interp=store(l15d+9)
c
      n=5000
      iln=15
      store(l15d+1) = iln
c
      call sfrml(iln,n)
      call xdump
      return
      end
c
code for sfl30
      subroutine sfl30(nats,idisp,numset,interp)
c--read absolute list 30  (copy of list 15)
c
c   nats = number of coordinates
c   numset = number of set
c   interp = 0 if no interpretation of peaks has been performed
c          = 1 if    interpretation of peaks has been performed
c  idisp = starting position in x and nz array
c
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common /atomo/ x(5,200),icvet(200),dold(400)
      common/xlimi/nfl,lfl,nl,idummy(3),nfls
      common/data/store(5000)
      dimension  istore(5000)
      equivalence (istore,store)
c--
***** nfls=nfl
      call srlin(30,lsn,li,lj,lk,ll)
      nfl=nfls
      call sldl(30,li,l15d,lj)
      mm  =store(l15d+5)
      md15=store(l15d+6)
      nats=store(l15d+7)
      numset=store(l15d+8)
      interp=store(l15d+9)
      l15=l15d+mm
      m15=l15
      if (idisp.lt.1.or.idisp.gt.200) idisp=1
      k=idisp
      do 2000 i=1,nats
      iz     =istore(m15  )
      kfrag  =istore(m15+2)
      icv=iz*100+kfrag
      if (kfrag.eq.0.and.iz.gt.0) icv=-icv
      icvet(k)=icv
      x(1,k) = store(m15+3)
      x(2,k) = store(m15+4)
      x(3,k) = store(m15+5)
      x(4,k) = store(m15+6)
      x(5,k) = store(m15+7)
      k=k+1
      m15=m15+md15
2000  continue
      return
      end
CRYSTALS CODE FOR MOLPLO94
      SUBROUTINE MOLPLO(iPlT)
C
C                --------     MOLPLO    ----------
C
      IMPLICIT REAL *4 (M)
      CHARACTER *1 Lett
      CHARACTER *5 Lab
      CHARACTER *80 Titolo
C
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      COMMON /Leg1/ LE1(800,2),nLegInd
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /work/ rm(3,3), eval(3), evec(3,3), ainer(3,3)
      COMMON /Contr/ NF,iFirstTime,Titolo,Ratio,IfCont,IfEdge,IfScale,
     *               kplty,radii(8), IfScaleB
      common /screen/ kscreen,iy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      common /temp/ conn(9800)
      DIMENSION B(3, 3)
c
      call xspinb
c
      loop=0
      kcont=0
      CheScale = 1
      LegCol = 2
      NF=0
      iFirstTime = 1
      PI = 4 * ATAN(1.)
      iPlType=iPlT
      if (iPlType.eq.3) then
         iPlType=2
         iFirstTime = 0
      endif
      if (mod(kprog,10).eq.2) iPlType=2
      kplty=iPlType
c
c     il punto (Lim1,Lim2) e' il punto in alto a sinistra del viewport grafico
c     mentre (Lim3,Lim4) e' quello in basso a destra
c     i valori attuali sono per una VGA
c
      Lim1 = 0
Corig Lim2 = 40
      Lim2 = 0
      Lim3 = kscrx
      Lim4 = kscry
      Ratio = float(Lim3 - 80) / float(Lim4 - 20)
      NPX = Lim3 - Lim1
      NPY = Lim4 - Lim2
c
    8 Call Orto
      ind=8
      call defswi
c
      IfLeg = conn(1)
c
      if (IfLeg .eq.-1) then
         call BuildBonds(1)
      else
         call GetBonds(1)
      end if
c
   15 continue
      Rmin1 = 99999.
      Rmin2 = 99999.
      RMAX1 = -99999.
      RMAX2 = -99999.
c
      if (loop.eq.0) then
         iPlotType = iPlType
      else
         iPlotType = kplty
      endif
      CALL FindOr(B)
      CALL NewPage
      CALL MMenu(B,loop)
      if (loop.eq.1) go to 15
      if (loop.eq.2) go to 8
c
      return
      END
C ---------------------------------------------------------------------
      SUBROUTINE GetBonds(iAction)
 
      IMPLICIT REAL *4 (M)
      CHARACTER *1 Lett
      CHARACTER *5 Lab
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      COMMON /Leg1/ LE1(800,2),nLegInd
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /work/ rm(3,3), eval(3), evec(3,3), ainer(3,3)
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      common /temp/ conn(9800)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
 
      lsq = 1
      VMod  = evec(1,lsq)**2 + evec(2,lsq)**2
      V1Mod = sqrt(VMod + evec(3,lsq)**2)
      VMod  = sqrt(VMod) / V1Mod
      if ( VMod .gt.  1.0 ) VMod = 1.0
      if ( VMod .lt. -1.0 ) VMod =-1.0
      Ang   = asin(VMod) * 180./ PI
c     Ang   = Ang + 0.5
      Ang   = SIGN(Ang, evec(3,lsq))
      RK(1) = Ang
      RK(2) = 4
      RK(3) = 1
      VV(1, 1) = evec(2,lsq)
      VV(1, 2) = -evec(1,lsq)
      VV(1, 3) = 0
      MaxLu = 2.05
      iColDef = 4
      Radius = .22
      DO 10 i = 1 , NAT + nv
         iOrd(i) = i
         if (iCol(i) .eq. 0) iCol(i) = iColDef
         if (abs(RS(i)) .lt. 0.00001) RS(i) = Radius
   10 CONTINUE
c
      if (iAction .eq.2) return
c
c ----  costruisci la tabella dei legami
c
      NumLeg = conn(1)
      j = 0
      DO 40 i = 1 , NumLeg
         i1 = i * 2
         i2 = i * 2 + 1
         n1 = conn(i1)
         n2 = conn(i2)
         if (nz(n1).ne.0.and.nz(n2).ne.0) then
             j = j + 1
             LE(j, 1) = conn(i1)
             LE(j, 2) = conn(i2)
         endif
         if (j .eq. nMaxLeg - nlp) goto 50
   40 CONTINUE
   50 NumLeg = j
c
      do 60 i = nMaxLeg - nlp + 1, nMaxLeg
         NumLeg = NumLeg + 1
         LE(NumLeg, 1) = LE(i, 1)
         LE(NumLeg, 2) = LE(i, 2)
   60 continue
c
      do 70 i = 1, NumLeg
         LE1(i, 1) = LE(i, 1)
         LE1(i, 2) = LE(i, 2)
   70 continue
      nLegInd = NumLeg
c
      return
      end
C ---------------------------------------------------------------------
      SUBROUTINE BuildBonds(iAction)
 
      IMPLICIT REAL *4 (M)
      REAL *4  LuLe,LuLeg
      CHARACTER *1 Lett
      CHARACTER *5 Lab
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      COMMON /Leg1/ LE1(800,2),nLegInd
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /work/ rm(3,3), eval(3), evec(3,3), ainer(3,3)
      common /temp/ conn(9800)
 
      lsq = 1
      VMod  = evec(1,lsq)**2 + evec(2,lsq)**2
      V1Mod = sqrt(VMod + evec(3,lsq)**2)
      VMod  = sqrt(VMod) / V1Mod
      if ( VMod .gt.  1.0 ) VMod = 1.0
      if ( VMod .lt. -1.0 ) VMod =-1.0
      Ang   = asin(VMod) * 180./ PI
c     Ang   = Ang + 0.5
      Ang   = SIGN(Ang, evec(3,lsq))
      RK(1) = Ang
      RK(2) = 4
      RK(3) = 1
      VV(1, 1) = evec(2,lsq)
      VV(1, 2) = -evec(1,lsq)
      VV(1, 3) = 0
      MaxLu = 2.05
      iColDef = 4
      Radius = .22
      DO 10 i = 1 , NAT + nv
         iOrd(i) = i
         if (iCol(i) .eq. 0) iCol(i) = iColDef
         if (abs(RS(i)) .lt. 0.00001) RS(i) = Radius
   10 CONTINUE
c
c ----  costruisci la tabella dei legami
c
      NumLeg = 0
      DO 40 i = 1 , NAT - 1
         if (Lab(i)(1:1).eq.'Q') go to 40
         iP1 = i + 1
         DO 30 j = iP1 , NAT
            if (Lab(j)(1:1).eq.'Q') go to 30
            IF (MLU(i) .lt. 0.00001) THEN
               LuLeg = MaxLu
            ELSE
               LuLeg = MLU(i)
            END IF
            DIS = 0
            DO 20 K = 1 , 3
               RAI = xyz(K,i)
               RAJ = xyz(K,j)
               DIS = DIS + (RAI - RAJ) ** 2
   20       CONTINUE
            DIS = SQRT(DIS)
            IF (MLU(j) .lt. 0.00001) THEN
               LuLe = MaxLu
            ELSE
               LuLe = MLU(j)
            END IF
            IF (LuLeg.LT.LuLe) LuLeg = LuLe
            IF (DIS.LE.LuLeg) THEN
               NumLeg = NumLeg + 1
               LE(NumLeg, 1) = i
               LE(NumLeg, 2) = j
            END IF
            IF (NumLeg .EQ. nMaxLeg - nlp) return
   30    CONTINUE
   40 CONTINUE
c
      do 60 i = nMaxLeg - nlp + 1, nMaxLeg
         NumLeg = NumLeg + 1
         LE(NumLeg, 1) = LE(i, 1)
         LE(NumLeg, 2) = LE(i, 2)
   60 continue
c
      if (iAction .eq. 1) then
         do 70 i = 1, NumLeg
            LE1(i, 1) = LE(i, 1)
            LE1(i, 2) = LE(i, 2)
   70    continue
         nLegInd = NumLeg
      end if
c
      return
      end
C ---------------------------------------------------------------------
      BLOCK DATA
      IMPLICIT REAL *4 (M)
      CHARACTER *1 Lett
      CHARACTER *5 Lab
c
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
c
Caratteri
      DATA ((iBarre(i,j),j=1, 4),i=1, 62)
     */ 0,4,4,4,  0,2,4,2,  0,0,4,0,  0,4,0,2,  4,4,4,2,
     *  0,2,0,0,  4,2,4,0,  0,4,0,0,  4,4,4,0,  2,4,2,0,
     *  0,4,2,0,  2,0,4,4,  0,4,4,0,  0,0,4,4,  2,2,4,0,
     *  0,4,5,4,  3,4,3,0,  5,4,5,0,  0,2,4,4,  0,3,4,0,
     *  0,4,2,2,  2,2,4,4,  0,0,0,2,  0,4,2,4,  2,4,4,2,
     *  3,4,3,2,  0,0,2,0,  2,0,4,2,  2,2,4,0,
     *  0,4,2,4,  0,3,2,3,  0,2,2,2,  0,1,2,1,  0,0,2,0,
     *  0,4,0,0,  2,4,2,0,  0,4,0,2,  0,2,0,0,  2,4,2,2,
     *  2,2,2,0,  0,3,0,0,  2,3,2,0,  0,4,0,1,  2,4,2,1,
     *  2,3,2,2,  0,1,0,0,  0,3,1,0,  1,0,2,3,  2,2,0,0,
     *  0,2,2,0,  0,3,0,1,  2,3,2,-2, 0,-2,2,-2,  0,2,1,2,
     *  4,3,4,0,  2,3,4,3,  0,3,0,-2, 0,0,0,0,  0,4,0,4,
     *  1,0,3,0,  1,3,2,4,  1,4,2,4/
c
      DATA Lett
     */' ','A','B','C','D','E','F','G','H','I','J','K','L','M',
     * 'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
     * 'a','b','c','d','e','f','g','h','i','j','k','l','m',
     * 'n','o','p','q','r','s','t','u','v','w','x','y','z','/',
     * '''','-','+','.',':','?',
     * '0','1','2','3','4','5','6','7','8','9',' ',' '/
c
      DATA (NumBar(i),(iCheBarre(i,j),j = 1 , 6),i = 1, 36)
     */0, 0, 0, 0, 0, 0, 0,  4, 1, 2, 8, 9, 0, 0,  6, 8, 2, 7, 3,24,26,
     * 3, 1, 8, 3, 0, 0, 0,  5, 8, 3,24,25, 7, 0,  4, 8, 1, 2, 3, 0, 0,
     * 3, 8, 1, 2, 0, 0, 0,  4, 1, 8, 3, 7, 0, 0,  3, 8, 2, 9, 0, 0, 0,
     * 1, 8, 0, 0, 0, 0, 0,  3, 9, 3,23, 0, 0, 0,  3, 8,19,20, 0, 0, 0,
     * 2, 8, 3, 0, 0, 0, 0,  4, 8,21,22, 9, 0, 0,  3, 8,13, 9, 0, 0, 0,
     * 4, 1, 8, 3, 9, 0, 0,  4, 8, 1, 2, 5, 0, 0,  6, 8, 1, 5,27,28,29,
     * 5, 8, 1, 2, 5,15, 0,  5, 1, 2, 3, 4, 7, 0,  2, 1,10, 0, 0, 0, 0,
     * 3, 8, 3, 9, 0, 0, 0,  2,11,12, 0, 0, 0, 0,  4, 8,10, 9, 3, 0, 0,
     * 2,13,14, 0, 0, 0, 0,  4, 4, 2, 9, 3, 0, 0,  3, 1,14, 3, 0, 0, 0,
     * 5,31,42,33,46,34, 0,  4,35,32,40,34, 0, 0,  3,31,41,34, 0, 0, 0,
     * 4,32,38,34,36, 0, 0,  5,31,41,32,45,34, 0,  3,30,35,54, 0, 0, 0,
     * 5,31,34,51,52,53, 0,  3,35,32,40, 0, 0, 0,  2,38,59, 0, 0, 0, 0/
      DATA (NumBar(i),(iCheBarre(i,j),j = 1 , 6),i = 37, 70)
     */2,52,53, 0, 0, 0, 0,  3,35,49,50, 0, 0, 0,  3,10,60,62, 0, 0, 0,
     * 5,31,56,41,42,55, 0,  3,31,41,42, 0, 0, 0,  4,31,41,34,42, 0, 0,
     * 4,57,31,42,34, 0, 0,  4,31,34,41,52, 0, 0,  2,31,41, 0, 0, 0, 0,
     * 5,30,37,32,40,34, 0,  3,35,31,34, 0, 0, 0,  3,41,34,42, 0, 0, 0,
     * 2,47,48, 0, 0, 0, 0,  4,41,42,55, 3, 0, 0,  2,49,50, 0, 0, 0, 0,
     * 4,41,34,52,53, 0, 0,  3,31,49,34, 0, 0, 0,  1,14, 0, 0, 0, 0, 0,
     * 1, 4, 0, 0, 0, 0, 0,  1, 2, 0, 0, 0, 0, 0,  2, 2,10, 0, 0, 0, 0,
     * 1,58, 0, 0, 0, 0, 0,  2,58,59, 0, 0, 0, 0,  4,30,39,32,38, 0, 0,
     * 4, 1, 3, 8, 9, 0, 0,  3,10,60,61, 0, 0, 0,  5, 1, 5, 2, 6, 3, 0,
     * 4, 1, 2, 3, 9, 0, 0,  3, 4, 2, 9, 0, 0, 0,  5, 1, 4, 2, 7, 3, 0,
     * 5, 1, 8, 3, 7, 2, 0,  2, 1, 9, 0, 0, 0, 0,  5, 1, 2, 3, 8, 9, 0,
     * 5, 1, 2, 3, 4, 9, 0/
c
      END
c ---------------------------------------------------------------
      SUBROUTINE Orto
      REAL *4 MLu
      CHARACTER *80 Titolo
      CHARACTER*5 Lab
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      common/work/rm(3,3), eval(3), evec(3,3), ainer(3,3)
      COMMON /Contr/ NF,iFirstTime,Titolo,Ratio,IfCont,IfEdge,IfScale,
     *               kplty,radii(8), IfScaleB
      dimension asta(3)
c
      pi=4*datan(1.d0)
      call tomolplo1(a,b,c,alf,bet,gam)
      alf=pi/180*alf
      bet=pi/180*bet
      gam=pi/180*gam
c ---------
c ---------  sgs =  coseno di gamma star
c ---------
      sgs=(cos(alf)*cos(bet)-cos(gam))/(sin(alf)*sin(bet))
c ---------
c ---------  gams =  gamma star
c ---------
 
      if ( sgs .gt.  1.0 ) sgs = 1.0
      if ( sgs .lt. -1.0 ) sgs =-1.0
      gams=acos(sgs)
      v=a*b*c
      v=v*sqrt(sin(alf)**2+sin(bet)**2+sin(gam)**2-2+
     *    2*cos(alf)*cos(bet)*cos(gam))
      astar=b*c*sin(alf)/v
      bstar=a*c*sin(bet)/v
      cstar=a*b*sin(gam)/v
      asta(1)=astar
      asta(2)=bstar
      asta(3)=cstar
      rm(1,1)=a*sin(bet)
      rm(1,2)=-b*sin(alf)*cos(gams)
      rm(1,3)=0
      rm(2,1)=0
      rm(2,2)=b*sin(alf)*sin(gams)
      rm(2,3)=0
      rm(3,1)=a*cos(bet)
      rm(3,2)=b*cos(alf)
      rm(3,3)=c
c     read(ic,*) NAT
      call tomolplo2
*      do 90 i = 1, NAT
*c                                                 max
*c                                                lung di  raggio  1-7
*c                                    label  xyz  legame  palla  colore
*         read(ic,'(a3,1x,5f10.0,i4)') Lab(i), x, MLu(i), RS(i), iCol(i)
*         call molt1(rm,x,r)
*         xyz(1,i) = r(1)
*         xyz(2,i) = r(2)
*         xyz(3,i) = r(3)
*90    continue
c
      call LsPlane(NATV)
c
      return
      end
c ---------------------------------------------------------------
      SUBROUTINE LsPlane(NATV)
c
c--main routine for l.s. plane calculation
c
      common/work/rm(3,3), eval(3), evec(3,3), ainer(3,3)
      dimension xbar(3)
c
c---- set normal equations matrix for the best plane
c
      call fillmatr(ainer, xbar, NATV)
c
      if (NATV.eq.0) then
          return
      end if
c
c--search for the eigenvalues and eigenvectors
c
      call autov(ainer,eval,evec,icod)
c
      do 50 i=1 , 2
         do 30 j= i+1 , 3
            if (eval(i) .gt. eval(j)) then
               Dum = eval(i)
               eval(i) = eval(j)
               eval(j) = Dum
               do 10 k=1 , 3
                  Dum = evec(k,i)
                  evec(k,i) = evec(k,j)
                  evec(k,j) = Dum
   10          continue
            endif
   30    continue
   50 continue
c
      return
      end
c ---------------------------------------------------------------
      SUBROUTINE fillmatr(tmab, bard, NATV)
      REAL *4 MLU
      CHARACTER *5 Lab
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      dimension tmab(3,3),bard(3),xd(3)
c
      do 130 i = 1 , 3
           bard(i) = 0.0
           do 100 j=1,3
               tmab(i,j) = 0.0
  100      continue
  130 continue
c ----
c ----   trova il baricentro deli atomi visibili
c ----
      NATV = 0
      do 150 i = 1 , NAT
          if (RS(i).gt.0) then
              NATV = NATV + 1
              bard(1) = bard(1) + xyz(1,i)
              bard(2) = bard(2) + xyz(2,i)
              bard(3) = bard(3) + xyz(3,i)
          end if
  150 continue
c
      if (NATV.eq.0) then
          return
      end if
      bard(1) = bard(1) / NATV
      bard(2) = bard(2) / NATV
      bard(3) = bard(3) / NATV
c ----
c ----    shift degli atomi per avere l'origine sul baricentro
c ----
      do 200 i = 1 , NAT + nv
          xyz(1,i) = xyz(1,i) - bard(1)
          xyz(2,i) = xyz(2,i) - bard(2)
          xyz(3,i) = xyz(3,i) - bard(3)
  200 continue
      do 500 i=1,NAT
          if (RS(i).gt.0) then
              xd(1) = xyz(1,i)
              xd(2) = xyz(2,i)
              xd(3) = xyz(3,i)
              do 400 k=1,3
                  do 300 l=1,3
                      tmab(k,l) =tmab(k,l)+xd(k)*xd(l)
  300             continue
  400         continue
          end if
  500 continue
c
      return
      end
c ------------------------------------------------------------------
      SUBROUTINE autov(a,eigen,t,icod)
      dimension t(3,3),a(3,3),aik(3),eigen(3)
c
      itmax=50
      n=3
      nm1=n-1
      eps1=.1e-10
      eps2=eps1
      eps3=.1e-7
      sigma1=0
      offdsq=0
      do 2 i=1,3
      do 2 j=1,3
    2 t(i,j)=0.
      do 5 i=1,n
      sigma1=sigma1+a(i,i)**2
      t(i,i)=1.0
      ip1=i+1
      if (i.ge.n) go to 6
                    do 5 j=ip1,n
   5                offdsq=offdsq+a(i,j)**2
   6  s=2.*offdsq+sigma1
c
c  inizio iter. jacobi
c
      do 26 iter=1,itmax
      do 20 i=1,nm1
      ip1=i+1
      do 20 j=ip1,n
      q=abs(a(i,i)-a(j,j))
      if(q.le.eps1) goto 9
      if(abs(a(i,j)).le.eps2) goto 20
      p=2.*a(i,j)*q/(a(i,i)-a(j,j))
      spq=sqrt(p*p+q*q)
      csa=sqrt((1.+q/spq)/2.)
      sna=p/(2.*csa*spq)
      goto 10
    9 csa=1./sqrt(2.d0)
      sna=csa
   10 continue
c
      do 11 k=1,n
      holdki=t(k,i)
      t(k,i)=holdki*csa+t(k,j)*sna
   11 t(k,j)=holdki*sna-t(k,j)*csa
c
      do 16 k=i,n
      if(k.gt.j) goto 15
      aik(k)=a(i,k)
      a(i,k)=csa*aik(k)+sna*a(k,j)
      if(k.ne.j) goto 14
      a(j,k)=sna*aik(k)-csa*a(j,k)
   14 goto 16
   15 holdik=a(i,k)
      a(i,k)=csa*holdik+sna*a(j,k)
      a(j,k)=sna*holdik-csa*a(j,k)
   16 continue
c
      aik(j)=sna*aik(i)-csa*aik(j)
c
      do 19 k=1,j
      if (k.le.i) then
                    holdki=a(k,i)
                    a(k,i)=csa*holdki+sna*a(k,j)
                    a(k,j)=sna*holdki-csa*a(k,j)
                  else
                    a(k,j)=sna*aik(k)-csa*a(k,j)
                  endif
   19 continue
   20 a(i,j)=0.0
c
      sigma2=0.0
      do 21 i=1,n
      eigen(i)=a(i,i)
   21 sigma2=sigma2+eigen(i)**2
      if (abs(sigma2).gt.0.00001) then
         if(1.0-sigma1/sigma2.ge.eps3) goto 25
      end if
      icod=1
      return
   25 continue
   26 sigma1=sigma2
      icod=0
c
      return
      end
c ------------------------------------------------------------------
      SUBROUTINE molt1(a,b,c)
      dimension a(3, 3), b(3), c(3)
c
      do 20 i=1,3
         c(i)=0
         do 10 j=1,3
            c(i)=c(i)+a(i,j)*b(j)
   10    continue
   20 continue
c
      return
      end
c --------------------------------------------------------------------
      SUBROUTINE FindOr(B)
      IMPLICIT REAL*4 (M)
      CHARACTER *1 Lett
      CHARACTER *5 Lab
c
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      DIMENSION B(3, 3), BOpt(3, 3)
c
      DO 20 j = 1 , 3
         DO 10 i = 1 , 3
            B(i, j) = 0
   10    CONTINUE
         B(j, j) = 1
   20 CONTINUE
c
      CALL CombRot(B)
*     CALL RotAtoms(B, 2)
      CALL RotAtoms(B, 1)
      CALL SetScale(4)
      SupMin = abs((RMAX1-Rmin1)/RS(1))
      DO 40 i = 1 , 3
         DO 30 j = 1 , 3
            BOpt(i, j) = 0
            B   (i, j) = 0
*           BOpt(i, j) = B(i, j)
   30    CONTINUE
         BOpt(i, i) = 1
         B   (i, i) = 1
   40 CONTINUE
      RK(1) = 0
      DO 90 NuR = 1 , 18
         RK(1) = RK(1) + 10
         RK(2) = 3
         DO 44 j = 1 , 3
            DO 42 i = 1 , 3
               B(i, j) = 0
   42       CONTINUE
            B(j, j) = 1
   44    CONTINUE
         CALL CombRot(B)
         Rmin1 = 99999.
         Rmin2 = 99999.
         RMAX1 = -99999.
         RMAX2 = -99999.
         CALL RotAtoms(B, 2)
         CALL SetScale(4)
         sca=abs((RMAX1-Rmin1)/RS(1))
         IF (sca .lt. SupMin) then
                                SupMin = sca
                                DO 80 i = 1 , 3
                                   DO 70 j = 1 , 3
                                      BOpt(i, j) = B(i, j)
   70                              CONTINUE
   80                           CONTINUE
                              END IF
   90 CONTINUE
      Rmin1 = 99999.
      Rmin2 = 99999.
      RMAX1 = -99999.
      RMAX2 = -99999.
      CALL RotAtoms(BOpt, 1)
c
      RETURN
      END
C -----------------------------------------------------------------
      SUBROUTINE Balls
      IMPLICIT REAL*4 (M)
      CHARACTER *1 Lett
      CHARACTER *5 Lab
      CHARACTER *80 Titolo
      INTEGER *4 CC,O1,O2,O3,O4,X11,Y11,R
c
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      COMMON /Contr/ NF,iFirstTime,Titolo,Ratio,IfCont,IfEdge,IfScale,
     *               kplty,radii(8), IfScaleB
      DIMENSION S(3)
c
      DO 20 i = 1 , (NAT + nv) - 1
         DO 10 K = i + 1 , NAT + nv
            O1 = iOrd(i)
            O2 = iOrd(K)
            O3 = xyz(3,O1)
            O4 = xyz(3,O2)
            IF (O3.GT.O4) THEN
               iOrd(i) = O2
               iOrd(K) = O1
            END IF
   10    CONTINUE
   20 CONTINUE
c
      CALL NewPage
c
      DDX = (XMax - Xmin) / NPX
      DDY = (YMax - Ymin) / NPY
      DO 50 III = 1 , NAT + nv
         IJ = iOrd(III)
         if (RS(IJ).LE.0.0) go to 50
c
c        if (IfEdge.eq.1 .OR. IJ.le.NAT) then
c           CALL DisePalle(IJ, X11, Y11, R, CC)
c        end if
c
      X11 = ipix(1,IJ)
      Y11 = ipix(2,IJ)
      RR(IJ) = RS(IJ)
      CC = ICol(IJ)
      R = ipix(3,IJ)
c      R = R+2
         DO 40 NLL = 1 , NumLeg
            N1 = LE(NLL, 1)
            if (IfEdge.eq.0 .AND. N1.gt.NAT) GOTO 40
            N2 = LE(NLL, 2)
            IF (N1.NE.IJ.AND.N2.NE.IJ) GOTO 40
            IF (N1 .LT. 0)  GOTO 40
            IF (RR(N1) .LE. 0 .OR. RR(N2) .LE. 0)  GOTO 40
 
            RAN1 = xyz(3,N1)
            RAN2 = xyz(3,N2)
            IF (RAN1.GT.RAN2) THEN
               NDUM = N1
               N1 = N2
               N2 = NDUM
            END IF
            DO 30 i = 1 , 3
               DU1 = xyz(i,N1)
               DU2 = xyz(i,N2)
               S(i) = DU1 - DU2
   30       CONTINUE
            SS = S(1) ** 2 + S(2) ** 2
            if (SS .LT. 0.001) goto 34
            SSS = SS + S(3) ** 2
            RL = SQRT(SSS)
            RL2 = SQRT(SS)
            RN21 = xyz(1,N2)
            RN22 = xyz(2,N2)
            RN11 = xyz(1,N1)
            RN12 = xyz(2,N1)
            S1 = S(1)
            S2 = S(2)
            RR1 = RR(N1)
            if ( N2 .gt. NAT ) then
                                 RR2 = RR(N2)
                               else
                                 RR2 = RR(N2) - 2 * DDX
                               endif
            p1 = S1 / RL2 * RR2 + RN21
            p2 = S2 / RL2 * RR2 + RN22
            p3 = -S1 / RL * RR1 + RN11
            p4 = -S2 / RL * RR1 + RN12
            P3RN = (p3 - RN21) ** 2
            P4RN = (p4 - RN22) ** 2
            P3P4 = P3RN + P4RN
            P3P4 = SQRT(P3P4)
            IF (P3P4 .LT. RR(N2) .OR. P3P4 .LT. RR(N1))  GOTO 34
            RN13 = xyz(3,N1)
            RN23 = xyz(3,N2)
            DEL = ABS(RN13 - RN23)
            DIS = RL
            RAP = (DIS - DEL) / DIS
            if (IJ.gt.NAT) then
               CALL Linea0(p1, p2, p3, p4, 7)
            else
               CALL DisLegN(p1, p2, p3, p4, RAP)
               Ize = 0
               if (iPlotType .NE. 6) then
                  CALL Cerchio ( X11, Y11, R, CC, Ize, Ize)
               end if
            end if
c
   34       CONTINUE
            LE(NLL, 1) = -LE(NLL, 1)
   40    continue
         if (IJ.le.NAT) then
            CALL DisePalle(IJ, X11, Y11, R, CC)
            if (Lab(IJ)(1:1).eq.'Q' .and. iPlotType.ne.3) then
               IRT = 0.6 * R - 2
               if (IRT .gt. R-2) IRT = R-2
               if (IRT .lt. 1) IRT = 1
c              CCV = CC
c              CC = 0
c              CALL DisePalle(IJ, X11, Y11, IRT, CC)
c              CC = CCV
               IfF = -1
               iCC=0
               Call Cerchio( X11, Y11, IRT, iCC, IfF, iCC)
               if (iPlotType.eq.5) then
                  IfF = 0
                  iCC = CC
                  Call Cerchio( X11, Y11, IRT, iCC, IfF, iCC)
               end if
            end if
         end if
   50 CONTINUE
c
      RETURN
      END
C -----------------------------------------------------------------
      SUBROUTINE CombRot(B)
      IMPLICIT REAL*4 (M)
      CHARACTER *1 Lett
      CHARACTER *5 Lab
c
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      DIMENSION DU(3, 3), VU(10), W(3, 3), B(3,3)
c
         IF (nint(RK(2)) .EQ. 0) GOTO 80
         DO 20 ISS = 1 , 3
            DO 10 kSSI = 1 , 3
               DU(ISS, kSSI) = 0
   10       CONTINUE
   20    CONTINUE
         T = PI / 180 * RK(1)
         DSINT = SIN(T)
         DCOST = COS(T)
         IF (nint(RK(2)) .EQ. 1) THEN
            DU(1, 1) = 1
            DU(2, 2) = DCOST
            DU(3, 3) = DCOST
            DU(2, 3) = -DSINT
            DU(3, 2) = DSINT
         END IF
         IF (nint(RK(2)) .EQ. 2) THEN
            DU(1, 1) = DCOST
            DU(1, 3) = DSINT
            DU(2, 2) = 1
            DU(3, 1) = -DSINT
            DU(3, 3) = DCOST
         END IF
         IF (nint(RK(2)) .EQ. 3) THEN
            DU(1, 1) = DCOST
            DU(1, 2) = -DSINT
            DU(2, 1) = DSINT
            DU(2, 2) = DCOST
            DU(3, 3) = 1
         END IF
         IF (nint(RK(2)) .EQ. 4) THEN
            NRTO = RK(3)
            PAR = VV(NRTO, 1) ** 2 + VV(NRTO, 2) ** 2
            PAR = PAR + VV(NRTO, 3) ** 2
            DDN = SQRT(PAR)
            DO 30 i = 1 , 3
               VU(i) = VV(NRTO, i) / DDN
   30       CONTINUE
            VU(4) = -VU(2)
            VU(5) = VU(1)
            ANG = RK(1)
            RO = PI / 180 * ANG
            CORO = COS(RO)
            SIRO = SIN(RO)
            UCORO = 1 - CORO
            DO 50 i = 1 , 3
               DO 40 j = i , 3
                  DU(i, j) = VU(i) * VU(j) * UCORO
                  IF (i.EQ.j) THEN
                     DU(i, j) = DU(i, j) + CORO
                  ELSE
                     DU(j, i) = DU(i, j) + VU(i + j) * SIRO
                     DU(i, j) = DU(i, j) - VU(i + j) * SIRO
                  END IF
   40          CONTINUE
   50       CONTINUE
         END IF
 
         CALL Molt2(B, DU, W)
 
         DO 70 i = 1 , 3
            DO 60 j = 1 , 3
               B(i, j) = W(i, j)
   60       CONTINUE
   70    CONTINUE
   80 CONTINUE
c
      RETURN
      END
c ----------------------------------------------------------------------
      SUBROUTINE AggiuSpig
      CHARACTER *5 Lab
      CHARACTER *1 Lett
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      common/work/rm(3,3), eval(3), evec(3,3), ainer(3,3)
      common /temp/  conn(9800)
      DIMENSION x1(3), r(3), lega(12,2)
c
      nMaxAtm = 800
c
      lega(  1, 1) = 1
      lega(  1, 2) = 4
      lega(  2, 1) = 1
      lega(  2, 2) = 5
      lega(  3, 1) = 1
      lega(  3, 2) = 6
      lega(  4, 1) = 2
      lega(  4, 2) = 4
      lega(  5, 1) = 2
      lega(  5, 2) = 5
      lega(  6, 1) = 2
      lega(  6, 2) = 7
      lega(  7, 1) = 3
      lega(  7, 2) = 4
      lega(  8, 1) = 3
      lega(  8, 2) = 6
      lega(  9, 1) = 3
      lega(  9, 2) = 7
      lega( 10, 1) = 8
      lega( 10, 2) = 5
      lega( 11, 1) = 8
      lega( 11, 2) = 6
      lega( 12, 1) = 8
      lega( 12, 2) = 7
 
      xyz(1, NAT + 1) = 1
      xyz(2, NAT + 1) = 0
      xyz(3, NAT + 1) = 0
      xyz(1, NAT + 2) = 0
      xyz(2, NAT + 2) = 1
      xyz(3, NAT + 2) = 0
      xyz(1, NAT + 3) = 0
      xyz(2, NAT + 3) = 0
      xyz(3, NAT + 3) = 1
      xyz(1, NAT + 4) = 0
      xyz(2, NAT + 4) = 0
      xyz(3, NAT + 4) = 0
      xyz(1, NAT + 5) = 1
      xyz(2, NAT + 5) = 1
      xyz(3, NAT + 5) = 0
      xyz(1, NAT + 6) = 1
      xyz(2, NAT + 6) = 0
      xyz(3, NAT + 6) = 1
      xyz(1, NAT + 7) = 0
      xyz(2, NAT + 7) = 1
      xyz(3, NAT + 7) = 1
      xyz(1, NAT + 8) = 1
      xyz(2, NAT + 8) = 1
      xyz(3, NAT + 8) = 1
      do 200 i = NAT + 1, NAT + 8
         Lab(i) = ' '
         iCol(i) = 7
         RS(i) = 0.01
         do 150 j = 1, 3
            x1(j) = xyz(j, i)
  150    continue
         call molt1(rm,x1,r)
         xyz(1,i) = r(1)
         xyz(2,i) = r(2)
         xyz(3,i) = r(3)
  200 continue
      nv = 9
      nlp = 0
      do 300 i = 1, 12
         j = lega(i,1) + NAT
         k = lega(i,2) + NAT
         x01 = xyz(1,j)
         y1 = xyz(2,j)
         z1 = xyz(3,j)
         x2 = xyz(1,k)
         y2 = xyz(2,k)
         z2 = xyz(3,k)
         dist = sqrt( (x01-x2)**2 + (y1-y2)**2 + (z1-z2)**2 )
         r0 = 2.5 / dist
         r1 = r0
         iu = j
  250    xm = x01 + (x2 - x01) * r1
         ym = y1 + (y2 - y1) * r1
         zm = z1 + (z2 - z1) * r1
         xyz(1, NAT + nv) = xm
         xyz(2, NAT + nv) = ym
         xyz(3, NAT + nv) = zm
         Lab(NAT + nv) = ' '
         iCol(NAT + nv) = 7
         RS(NAT + nv) = 0.01
         LE(nMaxLeg - nlp, 1) = iu
         LE(nMaxLeg - nlp, 2) = NAT + nv
         iu = NAT + nv
         nlp = nlp + 1
         r1 = r1 + r0
         nv = nv +1
         if (NAT + nv .gt. nMaxAtm) goto 400
         if (r1 .lt. 1.) then
             goto 250
         else
             LE(nMaxLeg - nlp, 1) = iu
             LE(nMaxLeg - nlp, 2) = k
             nlp = nlp + 1
         end if
  300 continue
  400 LE(nMaxLeg - nlp, 1) = 0
      LE(nMaxLeg - nlp, 2) = 0
c
      return
      end
C -----------------------------------------------------------------
      SUBROUTINE MMenu(B,loop)
      IMPLICIT REAL*4 (M)
      CHARACTER *1 Lett, nt1
      CHARACTER *5 Lab
      CHARACTER *80 Titolo
      INTEGER *4 Asse, Angolo, AngDef
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      COMMON /GeneraC/ DePA, DeMA, DePB, DeMB, DePC, DeMC,
     *                 R(3, 3, 48), T(3, 48),
     *                 Shf(3, 3), Tra(3, 20), nsym, NatInd, nt1
      COMMON /Contr/ NF,iFirstTime,Titolo,Ratio,IfCont,IfEdge,IfScale,
     *               kplty,radii(8), IfScaleB
      common /mess/ Message,ifMess,lMess
      common /buffer/ ixv(100),iyv(100),dummr(315)
      common/xwi/ color,xo,yo,khead,Species,NumSpec,iHCopy,ipres,jpres
      common /screen/ kscreen,jy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      character *80 Message, Species(8)*2
      integer *2 color, xo, yo, khead
      DIMENSION B(3, 3)
c
      nbox=31
      AngDef = 5
c
      Asse = 1
      Angolo = 0
c
c-- flush screen
c
      if (loop.eq.0) then
         call zflush
      end if
c
      goto 50
   10 continue
 
      if (iFirstTime.eq.1) return
c
c-- event handling
c
 1999 continue
      if (ifMess.eq.1) call PrintMess
      iz=0
      call getkey(iz)
c
      if (iz.eq. 0) then
         jrest=0
         if (mod(kprog,10) .lt. 3) Call ModCom(jrest)
         loop=0
         khead = 1
         RETURN
      else if (iz.eq. 1) then
         iPlotType = 1
         Angolo = 0
         Asse = 1
         kplty=iPlotType
         if(IfScale.eq.1) GOTO 20
         GOTO 55
      else if (iz.eq. 2) then
         iPlotType = 2
         Angolo = 0
         Asse = 1
         kplty=iPlotType
         if(IfScale.eq.1) GOTO 20
         GOTO 55
      else if (iz.eq. 3) then
         iPlotType = 3
         Angolo = 0
         Asse = 1
         kplty=iPlotType
         if(IfScale.eq.1) GOTO 20
         GOTO 55
      else if (iz.eq. 4) then
         iPlotType = 4
         Angolo = 0
         Asse = 1
         kplty=iPlotType
         if(IfScale.eq.1) GOTO 20
         GOTO 55
      else if (iz.eq. 5) then
         iPlotType = 5
         Angolo = 0
         Asse = 1
         kplty=iPlotType
         if(IfScale.eq.1) GOTO 20
         GOTO 55
      else if (iz.eq. 6) then
         iPlotType = 6
         Angolo = 0
         Asse = 1
         kplty=iPlotType
         if(IfScale.eq.1) GOTO 20
         GOTO 55
      else if (iz.eq. 7) then
         Angolo = -AngDef
         Asse = 1
      else if (iz.eq. 8) then
         Angolo = AngDef
         Asse = 1
      else if (iz.eq. 9) then
         Angolo = -AngDef
         Asse = 2
      else if (iz.eq.10) then
         Angolo = AngDef
         Asse = 2
      else if (iz.eq.11) then
         Angolo = -AngDef
         Asse = 3
      else if (iz.eq.12) then
         Angolo = AngDef
         Asse = 3
      else if (iz.ge.13.and.iz.le.18) then
         call Traslate(iz)
         Angolo = 0
         Asse = 1
         go to 55
      else if (iz.eq.19) then
         if (IfEdge.eq.0) then
            IfEdge = 1
         else
            IfEdge = 0
         endif
         GOTO 20
      else if (iz.eq.20) then
         if (IfCont.eq.0) then
            IfCont = 1
            NATind = NAT
            call Genera(B)
            iFirstTime = 0
            goto 50
         else
            IfCont = 0
c           NAT = NATind
            call SoloInd(B,NatInd)
            goto 50
         endif
         GOTO 20
      else if (iz.eq.21) then
         if (IfScale.eq.3) then
            IfScale = 1
         else
            IfScale = 3
            goto 10
         endif
         GOTO 20
      else if (iz.eq.22) then
         iPlotType = kplty
         Call DelAt
         if(IfScale.eq.1) GOTO 20
         goto 55
c        loop=1
c        RETURN
      else if (iabs(iz).eq.23 .or. iz.eq.123 .or. iz .eq. 223) then
         iPlotType = kplty
         Call DelHide(iz)
         if(IfScale.eq.1) GOTO 20
         goto 55
c        loop=1
c        RETURN
      else if (iz.ge.nbox+1 .and. iz .le. nbox+3 .or.
     *         iz.ge.nbox+6 .and. iz .le. nbox+8) then
         iPlotType = kplty
         iScelta = iz - nbox
         if (iScelta .gt. 3) iScelta = iScelta - 2
         Call ChePiano (iScelta)
         go to 50
      else if (iz.eq.25) then
         iPlotType = kplty
         Call ReLab(ixv(1),iyv(1),iyv(2))
         go to 55
      else if (iz.eq.26 .and. mod(kprog,10).lt.3) then
         iPlotType = kplty
         jrest=0
         Call ModCom(jrest)
         Call ReGro
         IfCont = 0
c        NAT = NATind
         call SoloInd(B,NatInd)
         IfEdge = 0
         IfScale= 1
         loop=2
         RETURN
      else if (iz.eq.27 .and. mod(kprog,10) .lt.3) then
         iPlotType = kplty
         jrest=1
         Call ModCom(jrest)
         loop=0
         khead = 1
*        ind = 1
*        iz=79
*        call graphs( ixv,iyv,iz,ind,Titolo,icolor)
         RETURN
      else if (iz.eq.28 .and. mod(kprog,10).lt.3) then
         iPlotType = kplty
         jrest=2
         Call ModCom(jrest)
         loop=0
         khead = 1
         RETURN
      else if (iz.eq.29) then
         iPlotType = kplty
         go to 55
      else if (iz.eq.30) then
         go to 50                   ! hard copy richiesta
      else if (iz.eq.-30) then
         Angolo=0                   ! ridisegna dopo hard copy
         Asse=1
         IfScaleB = IfScale
         IfScale = 2
         go to 20
      else if (iz.eq.131) then
         Call Distance
         go to 1999
      else if (iz.eq.231) then
         Call CalcAngle
         go to 1999
      else if (iz.eq.331) then
         Call TorsAngle
         go to 1999
      else if (iz.eq.631 .or. iz.eq.731 ) then
         Call AddDelBonds(iz, NatInd)
         go to 55
      else if (iz.eq.831) then
 2222    Call NumTable(iexit)
         if (iexit .eq. 0) goto 3333
         Call Histogr(iexit)
         if (iexit .eq. 2) goto 2222
 3333    khead = 1
         go to 55
      else
         go to 1999
      endif
c
      IF (Angolo .EQ. 0) GOTO 10
c
   20 RK(1) = Angolo
      RK(2) = Asse
      DO 40 i = 1 , 3
         DO 30 j = 1 , 3
            B(i, j) = 0
   30    CONTINUE
         B(i, i) = 1
   40 CONTINUE
      CALL CombRot(B)
      Rmin1 = 99999
      Rmin2 = 99999
      RMAX1 = -99999
      RMAX2 = -99999
      CALL RotAtoms(B, 1)
   50 CALL SetScale(IfScale)
   55 CALL AngToPix
      if (iPlotType.le.2) then
         CALL SticksOrd
      else
         CALL Balls
         DO 60 i = 1 , NumLeg
            LE(i, 1) = ABS(LE(i, 1))
   60    CONTINUE
         DO 70 i = 1 , NAT + nv
            RR(i) = 0
   70    CONTINUE
      end if
      Angolo = 0
      if (iz.eq.-30) then
          IfScale = IfScaleB
          call display_mouse_cursor
      end if
      GOTO 10
c
      END
C -----------------------------------------------------------------
      SUBROUTINE DisePalle(IJ, X11, Y11, R, CC)
      IMPLICIT REAL*4 (M)
      CHARACTER *1 Lett
      CHARACTER *5 Lab
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      common /scale/ x11scale(2),x11disp(2),ragmed,deltax,deltay
      common /screen/ kscreen,jy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      common /buffer/ ixv(100),iyv(100),dummr(315)
      common/xwi/ color,xo,yo,khead,Species,NumSpec,iHCopy,ipres,jpres
      integer *2 color, xo, yo, khead
      INTEGER *4  CC, CR
      DIMENSION EL(3, 3), C(3), RJ(3)
      DIMENSION H(128, 3)
      character*80 string, Species(8)*2
      integer X11, Y11, R
c
      ifQ =0
      if (CC.le.0) ifQ = 1
      CC = iCol(IJ)
      CR = CC + 8
      iCC = 8
c     if (iPlotType .EQ. 6) goto 500
      IfF = -1
      iFC = 0
      Call Cerchio( X11, Y11, R, iCC, IfF, iCC)
      iCC=0
      Call Cerchio( X11, Y11, R + 2, iCC, IfF, iCC)
      if (ifQ .eq. 1 .and. (IPlotType .eq.4.or.IPlotType.eq.6)) goto 5
      iPP = nint(0.2 * R)
      if (iPP .LT. 1) iPP = 1
      if (iPlotType .EQ. 6) goto 500
      IfF = 0
      IF (iPlotType .NE. 4) CC = CR
      Call Cerchio( X11, Y11, R, CC, IfF, iFC)
      if (ifQ .eq. 1) goto 5
      IF (iPlotType .GE. 4) THEN
         IF (iPlotType .NE. 5) then
            IDum = CC
            Call Paint(X11, Y11, IDum, IDum,R)
         endif
         if (iHCopy.ne.0) then
             iCC = 0
         else
             iCC = 15
         end if
         iPieno = 1
         iX11=nint(X11+0.5*R)
         iY11=nint(Y11-0.5*R)
         Call Cerchio( iX11, iY11, iPP, iCC, iPieno, iCC)
      END IF
5     IF (iPlotType .EQ. 3) THEN
         if (ragmed.lt.10) then          !14
            fx = .75
            fy = 1
         else if (ragmed.lt.15) then     !23
            fx = 1.
            fy = 1.5
         else if (ragmed.lt.22) then
            fx = 1.5
            fy = 2.0
         else if (ragmed.lt.30) then
            fx = 2.0
            fy = 2.8
         else
            fx = 3.0
            fy = 4.0
         endif
         iiY = Y11 + 2 * fy
         L = Lung(Lab(IJ))
         IF (L .GT. 0) THEN
            iiX = X11 - fx * 6.0 * L / 2.0
            IColor = 7
            CALL LabelM(Lab(IJ), iiX, iiY, fx , fy , IColor)
         END IF
      END IF
c
      return
c
  500 DTOR= PI / 180.
      N2 = 40
      AngSt = -225. * DTOR
      AngEn = 135. * DTOR
      DeAng= 360. * DTOR / N2
      Ang = AngSt - DeAng
      do 10 i=1, N2
         Ang = Ang + DeAng
         if (iHCopy.eq.0) then
            ixv(i) = nint( X11 + R * COS(Ang) )
         else
            ixv(i) = nint( X11 + 2.* R * COS(Ang) )
         end if
         iyv(i) = nint( Y11 - R * SIN(Ang) )
   10 continue
*     ixv(N2 + 1) = ixv(1)
*     iyv(N2 + 1) = iyv(1)
*     nz = N2 + 1
*     ind = 13
*     iot = 8
*     call graphs(ixv, iyv, nz, ind,string, iot)
      nz = N2
      ind = 14
      iot = CR
      call graphs(ixv, iyv, nz, ind,string, iot)
 
      DO 50 K = 1 , 3
         DO 40 L = 1 , 3
            IF (L.NE.K) THEN
               EL(K, L) = 0
            ELSE
               EL(K, L) = 1. / FLOAT(R * R)
            END IF
   40    CONTINUE
         C(K) = EL(K, 3)
   50 CONTINUE
      RJ(1) = 1
      RJ(2) = -1
      RJ(3) = .7
      CE = 1
      RANA1 = X11
      RANA2 = Y11
C
C  richiamo sub EllPrinc
C
      iColor=0
      N1 = 9
      CALL EllPrinc(RJ, C, EL, N1, H)
      N2M = N2 / 2
      do 60 i=1, N1
         if (iHCopy.eq.0) then
            ixv(N2M + i) = H(i, 1) + X11
         else
            ixv(N2M + i) = 2. * H(i, 1) + X11
         end if
         iyv(N2M + i) = H(i, 2) + Y11
   60 continue
      nz = N2M + N1 - 1
      ixv(nz)=ixv(1)
      iyv(nz)=iyv(1)
      ind = 13
      iot = CC
      call graphs(ixv, iyv, nz, ind,string, iot)
c-- fill !!!
      ind = 14
      call graphs(ixv, iyv, nz, ind,string, iot)
c
         if (iHCopy.eq.0) then
            iCC = 15
         else
            iCC = 0
         end if
         iPieno = 1
         iX11=nint(X11+0.5*R)
         iY11=nint(Y11-0.5*R)
         Call Cerchio( iX11, iY11, iPP, iCC, iPieno, iCC)
c
      RETURN
      END
C -----------------------------------------------------------------
      SUBROUTINE DisLegN (x1, y1, x2, y2, Rap)
      IMPLICIT REAL*4 (M)
      CHARACTER *1 Lett
      CHARACTER *5 Lab
      character *1 string
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      common /scale/ x11scale(2),x11disp(2),ragmed,deltax,deltay
      common /screen/ kscreen,jy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      common /buffer/ ixv(100),iyv(100),dummr(315)
      dimension xy(8)
 
      DOUBLE PRECISION m8, m9
 
      Rap = .2 + .8 * Rap
      DLeg = .08
      IF (ABS(x1 - x2) .LT. .00001) THEN
         x11 = x1 - DLeg
         y11 = y1
         x12 = x1 + DLeg
         y12 = y1
         x21 = x2 - DLeg
         y21 = y2
         x22 = x2 + DLeg
         y22 = y2
         GOTO 100
      ELSE
         m8 = (y2 - y1) / (x2 - x1)
      END IF
      IF (ABS(m8) .GT. .00001) THEN
         m9 = -1. / m8
      ELSE
         x11 = x1
         y11 = y1 - DLeg * Rap
         x12 = x1
         y12 = y1 + DLeg * Rap
         x21 = x2
         y21 = y2 - DLeg * Rap
         x22 = x2
         y22 = y2 + DLeg * Rap
         GOTO 100
      END IF
      DFK1 = (DLeg  * m8) / SQRT(m8 * m8 + 1.)
      x11 = x1 + DFK1
      y11 = m9 * x11 + x1 / m8 + y1
      x12 = x1 - DFK1
      y12 = m9 * x12 + x1 / m8 + y1
      DFK2 = (DLeg * Rap * m8) / SQRT(m8 * m8 + 1)
      x21 = x2 + DFK2
      y21 = m9 * x21 + x2 / m8 + y2
      x22 = x2 - DFK2
      y22 = m9 * x22 + x2 / m8 + y2
 
  100 BondLu = SQRT((x1 - x2) ** 2 + (y1 - y2) ** 2)
Ccc   IF (BondLu .GT. 5 * DDX) THEN
         xy(1) = x11
         xy(2) = y11
         xy(3) = x12
         xy(4) = y12
         xy(5) = x22
         xy(6) = y22
         xy(7) = x21
         xy(8) = y21
         do 200 i=1,4
         a = ( xy(i*2-1) + x11disp(1) ) * x11scale(1)
         b = ( xy(i*2  ) + x11disp(2) ) * x11scale(2)
         ixv(i)=nint(a)
         iyv(i)=(kscry - deltay) - nint(b)
  200    continue
         iz=4
         ind = 14
         icolor = 0
         call graphs(ixv,iyv,iz,ind,string,icolor)
         ixv(5)=ixv(1)
         iyv(5)=iyv(1)
         iz=5
         ind = 13
         call graphs(ixv,iyv,iz,ind,string,LegCol)
Ccc   END IF
c
      RETURN
      END
C -----------------------------------------------------------------
      SUBROUTINE EllPrinc(RJ, C, EL, N1, H)
      IMPLICIT REAL*4 (M)
      CHARACTER *1 Lett
      CHARACTER *5 Lab
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      DIMENSION S(3), G(3), E(3), H(128, 3), RJ(3), EL(3,3), C(3)
c
      S(1) = C(2) * RJ(3) - C(3) * RJ(2)
      S(2) = C(3) * RJ(1) - C(1) * RJ(3)
      S(3) = C(1) * RJ(2) - C(2) * RJ(1)
      CALL NormVett(S, EL, Q)
      DO 10 i = 1 , 3
         G(i) = Q * RI(i)
   10 CONTINUE
      DO 30 i = 1 , 3
         EI = 0
         DO 20 j = 1 , 3
            EI = EI + EL(i, j) * G(j)
   20    CONTINUE
         E(i) = EI
   30 CONTINUE
      S(1) = RJ(2) * E(3) - RJ(3) * E(2)
      S(2) = RJ(3) * E(1) - RJ(1) * E(3)
      S(3) = RJ(1) * E(2) - RJ(2) * E(1)
      CALL NormVett(S, EL, Q)
      DO 40 i = 1 , 3
         E(i) = Q * RI(i)
   40 CONTINUE
      IF (E(3) .LE. 0) THEN
                         E(1) = -E(1)
                         E(2) = -E(2)
                         E(3) = -E(3)
                       END IF
      N1 = 9
      N2 = 2
      N = 4
      nP1 = N + 1
      N2P1 = N * 2 + 1
      DO 50 j = 1 , 3
         H(1, j) = 1. * G(j)
         H(nP1, j) = E(j)
         H(N2P1, j) = -1. * G(j)
   50 CONTINUE
      DO 90 M = 1 , N2
         N1N = N1 - N
         DO 80 JU = 1 , N1N , N
            K = JU + N
            DO 60 L = 1 , 3
               S(L) = H(JU, L) + H(K, L)
   60       CONTINUE
            CALL NormVett(S, EL, Q)
            DO 70 i = 1 , 3
               E(i) = Q * RI(i)
   70       CONTINUE
            JJ = JU + N / 2
            H(JJ, 1) = E(1)
            H(JJ, 2) = E(2)
            H(JJ, 3) = E(3)
   80    CONTINUE
         N = N / 2
   90 CONTINUE
c     XX = H(1, 1) + RANA1
c     YY = H(1, 2) + RANA2
c     DO 100 j = 2 , N1
c        XXX = H(j, 1) + RANA1
c        YYY = H(j, 2) + RANA2
c        CALL Linea (XX, YY, XXX, YYY, 14)
c        XX = XXX
c        YY = YYY
c 100 CONTINUE
c
      RETURN
      END
C -----------------------------------------------------------------
      SUBROUTINE LabelM (Label, X, Y, Dx, Dy, iColor)
      IMPLICIT REAL*4 (M)
      integer Carattere
      CHARACTER *1 Lett
      CHARACTER *5 Label, Lab
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      integer X, Y, X1, Y1
c
      X1 = X
      Y1 = Y
      L = Lung (Label)
      DO 40 i = 1 , L
         IF (Label(i:i) .NE. ' ') THEN
            DO 10 K = 1 , 70
               IF (Label(i:i) .EQ. Lett(K)) THEN
                  Carattere = K
                  GOTO 20
               END IF
   10       CONTINUE
            Carattere = 1
   20       NBar = NumBar(Carattere)
            DO 30 K = 1 , NBar
               iBarra = iCheBarre(Carattere, K)
               iB1 = X1 + Dx * iBarre(iBarra, 1)
               iB2 = Y1 - Dy * iBarre(iBarra, 2)
               iB3 = X1 + Dx * iBarre(iBarra, 3)
               iB4 = Y1 - Dy * iBarre(iBarra, 4)
               CALL Linea (iB1, iB2, iB3, iB4, iColor)
   30       CONTINUE
            X1 = X1 + 7 * Dx
         END IF
   40 CONTINUE
c
      RETURN
      END
C -----------------------------------------------------------------
      SUBROUTINE Molt2(B, DU, W)
      DIMENSION B(3,3), DU(3,3), W(3,3)
c
      DO 30 i = 1 , 3
         DO 20 j = 1 , 3
            dum = 0
            DO 10 K = 1 , 3
               dum = dum + B(i, K) * DU(K, j)
   10       CONTINUE
            W(i, j) = dum
   20    CONTINUE
   30 CONTINUE
c
      RETURN
      END
C -----------------------------------------------------------------
      SUBROUTINE NormVett(S, EL, Q)
      IMPLICIT REAL*4 (M)
      CHARACTER *1 Lett
      CHARACTER *5 Lab
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      DIMENSION S(3), EL(3, 3)
c
      RL = SQRT(S(1) * S(1) + S(2) * S(2) + S(3) * S(3))
      IF (RL .lt. 0.0001) RL = .0001
      DO 10 K = 1 , 3
         RI(K) = S(K) / RL
   10 CONTINUE
      d = 0
      DO 30 j = 1 , 3
         DD = 0
         DO 20 K = 1 , 3
            DD = DD + RI(K) * EL(K, j)
   20    CONTINUE
         d = d + DD * RI(j)
   30 CONTINUE
      IF (d .lt. 0.0001)  d = .0001
      Q = SQRT(1 / ABS(d))
c
      RETURN
      END
C -----------------------------------------------------------------
      SUBROUTINE RotAtoms(B, iAction)
      IMPLICIT REAL*4 (M)
      integer O1,O2
      CHARACTER *1 Lett
      CHARACTER *5 Lab
      CHARACTER *80 Titolo
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Contr/ NF,iFirstTime,Titolo,Ratio,IfCont,IfEdge,IfScale,
     *               kplty,radii(8), IfScaleB
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      DIMENSION M(3), P(3), B(3, 3)
c
      DO 30 JAT = 1 , NAT + nv
         if (RS(JAT) .LT. -10.0) go to 30
         M(1) = xyz(1,JAT)
         M(2) = xyz(2,JAT)
         M(3) = xyz(3,JAT)
         DO 20 i = 1 , 3
            P(i) = 0
            DO 10 j = 1 , 3
               P(i) = P(i) + B(i, j) * M(j)
   10       CONTINUE
   20    CONTINUE
         IF (iAction.eq.1) then
            xyz(1,JAT) = P(1)
            xyz(2,JAT) = P(2)
            xyz(3,JAT) = P(3)
         END IF
         if (RS(JAT) .LT. 0.0) go to 30
         if (JAT.le.NAT .OR. IfEdge.gt.0) then
            IF (P(1)-RS(JAT) .LT. Rmin1)  Rmin1 = P(1)-RS(JAT)
            IF (P(1)+RS(JAT) .GT. RMAX1)  RMAX1 = P(1)+RS(JAT)
            IF (P(2)-RS(JAT) .LT. Rmin2)  Rmin2 = P(2)-RS(JAT)
            IF (P(2)+RS(JAT) .GT. RMAX2)  RMAX2 = P(2)+RS(JAT)
         end if
   30 CONTINUE
 
      IF (iAction .eq. 1) THEN
         DO 50 i = 1 , (NAT + nv) - 1
            if (RS(i) .LT. 0.0) go to 50
            DO 40 K = i + 1 , NAT + nv
               if (RS(K) .LT. 0.0) go to 40
               O1 = iOrd(i)
               O2 = iOrd(K)
               O3 = xyz(3,O1)
               O4 = xyz(3,O2)
               IF (O3.GT.O4) THEN
                  iOrd(i) = O2
                  iOrd(K) = O1
               END IF
   40       CONTINUE
   50    CONTINUE
      END IF
c
      RETURN
      END
C -----------------------------------------------------------------
      SUBROUTINE SetScale(Azione)
      IMPLICIT REAL*4 (M)
      CHARACTER *1 Lett
      CHARACTER *5 Lab
      CHARACTER *80 Titolo
      INTEGER *4 Azione
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      COMMON /Contr/ NF,iFirstTime,Titolo,Ratio,IfCont,IfEdge,IfScale,
     *               kplty,radii(8), IfScaleB
c
      IF (Azione .EQ. 2)  GOTO 2630
      IF (Azione .EQ. 3)  GOTO 2690
      D1 = (RMAX1 - Rmin1) / 10
      Rmin1 = Rmin1 - D1
      RMAX1 = RMAX1 + D1
      D2 = (RMAX2 - Rmin2) / 10
      Rmin2 = Rmin2 - D2
      RMAX2 = RMAX2 + D2
2630  Dx = RMAX1 - Rmin1
      Dy = RMAX2 - Rmin2
c
***** if (Dy .lt. 0.5) Dy = 0.5
c
      IF (Dx.LE.Dy * Ratio) THEN
                             DX1 = Dy * Ratio
                             DEL = (DX1 - Dx) / 2
                             Rmin1 = Rmin1 - DEL
                             RMAX1 = RMAX1 + DEL
                             Dx = DX1
                           ELSE
                             DY1 = Dx / Ratio
                             DEL = (DY1 - Dy) / 2
                             Rmin2 = Rmin2 - DEL
                             RMAX2 = RMAX2 + DEL
                             Dy = DY1
                           END IF
      IF (Azione .EQ. 4) RETURN
      Xmin = Rmin1
      Ymin = Rmin2
      YMax = Rmin2 + Dy
      XMax = Rmin1 + Dx
      RMAX1 = XMax
      RMAX2 = YMax
2690  CALL WINDOW (Xmin, Ymin, XMax, YMax)
      DDX = (XMax - Xmin) / (Lim3 - Lim1)
      DDY = (YMax - Ymin) / (Lim4 - Lim2)
c
      RETURN
      END
C -----------------------------------------------------------------
      SUBROUTINE Window(Amin1, Amin2, AMax1, AMax2)
      common /screen/ kscreen,iy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      common /scale/ x11scale(2),x11disp(2),ragmed,deltax,deltay
 
      if (ABS(Amin1 - AMax1) .lt. 1.) then
         Amin1 = Amin1 - 0.5
         AMax1 = AMax1 + 0.5
      end if
      if (ABS(Amin2 - AMax2) .lt. 1.) then
         Amin2 = Amin2 - 0.5
         AMax2 = AMax2 + 0.5
      end if
      XXmin = Amin1
      XXMax = AMax1
      YYmin = Amin2
      YYMax = AMax2
      dx=XXMax-XXMin
      dy=YYMax-YYMin
      x11scale(1)=(float(kscrx)-deltax)/dx
      x11scale(2)=(float(kscry)-deltay)/dy
      x11disp(1)=-XXMin + deltax / x11scale(1)
      x11disp(2)=-YYMin - deltay / x11scale(2)
c
      RETURN
      END
C -----------------------------------------------------------------
      SUBROUTINE AngToPix
      CHARACTER *5 Lab
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      common /scale/ x11scale(2),x11disp(2),ragmed,deltax,deltay
      common /screen/ kscreen,iy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
c
      RagMed = 0.0
      NatVis = 0
      do 20 j = 1, NAT + nv
      a = ( xyz(1,j) + x11disp(1) ) * x11scale(1)
      b = ( xyz(2,j) + x11disp(2) ) * x11scale(2)
      c =                     RS(j) * x11scale(2)
      if (j.le.NAT .and. c.gt.0.0) then
          NatVis = NatVis + 1
          RagMed = RagMed + c
      end if
      ipix(1,j)=nint(a)
      ipix(2,j)=(kscry-deltay) - nint(b)
      ipix(3,j)=nint(c)
   20 continue
      if (NatVis.gt.0) RagMed = RagMed / float(NatVis)
c
      RETURN
      END
C -----------------------------------------------------------------
      SUBROUTINE SticksOrd
c
      IMPLICIT REAL*4 (M)
      INTEGER O1,O2
      INTEGER *4 CC, CC1, XX1, YY1, XX2, YY2, DDX, DDY, DDDX, DDDY
      INTEGER *4  XX3, YY3, XD1, XD2
      CHARACTER *1 Lett
      CHARACTER *5 Lab
      CHARACTER *80 Titolo
c
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      COMMON /Contr/ NF,iFirstTime,Titolo,Ratio,IfCont,IfEdge,IfScale,
     *               kplty,radii(8), IfScaleB
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
c
      DO 20 i = 1 , (NAT + nv) - 1
         DO 10 K = i + 1 , NAT + nv
            O1 = iOrd(i)
            O2 = iOrd(K)
            O3 = xyz(3,O1)
            O4 = xyz(3,O2)
            IF (O3.GT.O4) THEN
               iOrd(i) = O2
               iOrd(K) = O1
            END IF
   10    CONTINUE
   20 CONTINUE
      DDY = 1
      DDX = 1
c
      CALL NewPage
c
      DO 40 JJ = 1 , NAT + nv
         IJ = iOrd(JJ)
         if (RS(IJ).LE.0) go to 40
         if (IfEdge.eq.0 .AND. IJ.gt.NAT) GOTO 40
         ZETA = xyz(3,IJ)
         Legato = 0
         DO 30 NLL = 1 , NumLeg
            N1 = LE(NLL, 1)
            N2 = LE(NLL, 2)
            IF (N1.NE.IJ.AND.N2.NE.IJ) GOTO 30
            IF (N1 .EQ. IJ .AND. xyz(3,N2) .GT. ZETA)  GOTO 30
            IF (N2 .EQ. IJ .AND. xyz(3,N1) .GT. ZETA)  GOTO 30
            IF (RS(N1) .LE. 0 .OR. RS(N2) .LE. 0)  GOTO 30
            Legato = -1
            XX1 = ipix(1,N1)
            XX2 = ipix(1,N2)
            YY1 = ipix(2,N1)
            YY2 = ipix(2,N2)
            ZZ1 = xyz(3,N1)
            ZZ2 = xyz(3,N2)
c           write(lo,'(6f10.4,6i5)') xyz(1,n1),xyz(2,n1),xyz(3,n1),
c    * xyz(1,n2),xyz(2,n2),xyz(3,n2),ipix(1,n1),ipix(2,n1),ipix(3,n1),
c    * ipix(1,n2),ipix(2,n2),ipix(3,n2)
            IF (XX1.LT.XX2) THEN
               DDDX = DDX
            ELSE
               DDDX = -DDX
            END IF
            IF (YY1.LT.YY2) THEN
               DDDY = DDY
            ELSE
               DDDY = -DDY
            END IF
            XD1= XX1 + DDDX
            XD2= XX2 - DDDX
            Ize = 0
            CALL Linea (XD1, YY1-DDDY, XD2, YY2 - DDDY, Ize)
            CALL Linea (XD1, YY1+DDDY, XD2, YY2 + DDDY, Ize)
            CALL Linea (XD1, YY1-2 * DDDY, XD2, YY2 - 2 * DDDY,Ize)
            CALL Linea (XD1, YY1+2 * DDDY, XD2, YY2 + 2 * DDDY,Ize)
            XX3 = (XX1 + XX2) / 2
            YY3 = (YY1 + YY2) / 2
            CC1 = iCol(N1) + 8
            CC  = iCol(N2) + 8
            CALL Linea (XX1, YY1, XX3, YY3, CC1)
            CALL Linea (XX3, YY3, XX2, YY2, CC)
            IF (iPlotType .EQ. 2 .AND. N1 .LE. NAT) THEN
               iCC = 8
               IfF = -1
               Call Cerchio(XX1, YY1, 3 * DDX, iCC, IfF, iCC)
               iCC = 0
               IfF = 0
               iFC = 0
               Call Cerchio( XX1, YY1, 4 * DDX, iCC, IfF, iFC)
               Call Paint(XX1, YY1, CC1-8, iFC,4*DDx)
               IDum = 15
               CALL MettiPixel(XX1 + DDX, YY1 - 2 * DDY, IDum)
               if (Lab(N1)(1:1).eq.'Q') then
                  IfF = -1
                  iFC = 0
                  Call Cerchio( XX2, YY2, 2 * DDX, iCC, IfF, iFC)
               end if
               if (N2 .LE. NAT) THEN
               iCC = 8
               IfF = -1
               Call Cerchio( XX2, YY2, 3 * DDX, iCC, IfF, iCC)
               iCC = 0
               IfF = 0
               iFC = 0
               Call Cerchio( XX2, YY2, 4 * DDX, iCC, IfF, iFC)
               Call Paint(XX2, YY2, CC-8, iFC,4*DDx)
               IDum = 15
               CALL MettiPixel(XX2 + DDX, YY2 - 2 * DDY, IDum)
               if (Lab(N2)(1:1).eq.'Q') then
                  IfF = -1
                  iFC = 0
                  Call Cerchio( XX2, YY2, 2 * DDX, iCC, IfF, iFC)
               end if
               END IF
            END IF
   30    CONTINUE
         if (Legato .eq. 0) then
             ix = ipix(1,IJ)
             iy = ipix(2,IJ)
             IDum = iCol(IJ) + 8
             if (iPlotType .eq. 1) then
                CALL MettiPixel(ix , iy , IDum)
             else
                if (IJ.LE.NAT) THEN
                iCC = 8
                IfF = -1
                Call Cerchio(ix, iy, 3 , iCC, IfF, iCC)
                iCC = 0
                IfF = 0
                iFC = 0
                Call Cerchio( ix, iy, 4 , iCC, IfF, iFC)
                Call Paint(ix, iy, IDum-8, iFC, 4)
                IDum = 15
                CALL MettiPixel(ix + 1, iy - 2, IDum)
                if (Lab(IJ)(1:1).eq.'Q') then
                  IfF = -1
                  iFC = 0
                  Call Cerchio( ix, iy, 2, iCC, IfF, iFC)
                end if
                END IF
             end if
         end if
   40 CONTINUE
c
      RETURN
      END
C -----------------------------------------------------------------
      FUNCTION Lung (Stringa)
 
      CHARACTER  Stringa *(*)
 
      K = len (Stringa)
      DO 10 I = K, 1, -1
          IF (Stringa(I:I) .NE. ' ') then
                                       Lung = I
                                       RETURN
                                     END IF
   10 CONTINUE
      Lung = 0
c
      RETURN
      END
C -----------------------------------------------------------------
      SUBROUTINE NewPage
      character*80 string
      common /buffer/ ixv(100),iyv(100),dummr(315)
c* *ind == 6 : clear screen
      ind=6
      icolor=1
      call graphs( ixv,iyv,iz,ind,string,icolor)
c
      RETURN
      END
C -----------------------------------------------------------------
      SUBROUTINE Linea (ix, iy, ix2, iy2, iColor)
      character*80 string
      common /buffer/ ixv(100),iyv(100),dummr(315)
c
      call SetColr (iColor)
      ixv(1)=ix
      ixv(2)=ix2
      iyv(1)=iy
      iyv(2)=iy2
      ind=2
      call graphs( ixv, iyv, iz, ind, string, iColor)
c
      RETURN
      END
C -----------------------------------------------------------------
      SUBROUTINE Linea0(x, y, x2, y2, iColor)
c
      common /scale/ x11scale(2),x11disp(2),ragmed,deltax,deltay
      common /screen/ kscreen,iy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
c
      ix  = nint( (  x + x11disp(1) ) * x11scale(1) )
      iy  = nint( (  y + x11disp(2) ) * x11scale(2) )
      ix2 = nint( ( x2 + x11disp(1) ) * x11scale(1) )
      iy2 = nint( ( y2 + x11disp(2) ) * x11scale(2) )
      iy  = (kscry - deltay) - iy
      iy2 = (kscry - deltay) - iy2
      call Linea (ix, iy, ix2, iy2, iColor)
c
      RETURN
      END
C -----------------------------------------------------------------
      SUBROUTINE Paint (ix1, iy1, iColore, iColoreBordo, Raggio)
      CHARACTER *1 Lett
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      common /screen/ kscreen,iy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      common /buffer/ ixv(100),iyv(100),dummr(315)
      character*80 string
      integer Raggio
c
      call SetColr (iColore)
c
      ixv(1) = ix1 - Raggio
      iyv(1) = iy1 - Raggio
      iz = 2 * Raggio
      ind=11
      call graphs( ixv,iyv,iz,ind,string,iColoreBordo)
c
      RETURN
      END
C -----------------------------------------------------------------
      SUBROUTINE MettiPixel (ix, iy, IColor)
      character*80 string
      common /buffer/ ixv(100),iyv(100),dummr(315)
c
      call SetColr (iColor)
      ixv(1)=ix
      ixv(2)=ix
      iyv(1)=iy
      iyv(2)=iy
      ind=2
      call graphs( ixv,iyv,iz,ind,string,iColor)
c
      RETURN
      END
C -----------------------------------------------------------------
      SUBROUTINE Cerchio (ix1, iy1, Radius, iColor, IfFill, iFillColor)
      common /screen/ kscreen,iy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      common /buffer/ ixv(100),iyv(100),dummr(315)
      character*80 string
      integer Radius
C
C     X , Y  :  Center Coordinates
C     Radius :  Circle Radius
C     iColor  :  Line Color
C     IfFill = 0 don't fill    = -1  Fill
C     iFillColor : Filling Color
C
      ixv(1) = ix1 - Radius
      iyv(1) = iy1 - Radius
      iz = 2 * Radius
      IF (IfFill .NE. 0) THEN
         call SetColr (iFillColor)
         ind=11
         call graphs( ixv,iyv,iz,ind,string,iFillcolor)
      ELSE
         call SetColr (iColor)
         ind=10
         call graphs( ixv,iyv,iz,ind,string,iColor)
      END IF
c
      RETURN
      END
C ------------------------------------------------------------------
      SUBROUTINE SetColr(iColor)
      character*80 string
      common /buffer/ ixv(100),iyv(100),dummr(315)
c
      ind = 12
      ix=0
      iy=0
      call graphs( ixv,iyv,iz,ind,string,iColor)
c
      return
      end
C -----------------------------------------------------------------
      SUBROUTINE Genera(B)
 
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      COMMON /GeneraC/ DePA, DeMA, DePB, DeMB, DePC, DeMC,
     *                 R(3, 3, 48), T(3, 48),
     *                 Shf(3, 3), Tra(3, 20), nsym, NatInd, nt1
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Contr/ NF,iFirstTime,Titolo,Ratio,IfCont,IfEdge,IfScale,
     *               kplty,radii(8), IfScaleB
      common/work/rm(3,3), eval(3), evec(3,3), ainer(3,3)
      common/rc/p(6),cx(9),dumm(9)
      common /screen/ kscreen,iy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
 
      CHARACTER  Lab*5, nt1*1, titolo *80
      REAL MLU
      DIMENSION B(3, 3)
      DIMENSION cb(3), x1(3), r1(3)
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent,
     *         kpol,jsys,lat,indv(32),mpv(64),jspini,ddmin,ncawu,ncwu
      character*7 reticoli
c
      nMaxAtm = 800
c
c                P E Z Z A  ! ! !
c
      if (mod(kprog,10) .lt. 3) then
      reticoli='pabcifr'
      nt1=reticoli(lat:lat)
      nsym = noper
      do k=1,nsym
         do i=1,3
            do j=1,3
               R(i,j,k)=soper(i,j,k)
               if (icent.eq.1) R(i,j,k+nsym)=-R(i,j,k)
            enddo
            T(i,k)=soper(i,4,k)
            if (icent.eq.1) T(i,k+nsym)=T(i,k)
         enddo
      enddo
      if (icent.eq.1) nsym=nsym*2
      end if
c
c
 
      Tra(1, 1) = 1
      Tra(2, 1) = 0
      Tra(3, 1) = 0
      Tra(1, 2) = 0
      Tra(2, 2) = 1
      Tra(3, 2) = 0
      Tra(1, 3) = 0
      Tra(2, 3) = 0
      Tra(3, 3) = 1
 
      DeA = 3.0/cx(1)
      DeB = 3.0/cx(2)
      DeC = 3.0/cx(3)
      if ( DeA .gt. cx(1)*0.5 ) DeA = cx(1) * 0.5
      if ( DeB .gt. cx(2)*0.5 ) DeB = cx(2) * 0.5
      if ( DeC .gt. cx(3)*0.5 ) DeC = cx(3) * 0.5
 
      DePA = 1.0 + DeA
      DeMA =     - DeA
      DePB = 1.0 + DeB
      DeMB =     - DeB
      DePC = 1.0 + DeC
      DeMC =     - DeC
 
      iCentrato = 0
      nce = 0
      nit = 3
      do 50 i = 1, NAT
         xyz(1, i) = x(1,i)
         xyz(2, i) = x(2,i)
         xyz(3, i) = x(3,i)
         iEqui(i) = i
   50 continue
c
      IF (nt1 .NE. 'p') THEN
         CALL Centra(nce, Shf, nt1)
         iCentrato = -1
      END IF
 
      natot = NAT
      do 200 na = 1, NAT
         do 150 n = 1, nsym
            CALL Ruota(R, T, n, na, cb)
            idop = iDoppio(natot, cb)
            IF (idop .EQ. 0) THEN
               natot = natot + 1
               xyz(1, natot) = cb(1)
               xyz(2, natot) = cb(2)
               xyz(3, natot) = cb(3)
               iEqui(natot) = na
               if (natot.eq.nMaxAtm - nv) go to 480
            END IF
  150    continue
  200 continue
 
      NAT = natot
      IF (iCentrato .NE. 0) THEN
         do 250 na = 1, NAT
            do 220 n =1, nce
               CALL Trasl(Shf, n, na, cb, -1)
               idop = iDoppio(natot, cb)
               IF (idop .EQ. 0) THEN
                  natot = natot + 1
                  xyz(1, natot) = cb(1)
                  xyz(2, natot) = cb(2)
                  xyz(3, natot) = cb(3)
                  iEqui(natot) = iEqui(na)
                  if (natot.eq.nMaxAtm - nv) go to 480
               END IF
  220       continue
  250    continue
      END IF
 
      NAT = natot
      do 450 it = 1, nit
         do 400 ic = -1, 1, 2
            do 350 na = 1 , NAT
               do 300 i = 1, 3
                  Tra(i, it) = ic * ABS(Tra(i, it))
  300          continue
               CALL Trasl(Tra, it, na, cb, -1)
               idop = iDoppio(natot, cb)
               IF (idop .EQ. 0) THEN
                  natot = natot + 1
                  xyz(1, natot) = cb(1)
                  xyz(2, natot) = cb(2)
                  xyz(3, natot) = cb(3)
                  iEqui(natot) = iEqui(na)
                  if (natot.eq.nMaxAtm - nv) go to 480
               END IF
  350       continue
 
            NAT = natot
 
  400    continue
  450 continue
 
  480 NAT = natot
 
c     io=2
c     open(unit=2,status='unknown',file='Compl.mol')
c     write(io,'(a)') titolo
c     write(io,'(6f10.6)') a, b, c, alfa, beta, gamma
c     write(io,'(i5)') NAT
 
      do 550 na = 1, NAT
         ieq = iEqui(na)
         Lab(na) = Lab(ieq)
         MLU(na) = MLU(ieq)
         RS(na) = RS(ieq)
         iCol(na) = iCol(ieq)
         Lab(na) = Lab(ieq)
c     write(io,'(a4,1h,,5f10.6,i4)')Lab(na),(xyz(i,na),i=1,3),
c    +                                MLU(na),RS(na),iCol(na)
         x1(1) = xyz(1, na)
         x1(2) = xyz(2, na)
         x1(3) = xyz(3, na)
         call molt1(rm,x1,r1)
         xyz(1, na) = r1(1)
         xyz(2, na) = r1(2)
         xyz(3, na) = r1(3)
  550 continue
      call AggiuSpig
c
      call LsPlane(NATV)
c
      call BuildBonds(2)
c
      Rmin1 = 99999.
      Rmin2 = 99999.
      RMAX1 = -99999.
      RMAX2 = -99999.
c
      CALL FindOr(B)
c
      RETURN
      END
c --------------------------------------------------------------------
      SUBROUTINE Centra (nce, Shf, nt1)
 
      CHARACTER *1 nt1
      DIMENSION Shf(3,3)
 
      IF (nt1 .EQ. 'f') THEN
         nce = 3
         Shf(1, 1) = 0.
         Shf(2, 1) = .5
         Shf(3, 1) = .5
         Shf(1, 2) = .5
         Shf(2, 2) = 0.
         Shf(3, 2) = .5
         Shf(1, 3) = .5
         Shf(2, 3) = .5
         Shf(3, 3) = 0.
      END IF
      IF (nt1 .EQ. 'r') THEN
         nce = 2
         Shf(1, 1) = .333
         Shf(2, 1) = .666
         Shf(3, 1) = .333
         Shf(1, 2) = .666
         Shf(2, 2) = .333
         Shf(3, 2) = .666
      END IF
      IF (nt1 .EQ. 'i') THEN
         nce = 1
         Shf(1, 1) = .5
         Shf(2, 1) = .5
         Shf(3, 1) = .5
      END IF
      IF (nt1 .EQ. 'a') THEN
         nce = 1
         Shf(1, 1) = 0.
         Shf(2, 1) = .5
         Shf(3, 1) = .5
      END IF
      IF (nt1 .EQ. 'b') THEN
         nce = 1
         Shf(1, 1) = .5
         Shf(2, 1) = 0.
         Shf(3, 1) = .5
      END IF
      IF (nt1 .EQ. 'c') THEN
         nce = 1
         Shf(1, 1) = .5
         Shf(2, 1) = .5
         Shf(3, 1) = 0.
      END IF
 
      RETURN
      END
c --------------------------------------------------------------------
      FUNCTION iDoppio (natot, c)
 
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      DIMENSION c(3)
      character *5 Lab
      real *4 MLU
 
      iDoppio = 0
      DO 20 nn = 1, natot
         DO 10 i = 1, 3
            IF (ABS(xyz(i, nn) - c(i)) .GT. .001) THEN
                GOTO 20
            END IF
   10    CONTINUE
         iDoppio = -1
         RETURN
   20 CONTINUE
 
      RETURN
      END
c --------------------------------------------------------------------
      SUBROUTINE RimettiDentro (c)
 
      character * 1 nt1
      COMMON /GeneraC/ DePA, DeMA, DePB, DeMB, DePC, DeMC,
     *                 R(3, 3, 48), T(3, 48),
     *                 Shf(3, 3), Tra(3, 20), nsym, NatInd, nt1
      DIMENSION c(3)
 
   10 if (c(1) .gt. DePA) then
         c(1) = c(1) - 1
         goto 10
      end if
   20 if (c(1) .lt. DeMA) then
         c(1) = c(1) + 1
         goto 20
      end if
   30 if (c(2) .gt. DePB) then
         c(2) = c(2) - 1
         goto 30
      end if
   40 if (c(2) .lt. DeMB) then
         c(2) = c(2) + 1
         goto 40
      end if
   50 if (c(3) .gt. DePC) then
         c(3) = c(3) - 1
         goto 50
      end if
   60 if (c(3) .lt. DeMC) then
         c(3) = c(3) + 1
         goto 60
      end if
 
      RETURN
      END
c --------------------------------------------------------------------
      SUBROUTINE Ruota (R, T, n, na, cb)
 
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      DIMENSION A(3, 3), B(3), R(3,3,48), T(3,48), cb(3)
      character *5 Lab
      real *4 MLU
 
      DO 20 j = 1, 3
         DO 10 k = 1, 3
            A(k, j) = R(k, j, n)
  10     CONTINUE
         B(j) = xyz(j, na)
  20  CONTINUE
      DO 40 i = 1, 3
         cb(i) = 0
         DO 30 j = 1, 3
            cb(i) = cb(i) + A(i, j) * B(j)
  30     CONTINUE
         cb(i) = cb(i) + T(i, n)
  40  CONTINUE
 
      CALL RimettiDentro(cb)
 
      RETURN
      END
c --------------------------------------------------------------------
      SUBROUTINE Trasl (T, n, na, cb, ird)
 
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      DIMENSION T(3,3), cb(3)
      character *5 Lab
      real *4 MLU
 
      DO 10 i = 1, 3
       cb(i) = xyz(i, na) + T(i, n)
   10 CONTINUE
      IF (ird .NE. 0) THEN
       CALL RimettiDentro(cb)
      END IF
      RETURN
      END
c --------------------------------------------------------------------
      SUBROUTINE SoloInd(B,NatInd)
 
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Contr/ NF,iFirstTime,Titolo,Ratio,IfCont,IfEdge,IfScale,
     *               kplty,radii(8), IfScaleB
      common/work/rm(3,3), eval(3), evec(3,3), ainer(3,3)
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      COMMON /Leg1/ LE1(800,2),nLegInd
c
      CHARACTER *1 Lett
      CHARACTER *5 Lab, titolo *80
      REAL MLU
      DIMENSION  x1(3), r1(3), B(3, 3)
 
c
      do 2 i=NatInd+1, NAT
         if (RS(i) .gt. 0.0) then
            RS(iEqui(i)) = abs(RS(i))
         end if
    2 continue
      NAT = NatInd
      do 5 i = 1, NAT
         x1(1) = x(1, i)
         x1(2) = x(2, i)
         x1(3) = x(3, i)
         call molt1(rm,x1,r1)
         xyz(1, i) = r1(1)
         xyz(2, i) = r1(2)
         xyz(3, i) = r1(3)
         iEqui(i) = i
    5 continue
      call AggiuSpig
c
      call LsPlane(NATV)
c
      NumLeg = nLegInd
      call GetBonds(2)
c
      do 70 i = 1, NumLeg
         LE(i, 1) = LE1(i, 1)
         LE(i, 2) = LE1(i, 2)
   70 continue
c
      if (NATV.eq.0) then
          return
      end if
c
      Rmin1 = 99999.
      Rmin2 = 99999.
      RMAX1 = -99999.
      RMAX2 = -99999.
c
      CALL FindOr(B)
c
      return
      END
C -----------------------------------------------------------------
      SUBROUTINE DelAt
      IMPLICIT REAL*4 (M)
      CHARACTER *1 Lett
      CHARACTER *5 Lab
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      common /mess/ Message,ifMess,lMess
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      character blank,digit*12,card(100)*80,ffile*80
      common /chara/ blank,digit,card,ffile
      common /buffer/ ixv(100),iyv(100),dummr(315)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      character *80 Message, Deltd*130
      integer X11,Y11
c
      do 5 i=1, 126
         Deltd(i:i) = ' '
    5 continue
c
      NumCanc = 0
      NumCTot = 0
      iscr=0
      do 60 n = 1, 99
         ix = ixv(n)
         if(ix.lt.0) goto 70
         iy = iyv(n)
         jfound = 0
         idmin = 9999
         DO 50 III = NAT + nv, 1 , -1
            IJ = iOrd(III)
            if (IJ.gt.NAT .OR. RS(IJ).lt.0 ) go to 50
            X11 = ipix(1,IJ)
            Y11 = ipix(2,IJ)
            dx= ix - X11
            dy= iy - Y11
            dist = sqrt( dx*dx + dy*dy )
            idist=nint(dist)
            if (idist.le.ipix(3,IJ) .and. RS(IJ).gt.0) then
               if (idist.le.idmin) then
                  idmin = idist
                  jfound= IJ
               endif
            endif
   50    continue
c  40    format(i4,1h) ,2x,a4,8i5)
         if (jfound.gt.0) then
            RS(jfound) = -(10. + RS(jfound))
            NumCanc = NumCanc + 1
            NumCTot = NumCTot + 1
            ipu = (NumCanc - 1) * 6 + 1
            if (ipu.eq.127) then
                if (iscr.eq.0) write(lo,120)
                write(lo,'(1h ,a)') Deltd
                do 51 i=1, 130
                   Deltd(i:i) = ' '
   51           continue
                iscr = 1
                NumCanc = 1
                ipu = 1
            end if
            Deltd(ipu:ipu+4) = Lab(jfound)
            do 55 i=1, NAT
               if (iEqui(i).eq.iEqui(jfound)) then
                   RS(i) =  RS(jfound)
               end if
   55       continue
         endif
   60 continue
   70 if (NumCTot.gt.0) then
         write(Message,100) NumCTot
         lMess = 30
      else
         write(Message,110)
         lMess = 18
      endif
      if (NumCanc.gt.0) then
         if (iscr.eq.0) write(lo,120)
         if (Deltd(1:1).ne.' ') write(lo,'(1h ,a)') Deltd
      end if
c
  100 format(i3,' Atom(s) has been deleted !')
  110 format(' No Atom deleted !')
  120 format(/,' The following Atom(s) has been deleted :')
      ifMess=1
c
      return
      end
C -----------------------------------------------------------------
      SUBROUTINE DelHide(iz)
      IMPLICIT REAL*4 (M)
      CHARACTER *1 Lett
      CHARACTER *5 Lab
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      common /mess/ Message,ifMess,lMess
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      character blank,digit*12,card(100)*80,ffile*80
      common /chara/ blank,digit,card,ffile
      common /buffer/ ixv(100),iyv(100),dummr(315)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      character *80 Message, Deltd*132
c
      do 5 i=1, 132
         Deltd(i:i) = ' '
    5 continue
c
c   rendi visibili tutti gli atomi hidden (show all)
c
      if (iz.eq.123) then
         do 500 i=1, NAT 
            IJ = i
            if (RS(IJ) .gt. -10.) then
               RS(IJ) = abs(RS(IJ))
            end if
  500    continue
         return
      end if
c
      do 10 i = 1, 99
         if (ixv(i).lt.0) goto 20
   10 continue
   20 nvpol = i - 1
      n = 1
   21 n = n + 1
      if (ixv(n).eq.ixv(n - 1) .AND. iyv(n).eq.iyv(n - 1)) then
         do 22 i = n, nvpol - 1
            ixv(i) = ixv(i + 1)
            iyv(i) = iyv(i + 1)
   22    continue
         nvpol = nvpol - 1
         n = n - 1
      end if
      if (n.lt.nvpol) goto 21
   23 icont = 0
      do 26 i = 1, nvpol - 2
         do 24 j = i + 1, nvpol - 1
            IF (IABS(iyv(i) - iyv(j)) .le. 2) THEN
               iyv(j) = iyv(j) - 1
               icont = -1
            END IF
   24    continue
   26 continue
      if (icont .ne. 0) goto 23
      NumCanc = 0
      NumCancTot = 0
      NumHidd = 0
      iscr = 0
      DO 50 III = NAT + nv, 1 , -1
         IJ = iOrd(III)
         if (IJ .GT. NAT. OR. RS(IJ). LT. 0) go to 50
         ix = ipix(1,IJ)
         iy = ipix(2,IJ)
         in = Interno(ix, iy, nvpol)
         inn = Interno(ix, iy - 1, nvpol)
         if (iz .eq. 223) then
c --        voglio nascondere gli esterni
            if (in .ne. -2 .and. inn .ne. -2) then
c --           e' esterno
               RS(IJ) = -RS(IJ)
               NumHidd = NumHidd + 1
            end if
         else
c --        gli interni sono selezionati ...
            if (in.eq.-2 .or. inn.eq.-2) then
               if (iz.lt.0) then
c --              ... per cancellarli
                  RS(IJ) = -(10. + RS(IJ))
                  NumCanc = NumCanc + 1
                  NumCancTot = NumCancTot + 1
                  ipu = (NumCanc - 1) * 6 + 1
                  if (ipu.eq.133) then
                     if (iscr.eq.0) write(lo,120)
                      write(lo,'(a)') Deltd
                      do 51 i=1, 132
                         Deltd(i:i) = ' '
   51                 continue
                      iscr = 1
                      NumCanc = 1
                      ipu = 1
                  end if
                  Deltd(ipu:ipu+4) = Lab(IJ)
                  do 55 i=1, NAT
                     if (iEqui(i) .eq. iEqui(IJ)) then
                         RS(i) =  RS(IJ)
                     end if
   55             continue
               else
c --              ... per nasconderli
                  RS(IJ) = -RS(IJ)
                  NumHidd = NumHidd + 1
               end if
            end if
         end if
   50 continue
      if(iz.lt.0) then
         if (NumCancTot.gt.0) then
            write(Message,100) NumCancTot
            lMess = 30
            if (NumCanc.gt.0) then
               if (iscr.eq.0) write(lo,120)
               if (Deltd(1:1).ne.' ') write(lo,'(a)') Deltd
            end if
         else
            write(Message,110)
            lMess = 18
         endif
      else
         if (NumHidd.gt.0) then
            write(Message,200) NumHidd
            lMess = 30
         else
            write(Message,210)
            lMess = 18
         endif
      end if
c
  100 format(i3,' Atom(s) has been deleted !')
  110 format(' No Atom deleted !')
  120 format(/,' The following Atom(s) has been deleted :')
  200 format(i3,' Atom(s) has been hidden  !')
  210 format(' No Atom hidden  !')
      ifMess=1
c
      return
      end
C -----------------------------------------------------------------
      SUBROUTINE ReLab(ix,iy,iz)
      IMPLICIT REAL*4 (M)
      CHARACTER *1 Lett
      CHARACTER *5 Lab,Labb
      CHARACTER *80 Titolo
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      COMMON /Contr/ NF,iFirstTime,Titolo,Ratio,IfCont,IfEdge,IfScale,
     *               kplty,radii(8), IfScaleB
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,kat,f(9),nalf(8)
      common /mess/ Message,ifMess,lMess
      character *80 Message
      character blank,digit*12,card(100)*80,ffile*80
      common /chara/ blank,digit,card,ffile
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      common /neutro/ neutro,bmat(2,98),neuwei,vetint(200)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      integer X11,Y11
c
      if (neutro.eq.0) then
      if(no(1).eq.1) iz = iz + 1
                       endif
      jfound = 0
      idmin = 9999
      DO 50 III = NAT + nv, 1 , -1
         IJ = iOrd(III)
         if (IJ .GT. NAT) go to 50
         X11 = ipix(1,IJ)
         Y11 = ipix(2,IJ)
         dx= ix - X11
         dy= iy - Y11
         dist = sqrt( dx*dx + dy*dy )
         idist=nint(dist)
         if (idist.le.ipix(3,IJ)) then
            if (idist.le.idmin) then
               idmin = idist
               jfound= IJ
             endif
         endif
   50 continue
c  40 format(i4,1h) ,2x,a4,8i5)
      if (jfound.gt.0) then
         jfeq = iequi(jfound)
         lnz=mod(nz(jfeq),100)
         nz(jfeq)=iz*100+lnz
         write(Message(1:33),100) Lab(jfound)
         call CreaLab(iequi(jfound),iz,Labb)
         Lab(jfound) = Labb
         write(Message(34:46),120) Lab(jfound)
         lMess = 46
         if (no(1).eq.1) then
            jlig=1
         else
            jlig=0
         endif
         if (neutro.eq.1) jlig=0
         iCol(jfound) = iz - jlig
         Rs  (jfound) = radii(iz) / 3.0
         MLu (jfound) = 2*radii(iz)+0.3
         do 55 i=1, NAT
            if (iEqui(i).eq.iEqui(jfound)) then
                if (RS(i) .gt.-10.) then
                   if (RS(i) .gt. 0.) then
                       RS(i) =  RS(jfound)
                   else
                       RS(i) = -RS(jfound)
                   end if
                end if
                iCol(i) = iCol(jfound)
                MLu(i) = MLu(jfound)
                Lab(i) = Lab(jfound)
            end if
   55    continue
      else
         write(Message,110)
         lMess = 21
      endif
c
  100 format(' Atom ',a5,' has been reLabelled  ')
  110 format(' No Atom reLabelled !')
  120 format(' as   ',a5,' !')
c
      ifMess=1
      if (lMess.gt.21) write(lo,'(a)') Message(1:lMess)
c
      return
      end
C -----------------------------------------------------------------
      SUBROUTINE Distance
      IMPLICIT REAL*4 (M)
      CHARACTER *1 Lett
      CHARACTER *5 Lab
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      common /mess/ Message,ifMess,lMess
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      character blank,digit*12,card(100)*80,ffile*80
      common /chara/ blank,digit,card,ffile
      common /buffer/ ixv(100),iyv(100),dummr(315)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/xwi/ color,xo,yo,khead,Species,NumSpec,ihcopy,ipres,jpres
      character *80 Message, Species(8)*2
      integer *2 color, xo, yo, khead
      integer X11,Y11, jfou(100)
      dimension dis(100)
c
      iscr=0
      nf = 0
      do 60 n = 1, 99
         jfound = 0
         ix = ixv(n)
         if(ix.lt.0) goto 55
         iy = iyv(n)
         idmin = 9999
         DO 50 IJ = NAT, 1 , -1
            if ( RS(IJ).lt.0 ) go to 50
            X11 = ipix(1,IJ)
            Y11 = ipix(2,IJ)
            dx= ix - X11
            dy= iy - Y11
            dist = sqrt( dx*dx + dy*dy )
            idist=nint(dist)
            if (idist.le.ipix(3,IJ) .and. RS(IJ).gt.0) then
               if (idist.le.idmin) then
                  idmin = idist
                  jfound= IJ
               endif
            endif
   50    continue
   55    if (jfound.gt.0) then
            nf = nf + 1
            jfou(nf) = jfound
         elseif (nf .eq. 0) then
            write(Message,300)
            LMess = 35
            ifMess = 1
            goto 100
         elseif (nf .eq.1) then
            j1 = jfou(1)
            ndist = 0
            distmin = 999.
            do 30 jj = 1, NAT
               if (jj .ne. j1 .and. RS(jj).gt.0 ) then
                  dist = 0.
                  do 20 i=1,3
                     dist = dist + (xyz(i,j1)-xyz(i,jj))**2
   20             continue
                  dist = sqrt(dist)
                  if (dist .lt. distmin) then
                     distmin = dist
                     jf = jj
                  end if
                  if ( dist .le. 1.5 * MLU(j1) .or.
     *                 dist .le. 1.5 * MLU(jj)       ) then
                     ndist = ndist + 1
                     dis(ndist) = dist
                     jfou(ndist) = jj
                   end if
               endif
   30       continue
            if (ndist .eq. 0) then
               ndist = 1
               dis(1) = distmin
               jfou(1) = jf
            end if
            call DispDist(dis, jfou, j1, ndist)
            goto 100
c           nf = 0
         end if
         if (nf.eq.2) then
            dist = 0.
            j1 = jfou(1)
            j2 = jfou(2)
            do 80 i=1,3
               dist = dist + (xyz(i,j1)-xyz(i,j2))**2
   80       continue
            dist = sqrt(dist)
            write (Message,200) Lab(j1),Lab(j2),dist
            lMess = 35
            Call PrintMess
            nf = 0
            goto 100
         end if
   60 continue
c
  200 format(' Distance ',a,'- ',a,' = ',f7.4)
c
  100 khead = 0
      ipres = 31
      jpres = 52
      return
  300 format(' Sorry ....   Wrong selection !')
      end
C -----------------------------------------------------------------
      SUBROUTINE DispDist(dis, jfou, j1, ndist)
c
      IMPLICIT REAL *4 (M)
c
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      common/xwi/ color,xo,yo,khead,Species,NumSpec,iHCopy,ipres,jpres
      common /buffer/ ixv(100),iyv(100),dummr(315)
      common /mess/ Message,ifMess,lMess
      dimension dis(100), jfou(100)
      character *80 Message, Species(8)*2
      character *5 Lab
      integer *2 color, xo, yo, khead
c
      n = 1
   10 j2 = jfou(n)
      write (Message,200) n,ndist,Lab(j1),Lab(j2),dis(n)
      lMess = 38
      Call PrintMess
      khead = 1
c     ind = 5
      iz = 11
      ipres = 0
      jpres = 0
      call getkey(iz)
      if (iz.eq.0) then
         return
      else
         n = n + iz
         if (n .gt. ndist) n = 1
         if (n .lt. 1) n = ndist
         goto 10
      end if
  200 format (i3,' /',i3,') Dist. ',a,'- ',a,'=',f7.4)
      end
C -----------------------------------------------------------------
      SUBROUTINE CalcAngle
      IMPLICIT REAL*4 (M)
      CHARACTER *1 Lett
      CHARACTER *5 Lab
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      common /mess/ Message,ifMess,lMess
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      character blank,digit*12,card(100)*80,ffile*80
      common /chara/ blank,digit,card,ffile
      common /buffer/ ixv(100),iyv(100),dummr(315)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/xwi/ color,xo,yo,khead,Species,NumSpec,iHCopy,ipres,jpres
      character *80 Message, Species(8)*2
      integer *2 color, xo, yo, khead
      integer X11,Y11, jfou(100)
c
      iscr=0
      nf = 0
      do 60 n = 1, 99
         jfound = 0
         ix = ixv(n)
         if(ix.lt.0) goto 55
         iy = iyv(n)
         idmin = 9999
         DO 50 IJ = NAT , 1 , -1
            if (RS(IJ).lt.0 ) go to 50
            X11 = ipix(1,IJ)
            Y11 = ipix(2,IJ)
            dx= ix - X11
            dy= iy - Y11
            dist = sqrt( dx*dx + dy*dy )
            idist=nint(dist)
            if (idist.le.ipix(3,IJ) .and. RS(IJ).gt.0) then
               if (idist.le.idmin) then
                  idmin = idist
                  jfound= IJ
               endif
            endif
   50    continue
   55    if (jfound.gt.0) then
            nf = nf + 1
            jfou(nf) = jfound
         end if
         if (nf.eq.3) then
            dist = 0.
            j1 = jfou(1)
            j2 = jfou(2)
            j3 = jfou(3)
c
            if (j1.eq.j2 .or. j2.eq.j3 .or. j1.eq.j3) then
               write(Message,300)
               LMess = 35
               ifMess = 1
               goto 100
            end if
c
            nvc = 0
            do 85 j=1, 3, 2
               nvc = nvc + 1
               jj = jfou(j)
               do 80 i=1, 3
                  VV(nvc,i) = xyz(i,jj) - xyz(i,j2)
   80          continue
   85       continue
            Mod1 = sqrt(VV(1,1)**2+VV(1,2)**2+VV(1,3)**2)
            Mod2 = sqrt(VV(2,1)**2+VV(2,2)**2+VV(2,3)**2)
            ModuS = VV(1,1)*VV(2,1)+VV(1,2)*VV(2,2)+VV(1,3)*VV(2,3)
            CosAng = ModuS/(Mod1*Mod2)
            if (CosAng .gt. 0.999999) CosAng = 0.999999
            if (CosAng .lt.-0.999999) CosAng =-0.999999
            Ang = acos(CosAng) * 180. / PI
            write (Message,200) Lab(j1),Lab(j2),Lab(j3),Ang
            ifMess = 1
            lMess = 38
            nf = 0
            goto 100
         elseif (ix .lt. 0) then
            write(Message,300)
            LMess = 35
            ifMess = 1
            goto 100
         end if
   60 continue
c
  200 format(' Angle ',a,'- ',a,'- ',a,' = ',f6.1)
  300 format(' Sorry ....   Wrong selection !')
c
  100 khead = 1
      ipres = 31
      jpres = 53
      return
      end
C -----------------------------------------------------------------
      SUBROUTINE AddDelBonds(iAction, NatInd)
      IMPLICIT REAL*4 (M)
      CHARACTER *1 Lett
      CHARACTER *5 Lab
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      COMMON /Leg1/ LE1(800,2),nLegInd
      common /mess/ Message,ifMess,lMess
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      character blank,digit*12,card(100)*80,ffile*80
      common /chara/ blank,digit,card,ffile
      common /buffer/ ixv(100),iyv(100),dummr(315)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/xwi/ color,xo,yo,khead,Species,NumSpec,iHCopy,ipres,jpres
      character *80 Message, Species(8)*2
      integer *2 color, xo, yo, khead
      integer X11,Y11, jfou(100)
c
      NumAD = 0
      nf = 0
      do 60 n = 1, 99
         jfound = 0
         ix = ixv(n)
         if(ix.lt.0) goto 55
         iy = iyv(n)
         idmin = 9999
         DO 50 IJ = NAT, 1 , -1
            if ( RS(IJ).lt.0 ) go to 50
            X11 = ipix(1,IJ)
            Y11 = ipix(2,IJ)
            dx= ix - X11
            dy= iy - Y11
            dist = sqrt( dx*dx + dy*dy )
            idist=nint(dist)
            if (idist.le.ipix(3,IJ) .and. RS(IJ).gt.0) then
               if (idist.le.idmin) then
                  idmin = idist
                  jfound= IJ
               endif
            endif
   50    continue
   55    if (jfound.gt.0) then
            nf = nf + 1
            jfou(nf) = jfound
         else
            nf = 0
            goto 100
         end if
         if (nf.eq.2) then
            j1 = jfou(1)
            j2 = jfou(2)
            if (j1.eq.j2) goto 95
            NumAD = NumAD + 1
            if (iAction.eq.631) then
               do 70 i = NumLeg, NumLeg - nlp + 1, -1
                  LE(i + 1, 1) = LE(i, 1)
                  LE(i + 1, 2) = LE(i, 2)
   70          continue
               NumLeg = NumLeg + 1
               LE(NumLeg - nlp, 1) = j1
               LE(NumLeg - nlp, 2) = j2
               IF (NumLeg .EQ. nMaxLeg) goto 100
            else
               do 90 nll = 1, NumLeg
                  if(LE(nll, 1).eq.j1 .and. LE(nll, 2).eq.j2 .or.
     *               LE(nll, 1).eq.j2 .and. LE(nll, 2).eq.j1 )  then
                     if (nll.lt.NumLeg) then
                        do 80 i = nll + 1, NumLeg
                           LE(i-1, 1) = LE(i, 1)
                           LE(i-1, 2) = LE(i, 2)
   80                   continue
                     end if
                     NumLeg = NumLeg - 1
                     goto 95
                  end if
   90          continue
            end if
   95       nf = 0
         end if
   60 continue
c
  200 format(i4,'  bond(s) have been added  ')
  300 format(i4,'  bond(s) have been deleted')
c
  100 if (iAction.eq.631) then
         write(Message,200) NumAD
      else
         write(Message,300) NumAD
      end if
      IfMess = 1
      LMess = 32
c
      khead = 1
      ipres = 31
      if (iAction.eq.631) then
         jpres = 57
      else
         jpres = 58
      end if
      if (NAT .eq. NatInd) then
         do 170 i = 1, NumLeg
            LE1(i, 1) = LE(i, 1)
            LE1(i, 2) = LE(i, 2)
  170    continue
         nLegInd = NumLeg
      end if
      return
      end
C -----------------------------------------------------------------
      SUBROUTINE TorsAngle
      IMPLICIT REAL*4 (M)
      CHARACTER *1 Lett
      CHARACTER *5 Lab
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      common /mess/ Message,ifMess,lMess
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      character blank,digit*12,card(100)*80,ffile*80
      common /chara/ blank,digit,card,ffile
      common /buffer/ ixv(100),iyv(100),dummr(315)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/xwi/ color,xo,yo,khead,Species,NumSpec,iHCopy,ipres,jpres
      character *80 Message, Species(8)*2
      integer *2 color, xo, yo, khead
      integer X11,Y11, jfou(100)
c
      nf = 0
      do 60 n = 1, 99
         jfound = 0
         ix = ixv(n)
         if(ix.lt.0) goto 55
         iy = iyv(n)
         idmin = 9999
         DO 50 IJ = NAT, 1 , -1
            if ( RS(IJ).lt.0 ) go to 50
            X11 = ipix(1,IJ)
            Y11 = ipix(2,IJ)
            dx= ix - X11
            dy= iy - Y11
            dist = sqrt( dx*dx + dy*dy )
            idist=nint(dist)
            if (idist.le.ipix(3,IJ) .and. RS(IJ).gt.0) then
               if (idist.le.idmin) then
                  idmin = idist
                  jfound= IJ
               endif
            endif
   50    continue
   55    if (jfound.gt.0) then
            nf = nf + 1
            jfou(nf) = jfound
         else
            nf = -1
            goto 100
         end if
         if (nf.eq.4) then
            j1 = jfou(1)
            j2 = jfou(2)
            j3 = jfou(3)
            j4 = jfou(4)
            if (j1.eq.j2 .or. j2.eq.j3 .or. j3.eq.j4) then
               nf = -1
               goto 100
            end if
c
c--- Calcola i vettori V1, V2 e V3
c
            do 80 i = 1, 3
               do 70 j = 1, 3
                  VV(i, j) = xyz(j, jfou(i+1)) - xyz(j, jfou(i))
   70          continue
   80       continue
c
c--- Calcola gli angoli V1^V2 e V2^V3
c
            ModuA = sqrt(VV(1,1)**2+VV(1,2)**2+VV(1,3)**2)
            ModuB = sqrt(VV(2,1)**2+VV(2,2)**2+VV(2,3)**2)
            ModuS = VV(1,1)*VV(2,1)+VV(1,2)*VV(2,2)+VV(1,3)*VV(2,3)
            CosAng = ModuS/(ModuA*ModuB)
            if (CosAng .gt. 0.999999) CosAng = 0.999999
            if (CosAng .lt.-0.999999) CosAng =-0.999999
            AngG = acos(CosAng)
            SinG = sin(AngG)
c
            ModuC = sqrt(VV(3,1)**2+VV(3,2)**2+VV(3,3)**2)
            ModuS = VV(2,1)*VV(3,1)+VV(2,2)*VV(3,2)+VV(2,3)*VV(3,3)
            CosAng = ModuS/(ModuB*ModuC)
            if (CosAng .gt. 0.999999) CosAng = 0.999999
            if (CosAng .lt.-0.999999) CosAng =-0.999999
            AngA = acos(CosAng)
            SinA = sin(AngA)
c
c--- Calcola le componenti dei prodotti vettoriali V1 x V2, V2 x V3
c   ( V4 e V5 )
c
            do 180 i = 2, 3
               VV(2+i,1) = VV(i-1,2)*VV(i,3) - VV(i-1,3)*VV(i,2)
               VV(2+i,2) =-VV(i-1,1)*VV(i,3) + VV(i-1,3)*VV(i,1)
               VV(2+i,3) = VV(i-1,1)*VV(i,2) - VV(i-1,2)*VV(i,1)
  180       continue
c
c--- Calcola il prodotto scalare V4 . V5
c
            ModuS = VV(4,1)*VV(5,1)+VV(4,2)*VV(5,2)+VV(4,3)*VV(5,3)
c
            ModuB = ModuB * ModuB
            CosAng = ModuS / (ModuA*ModuB*ModuC*SinA*SinG)
            if (CosAng .gt. 0.999999) CosAng = 0.999999
            if (CosAng .lt.-0.999999) CosAng =-0.999999
            Ang = acos(CosAng) * 180. / PI
            goto 100
c
         end if
   60 continue
c
  200 format(' Torsion angle ',a,'- ',a,'- ',a,'- ',a,' =',f6.1)
  300 format(' Sorry ....   Wrong selection !')
c
  100 if (nf.lt.0) then
         write(Message,300)
         LMess = 35
      else
         write(Message,200) Lab(j1),Lab(j2),Lab(j3),Lab(j4),Ang
         LMess = 50
      end if
      IfMess = 1
      khead = 1
      ipres = 31
      jpres = 54
c
      return
      end
C -----------------------------------------------------------------
      SUBROUTINE NumTable(iz)
      IMPLICIT REAL*4 (M)
      CHARACTER *1 Lett, nt1
      CHARACTER *5 Lab
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      common /mess/ Message,ifMess,lMess
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      COMMON /GeneraC/ DePA, DeMA, DePB, DeMB, DePC, DeMC,
     *                 RB(3, 3, 48), T(3, 48),
     *                 Shf(3, 3), Tra(3, 20), nsy, NatInd, nt1
      common /buffer/ ixv(100),iyv(100),kpointer(200),dummr(115)
      common /screen/ kscreen,iy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      common /scale/ x11scale(2),x11disp(2),ragmed,deltax,deltay
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common/xwi/ color,xo,yo,khead,Species,NumSpec,ihcopy,ipres,jpres
      character *80 Message, Species(8)*2
      integer *2 color, xo, yo, khead
c
      npointer = 0
      do 2 i=1,NatInd
         if (RS(i).gt.-10.0) then
                               npointer = npointer + 1
                               kpointer(npointer) = i
                             endif
    2 continue
      j=1
      do 5 i=1,20
         Message(j:j+3) = '    '
         j = j + 4
    5 continue
c
      call NewPage
      ixp = 10
      iyp0= deltay + 30
      iyp = iyp0
      ini = 1
      NumPerPag = 0
      npp = 0
      npl = 0
   15 write(Message,18)
   18 format('Atom  Height    B       Atom  Height    B       Atom  H'
     *,'eight    B  ')
      call SetColr(10)
      ind = 9
      ixv(1)= ixp
      iyv(1)= iyp
      iz = 65
      call graphs(ixv, iyv, iz, ind, Message, iot)
      iyp = iyp + 30
      call SetColr(7)
      Message = ' '
      do 20 iii = ini, npointer
         i = kpointer(iii)
         if (npp .eq. 0) NumPerPag = NumPerPag + 1
CCC      if (RS(i) .gt. -10.) then
            is = npl * 24 + 2
            npl = npl + 1
            write(Message(is:is+18),100) Lab(i),x(4,i),bfac(i)
CCC      end if
c        write(Message,100) Lab(i),x(4,i),bfac(i),
c    *         Lab(i+1),x(4,i+1),bfac(i+1),Lab(i+2),x(4,i+2),bfac(i+2)
c 100    format(2(a5,f7.0,f7.3,4x),a5,f7.0,f7.3)
  100    format(a5,f7.0,f7.3)
CCC      if (npl.eq.3 .or. i.eq.NatInd) then
         if (npl.eq.3 .or. iii.eq.npointer) then
            npl = 0
            ind = 9
            ixv(1)= ixp
            iyv(1)= iyp
            iz = 68
            call graphs(ixv, iyv, iz, ind, Message, iot)
            j=1
            do 25 id=1, 20
               Message(j:j+3) = '    '
               j = j + 4
   25       continue
            iyp = iyp + 25
CCC         if (iyp.gt.kscry-35 .or. i.eq.NatInd) then
            if (iyp.gt.kscry-35 .or. iii.eq.npointer) then
c              if (NumPerPag .eq.0) NumPerPag = i + 2
               npp = 1
               ifine = i
               khead = 1
               iz = 12
CCC            if (NumPerPag .ge. NatInd) iz = 13
               if (NumPerPag .ge. npointer) iz = 13
               ipres = 0
               jpres = 0
               call getkey(iz)
               if (iz.eq.0 .or. iz.eq.2) then
                  return
               else
  222             if (iz.lt.0) then
                     np = 0
  333                if (ini-np.gt.1) np = np + 1
CCC                  if (RS(ini - np) .gt. -10.) then
                        if (np.eq.NumPerPag .or. ini-np.eq.1) goto 444
                        goto 333
CCC                  end if
  444                ini = ini - np
                  else
                     ini = ifine + 1
  555                if (mod(ini-1,3).ne.0) then
                        ini = ini+1
                        goto 555
                     end if
CCC                  if (ini.gt.NatInd) then
                     if (ini.gt.npointer) then
                                          iz = -1 
                                          goto 222
                                        endif
                  end if
                  call NewPage
                  iyp = iyp0
                  goto 15
               end if
            end if
         end if
   20 continue
      return
      end
C -----------------------------------------------------------------
      SUBROUTINE Histogr(iz)
      IMPLICIT REAL*4 (M)
      CHARACTER *1 Lett, nt1
      CHARACTER *5 Lab
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      common /mess/ Message,ifMess,lMess
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      COMMON /GeneraC/ DePA, DeMA, DePB, DeMB, DePC, DeMC,
     *                 RB(3, 3, 48), T(3, 48),
     *                 Shf(3, 3), Tra(3, 20), nsy, NatInd, nt1
      common /buffer/ ixv(100),iyv(100),dummr(315)
      common /screen/ kscreen,iy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      common /scale/ x11scale(2),x11disp(2),ragmed,deltax,deltay
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common/xwi/ color,xo,yo,khead,Species,NumSpec,ihcopy,ipres,jpres
      character *80 Message, Species(8)*2
      integer *2 color, xo, yo, khead
c
      Message(1:5) = '     '
c
      call NewPage
      Max = -999.
      MaxB = -999.
      NatV=0
      do 10 i = 1, NatInd
         if (RS(i) .gt. -10.) then
            NatV = NatV + 1
            if (x(4,i).gt.Max) Max = x(4,i)
            if (bfac(i).gt.MaxB) MaxB = bfac(i)
         end if
   10 continue
      if (abs(Max).le.0.0001) Max = 1.
c
   12 ixp = deltax + 5
      ixpi = ixp
      iyp = kscry - 30
      iypm = deltay + 10
      ini = 1
      NumPerRig = NatV
      nRig = 1
      Larg = (kscrx - deltax) / NumPerRig
      if (Larg .lt.10) then
         NumPerRig = NumPerRig /2
         Larg = (kscrx - deltax) / NumPerRig
         nRig = 2
         iyp = (kscry - deltay - 60) / 2
      end if
      Larg1 = .75 * Larg
      if (Larg .eq. Larg1) Larg1 = Larg - 1
      call SetColr(7)
      ix1 = deltax
      call Linea(ix1,iyp,kscrx,iyp,7)
      do 15 i=1,3
         iypp = iyp + i * (iypm - iyp) / 4
         do 14 np=deltax, kscrx, 5
            ix2 = np + 2
            call Linea (np,iypp,ix2,iypp,7)
   14    continue
   15 continue
      nfatti = 0
      do 20 i = 1, NatInd
         if (RS(i).le.-10.) goto 20
         nfatti = nfatti + 1
         if (nfatti . eq. NumPerRig + 1) then
            iypm = iypm + iyp
            iyp = iypm + iyp
            ixp = ixpi
            call Linea(ix1,iyp,kscrx,iyp,7)
            do 18 j=1,3
               iypp = iyp + j * (iypm - iyp) / 4
               do 16 np=deltax, kscrx, 5
                  ix2 = np + 2
                  call Linea (np,iypp,ix2,iypp,7)
   16          continue
   18       continue
         end if
         AltInPix = nint(abs((x(4,i))/Max) * (iypm - iyp))
         if (AltInPix .gt. -1) AltInPix = 0.03 * (iypm-iyp)
         ixv(1) = ixp
         iyv(1) = iyp
         ixv(2) = ixp
         iyv(2) = iyp + AltInPix
         ixv(3) = ixp + Larg1
         iyv(3) = iyp + AltInPix
         ixv(4) = ixp + Larg1
         iyv(4) = iyp
         ixv(5) = ixv(1)
         iyv(5) = iyv(1)
         ind = 13
         iot = iCol(i)
         iz = 5
         call graphs(ixv, iyv, iz, ind, Message, iot)
c-- fill !!!
         ind = 14
         call graphs(ixv, iyv, iz, ind, Message, iot)
         ixp = ixp + Larg
   20 continue
c
         khead = 1
         iz = 13
         ipres = 0
         jpres = 0
         call getkey(iz)
         if (iz.eq.0 .or. iz.eq.2) then
            return
         else
            call NewPage
            goto 12
         end if
      return
      end
C -----------------------------------------------------------------
      SUBROUTINE PrintMess
      common /mess/ Message,ifMess,lMess
      character *80 Message
      common /buffer/ ixv(100),iyv(100),dummr(315)
c
      icolor=14
      call SetColr(icolor)
      ind = 15
      iz = min0(lMess+1,80)
      Message(iz:iz)=char(0)
      call graphs( ixv,iyv,lMess,ind,Message,icolor)
      ifMess=0
c
      return
      end
c-----------------------------------------------------------------------
      SUBROUTINE zflush
      character*80 string
      common /buffer/ ixv(100),iyv(100),dummr(315)
c* *ind == 7 : xflush
      ind=7
      icolor=1
      call SetColr(icolor)
      call graphs(ixv,iyv,iz,ind,string,icolor)
c
      return
      end
c-----------------------------------------------------------------------
      SUBROUTINE getkey(iz)
      character string*80, Species(8)*2
      common /buffer/ ixv(100),iyv(100),dummr(315)
      common/xwi/ color,xo,yo,khead,Species,NumSpec,iHCopy,ipres,jpres
      integer *2 color, xo, yo, khead
c
c* *ind == 5 : eventloop (mouse)
      ind=5
      icolor=1
      if (if_mouse_there().eq.1) then 
      call graphs(ixv,iyv,iz,ind,string,icolor)
                               else 
                                 iz=0
                               endif 
c
      return
      end
c-----------------------------------------------------------------------
      SUBROUTINE CreaLab(i,lnz,Labb)
      CHARACTER *5  Lab, Labb
      CHARACTER *6  Buffer
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,kat,f(9),nalf(8)
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      common /neutro/ neutro,bmat(2,98),neuwei,vetint(200)
      common /screen/ kscreen,iy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      common/xwi/ color,xo,yo,khead,Species,NumSpec,ihcopy,ipres,jpres
      character  Species(8)*2
      integer *2 color, xo, yo, khead
c
      Buffer = '      '
      if (lnz.ne.0) then
         if (mod(kprog,10) .lt. 3) then
             write(Buffer(1:2),'(a2)') nalf(lnz)
         else
             Buffer(1:2) = Species(lnz)
         end if
      else
         Buffer(1:2)='Q '
      endif
      sg=1.0
      if(neutro.gt.0.and.lnz.gt.0) sg=x(4,i)*bs(1,lnz)
      if(sg.lt.0.0) then
                      write(Buffer(1:2),'(a2)') 'nl'
                    else
      call ucase(Buffer(1:1))
                    endif
      if (Buffer(2:2).eq.' ') then
         k=2
      else
         if (i.le.999) then
            k=3
         else
            Buffer(1:1)='X'
            k=2
         endif
      endif
      write(Buffer(k:k+3),'(i4)') i
      call xcmprp(Buffer,lstri)
      Labb=Buffer(1:lstri)
c
      return
      end
c-----------------------------------------------------------------------
      SUBROUTINE ModCom(jrest0)
c
      CHARACTER *5  Lab
      CHARACTER *1 Lett, nt1
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , KR(4), VV(10,3), LE(800,2), RI(3)
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /GeneraC/ DePA, DeMA, DePB, DeMB, DePC, DeMC,
     *                 RB(3, 3, 48), T(3, 48),
     *                 Shf(3, 3), Tra(3, 20), nsy, NatInd, nt1
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,natsir,f(9),nalf(8)
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /xdata/ store(244000)
      common /temp/  conn(9800)
      dimension B(3, 3)
c
c     NAT = NATind
      call SoloInd(B,NATind)
c
c-- update atoms
c
      j=0
      ndel = 0
      do 200 i=1,nats
         if (RS(i).lt.-10.0) then
            ndel = ndel +1
            MLU(i) = 0
         else
            MLU(i) = i - ndel
            j = j + 1
            nz(j) = nz(i)
            bfac(j) = bfac(i)
            do 100 k = 1 , 5
               x(k,j) = x(k,i)
  100       continue
         endif
  200 continue
c
      nats = j
c
c-- update connectivity
c
      NLeg = NumLeg - nlp
c
      k=0
      do 300 j=1,NLeg
         le1=LE(j,1)
         le2=LE(j,2)
         if (MLU(le1).gt.0 .and. MLU(le2).gt.0) then
c             if (le1.eq.iequi(le1) .and. le2.eq.iequi(le2)) then
                 k=k+1
                 LE(k,1) = MLU(le1)
                 LE(k,2) = MLU(le2)
c             end if
         endif
  300 continue
c
      NLeg = k
c
      j=1
      conn(1)=NLeg
      do 400 i=1,NLeg
         do 400 k=1,2
            j=j+1
            conn(j)=LE(i,k)
  400 continue
c
      jrest=jrest0
      interp=1
      call frm15(nats,numset,interp)
      call cp1530
c
      return
      end
C ----------------------------------------------------------------------
      SUBROUTINE ReGro
c
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      common /atomo/ xyzo(5,200),nzo(200),dold(400)
      common/sf/al(4,8),bs(4,8),cl(8),nnw(8),nno(8),nk,nat,f(9),nalf(8)
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,nonos,iprin,iflag
C     *            ,jmpsie,ipripe
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/inpcl/ntype,ttype(10,5),nprojx,nbond,dmaxi,radnew(8)
      dimension izpk(500)
c
      nbond=1
c
c-- regroup the molecule.
c
      kact=5
      call maincl(izpk,kact,iprin)
c
c-- save atom list for future use
c
      interp=1
      call frm15(nats,numset,interp)
c
      return
      end
C -----------------------------------------------------------------
      SUBROUTINE Traslate (iAction)
c
      CHARACTER *1 Lett
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
c
      Rmin1 = Xmin
      Rmin2 = Ymin
      RMax1 = XMax
      RMax2 = YMax
      D1 = (RMAX1 - Rmin1) / 10
      D2 = (RMAX2 - Rmin2) / 10
      IF (iAction.EQ.13) then
         Rmin1 = Rmin1 + D1
         RMax1 = RMax1 + D1
      else IF (iAction.EQ.14) then
         Rmin1 = Rmin1 - D1
         RMax1 = RMax1 - D1
      else IF (iAction.EQ.15) then
         Rmin2 = Rmin2 + D2
         RMax2 = RMax2 + D2
      else IF (iAction.EQ.16) then
         Rmin2 = Rmin2 - D2
         RMax2 = RMax2 - D2
      else IF (iAction.EQ.17) then
         Rmin1 = Rmin1 - D1
         RMax1 = RMax1 + D1
         Rmin2 = Rmin2 - D2
         RMax2 = RMax2 + D1
      else IF (iAction.EQ.18) then
         Rmin1 = Rmin1 + D1
         RMax1 = RMax1 - D1
         Rmin2 = Rmin2 + D2
         RMax2 = RMax2 - D2
      end if
      Xmin = Rmin1
      Ymin = Rmin2
      XMax = RMax1
      YMax = RMax2
      CALL SetScale(3)
      RETURN
      END
C -----------------------------------------------------------------
      SUBROUTINE tomolplo1(a,b,c,alf,bet,gam)
      CHARACTER *1 Lett
      CHARACTER *80 Titolo
      CHARACTER *5 Lab
      COMMON /Contr/ NF,iFirstTime,Titolo,Ratio,IfCont,IfEdge,IfScale,
     *               kplty,radii(8), IfScaleB
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      common/rc/p(6),cx(9),dumm(9)
      common /screen/ kscreen,iy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
c
      if (mod(kprog,10) .lt. 3) then
         a   = cx(1)
         b   = cx(2)
         c   = cx(3)
         alf = cx(4)
         bet = cx(5)
         gam = cx(6)
         write(Titolo,'(20a4)') (itle(i),i=1,20)
      else
         read(ln,'(a)') titolo
         read(ln,*) a, b, c, alf, bet, gam
         cx(1) = a
         cx(2) = b
         cx(3) = c
         cx(4) = alf
         cx(5) = bet
         cx(6) = gam
      end if
c
      return
      end
C -----------------------------------------------------------------
      SUBROUTINE tomolplo2
      REAL *4 MLu
      CHARACTER  str2*2,str*80
      CHARACTER *1 Lett,carat,nt1
      CHARACTER *80 Titolo
      CHARACTER *5  Lab, Labb
      COMMON /Contr/ NF,iFirstTime,Titolo,Ratio,IfCont,IfEdge,IfScale,
     *               kplty,radii(8), IfScaleB
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      COMMON /GeneraC/ DePA, DeMA, DePB, DeMB, DePC, DeMC,
     *                 RB(3, 3, 48), T(3, 48),
     *                 Shf(3, 3), Tra(3, 20), nsy, NatInd, nt1
      common/work/rm(3,3), eval(3), evec(3,3), ainer(3,3)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common /atoms/ x(5,200),nz(200),ngp,ninf(10),nag(10)
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      common /tape/ cell(6),neqv,icent,lat,natm,ts(3,24),is(2,3,24),nsym
     *             ,dumb(3)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,kat,f(9),nalf(8)
      common/lst03/l3,m3,md3,n3,l3t,m3t,l3ti,m3ti,l3g,n3g,sys03
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common / data/  store(5000)
      common /temp/  conn(9800)
      common /buffer/ ixv(100),iyv(100),dummr(315)
      common /screen/ kscreen,iy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      common /neutro/ neutro,bmat(2,98),neuwei,vetint(200)
      common/xwi/ color,xo,yo,khead,Species,NumSpec,ihcopy,ipres,jpres
      character  Species(8)*2
      integer *2 color, xo, yo, khead
      dimension x1(3),r(3),ibuff(5000)
      equivalence (store(1),ibuff(1))
c
      nMaxLeg = 800
c
      if (mod(kprog,10) .lt. 3) then
      call yfl03
      m3=l3
      do 5 i= 1,n3
          radii(i) = store(m3+15)
          m3=m3+md3
    5 continue
      if (no(1).eq.1) then
          jlig=1
      else
          jlig=0
      endif
      if (neutro.eq.1) jlig=0
      if (jscreen.eq.1) then
          str=' '
          write(str2,10) nalf(jlig+1)
          call ucase(str2(1:1))
          write(str(1:2),10) str2
   10     format(a2)
          j=3
          iz=nk-jlig
          do 20 i=2,iz
          write(str2,10) nalf(jlig+i)
          call ucase(str2(1:1))
          write(str(j:j+2),30) str2
          j=j+3
   20     continue
   30     format('+',a2)
CHAR      str(j:j)=char(0)
          ind=16
          call graphs( ixv,iyv,iz,ind,str,icolor)
          jscreen = 2
                        endif
c
      idisp = 1
      call sfl15(nats,idisp,numset,interp)
c
      do 50 i = 1, nats
          NAT = i
          knz=nz(i)/100
*          if (knz.eq.0) go to 50
          do 40 j = 1, 3
              x1(j)=x(j,i)
   40     continue
c                                               max
c                                             lung di raggio  1-7
c                                  label  xyz legame  palla  colore
c     read(ic,'(a3,1x,5f10.0,i4)') Lab(i), x, MLu(i), RS(i), iCol(i)
          call molt1(rm,x1,r)
          xyz(1,i) = r(1)
          xyz(2,i) = r(2)
          xyz(3,i) = r(3)
          lnz=iabs(knz)
          call CreaLab(i,lnz,Labb)
          Lab(i)=Labb
          if (knz.ne.0) then
              jnz = lnz
              iCol(i)=lnz - jlig
          else
              jnz = jlig+1
              iCol(i)= 7
          endif
          if(Labb(1:2).eq.'nl') iCol(i)=7
          Rs(i)=radii(jnz) / 3.0
          MLu(i)=2*radii(jnz)+0.3
          iEqui(i) = i
   50 continue
      else
         NumSpec = 0
         read(ln,*) NAT
         do 70 i=1, NAT
            read(ln,'(a5,1x,5f10.0,i4)') Lab(i), x1, MLu(i), RS(i),ic
            x(1,i) = x1(1)
            x(2,i) = x1(2)
            x(3,i) = x1(3)
            call molt1(rm,x1,r)
            xyz(1,i) = r(1)
            xyz(2,i) = r(2)
            xyz(3,i) = r(3)
            iEqui(i) = i
            iCol(i) = ic
            if (RS(i) .lt. 0.11) then
               RS(i) = 0.22
            endif
            carat=Lab(i)(2:2)
            numcar=ichar(carat)
            if (numcar.gt.48 .and. numcar .lt.58) then
               str2 = Lab(i)(1:1) // ' '
            else
               str2 = Lab(i)(1:2)
            end if
            do 60 nc=1, NumSpec
               if (Species(9 - nc).eq.str2 .or. str2.eq.'Q ') goto 70
   60       continue
            NumSpec = NumSpec + 1
            Species(9 - NumSpec) = str2
            Radii(NumSpec) = 3. * RS(i)
   70    continue
         do 75 i=1, NumSpec
            Species(i) = Species(8 - NumSpec + i)
cccccccccc  nalf(i) = Species(i)
            Species(8 - NumSpec + i) = '  '
   75    continue
         read(ln,*) nsy
         nsym = nsy
         do 80 i=1, nsym
            read(ln,*) (T(j,i), j=1,3), ((RB(j,k,i), k=1,3), j=1,3)
   80    continue
         read(ln,'(a)') nt1
      end if
c
      CALL AggiuSpig
c
      NATind = NAT
c
      return
      end
C -----------------------------------------------------------------
      SUBROUTINE topl
      character*80 string
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common /buffer/ ixv(100),iyv(100),dummr(315)
c* *ind == 3 : reset title and menu window
      ind=3
      write(string,'(20a4)') itle
      call graphs(ixv,iyv,iz,ind,string,icolor)
c
      return
      end
C ----------------------------------------------------------------------
      SUBROUTINE defswi
      character*80 string
      CHARACTER *80 Titolo
      COMMON /Contr/ NF,iFirstTime,Titolo,Ratio,IfCont,IfEdge,IfScale,
     *               kplty,radii(8), IfScaleB
      common /buffer/ ixv(100),iyv(100),dummr(315)
c* *ind == 8 : Set Switches to default value
      IfEdge = 0
      IfCont  = 0
      IfScale = 1
      ind=8
      call graphs(ixv,iyv,iz,ind,string,icolor)
c
      return
      end
 
C --------------------------------------------------------------------
      FUNCTION Interno (ix, iy, nv)
      COMMON /buffer/ ixv(100), iyv(100),dummr(315)
      real  m
c
      NumIntD = 0
      NumIntS = 0
      Inter = 0
      do 10 k = 1, nv - 1
          ia = iy - iyv(k + 1)
          IF (ia .ne. 0) THEN
              a1 = iy - iyv(k + 1)
              b1 = iyv(k) - iy
              IF (b1 / a1 .ge. 0.0) THEN
                  IF (iyv(k + 1) .ne. iyv(k)) THEN
                      a = ixv(k + 1) - ixv(k)
                      b = iyv(k + 1) - iyv(k)
                      IF (ABS(b) .gt. .00001) THEN
                          m = a / b
                      ELSE
                          m = 0
                      END IF
                      rix1 = ixv(k) + (iy - iyv(k)) * m
                  ELSE
                      rix1 = ixv(k)
                  END IF
                  IF (rix1 .lt. ix) THEN
                      NumIntS = NumIntS + 1
                  END IF
                  IF (rix1 .gt. ix) THEN
                      NumIntD = NumIntD + 1
                  END IF
              END IF
          END IF
10    continue
      IF (NumIntD .gt. 0) THEN
         IF (INT(NumIntD / 2) * 2 .ne. NumIntD) THEN
            Inter = -1
         END IF
      END IF
      IF (NumIntS .gt. 0) THEN
         IF (INT(NumIntS / 2) * 2 .ne. NumIntS) THEN
            Inter = Inter - 1
         END IF
      END IF
      Interno = Inter
c
      return
      END
C --------------------------------------------------------------------
      SUBROUTINE ChePiano(iScelta)
c
      CHARACTER *1 Lett
      CHARACTER *5 Lab
      CHARACTER *80 Titolo
c
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /work/ rm(3,3), eval(3), evec(3,3), ainer(3,3)
      COMMON /Contr/ NF,iFirstTime,Titolo,Ratio,IfCont,IfEdge,IfScale,
     *               kplty,radii(8), IfScaleB
      common /screen/ kscreen,iy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      DIMENSION B(3, 3)
c
      if (iScelta.ge.1 .and. iScelta .le.3) then
          Call LsPlane(NATV)
          if (NATV.eq.0) then
              return
          end if
          VecX = evec(1, iScelta)
          VecY = evec(2, iScelta)
          VecZ = evec(3, iScelta)
      elseif (iScelta.ge.4 .and. iScelta .le.6) then
          k = NAT + iScelta - 3
          VecX = xyz(1, k) - xyz(1, NAT + 4)
          VecY = xyz(2, k) - xyz(2, NAT + 4)
          VecZ = xyz(3, k) - xyz(3, NAT + 4)
      end if
      if (iScelta .lt. 7) then
          CALL PlaneFound(VecX, VecY, VecZ)
          CALL FindOr(B)
      END IF
c
      return
      end
C -----------------------------------------------------------------
      SUBROUTINE PlaneFound (VecX, VecY, VecZ)
c
      CHARACTER *1 Lett
      CHARACTER *5 Lab
      CHARACTER *80 Titolo
c
      COMMON /Crt/ iBarre(62, 4),Lett(72),NumBar(70), iCheBarre(70, 6)
     2     , Rmin1, Rmin2, RMAX1, RMAX2, XMax, YMax, DDX, DDY, NPX, NPY
     3     , Lim1,Lim2,Lim3,Lim4,PI,Xmin,Ymin,LegCol,nlp, nMaxLeg
     5     , NumLeg, iPlotType , RK(4), VV(10,3), LE(800,2), RI(3)
      COMMON /atomi/ xyz(3,800),NAT, RR(800), iCol(800), iOrd(800),nv,
     *               MLU(800), Lab(800), RS(800), ipix(3,800),iEqui(800)
      COMMON /work/ rm(3,3), eval(3), evec(3,3), ainer(3,3)
      COMMON /Contr/ NF,iFirstTime,Titolo,Ratio,IfCont,IfEdge,IfScale,
     *               kplty,radii(8), IfScaleB
      common /screen/ kscreen,iy,ivd,kscrx,kscry,jscreen,kprog,ifMouse
c
      nRot = 1
      nRTot = 1
      VMod = VecX ** 2 + VecY ** 2
      V1Mod = SQRT(VMod + VecZ ** 2)
      VMod = SQRT(VMod)
      s = VMod / V1Mod
      IF (s .lt. .999) THEN
          Ang = ATAN(s / SQRT(1 - s * s))
          Ang = 180 * Ang / PI
      ELSE
          Ang = 90
      END IF
      if (VecZ .lt. 0) then
          s = -1
      else
          s = 1
      end if
      Ang = s * ABS(Ang)
      RK(1) = Ang
      RK(2) = 4
      RK(3) = 1
      VV(1, 1) = VecY
      VV(1, 2) = -VecX
      VV(1, 3) = 0
      IF (abs(VecX).lt.0.00001 .AND. abs(VecY).lt.0.00001) THEN
          VV(1, 3) = 1
      END IF
c
      return
      end
CRYSTALS CODE FOR PATTER
      subroutine patter(ier)
      character*80 name
      character cff,space*16,laues*5
c
      character blank,digit*12,card(100)*80,ffile*80
      common /chara/ blank,digit,card,ffile
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      common /xdata/ ihkl(31000),e(31000),iphaz(31000),iphb(31000)
     *              ,wt(31000),duma(5000),dummpc(84000)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/c/flgw(30),flgd(30),avr(30),dcv(50),slope,flgk,bt,sc,del,ks
      common /atoms/ xyz(5,200),icvet(200),idumx(21)
      common /erl/ kmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym/isn(2,3,24),tsn(3,24),nnsym,pts,ksys,ncent,latt,s3s2,
     *          emme,s3s2p
      common /ureq1/ jpatt,jpunt(501),ksacc,jseteq,jumpp,jmpsie,nsec
c
      write(cff,'(i1)') kff
      write(lo,10) cff,itle
   10 format(///,a1 ,120('+'),//,
     1 39h patterson routine                     ,68x,14hRelease  93.02
     2 ,//,20x,20a4,/,1h ,120('+'),//,
     *       40x,'***   patterson synthesis section    ***',/)
c++++++
      call srlin (7,lsn,lixx,ljxx,lkxx,llxx)
      if(lixx.gt.0) then
                      call ysfl07(nrifl,mmm,mmmz,npseud,iy)
CORIG                 if (sc.lt.0.0) then
CORIG                                  write(lo,9040)
CORIG                                  ier=-1
CORIG                                endif
                    else
                      ier=-1
                      write(lo,9050)
                    endif
      if (ier.lt.0) return
      itype=1
      iform=2
      jop=jopen(jrel ,name,nlen,itype,iform,ier)
      if (jop.lt.0) go to 9000
      jop=jopen(ifour,name,nlen,itype,iform,ier)
      if (jop.lt.0) go to 9010
c
      call defco(nsize)
      call dirpat(ier)
      if (ier.lt.0) return
      if (sc.lt.0.0.and.jpatt.ne.2) then
                       write(lo,9040)
                       ier=-1
                     endif
c++++++
      call yfl02
c-- modifica degli operatori di simmetria
      do 11 i=1,nnsym
      do 12 j=1,3
      tmat(i,j)=0
   12 continue
   11 continue
      ncent=1
      call musym(kmat,tmat,nnsym,isn,tsn)
      write(space,'(16a1)') nt
      call laue(space,jsys,laues)
      if (jpatt.eq.1) then
                         write(lo,18)
                       else if (jpatt.eq.2) then
                         write(lo,19)
                        else
                         write(lo,20)
                       endif
      write(lo,15) laues
   15 format(48x,' Laue class: ',a5,//)
   18 format(/,48x,' /E/**2 coefficients ')
   19 format(/,48x,' /F/**2 coefficients ')
   20 format(/,48x,' /F/*/E/ coefficients ')
      mode=1
      numb2=0
c     call fft(anat,ccfom,nsize,ier)
      call fft(numb2,mode,anat,ccfom,nsize,ier)
      if (ier.lt.0) return
      write(lo,120) 
  120 format(2h  ,4hpeak,2x,6hheight,5x,1hx,6x,1hy,6x,1hz,3x,6h occ. )
      do 150 i=1,nats
      kk=xyz(4,i)+0.5
      write(lo,140) i,kk,(xyz(j,i),j=1,3),xyz(5,i)
  150 continue
  140 format(i5,i8,2x,3f7.3,f8.4)
      close(jrel )
      close(ifour)
c     call selpat
c-- reset variable jpatt
      jpatt = 0
      return
 9000 continue
      write(lo,9020) ier,jrel
      ier=-1
      return
 9010 continue
      write(lo,9030) ier,ifour
      ier=-1
 9020 format(' *** error ***  open error on scratch file jrel, code ='
     *,i5,',  channel =',i5)
 9030 format(' *** error ***  open error on scratch file ifour, code ='
     *,i5,',  channel =',i5)
 9040 format(' *** error ***  reflections must be normalized.')
 9050 format(' *** error ***  no reflections in direct access file.')
      return
      end
c----------------------------------------------------------------------
      subroutine dirpat(ier)
      character line*80,dire*80,diret*80
      character blank,digit*12,card(100)*80,ffile*80
      common /comdir/ icomq(200,2),maxcom,ipcom,ipdir,icomat
      common /chara/ blank,digit,card,ffile
      common /tran/ scale,mh(3),level,it4,xlim(3)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /sdir/ dm,npc,nproj,nojoin
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common /ureq1/ jpatt,jpunt(501),ksacc,jseteq,jumpp,jmpsie,nsec
      common/spec/ soper(3,4,24),centrt(7,12),aaa(6),noper,ncentr,icent,
     *         kpol,jsys,lat,indv(32),mpv(64),jspini,ddmin,ncawu,ncwu
      dimension vet(40),ivet(40)
c-- set default values
c
      jspini = -1
      iprin=0
      nsec=1
      jmpsie=1
      jpatt=1
      npc=0
      factr= 1.0/3.0
      it4=0
      level = 100
      xlim(1)=1.0
      xlim(2)=1.0
      xlim(3)=1.0
c
      ic=0
      icmax=icomq(icomat,2)
c
  100 continue
      ic=ic+1
      if (ic.gt.icmax) go to 8000
      ipdir=ipdir+1
      line=card(ipdir)
      diret=line
      call cutst(line,lenp,dire,lend)
      call lcase(dire)
      if (dire(1:4).eq.'layy') then
          nsec=1
          go to 100
          endif
      if (dire(1:4).eq.'layx') then
          nsec=2
          go to 100
          endif
      if (dire(1:4).eq.'layz') then
          nsec=3
          go to 100
          endif
      if (dire(1:4).eq.'e**2'.or.dire(1:4).eq.'e*e') then
          jpatt=1
          go to 100
          endif
      if (dire(1:4).eq.'f**2'.or.dire(1:4).eq.'f*f') then
          jpatt=2
          go to 100
          endif
      if (dire(1:3).eq.'f*e'.or.dire(1:3).eq.'e*f') then
          jpatt=3
          go to 100
          endif
      if (dire(1:3).eq.'map' ) then
          it4=lo
          go to 100
          endif
      iopt=0
      call getnum(line,vet,ivet,iv,iopt)
      if (iopt.eq.-1) go to 9000
      if (dire(1:4).eq.'peak') then
          if (iv.ne.1) go to 9000
          npc=ivet(1)
          go to 100
          endif
      if (dire(1:4).eq.'grid') then
          if (iv.ne.1) go to 9000
          factr=vet(1)
          go to 100
          endif
      if (dire(1:4).eq.'prin') then
          if (iv.ne.1) go to 9000
          iprin=ivet(1)
          go to 100
          endif
      if (dire(1:4).eq.'limi') then
          if (iv.ne.3) go to 9000
          do 7500 i=1,3
 7500     xlim(i)=amin1(vet(i),1.0)
          go to 100
          endif
      write(lo,6500) diret
 6500 format(' wrong directive on following line:',/a)
      ier=-1
      return
 8000 continue
      return
 9000 continue
      ier=-1
      write(lo,'(22h error in directive : ,a80)') diret
      return
      end
c--------------------------------------------------------------------
      subroutine laue(space,jsys,laues)
      character space*16,laues*5,string*16,dire*16
c
      if (jsys.le.3) then
                       if (jsys.eq.1) then
                                        laues=' -1  '
                  else if (jsys.eq.2) then
                                        laues=' 2/m '
                  else if (jsys.eq.3) then
                                        laues=' mmm '
                                      endif
                     else
                       string=space 
                       call cutst(string,lens,dire,lend)
c--calcola il numero di operatori
                       nop=1
                       do 40 i=1,3
                       call cutst(string,lens,dire,lend)
                       if (lens.le.0) go to 45
                       nop=nop+1
   40                  continue 
   45                  continue 
           if (jsys.eq.4) then
                if (nop.eq.1) then
                                laues=' 4/m '
                              else 
                                laues='4/mmm'
                              endif
       else if (jsys.eq.5) then
                 j=index(space,'3')
                 if (j.eq.0) then
                  if (nop.eq.1) then
                                   laues=' 6/m '
                                 else 
                                   laues='6/mmm'
                                 endif
                              else 
                     if (nop.eq.1) then
                                      laues='  -3 '
                                    else  
                                      laues=' -3m '
                                    endif 
                                endif
        else          
             if (nop.eq.2) then
                             laues=' m-3 '
                           else 
                            laues=' m-3m'
                           endif
                       endif
                       endif
        return
        end  
CRYSTALS CODE FOR PHASE92
c-- sir code for phase                           Release 92.04
      subroutine contan(ier)
c -----
c           routine  tangente con :  struttura parziale
c                                    fasi pseudo-random
c                                    tangente formula pesata
c -----                              19/06/1987
      character cff
      character blank,digit*12,card(100)*80,ffile*80
      common /chara/ blank,digit,card,ffile
      common /param2/ mkg(500),modul(3)
      common /param/ numb,nant(4),nral,alra,sumalf,ssig,nref,duma
      common /unp/ hmax,kmax,lmax,iplan,irang,iplan2
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngenn
     *,irot(48,48),jsvet(10),isvet(8),nori,imod(3),nss(3)
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common/rc/pippo(6),para(6),dummy(12)
c
      common /partia/e(800),ep(800),kdstor(500),iphp(800),
     * iverbo,imk,gminpa,aksca,ssims,cutpa
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /sup/ ibufr(80,3),bufr(80,2),n,zi,zpi,k,nlist,buf(80),
     *ibuf(80,4),n1,ntrip,idumm1(500),n0,ibu(80,2),bu(80),lcri,
     * nbset,pub(800)
      common /xdata/ imat(3,20000),z(500),iee(20000),iph(41000),
     2 iphaz(500),iorde(500),alfest(500),iz(500),ih(800),e1(800),
     3 limref(500),mkang(800),alfvar(500),ifstor(500),alphac(500),
     4 icont(3),idummy(500),wt(500),zp(500),irefin(500),nn(8),
     5 nbinv(61000),eni1(4),lin1(4,6),dummx(53061)
      common/xdata1/ ish(2,500),itype(500),itab(8000),itab1(8000),
     1 isr(100000),isig(3,8000),inq(3,30000),ntrr,nqq
      common /comdir/ icomq(200,2),maxcom,ipcom,ipdir,icomat
      common / ureq1/ jpatt,jpunt(501),ksacc,jseteq,jumpp,jmpsie,nsec
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      integer hmax,pub
      dimension par(12)
      data par/5.5,4.7,3.2,2.6,2.4,2.2,2.1,2.0,1.9,1.8,1.7,1.7/
c
      write(cff,'(i1)') kff
      write(lo,10) cff,itle
   10 format(///,a1 ,120('+'),//,
     1 22h SIR92 : Phase routine,85x,14hRelease  93.02
     2 ,//,20x,20a4,/,1h ,120('+'),//,
     3 40x,39h***   converge / diverge  section   ***,/)
c
      ilist=15
      call cancella(ilist)
      errem = -1.0
c
      call conver(nb,nrel1,ns1mx,sogs2,ilist,
     *                  nusx,iy,fomin,mxsac,ier,par,
     *                  jproc,jrej)
      if (ier.lt.0) return
      call histor(5,1,ier)
      if (ier.lt.0) return
      call punts1
      if (jrej.eq.0) then
                       ksav=jpunt(501)
                       jpunt(501)=0
                     endif
      call tangen(nb,nrel1,ns1mx,sogs2,ilist,
     *            jproc,nusx,iy,fomin,mxsac,ier,par)
      if (ier.lt.0) return
      if (jrej.eq.0) then
                       jpunt(501)=ksav
                     endif
      if (knw.gt.0) call ssfom(pub)
c
      return
      end
c----------------------------------------------------------------------
      subroutine conver(nb,nrel1,ns1mx,sogs2,ilist,
     *                  nusx,iy,fomin,mxsac,ier,par,
     *                  jproc,jrej)
      common /param2/ mkg(500),modul(3)
      common /param/ numb,nant(4),nral,alra,sumalf,ssig,nref,duma
      common /unp/ hmax,kmax,lmax,iplan,irang,iplan2
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
      common /cpseud/ npseud,lpseuv(12),llpse
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngenn
     *,irot(48,48),jsvet(10),isvet(8),nori,imod(3),nss(3)
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /partia/e(800),ep(800),kdstor(500),iphp(800),
     * iverbo,imk,gminpa,aksca,ssims,cutpa
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /cris/ numcri,jcran,maxtri,nstart,muset
      common /sup/ ibufr(80,3),bufr(80,2),n,zi,zpi,k,nlist,buf(80),
     *ibuf(80,4),n1,ntrip,alfran(500),n0,ibu(80,2),bu(80),lcri,
     * nbset,pub(800)
      common /xdata/ imat(3,20000),z(500),iee(20000),iph(41000),
     2 iphaz(500),iorde(500),alfest(500),iz(500),ih(800),e1(800),
     3 limref(500),mkang(800),alfvar(500),ifstor(500),alphac(500),
     4 icont(3),idummy(500),wt(500),zp(500),irefin(500),nn(8),
     5 nbinv(61000),eni1(4),lin1(4,6),iee1(20000),
     6 lim1(501),enil(500,2),bility(50),iphh(500),line(500,6),
     7 jvec(3,500),zph(500),dummx(26010)
      common/xdata1/ ish(2,500),itype(500),itab(8000),itab1(8000),
     1 isr(100000),isig(3,8000),inq(3,30000),ntrr,nqq
      common /use1/ symb(12),symbo(500),nusy(500),inperm(12)
      common /use2/ ipigin(3),icode(200),ifaz20(200),peso(200)
      integer symb,hmax,pub,igin(3),igin2(3)
      dimension ielim(500),par(12),imat1(7,1000)
      equivalence (ielim(1),symbo(1))
c
      vec(x)=amin1(x*(x+0.4807)/((x+0.8636)*x+1.3943),1.0)
c
      do  2 i=1,500
      iorde(i)=0
      z(i)=0.
      zp(i)=0.
      zph(i)=0.
      alfran(i)=0.
      alfest(i)=0.
      wt(i)=0.
   2  continue
      limref(1)=0
      n2cp = 0
c  *********************************************************************
c   lettura informazioni strutturali
c  *********************************************************************
c -----
c     call sub. per lettura lista 2 : simmetria
c -----
      call yfl02
c -----
c     call sub. per lettura preambolo lista 7
c -----
      call ysfl07(nref,numb,num0,npseud,iy)
      hmax=ihx(1)
      kmax=ihx(2)
      lmax=ihx(3)
      call musym(ksmat,tmat,nsym,is,ts)
      call dirpha (nlist,nsymb,sogs2,ns1mx,inpori,norig,
     * inpena,inpfas,igin,ipigin,icode,ifaz20,peso,iperm,inperm,nspec,
     * jtabl,ilist,iy,nusx,fomin,mxsac,
     * ier,jproc,jrej,nneg,nngq)
      if (ier.lt.0) return
      if (jpart.eq.0) then
c  ***************************************************************
c -----
c     call sub. lettura lista 26 : seminvarianti a una fase
c -----
      iprea=-1
      call srlin (26,lsn,lfw,llw,lpb,ll)
      if(lfw.gt.0) then
                     call sflxx(iprea,26,ns1,ns1,ns1p,nxxe,iccd,iee)
                     if (ns1mx.gt.ns1p) ns1mx=ns1p
                   endif
c -----
c     call sub. lettura lista 8 : tripletti positivi
c -----
      iprea=-1
      call srlin (8,lsn,lfw,llwxx,lpbxx,llxx)
      if(lfw) 5817,5817,5819
 5817 write(lo,5818)
 5818 format(//,' ****  error : no triplets calculated    ****',
     *       //,' ****  try with more active reflections ****',//)
      ier=-1
      return
 5819 call sflxx(iprea,8,nxxd,nxxe,numb,ipten,igm,imat)
      if (nxxe.le.0) then
                       write(lo,5818)
                       ier=-1
                       return
                     endif
      if(sogs2.eq.0) sogs2=igm*0.001
                     endif
c **********************************************************************
c   j = puntatore  nel vettore iph
c
      j=1
c   k = puntatore nel vettore iorde
      k=1
c  *********************************************************************
      if ( jpart.ne.0 ) goto 2222
c **********************************************************************
c
c  lettura completa degli ns1 seminv. a una fase
c
c **********************************************************************
c -----
c     call sub. lettura lista 26 : seminvarianti a una fase
c -----
      ns1=0
      iprea=0
      ns1p=0
      call srlin (26,lsn,lfw,llw,lpb,ll)
      if(lfw) 2051,2051,2028
 2028 call sflxx(iprea,26,ns1,ns1,ns1p,nxxe,iccd,iee)
      if(ns1.eq.0) goto 2051
      ns1p=0
      do 2050 i=1,ns1
      if(i.gt.ns1mx) goto 2051
      call unpak3 (iee(i),kod1,kod2,ifaz)
      a1=kod2*0.01
      if(kod1.gt.0) goto 2030
      p1p = vec(2.*a1)
      kod1 = iabs(kod1)
      goto2035
 2030 if(ifaz.ge.12) a1=-a1
      p1p = 0.5*(1.+tanh(a1))
      if(a1.lt.0.) p1p = 1.-p1p
c ***********************************************************
c   controllo momentaneoper eliminazione riflessi sup. a  numb
c  nel caso in cui siano stati calcolati  i seminv
c  in un numero di riflessi maggiore di numb
c ***********************************************************
 2035 if(kod1.gt.numb) goto 2050
      if (iperm.eq.0) go to 2040
      do 2038 ljc=1,iperm
      if (kod1.ne.inperm(ljc)) go to 2038
      write(lo,2037) kod1
 2037 format(/,' ****  warning : reflection with code ',i3,' is a seminv
     1ariant to be used in active way but it will be permuted  ****',/)
      go to 2050
 2038 continue
c ********************************************************************
c
c controllo se un ss1 stimato viene dato come fase nota
c
c *********************************************************************
 2040 if(inpfas.eq.0) goto 2048
      do 2046 jcris=1,inpfas
      if(kod1.eq.icode(jcris)) goto 2050
 2046 continue
 2048 if(iprin.eq.1) write(lo,2049) kod1,a1,p1p,ifaz
 2049 format(1h ,' code=',i8,'  g=',f6.2,'  p+=',f6.2,
     *'  dshift=',i6)
      iorde(k)=kod1
      k=k+1
      ns1p=ns1p+1
      faz=15.*ifaz
      if(faz.eq.0.) faz=360.
c    pongo in zph la fase dei seminvarianti ad una fase
      zph(kod1)=faz
      wt(kod1)=p1p
 2050 continue
c    pongo  in  nsig1 = numero  di  ss1
 2051 nsig1=k-1
      if(inpfas.eq.0) goto 2100
      do 2090 jcris=1,inpfas
      if(icode(jcris).gt.numb) goto 2095
      kod1=icode(jcris)
      if (iperm.eq.0) go to 2060
      do 2058 ljc=1,iperm
      if (kod1.ne.inperm(ljc)) go to 2058
      write(lo,2057) kod1
 2057 format(/,' ****  warning  :  reflection with code ',i3,' has a ',
     1'known phase but it will be permuted  **** ',/)
      go to 2090
 2058 continue
 2060 iorde(k)=kod1
      k= k+1
      if(ifaz20(jcris).eq.0) ifaz20(jcris)=360
      zph(kod1)=ifaz20(jcris)
      wt(kod1)=peso(jcris)
 2090 continue
      goto 2100
 2095 write(lo,2098) icode(jcris)
 2098 format(//,' ***  error  ***  reflexion number',i10,
     *'   out of range ****')
      stop 3333
 2100 if (iprin.eq.2.and.ns1p.ne.0) write(lo,2120) ns1,ns1p
      if (iprin.eq.2.and.ns1p.eq.0) write(lo,2118)
 2118 format(///,10x,' no one phase seminvariants accepted ')
 2120 format(///,10x,i6,' one phase seminvariants read ',i6,
     1 ' of which are used ')
      k2=k-1
c   nsigm1  =  k2  numero di sigma1 + fasi note
      nsigm1= k2
      if(iprin.eq.2) write(lo,2130) (iorde(i),i=1,k2)
 2130 format(//,'  contenuto iorde dopo  lettura seminvarianti',
     */,30(20i4,/))
c -----
c     call sub. lettura lista 27 : seminvarianti a due fasi
c -----
      n2cp =0
      nse2c=0
      is2=sogs2*100
      iprea=0
      call srlin (27,lsn,lfw,llw,lpb,ll)
      if(lfw) 2200,2200,2121
 2121 call sflxx(iprea,27,ns2c,ns2c,ns2cp,nxxe,iccd,imat)
      do 2124 i=1,ns2c
      iee(i)=imat(1,i)
 2124 iee1(i)=imat(2,i)
      if(ns2cp.eq.0) go to 2200
      ns2cp=min0(ns2cp,170)
      if(iprin.eq.1) write (lo,2132)  sogs2
 2132 format(6x,'  list of  two phase seminvariants',
     *' with /alpha/ greater than ',f6.2//)
      do 2150 i=1,ns2cp
      call unpak3(iee1(i),n1,n2,ifaz)
      if(n2.lt.is2) goto 2200
      n2cp=n2cp+1
      nse2c=nse2c+1
      iph(j)=iee(i)
      if(n2.le.600) goto2140
      iee1(i)=((n1+2048)*4096 +2648)*32+ifaz+1
 2140 iph(j+1)=iee1(i)
      call unpak3 (iee(i),n1,n2,ifaz)
      call unpak3(iee1(i),n3,n4,ifaz)
      arg=n4*0.01
      if(iprin.eq.1) write(lo,2145) nse2c,n1,n2,arg,ifaz
 2145 format(10x,i6,')',5x,3(i4,'*'),'  arg=',f8.2,'  dshift=',
     *i5)
      j=j+2
 2150 continue
 2200 n2cp=nse2c
      if(n2cp.ne.0) write(lo,2205) n2cp,sogs2
 2205 format(///,i6,'  two-phase structure seminvariants (with alpha',
     *' greater than ',f5.2,' ) are used in active way'//)
 2222 continue
c -----
c     call sub. lettura lista 8 : tripletti positivi
c -----
      iprea=0
      call sflxx(iprea,8,nxxa,ntrip,numb,ipten,igm,imat)
      do 2224 i=1,ntrip
      iee(i)=imat(1,i)
 2224 iee1(i)=imat(2,i)
      if (nneg.eq.0) go to 2226
c
c ---    NEW NEW NEW  aggiungo ad iee/iee1 i tripletti negativi
c ---    NEW NEW NEW  invertendo il valore del delta-shift
c
c     write(6,*) ' triplette positive =',ntrip
      call srlin (10,lsn,lfw,llw,lpb,ll)
      if (lfw.gt.0) then
                      call sflxx(iprea,10,nxxa,ntrn,idm1,idm2,idm3,imat)
                      ja=ntrip
                      do 2225 i=1,ntrn
                      call unpak3 (imat(2,i),n3,ia,ishift)
                      if (ia.lt.60) go to 2225
                      ia=-ia
                      ja=ja+1
                      ishift =mod(ishift+12 ,24)
                      idm1=((n3+2048)*4096+ia+2048)*32+ishift+1
                      iee(ja)=imat(1,i)
                      iee1(ja)=idm1
 2225                 continue
                      ntrip=ja
c                     write(6,*) ' triplette totali   =',ntrip
                    endif
c
c ---    NEW NEW NEW
c
 2226 continue
c -----
c     call sub. lettura lista 20 : quartetti negativi
c -----
      call srlin (20,lsn,lfw,llw,lpb,ll)
      if(lfw.gt.0) then
         call sflxx(iprea,20,nquar,nquar,nxxd,nxxe,iccd,imat1)
                   endif
      icocc=1
      call refsto(icocc)
      nt=0
      if(ntrip.eq.0) goto 11
      if(jpart.eq.0) goto 8770
      sgp=0.0
      sg=0.0
c -----------------------------------------------------------------
c   variazione stima tripletti in caso di parziale
c -----------------------------------------------------------------
      jbc=0
      snuf1=0.
      snuf2=0.
      sdef1=0.
      sdef2=0.
      do 8768 i=1,ntrip
      call unpak3 (iee(i),n1,n2,ifaz)
      call unpak3 (iee1(i),n3,ia,ifaz)
      if(icent.gt.0) ia=2*ia
      if(ia.gt.2047) ia=2047
      nn1=n1
      nn2=iabs(n2)
      nn3=iabs(n3)
      ifaz1=ifaz*15
      a1=ia*0.01
      sg=sg+a1
c  calcolo fase vera del tripletto per struttura nota
      if (knw.eq.1)  then
                       ifa1=iphaz(nn1)
                       ifa2=iphaz(nn2)
                       ifa3=iphaz(nn3)
                       iphi=ifa1+isign(ifa2,n2)+isign(ifa3,n3)+ifaz1
                       iphi=mod(iphi+36000,360)
                       if(iphi.eq.0) iphi=360
                       snuf1=snuf1+a1*cos(iphi*dtor)
                       sdef1=sdef1+a1
                       costru=cos(iphi*dtor)
                       endif
      iphip=iphp(nn1)+isign(iphp(nn2),n2)+isign(iphp(nn3),n3)+ifaz1
      iphip=mod(iphip+36000,360)
      if(iphip.eq.0) iphip=360
      phi3p=iphip*dtor
      s31=bes(2.*e(nn1)*ep(nn1))
      s32=bes(2.*e(nn2)*ep(nn2))
      s33=bes(2.*e(nn3)*ep(nn3))
      s3=besinv(s31*s32*s33)
      s3=s3*0.5
      sumnum=s3*sin(phi3p)
      sumden=s3*cos(phi3p)+a1
      alfa3=sqrt(sumnum*sumnum+sumden*sumden)
      teta3=rtod*atan2(sumnum,sumden)
      iteta3=teta3+sign(0.5,teta3)
      iteta3=mod(iteta3+3600,360)
      if(iteta3.eq.0) iteta3=360
      if(knw.eq.1) then
                     diff = iabs(iphi-iteta3)
                     snuf2=snuf2 + alfa3 * cos(diff*dtor)
                     sdef2=sdef2 + alfa3
                    endif
      if(alfa3.lt.0.01) alfa3=0.01
      if(alfa3.gt.20.47) alfa3=20.47
      ia=alfa3 * 100.
      sgp=sgp+alfa3
      ifazz=ifaz1-iteta3
      ifaz=mod(ifazz+36000,360)
      if(ifaz.eq.0) ifaz=360
      ifaz=ifaz/15
      iee1(i)=((n3+2048)*4096 + ia +2048)*32 +ifaz +1
 8768 continue
      appa=sgp/sg
      if(knw.eq.1) then
                     fig1=snuf1/sdef1
                     fig2=snuf2/sdef2
                    if(iprin.eq.1) write(lo,8772) appa,fig1,fig2
 8772 format(//5x,'  scale  ',f5.2,'  fom1(k) =',f7.3,' fom2(alfa3) =',
     *  f7.3/)
                  endif
 8770 do 10 i = 1,ntrip
      call unpak3 (iee(i),n1,n2,ifaz)
      call unpak3 (iee1(i),n3,ia,ifaz)
      nn1=n1
      nn2=iabs(n2)
      nn3=iabs(n3)
      ifaz1=ifaz*15
c  calcolo fase vera del tripletto per struttura nota
      if (knw.eq.1)  then
                       ifa1=iphaz(nn1)
                       ifa2=iphaz(nn2)
                       ifa3=iphaz(nn3)
                       iphi=ifa1+isign(ifa2,n2)+isign(ifa3,n3)+ifaz1
                       iphi=mod(iphi+36000,360)
                       if(iphi.eq.0) iphi=360
                       costru=cos(iphi*dtor)
                       endif
      nt=nt+1
      if(jpart.ne.0) then
                        a1=ia*0.01
                        a1=a1/appa
                        if(a1.lt.0.01) a1=0.01
                        if(a1.gt.20.47) a1=20.47
                        ia=a1*100.
                     else
                        if(icent.gt.0) ia=2*ia
                        if(ia.gt.2047) ia=2047
                     endif
      iph(j) = ((n1+2048)*4096+n2+2048)*32
      iph(j+1) = ((n3+2048)*4096 + ia + 2048)*32 + ifaz + 1
      j = j + 2
  10  continue
c
c ---    new new new
c
      if (nngq.eq.0) then
                       nq=0
                     else
      nq=nquar
      if (nquar.eq.0) go to 11
      nq=0
      idum=0
      nquse=min0(200,nquar)
c     nquse=nquar
      do 8882 i = 1,nquse
      call unpak3 (imat1(1,i),nn(1),nn(2),if1)
      call unpak3 (imat1(2,i),nn(3),nn(4),if2)
      call unpak3 (imat1(3,i),l,jg,ifaz)
c     write(lo,*) nn(1),nn(2),nn(3),nn(4),jg,ifaz
      if (jg.lt.40) go to 8882
      if (icent.gt.0) jg=2.*jg
      if (jg.gt.2047) jg=2047
      jg=-jg
      nq=nq+1
      ifaz =mod(ifaz+12 ,24)
      iph(j) = ((nn(1)+2048)*4096+nn(2)+2048)*32
      iph(j+1) = ((nn(3)+2048)*4096+nn(4)+2048)*32
      iph(j+2) = ((idum+2048)*4096+jg+2048)*32+ifaz +1
      j = j + 3
 8882 continue
                    endif
  11  if (nqq.eq.0) go to 12
      do 8883 i = 1,nqq
      call unpak3 (inq(1,i),nn(1),nn(2),if1)
      call unpak3 (inq(2,i),nn(3),nn(4),if2)
      call unpak3 (inq(3,i),l,jg,ifaz)
      if (jg.ge.30) then
      nq=nq+1
      thne1=15*if1+if2
      if (jg.gt.600) jg=600
      if(cos(thne1*dtor).lt.0.0) then
                                   ifaz=mod(ifaz+12,24)
                                   jg=-jg
                                 endif
      iph(j) = ((nn(1)+2048)*4096+nn(2)+2048)*32
      iph(j+1) = ((nn(3)+2048)*4096+nn(4)+2048)*32
      iph(j+2) = ((idum+2048)*4096+jg+2048)*32+ifaz +1
      j = j + 3
                  endif
 8883 continue
  12  continue
c
c ---    new new new
c
c =============== numero totale di relazioni considerate ===========
      nrel = nt+nq+n2cp
      nrel1 = j-1
c     if(iprin.eq.2) write(lo,6020) nrel,nt,nq,n2cp,nrel1, numb
c     write(lo,6020) nrel,nt,nq,n2cp,nrel1, numb
c6020 format(///,' num.tot.  num.sigma2.  num.quar.  ',
c    *'num.seminvariants ',/,2x,i5,7x,i5,7x,i5,5x,i5,
c    * 5x,i5,10x,2i10,//)
c
c   preparation of pointers table
c
      nb1 = numb + 1
      do 100 i = 1,nb1
100   limref(i) = 0
      j = 1
      do 120 i = 1,nrel
      call depacc (0,j,a,ifaz,iw)
      j = j + iw
      do 110 kk = 1,4
      if(nn(kk).eq.0) go to 110
      n1=iabs(nn(kk))+1
      limref(n1) = limref(n1) + 1
110   continue
120   continue
      do 130 i = 1,numb
      limref(i+1) = limref(i+1) + limref(i)
      lim1(i+1) = limref(i+1)
130   continue
      lim1(1) = 0
c
c  storage of the no. of relations for a given reflexion
      j = 1
      do 150 i = 1,nrel
      call depacc (0,j,a,ifaz,iw)
      do 140 kk = 1,4
      if(nn(kk).eq.0) go to 140
      ind=iabs(nn(kk))
      lim1(ind) = lim1(ind) + 1
      ind1= lim1(ind)
      nbinv(ind1) = j
140   continue
      j = j+iw
150   continue
      ntota=0
      do 300 i=1,numb
      n1=0
      n2=0
      lm=limref(i)+1
      ls=limref(i+1)
      if(lm.gt.ls) goto 300
      do 220 ii=lm,ls
      ind=nbinv(ii)
      call depacc (0,ind,a1,ifaz,iw)
c     if (i.eq.2) then
c           write(lo,215) i,(nn(kj),kj=1,4),a1,ifaz
c 215 format(3x,' code =',i5,3x,4i5,e15.8,i5)
c           endif
      if (iw.eq.2) then
                   n1=n1+1
                  else
                   n2=n2+1
                  endif
  220 continue
      ntota=ntota+n2
c     write (lo,280) i,lm,ls,n1,n2
* 280 format(2x,i5,1h),5x,4i8)
  300 continue
cgianluca
      call newpsi1
cgianluca
c
c  chiamata  subroutine group e azzeramento vettore iz
c
      do 152 i=1,numb
  152 iz(i)=0
      call group
      nlist=iabs(nlist)
      do 910 i=1,4
  910 nant(i)=0
      if (inpori.ne.0) go to 914
      do 912 i=1,3
  912 igin(i)=0
c ********************************************************************
c
c    controllo  per struttura parziale e call di xsim e xcon
c
c *******************************************************************
  914 if ( jpart.eq.0 ) goto 6965
      iverbo = 0
      larn = - nral
      ngen = 0
      nany = nsymb - nspec
      norin = 0
      call xsim (nspec,ngen,nany,larn,igin,norin)
      call xcon (nspec,ngen,nany,larn,igin,norin)
c  nsig1 = number  of  one-phase  seminvariants
      nsig1 = 0
c  k2 = number  of  known  phases  for  partial  structures
      k2 = nbset - nsymb - nori
      nsigm1 = k2
      nbset = imk
      goto 1240
 6965 do 354 i=1,numb
  354 if(wt(i).ne.0.) mkang(i)=-mkang(i)
 6021 format(4(i4,'*',i3,2f10.5))
      if(inpena.ne.0) nant(1)=inpena
      k1=0
      if(inpori.eq.0) goto 1104
      if (norig.lt.nori) then
                          write(lo,1001)
 1001 format(/,' *** error *** the number of reflections given in input'
     *       /,'               is not sufficient to fix the origin:',
     *       /,'               the program is interrupted')
                           stop
                         endif
c  variazione  per controllare se i riflessi dati per origine sono accet
      if(iprin.eq.2) write(lo,6969) igin,ipigin
6969  format(5x,'igin', 3i6,'   ipigin',3i6)
      do 1004 i=1,numb
      if(zph(i).ne.0.) goto 1004
      do 1002 jc=1,nori
      if ( i.eq.igin(jc) ) goto 1004
 1002 continue
      mkang(i)=-mkang(i)
 1004 continue
      do 1005 jc=1,nori
 1005 igin2(jc)=igin(jc)
      call origin(jump,0,1,0,igin2)
      if(iprin.eq.2) write(lo,8875) jump,nori,nral,igin2,k
      if(jump.eq.0) goto 1008
      write(lo,1006)
 1006 format(//5x,' ****  warning  :  input reflexions',
     * ' do not properly fix the origin  ****'/)
 1008 do 1009 i=1,numb
      if(zph(i).ne.0.) goto 1009
      mkang(i)=-mkang(i)
 1009 continue
      if(iprin.eq.2) write(lo,6021) (i,mkang(i),zp(i),
     * zph(i),i=1,numb)
      go to 1106
 1104 do 1105i=1,3
 1105 igin(i)=0
 1106 n=0
      if (jtabl.eq.0) go to 909
      if (knw.eq.0) write(lo,905)
      if (knw.ne.0) write(lo,907)
  905 format(////47x,26htable of estimated alpha's//
     * 4(29h  code  h   k   l    E  alpha)//)
  907 format(////47x,26htable of estimated alpha's//
     * 3(41h   code   h   k   l    E   phi   alpha   )//)
  909 continue
      sumalp=0.
      ii=1
      do 1150 i=1,numb
      zi=0.
      alf1=0.
      call inter(ii,i,alf1)
      zi=abs(zi)
      alf1=abs(alf1)
      alfa=zi
      n=n+1
      line(n,1)=i
      ie=ih(i)/500000
      ihh=ih(i)-500000*ie
      enil(n,1)=0.01*ie
      call unpacc(ihh,line(n,2),line(n,3),line(n,4))
      bility(n)=alfa
      if(knw.ne.0) iphh(n)=iphaz(i)
      alfest(i)=alf1
      if(knw.eq.0) goto1120
      if(n.lt.3) goto1130
      if (jtabl.ne.0) write(lo,908) ((line(n,l),l=1,4),enil(n,1),
     * iphh(n),bility(n),n=1,3)
  908 format(3(i6,')',3i4,f6.2,i5,1x,f9.3))
      n=0
      goto 1130
 1120 continue
      if(n.lt.4) go to 1130
      if (jtabl.ne.0) write(lo,906) ((line(n,l),l=1,4),enil(n,1),
     *bility(n),n=1,4)
  906 format(4(i4,')',3i4,f6.2,f6.1))
      n=0
 1130 sumalp=sumalp+alfa
      z(i)=zi
 1150 continue
c  calcolo di alfastimato e alfarandom per figure di merito
      alra=0.
      sumalf=0.
      do 1151 i=1,numb
      alfran(i)=sqrt(alfran(i))
      sumalf=sumalf+alfest(i)
 1151 alra=alra+alfran(i)
      if(n.eq.0) go to 1152
      if(knw.eq.0.and.jtabl.ne.0)
     *write(lo,906)((line(m,l),l=1,4),enil(m,1),bility(m),m=1,n)
      if(knw.ne.0.and.jtabl.ne.0)
     * write(lo,908) ((line(m,l),l=1,4),enil(m,1),iphh(m),
     * bility(m),m=1,n)
 1152 continue
c ************************************************************
c
c   definizione  peso  iniziale  sulla base del valore di alfa estimato
c
c  *********************************************************************
      jcc=0
      ii=5
 2572 do 2574  i=1,numb
      alfran(i)=0.
      alfest(i)=0.
c       riscalamento   alfa  iniziale
      z(i)=z(i)/2
 2574 wt(i)=bes(z(i))
      sumalp=0
      do 2580 i=1,numb
      zi=0.
      alf1=0.
      call inter(ii,i,alf1)
      zi=abs(zi)
      alf1=abs(alf1)
      z(i)=zi
      alfest(i)=alf1
      if(alfest(i).lt.0.0.or.z(i).lt.0.0) write(lo,*) ' ii =',
     *ii,i,alfest(i),z(i)
      sumalp=sumalp+zi
 2580 continue
      alra=0.
      sumalf=0.
      do 2588 i=1,numb
      alfran(i)=sqrt(alfran(i))
      sumalf=sumalf+alfest(i)
 2588 alra=alra+alfran(i)
      jcc=jcc+1
      if(jcc.eq.1) goto 2572
      if(iprin.eq.2)write(lo,4020)(i,z(i),zp(i),mkang(i),wt(i),
     * i=1,numb)
c    ridefinisco zp e z per i seminvarianti ad una fase
      do 3000 i=1,numb
      if(mkang(i).gt.0) goto 3000
      if(wt(i).eq.0) goto 2995
      zp(i)=zph(i)
      z(i)=0.0
      goto 3000
 2995 zp(i)=0.0
 3000 continue
      if(iprin.eq.2) write(lo,4010)
 4010 format(//,' contenuto dei vettori  z  e  zp ',//)
      if(iprin.eq.2) write(lo,4020) (i,z(i),zp(i),mkang(i),wt(i),
     1i=1,numb)
 4020 format(1h ,3(i4,'*',2e12.3,i4,f5.2))
      nelim = numb
c
c   eliminazione riflessi con alfa debole
c
      alfmin=sumalp/(4.*numb)
      a2=alfmin
      ii=4
      do 1155 i=1,numb
      z(i)=abs(z(i))
      if(mkang(i).lt.0) goto 1155
c     if(wt(i).ne.0) go to 1155
      if(z(i).gt.a2) goto 1155
      if((z(i)+0.1).lt.0.) go to 1155
      mkang(i)=-mkang(i)
      mkang(i)=mkang(i)-20
      iorde(nelim) = i
      nelim = nelim -1
      call inter(ii,i,alf1)
 1155 continue
      do 1156 i=1,numb
      if(mkang(i).gt.0) goto  1156
      if(zp(i).gt.0)  goto 1156
      wt(i)=0
 1156 continue
      if(iprin.eq.2) write(lo,4030)
 4030 format(//,'  contenuto dei vettori z  e  zp dopo aver',
     * '  eliminato i riflessi con alfa troppo basso '//)
      if(iprin.eq.2) write(lo,4020) (i,z(i),zp(i),mkang(i),wt(i),
     * i=1,numb)
          icontr=0
          if (nsymb.gt.nelim) then
                                nsymb=nelim
                                icontr=1
                                go to 1240
                             endif
c     ngen contiene il numero inziale di riflessi di tipo
c     generale scelti per la definizione dell'origine
      nord=0
      do 1158 i=1,numb
 1158 symbo(i)=1.0e+20
      ngen=nral
      if(inpori.ne.0) goto 1240
      ial =1
 1160 larn=-nral
      call origin(jump,0,ial,0,igin)
      if(iprin.eq.2) write(lo,8875) jump,nori,nral,igin,k
 8875 format(' jump=',i4,i6,i6,' igin=',3i8,10x,'  k  ',i8)
      if(larn.gt.0) goto 1162
      if(jump.eq.0) goto 1240
 1162 if(nral.eq.nori)go to 1220
      nral=nral+1
      go to 1160
 1220 nori=0
      write(lo,1225)
 1225 format(/,' ****  warning : the origin can not be fixed correctly',
     1'  ****')
      nsymb=nsymb+2
      nsymb=min0(nsymb,12)
          if (nsymb.gt.nelim) then
                                nsymb=nelim
                                icontr=1
                               else
                                if (jcran.eq.0) write(lo,1226)
                               endif
 1226 format(/,' **** the number of selected symbols will be increased',
     1'  ****')
 1240 call histor(3,nsymb,ier)
      if(ier.lt.0) return
      call con2 (nb,nrel1,ns1mx,sogs2,ilist,icontr,
     * nusx,iy,fomin,mxsac,ier,k2,nsigm1,igin,
     * nsymb,nelim,ngen,nsig1,iperm,inpori,inpena,nspec,inpfas,nrel,par)
      return
      end
c----------------------------------------------------------------------
      subroutine con2(nb,nrel1,ns1mx,sogs2,ilist,icontr,
     *           nusx,iy,fomin,mxsac,ier,k2,nsigm1,
     *           igin,nsymb,nelim,ngen,nsig1,iperm,inpori,inpena,
     *           nspec,inpfas,nrel,par)
      common /param2/ mkg(500),modul(3)
      common /param/ numb,nant(4),nral,alra,sumalf,ssig,nref,duma
      common /unp/ hmax,kmax,lmax,iplan,irang,iplan2
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /cpseud/ npseud,lpseuv(12),llpse
      common /erl/ ksmat(48,3,3),tmat(48,3),nto(16),jsys,ngenn
     *,irot(48,48),jsvet(10),isvet(8),nori,imod(3),nss(3)
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common /partia/e(800),ep(800),kdstor(500),iphp(800),
     * iverbo,imk,gminpa,aksca,ssims,cutpa
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /sup/ ibufr(80,3),bufr(80,2),n,zi,zpi,k,nlist,buf(80),
     *ibuf(80,4),n1,ntrip,alfran(500),n0,ibu(80,2),bu(80),lcri,
     * nbset,pub(800)
      common /xdata/ imat(3,20000),z(500),iee(20000),iph(41000),
     2 iphaz(500),iorde(500),alfest(500),iz(500),ih(800),e1(800),
     3 limref(500),mkang(800),alfvar(500),ifstor(500),alphac(500),
     4 icont(3),idummy(500),wt(500),zp(500),irefin(500),nn(8),
     5 nbinv(61000),eni1(4),lin1(4,6),iee1(20000),
     6 lim1(501),enil(500,2),bility(50),iphh(500),line(500,6),
     7 jvec(3,500),zph(500),dummx(26010)
      common /use1/ symb(12),symbo(500),nusy(500),inperm(12)
      common /use2/ ipigin(3),icode(200),ifaz20(200),peso(200)
      common /cris/ numcri,jcran,maxtri,nstart,muset
      character rescha(13)*9,linex(500)*9
      integer symb,hmax,pub,igin(3)
      dimension par(12),ielim(500)
      equivalence (ielim(1),symbo(1))
      data klist/0/, numph/500/
      data ibl/1h /,ias/1h*/
      data rescha/'   any   ','         ','  30,210 ','  45,225 ',
     *'  60,240 ','         ','  90,270 ','         ',' 120,300 ',
     *' 135,315 ',' 150,330 ','         ','   0,180 '/
c   ==========================================================
c   ricerca  alfa minimo
c  ===========================================================
      ii=2
      do 1158 i=1,numb
 1158 symbo(i)=1.0e+20
      nord=0
      if(jpart.ne.0) goto 1319
 1240 do 1230 j=1,numb
      if(mkang(j).lt.0) goto 1230
      if(wt(j).eq.0.and.mkang(j).lt.0) goto 1230
      wt(j)=bes(z(j))
 1230 continue
      alfmin=1.0e10
      do 1270 j=1,numb
      if(mkang(j).lt.0) go to 1270
      if(z(j).eq.-1.)go to 1270
      alfa=z(j)
      if(alfa.ge.alfmin)go to 1270
      i=j
      alfmin=alfa
 1270 continue
      if(alfmin.gt.0.9e10)go to 1320
      nord=nord+1
      mkang(i)=mkang(i)+20
      mkang(i)=-mkang(i)
c     test per vedere se un riflesso e' stato scelto
c     precedentemente per origine
      do 1280 j=1,nori
      if(igin(j).eq.i)go to 1290
 1280 continue
      go to 1295
 1290 if(inpori.ne.0) goto 1295
      larn=-nral
      ial=1
      call origin(jump,0,ial,0,igin)
      if(iprin.eq.2) write(lo,8875) jump,nori,nral,igin,k
 8875 format(' jump=',i4,i6,i6,' igin=',3i8,10x,'  k  ',i8)
      if(jump.eq.0)go to 1295
      iorde(k)=i
      k=k+1
      mkang(i)=mkang(i)+20
      mkang(i)=-mkang(i)
      z(i)=-1.0
      j=mkang(i)-1
      if(mod(j,12).eq.0)  j=24
      zp(i)=j*15
      go to 1240
c    memorizzazione per scelta simboli
 1295 symbo(i)=10.0*alfmin/float(nord)
      nusy(i)=i
      ii=2
c    scrittura mappa di convergenza
      if(iprin.eq.2) write(lo,1301) i,alfmin,mkang(i)
 1301 format(3x,i5,f10.2,i5)
      iorde(nelim) = i
      nelim = nelim -1
      call inter(ii,i,alf1)
      alf1=abs(alf1)
      z(i)=abs(z(i))
      if(alfest(i).lt.0.0.or.z(i).lt.0.0) write(lo,*) ' ii =',
     *ii,i,z(i)
      go to 1240
c  ==================================================
 1320 continue
      if(k.eq.(k2+nori+1)) goto 1165
      do 1163 j=1,nori
      if (igin(j).eq.0) go to 1163
      k1in=k2+1
      k1f=k-1
      do 1161 jcc=k1in,k1f
      if(iorde(jcc).ne.igin(j)) goto 1161
      goto 1163
 1161 continue
      iorde(k)=igin(j)
      k=k+1
      i=igin(j)
      z(i)=-1.
      jc=mkang(i)-1
      if(mod(jc,12).eq.0) jc=24
      zp(i)=jc*15
 1163 continue
 1165 continue
      if(inpori.eq.0) go to 6982
      do 6981 jcr = 1,nori
      j = igin(jcr)
      zp(j) = ipigin(jcr)
      mkang(j) = -mkang(j)
 6981 continue
 6982 jdv = 0
      jvd = 0
      if(nant(1).ne.0) jdv=1
      do 6984 jcr = 1,nori
      j = igin(jcr)
      if (j.eq.0) go to 6984
cristina 7/4/1993
      if(iabs(mkang(j)).ne.1) go to 6984
cristina 7/4/1993
      if(iabs(mkang(j)).eq.1) jvd = jvd+1
      if(jvd.le.ngen) go to 6984
      jdv = jdv+1
      nant(jdv) = j
      zp(j) = 45.0
 6984 continue
c
c--   routine per definizione simboli ed
c--   eventuali riflessi da permutare
c
      lcc=1
      if(iperm.eq.0) goto 6998
      do 6997 l=1,iperm
      do 6992 jcr=1,nori
      if (igin(jcr).ne.inperm(l)) go to 6992
      write(lo,6990) inperm(l)
 6990 format('0 reflection having code ',i3,' will not be permuted.',/,
     1       '0 please do not permute this reflection or force the ',/,
     2       '0 origin.  program, anyway, is interrupted. sorry. ')
      stop
 6992 continue
      symb(lcc)=inperm(l)
 6997 lcc=lcc+1
      if(iperm.ge.nsymb) goto 8659
 6998 call sortco (symbo,nusy,numb)
      if (nspec.eq.0) go to 7014
      j=0
      do 7008 l=1,numb
      ljc=mkang(nusy(l))
      if (iabs(ljc).eq.21) go to 7008
      if (iperm.eq.0) go to 7007
      do 7006 ll=1,iperm
      if (nusy(l).eq.symb(ll)) go to 7008
 7006 continue
 7007 j=j+1
      if (j.gt.nspec) go to 7009
      inperm(j)=nusy(l)
 7008 continue
 7009 do 7012 l=1,nspec
      symb(lcc)=inperm(l)
 7012 lcc=lcc+1
 7014 iperm=iperm+nspec
      if (lcc.gt.nsymb) go to 8659
      do 1337 l=1,numb
       if (iperm.eq.0) go to 8866
      do 8864 ljc=1,iperm
      if(nusy(l).eq.symb(ljc)) goto 1337
 8864 continue
 8866 if(lcc.gt.nsymb) goto 8659
      symb(lcc)=nusy(l)
      lcc=lcc+1
 1337 continue
 8659 k1=lcc-1
      nral=0
      do 8655 i=1,k1
      mkk=iabs(mkang(symb(i))) - 20
      if(mkk.eq.1) nral=nral+1
 8655 continue
      nsymb=k1
      if(iprin.eq.2) write(lo,4060)
 4060 format(//,'  contenuto dei vettori  z  e  zp dopo',
     * '  la scelta dello  starting set ',//)
      if( iprin.eq.2) write(lo,4020) (i,z(i),zp(i),mkang(i),wt(i),
     * i=1,numb)
 4020 format(1h ,3(i4,'*',2e12.3,i4,f5.2))
      if(nelim.eq.0) nelim=1
      do 7070 l = nelim,numb
      do 7068 i = 1,nsymb
      if (symb(i).eq.iorde(l)) go to 7069
7068  continue
      go to 7070
7069  iorde(l) = -100
7070  continue
      jdv = numb
      do 7090 l = nelim,numb
      jcr = numb - l + nelim
      if(iorde(jcr).lt.0) go to 7090
      iorde(jdv) = iorde(jcr)
      jdv = jdv - 1
7090  continue
c  come per i riflessi dell'origine il tipo di riflesso
c  mkg per i seminvarianti deve essere positivo
c  k2  =  numero di seminvarianti ad una fase considerati
      if(k2.eq.0) go to 4054
      do 4052 l=1,k2
      ind=iorde(l)
 4052 mkang(ind)=-mkang(ind)
 4054 if(k1.eq.0) go to 1323
      do 1322 l=1,k1
      iorde(k)=symb(l)
 1322 k=k+1
 1323 nbset=k-1
 1319 if(iprin.eq.2)write(lo,4065) nbset,k2,nori, (iorde(i),i=1,numb)
 4065 format(//,'  ntot. riflessi nello starting set  =',i4,2i4,
     * //,' contenuto del vettore iorde prima della mappa',
     * /,30(20i4,/))
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (jcran.ne.0) then
                        inn1=k2+nori+1
                        iff1=inn1+numcri-1
                        iff1=min0(499,iff1)
                        nbset=iff1
                        nsymb=iff1-inn1
                      endif
ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
      if (icontr.eq.1) nori=0
      do 1325 k1=1,nbset
      i=iorde(k1)
      line(k1,1)=i
      line(k1,5)=iabs(mkang(i))
      if(line(k1,5).gt.20) line(k1,5)=line(k1,5)-20
      write(linex(k1),4056) rescha(line(k1,5))
 4056 format(a9)
      line(k1,5)=ibl
      ie=ih(i)/500000
      ihh=ih(i)-500000*ie
      enil(k1,1)=0.01*ie
      if(jpart.ne.0) enil(k1,2)=alfest(i)
      call unpacc(ihh,line(k1,2),line(k1,3),line(k1,4))
      iphh(k1)=zp(i)
      if(jpart.eq.0) goto 1325
      iphh(k1)=iz(i)/1000
      zp(i) = float (iphh(k1))
      wt(i)=1.0
      if (knw.ne.0) then
                      ikcb=iabs(kdstor(i)-iphh(k1))
                      if(ikcb.gt.180) ikcb=360-ikcb
                      if(icent.gt.0.and.ikcb.ne.0) line(k1,5)=ias
                      if(icent.eq.0.and.ikcb.gt.45) line(k1,5)=ias
                    endif
 1325 continue
c   k1 = sigma1 + origine + simboli
      k1=nbset
      l=k2+1
c  l1= sigma1 + origine
      l1 = k2+nori
c  k2 = fasi note
      l2=l1+1
      if(nori.eq.0) goto 1372
      write(lo,1331)
 1331 format(//,5x,'origin fixing reflexion(s)',/)
      write(lo,1328)
 1328 format(30x,'                                phase     assigned',/
     *      ,30x,'code   h   k   l    E        restriction    phase'/)
      write(lo,1330)((line(n,k),k=1,4),enil(n,1),linex(n),iphh(n),
     * n=l,l1)
 1330 format(30x,4i4,f6.2,7x,a9,4x,i6)
 1372 if(l1.eq.nori) go to 1340
      if(nsig1.eq.0) goto 1327
      write(lo,1332)
 1332 format(//,5x,33hone-phase s.s. phases used       /)
      write(lo,1328)
      write(lo,1339)((line(n,k),k=1,4),
     * enil(n,1),linex(n),iphh(n),line(n,5),n=1,nsig1)
 1339 format(30x,4i4,f6.2,7x,a9,4x,i6,a1)
 1327 if(nsig1.eq.k2) goto 1340
      nsig1=nsig1+1
      write(lo,1326)
 1326 format(//,5x,25hknown phases used        /)
      if(jpart.eq.0) write(lo,1328)
      if(jpart.ne.0) write(lo,1338)
 1338 format(30x,'                                phase     assigned',/
     *      ,30x,'code   h   k   l    E        restriction    phase',
     *           '   alpha',/)
      if(jpart.eq.0)write(lo,1330)((line(n,k),k=1,4),enil(n,1),linex(n),
     *iphh(n),n=nsig1,k2)
      if(jpart.ne.0) write(lo,1369) ((line(n,k),k=1,4),enil(n,1),
     *linex(n),iphh(n),line(n,5),enil(n,2),n=nsig1,k2)
 1369 format(30x,4i4,f6.2,7x,a9,5x,i6,a1,1x,f6.2)
 1340 if(l2.gt.k1) go to 1350
      if (jcran.eq.0) write(lo,1333)
 1333 format(//,5x,25hselected symbols         /)
      if (jcran.eq.0) then
                        write(lo,1335)
                        write(lo,1334)((line(n,k),k=1,4),enil(n,1),
     *                                  linex(n),n=l2,k1)
                      endif
 1335 format(30x,'                                phase ',/
     *      ,30x,'code   h   k   l    E        restriction '/)
 1334 format(30x,4i4,f6.2,7x,a9)
c **********************************************************************
c     determinazione ordine di apparizione dei riflessi
c **********************************************************************
 1350 continue
      if (jpart.ne.0) goto 8985
      k2=1
      do 1416 j=1,numb
c   controllo se si   tratta di un seminvariante a una fase
      if (z(j).lt.0.and.zp(j).ne.0) go to 1410
      if(mkang(j).le.0) go to 1415
 1410 mkang(j)=-mkang(j)
      go to 1416
 1415 z(j)=0.
      zp(j)=0.
      mkang(j)=mkang(j)+20
 1416 continue
c  per i simboli pongo il valore di zp = -99
      if(l2.gt.k1) go to 1424
      do 1423 j=l2,k1
      ind= iorde(j)
 1423 zp(ind)=-99.
 1424 continue
      do 7005 j=1,numb
      iz(j)=0
 7005 mkang(j)=-mkang(j)
      if(iprin.eq.2) write(lo,4020) (jcris,z(jcris),zp(jcris),
     * mkang(jcris),wt(jcris),jcris=1,numb)
c **********************************************************************
c     costruzione vettore  iz
c     per i riflessi dello  s.s. : origine + simboli
c     si pone  wt = 1.
c **********************************************************************
      do 7040 j=1,numb
      if(z(j).eq.0.) go to 7010
c *********    origine    **********************************************
      iz(j)=ifix(zp(j)+.5) *1000+200
      wt(j) = 1.0
      goto 7040
c *********    sigma1 & fasi note   ************************************
 7010 if(zp(j)) 7020,7030,7015
 7015 iz(j)= ifix(zp(j)+.5)*1000 +ifix(abs(wt(j))*100.+.5)
      go to 7040
c *********    simboli   ***********************************************
 7020 iz(j) = -1
      wt(j) = 1.0
      goto 7040
 7030 iz(j)=-100
 7040 continue
c *****************************************************************
        if(iprin.eq.2) write(lo,7045)(jcris,iz(jcris),wt(jcris),
     * jcris=1,numb)
 7045 format(4(i4,'*',i8,f5.2))
      if(nant(1).eq.0) goto 7050
      n1=iabs(nant(1))
      if(iz(n1).ge.-1) goto 7050
      iz(n1) =-1
7050  continue
c***********************************************************************
c     chiamata   sub  start
c***********************************************************************
      if(jcran.eq.0) then
      if (icontr.eq.0) call starts(nsymb,ier)
      if (ier.lt.0) return
                     else
                       do 8980 j=nbset+1,numb
 8980                  iorde(j)=0
                     endif
      if(inpena.eq.0) goto 8985
      if(inpena.ne.iabs(nant(1))) goto 8985
      l1in=l1+1
      do 8981 jcdv=l1in,nbset
      if(inpena.eq.iorde(jcdv)) goto 8985
 8981 continue
      iorde(nbset+1) = inpena
      wt(inpena)=1.
c  pesaggio per enantiomorfo diverso per weight procedure
      wt(inpena)=100.
      if(iabs(mkang(inpena)).eq.1) wt(inpena) = 5.5
 8985 continue
      if(icent.lt.0) then
      if (jpart.eq.0) write(lo,8986)
 8986 format(//,5x,'enantiomorph fixed by space group ',/)
                     else
                      if(nant(1).eq.0)  go to 7060
                      ns = iabs(nant(1))
                      ie = ih(ns)/500000
                      ihh =ih(ns) - 500000* ie
                      eenan=float(ie)*0.01
                      call unpacc(ihh,nh,nk,nl)
                      write(lo,7055) ns,nh,nk,nl,eenan
                    endif
 7055 format(//,5x,'enantiomorph fixing reflexion ',//,
     *         30x,'code   h   k   l    E',//,30x,4i4,f6.2)
7060  continue
      if ( jpart.ne.0 ) goto 1705
c***********************************************************************
c     inizio  mappa  di  divergenza
c***********************************************************************
      do 1427 j=1,numb
 1427 mkang(j)=-mkang(j)
      i=iorde(1)
      mkang(i)=-mkang(i)
      ii=3
      lcri=k1
      k=2
      do  1425 j=1,numb
      do  1422 j1=1,nbset
      if(j.eq.iorde(j1)) goto 1425
 1422 continue
      wt(j)=0.0
 1425 continue
      do 1431 j=1,numb
      j1=iorde(j)
      if(j1.eq.0)  goto 1432
      if(j1.eq.iabs(nant(1)).and.wt(j1).ne.1.)goto 1431
      if(zp(j1).ne.(-99.)) goto 1420
c *** wt(j1) = 100.
      if(iabs(mkang(j1)).ne.1) goto 1419
      wt(j1)=par(nral)
      goto 1431
 1419 wt(j1)=100.
      goto 1431
 1420 iwt=mod(iz(j1),1000)
      if(iwt.gt.100) goto 1426
      wt(j1)=-1
      goto 1431
 1426 wt(j1)=100.
 1431 continue
 1432 continue
      do 1445 j=1,numb
      if(wt(j).le.1) goto 1440
      wt(j)=bes(wt(j))
      goto 1445
 1440 if(wt(j).ge.0) goto 1445
      iwt = mod (iz(j),1000)
      wt(j) = iwt * 0.01
 1445 continue
 1430  i=iorde(k)
      mkang(i)=-mkang(i)
      n0=0
      n=0
      n1=0
      call inter(ii,i,alf1)
      z(i)=abs(z(i))
      alf1=abs(alf1)
      k=k+1
      if(k.ge.numph) go to 1580
      if(iorde(k))1580,1580,1430
 1580 amax=0.
      if(icontr.eq.1) go to 1705
      if(nlist.eq.0) goto 1590
      if(klist.ne.0)go to 1590
      klist=1
      write(lo,3595)
 3595 format(///,50x,18hdivergence mapping///'    code'
     *,'     h    k    l    alfest',6x,12hcontributors/)
 1590 do 1600 i=1,numb
      if(mkang(i).gt.0) go to 1600
      alfa=z(i)*z(i)
      if(alfa.lt.amax)go to 1600
      amax=alfa
      iorde(k)=i
 1600 continue
      amax=sqrt(amax)
c   stampa relazioni seminvarianti a due fasi
      if (nlist.eq.0) go to 1605
      if (n0.eq.0) go to 1595
      m1=0
      m=min0(n0,5)
      write(lo,1602) ((ibu(l,j),j=1,2),bu(l),l=1,m)
 1602 format(35x,5(i6,'*',i4,f6.2))
 1594 if(m.eq.n0) go to 1595
      n0=n0-5
      m1=m1+5
      m=min0(n0,5)
      m11=m1+1
      m1m=m1+m
      write(lo,1602) ((ibu(l,j),j=1,2),bu(l),l=m11,m1m)
      go to 1594
c  stampa delle relazioni di invarianti a tre fasi
 1595 if (n.eq.0) go to 1596
      m1=0
      if (knw.eq.0) m=min0(n,4)
      if (knw.ne.0) m=min0(n,3)
      if (knw.ne.0)
     *write(lo,1601) ((ibufr(l,j),j=1,3),(bufr(l,jc),jc=1,2),l=1,m)
      if (knw.eq.0)
     *write(lo,1603)((ibufr(l,j),j=1,3),bufr(l,1),l=1,m)
 1601 format(36x,3(2(i5,'*'),i4,2f6.2,2x))
 1597 if (m.eq.n) go to 1596
      if (knw.eq.0) go to 1608
      n=n-3
      m1=m1+3
      m=min0(n,3)
      goto 1609
 1608 n=n-4
      m1=m1+4
      m=min0(n,4)
 1609 m11 = m1+1
      m1m = m1+m
      if (knw.ne.0)
     *write(lo,1601) ((ibufr(l,j),j=1,3),(bufr(l,jc),jc=1,2),l=m11,m1m)
      if (knw.eq.0)
     *write(lo,1603) ((ibufr(l,j),j=1,3),bufr(l,1),l=m11,m1m)
      go to 1597
c   stampa delle relazioni di quartetto
 1596 if (n1.eq.0) go to 1605
      m1=0
 1598 m=min0(n1,3)
      m11 = m1+ 1
      m1m = m1 + m
      write(lo,1599) ((ibuf(l,j),j=1,4),buf(l),l=m11,m1m)
 1599 format(36x,3(3i5,i4,f6.2))
      if (m.eq.n1) go to 1605
      m1=m1+3
      n1=n1-3
      go to 1598
 1603 format(36x,4(2(i5,'*'),i4,f6.2))
 1605 if(k.lt.numb) goto 1610
c +++++++++++++++++++++++++++++++++++++++++++++++++++++
      ind = iorde(k)
      mkang(ind)=-mkang(ind)
      do 1604 i=1,numb
      if(mkang(i).gt.0) go to 1604
      k=k+1
      iorde(k)=i
 1604 continue
 1705 nb=limref(numb+1)
c   per i seminvarianti a una fase il peso wt e posto negativo
      if(nsigm1.eq.0) go to 5530
      do 5500 i=1,nsigm1
      ind=iorde(i)
 5500 wt(ind)=-wt(ind)
 5530 if(jpart.eq.0) goto 5535
      if (l2.gt.k1) goto 5535
      do 5532 i=l2,k1
      ind = iorde(i)
      zp(ind) = -99.
 5532 continue
 5535 nin=nbset+1
      do 5550 i=nin,numb
      ind=iorde(i)
      zp(ind)=0
 5550 continue
      if(iprin.eq.2) write(lo,4023) (iorde(jcris),jcris=1,numb)
      if(iprin.eq.2) write(lo,4022) (limref(jcris),jcris=1,numb)
 4022 format(12(10i10,/))
 4023 format(30(20i4,/))
      if(iprin.eq.2) write(lo,4028) (jcris,zp(jcris),alfest(jcris),
     *  iz(jcris),wt(jcris),jcris=1,numb)
 4028 format(1h ,2(i4,'*',2e12.3,i8,f5.2))
      return
 1610 i=iorde(k)
      wate=1.0
      if(amax.lt.5.) wate=0.15*amax+0.25
      wt(i)=amax1(wate,0.15)
      if(k.gt.nlist+nbset)go to 1430
      ie=ih(i)/500000
      ihh=ih(i)-ie*500000
      call unpacc(ihh,i1,i2,i3)
      write(lo,1620) i,i1,i2,i3,amax,wt(i)
 1620 format(2h -,2i6,2i5,2f10.2)
      go to 1430
      end
c----------------------------------------------------------------------
c      subroutine  lettura  dei  riflessi
      subroutine refsto(icode)
      common /param/ numb,nant(4),nral,alra,sumalf,ssig,nref,duma
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /cpseud/ npseud,lpseuv(12),llpse
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngenn
     *,irot(48,48),jsvet(10),isvet(8),nori,imod(3),nss(3)
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common /unp/ hmax,kmax,lmax,iplan,irang,iplan2
      common /partia/e(800),ep(800),kdstor(500),iphp(800),
     * iverbo,imk,gminpa,aksca,ssims,cutpa
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /psi0/ npsi,num0,alfest0(300),alfvar0(300),llll(300),
     1 lim0n(300),iph0n(20000)
      common /sup/ ibufr(80,3),bufr(80,2),n,zi,zpi,k,nlist,buf(80),
     *ibuf(80,4),n1,ntrip,idumm1(500),n0,ibu(80,2),bu(80),lcri,
     * nbset,pub(800)
      common /xdata/ imat(3,20000),z(500),iee(20000),iph(41000),
     2 iphaz(500),iorde(500),alfest(500),iz(500),ih(800),e1(800),
     3 limref(500),mkang(800),alfvar(500),ifstor(500),alpha(500),
     4 icont(3),idummy(500),wt(500),zp(500),irefin(500),nnx(8),
     5 nbinv(61000),enil(4),line(4,6),dummx(53061)
      integer hmax,pub
      dimension vet(12),ivet(12)
      equivalence (ivet(1),vet(1))
c
      irang = 2*lmax + 1
      iplan = (2*kmax + 1) * irang
      iplan2 =  kmax * irang + lmax
      i=0
      nfin=nref-num0+1
      nn=0
      do 50 j=1,nref
      call snr07(vet)
      if(icode.eq.2) goto 48
      if(i.eq.numb) go to 50
      i=i+1
      lh=ivet(1)
      lk=ivet(2)
      ll=ivet(3)
      e11=vet(4)
      if(jpart.eq.0) goto 45
      e(i)=vet(6)
      ep(i)=vet(7)
      iphp(i)=ivet(8)/(2**15)
   45 ie= 100*(e11 + 0.005)
c  compattamento indice
      ihkl = iplan*lh + irang*lk + ll
      ih(i) = ie * 500000 + ihkl
      iphi8=mod(ivet(8),2**15)
      iphaz(i) = iphi8/32
      mkang(i) = mod(iphi8,32)
      goto 50
   48 i=i+1
      if(i.gt.numb.and.i.lt.nfin) go to 50
      nn=nn+1
      lh=ivet(1)
      lk=ivet(2)
      ll=ivet(3)
      e11=vet(4)
      ie= 100*(e11 + 0.005)
c  compattamento indice
      ihkl = iplan*lh + irang*lk + ll
      ih(nn) = ihkl
      e1(nn) = ie * 0.01
      iphi8=mod(ivet(8),2**15)
      pub(nn) = iphi8/32
      mkang(nn) = mod(iphi8,32)
   50 continue
      if (jpart.eq.0) return
      s3s2p = 0.5 * s3s2p
      return
      end
c     -----------------------------------------------------------------
      subroutine unpacc(ind,ih,ik,il)
c   unpack indices with  lk paking constants (big list index)
      common /unp/ hmax,kmax,lmax,iplan,irang,iplan2
      integer hmax
      ind1 = ind + iplan2
      ih = ind1/iplan
      iau = mod(ind1,iplan)
      ik = iau/irang - kmax
      il = mod(iau,irang) - lmax
      return
      end
c----------------------------------------------------------------------
      subroutine inter(ii,i,alf1)
      common /param2/ mkg(500),modul(3)
      common /param/ numb,nant(4),nral,alra,sumalf,ssig,nref,duma
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngenn
     *,irot(48,48),jsvet(10),isvet(8),nori,imod(3),nss(3)
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common /sup/ ibufr(80,3),bufr(80,2),n,zi,zpi,k,nlist,buf(80),
     *ibuf(80,4),n1,ntrip,alfran(500),n0,ibu(80,2),bu(80),lcri,
     * nbset,pub(800)
      common /xdata/ imat(3,20000),z(500),iee(20000),iph(41000),
     2 iphaz(500),iorde(500),alfest(500),iz(500),ih(800),e(800),
     3 limref(500),mkang(800),alfvar(500),ifstor(500),alphac(500),
     4 icont(3),idummy(500),wt(500),zp(500),irefin(500),nn(8),
     5 nbinv(61000),eni1(4),lin1(4,6),dummx(53061)
c
      integer pub
c
      vec(x)=amin1(x*(x+0.4807)/((x+0.8636)*x+1.3943),1.0)
c
      lm=limref(i)+1
      ls=limref(i+1)
      if(lm.gt.ls) go to 3300
      nv=0
      do 3100 j=lm,ls
      ind = nbinv(j)
      call depacc (i,ind,a1,ifaz,iw)
      ila=iabs(nn(1))
      ira=iabs(nn(2))
      ita=iabs(nn(3))
      w=1.
      go to (3038,3020,3010,3020,3020),ii
c ordine di apparizione nella mappa di divergenza  ii = 3
 3010 w=wt(i)
      ix=0
      do 3015 jj=1,3
      ira=iabs(nn(jj))
      if(nn(jj).eq.0) go to 3015
      if(mkang(ira))3011,3011,3014
 3011 ix=ix+1
      ila=ira
      go to 3015
 3014 w=w*wt(ira)
 3015 continue
      if(ix-1)3080,3035,3100
 3020 do 3025 jj=1,3
      if(nn(jj).eq.0) go to 3025
      ila=iabs(nn(jj))
      if(iabs(mkang(ila)).gt.20) goto 3100
      w=w*wt(ila)
 3025 continue
c     if (iwei.eq.0) goto 3038
c     if (iwei.ne.0) goto 3039
      go to 3039
c3035 if(k.gt.lcri.and.iwei.eq.0) goto 3038
c     if(k.gt.lcri.and.iwei.ne.0) goto 3039
 3035 if(k.gt.lcri) goto 3039
      do 3036 jc=1,lcri
      if(ila.eq.iorde(jc)) goto 3100
 3036 continue
 3038 gbes = abs(a1)
      eee = gbes * w
corig vec1 = bes(eee)
      vec1 = bes(a1*w)
      goto 3040
 3039 gbes = abs(a1)
      a1 = bes(a1)
      eee = a1 * w
      vec1 = gbes
 3040 vec2 = vec1 * eee
      go to (3060,3050,3045,3050,3060),ii
 3045 continue
      z(ila)=z(ila)+vec2
      go to 3100
 3050 do 3055 jj=1,3
      if(nn(jj).eq.0) go to 3055
      ira=iabs(nn(jj))
      if(mkang(ira).lt.0) goto 3055
      if(z(ira).lt.0.) go to 3055
      z(ira)=z(ira)-vec2
 3055 continue
      if(ii.ne.2) goto 3100
      if(iprin.lt.1) goto 3100
      if(nv.ge.80) goto 3100
      nv=nv+1
      do 3056 jj=1,2
 3056 ibuf(nv,jj)= nn(jj)
      buf(nv)=gbes
      ibuf(nv,3)=ifaz
      go to 3100
 3060 zi=zi+vec2
corig if (iw.eq.3.or.nn(2).eq.0)  goto 3100
      if (nn(2).eq.0)  goto 3100
      alf1=alf1+vec2
c  incremento alfarandom di ogni riflesso
      alfran(i)=alfran(i)+a1**2
c ======================================================
      go to 3100
c sortie des resultats
 3080 if(k.gt.nlist+nbset) go to 3100
      if(nn(2).ne.0) go to 3085
      if(n0.ge.80) go to 3100
      n0=n0+1
      ibu(n0,1) = nn(1)
      ibu(n0,2)=ifaz
      bu(n0)=a1
      go to 3100
 3085 if(nn(3).ne.0) go to 3090
      if(n.ge.80) go to 3100
      n=n+1
      ibufr(n,1) =nn(1)
      ibufr(n,2)= nn(2)
      ibufr(n,3)= ifaz
c  calcolo coseno reale e coseno calcolato
      if(knw.eq.0) goto 3087
      isi1=isign(1,nn(1))
      nn1=iabs(nn(1))
      isi2=isign(1,nn(2))
      nn2=iabs(nn(2))
      ip=iphaz(i)-isi1*iphaz(nn1)-isi2*iphaz(nn2) -ifaz*15
      cosc=vec(a1)
      cosr=cos(ip/57.29578)
      bufr(n,1)=abs(cosc-cosr)
      bufr(n,2)=a1
      goto 3100
 3087 continue
      bufr(n,1)=a1
      go to 3100
 3090 if(n1.ge.80) go to 3100
      n1=n1+1
      ibuf(n1,1)=nn(1)
      ibuf(n1,2)=nn(2)
      ibuf(n1,3)=nn(3)
      ibuf(n1,4)=ifaz
      buf(n1)=a1
c ===============================================
 3100 continue
      if(ii.ne.2) goto 3300
c  scrittura mappa di convergenza
      if(iprin.ne.2) goto 3300
      if(nv.gt.0)
     1write(lo,3105) ((ibuf(kv,lv),lv=1,3),buf(kv),kv=1,nv)
 3105 format((20x,4(2i5,i4,f7.2,3x)))
 3300 continue
      return
      end
c-----------------------------------------------------------------------
      subroutine depacc (i,ind,a,ifaz,iw)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngenn
     *,irot(48,48),jsvet(10),isvet(8),nori,imod(3),nss(3)
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common /sup/ ibufr(80,3),bufr(80,2),n,zi,zpi,k,nlist,buf(80),
     *ibuf(80,4),n1,ntrip,idumm1(500),n0,ibu(80,2),bu(80),lcri,
     * nbset,pub(800)
      common /xdata/ imat(3,20000),z(500),iee(20000),iph(41000),
     2 iphaz(500),iorde(500),alfest(500),iz(500),ih(800),e(800),
     3 limref(500),mkang(800),alfvar(500),ifstor(500),alphac(500),
     4 icont(3),idummy(500),wt(500),zp(500),irefin(500),nn(8),
     5 nbinv(61000),eni1(4),lin1(4,6),dummx(53061)
      integer pub
c **********  icod = 0  relazione  di tripletto
c **********  icod = 1  relazione di seminvariante
      icod=0
      do 10 j = 1,4
10    nn(j) = 0
      call unpak3(iph(ind),nn(1),nn(2),ifaz)
      iw = 1
      if(ifaz.lt.0) go to 20
c     one-phase  seminvariant
         write(lo,100) ind,nn(1),nn(2),iph(ind),ifaz
  100  format(' error in subroutine depacc',3i6,i20,i4)
         stop
20    call unpak3 (iph(ind+1),nn(3),nn(4),ifaz)
      iw = 2
      if(ifaz.lt.0) go to 30
      a= 0.01*nn(4)
      nn(4) = 0
c+++++if(ind.le.2*ntrip) go to 40
c   sostituito controllo sul primo codice del secondo campo di iph =
c  =  nn(3)  minore di 700 implica che la relazione e di tripletto
c  maggiore di  700 la relazione e seminvarianti
c  per i seminvarianti a due fasi nn(3) rappresenta
c la fase della relazione in gradi - campo inutile
          if(nn(3).lt.700) go to 40
c   two-phase seminvariant
      icod=1
      nn(3) = 0
      go to 40
c   quartets (this is a french quartet)
30    call unpak3(iph(ind+2),l,m,ifaz)
      iw = 3
      a = 0.01*m
c  relationship solution in terms of i
40    if(i.eq.0) return
      do 50 j = 1,4
      if(iabs(nn(j)).eq.i) go to 60
50    continue
      write(lo,55)i,nn
55    format (5x,'*****error in subroutine  depacc ******',i5,3x,4i5)
      stop
60    isi = isign(1,nn(j))
      j1 = 1
      do 70 jcris = 1,4
      if(jcris.eq.j) go to 70
      nn(j1) = nn(jcris)*(-isi)
      j1 = j1+1
70    continue
      ifaz = ifaz*(-isi)
      if(ifaz.lt.0) ifaz=ifaz+24
      if(icod.eq.1) nn(2)=0
      nn(4) = 0
      return
      end
c ------------------------------------------------------------------
      subroutine sortco (st1,list2,n)
      dimension st1(n),list2(n)
      int = 2
10    int = int*2
      if(int.lt.n)goto 10
      int = min0(n,(3*int)/4 - 1)
20    int = int/2
      ifin = n - int
      do 120  ii = 1,ifin
      i = ii
      j = i + int
      if(st1(i)-st1(j))120,120,40
40    r = st1(j)
      m = list2(j)
60    st1(j) = st1(i)
      list2(j) = list2(i)
      j = i
      i = i - int
      if(i) 100,100,80
80    if(st1(i)-r) 100,100,60
100   st1(j) = r
      list2(j) = m
120   continue
      if(int.gt.1) go to 20
      return
      end
c-----------------------------------------------------------------------
c     determine space group type according to the categories of hauptman
c     & karle,  acta cryst. (1956) 9, 45  and  acta cryst. (1959) 12, 93
c     and karle & hauptman,  acta cryst. (1961) 14, 217,  given only the
c     general equivalent positions and lattice type  -  gives  necessary
c     information on number and  type  of  reflexions  used  for  origin
c     definition, seminvariant modulus & reduced indices for  reflexions
c     routine will handle 230 space groups in the standard  orientations
c     including alternative settings as in international tables volume 1
c     determine  also  the  phase   restrictions  for   all   reflexions
c     test  whether  the  enantiomorph  is  fixed  by  the  space  group
      subroutine group
      common /local/ ind(3),khl(4)
      common /param2/ mkg(500),modul(3)
      common /param/ numb,nant(4),nral,alra,sumalf,ssig,nref,duma
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngenn
     *,irot(48,48),jsvet(10),isvet(8),nori,imod(3),nss(3)
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /unp/ hmax,kmax,lmax,iplan,irang,iplan2
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /sup/ ibufr(80,3),bufr(80,2),n,zi,zpi,k,nlist,buf(80),
     *ibuf(80,4),n1,ntrip,idumm1(500),n0,ibu(80,2),bu(80),lcri,
     * nbset,pub(800)
      common /xdata/ imat(3,20000),z(500),iee(20000),iph(41000),
     2 iphaz(500),iorde(500),alfest(500),iz(500),ih(800),e(800),
     3 limref(500),mkang(800),alfvar(500),ifstor(500),alphac(500),
     4 icont(3),idummy(500),wt(500),zp(500),irefin(500),nn(8),
     5 nbinv(61000),eni1(4),lin1(4,6),dummx(53061)
      integer hmax,pub
c     * * * * * * * * * * * * * * * * ** * * * * * * * * * * * * * * * *
c     initialize parameters
      nral = 0
      do 1000 i=1,3
      modul(i) = 2
 1000 continue
c     it = 3  tests for z in 1st coord. of general equivalent  positions
c     -  gives rhombohedral or cubic
c     it = 2  tests for y in 1st coord. - gives tetragonal, hexagonal or
c     trigonal
      do 1060 ii=1,2
      it = 4 - ii
      do 1040 j=1,nsym
      if (iabs(is(1,1,j)) - it) 1020,1500,1020
 1020 if (iabs(is(2,1,j)) - it) 1040,1500,1040
 1040 continue
 1060 continue
c     space group must be triclinic,  monoclinic  or  orthorhombic
c     three reflexions are normally required for origin definition
      nori = 3
      if (icent) 1080,1080,1160
c     determine  seminvariant  modulus vector (modul) and number of axes
c     along  which the  origin  position is infinitely  variable  (nral)
 1080 nral = 3
      do 1140 i=1,3
      modul(i) = 1000
      do 1100 j=1,nsym
      if (is(1,i,j)) 1120,1100,1100
 1100 continue
      go to 1140
 1120 modul(i) = 2
      nral = nral - 1
 1140 continue
c     check for centred lattice
 1160 go to (1380,1260,1180,1220,1380,1320,1380), latt
c     b centred lattice  -  test for b2  or  bm, bb
 1180 if (nral.le.1) goto 1380
      ii= 2
      modul(3) = 1000
      go to 1280
c     c centred lattice  -  test for c2  or  cm, cc
 1220 if(nral.le.1) goto 1380
      modul(2) = 1000
 1260 ii = 3
c     a centred lattices, bm, bb, cm, cc
c     determine reduced indices for all reflexions
 1280 do 1300 i=1,numb
      inn=ih(i)-500000*(ih(i)/500000)
      call unpacc(inn,ind(1),ind(2),ind(3))
      ind(1)=iabs(ind(1))
      ind(2)=iabs(ind(2))
      ind(3)=iabs(ind(3))
      mkg(i)=512*(mod(ind(1),modul(2))+256)+mod(ind(ii),modul(3))+256
 1300 continue
      go to 2000
c     f centred lattice - test point group symmetry around (1/4,1/4,1/4)
c     to detect f222 if space group is non-centrosymmetric
 1320 if (icent.gt.0) goto 1980
      call test9(1,1,1,4,mm)
      if (mm.eq.0) goto 1960
c     triclinic, monoclinic & orthorhombic except a centred, bm,bb,cm,cc
c     determine reduced indices for all reflexions
 1380 do 1400 i=1,numb
      inn=ih(i)-500000*(ih(i)/500000)
      call unpacc(inn,ind(1),ind(2),ind(3))
      ind(1)=iabs(ind(1))
      ind(2)=iabs(ind(2))
      ind(3)=iabs(ind(3))
      mkg(i)=262144*mod(ind(1),modul(1))+512*(mod(ind(2),modul(2)
     1  ) + 256) + mod(ind(3),modul(3)) + 256
 1400 continue
      go to 2000
c     space group must be tetragonal, trigonal, hexagonal or cubic
 1500 if (icent) 1520,1520,1640
 1520 if (latt - 1) 1600,1540,1600
c     test whether enantiomorph is fixed by the space group
 1540 do 1560 i=1,nsym
      it = 24.0 * ts(3,i) + 0.1
      if (mod(it,12)) 1580,1560,1580
 1560 continue
      go to 1600
c     enantiomorph fixed by space group  -  set flag
 1580 icent = -1
c     is origin position infinitely variable along z
c     set flag (nral) and 3rd component of seminvariant  modulus  vector
 1600 do 1620 i=1,nsym
      if (is(1,3,i)) 1640,1620,1620
 1620 continue
c     space group must be 2p20, 3p30, 3p(1)0 or 3p(2)0
      nral = 1
      modul(3) = 1000
c     branch for rhombohedral and cubic
 1640 go to (1940,1660), ii
c     test point group symmetry around (1/2,1/2,0) to detect  tetragonal
 1660 call test9(1,1,0,2,mm)
      if (mm) 1820,1680,1820
c     space group must be tetragonal
c     two reflexions are normally required for origin definition
 1680 nori = 2
      if (latt.ne.5) goto 1780
c     i centred  tetragonal    -    test  point  group  symmetry  around
c     (0,1/2,1/4)  to  detect  bar 4  axis
      call test9(0,2,1,4,mm)
      if (mm.ne.0) goto 1780
c     space group must be 3p(3)4
      modul(3) = 4
c     determine reduced indices for all reflexions
      do 1740 i=1,numb
      inn=ih(i)-500000*(ih(i)/500000)
      call unpacc(inn,ind(1),ind(2),ind(3))
      ind(1)=iabs(ind(1))
      ind(2)=iabs(ind(2))
      ind(3)=iabs(ind(3))
      mkg(i) = mod(2 * ind(2) + ind(3), modul(3)) + 131328
 1740 continue
      go to 2000
c     space group must be 3p(3)0 or 3p(3)2
c     enter here for primitive tetragonal
c     determine reduced indices for all reflexions
 1780 do 1800 i=1,numb
      inn=ih(i)-500000*(ih(i)/500000)
      call unpacc(inn,ind(1),ind(2),ind(3))
      ind(1)=iabs(ind(1))
      ind(2)=iabs(ind(2))
      ind(3)=iabs(ind(3))
      mkg(i) = 512*(mod(ind(1) + ind(2), modul(2)) + 256) + mod(ind(3),
     1  modul(3)) + 256
 1800 continue
      go to 2000
c     space group must be trigonal or hexagonal
 1820 if (icent) 1840,1840,1900
c     test point group symmetry around (1/3,2/3,0) to detect 3p30 & 3p32
 1840 if (latt - 7) 1850,1900,1900
 1850 call test9(1,2,0,3,mm)
      if (mm) 1900,1860,1900
c     space group must be 3p30 or 3p32
 1860 modul(2) = 3
c     detect 6p6
      if (modul(3).eq.2) goto 1890
c     two reflexions are normally required for origin definition
      nori = 2
c     determine reduced indices for all reflexions
      do 1880 i=1,numb
      inn=ih(i)-500000*(ih(i)/500000)
      call unpacc(inn,ind(1),ind(2),ind(3))
      ind(1)=iabs(ind(1))
      ind(2)=iabs(ind(2))
      ind(3)=iabs(ind(3))
      mkg(i) = 512*(mod(ind(1) - ind(2), modul(2)) + 256) + mod(ind(3),
     1  modul(3)) + 256
 1880 continue
      go to 2000
c     one reflexion normally required for origin definition
 1890 nori=1
      modul(3)=6
c     determine reduced reflexions for all reflexions
      do 1895 i=1,numb
      inn=ih(i)-500000*(ih(i)/500000)
      call unpacc(inn,ind(1),ind(2),ind(3))
      ind(1)=iabs(ind(1))
      ind(2)=iabs(ind(2))
      ind(3)=iabs(ind(3))
      mkg(i)=mod(2*ind(1)+4*ind(2)+3*ind(3),modul(3))
 1895 continue
      goto 2000
c     space group must be 3p(1)0, 3p(1)2 or rhombohedral using hexagonal
c     axes
c     one reflexion is normally required for origin definition
 1900 nori = 1
c     determine reduced indices for all reflexions
      do 1920 i=1,numb
      inn=ih(i)-500000*(ih(i)/500000)
      call unpacc(inn,ind(1),ind(2),ind(3))
      ind(1)=iabs(ind(1))
      ind(2)=iabs(ind(2))
      ind(3)=iabs(ind(3))
      mkg(i) = mod(ind(3),modul(3)) + 131328
 1920 continue
      go to 2000
c     space group must be 3p(2)0, 3p(2)2, 3p(2)4 or 4p111
c     test point group symmetry around  (1/4,1/4,1/4)  to detect  3p(2)4
 1940 if (icent) 1950,1950,1980
 1950 if (latt - 7) 1960,1980,1980
 1960 call test9(1,1,1,4,mm)
      if (mm) 1980,1970,1980
 1970 modul(3) = 4
c     one reflexion is normally required for origin definition
 1980 nori = 1
c     determine reduced indices for all reflexions
      do 1990 i=1,numb
      inn=ih(i)-500000*(ih(i)/500000)
      call unpacc(inn,ind(1),ind(2),ind(3))
      ind(1)=iabs(ind(1))
      ind(2)=iabs(ind(2))
      ind(3)=iabs(ind(3))
      mkg(i) = mod(ind(1) + ind(2) + ind(3), modul(3)) + 131328
 1990 continue
c     calculate phase restrictions on all reflexions
 2000 do 2040 i=1,numb
      mkang(i) = 13
c     alpha(i) = 0.0
c     palf(i) = 0.0
 2040 continue
      if(icent .gt . 0) go to 2240
      do 2200 i=1,numb
      mkang(i) = 1
      inn=ih(i)-500000*(ih(i)/500000)
      call unpacc(inn,ind(1),ind(2),ind(3))
      ind(1)=iabs(ind(1))
      ind(2)=iabs(ind(2))
      ind(3)=iabs(ind(3))
c     generate symmetry related reflexions
      do 2180 j=1,nsym
      do 2080 kcb=1,4
      khl(kcb) = 0
 2080 continue
      do 2140 kcb=1,3
      khl(4) = khl(4) + ind(kcb) * int(ts(kcb,j) * 12.0 + 0.1)
      do 2120 l=1,2
      m = iabs(is(l,kcb,j))
      if (m .ne. 0) khl(m)=khl(m) + ind(kcb) * isign(1,is(l,kcb,j))
 2120 continue
 2140 continue
c     has friedel opposite been generated
      do 2160 kcb=1,3
      if (ind(kcb) + khl(kcb)) 2180,2160,2180
 2160 continue
c     yes - phase must be restricted to  pi*khl(4)/24 or pi*khl(4)/24+pi
      mkang(i) = mod(khl(4), 12) + 1
      if (mkang(i) .le. 1) mkang(i) = mkang(i) + 12
      go to 2200
 2180 continue
 2200 continue
      do 2220 i=1,3
      modul(i) = mod(modul(i),1000)
 2220 continue
c     adjust number of origin  defining  reflexions for centred lattices
 2240 go to (2280,2260,2260,2260,2260,2300,2280), latt
c     a, b, c and i centred lattices
 2260 nori = nori - 1
 2280 return
c     f centred lattices
 2300 nori = iabs(nori - 2)
      return
      end
c     ------------------------------------------------------------------
c     test to see if the point (m1/m4,m2/m4,m3/m4) is a possible  origin
c     position     mm .eq. 0  if yes     mm .ne. 0  if no
c     this routine is written to test  non-centrosymmetric  space groups
c     with p, i and f lattices only
      subroutine test9(m1,m2,m3,m4,knt)
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngenn
     *,irot(48,48),jsvet(10),isvet(8),nori,imod(3),nss(3)
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      dimension matrix(3,3)
      do 1220 i=1,nsym
      do 1020 j=1,3
      do 1000 k=1,3
      matrix(j,k) = 0
 1000 continue
      matrix(j,j) = -1
 1020 continue
      do 1080 j=1,2
      do 1060 k=1,3
      m = iabs(is(j,k,i))
      if (m) 1060,1060,1040
 1040 matrix(k,m) = matrix(k,m) + isign(1,is(j,k,i))
 1060 continue
 1080 continue
      knt = 0
      do 1140 j=1,3
      mm = iabs(mod(matrix(j,1) * m1 + matrix(j,2) * m2 + matrix(j,3) *
     1  m3, m4))
      if (mm) 1140,1140,1100
 1100 if (2 * mm - m4) 1260,1120,1260
 1120 knt = knt + 1
 1140 continue
      if (knt) 1220,1220,1160
 1160 go to (1240,1240,1240,1240,1180,1200,1240), latt
 1180 if (knt - 3) 1240,1220,1240
 1200 if (knt - 2) 1240,1220,1240
 1220 continue
      knt = 0
 1240 return
 1260 knt = 1
      return
      end
c   --------------------------------------------------------------------
c     find any nori reflexions from those available to define the origin
c     routine will handle 230 space groups in the standard  orientations
c     including alternative settings as in international tables volume 1
      subroutine origin(jump,norin,ial,min,igin)
      common /param2/ mkg(500),modul(3)
      common /param/ numb,nant(4),nral,alra,sumalf,ssig,nref,duma
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngenn
     *,irot(48,48),jsvet(10),isvet(8),nori,imod(3),nss(3)
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /unp/ hmax,kmax,lmax,iplan,irang,iplan2
      common /partia/e(800),ep(800),kdstor(500),iphp(800),
     * iverbo,imk,gminpa,aksca,ssims,cutpa
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /sup/ ibufr(80,3),bufr(80,2),n,zi,zpi,k,nlist,buf(80),
     *ibuf(80,4),n1,ntrip,idumm1(500),n0,ibu(80,2),bu(80),lcri,
     * nbset,pub(800)
      common /xdata/ imat(3,20000),z(500),iee(20000),iph(41000),
     2 iphaz(500),iorde(500),palf  (500),iz(500),ih(800),e1(800),
     3 limref(500),mkang(800),alfvar(500),ifstor(500),alphac(500),
     4 icont(3),idummy(500),wt(500),zp(500),irefin(500),nn(8),
     5 nbinv(61000),eni1(4),lin1(4,6),dummx(53061)
      integer hmax,pub
      dimension igin(3)
c     * * * * * * * * * * * * * * * * ** * * * * * * * * * * * * * * * *
      jump=0
c     origin is defined by space group
      if(nori.eq.0) return
c     reflexion min must be included in origin
      must=0
      if(min.eq.0) must=-1
      do 900 iii=1,numb
c  *******************************************************************
      i = iii
      if (jpart.ne.0) i = iorde(iii)
c     test if reflexion min is in origin defining set
      if(must.eq.1) go to 950
      if(i.eq.min) must=1
c  *******************************************************************
      if(jpart.eq.0) goto 50
c     eliminated reflexion
      if (iz(i).ne.0.and.mod(iz(i),1000).ne.200) goto 900
c     reflexion with no sigma-2 contributors
      if(palf(i).lt.0.2) go to 900
      goto 55
  50  if(mkang(i).lt.0) goto 900
c     seminvariant reflexion
  55  if(mkg(i).eq.131328) go to 900
      nral1=0
c     count general reflexions
      if(mkang(i).eq.1) nral1=1
      if(nral1.gt.nral) go to 900
      n1=0
c     count user reflexions requested
c     if(mod(iz(i),1000).eq.200) n1=1
c     if (norin-n1.ge.nori) go to 900
      call sir_unpack(mkg(i),j1,k1,l1)
      if(nori.gt.1) go to 100
c     is min included
      if(must.eq.0) go to 900
c     test with origin rules if one reflexion is needed to define origin
c     modulus = (2), (3), (4), (6) or (0)
      if(l1.eq.1) go to 1000
      if(l1.eq.modul(3)-1) go to 1000
      go to 900
  100 ipo=i+1
      if(ipo.gt.numb) go to 900
      do 800 jjj=ipo,numb
c  ********************************************************************
      j = jjj
      if(jpart.ne.0) j = iorde(jjj)
      if(must.eq.2) go to 900
      if(j.eq.min) must=2
c  ********************************************************************
      if (jpart.eq.0) goto 150
      if (iz(j).ne.0.and.mod(iz(j),1000).ne.200) goto 800
      if(palf(j).lt.0.2) go to 800
      goto 155
  150 if(mkang(j).lt.0) goto 800
  155 if(mkg(j).eq.131328) go to 800
      nral2=nral1
      if(mkang(j).eq.1) nral2=nral2+1
      if(nral2.gt.nral) go to 800
      n2=n1
      call sir_unpack(mkg(j),j2,k2,l2)
      if(nori.gt.2) go to 200
      if(must.eq.0) go to 800
c     test with origin rules if two reflexions are needed
      mdet=k1*l2-k2*l1
      maxm=max0(modul(2),modul(3))
c     modulus = (0,0) or (2,2)
      if(iabs(mdet).eq.1) go to 1000
      if(maxm.eq.0) go to 800
c     modulus = (0,2), (2,0) or (3,0)
      if(mod(mdet,maxm).eq.0) go to 800
c     modulus = (0,2)
      if(modul(2).eq.0.and.jfac(k1,k2,-1000).ne.1) go to 800
c     modulus = (2,0) or (3,0)
      if(modul(3).eq.0.and.jfac(l1,l2,-1000).ne.1) go to 800
      go to 1000
  200 jpo=j+1
      if(jpo.gt.numb) go to 800
      do 700 kkk=jpo,numb
c  *******************************************************************
      kcc = kkk
      if (jpart.ne.0) kcc = iorde(kkk)
      if(must.eq.3) go to 800
      if(kcc.eq.min) must=3
c  ******************************************************************
      if (jpart.eq.0) goto 250
      if (iz(kcc).ne.0.and.mod(iz(kcc),1000).ne.200) goto 700
      if(palf(kcc).lt.0.2) go to 700
      goto 255
  250 if(mkang(kcc).lt.0) goto 700
  255 if(mkg(kcc).eq.131328) go to 700
      nral3=nral2
      if(mkang(kcc).eq.1) nral3=nral3+1
      if(nral3.gt.nral) go to 700
      n3=n2
      call sir_unpack(mkg(kcc),j3,k3,l3)
      if(must.eq.0) go to 700
c     test with origin rules if three reflexions are needed
      mdet=j1*(k2*l3-k3*l2)-j2*(k1*l3-k3*l1)+j3*(k1*l2-k2*l1)
      maxm=modul(1)+modul(2)+modul(3)
c     modulus = (0,0,0) or (2,2,2)
      if(iabs(mdet).eq.1) go to 1000
      if(maxm.eq.0) go to 700
      if(maxm.eq.2) go to 600
c     modulus = (0,2,2), (2,0,2) or (2,2,0)
      if(mod(mdet,2).eq.0) go to 700
c     modulus = (0,2,2)
      if(modul(1).eq.0.and.jfac(j1,j2,j3).ne.1) go to 700
c     modulus = (2,0,2)
      if(modul(2).eq.0.and.jfac(k1,k2,k3).ne.1) go to 700
c     modulus = (2,2,0)
      if(modul(3).eq.0.and.jfac(l1,l2,l3).ne.1) go to 700
      go to 1000
  600 if(modul(2).ne.2) go to 650
c     modulus = (0,2,0)
      if(k1.eq.1.and.iabs(j2*l3-j3*l2).eq.1) go to 1000
      if(k2.eq.1.and.iabs(j3*l1-j1*l3).eq.1) go to 1000
      if(k3.eq.1.and.iabs(j1*l2-j2*l1).eq.1) go to 1000
      go to 700
c     modulus = (0,0,2)
  650 if(l1.eq.1.and.iabs(j2*k3-j3*k2).eq.1) go to 1000
      if(l2.eq.1.and.iabs(j3*k1-j1*k3).eq.1) go to 1000
      if(l3.eq.1.and.iabs(j1*k2-j2*k1).eq.1) go to 1000
  700 continue
  800 continue
  900 continue
  950 jump=-1
      return
 1000 if(ial.eq.0) return
      l=0
 1050 l=l+1
      igin(l)=i
      if(l.eq.nori) goto 1300
      if(l.eq.1) i=j
      if(l.eq.2) i=kcc
       go to 1050
 1300 jump=0
      return
      end
c     ------------------------------------------------------------------
c     test for common factor (.gt.1) amongst k,l,n
      function jfac(k,l,n)
      dimension in(3)
      in(1) = k
      in(2) = l
      in(3) = n
      jfac=1
      m = 1000
      j = 0
      do 100 i = 1,3
      if(in(i).eq.0) go to 100
      j = j + 1
      in(j) = in(i)
      m = min0(m,in(j))
100   continue
      if(m.eq.1) return
      do 200 i = 2,m
      do 150 jj = 1,j
      if(mod(in(jj),i).ne.0) go to 200
150   continue
      jfac = i
      go to 300
200   continue
300   return
      end
c     ------------------------------------------------------------------
c     determine   the   enantiomorph   fixing   reflexion
      subroutine starts(nsymb,ier)
      common /param2/ mkg(500),modul(3)
      common /param/ numb,nant(4),nral,alra,sumalf,ssig,nref,duma
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngenn
     *,irot(48,48),jsvet(10),isvet(8),nori,imod(3),nss(3)
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /unp/ hmax,kmax,lmax,iplan,irang,iplan2
      common /partia/e(800),ep(800),kdstor(500),iphp(800),
     * iverbo,imk,gminpa,aksca,ssims,cutpa
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /sup/ ibufr(80,3),bufr(80,2),n,zi,zpi,k,nlist,buf(80),
     *ibuf(80,4),n1,ntrip,idumm1(500),n0,ibu(80,2),bu(80),lcri,
     * nbset,pub(800)
      common /xdata/ imat(3,20000),z(500),iee(20000),iph(41000),
     2 iphaz(500),iorde(500),alfest(500),iz(500),ih(800),e1(800),
     3 limref(500),mkang(800),alfvar(500),ifstor(500),alphac(500),
     4 icont(3),idummy(500),wt(500),zp(500),irefin(500),nn(8),
     5 nbinv(61000),eni1(4),lin1(4,6),dummx(53061)
      integer hmax,pub
c     * * * * * * * * * * * * * * * * ** * * * * * * * * * * * * * * * *
c     has enantiomorph been fixed     nant(1) .eq. 0 if not
      nbs1 = nbset + 1
 1580 if (nant(1)) 2160,1590,1584
c     does the enantiomorph  fixing  reflexion  also  define  the origin
 1584 max = nant(1)
      alfmax = abs(alfest(max))
      if (iz(max).ge.0) goto 2160
c     does the  enantiomorph  need to be fixed   -  icent .ne. 0  if not
      if (icent) 2105,1595,2105
 1590 if (icent.ne.0) goto 2160
c     enantiomorph to be fixed  -  initialise alfest
 1595 do 1597 i=1,numb
      alfest(i) = abs(alfest(i))
 1597 continue
      jump = 0
      nan = 1
c     test for primitive space group with seminvariant  modulus  (2,2,2)
      if (latt.ne.1) goto 1605
      j = 4 - nori
      do 1603 i=j,3
      if (modul(i).ne.2) goto 1605
 1603 continue
      jump = 1
 1605 if (nant(1).ne.0) goto 1625
c     select enantiomorph reflexion from bottom of the convergence map
c     is there a permutable reflexion in the starting set?
      if(nsymb.eq.0) goto 2120
c     select lowest reflexion used in convergence map
      max = 0
      alfmax = 0.0
      do 1615 i=1,numb
      min = iorde(i)
      if (iz(min).ne.(-100)) goto 1615
      li = limref(min)+1
      lf = limref(min+1)
      if (li.gt.lf) goto 1615
      do 1614 jj=li,lf
      ind=nbinv(jj)
      call depacc (min,ind,a,ifaz,iw)
      ila=iabs(nn(1))
      ira=iabs(nn(2))
      ita=iabs(nn(3))
      if (iz(ila).ne.(-1)) goto 1609
      if(alfest(ila).le.alfmax) goto 1609
      if(jump.eq.1.and.mkang(ila).eq.1) go to 1609
      max = ila
      alfmax = alfest(ila)
      if (iprin.eq.2) write(lo,1612) max,ila,ira,i
 1612  format(5x,' max',i3,' ila',i3,' ira',i3,' i',i3)
 1609  if(ira.eq.0) goto 1610
      if (iz(ira).ne.(-1)) goto 1610
      if(alfest(ira).le.alfmax) goto 1610
      if(jump.eq.1.and.mkang(ira).eq.1) go to 1610
      max = ira
      alfmax = alfest(ira)
       if (iprin.eq.2) write(lo,1612) max,ila,ira
 1610  if(ita.eq.0) goto 1614
      if (iz(ita).ne.(-1)) goto 1614
      if(alfest(ita).le.alfmax) goto 1614
      if(jump.eq.1.and.mkang(ita).eq.1) go to 1614
      max = ita
      alfmax = alfest(ita)
      if (iprin.eq.2) write(lo,1612) max,ila,ira,ita,i
 1614 continue
      if(max.ne.0)  goto 1625
 1615 continue
      if(jump.eq.0) goto 2120
c     select general reflexion with highest expected alpha
 1625 if (jump.le.0) goto 1860
      if(max.ne.0) go to 1635
1628  do 1630 i = nbs1,numb
      jdv = iorde(i)
      if(alfest(jdv).le.0.0) go to 1630
      if(mkang(jdv).eq.1) go to 1630
      max = jdv
      go to 1635
1630  continue
      if(jump.eq.2) go to 2120
      jump=2
      goto 1605
c     to determine  whether  enantiomorph  fixing  reflexion  must  have
c     positive real (nan = -1) or imaginary (nan = 1) part,  find linear
c     dependence of enantiomorph fixing reflexion on  origin  reflexions
 1635 log1 = 0
      call sir_unpack(mkg(max),m1,m2,m3)
      l1 = m1
      l2 = m2
      l3 = m3
      norf=0
      do 1800 j=1,numb
      if(mod(iz(j),1000).ne.200) goto 1800
      norf=norf+1
      call sir_unpack(mkg(j),j1,j2,j3)
      log2 = mod(m1 + j1, 2) + mod(m2 + j2, 2) + mod(m3 + j3, 2)
      if (log2.gt.0) goto 1660
c     reflexion is linearly dependent on one origin reflexion
      if(iabs(mkang(j)-7)-3) 1840,1820,1820
 1660 jp=j+1
      if(norf.eq.nori) jp=1
      do 1670 k=jp,numb
      if(mod(iz(k),1000).eq.200) goto 1675
 1670 continue
 1675 call sir_unpack(mkg(k),k1,k2,k3)
      log2 = mod(m1+j1+k1,2) + mod(m2+j2+k2,2) + mod(m3+j3+k3,2)
      if (log2.gt.0) goto 1700
c     reflexion is linearly dependent on two origin reflexions
      if(iabs(mod(mkang(j)+mkang(k)-2,12) - 6) - 3) 1840,1820,1820
c     determine linear dependence on all three origin reflexions
 1700 log1 = log1 + mkang(j) - 1
      l1 = l1 + j1
      l2 = l2 + j2
      l3 = l3 + j3
      if (iprin.eq.2) write(lo,1705)max,m1,m2,m3,mkang(max),
     1j,j1,j2,j3,mkang(j),k,k1,k2,k3,mkang(k),norf,l1,l2,l3
 1705 format(i10,'***',4i8)
 1800 continue
      if (mod(l1,2) + mod(l2,2) + mod(l3,2)) 2100,1810,1820
c     reflexion is linearly dependent on three origin reflexions
 1810 if(iabs(mod(log1,12) - 6) - 3 )  1840,1820,1820
c     imaginary part must be positive to fix enantiomorph
 1820 nan = 1
      go to 1860
c     real part must be positive to fix enantiomorph
 1840 nan = -1
 1860 if (mkang(max).le.1) goto 2060
      if (iabs(mkang(max) - 7) - 3 )  2020,2040,2040
 2020 if (nan) 2100,2100,2080
 2040 if (nan) 2080,2100,2100
 2060 if (nan) 2080,2100,2080
 2080 nant(1) = nan * max
      go to 2160
 2100 alfest(max) = -alfest(max)
      if (nant(1).ne.0) goto 2105
      if(jump.ne.0) go to 1628
      go to 1605
c     output error message
 2105 write (lo,2110)
 2110 format(/,' ****  warning :  enantiomorph fixing reflexion chosen b
     *y the user does not fix the enantiomorph'//)
c     remove reflexion and try again
      do 2115 i=1,3
      nant(i) = nant(i+1)
 2115 continue
      go to 1580
 2120 write (lo,2140)
 2140 format(/,' ****  warning :  the reflexions in the starting set wil
     *l not define the enantiomorph',
     *       /,'                  the last general  reflexion eliminated
     * by converge is added to the starting set.')
c+++++++++++++++  introduzione routine di ricerca riflesso per enantiomo
      do 2145 i= nbs1,numb
      nr =iorde(i)
      if (mkang(nr).eq.1) goto 2150
 2145  continue
      write(lo,2148)
 2148 format(/,' *** error *** the enantiomorph can not be fixed',
     *       /,'               the program is interrupted')
      ier=-1
      return
 2150 nant(1)=nr
c+++++++++++++  fine routine per enantiomorfo
c====================================================
 2160 if(jpart.ne.0) goto 2190
      do 2180 i=1,numb
      alfest(i) = abs(alfest(i))
      if(i.lt.nbs1) go to 2180
      iorde(i) = 0
 2180 continue
 2190 do 2195 i=1,numb
      aa = alfest(i)
 2195 alfest(i) = abs (aa)
      if (icent.ne.0) go to 2200
      ns=iabs(nant(1))
      if(iz(ns).ge.-1) return
      iorde(nbs1)=ns
      iz(ns)=-1
      wt(ns)=1.
      wt(ns)=100.
      if(iabs(mkang(ns)).eq.1) wt(ns) =5.5
 2200 return
      end
c -----------------------------------------------------------------
      subroutine sort3 (alf,iorde,   numb)
c--sort the e(s) respect to the g (partial structure only)
c
      dimension alf(500),iorde(500)
      dimension wt(500)
      integer iorde
c--
      do 1010 i=1,numb
      wt(i)=alf(i)
1010  continue
      int = 2
1000  int = 2*int
      if(int .lt. numb) go to 1000
      int = min0(numb,(3*int)/4-1)
1020  int = int/2
      ifin = numb - int
      do 1120 ii=1,ifin
      i=ii
      j=i+int
      if(wt(i)-wt(j)) 1040,1120,1120
1040  a=wt(j)
      m=iorde(j)
1060  wt(j)=wt(i)
      iorde(j)=iorde(i)
      j=i
      i=i-int
      if(i) 1100,1100,1080
1080  if(wt(i)-a) 1060,1100,1100
1100  wt(j)=a
      iorde(j)=m
1120  continue
      if(int .gt. 1) go to 1020
      return
      end
c -------------------------------------------------------------------
      subroutine tstp(iph,iphz,iorde,wt,numb)
c--test delle fasi rispetto alle fasi vere
c
      dimension iph(500),iphz(500),iorde(500),wt(500)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      dimension a(5),b(5),f(5)
      do 1000 i=1,5
      a(i)=0.0
      b(i)=0.0
      f(i)=0.0
1000  continue
      do 1100 i=1,numb
      j=iorde(i)
      if(wt(j)) 1100,1100,1010
1010  continue
      c=iabs(iph(j)-iphz(j))
      if(c.gt.180) c=360.0-c
      a(1)=a(1)+c
      b(1)=b(1)+c**2
      f(1)=f(1)+1
      if(i.gt.50) go to 1020
      a(2)=a(2)+c
      b(2)=b(2)+c**2
      f(2)=f(2)+1
1020  continue
      if(i.gt.100) go to 1030
      a(3)=a(3)+c
      b(3)=b(3)+c**2
      f(3)=f(3)+1
1030  continue
      if(i.lt.numb-99) go to 1100
      a(4)=a(4)+c
      b(4)=b(4)+c**2
      f(4)=f(4)+1
      if(i.lt.numb- 49) go to 1100
      a(5)=a(5)+c
      b(5)=b(5)+c**2
      f(5)=f(5)+1
1100  continue
      do 1110 i=1,5
      if(f(i).lt.0.1) goto 1110
      a(i)=a(i)/f(i)
      b(i)=sqrt(b(i)/f(i))
1110  continue
      write(lo,1120)
1120  format(/,11x,'    all    f50   f100   l100    l50')
      write(lo,1130) (a(i),i=1,5),(b(i),i=1,5),(f(i),i=1,5)
1130  format(/,' (err)    =',5f7.1,/
     1        ,' (err**2) =',5f7.1,/
     2        ,' no. refl.=',5f7.0)
      return
      end
c ----------------------------------------------------------------------
      subroutine xsim (nspec,ngen,nany,larn,igin,norin)
c     calculate g(s) and phase(s) for the e(s) (partial structure
      common /param2/ mkg(500),modul(3)
      common /param/ numb,nant(4),nral,alra,sumalf,ssig,nref,duma
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,lgen
     *,irot(48,48),jsvet(10),isvet(8),nori,imod(3),nss(3)
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common /unp/ hmax,kmax,lmax,iplan,irang,iplan2
      common /partia/e(800),ep(800),kdstor(500),iphp(800),
     * iverbo,imk,gminpa,aksca,ssims,cutpa
      common /tables/ stable(500)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /sup/ ibufr(80,3),bufr(80,2),n,zi,zpi,k,nlist,buf(80),
     *ibuf(80,4),n1,ntrip,alpha(500),n0,ibu(80,2),bu(80),lcri,
     * nbset,pub(800)
      common /xdata/ imat(3,20000),z(500),iee(20000),iph(41000),
     2 iphaz(500),iorde(500),palf  (500),iz(500),ih(800),e1(800),
     3 limref(500),mkang(800),alfvar(500),ifstor(500),alphac(500),
     4 icont(3),idummy(500),wt(500),zp(500),irefin(500),nn(8),
     5 nbinv(61000),eni1(4),lin1(4,6),iee1(20000),dummx(33061)
c
      common /use1/ symb(12),symbo(500),nusy(500),inperm(12)
      common /use2/ ipigin(3),icode(200),ifaz20(200),peso(200)
      integer hmax,pub,symb,igin(3)
      dimension enil(2,4)
      dimension line(2,7),ctable(500),zph(500),ielim(500)
      equivalence (stable(91),ctable(1))
      equivalence (ielim(1),symbo(1))
c
      vec(x)=amin1(x*(x+0.4807)/((x+0.8636)*x+1.3943),1.0)
c
      do 1480 i=1,450
      stable(i)=sin(dtor * float(i-1))
 1480 continue
      write(lo,1010)
 1010 format(//,45x,' partial structure procedure',//)
 1    format(1x,i4,2f7.3,f7.1,3e10.4,15(1h*))
 10   format(1x,i4,2f7.3,i7,3e10.4,15(1h*))
 2    format(1x,2(i4,2f7.3,f7.1),2e10.4)
 20   format(1x,2(i4,2f7.3,i7),2e10.4)
 3    format(1x, 5e10.4,4i8)
      do 1015 i=1,numb
      iorde(i)=i
      zph(i)=1.0
      palf(i)=2.0*e(i)*ep(i)
      if(iphp(i).le.  0) iphp(i)=iphp(i)+360
1015  continue
      if(knw.eq.0) go to 3560
      do 1030 i=1,numb
      kdstor(i)=iphaz(i)
      if(kdstor(i).le.0) kdstor(i)=kdstor(i)+360
1030  continue
c
c-- 1 tabella : formula di sim
      call sort3 (palf,iorde,numb)
      call tstp (iphp,kdstor,iorde,zph,numb)
c     iverbo=1
      if (iverbo.eq.1) write (lo,101)
 101  format(  //40x, ' table of estimated g(s) and phase(s) ',
     1 /,1x,2(' code  h  k  l    e    ep  alpha  palf  phip  phic  ',
     2 'phiv ', 9x))
      k=0
      do 110 n=1,numb
      i=iorde(n)
      k=k+1
      line(k,1) = i
      ie=ih(i)/500000
      ihh=ih(i)-500000*ie
      call unpacc(ihh,line(k,2),line(k,3),line(k,4))
      enil(k,1) = e(i)
      enil(k,2) = ep(i)
      enil(k,3) = alpha(i)
      enil(k,4) = palf (i)
      line(k,5) = iphp(i)
      line(k,6) = iphaz(i)
      line(k,7) = kdstor(i)
      if (iverbo.ne.1) goto 108
      if (k - 2) 110,50,50
   50 write (lo,1055) ((line(m,l),l=1,4),(enil(m,l),l=1,4),(line(m,l),
     1  l=5,7),m=1,2)
  108 k = 0
  110 continue
      if (iverbo.ne.1) goto 140
      if (k) 140,140,120
  120 write (lo,1055) ((line(m,l),l=1,4),(enil(m,l),l=1,4),(line(m,l),
     1  l=5,7),m=1,k)
  140 continue
      mark=0
c
c--calcolo dell'errore medio della struttura (fasi note)
c  2 tabella : da c.giacovazzo  (eeq.26) con w=1 e phi=phi(vere)
c  3 tabella : formula della tangente ( phi=phi(vere))
c
3210  do 3500  i=1,numb
      ll = i
      palf (ll)=0.0
      li=limref(ll)+1
      ls=limref(ll+1)
      if (li-ls) 3220,3220,3500
 3220 sumden=0.0
      sumnum=0.0
      do 3400 jj=li,ls
      ind=nbinv(jj)
      call depacc(ll,ind,a1,ifaz,iw)
      il=nn(1)
      ila=iabs(nn(1))
      ir=nn(2)
      ira=iabs(nn(2))
      if (ira.eq.0) goto 3400
      ipphh=iphaz(ila)
      ifaz1 = isign(ipphh,il)
      ipphh=iphaz(ira)
      ifaz2 = isign(ipphh     ,ir)
      ip = ifaz
      iarg = mod(ifaz1 + ifaz2 + 15 * ip + 1440, 360) + 1
      if(mark.eq.0) go to 3230
      ee=a1
      go to 3240
3230  ee=e (ila)*e (ira)
      sumnum = sumnum + ee * stable(iarg)
      sumden = sumden + ee * ctable(iarg)
      ee=ep(ila)*e (ira)
      ipphh=iphp(ila)
      ifaz1p=isign(ipphh,il)
      iarg = mod(ifaz1p + ifaz2 + 15 * ip + 1440, 360) + 1
      sumnum = sumnum - ee * stable(iarg)
      sumden = sumden - ee * ctable(iarg)
      ee=e (ila)*ep(ira)
      ipphh=iphp(ira)
      ifaz2p=isign(ipphh,ir)
      iarg = mod(ifaz1  + ifaz2p + 15 * ip + 1440, 360) + 1
      sumnum = sumnum - ee * stable(iarg)
      sumden = sumden - ee * ctable(iarg)
      ee=ep(ila)*ep(ira)
      iarg = mod(ifaz1p + ifaz2p + 15 * ip + 1440, 360) + 1
3240  sumnum = sumnum + ee * stable(iarg)
      sumden = sumden + ee * ctable(iarg)
 3400 continue
      if(mark.eq.1) go to 3250
      iarg=mod(iphp(ll)+360,360)+1
      sumnum=sumnum*e(ll)*s3s2p +2.0* e(ll)*ep(ll)*stable(iarg)
      sumden=sumden*e(ll)*s3s2p +2.0* e(ll)*ep(ll)*ctable(iarg)
3250  id = 15 * mkang(ll)  - 14
      if(sumnum.ne.0.0.or.sumden.ne.0.0) then
                            phaz  = rtod * atan2(sumnum, sumden)
                         else
                            phaz = 0.
                         endif
      if (phaz .le. 0.0)  phaz = phaz + 360.0
      alfa = sumnum**2 + sumden**2
      if (id .eq. 1) go to 3405
      ifaz1=phaz+0.5
      id1=id-1
      iarg=mod(ifaz1-id1+720,360)+1
      a=ctable(iarg)
      phaz=id1
      if(a) 3403,3404,3404
3403  phaz=phaz+180
3404  alfa=alfa*abs(a)
3405  continue
      palf (ll) = sqrt(alfa)
      iphaz(ll) = phaz + 0.5
 3500 continue
      call sort3 (palf ,iorde,   numb)
      call tstp (iphaz,kdstor,iorde,zph,numb)
      do 3505 i=1,numb
3505  iphaz(i)=kdstor(i)
      mark=mark+1
      if(mark.eq.1) go to 3210
c
c--------------------------------------------------------
c     procedimento per il calcolo dell'alfa
c
3560  continue
      ssims=0.0
      salfas=0.0
      do 4100 i=1,numb
      lim1 = limref(i) + 1
      lim2 = limref(i+1)
      iorde(i)=i
      aa=0.0
      bb=0.0
      cc1=0.
      cc2=0.
      vecen=2.0*e(i)*ep(i)
      iarg=mod(iphp(i)+360,360)+1
      vecea=vecen*ctable(iarg)
      vecex=vecen*stable(iarg)
      aa=vecea
      bb=vecex
      cc=vecen*vecen
      if(iverbo.eq.1) write(lo,10) i,e(i),ep(i),iphp(i),
     1 vecen,vecea,vecex
      if(lim1 .gt. lim2) go to 4042
      do 4040 j=lim1,lim2
      ind=nbinv(j)
      call depacc(i,ind,a1,ifaz,iw)
      il=nn(1)
      ila=iabs(nn(1))
      ir=nn(2)
      ira=iabs(nn(2))
      if (ira.eq.0) goto 4040
      irr=iphp(ila)
      ifaz1=isign(irr,il)
      irr=iphp(ira)
      ifaz2=isign(irr,ir)
      ip=ifaz
      iarg=mod(ifaz1+ifaz2+15*ip+1440,360)+1
      q2 = e (ila) * e (ira)
      q3 = ep(ila) * e (ira)
      q4 = e (ila) * ep(ira)
      q5 = ep(ila) * ep(ira)
      g2 = (2.0 * e(ila) * ep(ila))* 0.70
      g3 = (2.0 * e(ira) * ep(ira))* 0.70
      vecen=s3s2p*e(i)*vec(g2)*vec(g3)* ( q2 -
     1 q3 - q4 + q5 )
      vecea=vecen*ctable(iarg)
      vecex=vecen*stable(iarg)
      cc1=cc1+vecea
      cc2=cc2+vecex
      aa     = aa    +vecea
      bb     = bb    +vecex
      if(iverbo.ne.1) go to 4040
      pp=atan2(bb,aa) * rtod
      w=sqrt(aa**2+bb**2)
      write(lo,20) il ,e(ila),ep(ila),iphp(ila),
     1              ir ,e(ira),ep(ira),iphp(ira),w,pp
      ipp=ip*15
      write(lo  ,3)  vecen    ,vecea    ,vecex,aa,bb      ,iarg
     1,ifaz1,ifaz2,ipp
 4040 continue
 4042 continue
      id = 15 * mkang(i) -14
      if(bb.ne.0.0.or.aa.ne.0.0) then
                                   pp= rtod * atan2(bb, aa)
                                 else
                                   pp=0
                                 endif
      if (pp   .le. 0.0)  pp   = pp   + 360.0
      alfa = bb**2 + aa**2
      cc3=cc1**2 + cc2**2
      if (id .eq. 1) go to 4030
      ifaz1=pp+0.5
      id1=id-1
      iarg=mod(ifaz1-id1+720,360)+1
      a=stable(iarg+90)
      pp=id1
      if(a) 4033,4034,4034
4033  pp=pp+180
4034  alfa=alfa*abs(a)
4030  continue
      iphaz(i) =pp+0.5
      cc=sqrt(cc)
      cc3=sqrt(cc3)
      palf(i)=cc3
      ssims=ssims+cc
      salfas=salfas+cc3
 4100 continue
      aksca= ssims/salfas
      do 3900 i=1,numb
      vecen=2.0*e(i)*ep(i)
      if(aksca.le.1.0) palf(i)=(vecen+palf(i)*aksca)*0.5
      if(aksca.gt.1.0) palf(i)=(vecen+palf(i))/(1.0+1.0/aksca)
 3900 continue
      call sort3 (palf,iorde,numb)
c     iverbo=1
      if (iverbo.eq.1) write (lo,4101)
 4101 format(  //40x, ' table of estimated g(s) and phase(s) ',
     1 /,1x,2(' code  h  k  l    e    ep  alpha  palf  phip  phic  ',
     2 'phiv ', 9x))
      k=0
      do 4110 n=1,numb
      i=iorde(n)
      k=k+1
      line(k,1) = i
      ie=ih(i)/500000
      ihh=ih(i)-500000*ie
      call unpacc(ihh,line(k,2),line(k,3),line(k,4))
      enil(k,1) = e(i)
      enil(k,2) = ep(i)
      enil(k,3) = alpha(i)
      enil(k,4) = palf (i)
      line(k,5) = iphp(i)
      line(k,6) = iphaz(i)
      line(k,7) = kdstor(i)
      if (iverbo.ne.1) goto 4108
      if (k - 2) 4110,4050,4050
 4050 write (lo,1055) ((line(m,l),l=1,4),(enil(m,l),l=1,4),(line(m,l),
     1  l=5,7),m=1,2)
 1055 format(1x,2(i5,3i3,2f6.2,2f6.2,3i6,10x))
 4108 k = 0
 4110 continue
      if (iverbo.ne.1) goto 4140
      if (k) 4140,4140,4120
 4120 write (lo,1055) ((line(m,l),l=1,4),(enil(m,l),l=1,4),(line(m,l),
     1  l=5,7),m=1,k)
 4140 continue
c     iverbo=0
c
c--4 tabella : da c.giacovazzo (calcolo dell'alfa)
      if(knw.ne.0) call tstp(iphaz,kdstor,iorde,zph,numb)
c
c--calcolo dell'alpha massimo
      do 4201 i=1,numb
      lim1 = limref(i) + 1
      lim2 = limref(i+1)
      vecen=2.0*e(i)*ep(i)
      aa=0.0
      if(iverbo.eq.1) write(lo  ,1) i,e(i),ep(i),iphp(i),vecen
      if(lim1 .gt. lim2) go to 4242
      do 4240 j=lim1,lim2
      ind=nbinv(j)
      call depacc(i,ind,a1,ifaz,iw)
      il=nn(1)
      ila=iabs(nn(1))
      ir=nn(2)
      ira=iabs(nn(2))
      if (ira.eq.0) goto 4240
      q2 = e (ila) * e (ira)
      q3 = ep(ila) * e (ira)
      q4 = e (ila) * ep(ira)
      q5 = ep(ila) * ep(ira)
      g2 = 2.0 * e (ila) * ep(ila)
      g3 = 2.0 * e (ira) * ep(ira)
      vecea=s3s2p*e(i)*vec(g2)*vec(g3)*(q2-q3-q4+q5)
      aa=aa+abs(vecea)
      if(iverbo.ne.1) go to 4240
      write(lo  ,2) il ,e(ila),ep(ila),iphp(ila),
     1              ir ,e(ira),ep(ira),iphp(ira)
      write(lo  ,3) vecea,aa
 4240 continue
      if(aksca.gt.1.0) alpha(i)=(aa+vecen)/(1.0+1.0/aksca)
      if(aksca.le.1.0) alpha(i)=(aa*aksca+vecen)*0.5
      goto 4201
 4242 continue
      alpha(i)= vecen
 4201 continue
      if (iverbo.eq.1) write (lo,4262)
 4262 format(  //40x, ' table of estimated g(s) and phase(s) ',
     1 /,1x,2(' code  h  k  l    e    ep  amx-a   fom  phis  phit  ',
     2 'phiv ', 9x))
      k=0
      do 4310 n=1,numb
      i=iorde(n)
      k=k+1
      line(k,1) = i
      ie=ih(i)/500000
      ihh=ih(i)-500000*ie
      call unpacc(ihh,line(k,2),line(k,3),line(k,4))
      enil(k,1) = e(i)
      enil(k,2) = ep(i)
      aa=alpha(i)-palf(i)
      enil(k,3) = aa
      if(palf(i).ne.0.)bb=(alpha(i)-palf(i))*alpha(i)/palf(i)
      enil(k,4) = bb
      line(k,5) = iphp(i)
      line(k,6) = iphaz(i)
      line(k,7) = kdstor(i)
      if (iverbo.ne.1) goto 4308
      if (k - 2) 4310,4350,4350
 4350 write (lo,1055) ((line(m,l),l=1,4),(enil(m,l),l=1,4),(line(m,l),
     1  l=5,7),m=1,2)
 4308 k = 0
 4310 continue
      if (iverbo.ne.1) goto 4340
      if (k) 4340,4340,4320
 4320 write (lo,1055) ((line(m,l),l=1,4),(enil(m,l),l=1,4),(line(m,l),
     1  l=5,7),m=1,k)
 4340 continue
c
      do 4360 i=1,numb
      alpha(i)=abs(alpha(i)-palf(i))
 4360 continue
      return
      end
c-----------------------------------------------------------------------
      subroutine xcon  (nspec,ngen,nany,larn,igin,norin)
c--definisce origine e riflessi dello starting set per strutture
c  parziali
      common /param2/ mkg(500),modul(3)
      common /param/ numb,nant(4),nral,alra,sumalf,ssig,nref,duma
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,lgen
     *,irot(48,48),jsvet(10),isvet(8),nori,imod(3),nss(3)
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /unp/ hmax,kmax,lmax,iplan,irang,iplan2
      common /partia/e(800),ep(800),kdstor(500),iphp(800),
     * iverbo,imk,gminpa,aksca,ssims,cutpa
      common /tables/ stable(500)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /sup/ ibufr(80,3),bufr(80,2),n,zi,zpi,k,nlist,buf(80),
     *ibuf(80,4),n1,ntrip,alpha(500),n0,ibu(80,2),bu(80),lcri,
     * nbset,pub(800)
      common /xdata/ imat(3,20000),z(500),iee(20000),iph(41000),
     2 iphaz(500),iorde(500),palf  (500),iz(500),ih(800),e1(800),
     3 limref(500),mkang(800),alfvar(500),ifstor(500),alphac(500),
     4 icont(3),idummy(500),wt(500),zp(500),irefin(500),nn(8),
     5 nbinv(61000),eni1(4),lin1(4,6),iee1(20000),dummx(33061)
      common /use1/ symb(12),symbo(500),nusy(500),inperm(12)
      common /use2/ ipigin(3),icode(200),ifaz20(200),peso(200)
      integer hmax,pub,symb,igin(3),ipar(8)
      dimension aline(5)
      dimension ctable(500),iorde1(500),ielim(500),line(5,3)
      equivalence (stable(91),ctable(1))
      equivalence (ielim(1),symbo(1))
c *********************************************************************
c
c  definizione gmin - imk
c
c ********************************************************************
      imk = 15
      gmin = 4.0
  901 nmk=0
      do 1000 ii=1,numb
      i=iorde(ii)
      if(ii.gt.imk) go to 1000
      if(palf(i).lt.gmin) go to 1000
      nmk=nmk+1
 1000 continue
      if(nmk.lt.7.and.imk.gt.8) then
                                if(imk.gt.12) then
                                               imk  = 12
                                               gmin = 3.0
                                               goto 901
                                              else
                                               imk  = 8
                                               gmin = 2.5
                                               goto 901
                                              endif
                                else
                                   if(nmk.ge.7) goto 1101
                                   imk = 4
                                   gmin = 1.5
                                endif
 1101 nmk=0
      do 1100 ii=1,numb
      i=iorde(ii)
      if(ii.gt.imk) go to 1110
      if(palf(i).lt.gmin) go to 1110
      nmk=nmk+1
      go to 1100
 1110 continue
      iz(i)=-100
 1100 continue
      imk=nmk
      if (iprin.lt.2) go to 1200
      k=0
      do 1103 n=1,numb
      i=iorde(n)
      k=k+1
      line(k,1)=i
      line(k,2)=iz(i)
      line(k,3)=mkang(i)
      aline(k)=palf(i)
      if(k.ne.5) go to 1103
      write(lo,1420) ((line(m,l),l=1,3),aline(m),m=1,5)
      k=0
 1103 continue
      if(k.ne.0) write(lo,1420)((line(m,l),l=1,3),aline(m),m=1,k)
c+++++++++++
 1200 nori=0
      do 1125 i=1,3
 1125 igin(i)=0
c+++++++++++
      if (nori.eq.0) goto 1242
      do 1240 i=1,nori
      min=igin(i)
      ihh=iphaz(min)
      if (mkang(min) - 1) 1350,1350,1380
c  count number of general  reflexions  used  for  origin  definition
 1350 larn = larn + 1
      if (larn) 1380,1380,1355
 1355 if (nant(larn)) 1365,1360,1365
 1360 nant(larn) = min
      go to 1370
 1365 nant(larn+1) = min
 1370 iz(min) = ihh*1000+200
      go to 1240
 1380 iz(min) = ihh*1000+200
 1240 continue
 1242 do 1238 ii=1,numb
      i=iorde(ii)
      ihh=iphaz(i)
      if(ii.gt.imk) go to 1236
      if(iz(i).eq. 0) iz(i)=ihh*1000+100
      go to 1238
 1236 continue
      if(iz(i).eq.0) iz(i)=-100
 1238 continue
      i=iorde(imk+1)
      gmin=palf(i)
      icenti=icent
      icent=1
      if(icenti.eq.1) go to 1490
c--controllo se l'enantiomorfo e' definito
      do 1470 i=1,imk
      ll=iorde(i)
      li=limref(ll)+1
      ls=limref(ll+1)
      if(li-ls)1450,1450,1470
1450  continue
      do 1460 jj=li,ls
      ind=nbinv(jj)
      call depacc(ll,ind,a1,ifaz,iw)
      il=nn(1)
      ila=iabs(il)
      if(iz(ila)) 1460,1460,1453
1453  ir=nn(2)
      ira=iabs(ir)
      if(iz(ira)) 1460,1460,1455
1455  ipphh=iphp(ila)
      ifaz1=isign(ipphh,il)
      ipphh=iphp(ira)
      ifaz2=isign(ipphh,ir)
      ip=ifaz
      iarg=mod(ifaz1+ifaz2+15*ip+1440,360)+1
      if(iarg.gt.30.and.iarg.lt.150) go to 1490
      if(iarg.gt.210.and.iarg.lt.330)go to 1490
1460  continue
1470  continue
      write (lo,2140)
 2140 format(  //53x,13h* ** *** ** *,/26x,67hthe reflexions in the star
     1ting set will not define the enantiomorph//)
c--l'enantiomorfo non e' definito
      icent=icenti
 1490 do 1239 ii=1,numb
      aa=palf(ii)
      palf(ii)=alpha(ii)
c     alpha(ii)=palf(ii)
      alpha(ii)=aa
 1239 continue
      jj = 0
      do 1235 jc = 1,numb
      jcc = iorde(jc)
      ihh = mod(iz(jcc),1000)
      if(ihh.ne.100) goto 1235
      jj = jj+1
      iorde1(jj) = iorde(jc)
 1235 continue
      do 1237 jc = 1,numb
      jcc = iorde(jc)
      ihh = mod(iz(jcc),1000)
      if(ihh.ne.200) goto 1237
      jj = jj+1
      iorde1(jj) = iorde(jc)
 1237 continue
c     * * * * * * * * * * * * * * * * ** * * * * * * * * * * * * * * *
c     routine  definizione  simboli
c     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ** *
      do 8000 i=1,8
      ipar(i) = 0
 8000 continue
c     determine parity of origin defining and  starting  set  reflexion
      do 8800 i=1,numb
c     test for starting set reflexion
      if(iz(i)+1) 8800,8040,8020
c     test for origin fixing reflexion
 8020 if(iz(i)-1000*(iz(i)/1000)-100) 8800,8800,8040
 8040 ihh=ih(i)-(ih(i)/500000)*500000
      call unpacc(ihh,m1,m2,m3)
      ind = 4*mod(iabs(m1),2)+2*mod(iabs(m2),2)+mod(iabs(m3),2)+1
      ipar(ind) = ipar(ind) + 1
 8800 continue
 8820 ip = 1000
      do 8160 i=1,8
      if (ipar(i)) 8160,8840,8840
 8840 if (ipar(i) .lt. ip) ip = ipar(i)
 8160 continue
      do 8170 i=1,numb
      aa=palf(i)
      palf(i) = abs(aa)
 8170 continue
c     find the highest estimated alpha among the  eliminated  reflexion
 1880 alfmax = 0.0
      do 8300 i=1,numb
      if(iz(i)+10) 8200,8300,8300
 8200 if(palf(i)-alfmax) 8300,8300,8220
 8220 max = i
      alfmax=palf(i)
 8300 continue
      if (alfmax) 8320,8320,8500
 8320 do 8400 i=1,8
      if (ipar(i) .gt. ip) go to 8400
      ipar(i) = -1
      go to (8380,8330,8340,8350,8360,8370,8380), latt
 8330 go to (8380,8400,8400,8380,8380,8400,8400,8380), i
 8340 go to (8380,8400,8380,8400,8400,8380,8400,8380), i
 8350 go to (8380,8380,8400,8400,8400,8400,8380,8380), i
 8360 go to (8380,8400,8400,8380,8400,8380,8380,8400), i
 8370 go to (8380,8400,8400,8400,8400,8400,8400,8380), i
 8380 continue
 8400 continue
      go to 8820
 8500 ihh=ih(max)-(ih(max)/500000)*500000
      call unpacc(ihh , m1,m2,m3)
      ind = 4*mod(iabs(m1),2)+2*mod(iabs(m2),2)+mod(iabs(m3),2)+1
      if (ipar(ind) - ip) 8540,8540,8520
 8520 palf(max)=-palf(max)
      go to 1880
 8540 if (mkang(max) - 1) 8545,8545,8555
 8545 if (ngen) 8565,8565,8550
 8550 ngen = ngen - 1
      go to 8575
 8555 if (nspec) 8565,8565,8560
 8560 nspec = nspec - 1
      go to 8575
 8565 if (nany) 8580,8580,8570
 8570 nany = nany - 1
 8575 iz(max) = -1
      ipar(ind) = ipar(ind) + 1
      palf(max) = -palf(max)
      go to 8820
 8580 if (nspec + ngen) 8582,8582,8520
 8582 continue
      do 8583  ii=1,numb
 8583 palf(ii)=abs(palf(ii))
c * * * * * * * * * * * * *  * * * * * * * * * * ** * * * * * *
      icent=icenti
      do 1231 ii=1,numb
      aa=palf(ii)
      palf(ii)=alpha(ii)
      alpha(ii)=aa
 1231 continue
      if(iprin.lt.2) go to 1401
      k=0
      do 1440 n=1,numb
      i=iorde(n)
      k=k+1
      line(k,1)=i
      line(k,2)=iz(i)
      line(k,3)=mkang(i)
      aline(k)=alpha(i)
      if(k.ne.5) go to 1440
      write(lo,1420) ((line(m,l),l=1,3),aline(m),m=1,5)
      k=0
 1440 continue
      if(k.ne.0) write(lo,1420)((line(m,l),l=1,3),aline(m),m=1,k)
 1401 continue
      k=0
      do 1300 jc=1,numb
      jcc=iorde(jc)
      if(iz(jcc).ne.-1) goto 1300
      k=k+1
      jj=jj+1
      iorde1(jj)=iorde(jc)
 1300 continue
c  nbset  =  number of known phases and origin reflexions
c     nbset = imk + nany
      nbset=jj
      imk=jj
      do 1405 jc=1,numb
      jcc=iorde(jc)
      if(iz(jcc).eq.-100) then
                            jj=jj+1
                            iorde1(jj)=iorde(jc)
                            endif
 1405 continue
      do 1410 ii=1,numb
 1410 iorde(ii)=iorde1(ii)
      if(iprin.lt.2) return
      k=0
      do 1430 n=1,numb
      i=iorde(n)
      k=k+1
      line(k,1)=i
      line(k,2)=iz(i)
      line(k,3)=mkang(i)
      aline(k)=palf(i)
      if(k.ne.5) go to 1430
      write(lo,1420) ((line(m,l),l=1,3),aline(m),m=1,5)
 1420 format(5(i5,i8,i4,f7.1))
      k=0
 1430 continue
      if(k.ne.0) write(lo,1420)((line(m,l),l=1,3),aline(m),m=1,k)
      iprin=0
      return
      end
c-----------------------------------------------------------------------
      subroutine tangen(nsrt,nrel,ns1mx,sogs2,ilist,
     *                  jproc,nusx,iy,fomin,mxsac,ier,par)
      common /param/ numb,nant(4),nral,ckae,salfe,ssig,nref,nsxx
      common /unp/hmax,kmax,lmax,iplan,irang,iplan2
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /cpseud/ npseud,lpseuv(12),llpse
      common / ureq1/ jpatt,jpunt(501),ksacc,jseteq,jumpp,jmpsie,nsec
      common/fom4/attl2,attl3,nqen,nen,ntrneg,ns1,ns2,nquar,nphas,nfom0,
     *            coeco
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngenn
     *,irot(48,48),jsvet(10),isvet(8),nori,imod(3),nss(3)
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common/rc/pippo(6),para(6),dumc(12)
      common/c/flgw(30),flgd(30),avr(30),dcv(50),slope,flgk,bt,sc,del,ks
      common /tables/ stable(500)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /mag/ sqp4,sq2pi,mi(15),ms(15),dx,iyyy,lasts
      common /psi0/ npsi,num0,alfest0(300),alfvar0(300),llll(300),
     1 lim0n(300),iph0n(20000)
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nat,f(9),nalf(8)
c
      common /sup/ ibufr(80,3),bufr(80,2),n,zi,zpi,k,nlist,buf(80),
     *ibuf(80,4),n1,ntrip,idumm1(500),n0,ibu(80,2),bu(80),lcri,
     * nbset,pub(800)
      common /xdata/ imat(3,20000),z(500),iee(20000),iph(41000),
     * iphaz(500),iorde(500),
     2 alfest(500),iz(500),ih(800),e(800),limref(500),mkang(800),
     3 alfvar(500),ifstor(500),alpha(500),icont(3),kdstor(500),wt(500),
     4 zp(500),irefin(500),nn(8),nbinv(61000),enil(4),line(4,6),absfom,
     5 resid,al2,al2m1,almed,nundet,error,errpes,fomps0,foms1,coms,
     6 fomrt(302,10),f1mx,f1mn,f2mx,f2mn,f21mx,f21mn,f22mx,f22mn,f23mx,
     7 f23mn,f3mx,f3mn,f4mx,f4mn,f5mx,f5mn,f6mx,f6mn,f7mx,f7mn,f8mx,
     8 f8mn,f9mx,f9mn,f10mx,f10mn,f11mx,f11mn,f12mx,f12mn,f13mx,f13mn,
     9 f14mx,f14mn,f15mx,f15mn,f16mx,f16mn,f17mx,f17mn,f18mx,f18mn,
     * iph1(500),negt1(500),negt2(500),iqu1(750),iqu2(750),
     1 iqu3(750),nent1(500),nent2(500),nq1(500),nq2(500),nq3(500),
     2 iph21(2514),iph22(2514),psivet(500),dummx(38210)
      common /cris/ numcri,jcran,maxtri,nstart,muset
c
      integer hmax,pub
      dimension ccffmm(302),ipos(302)
      dimension kline(500),ctable(500),par(12)
      equivalence (stable(91),ctable(1))
c
      icont(1)=0
      icont(2)=3
      if (jcran.eq.0) then
                        icont(3)=15
                      else
                        icont(3)=496
                      endif
      do 1480  i=1,450
      stable(i)=sin(dtor * float(i-1))
 1480 continue
c     write(6,*)' tangent: pi, dtor=',pi,dtor
      do 1485  i=1,500
 1485 kdstor(i)=0
      sqp4=sqrt(pi)
      sq2pi=2.0/sqp4
c  *****************************************************
c
c  lettura  relazioni e lettura riflessi
c
c  *****************************************************
      sigm=s3s2
      atoms=(1.0/s3s2)**2.0
      nat=int(atoms+0.05)
      write(lo,10)
   10 format(///,1h ,120('+'),//,42x,
     1 35h***   tangent formula section   ***,/)
c -----
c     call sub. lettura lista 8 : tripletti positivi
c -----
      iprea=-1
      call sflxx(iprea,8,ntot,ntrip,numb,ipten,iccd,imat)
c  *******************************************************************
c
c      leggi i parametri di     f a s t a n
c
c  *******************************************************************
c -----
c     call sub. per lettura preambolo lista 7
c -----
      call ysfl07(nref,numx,num0,npseud,iy)
      icode=2
      call refsto(icode)
c ---  calcola alfest ed alfvar
      call rialfnew(icent,sigm)
c ------------------------------------------------------------------
c
c    imposizione di jpart  nel caso di parziale  version 1988
c
      if (jpart.ne.0) then
                       jpart=0
                      endif
c ------------------------------------------------------------------
c  ************************************************
c  controllo file  relazioni
c  **************************************************
      if(iprin.eq.2)write(lo,20) nant,nrel
   20 format(///,' nant=',4i4,' nrel=',i6)
      if(iprin.eq.2) write(lo,30) (iorde(jcris),jcris=1,numb)
   30 format(//10x,'  contenuto  vettore  iorde  ',//,30(20i4,/))
      if(iprin.eq.2) write(lo,31) (iz(jcris),jcris=1,numb)
   31 format(//10x,'  contenuto  vettore  iz     ',//,30(10i6,/))
      if(iprin.eq.2) write(lo,4028) (jcris,zp(jcris),alfest(jcris),
     *  iz(jcris),wt(jcris),jcris=1,numb)
 4028 format(1h ,2(i4,'*',2e12.3,i8,f5.2))
c --- estrai i codici dei riflessi che definiscono l'origine e gli altri
c --- riflessi  dello starting  set
      do  550  i= 1,numb
c ---
c --- determina il tipo di riflesso: origine,simbolo,seminv. ad una
c --- fase (codici 1/2/3  rispettivamente)
c ---
      if(zp(i).eq.0)  goto 550
      if(zp(i).gt.0) goto 510
c --- il riflesso e' stato preso come simbolo se zp(i)  lt 0
      ncod=2
      goto  530
c  se zp(i) maggiore di 0 e wt(i) minore di 0 - semin. ad una fase
  510 if(wt(i).lt.0) goto 520
c --- riflesso origine se zp(i)  >  0 e wt(i) >0
      ncod=1
      goto 530
  520 ncod=3
  530 icont(ncod)=icont(ncod)+1
      nco = icont(ncod)
c  nel vettore kdstor() i numeri sequenziali dei riflessi origine - simb
c  seminvarianti  ad una fase
      kdstor(nco)=i
c --- memorizza  la fase
c --- controllando prima se il riflesso e' un simbolo
      if (ncod.eq.2) goto 550
      iphaz(i)=zp(i)
  550 continue
c =======================================================
c
c   scrittura  riflessi
c
c =====================================================
      jj=0
      if (iprin.ne.2) go to 8050
      do 8000 i=1,numb
      jj=jj+1
      line(jj,1)=i
      call unpacc(ih(i),line(jj,2),line(jj,3),line(jj,4))
      line(jj,5)=mkang(i)
      line(jj,6)=360
      if(knw.ne.0) line(jj,6)=pub(i)
      enil(jj)=e(i)
      if(jj.lt.3) goto 8000
      write(lo,5005) ((line(ii,ll),ll=1,6),enil(ii),ii=1,jj)
      jj=0
 5005 format(3(i5,')',3i4,2x,i3,'*',i5,f6.2,2x))
 8000 continue
      if(jj.eq.0) goto 8050
      write(lo,5005) ((line(ii,ll),ll=1,6),enil(ii),ii=1,jj)
 8050 continue
c==================================================
      nstart=numcri+nori
c     write(6,*) 'NSTART',nstart,numcri,nori,numb
      if (nant(1).ne.0) nstart=nstart+1
c     write(6,*) 'NSTART',nstart,numcri,nori,numb
c==================================================
c  calcola il numero di  simboli da considerare
      nsymb =icont(2)-3
      if(iprin.eq.2) write(lo,7060)icont,nsymb
 7060 format(///,'  icont =',3i6,' nsymb =',i6)
      nral = 0
      ns = 0
      mark = 0
      jj = 0
      ifsal = 0
c        count number of general and special reflexions in starting set
      do 200 i=1,numb
      if(iz(i) + 1) 115 , 150 , 120
c        eliminated reflexions
115   iz(i) = 0
      go to  200
120   iwt = mod(iz(i),1000)
c        iwt .le. 100  known reflexions
      if(iwt-100) 170 , 170 , 130
c        origin fixing reflexion - does it also fix enantiomorph
130   if(iabs(nant(1)).eq.i)  ns = ns + 1
      go to  170
c        starting set reflexion
150   if(mkang(i).eq.1)  go to  160
      iz(i) = -15000*(mod(mkang(i)-1,12)) - 360000
      ns = ns + 1
      if(mark.eq.0) mark = i
      go to  170
160   nral = nral + 1
170   jj = jj + 1
      kline(jj) = i
200   continue
      if(nant(2).gt.0) ns = ns + 1
      if(nant(3).gt.0) ns = ns + 1
      if (jcran.eq.1) then
c                       iy=67543
                        nsx=maxtri
                        nral=maxtri
                        go to 265
                      endif
      if(nral.gt.0) go to  210
      if(mark.gt.0)  iz(mark) = iz(mark) + 180000
      nral = 1
      go to  260
  210 ngen = nral
      call magic(nral)
      n =0
c
c
c        now, nral is the number of magic integer permutations
c
c     assign magic integer representation phi(n)=m(n)*x  to unknown
c     general phases in starting set. assign largest magic integer
c     (mi(1) as the integers in mi(i) are in decreasing order)
c     to enantiomorph defining phase if it is a general unknown phase.
      if(nant(1).eq.0) go to 230
      n1 = iabs(nant(1))
      if(iz(n1).ne.(-1)) go to 230
      if(mkang(n1).ne.1) goto 230
      iz(n1) = -mi(1)
      n=1
230   if(nral.eq.4) go to 260
      do 250 i=1,numb
      if(iz(i).ne.(-1)) go to  250
      n=  n + 1
      iz(i) = -mi(n)
250   continue
260   nsx = (2**ns) * nral
      if (nant(1).eq.0) go to 265
      if (icent.eq.0) nsx = nsx/2
      n1 = iabs(nant(1))
      if((mkang(n1).eq.1).and.(iz(n1).lt.0)) nral=nral/2
265   nuset = 0
      nsxx=nsx
      nsacc=0
      ksacc=0
      jseteq=0
      jumpp=0
      nfom0=0
      if (jcran.eq.0) write(lo,270) nsxx
      if (jcran.ne.0) write(lo,271) numcri,nsxx
  270 format(/11x,'     the total number of permutations is',i5)
  271 format( 11x,'          the number of random phases is',i5,/,
     *        11x,'      the total number of trials will be',i5)
      if(mxsac.eq.300) mxsac=nsxx
c ---
      n=0
      icenti=icent
      call yfl01
      call yfl02
      call yfl03
      icent=icenti
      if (jproc.eq.0) iy=67543
c ---
      coms=-0.1
      if(nsxx.lt.mxsac) mxsac=nsxx
cNEW
      mxsac=min0(mxsac,300)
cNEW
cNEW  if(mxsac.le.nsxx) write(lo,274) mxsac
                        write(lo,274) mxsac
  274 format(10x,'the maximum number of sets stored will be ',i4)
      lung=mxsac+2*knw*lasts
      call nfrm16(lung)
      call ysfl16(ccffmm,ipos,idum)
      xp = 0.0
      if (jcran.eq.1)  go to 290
      if (nral.eq.1)  go to 290
      if (jall.eq.1) write(lo,275)  nral
  275 format(5x,'the number of magic integer permutations is',i5,/)
      xp = 0.5 * dx - 360.0
      if(nant(1).lt.0)  xp = xp - 90.0
  280 if(xp.gt.(-360.1))  go to  290
      xp = xp + dx
      go to 280
290   nuset = nuset + 1
      if (coms.gt.fomin) goto 397
      do 300 i=1,numb
  300 iphaz(i) = 0
      if(nuset.le.nsx.and.jall.eq.1) write(lo,310) nuset,(kline(i),
c                                    write(lo,310) nuset,(kline(i),
     1 i=1,jj)
  310 format(/5x,'trial no.',i4,3x,'starting set phases',3x,20i4/,
     1 12(41x,20i4,/))
      call weipha(mark,xp,dx,ngen,par)
c  routine definizione set di fasi mediante randu
      if (jcran.eq.1) then
                        maxtri=maxtri-1
                        if (maxtri.lt.0) then
                                           mark=0
                                         else
                        ix=iy
                        do 315 i=4,icont(2)-1
 
c-fasi random           do 315 i=1,icont(2)-1
c per l'origine
                        k=kdstor(i)
                        if (k.eq.0) go to 316
 
c-fasi random           if (k.eq.0) go to 315
c per l'origine
                        call randu(ix,iy,yfl)
                        ix=iy
                        iphi=nint(yfl*360.0)
                        if(iabs(mkang(k)).eq.1) go to 314
                        idv = 15*mod(iabs(mkang(k))-1,12)
c-------
                        id1 = iabs(idv-iphi)
                        id2 = iabs(idv+180-iphi)
                        id1=min0(id1,360-id1)
                        id2=min0(id2,360-id2)
                        if (id1.lt.id2) then
                                          iphi=idv
                                        else
                                          iphi=idv+180
                                        endif
c-------
*                       if (yfl.ge.0.5) then
*                                         iphi=idv
*                                       else
*                                         iphi=idv+180
*                                       endif
c-------
  314                   iphi=mod(iphi,360)
                        iphaz(k)=iphi
  315                   continue
  316                   continue
                                         endif
                      call spb07(iy)
                    endif
      if (nsymb.eq.0.and.nuset.eq.1) goto 390
      if (mark.eq.0) go to 400
  390 call weitan(ilist,nuset,pub,ifsal,
     1  ns1mx,sogs2,sigm,mxsac,mxsaco,nsacc,aminco,nena)
      go to 290
  397 write(lo,398) fomin
  398 format(//,' a set with  cfom greater than',f6.3,' has been found.'
     1      ,//,' the multisolution procedure has been stopped.',//)
      if (nuset.le.mxsac) mxsac=nuset-1-jseteq
  400 continue
      if ((nuset-1-jseteq).lt.mxsac) mxsac=nuset-1-jseteq
      if (ksacc.lt.mxsac) mxsac=ksacc
  403 jumpp=1
      if(knw.eq.0.or.jpart.ne.0) goto 408
      do 405 i=1,numb
      wt(i)=1.0
      if(pub(i).eq.0) pub(i)=360
c-new anto 25/6/92
      if(ifsal.eq.0) wt(i)=100.
      li=limref(i)+1
      ls=limref(i+1)
      if(li.gt.ls) wt(i)=0.0
  405 iphaz(i) = pub(i)
      if(ifsal.eq.0) then
         mxsac=mxsac+2
      endif
      call weitan(ilist,nuset,pub,ifsal,
     1  ns1mx,sogs2,sigm,mxsac,mxsaco,nsacc,aminco,nena)
      if(ifsal.ne.0) goto 6200
      ifsal = 1
      nuset = nuset + 1
      go to 403
  408 nuset = nuset -1
c ---
 6200 if (knw.eq.1.and.jpart.eq.0) then
         nsacc=nsacc-2
         mxsac=mxsac-2
      endif
      if (ksacc.lt.mxsac) mxsac=ksacc
      noset=min0(nsacc,mxsac)
c ---
      if (nfom0.ne.0) write(lo,9020) nfom0
      if (jseteq.ne.0) write(lo,9015) jseteq
 9020 format(7x, 'the number of sets rejected with cfom=0.0 is ',i4)
 9015 format(10x,'the number of equivalent sets rejected is ',i4,//)
      call prtfom(noset,nena,ccffmm,numb,ier)
      return
      end
c-----------------------------------------------------------------------
      subroutine prtfom(noset,nena,ccffmm,numb,ier)
      character seed*10,cseed*10,blank*10,cbuff*119
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common /mag/ sqp4,sq2pi,mi(15),ms(15),dx,iyyy,lasts
      common /xdata/ prvet(60000),z(500),iee(20000),iph(41000),
     * iphaz(500),iorde(500),
     2 alfest(500),iz(500),ih(800),e(800),limref(500),mkang(800),
     3 alfvar(500),ifstor(500),alpha(500),icont(3),kdstor(500),wt(500),
     4 zp(500),irefin(500),nn(8),nbinv(61000),enil(4),line(4,6),absfom,
     5 resid,al2,al2m1,almed,nundet,error,errpes,fomps0,foms1,coms,
     6 fomrt(302,10),f1mx,f1mn,f2mx,f2mn,f21mx,f21mn,f22mx,f22mn,f23mx,
     7 f23mn,f3mx,f3mn,f4mx,f4mn,f5mx,f5mn,f6mx,f6mn,f7mx,f7mn,f8mx,
     8 f8mn,f9mx,f9mn,f10mx,f10mn,f11mx,f11mn,f12mx,f12mn,f13mx,f13mn,
     9 f14mx,f14mn,f15mx,f15mn,f16mx,f16mn,f17mx,f17mn,f18mx,f18mn,
     * iph1(500),negt1(500),negt2(500),iqu1(750),iqu2(750),
     1 iqu3(750),nent1(500),nent2(500),nq1(500),nq2(500),nq3(500),
     2 iph21(2514),iph22(2514),psivet(500),dummx(38210)
      dimension iprvet(60000),ccffmm(302),ipos(302),zero(6)
      equivalence (prvet(1),iprvet(1))
c
      do 10 i=1,6
   10 zero(i)=0.0
      nwro=0
      iploe=0
      inund=0
      blank='          '
      cseed=blank
      if (knw.eq.1.and.jpart.eq.0) then
          noset=noset+2
          if (fomrt(noset,10).lt.fomrt(noset-1,10)) then
              do 20 i=1,10
              a=fomrt(noset,i)
              fomrt(noset,i)=fomrt(noset-1,i)
              fomrt(noset-1,i)=a
   20         continue
              a=psivet(noset)
              psivet(noset)=psivet(noset-1)
              psivet(noset-1)=a
            endif
          endif
c
c-- transfer fom's values in prtvet to sort them
      k=0
      do 200 i=1,noset
      do 100 j=1,10
      k=k+1
  100 prvet(k)=fomrt(i,j)
      k=k+1
      prvet(k)=psivet(i)
      k=k+1
  200 iprvet(k)=i
      jump=-5
      iniz=1
      if (knw.eq.1) then
                      lung=noset-2
                    else
                      lung=noset
                    endif
c     lung=noset
      istep=12
      call sortz(iniz,lung,istep,jump)
      k=0
      l=0
      do 300 i=1,noset
      l=l+1
      k=k+5
      ccffmm(l)=prvet(k)
      k=k+7
      ipos(l)=iprvet(k)
  300 continue
      if (f18mx.lt.0.0) then
                          ier=-1
                          write (lo,630) (zero(i),i=1,6),
     *                                   (zero(i),i=1,6)
                        else
                     write (lo,630) f1mn,f15mn,f14mn,f16mn,f17mn,f18mn,
     *                              f1mx,f15mx,f14mx,f16mx,f17mx,f18mx
                        endif
  630 format(/// 22x,'+++++++++++++  figures  of  merit  ++++++++++++'
Corig* ,//31x,'  mabs   alcomb  pscomb  cphase   cfom      '
     * ,//31x,'  mabs   alcomb  pscomb  R(x,y)  cphase   cfom      '
     * ,/22x,'min    ',
     * 6f8.3,/,22x,'max    ',6f8.3)
      if (knw.eq.0) then
                      write(lo,635) cseed
                    else
                      write(lo,636) cseed
                    endif
Co635 format(///1h ,a10,2x,'set  (trial)',6x,'  mabs   alcomb  pscomb  c
  635 format(///1h ,a10,2x,'set  (trial)',6x,'  mabs   alcomb  pscomb  R
     *(x,y)  cphase   cfom',4x,'nundet',/)
Co636 format(///1h ,a10,2x,'set  (trial)',6x,'  mabs   alcomb  pscomb  c
  636 format(///1h ,a10,2x,'set  (trial)',6x,'  mabs   alcomb  pscomb  R
     *(x,y)  cphase   cfom',4x,'nundet',4x,'error   (w-error)',/)
      k=0
      do 690 i=1,noset
      do 675 j=1,119
  675 cbuff(j:j)=' '
      jj=i
      inuk=0
      psicom=prvet(k+11)
      if(prvet(k+6).ge.numb/2) then
                                 inund=inund+1
                                 inuk=1
                                 do 680 kk=k+1,k+5
  680                            prvet(kk)=zero(1)
                                 prvet(k+7)=zero(1)
                                 prvet(k+8)=zero(1)
                                 prvet(k+11)=zero(1)
                               endif
      nund=int(prvet(k+6))
      itrial=nint(prvet(k+10))
c     iyy=iprvet(k+11)
      seed=blank
C     write(seed,'(f9.3,1h )') psicom
c
c          put refined phases with same origin as true
c
*     if(knw.eq.1 .and. i.le.noset-2)then
*      call setorg(numb,ipos(jj),erm1,erm2,pub)
*      prvet(k+7)=erm1
*      prvet(k+8)=erm2
*     endif
      if(knw.eq.0) write(cbuff,650) seed,jj,itrial,
     *                  (prvet(kk),kk=k+1,k+2),psicom,
     *                  (prvet(kk),kk=k+3,k+5),nund
      if(knw.eq.1) write(cbuff,650) seed,jj,itrial,
     *                  (prvet(kk),kk=k+1,k+2),psicom,
     *                  (prvet(kk),kk=k+3,k+5),nund,
     *                  (prvet(kk),kk=k+7,k+8)
      enan=prvet(k+9)
      if( abs(enan) .lt. 0.0001 ) enan=99.0
      if(enan.lt.30.0.and.nena.ge.70) then
         iploe=1
         if(knw.eq.1) then
            write (cbuff(112:119),638) enan
         else
            write (cbuff(92:119),639) enan
         endif
      endif
      if (inuk.eq.1) then
                       nwro=nwro+1
                       if(knw.eq.1) then
                                      cbuff(111:114)='(**)'
                                    else
                                      cbuff(91:94)='(**)'
                                    endif
                     endif
      write(lo,'(a)') cbuff
c 638 format(1h+,102x,f4.1,' (*)')
  638 format(f4.1,' (*)')
c 639 format(1h+, 82x,f4.1,' (*)')
  639 format(f4.1,' (*)                    ')
* 648 format(1h+,102x,'(**)')
* 649 format(1h+,82x,'(**)')
  650 format(1h ,a10,2x,i3,'  (',i5,')',4x,6f8.3,3x,i5,1x,2f10.2)
      k=k+istep
  690 continue
      if (nwro.eq.lung) ier=-1
      if (iploe.gt.0) then
                        write(lo,700)
                      endif
      if (inund.gt.0) then
                        write(lo,710)
                        if (ifper.eq.1) then
                          ier=0
                          write(lo,730)
                        else
                          if (ier.eq.-1) write(lo,720)
                        endif
                      endif
  700 format(//,12x,'(*)   ***  warning  ***   possible loss of enantiom
     *orph. the written figure is the average value',/,38x,
     *'of the enantiomorph sensitive triplet and quartet phase values.'
     *,//)
  710 format(//,11x,'(**)  ***  warning  ***   the number of',
     *   ' undetermined phases is too hight',//)
  720 format(//,11x,'      ***   error   ***   all sets',
     *   ' have undetermined phases. sir stops',//)
  730 format(//,11x,'      *** warning   ***   all sets',
     *   ' have undetermined phases. sir doesn',2h't,' stop',//)
      lung=lung+2*knw*lasts
      call ysup16(ccffmm,ipos,lung)
      if (ier.eq.-1) then
                       call cancella(15)
                       call cancella(16)
                     endif
      return
      end
c-----------------------------------------------------------------------
       subroutine magic(ni)
c   subroutine to generate magic integers based on fibonacci series
      common /mag/ sqp4,sq2pi,mi(15),ms(15),dx,iyyy,lasts
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      if(ni.gt.1) go to 5
      mi(1) = 1
      max=ni
      ni = 4
      gam = 1.0
      en = 1.0
      xsum = 1.0
      dx = 90.0
      go to 35
    5 ni1 = iu(ni-1)
      ni1 = ni-1
      max = 1
      do 20 i = 1,ni1
   20 max = max + ms(i)
      max = 2*max - 1
      xsum = 0.0
      do 30 i = 1,ni
      mi(i) = max
      max = max - ms(i)
   30 xsum = xsum + float(mi(i))**2
      en = ni
      gam = gamfu(ni+1)
      dx = sq2pi*exp((alog(gam)-alog(xsum)*en*0.5)
     *  /(en-1.0))
      max = ni
      ni = int(1.0/dx) + 1
      if(mod(ni,2).ne.0) ni = ni + 1
c***  ni =4 * mi(1)
      dx = 360.0/float(ni)
 35   if(iprin.ne.0) write(lo,40) max,ni,dx,(mi(max-i+1),i=1,max)
 40   format(/3x,'sequence of',i4,'  m. i. (no. of intervals ='
     * ,i5,' dx =',f8.4,' )'/5x,15i7)
      return
      end
c --------------------------------------------------------------------
      function iu(n)
      common /mag/ sqp4,sq2pi,mi(15),ms(15),dx,iyyy,lasts
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c   function to derive terms of fibonacci series
      iu = 1
      ms(1) = 1
      ms(2) = 1
      nc = 2
20    if(nc.ge.n) return
      iu = iu + ms(nc-1)
      nc = nc+1
      ms(nc) = iu
      go to 20
      end
c     ------------------------------------------------------------------
      function gamfu(n)
c   function to compute the gamma function
      common /mag/ sqp4,sq2pi,mi(15),ms(15),dx,iyyy,lasts
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      gamfu = 1.0
      if(mod(n,2).ge.1) gamfu=sqp4
      if(n.le.2) return
      ns = 4
      if(gamfu.gt.1.0) ns = 3
      do 10 i=ns,n,2
      gamfu = 0.5*float(i-2)*gamfu
 10   continue
      return
      end
c ----------------------------------------------------------------------
      subroutine weipha(mark,xp,dx,ngen,par)
      dimension linex(20), par(12)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /param/ numb,nant(4),nral,ckae,salfe,ssig,nref,nsxx
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngenn
     *,irot(48,48),jsvet(10),isvet(8),nori,imod(3),nss(3)
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common /xdata/ imat(3,20000),z(500),iee(20000),iph(41000),
     * iphaz(500),iorde(500),
     2 alfest(500),iz(500),ih(800),e(800),limref(500),mkang(800),
     3 alfvar(500),ifstor(500),alpha(500),icont(3),kdstor(500),wt(500),
     4 zp(500),irefin(500),nn(8),nbinv(61000),enil(4),line(4,6),
     5 dummx(53061)
      common /cris/ numcri,jcran,maxtri,nstart,muset
c     * * * * * * * * * * * * * * * * ** * * * * * * * * * * * * * * * *
      nan = iabs(nant(1))
 1000 mark = 0
c     generate next set of phases for starting point
      if (nral .eq. 1) go to 1010
      xp = xp - dx
      if (xp.gt.(-720.1)) goto 1006
      xp = xp + 360.0
      go to 1010
 1006 mark = 1
 1010 do 1200 i=1,numb
      izt = iabs(iz(i))
      if (iz(i)) 1100,1020,1040
c     unknown phase
 1020 wt(i) = 0.0
      iphaz(i)=0
      go to 1200
c     origin fixing or known phase
 1040 iwt=iz(i)-1000*(iz(i)/1000)
      if (iwt.lt.100) goto 1060
c   riflessi  per  origine
      wt(i) = 100.
      goto 1180
 1060 wt(i)=besinv(float(iwt))
      go to 1180
c     has starting set phase been incremented
 1100 if (mark) 1170,1120,1170
 1120 if (mkang(i).eq.1) go to 1170
      iz(i) = iz(i) - 180000
      if(iz(i)+720000) 1140,1140,1160
 1140 iz(i)=iz(i)+360000
      go to 1170
 1160 mark = 1
 1170 if(mkang(i).ne.1) go to 1175
      if (jcran.eq.1) then
                        wt(i)=0.25
COLD                    wt(i)=0.80
                      else
                        wt(i)=par(ngen)
                      endif
      iphaz(i) = amod((float(iz(i))*xp), 360.0) + 0.5
      go to 1190
c    simbolo speciale  wt = 5.5
 1175 if (jcran.eq.1) then
corig                   wt(i)=0.25
                        wt(i)=0.80
                      else
                        wt(i)=100.0
                      endif
 1180 iphaz(i) = mod(iabs(iz(i)/1000), 360)
 1190 if (iphaz(i) .eq. 0) iphaz(i) = 360
c    simboli wt = 5.0
 1200 continue
      if (jcran.eq.1) goto 1220
      if (icent.ne.0) goto 1220
      if(mark.eq.0) go to 1220
c        reject sets which are enantiomorph equivalent
      if (nant(1).eq.0) goto 1208
      ns = iabs (nant(1))
      if(wt(ns) .ne. 0) goto 1208
      wt(ns) = 100.
      if(iabs(mkang(ns)).eq.1)  wt(ns) = 5.5
 1208 if (nant(1)) 1210,1220,1215
 1210 if (cos(dtor * float(iphaz(nan)))) 1000,1000,1220
 1215 if (sin(dtor * float(iphaz(nan)))) 1000,1000,1220
 1220 if (mark) 1230,1230,1270
 1230 if (icent.eq.1) go to 1360
      j=2+icent
      do 1240 i=j,4
      if (nant(i)) 1240,1360,1250
 1240 continue
      go to 1360
 1250 do 1260 k=j,i
      nant(k) = -nant(k)
      n1 = iabs(nant(k))
      iz(n1) = -(iz(n1) - 200) + 360200
      iphaz(n1) = mod(iabs(iz(n1)/1000), 360)
 1260 continue
      mark = 1
c     output starting point
 1270 if (jall.eq.0) goto 1360
      j=0
      do 1340 i=1,numb
      if (iz(i) .eq. 0) go to 1340
      j = j + 1
      linex(j) = iphaz(i)
      if (j .lt. 20) go to 1340
      write(lo,1320) (linex(k),k=1,j)
 1320 format(41x,20i4)
      j = 0
 1340 continue
      if(j .gt. 0) write(lo,1320) (linex(k),k=1,j)
 1360 return
      end
c  --------------------------------------------------------------------
      subroutine randu(ix,iy,yfl)
c ---
c ---computes uniformly distributed random real numbers between 0 and 1.
c ---
      iy=ix*65539
      if(iy)5,6,6
    5 iy=(iy+2147483647)+1
    6 yfl=iy
      yfl=yfl*.4656613e-9
      return
      end
c-----------------------------------------------------------------------
      subroutine dirpha (nlist,nsymb,sogs2,ns1mx,inpori,norig,
     * inpena,inpfas,igin,ipigin,icode,ifaz20,peso,iperm,inperm,nspec,
     * jtabl,ilist,iy,nusx,fomin,mxsac,
     * ier,jproc,jrej,nneg,nngq)
      character line*80,dire*80,diret*80
      character blank,digit*12,card(100)*80,ffile*80
      common /comdir/ icomq(200,2),maxcom,ipcom,ipdir,icomat
      common /chara/ blank,digit,card,ffile
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /param/ numb,nant(4),nral,alra,sumalf,ssig,nref,duma
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,imod(3),nss(3)
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common /partia/e(800),ep(800),kdstor(500),iphp(800),
     * iverbo,imk,gminpa,aksca,ssims,cutpa
      common /mag/ sqp4,sq2pi,mi(15),ms(15),dx,iyyy,lasts
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /cris/ numcri,jcran,maxtri,nstart,muset
      common /gian/ limref0(800),nbinv0(61000),jph0(40000),knewpsi,
     *              alphap(300),ktheta(300),a0est(300),a0var(300)
      integer igin(3),icode(200),ifaz20(200),ipigin(3),inperm(12)
      dimension peso(200)
      dimension vet(40),ivet(40)
c -----
      call ysfl07(nref,numb,num0,npseud,iy)
c -----
c-- set default values
      iynew=0
      iydef = -1
      knewpsi=1
      nneg=1
      nngq=1
      jproc=1
      jrej=1
      muset=-1
      jcran=0
      maxtri=100
      numcri=numb/2
      nqq=0
      nlist=0
      sogs2=0.
      ns1mx=3
      lasts=0
      iprin=0
      inpori=0
      inpena=0
      inpfas=0
      iperm=0
      nspec=0
      norig=0
      jtabl=0
      nusx=100
      fomin=0.95
      do 5 i=1,3
      igin(i)=0
    5 ipigin(i)=0
c--
      ilist=0
      jall =0
      nset=0
      cutpa=0.05
      gminpa=4.0
      do 7 jcris=1,20
    7 iset(jcris)=0
      nsymb=5
      mxsac=10
      ic=0
      icmax=icomq(icomat,2)
c
  100 continue
      ic=ic+1
      if (ic.gt.icmax) go to 9000
      ipdir=ipdir+1
      line=card(ipdir)
      diret=line
      call cutst(line,lenp,dire,lend)
      call lcase(dire)
c-- directives with numeric parameters
      iopt=0
      call getnum(line,vet,ivet,iv,iopt)
      if (iopt.eq.-1) go to 8000
      if (dire(1:4).eq.'seed')  then
          if (iv.ne.1) go to 8000
          iynew = ivet(1)
          go to 100
          endif
      if (dire(1:4).eq.'nops')  then
          knewpsi=0
          go to 100
          endif
      if (dire(1:4).eq.'nneg')  then
          nneg=0
          go to 100
          endif
      if (dire(1:4).eq.'nngq')  then
          nngq=0
          go to 100
          endif
      if (dire(1:4).eq.'nore')  then
          jrej=0
          go to 100
          endif
      if (dire(1:4).eq.'test')  then
          jproc=0
          go to 100
          endif
      if (dire(1:3).eq.'set')  then
          if (iv.ne.1) go to 8000
          muset=ivet(1)
          go to 100
          endif
      if (dire(1:4).eq.'maxt')  then
          if (iv.eq.0) go to 8000
          maxtri=ivet(1)
          go to 100
          endif
      if (dire(1:4).eq.'rand') then
          if (iv.gt.1) go to 8000
          if (iv.eq.1.and.ivet(1).gt.0) numcri=ivet(1)
          if (numcri.ge.numb-4) numcri=numb-4
          jcran=1
          go to 100
          endif
      if (dire(1:4).eq.'orig') then
          if (iv.eq.0) go to 8000
          if (mod(iv,2).ne.0) go to 8000
          inpori=1
          j1=0
          do 110 i=1,iv,2
          if(ivet(i).le.numb) then
                               j1=j1+1
                               igin  (j1)=ivet(i)
                               ipigin(j1)=ivet(i+1)
                              endif
  110     continue
          norig=j1
          go to 100
          endif
      if (dire(1:4).eq.'phas') then
          if (iv.eq.0) go to 8000
          if (mod(iv,3).ne.0) go to 8000
          j=inpfas+1
          inpfas=inpfas+iv/3
          k=0
          do 120 i=j,inpfas
          k=k+1
          j3=k*3
          j2=j3-1
          j1=j3-2
          icode (i)=ivet(j1)
          ifaz20(i)=ivet(j2)
  120     peso  (i)= vet(j3)
          go to 100
          endif
      if (dire(1:4).eq.'perm') then
          if (iv.eq.0) go to 8000
          iperm=iv
          if (iperm.gt.12) go to 8000
          do 130 i=1,iperm
  130     inperm(i)=ivet(i)
          go to 100
          endif
      if (dire(1:4).eq.'list') then
          if (iv.ne.1) go to 8000
          nlist=ivet(1)
          go to 100
          endif
      if (dire(1:4).eq.'symb') then
          if (iv.ne.1) go to 8000
          nsymb=ivet(1)
          if (nsymb.gt.12) go to 8000
          go to 100
          endif
      if (dire(1:4).eq.'twop') then
          if (iv.ne.1) go to 8000
          sogs2=vet(1)
          go to 100
          endif
      if (dire(1:4).eq.'onep') then
          if (iv.ne.1) go to 8000
          ns1mx=vet(1)
          if (ns1mx.lt.0) go to 8000
          go to 100
          endif
      if (dire(1:4).eq.'prin') then
          if (iv.ne.1) go to 8000
          iprin=ivet(1)
          go to 100
          endif
      if (dire(1:4).eq.'enan') then
          if (iv.ne.1) go to 8000
          inpena=ivet(1)
          go to 100
          endif
      if (dire(1:4).eq.'spec') then
          if (iv.ne.1) go to 8000
          nspec=ivet(1)
          if (nspec.gt.12) go to 8000
          go to 100
          endif
      if (dire(1:4).eq.'tria') then
          if (iv.eq.0) go to 8000
          nset=min0(iv,20)
          do 140 i=1,nset
  140     iset(i)=ivet(i)
          go to 100
          endif
      if (dire(1:4).eq.'minf') then
          if (iv.eq.0) go to 8000
          if (iv.ge.1) fomin=vet(1)
          if (iv.eq.2) mxsac=ivet(2)
          if (iv.gt.2) go to 8000
          go to 100
          endif
      if (dire(1:4).eq.'gmin') then
          if (iv.ne.1) go to 8000
          gminpa=vet(1)
          go to 100
          endif
      if (dire(1:4).eq.'cutm') then
          if (iv.ne.1) go to 8000
          cutpa=vet(1)
          go to 100
          endif
      if (dire(1:4).eq.'tabl') then
          if (iv.ne.0) go to 8000
          jtabl=1
          go to 100
          endif
      if (dire(1:4).eq.'part') then
          if (iv.ne.0) go to 8000
          jpart=1
          go to 100
          endif
      if (dire(1:3).eq.'all') then
          if (iv.ne.0) go to 8000
          jall=1
          go to 100
          endif
      if (dire(1:3).eq.'las') then
          if (iv.ne.0) go to 8000
          lasts=1
          go to 100
          endif
      write(lo,6000) diret
 6000 format(' wrong directive on following line:',/a)
      ier=-1
      return
 8000 write(lo,'(22h error in directive : ,a80)') diret
      ier=-1
      return
 9000 continue
      if (nset.gt.0) ilist=1
      if (jcran.eq.1) then
                        if (jpart.eq.1) then
                            write(lo,9100)
                            ier=-1
                            return
                          endif
                        ns1mx=0
                        inpfas=0
                      endif
 9100 format('  *** error *** RANDOM & PARTIAL directives are not compat
     *ible.')
      if (iynew.gt.0.and.iynew.ne.iydef) call spb07(iy)
      return
      end
c-----------------------------------------------------------------------
      subroutine ssfom(pub)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common /ureq1/ jpatt,jpunt(501),ksacc,jseteq,jumpp,jmpsie,nsec
      dimension ipos(300),cfom(300),wt(500),iphaz(500),fig(11),err(2)
      common /cris/ numcri,jcran,maxtri,nstart,muset
      integer pub(800)
      equivalence (npunt,jpunt(501))
c
      if (npunt.le.0) return
      write(lo,100) npunt
  100 format(/,' error using ',i3,' seminvariants',/)
      call ysfl16(cfom,ipos,nset)
      do 1000 i=1,nset
      ii=ipos(i)
      call snr16(ii,fig,wt,iphaz)
      is=-1
      do 780 l=1,2
      is=-is
      err(l)=0.0
      rror=0.0
      do 770 k=1,npunt
      j=jpunt(k)
      if (wt(j).gt.0.01) then
                           iphj = is*iphaz(j)
                           icb = iabs(iphj-pub(j))
                           icb = mod(icb,360)
                           rror = rror+1
                           css = min0(icb,360-icb)
                           err(l)= err(l) + css
                           if (muset.gt.0) write(6,750) i,j,iphj,pub(j)
     *                                             ,icb,css,err(l),rror
  750 format(' set #',i3,i5,1h),3i5,3f10.2)
                         endif
  770 continue
      if (rror.gt.0.0) err(l)=err(l)/rror
  780 continue
      n=nint(rror)
      write(lo,800) i,err,n
  800 format(' set ',i4,' <error> =',2f8.2,' (',i3,')')
 1000 continue
      return
      end
c----------------------------------------------------------------------
      subroutine punts1
      common /xdata/ imat(3,20000),z(500),iee(20000),iph(41000),
     * iphaz(500),iorde(500),
     2 alfest(500),iz(500),ih(800),e(800),limref(500),mkang(800),
     3 alfvar(500),ifstor(500),alpha(500),icont(3),kdstor(500),wt(500),
     4 zp(500),irefin(500),nn(8),nbinv(61000),enil(4),line(4,6),absfom,
     5 resid,al2,al2m1,almed,nundet,error,errpes,fomps0,foms1,coms,
     6 fomrt(302,10),f1mx,f1mn,f2mx,f2mn,f21mx,f21mn,f22mx,f22mn,f23mx,
     7 f23mn,f3mx,f3mn,f4mx,f4mn,f5mx,f5mn,f6mx,f6mn,f7mx,f7mn,f8mx,
     8 f8mn,f9mx,f9mn,f10mx,f10mn,f11mx,f11mn,f12mx,f12mn,f13mx,f13mn,
     9 f14mx,f14mn,f15mx,f15mn,f16mx,f16mn,f17mx,f17mn,f18mx,f18mn,
     * iph1(500),negt1(500),negt2(500),iqu1(750),iqu2(750),
     1 iqu3(750),nent1(500),nent2(500),nq1(500),nq2(500),nq3(500),
     2 iph21(2514),iph22(2514),psivet(500),imat1(7,750),
     3 dummx(32960)
      common /ureq1/ jpatt,jpunt(501),ksacc,jseteq,jumpp,jmpsie,nsec
      common /param/ numb,nant(4),nral,alra,sumalf,ssig,nref,duma
      dimension jhk(3)
      equivalence (npunt,jpunt(501))
c
      npunt=0
      do 10 i=1,numb
      ie=ih(i)/500000
      ihh=ih(i)-500000*ie
      call unpacc(ihh,jhk(1),jhk(2),jhk(3))
cdjw99      ks=modulo(jhk)
      ks=modulx(jhk)
      if (ks.eq.0) then
               npunt=npunt+1
               jpunt(npunt)=i
              endif
  10  continue
      return
      end
c----------------------------------------------------------------------
      subroutine absnew (pub,absfom,resid,al2,al2m1,almed,
     2    nundet,error,errpes,nuset,sigm)
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common / ureq1/ jpatt,jpunt(501),ksacc,jseteq,jumpp,jmpsie,nsec
      common /tables/ stable(500)
c NEW
      common/fom4/attl2,attl3,nqen,nen,ntrnex,ns1,ns2,nquax,nphas,nfom0,
     *            coeco
      common /param/ numb,nant(4),nral,ckae,ckae0,ssig,nref,nsxx
      common /psi0/ npsi,num0,alfest0(300),alfvar0(300),llll(300),
     1 lim0n(300),iph0n(20000)
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
c NEW
      common /xdata/ imat(3,20000),z(500),iee(20000),iph(41000),
     * iphaz(500),iorde(500),
     2 alfest(500),iz(500),ih(800),e(800),limref(500),mkang(800),
     3 alfvar(500),ifstor(500),alpha(500),icont(3),kdstor(500),wt(500),
     4 zp(500),irefin(500),nn(8),nbinv(61000),enil(4),line(4,6),
     5 dummx(53061)
c
      integer pub(800)
      dimension ctable(500),alpha0(300)
c
c vettore utilizzato per memorizzare il numero di tripletti per riflesso
      dimension ntrr(500),ntr0(300),eec(500),ee0(300)
c
      equivalence(stable(91),ctable(1))
c
c     vec(x)=amin1((x+0.4807)*x/((x+0.8636)*x +
c    *  1.3943),1.0)
c
c NEW inizial. variabili calcolo coeff. di correlaz. (1/8/91)
      seec=0.0
      seeo=0.0
      see0=0.0
      seo0=0.0
      scon=0.0
      ecm=0.0
      eom=0.0
      ccorc=0.0
      ccoro=0.0
      scor1=0.0
      scor2=0.0
      scor3=0.0
      rcarl1=0.0
      rcarld1=0.0
c
c    calcolo  absfom , resid  ed error
      q1=0.798
      q4=0.968
      id28=2**30
      error=0.
      errpes=0.
      anum=0.
      nundet=0
      salf=0.0
      salfe=0.0
      salfer=0.0
      dalfa=0.0
      dalf1=0.0
      dalf2=0.0
      dalf3=0.0
      absfom=0.0
      ssigt=ssig
c
      anumw=0.
      dpsa=0.0
      dps1=0.0
      dps2=0.0
      dps3=0.0
      if(icent.le.0) then
                       sigmp=2.0*sigm
                       sigmq=2.0*sigm*sigm
                     else
                       sigmp=sigm
                       sigmq=sigm*sigm
                     endif
c     if(nuset.eq.1) then
c                        write(6,*)
c    *' absnew * sigm sigmp, numb num0 npse=',sigm,sigmp,numb,num0,npse
c                      endif
c
c
      do 6500 k=1,numb
      ntrr(k)=0
      eec(k)=0
      wt(k)=abs(wt(k))
      alpha(k)=0.0
c
      li = limref(k) + 1
      ls = limref(k+1)
      if(li.gt.ls) then
                      nundet = nundet + 1
                      go to 6500
                   endif
c
       if(wt(k).gt.0.1) go to 6100
       nundet = nundet + 1
       iphaz(k)=0
       wt(k)=0.0
       go to 6499
Corig go to 6500
c
c6100 li = limref(k) + 1
Corig ls = limref(k+1)
Corig if(li.gt.ls) then
Corig                alpha(k)=0.0
Corig                go to 6500
Corig              endif
 6100 sang = 0.0
      cang = 0.0
      do 6200 jj = li,ls
      ind = nbinv(jj)
      call depacc(k,ind,a1,ifaz,iw)
      a1=abs(a1)
c     if(iw.ne.2) go to 6200
      if(nn(2).eq.0) go to 6200
      ila = iabs(nn(1))
      ira = iabs(nn(2))
      ita = iabs(nn(3))
       if (iw.eq.2) then
      if(wt(ila).le.0.1.or.wt(ira).le.0.1) goto 6200
      ip = isign(iphaz(ila),nn(1)) + isign(iphaz(ira),nn(2))
     *  +  15*ifaz
      a1=sigmp*e(ila)*e(ira)
                    else
      if(wt(ila).le.0.1.or.wt(ira).le.0.1.or.wt(ita).le.0.1)goto 6200
      ip = isign(iphaz(ila),nn(1)) + isign(iphaz(ira),nn(2))
     *  +  isign(iphaz(ita),nn(3)) + 15*ifaz
      a1=sigmq*e(ila)*e(ira)*e(ita)
                 endif
      ip = mod(ip+36000,360) + 1
      sang = sang + a1 * stable(ip)
      cang = cang + a1 * ctable(ip)
Corig ntrr(k)=ntrr(k)+1
 6200 continue
      if(mkang(k).eq.1) go to 6300
      idv = 15*mod(iabs(mkang(k))-1,12) + 1
      t2 = sang*stable(idv) + cang*ctable(idv)
      sang = t2*stable(idv)
      cang = t2*ctable(idv)
 6300 if(abs(sang).lt.0.1e-15) sang=0.0
      if(abs(cang).lt.0.1e-15) cang=0.0
      alpha(k)=sqrt( sang*sang + cang*cang )
Corig anum=anum+1.
 6499 anum=anum+1.
      ntrr(k)=ls-li+1
      salf=salf+alpha(k)
c
c MABS calcolata solo sui riflessi fasati
c
Corig salfe=salfe+alfest(k)
      if(wt(k).gt.0.1) salfe=salfe+alfest(k)
c
c
Corig salfer=salfer+alpha(k)
Corig if (knw.gt.0) then
      if (knw.gt.0.and.wt(k).gt.0.1) then
                      salfer=salfer+alpha(k)
                      ip= iabs(pub(k)-iphaz(k))
                      delta=min0 (ip,360-ip)
                      error=error+delta
                      errpes=errpes+delta*alpha(k)
                    endif
c     if (jumpp.eq.1.or.nuset.eq.9)
c     if (nuset.eq.4.or.nuset.eq.5)
c    *write(6,6301) k,alpha(k),alfest(k),alfvar(k),wt(k),
c    *ntrr(k),pub(k),iphaz(k),nint(delta)
c6301 format(i5,1h),4f10.3,4i8)
 6500 continue
*     do k=1,numb
*     if (ntrr(k).eq.1) then
*                         salf=salf-alpha(k)
*                         salfe=salfe-alfest(k)
*                         salfer=salfer-alpha(k)
*                         ntrr(k)=0
*                         alpha(k)=0.0
*                         alfest(k)=0.0
*                       endif
*     enddo
c
c-- indetermined phases number too high
c
      if(nundet.ge.(numb/2)) return
c     if(nundet.ge.(numb/2)) then
c                               write(6,*)
c    *'trial :',nuset,'  indetermined phases number too high !'
c                               return
c                             endif
c
c NEW introduco ciclo sui rifl. deboli
      if (num0.eq.0) go to 7001
      do 7000 k=1,num0
      alpha0(k)=0.0
      ntr0(k)=0.0
      ee0(k)=0.0
c test per riconoscere i rifl. senza tripl. psi-0
      if(alfest0(k).lt.0.000001.and.alfvar0(k).lt.0.000001) go to 7000
      li=lim0n(k)+1
      ls=lim0n(k+1)
      if(li.gt.ls) go to 7000
      sang = 0.0
      cang = 0.0
      do 7100 j=li,ls
      iph0n(j)=mod(iph0n(j),id28)
      call unpak3(iph0n(j),k1,k2,ifaz)
      ila = iabs(k1)
      ira = iabs(k2)
      if(iphaz(ila).eq.0.or.iphaz(ira).eq.0) then
                                               goto 7100
                                             endif
      ip = isign(iphaz(ila),k1) + isign(iphaz(ira),k2)
     *  +  15*ifaz
      ip = mod(ip+36000,360) + 1
      a1=sigmp*e(ila)*e(ira)
      sang = sang + a1 * stable(ip)
      cang = cang + a1 * ctable(ip)
Corig ntr0(k)=ntr0(k)+1
 7100 continue
      kk=llll(k)
      if(mkang(kk).eq.1) go to 7300
      idv = 15*mod(iabs(mkang(kk))-1,12) + 1
      t2 = sang*stable(idv) + cang*ctable(idv)
      sang = t2*stable(idv)
      cang = t2*ctable(idv)
 7300 if(abs(sang).lt.0.1e-15) sang=0.0
      if(abs(cang).lt.0.1e-15) cang=0.0
      alpha0(k)=sqrt( sang*sang + cang*cang )
Corig if(ntr0(k).eq.0) then
Corig                   alfless=alfvar0(k)*alfvar0(k)
Corig                   ssigt=ssigt-alfless
Corig                   go to 7000
Corig                   endif
      anumw=anumw+1.
      ntr0(k)=ls-li+1
 7000 continue
 7001 continue
c
      absfom=0.0
      if(salfe.gt.0.0001) absfom = salf / salfe
c     write(6,*) 'ABSFOM',absfom,salf,salfe,nuset
c
      do 3580 k=1,numb
      eec(k)=0.0
      if(ntrr(k).eq.0) go to 3580
Corig if(wt(k).le.0.1.or.ntrr(k).eq.0) then
Corig                   alfless=alfvar(k)*alfvar(k)
Corig                   ssigt=ssigt-alfless
Corig                   go to 3580
Corig                  endif
c
c-- rescaling of alpha
c-- alpha = alfa calcolato dalla tangente
c-- alfest = alfa stimato dai G
c-- alfvar = alfa random
c
      eec(k)=alpha(k)/ntrr(k)
      if(absfom.gt.0.0001) alpha(k)=alpha(k)/absfom
      seec=seec+eec(k)
      seeo=seeo+e(k)
c
      dalf2 = dalf2 + ( alfest(k) - alpha(k) )*( alfest(k) - alpha(k) )
      if (alfvar(k).lt.0.0001) go to 3580
      davi=(alfest(k)-alpha(k))/alfvar(k)
*     if (nuset.eq.2.or.nuset.eq.17.or.nuset.eq.23)
*    *write(6,6301) k,alpha(k),alfest(k),alfvar(k),wt(k),
*    *davi,ntrr(k)
      dalf3 = dalf3 + abs( davi )
      davi=davi*davi
      dalfa=dalfa+davi
      dalf1=dalf1+abs(davi-1.0)
 3580 continue
      if(salfer.gt.0.00001) errpes=errpes/salfer
c
      if(num0.eq.0) go to 3591
      do 3590 k=1,num0
      ee0(k)=0.0
      if(ntr0(k).eq.0) go to 3590
      ee0(k)=alpha0(k)/ntr0(k)
      see0=see0+ee0(k)
      seo0=seo0+e(llll(k))
c
      dps2 = dps2 + (alfest0(k) - alpha0(k) )*( alfest0(k) - alpha0(k))
      if (alfvar0(k).lt.0.0001) go to 3590
      dpsi=(alfest0(k)-alpha0(k))/alfvar0(k)
      dps3 = dps3 + abs( dpsi )
      dpsi=dpsi*dpsi
      dpsa=dpsa+dpsi
      dps1=dps1+abs(dpsi-1.0)
 3590 continue
 3591 continue
c NEW 11/10/91 : pesaggio delle sommatorie sui rifl.deboli con mabs
      ww0=1.0
      if(absfom.gt.0.0001) ww0=1.0/absfom
      dps3=dps3*ww0
      dpsa=dpsa*ww0
      dps1=dps1*ww0
      dps2=dps2*ww0
c
c*****************************************************************
c     write(6,*)'nuset absfom =',nuset,absfom
c     write(6,*)'nalf(i)  nps0(i)  ='
c     write(6,'(9f10.3)')
c    *dalf3,dalf2,dalfa,dalf1,dps3,dps2,dpsa,dps1,ssigt
c++++++++
c NEW calcolo coeffic. di correlaz. tra Ecalc ed Eobs (1/8/'91)
      scon=anum+anumw
      if(scon.gt.0.1) then
                        ecm=(seec+see0)/scon
                        eom=(seeo+seo0)/scon
                      endif
      do 5000 k=1,numb
      if(ntrr(k).eq.0) go to 5000
Corig if(wt(k).le.0.1.or.ntrr(k).eq.0) go to 5000
      ccorc=eec(k)-ecm
      ccoro=e(k)-eom
      scor1=scor1+ccorc*ccoro
      scor2=scor2+ccorc*ccorc
      scor3=scor3+ccoro*ccoro
      eec(k)=alpha(k)/(ckae*ntrr(k))
      rcarl1=rcarl1+abs(e(k)-eec(k))
      rcarld1=rcarld1+e(k)
 5000 continue
      if(num0.eq.0) go to 5100
      do 5050 k=1,num0
      if(ntr0(k).eq.0) go to 5050
      ccorc=ee0(k)-ecm
      ccoro=e(llll(k))-eom
      scor1=scor1+ccorc*ccoro
      scor2=scor2+ccorc*ccorc
      scor3=scor3+ccoro*ccoro
      ee0(k)=alpha0(k)/(ckae0*ntr0(k))
      rcarl1=rcarl1+abs(e(llll(k))-ee0(k))
      rcarld1=rcarld1+e(llll(k))
 5050 continue
 5100 continue
      coeco=-9999
      if((scor2*scor3).gt.0) coeco=scor1/sqrt(scor2*scor3)
      if(rcarld1.gt.0.0) rcarl1=rcarl1/rcarld1
c     write(6,'(10h  trial : ,i4,3f10.4,f10.3)') nuset,coeco,rcarl1
c
c++++++++++++++++
c calcolo le sommatorie complessive (forti + deboli)
      anumt=anum+anumw
      if(anumt.gt.0.1) anumt=1.0/anumt
      alfp1=(dalf3+dps3)*anumt
      alfp3=(dalfa+dpsa)*anumt
      alfp4=(dalf1+dps1)*anumt
      alfp2=0.00001
      if(ssigt.gt.0.0001) alfp2=(dalf2+dps2)/ssigt
c
c valori passati alla nuova fomsp comprendenti le vecchie alcom e psicom
      resid  = alfp2
      almed  = alfp1
      al2    = alfp3
      al2m1  = alfp4
      if(anum.gt.0.1) anum=1.0/anum
      error  = error * anum
      return
      end
c----------------------------------------------------------------------
      subroutine rialfnew(icent,sigmp)
c   calcola alfest e alfvar per i rifl. forti e deboli
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c NEW
      common /param/ numb,nant(4),nral,ckae,ckae0,ssig,nref,nsxx
      common /psi0/ npsi,num0,alfest0(300),alfvar0(300),llll(300),
     1 lim0n(300),iph0n(20000)
c NEW
      common /xdata/ imat(3,20000),z(500),iee(20000),iph(41000),
     * iphaz(500),iorde(500),
     2 alfest(500),iz(500),ih(800),e(800),limref(500),mkang(800),
     3 alfvar(500),ifstor(500),alpha(500),icont(3),kdstor(500),wt(500),
     4 zp(500),irefin(500),nn(8),nbinv(61000),enil(4),line(4,6),
     5 dummx(53061)
      dimension vet(12),ivet(12)
      equivalence (vet(1),ivet(1))
ccc
      sigm=sigmp
      sigmq=sigmp*sigmp
      q0=0.798
      if(icent.le.0) then
                       sigm=2.0*sigmp
                       sigmq=2.0*sigmq
                       q0=0.886
                      endif
      id28=2**30
      ssig  = 0.0
c NEW
      salfe=0.0
      seobs=0.0
      salfe0=0.0
      seobs0=0.0
      ckae=1.0
      ckae0=1.0
c NEW
c calcolo alfest e alfvar per i rifl. forti
      do 350 k= 1,numb
      alfvar(k) = 0.0
      alfest(k)=0.0
      li=limref(k)+1
      ls=limref(k+1)
      if(li.gt.ls) go to 350
      do 340 jj= li,ls
      ind=nbinv(jj)
      call depacc(k,ind,a1,ifaz,iw)
      if(nn(2).eq.0) go to 340
      ila=iabs(nn(1))
      ira=iabs(nn(2))
      ita=iabs(nn(3))
      if (iw.eq.2) then
                     aj=sigm*e(ila)*e(ira)
                     is=1
                     if(a1.lt.0.0)is=-1
                     gj=aj*e(k)*is
                   else
                     gj=a1
                     aj=sigmq*e(ila)*e(ira)*e(ita)
                   endif
      seobs=seobs+e(k)
      if (icent.le.0) go to 300
      if (iw.eq.2) then
                     t2=tanh(gj)
                   else
                     t2=tanh(gj*0.5)
                   endif
      alfest(k)=alfest(k)+aj*t2
      alfvar(k)=alfvar(k)+aj*aj*(1.0-t2*t2)
      go to 340
  300 continue
      t2=bes(gj)
      alfest(k)=alfest(k)+aj*t2
      alfvar(k) = alfvar(k) + aj * aj * ( 1.0 - t2 * (1.0/gj+t2) )
c
c      if(k.eq.13) then
c      if(iw.eq.3) then
c      write(lo,278) k,e(k),ila,e(ila),ira,e(ira),ita,e(ita),
c    * aj,t2,alfest(k)
c 278 format(' code=',i4,f6.2,3(i4,f6.2),5x,3f8.2)
c                  else
c      write(lo,279) k,e(k),ila,e(ila),ira,e(ira),
c    * aj,t2,alfest(k)
c 279 format(' code=',i4,f6.2,2(i4,f6.2),5x,3f8.2)
c                  endif
c                  endif
  340 continue
c
      alfest(k)=abs(alfest(k))
      alfvar(k)=abs(alfvar(k))
      salfe=salfe+alfest(k)
      ssig  = ssig  + alfvar(k)
      alfvar(k) = sqrt(alfvar(k))
c     write(6,*)k,alfest(k),alfvar(k)
  350 continue
      if(seobs.gt.0.0) ckae=salfe/seobs
c     write(6,*)'forti: sigh2,salfe seobs ckae =',ssig,salfe,seobs,ckae
**********
c calcolo alfest e alfvar per i rifl. deboli
c
c -----
c     call sub. lettura lista 9 : psizero
c -----
      npsi=0
      num0=0
      call srlin (9,lsn,lfw,llw,lpb,ll)
c-- check if list 9 exists
      if (lfw.gt.0) then
      iprea=0
      call sflxx(iprea,9,npsi,npsi,num0,nxxe,iccd,imat)
      if(npsi.gt.0) then
      do 25 i=1,npsi
   25 iph0n(i)=imat(1,i)
      n=0
      j=1
      do 987 i=1,num0
      llll(i)=0
      alfest0(i)=0.0
      alfvar0(i)=0.0
  987 lim0n(i)=0
      do 1120 i=2,npsi
      iniz=iph0n(i)/id28
      n=n+1
      if(iniz.eq.0) goto 1120
      j=j+1
      lim0n(j)=n
 1120 continue
      j=j + 1
      lim0n(j)=n
CCCCC             endif
c -----
      n0=numb+num0+1
      do 360 i=1,num0
      n0=n0-1
      llll(i)=n0
      li=lim0n(i) + 1
      ls=lim0n(i+1)
      if (ls.lt.li ) goto 360
      do 355 j=li,ls
      iph0n(j)=mod(iph0n(j),id28)
      call unpak3(iph0n(j),k1,k2,ifaz)
      ka1=iabs(k1)
      ka2=iabs(k2)
      aj=sigm*e(ka1)*e(ka2)
      alfvar0(i) = alfvar0(i) + aj * aj
      seobs0=seobs0+e(n0)
  355 continue
      ssig=ssig+alfvar0(i)
      if(alfvar0(i).lt.0.0) then
c                             write(6,*)'i alfvar0=',i,alfvar0(i)
                              go to 360
                            endif
      alfvar0(i)=sqrt(alfvar0(i))
      alfest0(i)=alfvar0(i)*q0
      salfe0=salfe0+alfest0(i)
c     write(6,*)'i alfest0 alfvar0=',i,alfest0(i),alfvar0(i)
  360 continue
          endif
          endif
      if(seobs0.gt.0.0) ckae0=salfe0/seobs0
c     write(6,*)'sigh2 ,salfe0 seobs0 ckae0 =',ssig,salfe0,seobs0,ckae0
      return
      end
c-----------------------------------------------------------------------
      subroutine fomsp(numb,nuset,nsxx,ns1mx,sogs2,
     * sigmp,icent,mxsac,mxsaco,nsacc,aminco,nena)
      common /cfomxx/ cfomx
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /cpseud/ npseud,lpseuv(12),llpse
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common / ureq1/ jpatt,jpunt(501),ksacc,jseteq,jumpp,jmpsie,nsec
      common /psi0/ npsi,num0,alfest0(300),alfvar0(300),llll(300),
     1 lim0n(300),iph0n(20000)
      common /tables/ stable(500)
      common /mag/ sqp4,sq2pi,mi(15),ms(15),dx,iyyy,lasts
      common/fom4/attl2,attl3,nqen,nen,ntrneg,ns1,ns2,nquar,nphas,nfom0,
     *            coeco
      common /xdata/ imat(3,20000),z(500),iee(20000),iph(41000),
     * iphaz(500),iorde(500),
     2 alfest(500),iz(500),ih(800),e(800),limref(500),mkang(800),
     3 alfvar(500),ifstor(500),alpha(500),icont(3),kdstor(500),wt(500),
     4 zp(500),irefin(500),nn(8),nbinv(61000),enil(4),line(4,6),absfom,
     5 resid,al2,al2m1,almed,nundet,error,errpes,fomps0,foms1,coms,
     6 fomrt(302,10),f1mx,f1mn,f2mx,f2mn,f21mx,f21mn,f22mx,f22mn,f23mx,
     7 f23mn,f3mx,f3mn,f4mx,f4mn,f5mx,f5mn,f6mx,f6mn,f7mx,f7mn,f8mx,
     8 f8mn,f9mx,f9mn,f10mx,f10mn,f11mx,f11mn,f12mx,f12mn,f13mx,f13mn,
     9 f14mx,f14mn,f15mx,f15mn,f16mx,f16mn,f17mx,f17mn,f18mx,f18mn,
     * iph1(500),negt1(500),negt2(500),iqu1(750),
     * iqu2(750),iqu3(750),nent1(500),nent2(500),nq1(500),nq2(500),
     1 nq3(500),iph21(2514),iph22(2514),psivet(500),imat1(7,750),
     2 dummx(32960)
      common /gian/ limref0(800),nbinv0(61000),jph0(40000),knewpsi,
     *              alphap(300),ktheta(300),a0est(300),a0var(300)
      dimension ctable(500),fig(11),wtj(500),iphazj(500)
      equivalence (stable(91),ctable(1)),(iyzz,fig(11))
      equivalence (npunt,jpunt(501))
c
c     vec(x)=amin1((x+0.4807)*x/((x+0.8636)*x +
c    *  1.3943),1.0)
c
      ipri0=0
c
c ---
c
      if(nuset.gt.1) goto 505
c ---
c-- initialize number of relationships to zero
      nen=0
      nqen=0
      nquar=0
      ntrneg=0
c     ....  per absfom
      f1mx=-1.0e+20
      f1mn=1.0e+20
c     ....  per resid
      f2mx=-1.0e+20
      f2mn=1.0e+20
c     ....  per al2
      f21mx=-1.0e+20
      f21mn=1.0e+20
c     ....  per al2m1
      f22mx=-1.0e+20
      f22mn=1.0e+20
c     ....  per almed
      f23mx=-1.0e+20
      f23mn=1.0e+20
c     ....  per ss1
      f3mx=-1.0e+20
      f3mn=1.0e+20
c     ....  per ss2
      f4mx=-1.0e+20
      f4mn=1.0e+20
c     ....  per nquest
      f5mx=-1.0e+20
      f5mn=1.0e+20
c     ....  per ntrest
      f6mx=-1.0e+20
      f6mn=1.0e+20
c     ....  per psi-0
      f7mx=-1.0e+20
      f7mn=1.0e+20
c     ....  per ensintr
      f8mx=-1.0e+20
      f8mn=1.0e+20
c     ....  per ensinqu
      f9mx=-1.0e+20
      f9mn=1.0e+20
c     ....  per rpsi0-1
      f10mx=-1.0e+20
      f10mn=1.0e+20
c     ....  per rpsi0-2
      f11mx=-1.0e+20
      f11mn=1.0e+20
c     ....  per abspsi0
      f12mx=-1.0e+20
      f12mn=1.0e+20
c     ....  per alcom
      f13mx=-1.0e+20
      f13mn=1.0e+20
c     ....  per psicom
      f14mx=-1.0e+20
      f14mn=1.0e+20
c     ....  per alcom normalizzata
      f15mx=-1.0e+20
      f15mn=1.0e+20
c     ....  per coeff. di correlazione
      f16mx=-1.0e+20
      f16mn=1.0e+20
c     ....  per cphase
      f17mx=-1.0e+20
      f17mn=1.0e+20
c     ....  per cfom
      f18mx=-1.0e+20
      f18mn=1.0e+20
c *********************************************************
c
c  lettura file relazioni
c
c *********************************************************
      ndim=500
c -----
c     call sub. lettura lista 26 : seminvarianti a una fase
c -----
      iprea=0
      call srlin (26,lsn,lfw,llw,lpb,ll)
      if(lfw) 15,15,10
   10 call sflxx(iprea,26,ns1,ns1,ns1p,nxxe,iccd,iph1)
      ns1=min0(200,ns1)
c -----
c     call sub. lettura lista 27 : seminvarianti a due fasi
c -----
   15 call srlin (27,lsn,lfw,llw,lpb,ll)
      if(lfw) 26,26,18
   18 call sflxx(iprea,27,ns2,ns2,ns2p,nxxe,iccd,imat)
      ns2=min0(2500,ns2)
      do 20 i=1,ns2
      iph21(i)=imat(1,i)
   20 iph22(i)=imat(2,i)
c -----
c     call sub. lettura lista 20 : quartetti negativi
c -----
   26 call srlin (20,lsn,lfw,llw,lpb,ll)
      if(lfw) 32,32,27
   27 call sflxx(iprea,20,nquar,nquar,nxxd,nxxe,iccd,imat1)
      nquar=min0(750,nquar)
      do 30 i=1,nquar
      iqu1(i)=imat1(1,i)
      iqu2(i)=imat1(2,i)
   30 iqu3(i)=imat1(3,i)
c -----
c     call sub. lettura lista 21 : quartetti enantiomorfi
c -----
   32 call srlin (21,lsn,lfw,llw,lpb,ll)
      if(lfw) 42,42,34
   34 call sflxx(iprea,21,nqen,nqen,nxxd,nxxe,iccd,imat1)
      do 40 i=1,nqen
      nq1(i)=imat1(1,i)
      nq2(i)=imat1(2,i)
   40 nq3(i)=imat1(3,i)
c -----
c     call sub. lettura lista 11 : tripletti enantiomorfi
c -----
   42 call srlin (11,lsn,lfw,llw,lpb,ll)
      if(lfw) 62,62,44
   44 call sflxx(iprea,11,nen,nen,nxxd,nxxe,iccd,imat)
      do 60 i=1,nen
      nent1(i)=imat(1,i)
   60 nent2(i)=imat(2,i)
c -----
c     call sub. lettura lista 10 : tripletti negativi
c -----
   62 call srlin (10,lsn,lfw,llw,lpb,ll)
      if(lfw) 490,490,64
   64 call sflxx(iprea,10,ntrneg,ntrneg,nxxd,nxxe,iccd,imat)
      do 80 i=1,ntrneg
      negt1(i)=imat(1,i)
   80 negt2(i)=imat(2,i)
c
c ----- compute  f.o.m. s for the different sets of phases
c
  490 continue
      nena=nqen+nen
      nphas=ns1+ns2+ntrneg+nquar
c NEW 11/10/91 elimino contributo MABS pesata da CFOM finale
      attl2=0.968
      attl3=0.798
  505 continue
      if (jall.eq.1) write(lo,1220)
 1220 format(//////10x,'numerators and denominators of phase ','dependan
     *t foms'//1x,'trial',9x,'ss1fom',12x,'ss2fom',12x,'nquest'
     * ,12x,'ntrest',12x,'fentrs',12x,'fenqus'/,5x,6(7x,'num     den')/)
      coms=0.0
      al2m1=al2m1/attl2
      almed=almed/attl3
      alcom=0.25*(sqrt(al2)+sqrt(al2m1)+sqrt(resid)
     1         +      almed)
      if(absfom.gt.f1mx) f1mx=absfom
      if(absfom.lt.f1mn) f1mn=absfom
      if(resid .gt.f2mx) f2mx=resid
      if(resid .lt.f2mn) f2mn=resid
      if(al2  .gt.f21mx) f21mx=al2
      if(al2  .lt.f21mn) f21mn=al2
      if(al2m1.gt.f22mx) f22mx=al2m1
      if(al2m1.lt.f22mn) f22mn=al2m1
      if(almed.gt.f23mx) f23mx=almed
      if(almed.lt.f23mn) f23mn=almed
      if(alcom.gt.f13mx) f13mx=alcom
      if(alcom.lt.f13mn) f13mn=alcom
      foms1=0.0
      foms2=0.0
      fomqn=0.0
      sgtot=0.0
c
c   *******         one-phase s.s. f.o.m.*******
c
      fs1num=0.0
      foms1=0.0
      sg1=0.0
      if (ns1.eq.0) go to 150
      do 100 i=1,ns1
      call unpak3 (iph1(i),k1,k2,ifaz)
      ka1=iabs(k1)
      if(ka1.gt.numb) go to 100
      if(iphaz(ka1).eq.0) go to 100
      g=abs(float(k2)*0.01)
      ga=g
c   peso meta' ai ss1 attivi
      if(i.le.ns1mx) ga=0.5*ga
      sg1=sg1 + ga * bes(g)
      iau=ifaz*15
      iarg=iphaz(ka1) - iau
      iarg=mod(iarg+36000,360)+1
      foms1=foms1 + ga*ctable(iarg)
  100 continue
      fs1num=foms1
      sgtot=sgtot + sg1
      if(sg1.lt.0.00001) go to 150
      foms1=foms1/sg1
  150 if(foms1.gt.f3mx) f3mx=foms1
      if(foms1.lt.f3mn) f3mn=foms1
c
c  *******   two-phase  s.s.   f.o.m.*******
c
      fs2num=0.0
      foms2=0.0
      sg2=0.0
      if(ns2.eq.0) go to 250
      do 200 i=1,ns2
      call unpak3 (iph21(i),k1,k2,ifaz)
      call unpak3 (iph22(i),k3,k4,ifaz)
      ka1=iabs(k1)
      ka2=iabs(k2)
      if(iphaz(ka1).eq.0.or.iphaz(ka2).eq.0) go to 200
      g=abs(float(k4)*0.01)
      if(g.lt.0.0001) go to 200
      ga=g
      iau=isign(iphaz(ka2),k2)
      iau1=isign(iphaz(ka1),k1)
      iarg=iau1+iau
      iarg=mod(iarg+36000,360)
c  peso meta ai ss2 attivi
      if(ga.ge.sogs2) ga=0.5*ga
      sg2=sg2 + ga * bes(g)
      iau=ifaz * 15
      iau=iarg -iau
      iarg=mod(iau+36000,360) + 1
      foms2=foms2 + ga*ctable (iarg)
  200 continue
      fs2num=foms2
      sgtot=sgtot + sg2
      if(sg2.lt.0.00001) go to 250
      foms2=foms2/sg2
  250 if(foms2.gt.f4mx) f4mx=foms2
      if(foms2.lt.f4mn) f4mn=foms2
c
c  *******     negative quartet f.o.m.   *******
c
      fqnnum=0.0
      fomqn=0.0
      sgq=0.0
c
      gmqn=0.0
      nqn=0
      if(nquar.eq.0) go to 310
      do 300 i=1,nquar
      call unpak3 (iqu1(i),k1,k2,ifaz)
      call unpak3 (iqu2(i),k3,k4,ifaz)
      call unpak3 (iqu3(i),k5,k6,ifaz)
      ka1=iabs(k1)
      ka2=iabs(k2)
      ka3=iabs(k3)
      ka4=iabs(k4)
      g=abs(float(k6)*0.01)
      if(iphaz(ka1).eq.0.or.iphaz(ka2).eq.0.or.iphaz(ka3).eq.0.
     1 or.iphaz(ka4).eq.0) go to 300
c    1 or.iphaz(ka4).eq.0) then
c
c
c se un riflesso e' non fasato entra con g dimezzato
c                            g=g*0.5
c
c
c                            go to 299
c                          endif
      iarg=isign(iphaz(ka1),k1)+ isign(iphaz(ka2),k2) +
     1       isign(iphaz(ka3),k3) + isign(iphaz(ka4),k4) + 15*ifaz
      iarg=mod(iarg+36000,360) + 1
      fomqn=fomqn - g*ctable(iarg)
c 299 sgq=sgq + g * bes(g)
      sgq=sgq + g * bes(g)
c
      gmqn=gmqn+g
      nqn=nqn+1
c
  300 continue
      fqnnum=fomqn
      sgtot=sgtot + sgq
      if(sgq.lt.0.00001) go to 310
      fomqn=fomqn/sgq
  310 if(fomqn.gt.f5mx) f5mx=fomqn
      if(fomqn.lt.f5mn) f5mn=fomqn
c
c  *******   psi-zero  f.o.m.    *******
c  -------   psi0, rpsi-1, rpsi-2, abspsi   -----------
c
c nuova procedura - psicom compresa in alcom
      rpsi1=0.0
      rpsi2=0.0
      abspsi=0.0
      fomps0=0.0
      psicom=0.0
c
c-new vecchio calcolo psicom - non inclusa in cfom
c
      sigm=sigmp
      if(icent.le.0) sigm=2.0*sigmp
      id28=2**30
      attps1=0.215
      attps2=0.736
      attps3=1.0
      attps4=0.886
      if(num0.eq.0) go to 450
      s1=0.0
      s2=0.0
      do 360 i=1,num0
      li=lim0n(i) + 1
      ls=lim0n(i+1)
      if (ls.lt.li ) goto 360
      t1=0.0
      t2=0.0
      t4=0.0
      do 350 j=li,ls
      iph0n(j)=mod(iph0n(j),id28)
      call unpak3(iph0n(j),k1,k2,ifaz)
      ka1=iabs(k1)
      ka2=iabs(k2)
      if(iphaz(ka1).eq.0.or.iphaz(ka2).eq.0) go to 350
      iarg=isign(iphaz(ka1),k1) + isign(iphaz(ka2),k2) +
     * ifaz*15
      iarg=mod(iarg+36000,360) + 1
      ee=e(ka1)*e(ka2)
      t3=sigm*ee
      t4=t4 + t3*t3
      t1=t1 + t3*ctable(iarg)
      t2=t2 + t3*stable(iarg)
  350 continue
      t11=sqrt(t1*t1 + t2*t2)
      t4=sqrt(t4)
      s1=s1 + t11
      s2=s2 + t4
      t3=0.0
      if (t4.gt.0.0001) t3=t11/t4
      s10=t3*t3
      t1=0.886
      if (icent.gt.0) t1=0.798
      rpsi1=rpsi1+(t3-t1  )*(t3-t1  )
      rpsi2=rpsi2+abs(s10  -1.0)
      abspsi=abspsi + s10
  360 continue
      t3=1.0/float(num0)
      rpsi1=rpsi1  * t3 / attps1
      rpsi2=rpsi2  * t3 / attps2
      abspsi=abspsi * t3
      if(abs(s2).gt.0.0001) fomps0=s1/(s2*attps4)
      if (absfom.gt.0.001) then
      psicom=0.25 * ( fomps0 + sqrt( rpsi1 )
     1    + sqrt( rpsi2 ) + sqrt( abspsi )) /       absfom
                           else
      psicom=0.0
                           endif
c-endnew
  450 if(fomps0.gt.f7mx) f7mx=fomps0
      if(fomps0.lt.f7mn) f7mn=fomps0
      if(rpsi1.gt.f10mx) f10mx=rpsi1
      if(rpsi1.lt.f10mn) f10mn=rpsi1
      if(rpsi2.gt.f11mx) f11mx=rpsi2
      if(rpsi2.lt.f11mn) f11mn=rpsi2
      if(abspsi.gt.f12mx) f12mx=abspsi
      if(abspsi.lt.f12mn) f12mn=abspsi
c
c *****    negative triplets  f.o.m.    *****
c
      fomntr=0.0
      ftrnum=0.0
      sgt=0.0
      if(ntrneg.eq.0) go to 455
      do 1400 i=1,ntrneg
      call unpak3 (negt1(i),k1,k2,ifaz)
      call unpak3 (negt2(i),k3,k4,ifaz)
      ka2=iabs(k2)
      ka3=iabs(k3)
      g=k4*0.01
      ga=abs(g)
      if(iphaz(k1).eq.0.or.iphaz(ka2).eq.0.or.iphaz(ka3).eq.0)
     *  go to 1400
c
c
c se un riflesso e' non fasato entra con g dimezzato
c                            ga=ga*0.5
c
c
c                           go to 1399
c                                                            endif
      iarg=iphaz(k1)+isign(iphaz(ka2),k2)+isign(iphaz(ka3),k3)
     * + 15*ifaz
      iarg=mod(iarg+36000,360) + 1
      fomntr=fomntr -ga*ctable(iarg)
c1399 sgt=sgt+ ga *bes(ga)
      sgt=sgt+ ga *bes(ga)
c
      gmqn=gmqn+ga
      nqn=nqn+1
c
 1400 continue
      ftrnum=fomntr
      sgtot=sgtot + sgt
      if(sgt.lt.0.00001) go to 455
      fomntr=fomntr/sgt
  455 if(fomntr.gt.f6mx) f6mx=fomntr
      if(fomntr.lt.f6mn) f6mn=fomntr
c
c NEW 5/11/91 peso cphase con D1(<G>) rispetto ad alcomb
      if(nqn.gt.0) then
                      gmqn=gmqn/nqn
                      wqtn=sqrt(bes(gmqn))
                    else
                      wqtn=0.0
                   endif
c
c  *******  enantiomorph sensitive  f.o.m. ' s
c
      fents=0.0
      fenqs=0.0
      gfx=0.1
      ren1=0.0
      gents=0.0
      ren2=0.0
      genqs=0.0
c  ----  skip if space group is centrosymmetric  ----
      if (icent.gt.0) go to 2200
c  +++++++     triplet  f.o.m.' s    +++++++
      if(nen.le.0) go to 2070
      n=0
      do 2050 i=1,nen
      call unpak3 (nent1(i),k1,k2,ifaz)
      call unpak3 (nent2(i),k3,k4,ifaz)
      ka2=iabs(k2)
      ka3=iabs(k3)
      if(iphaz(k1).eq.0.or.iphaz(ka2).eq.0.or.iphaz(ka3).eq.0)
     *  go to 2050
      iarg=iphaz(k1)+isign(iphaz(ka2),k2)+isign(iphaz(ka3),k3)
     * + 15*ifaz
      iarg=mod(iarg+36000,360) + 1
      fents=fents + abs(stable(iarg))
      n=n + 1
 2050 continue
      if(n.eq.0) go to 2070
      ren1=float(n)*gfx
      gents=fents*gfx
      s1=1.0/float(n)
      fents=fents*s1
 2070 if(fents.gt.f8mx) f8mx=fents
      if(fents.lt.f8mn) f8mn=fents
c  +++++++     quartet  f.o.m.' s    +++++++
      if(nqen.le.0) go to 2170
      n=0
      do 2150 i=1,nqen
      call unpak3 (nq1(i),k1,k2,ifaz)
      call unpak3 (nq2(i),k3,k4,ifaz)
      call unpak3 (nq3(i),k5,k6,ifaz)
      ka1=iabs(k1)
      ka2=iabs(k2)
      ka3=iabs(k3)
      ka4=iabs(k4)
      if(iphaz(ka1).eq.0.or.iphaz(ka2).eq.0.or.iphaz(ka3).eq.0.
     1 or.iphaz(ka4).eq.0) go to 2150
      iarg=isign(iphaz(ka1),k1)+ isign(iphaz(ka2),k2) +
     1       isign(iphaz(ka3),k3) + isign(iphaz(ka4),k4) + 15*ifaz
      iarg=mod(iarg+36000,360) + 1
      fenqs=fenqs + abs(stable(iarg))
      n=n + 1
 2150 continue
      if(n.eq.0) go to 2170
      ren2=float(n)*gfx
      genqs=fenqs*gfx
      s1=1.0/float(n)
      fenqs=fenqs*s1
 2170 if(fenqs.gt.f9mx) f9mx=fenqs
      if(fenqs.lt.f9mn) f9mn=fenqs
 2200 continue
      if(sgtot.gt.0.00001) coms=(fs1num +  fs2num+ fqnnum +
     * ftrnum  )/sgtot
      if (jall.eq.1)
     *write(lo,2220) nuset,fs1num,sg1,fs2num,sg2,fqnnum,sgq,
     * ftrnum,sgt,gents,ren1,genqs,ren2
 2220 format(1x,i4,6(2x,2f8.2))
c--
      den12=ren1+ren2
      enan=0.0
      if (abs(den12).gt.0.00001) enan=(gents+genqs)/den12
c
c ======= compute  combined  f.o.m.
c
      if(f1mn.gt.1.0e+19) f1mn=0.0
      if(f2mn.gt.1.0e+19) f2mn=0.0
      if(f21mn.gt.1.0e+19) f21mn=0.0
      if(f22mn.gt.1.0e+19) f22mn=0.0
      if(f23mn.gt.1.0e+19) f23mn=0.0
      if(f3mn.gt.1.0e+19) f3mn=0.0
      if(f4mn.gt.1.0e+19) f4mn=0.0
      if(f5mn.gt.1.0e+19) f5mn=0.0
      if(f6mn.gt.1.0e+19) f6mn=0.0
      if(f7mn.gt.1.0e+19) f7mn=0.0
      if(f8mn.gt.1.0e+19) f8mn=0.0
      if(f9mn.gt.1.0e+19) f9mn=0.0
      if(f10mn.gt.1.0e+19) f10mn=0.0
      if(f11mn.gt.1.0e+19) f11mn=0.0
      if(f12mn.gt.1.0e+19) f12mn=0.0
      if(f13mn.gt.1.0e+19) f13mn=0.0
      if(f1mx.lt.-1.0e+19) f1mx=0.0
      if(f2mx.lt.-1.0e+19) f2mx=0.0
      if(f21mx.lt.-1.0e+19) f21mx=0.0
      if(f22mx.lt.-1.0e+19) f22mx=0.0
      if(f23mx.lt.-1.0e+19) f23mx=0.0
      if(f3mx.lt.-1.0e+19) f3mx=0.0
      if(f4mx.lt.-1.0e+19) f4mx=0.0
      if(f5mx.lt.-1.0e+19) f5mx=0.0
      if(f6mx.lt.-1.0e+19) f6mx=0.0
      if(f7mx.lt.-1.0e+19) f7mx=0.0
      if(f8mx.lt.-1.0e+19) f8mx=0.0
      if(f9mx.lt.-1.0e+19) f9mx=0.0
      if(f10mx.gt.1.0e+19) f10mx=0.0
      if(f11mx.gt.1.0e+19) f11mx=0.0
      if(f12mx.gt.1.0e+19) f12mx=0.0
      if(f13mx.gt.1.0e+19) f13mx=0.0
      if (jall.eq.1)
     *write(lo,510) f1mn,f23mn,f2mn,f21mn,f22mn,f3mn,f4mn,f5mn,f6mn,
     * f7mn,f12mn,f11mn,f10mn,f8mn,f9mn,
     *              f1mx,f23mx,f2mx,f21mx,f22mx,f3mx,f4mx,f5mx,f6mx,
     * f7mx,f12mx,f11mx,f10mx,f8mx,f9mx
  510 format(/// 30x,'++++++++++  figures  of  merit  ++++++++++'//
     *8x,'mabs ',' nalf(1)',' nalf(2)',' nalf(3)',' nalf(4)','    ss1 ',
     *'    ss2 ','    nqu ','    ntr ','  nps(0)','  nps(1)','  nps(2)',
     *'  nps(3)','   entr ','   enqu ',
     * //,' min',15f8.3/,' max',15f8.3)
      if (jall.eq.1) write (lo,530)
  530 format(///' trial',2x,'mabs ',
     *           ' nalf(1)',' nalf(2)',' nalf(3)',' nalf(4)','    ss1 ',
     *'    ss2 ','    nqu ','    ntr ','  nps(0)','  nps(1)','  nps(2)',
     *'  nps(3)','   entr ','   enqu ',/)
      if (jall.eq.1)
     *write(lo,550) nuset,absfom,almed,resid,al2,al2m1,
     * foms1,foms2,fomqn,fomntr,fomps0,abspsi,
     * rpsi2,rpsi1,fents,fenqs
  550 format(1x,i3,17f8.3)
      if (nundet.lt. (numb/2) ) goto 558
      alcom=0.0
      psicom=0.0
      crel=0.0
      coms=0.0
      goto 586
  558 crel=coms
Corig if ( alcom.gt.1.0)  go to 560
      if ( alcom.gt.0.8)  go to 560
      alcom=1.0
      go to 565
c     go to 575
c 560 arg=( alcom  -1.0 )**1.5
  560 arg=( alcom  -0.8 )**1.5
      if(arg.gt.87.0) then
                       alcom=0.0
                      else
                       alcom=exp( -arg )
                      endif
c-
c 565 if (psicom.gt.1.0) go to 570
  565 if (psicom.gt.0.8) go to 570
      if (num0.eq.0) then
                       psicom=0.0
                     else
                       psicom=1.0
      endif
      go to 575
  570 continue
Corig psicom=exp( -(( psicom -1.0 )**1.5))
      psicom=exp( -(( psicom -0.8 )**1.5))
c-
  575 if (nphas.eq.0) go to 581
      if (  crel.lt.0.00001.and.crel.gt.-0.00001)   go to 581
Corig if (  crel.lt.1.0)   go to 580
      if (  crel.lt.1.2)   go to 580
      crel=1.0
      go to 581
  580 continue
Corig crel =exp( -(( 1.0 - crel  )**1.5))
      crel =exp( -(( 1.2 - crel  )**1.5))
  581 if (alcom.gt.f15mx) f15mx=alcom
      if (alcom.lt.f15mn) f15mn=alcom
      if(psicom.gt.f14mx) f14mx=psicom
      if(psicom.lt.f14mn) f14mn=psicom
      if (coeco.gt.f16mx) f16mx=coeco
      if (coeco.lt.f16mn) f16mn=coeco
      if(  crel.gt.f17mx) f17mx=  crel
      if(  crel.lt.f17mn) f17mn=  crel
c NEW 11/10/91 elimino contributo MABS pesata da CFOM finale
      swwn=1.0/(1.0+wqtn)
      coms=swwn*( crel*wqtn + alcom )
      if( coms.gt.f18mx) f18mx= coms
      if( coms.lt.f18mn) f18mn= coms
      enan=asin(enan)*rtod
  586 nsacc=nsacc+1
      ksacc=ksacc+1
      if (nuset.le.nsxx) cfomx=f18mx
      call scrp(nuset,nsxx,coms,cfomx)
c     write(lo,751) nuset,absfom,alcom,psicom,crel,coms,error,errpes,
c    *              enan,nundet
c 751 format(' trial #',i4,' foms=',5f8.3,8x,3f8.3,i6)
      if(ksacc.le.mxsac) then
                           nsind=ksacc
                           if(ksacc.eq.1) then
                              aminco=9.0
                              mxsaco=mxsac
                                          endif
                           if (jumpp.eq.1) go to 760
                           if(coms.lt.aminco) aminco=coms
                           if(coms.lt.0.0001.and.ksacc.gt.1) then
                                            nfom0=nfom0+1
                                            ksacc=ksacc-1
                                            go to 660
                                                           endif
                         endif
      if(jumpp.eq.1.and.ksacc.gt.mxsaco) then
                                               mxsaco=mxsaco+1
                                               nsind=mxsaco
                                               go to 760
                                            else
         if(ksacc.gt.mxsac) then
                              aminco=fomrt(1,5)
                              nsmin=1
                              do 710 idn=2,mxsac
                                 if(fomrt(idn,5).lt.aminco) then
                                    aminco=fomrt(idn,5)
                                    nsmin=idn
                                                           endif
 710                          continue
                              nsind=nsmin
                              if(coms.lt.aminco) then
                                  ksacc=ksacc-1
                              if(coms.lt.0.01) nfom0=nfom0+1
                                  goto 660
                                                 endif
                              endif
                                             endif
      if (npunt.gt.0) then
      cfodi=0.009
      jsacc=ksacc-1
      if (jsacc.gt.mxsac) jsacc=mxsac
      if (jsacc.eq.0) go to 760
      do 730 j=1,jsacc
      cfomd=abs(coms-fomrt(j,5))
      if (cfomd.lt.cfodi) then
                           jjeq=j
      cfomd=(abs(absfom-fomrt(jjeq,1))
     *      +abs( alcom-fomrt(jjeq,2))
     *      +abs(crel-fomrt(jjeq,4)))/3.0
      if (cfomd.gt.cfodi) go to 730
      iflag=0
      call snr16(jjeq,fig,wtj,iphazj)
      do 770 k=1,npunt
      i=jpunt(k)
      if (wt(i).gt.0.01.and.wtj(i).gt.0.01) then
            iphen=360.000-iphaz(i)
            if (abs(iphaz(i)-iphazj(i)).le.3.or.abs(iphen-iphazj(i))
     *.le.3) then
                go to 770
            else
                go to 730
            endif
            endif
  770 continue
      ksacc=ksacc-1
      jseteq=jseteq+1
c
c-new 22/04/93 to store equivalent trial with cfom max
c
      if (knw.eq.0) then
                       if (coms.gt.fomrt(jjeq,5)) then
                                               nsind=jjeq
                                               go to 760
                                             endif
                      else
                       if (error.lt.fomrt(jjeq,7)) then
                                               nsind=jjeq
                                               go to 760
                                             endif
                       endif
c-endnew
             endif
  730 continue
             endif
  760 fomrt(nsind,1)=absfom
      fomrt(nsind,2)=alcom
Corig fomrt(nsind,3)=psicom
      fomrt(nsind,3)=coeco
      fomrt(nsind,4)=crel
      fomrt(nsind,5)=coms
      fomrt(nsind,6)=nundet
      fomrt(nsind,7)=error
      fomrt(nsind,8)=errpes
      fomrt(nsind,9)=enan
      fomrt(nsind,10)=nuset
      psivet(nsind)=psicom
      iyzz=iyyy
      if (knw.eq.1.and.jumpp.eq.1.and.lasts.eq.0) go to 660
      nurec=nsind
      do 650 j=1,10
  650 fig(j)=fomrt(nsind,j)
      call snw16(nurec,fig,wt,iphaz)
  660 return
      end
c-----------------------------------------------------------------------
      subroutine weitan(ilist,nuset,pub,ifsal,
     1 ns1mx,sogs2,sigm,mxsac,mxsaco,nsacc,aminco,nena)
c
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngenn
     *,irot(48,48),jsvet(10),isvet(8),nori,imod(3),nss(3)
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
      common / ureq1/ jpatt,jpunt(501),ksacc,jseteq,jumpp,jmpsie,nsec
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common /unp/ hmax,kmax,lmax,iplan,irang,iplan2
      common /param/ numb,nant(4),nral,ckae,salfe,ssig,nref,nsxx
      common /tables/ stable(500)
      common /xdata/ imat(3,20000),z(500),iee(20000),iph(41000),
     * iphaz(500),iorde(500),
     2 alfest(500),iz(500),ih(800),e(800),limref(500),mkang(800),
     3 alfvar(500),ifstor(500),alpha(500),icont(3),kdstor(500),wt(500),
     4 zp(500),irefin(500),nn(8),nbinv(61000),enil(4),line(4,6),absfom,
     5 resid,al2,al2m1,almed,nundet,error,errpes,fomps0,foms1,coms,
     6 fomrt(302,10),f1mx,f1mn,f2mx,f2mn,f21mx,f21mn,f22mx,f22mn,f23mx,
     7 f23mn,f3mx,f3mn,f4mx,f4mn,f5mx,f5mn,f6mx,f6mn,f7mx,f7mn,f8mx,
     8 f8mn,f9mx,f9mn,f10mx,f10mn,f11mx,f11mn,f12mx,f12mn,f13mx,f13mn,
     9 f14mx,f14mn,f15mx,f15mn,f16mx,f16mn,f17mx,f17mn,f18mx,f18mn,
     * iph1(500),negt1(500),negt2(500),iqu1(750),iqu2(750),
     1 iqu3(750),nent1(500),nent2(500),nq1(500),nq2(500),nq3(500),
     2 iph21(2514),iph22(2514),iyvet(500),dummx(38210)
      common /cris/ numcri,jcran,maxtri,nstart,muset
      common /buffer/ ianto(500),dummb(15)
      integer hmax,pub(800)
      dimension ctable(500),linex(20),enix(20),ifa(3)
      equivalence (stable(91),ctable(1))
c
c+++++++++++ segnala  nel vettore  irefin() i riflessi con fase nota
c+++++++  considera i riflessi origine ed i simboli
c
      subtr=0.0
      inord=0
      soglow=0.5
      zer=0.1e-10
      numb2=numb/2
      do 1550 i=1,numb
      irefin(i)=0.
      alpha(i)=0.
 1550 continue
      if(ifsal.ne.0)  goto 6000
      do 50 i=1,numb
      ianto(i)=0
   50 continue
      if (jcran.eq.1) then
                        do 60 i=1,3
                        jj=kdstor(i)
                        if (jj.ne.0) ianto(jj)=1
   60                   continue
                        if (nant(1).ne.0) ianto(iabs(nant(1)))=1
                      endif
      if(knw.eq.0) goto 100
      if (nant(1).eq.0) go to 90
      ns=iabs(nant(1))
      if(pub(ns).gt.180) iphaz(ns)=iphaz(ns)+180
      iphaz(ns)=pub(ns)
   90 if (nori.eq.0) go to 100
      do 10000 i=1,3
      jj=kdstor(i)
      if(jj.eq.0) goto 100
10000 iphaz(jj)=pub(jj)
  100 continue
      if (jcran.ne.1) then
                        nfin=icont(2)
                        do 603 i=1,nfin
                        if(kdstor(i).ne.0) then
                                             ncod=kdstor(i)
                                             irefin(ncod)=1
                                             endif
  603                   continue
c++++poni irefin = 1 per fasi note -
                        nfin=  icont(3)
                        if (nfin.ne.15) then
                                          do 605 i=16,nfin
                                          ncod=kdstor(i)
                                          if (ncod.ne.0) irefin(ncod)=1
  605                                     continue
                                        endif
                      else
c===============================================================
c     questa parte serve a (non) fissare origine etc.
c     ponendo irefin   =   ( 0 )    1
                        if (nori.ne.0) then
                                         do 608 i=1,3
                                         jj=kdstor(i)
                                         if(jj.ne.0) irefin(jj)=1
  608                                    continue
                                       endif
                      endif
c===============================================================
      if(nant(1).ne.0) irefin(iabs(nant(1)))=1
      ncycl = 0
      do 610 i=1,500
      if(jcran.eq.1.and.wt(i).le.1.00) go to 610
      if(wt(i).eq.0) goto 610
      alpha(i)=abs(wt(i))
      wt(i)=bes(alpha(i))*sign(1.0,wt(i))
  610 continue
      ifin=0
      salf=0.
      if (jcran.eq.1) then
                        alpham=100000
                        nnn=nstart
                      else
                        alpham = 25.
                        nnn= min0(100,numb)
                      endif
      if (muset.eq.nuset) write(lo,1318)
     *   (iorde(i),pub(iorde(i)),iphaz(iorde(i)),irefin(iorde(i)),
     *    i=1,nstart)
 1318 format(6(i5,1h),2i4,i2,4x))
      if (jall.eq.0) goto  2990
      j=0
      do  650 i=1,numb
      if (iz(i) .eq. 0) go to  650
      j = j + 1
      linex(j) = iphaz(i)
      enix(j) = wt(i)
      if (j .lt. 20) go to  650
      write(lo,1320) (linex(k),k=1,j)
 1320 format(41x,20i4)
      write(lo,1325) (enix(k),k=1,j)
 1325 format(41x,20f4.2)
      j = 0
  650 continue
      if(j .gt. 0) write(lo,1320) (linex(k),k=1,j)
      if(j .gt. 0) write(lo,1325) (enix(k),k=1,j)
 2990 ncycl = ncycl + 1
      alphmax=0.0
      sumalf= salf
      salf  = 0.0
      numb1 = 0
      error = 0.0
      dalfa = 0.0
      tom   = 0.0
      jcon=0
      do 3500 ll= 1,nnn
      k=iorde(ll)
      if(k.lt.0) go to 3500
      if((ifin.eq.0).and.(irefin(k).ne.0) ) go to 3500
      alfmed=0.0
      varia=0.0
      jcon=jcon+1
      li=limref(k)+1
      ls=limref(k+1)
      if(li.gt.ls) go to 3500
      cang=0.
      sang=0.
      cangb=0.
      sangb=0.
      can=0.
      san=0.
      jcris=0
      do 3400 jj= li,ls
      ind=nbinv(jj)
      iphind=iph(ind)
      iphnd1=iph(ind+1)
      numi=0
      w=1
      ip=0
      nn(2)=0
      ifa(2)=0
      nn(3)=0
      ifa(3)=0
      iw=2
      ir=iphind/131072-2048
      ira=iabs(ir)
      if(ira.eq.k) goto 3021
      if(abs(wt(ira)).lt.0.1) goto 3400
      numi=numi+1
      nn(numi)=ir
      w=w*wt(ira)
      ifa(numi)=iphaz(ira)
      goto 3022
 3021 isi=isign(1,ir)
 3022 ir=mod(iphind,131072)/32-2048
      ira=iabs(ir)
      if(ira.eq.k) goto 3018
      if(abs(wt(ira)).lt.0.1) goto 3400
      numi=numi+1
      nn(numi)=ir
      w=w*wt(ira)
      ifa(numi)=iphaz(ira)
      goto 3019
 3018 isi=isign(1,ir)
 3019 ir=iphnd1/131072-2048
      ira=iabs(ir)
      if(ira.ge.700) goto 3017
      if(ira.eq.k) goto 3016
      if(abs(wt(ira)).lt.0.1) goto 3400
      numi=numi+1
      nn(numi)=ir
      w=w*wt(ira)
      ifa(numi)=iphaz(ira)
      goto 3017
 3016 isi=isign(1,ir)
 3017 ifaz=mod(iphnd1,32)-1
c  controllo eventuale quartetto
      if(ifaz.ge.0) go to 3030
      iw=3
      iphnd2=iph(ind+2)
      ir=mod(iphnd1,131072)/32-2048
      ira=iabs(ir)
      if(ira.eq.k) goto 3024
      if(abs(wt(ira)).lt.0.1) goto 3400
      numi=numi+1
      nn(numi)=ir
      w=w*wt(ira)
      ifa(numi)=iphaz(ira)
      goto 3025
 3024 isi=isign(1,ir)
 3025 iphnd1=iphnd2
      ifaz=mod(iphnd1,32)-1
 3030 nn(1)=-nn(1)*isi
      nn(2)=-nn(2)*isi
      if (iw.eq.3) nn(3)=-nn(3)*isi
      ip=isign(ifa(1),nn(1))
      ip=ip+isign(ifa(2),nn(2))
      if (iw.eq.3) ip=ip+isign(ifa(3),nn(3))
      ifaz=-ifaz*isi
      if(ifaz.lt.0) ifaz=ifaz+24
      aa1=abs(w)
      nn2=iabs(nn(1))
      nn3=iabs(nn(2))
      a1=(mod(iphnd1,131072)/32-2048)*0.01
      if(a1.gt.6.) a1=6.0
      jcris=jcris+1
      ip=ip+15*ifaz+36000
      ip= mod(ip,360)+1
      gbes=abs(a1)
corig a1=bes(gbes)
      a1=bes(a1)
      if (jcran.eq.1) then
                        aa1=aa1*gbes
                        ee=aa1
                        aab=bes(aa1)
                        sangb=sangb+gbes*aab*stable(ip)
                        cangb=cangb+gbes*aab*ctable(ip)
                      else
                        aa1=aa1*abs(a1)
                        ee=besinv(aa1)
                      endif
      sang=sang+ee*stable(ip)
      cang=cang+ee*ctable(ip)
      san=san+gbes*stable(ip)
      can=can+gbes*ctable(ip)
      alfmed=alfmed+gbes*a1
      d1=bes(gbes)
      ee=gbes
      d2=1-(2./ee)*d1
      costa=1+d2-2.*(d1*d1)
      varia=varia+gbes*gbes*costa
 3400 continue
      if (jcris.eq.0) go to 3500
c
c-- introduce psi-zero in tangent formula
c
      if (nnn.eq.numb) then
                     call newpsi(nuset,k,san,can,sang,cang,sangb,cangb,
     *                           subtr,nn0,tnd,alpham)
      subtr=0.0
                      endif
      if(mkang(k).eq.1) go to 3418
      idv = 15*mod(iabs(mkang(k))-1,12) + 1
      t2 = sang*stable(idv) + cang*ctable(idv)
      sang = t2*stable(idv)
      cang = t2*ctable(idv)
      t2 = san*stable(idv) + can*ctable(idv)
      san = t2*stable(idv)
      can = t2*ctable(idv)
      if (jcran.eq.1) then
                        t2 = sangb*stable(idv) + cangb*ctable(idv)
                        sangb = t2*stable(idv)
                        cangb = t2*ctable(idv)
                      endif
c
 3418 if(abs(sang).lt.zer.and.abs(cang).lt.zer) go to 3500
      if(abs(san).lt.zer.and.abs(can).lt.zer) go to 3500
c
      alfa = sang*sang + cang*cang
      if(alfa.lt.zer) goto 3500
      if (jcran.eq.1) then
      if(abs(sangb).lt.zer.and.abs(cangb).lt.zer) go to 3500
      alfab = sangb*sangb + cangb*cangb
      if(alfab.lt.zer) goto 3500
                      endif
c
      alfsp = san*san + can*can
      alpha(k)=alfa
      aiu=sqrt(alfsp)
      phaz=rtod*atan2(sang,cang)
      ip=phaz+sign(0.5,phaz)
      ip=mod(ip+3600,360)
      if(ip.eq.0) ip=360
      iphaze=ip
      wh=1.
      expo=1.
      alfmed=abs(alfmed)
      if(jcris.le.4.or.aiu.le.alfmed) goto 3455
      cost= ( aiu - alfmed) * ( aiu -alfmed)
      valex=cost/varia
      if (jcran.eq.1) then
cccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c     nuovo peso
c
      valex=sqrt(valex)
      if (valex.gt.1.0) then
                          wh=exp(-valex+1.0)
                          wh=wh * *  0.20
                          if (wh.lt.0.001) wh=0.001
                          endif
      alfanu=sqrt(alfab) * wh
CPROVAalfanu=     alfmed * wh
      alpha(k)=alfanu*alfanu
CPROVAphaz=rtod*atan2(sangb,cangb)
CPROVAip=phaz+sign(0.5,phaz)
CPROVAip=mod(ip+3600,360)
CPROVAif(ip.eq.0) ip=360
CPROVAiphaze=ip
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccc
                      else
cccccccccccccccccccccccccccccccccccccccccccccccccccccc
c
c     vecchio peso
c
      expo=-valex
      wh= exp(expo)
      wh=wh * * (1/3.)
      if (wh.lt.0.2) wh=0.2
      alfanu=(alfmed-subtr) * wh
      alpha(k)=alfanu*alfanu
c
cccccccccccccccccccccccccccccccccccccccccccccccccccccc
                      endif
 3455 continue
      if (jcran.eq.1) then
                        if(alpha(k).gt.alphmax) alphmax=alpha(k)
                        if(alpha(k).lt.alpham) go to 3500
                        wt(k)=wh
                        ianto(k)=1
                      else
                        aiuto=sqrt(alpha(k))
                        if(alpha(k).lt.alpham) go to 3500
                        wt(k)=bes(aiuto)
                      endif
      iphaz(k)=iphaze
      if(nuset.eq.muset) then
                       delta1=float(iphaz(k)-pub(k)) * dtor
                       delta1=atan2(sin(delta1),cos(delta1))
                       kdiff=nint(delta1*rtod+3600)
                       kdiff=mod(kdiff,360)
                       if (kdiff.gt.180) kdiff=360-kdiff
                       varsq=sqrt(varia)
                       soglia=sqrt(alpham)
                       sqalfa=sqrt(alfa)
                       sqalfk=sqrt(alpha(k))
       write(lo,3457) k,jcris,pub(k),iphaz(k)
     * ,kdiff,sqalfa,aiu,alfmed,varsq,wh,aiuto,wt(k),
     *  soglia,sqalfk
 3457 format(' code,jcris =',2i4,' fasi ',3i4,
     * ' ',4f9.2,f9.4,4f9.2)
c                      write(lo,3458) cost,varia,valex
*3458 format(13x,16x,6x,12x,9x,' ',7f9.2)
                     endif
      numb1=numb1+1
      salf=salf+alpha(k)
      if (knw.ne.0) then
                      snn = sqrt(alpha(k))
                      tom = tom + snn
                      icb = iabs(iphaz(k)-pub(k))
                      icb = min0(icb,360-icb)
                      css = icb
                      error = error + css
                      dalfa = dalfa + snn*css
                    endif
 3500 continue
      if (nnn.eq.numb) then
                         ipr=0
                         call newpsi4(nuset,ipr)
                       endif
      if(numb1.gt.0) error = error/float(numb1)
      if(tom.gt.0.0001) dalfa = dalfa/tom
      if (nuset.eq.muset) then
                            soglia=sqrt(alpham)
                            soglix=sqrt(alphmax)
                            write(lo,9000) ncycl,nnn,soglia,error,
     *                                     dalfa,numb1,soglix
                          endif
 9000 format(//,' ncycl=',i5,' nnn=',i5,' alpham=',f8.3,' error=',f8.3,
     1  ' w-error=',f8.3,' det.phases=',i7,' max alfa=',f10.3)
c
      if (jcran.eq.1.and.ncycl.eq.1) alpham=alphmax
c
      cut= 0.65 * alpham
      alpham=amax1(cut,0.05)
      if(ifin.eq.1) go to 3525
      if (jcran.ne.0) then
                       if (alpham.gt.soglow.and.nnn.ne.numb) go to 2990
                     endif
      if (alpham.gt.1.5) go to 2990
      if(nnn-numb) 3520,3524,3520
 3520 nnn=numb
c
      ipr=0
      call newpsi4(nuset,ipr)
c
c===============================================================
c               questa parte serve a (non) fissare origine etc.
c               ponendo irefin   =   ( 0 )    1
c
      if (jcran.eq.1) then
                        do 3523 i=1,3
                        jj=kdstor(i)
                        if(jj.ne.0) irefin(jj)=0
 3523                   continue
                        if(nant(1).ne.0) irefin(iabs(nant(1)))=0
                        do 3527 i=1,numb
                        wt(i)=wt(i)*ianto(i)
 3527                   iphaz(i)=iphaz(i)*ianto(i)
                      endif
c===============================================================
      alpham=25.
      go to 2990
 3524 continue
c  considero tutti i riflessi e faccio il controllo su sumalf
 3525 if (salf.le.0.0001) go to 9001
      if((salf-sumalf)/salf-0.02) 9001,9001,2990
 9001 if(ifin.eq.1) go to 3530
      do 3528 ll=1,numb
      if(abs(wt(ll)).lt.0.1) go to 3528
      if(irefin(ll).ne.0) go to 3526
      irefin(ll)=1
      go to 3528
 3526 irefin(ll)=2
 3528 continue
      ifin=1
      go to 2990
c   fine loop per raffinamento tangente
3530  continue
c ---     calcolo  absfom , resid  ed error
 6000 continue
      if (nuset.eq.muset)
     *write(lo,3434) (k,pub(k),iphaz(k),wt(k),irefin(k),k=1,numb)
 3434 format(4(i4,1h),2i5,f8.2,i2,4x))
      call absnew(pub,absfom,resid,al2,al2m1,almed,nundet,error,
     1            errpes,nuset,sigm)
c ---
      call fomsp(numb,nuset,nsxx,ns1mx,sogs2,
     * sigm,icent,mxsac,mxsaco,nsacc,aminco,nena)
c ---
      if (knw.eq.1.and.jall.eq.1)
     * write(lo,3590) nuset,error,errpes,nundet
 3590 format(/,4x,'trial no.',i4,3x,'error =',f7.2,' weighted error ='
     1 ,f7.2,' undetermined phases =',i4//)
      if (knw.eq.0.and.jall.eq.1)
     * write(lo,3595) nuset,nundet
 3595 format(/,4x,'trial no.',i4,3x,' undetermined phases =',i4//)
      if(ilist.eq.0) goto 5050
      if(nset.eq.0) goto 3620
      do 3600 jcris=1,nset
      if(nuset.eq.iset(jcris)) goto 3620
 3600 continue
      goto 5050
 3620 continue
      write(lo,4956)
4956  format(' ',4('   code    h   k  l  phi alpha'))
      jj=0
      do 5040 ll= 1 ,numb
      jj=jj+1
      line(jj,1)=ll
      call unpacc(ih(ll),line(jj,2),line(jj,3),line(jj,4))
      line(jj,5)=iphaz(ll)
      enil(jj)=alpha(ll)
      if(jj.lt.4) goto5040
      write(lo,5005) ((line(i,j),j=1,5),enil(i),i=1,4)
5005   format(4(i7,3i4,i5,f6.1))
      jj=0
5040  continue
      if (jj.eq.0) go to 5050
      write(lo,5005)((line(ii,ll),ll=1,5),enil(ii),ii=1,jj)
5050  continue
      return
      end
c-----------------------------------------------------------------------
c
c          Active use of psi-zero relationships
c
c-----------------------------------------------------------------------
      subroutine newpsi(nuset,k,san,can,sang,cang,sangb,cangb,
     *                  subtr,nn0,tnd,alpham)
      common /tables/ stable(500)
      common /param/ numb,nant(4),nral,alra,sumalf,ssig,nref,duma
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common /gian/ limref0(800),nbinv0(61000),jph0(40000),knewpsi,
     *              alphap(300),ktheta(300),a0est(300),a0var(300)
      common /xdata/ imat(3,20000),z(500),iee(20000),iph(41000),
     2 iphaz(500),iorde(500),alfest(500),iz(500),ih(800),e(800),
     3 limref(500),mkang(800),alfvar(500),ifstor(500),alphac(500),
     4 icont(3),idummy(500),wt(500),zp(500),irefin(500),nn(8),
     5 nbinv(61000),eni1(4),lin1(4,6),iee1(20000),
     6 lim1(501),enil(500,2),bility(50),iphh(500),line(500,6),
     7 jvec(3,500),zph(500),dummx(26010)
      dimension ctable(500)
      equivalence (stable(91),ctable(1))
c
      if (knewpsi.eq.0) return
      nn0=0
      sigm=s3s2
      q0=0.798
      if(icent.le.0) then
                       sigm=2.0*s3s2
                       q0=0.886
                      endif
      li=limref0(k) + 1
      ls=limref0(k+1)
      if (ls.ge.li ) then
                       ta=0.0
                       tn=0.0
                       td=0.0
                       do 350 j=li,ls
                       ind=nbinv0(j)
                       call depac0 (k,ind,a,ifaz,iw,nn)
                       k2=nn(1)
                       k3=nn(2)
          nn3=nn(3)
                       ka2=iabs(k2) - numb
                       ka3=iabs(k3)
c
c-- compute alpha' and theta' respect to refl. ka2
c
c                      call newpsi3(ka2)
c
                       if (ktheta(ka2).ne.0.and.iphaz(ka3).ne.0) then
                           iarg = isign(ktheta(ka2),k2)
     *                          + isign(iphaz(ka3),k3)
     *                          + ifaz*15
                           iarg=mod(iarg+36000,360) + 1
                           if (alphap(ka2).ge.a0var(ka2)) then
                             w= alphap(ka2)             / a0var(ka2)
                                   aprimo=e(k)*e(ka3)*sigm
Cristina if (mkang(k).eq.1) aprimo = aprimo / 2.0
                             w=(alphap(ka2)-a0est(ka2)) / a0var(ka2)
                                   w=bes(w)
                                   tn=tn + w * aprimo * stable(iarg)
                                   td=td + w * aprimo * ctable(iarg)
                                   nn0 = nn0 + 1
                                                          endif
                         endif
  350                  continue
                       tnd = sqrt(tn*tn+td*td)
        soglia = sqrt(alpham) * 0.30
c       if(nn0.le.2.or.tnd.lt.soglia) return
        if(tnd.lt.soglia) return
                       san   = san   - tn
                       can   = can   - td
                       sang  = sang  - tn
                       cang  = cang  - td
                       sangb = sangb - tn
                       cangb = cangb - td
                       subtr = sqrt ( tn*tn + td*td )
                     endif
      return
      end
c-----------------------------------------------------------------------
      subroutine newpsi1
      common /param/ numb,nant(4),nral,alra,sumalf,ssig,nref,duma
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common/ureq/ ihx(3),ksigma,knw,jpart,jtran,fosog,ifper,iprin,iflag
c
      common /xdata/ imat(3,20000),z(500),iee(20000),iph(41000),
     2 iphaz(500),iorde(500),alfest(500),iz(500),ih(800),e1(800),
     3 limref(500),mkang(800),alfvar(500),ifstor(500),alphac(500),
     4 icont(3),idummy(500),wt(500),zp(500),irefin(500),nn(8),
     5 nbinv(61000),eni1(4),lin1(4,6),iee1(20000),
     6 lim1(501),enil(500,2),bility(50),iphh(500),line(500,6),
     7 jvec(3,500),zph(500),dummx(26010)
c
      common /psi0/ npsi,num0,alfest0(300),alfvar0(300),llll(300),
     1 lim0n(300),iph0n(20000)
      common /gian/ limref0(800),nbinv0(61000),jph0(40000),knewpsi,
     *              alphap(300),ktheta(300),a0est(300),a0var(300)
      dimension klim0(801)
      equivalence(dummx(1),klim0(1))
c
      if (knewpsi.eq.0) return
c
      iprea=0
      call sflxx(iprea,9,npsi,npsi,num0,nxxe,iccd,imat)
      jg=0
      ifaz=-1
      j=0
      do 25 i=1,npsi
      call unpak3(imat(1,i),kod2,kod3,ishif)
      call unpak3(imat(2,i),kod1,kod2,ishif)
      jph0(j+1)=((kod1+2048)*4096+kod2+2048)*32+ifaz+1
      jph0(j+2)=((kod3+2048)*4096+jg+2048)*32+ishif+1
   25 j=j+2
c
c   preparation of pointers table for psi-zero
c
      n1=0
      n2=0
      nb1 = numb + num0 + 1
      do 100 i = 1,nb1
100   limref0(i) = 0
      j = 1
      do 120 i = 1,npsi
      call depac0 (0,j,a,ifaz,iw,nn)
      j = j + iw
      do 110 kk = 1,3
      if (nn(kk).ne.0) then
                         n1=iabs(nn(kk))+1
                         limref0(n1) = limref0(n1) + 1
                       endif
110   continue
120   continue
      do 130 i = 1,numb + num0
      limref0(i+1) = limref0(i+1) + limref0(i)
      klim0(i+1) = limref0(i+1)
130   continue
      klim0(1) = 0
c
c  storage of the no. of relations for a given reflexion
      j = 1
      do 150 i = 1,npsi
      call depac0 (0,j,a,ifaz,iw,nn)
      do 140 kk = 1,3
      if (nn(kk).ne.0) then
                         ind=iabs(nn(kk))
                         klim0(ind) = klim0(ind) + 1
                         ind1= klim0(ind)
                         nbinv0(ind1) = j
                       endif
140   continue
      j = j+iw
150   continue
      do 300 i=1,numb + num0
      n1=0
      n2=0
      lm=limref0(i)+1
      ls=limref0(i+1)
      if (lm.gt.ls) goto 300
      do 220 ii=lm,ls
      ind=nbinv0(ii)
      call depac0 (0,ind,a1,ifaz,iw,nn)
      if (iw.eq.2) then
                   n1=n1+1
                  else
                   n2=n2+1
                  endif
  220 continue
*     write (6,280) i,lm,ls,n1,n2
* 280 format(2x,i5,1h),5x,4i8)
  300 continue
      do 400 i=1,num0
      alphap(i)=0.0
      ktheta(i)=0
      a0est(i)=0.0
      a0var(i)=0.0
  400 continue
      return
      end
c-----------------------------------------------------------------------
      subroutine newpsi3(kweak)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /tables/ stable(500)
      common/sym/is(2,3,24),ts(3,24),nsym,pts,ksys,icent,latt,s3s2,emme
     *          ,s3s2p
      common /param/ numb,nant(4),nral,alra,sumalf,ssig,nref,duma
      common /psi0/ npsi,num0,alfest0(300),alfvar0(300),llll(300),
     1 lim0n(300),iph0n(20000)
      common /gian/ limref0(800),nbinv0(61000),jph0(40000),knewpsi,
     *              alphap(300),ktheta(300),a0est(300),a0var(300)
      common /xdata/ imat(3,20000),z(500),iee(20000),iph(41000),
     * iphaz(500),iorde(500),
     2 alfest(500),iz(500),ih(800),e(800),limref(500),mkang(800),
     3 alfvar(500),ifstor(500),alpha(500),icont(3),kdstor(500),wt(500),
     4 zp(500),irefin(500),nn(8),nbinv(61000),enil(4),line(4,6),absfom,
     5 resid,al2,al2m1,almed,nundet,error,errpes,fomps0,foms1,coms,
     6 fomrt(302,10),f1mx,f1mn,f2mx,f2mn,f21mx,f21mn,f22mx,f22mn,f23mx,
     7 f23mn,f3mx,f3mn,f4mx,f4mn,f5mx,f5mn,f6mx,f6mn,f7mx,f7mn,f8mx,
     8 f8mn,f9mx,f9mn,f10mx,f10mn,f11mx,f11mn,f12mx,f12mn,f13mx,f13mn,
     9 f14mx,f14mn,f15mx,f15mn,f16mx,f16mn,f17mx,f17mn,f18mx,f18mn,
     * iph1(500),iph0(20000),negt1(500),negt2(500),iqu1(750),iqu2(750),
     1 iqu3(750),nent1(500),nent2(500),nq1(500),nq2(500),nq3(500),
     2 iph21(2514),iph22(2514),lim0(300),psivet(500),imat1(7,1000),
     3 dummx(10910)
      dimension ctable(500)
      equivalence (stable(91),ctable(1))
c
      sigm=s3s2
      q0=0.798
      if(icent.le.0) then
                       sigm=2.0*s3s2
                       q0=0.886
                      endif
c
      i=kweak
      ii=i+numb
      alphap(i)=0.0
      ktheta(i)=0
      a0est(i)=0.0
      a0var(i)=0.0
      li=limref0(ii) + 1
      ls=limref0(ii+1)
      if (ls.ge.li ) then
                       ta=0.0
                       tn=0.0
                       td=0.0
*                      num=min0(ls-li+1,80)
                       jcont=0
                       do 350 j=li,ls
*                      if (jcont.gt.num) go to 350
                       jcont=jcont+1
                       ind=nbinv0(j)
                       call depac0 (0,ind,a,ifaz,iw,nn)
                       k2=-nn(2)
                       k3=-nn(3)
                       ifaz=-ifaz
                       ka2=iabs(k2)
                       ka3=iabs(k3)
                       if (iphaz(ka2).ne.0.and.iphaz(ka3).ne.0) then
                           iarg = isign(iphaz(ka2),k2)
     *                          + isign(iphaz(ka3),k3)
     *                          + ifaz*15
                           iarg=mod(iarg+36000,360) + 1
                           ee=e(ka2)*e(ka3)*sigm
                           ta=ta + ee * ee
                           tn=tn + ee * stable(iarg)
                           td=td + ee * ctable(iarg)
                         endif
  350                  continue
                      if (ta.gt.0.001) then
                          ta=sqrt(ta)
                          alphap(i)=  sqrt(tn*tn + td*td)
                          ip=3600+atan2(tn,td)*rtod
                          ip=mod(ip,360)
                          if (ip.eq.0) ip=360
                          ktheta(i)=ip
                          a0est(i)=ta*q0
                          a0var(i)=ta
                        endif
                     endif
      return
      end
c-----------------------------------------------------------------------
      subroutine newpsi4(nuset,ipr)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common /psi0/ npsi,num0,alfest0(300),alfvar0(300),llll(300),
     1 lim0n(300),iph0n(20000)
      common /gian/ limref0(800),nbinv0(61000),jph0(40000),knewpsi,
     *              alphap(300),ktheta(300),a0est(300),a0var(300)
c
c-- compute alpha' and theta' respect to all refl.
c
****  call  clrt
      do 10 ka2=1,num0
      call newpsi3(ka2)
   10 continue
      return
      end
c-----------------------------------------------------------------------
      subroutine depac0 (i,ind,a,ifaz,iw,nn)
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common /gian/ limref0(800),nbinv0(61000),jph0(40000),knewpsi,
     *              alphap(300),ktheta(300),a0est(300),a0var(300)
      dimension nn(8)
c
      icod=0
      do 10 j = 1,3
   10 nn(j) = 0
      call unpak3(jph0(ind),nn(1),nn(2),ifaz)
      call unpak3(jph0(ind+1),nn(3),jg,ifaz)
      iw = 2
      if (i.ne.0) then
                    jj=0
                    do 50 j = 1,3
                    if (iabs(nn(j)).eq.i) jj=j
   50               continue
                    if (jj.eq.0) then
                                   write(lo,90) i,nn(1),nn(2),nn(3),ind
                                   stop
                                 endif
                    isi = - isign(1,nn(jj))
                    j1 = 1
                    do 70 jcris = 1,3
                    if (jcris.ne.jj) then
                                       nn(j1) = nn(jcris) * isi
                                       j1 = j1+1
                                    endif
   70               continue
                    ifaz = ifaz * isi
                    if (ifaz.lt.0) ifaz=ifaz+24
                  endif
   90 format (5x,'***** error in subroutine depac0 ******',i5,3x,4i5)
      return
      end
CRYSTALS CODE FOR SCREEN92
c-----------------------------------------------------------------------
      subroutine scr1
      character str*80
      character beg,commen,allcom(25)*14
      character fname(9)*80,ext(9)*4
      common/dotdat/ fname,ext
      common /charas/ beg,commen,allcom
      common /comdir/ icomq(200,2),maxcom,ipcom,ipdir,icomat
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/sf/al(4,8),bs(4,8),cl(8),nw(8),no(8),nk,nat,f(9),nalf(8)
      common/screen/ kscreen,iys,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      common /buffer/ ixv(100),iyv(100),dummr(315)
      character *80 messh,messp(10),messf(10),messr(10)
      common /scmess/messh,messp,messf,messr,izv(4),ipuntp,ipuntf,ipuntr
      character*80 sirtx
      common /sirtxt/ sirtx,jhelp
c
      if (kscreen.eq.0) return
      kkprog=mod(kprog,10)
      if (jscreen.eq.0) then
          ipuntp=0
          ipuntf=0
          ipuntr=0
c
c-- define the name of XSir92.txt file
c
          str=' '
          iz=Lung(sirtx)
          str(1:iz)=sirtx(1:iz)
          ind = -1
          call graphs( ixv,iyv,iz,ind,str,icolor)
c
c-- open the window
c
          ind=1
          ixv(1)=kscrx
          iyv(1)=kscry
          icolor=1
          write(str,'(20a4)') itle
          iz=79
          call graphs( ixv,iyv,iz,ind,str,icolor)
          if (iz.lt.0) then
                         kscreen=0
                         return
                       endif
          kscrx=ixv(1)
          kscry=iyv(1)
          jscreen = 1
                        endif
c
      ivd=kscry/20
c
      call NewPage
c
c-- draw the Header
c
      k=index(fname(1),'.')
      call sirtime(str,icod)
      if (kkprog.eq.1) then
       lprog=16
       if (icod.eq.0) then
          messh=             ' SIR92 runs on: '//fname(1)(1:k-1)
        else
          messh=str(1:icod)//' SIR92 runs on: '//fname(1)(1:k-1)
        endif
       else
       lprog=20
       if (icod.eq.0) then
          messh=             ' SIRPOW.92 runs on: '//fname(1)(1:k-1)
        else
          messh=str(1:icod)//' SIRPOW.92 runs on: '//fname(1)(1:k-1)
        endif
       endif
c
      icolor=10
      call SetColr(icolor)
c
      iys=60
      ixv(1)=100
      iyv(1)=iys
      iz=icod+lprog+k
      izv(1)=iz
      ind=9
      call graphs(ixv,iyv,iz,ind,messh,icolor)
c
      ixv(1)=10
      iz=14
      icolor=3
      call SetColr(icolor)
      do 100 i=1,ipcom
      j=icomq(i,1)
      str=allcom(j)
CHAR  str(15:15)=char(0)
      iys=iys+ivd
      iyv(1)=iys
      call graphs(ixv,iyv,iz,ind,str,icolor)
  100 continue
      iys=60
      return
      end
c-----------------------------------------------------------------------
      subroutine scr2
      character str*80
      character beg,commen,allcom(25)*14
      common /charas/ beg,commen,allcom
      common /comdir/ icomq(200,2),maxcom,ipcom,ipdir,icomat
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/screen/ kscreen,iys,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      common /buffer/ ixv(100),iyv(100),dummr(315)
      character *80 messh,messp(10),messf(10),messr(10)
      common /scmess/messh,messp,messf,messr,izv(4),ipuntp,ipuntf,ipuntr
c
      if (kscreen.eq.0) return
c
      call NewPage
c
c-- draw the Header
c
      iys=60
      icolor=10
      call SetColr(icolor)
      ixv(1)=100
      iyv(1)=iys
      iz=izv(1)
      ind=9
      call graphs(ixv,iyv,iz,ind,messh,icolor)
c
      jj=icomq(icomat,1)
      ipup=0
      ipuf=0
      ipur=0
      do 100 i=1,ipcom
      iz=14
      j=icomq(i,1)
      str=allcom(j)
      iys=iys+ivd
      iyv(1)=iys
      if (i.eq.icomat) then
                         ixv(1)=-10
                         iyss=iys
                       else
                         ixv(1)=10
                       endif
      if (i.le.icomat) then
                         icolor=10
                         call SetColr(icolor)
                         if (str(1:3).eq.'pha') then
                                        if (izv(2).gt.0) then
                                                  ipup=ipup+1
       write(str,'(a14,a)') allcom(j),messp(ipup)(1:izv(2))
                                                  iz=iz+izv(2)
                                                endif
                                                endif
                         if (str(1:3).eq.'fou') then
                                        if (izv(3).gt.0) then
                                                  ipuf=ipuf+1
       write(str,'(a14,a)') allcom(j),messf(ipuf)(1:izv(3))
                                                  iz=iz+izv(3)
                                                endif
                                                endif
                         if (str(1:3).eq.'res') then
                                        if (izv(4).gt.0) then
                                                  ipur=ipur+1
       write(str,'(a14,a)') allcom(j),messr(ipur)(1:izv(4))
c                        str=str(1:iz)//messr(ipur)(1:izv(4))
                                                  iz=iz+izv(4)
                                                endif
                                                endif
CHAR                     str(iz:iz)=char(0)
                       else
                         icolor=3
                         call SetColr(icolor)
CHAR                     str(15:15)=char(0)
                       endif
      call graphs(ixv,iyv,iz,ind,str,icolor)
  100 continue
      iys=iyss
      return
      end
c-----------------------------------------------------------------------
      subroutine scrp(itrial,maxtr,cfom,cfomx)
      character str*80
      character beg,commen,allcom(25)*14
      common /charas/ beg,commen,allcom
      common /comdir/ icomq(200,2),maxcom,ipcom,ipdir,icomat
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/screen/ kscreen,iys,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      common /buffer/ ixv(100),iyv(100),dummr(315)
      character *80 messh,messp(10),messf(10),messr(10)
      common /scmess/messh,messp,messf,messr,izv(4),ipuntp,ipuntf,ipuntr
c
      if (kscreen.eq.0) return
c
      icolor=10
      call SetColr(icolor)
c
      j=icomq(icomat,1)
      str(1:14)=allcom(j)
      if (cfomx.lt.0.0) then
                          ccfmx=0.0
                        else
                          ccfmx=cfomx
                        endif
      write(str(15:62),10) itrial,maxtr,cfom,ccfmx
   10 format(
     *'Trial ',i4,' / ',i4,'  CFom = ',f5.3,'  (max = ',f5.3,') ')    
CHAR  str(60:60)=char(0)
      ixv(1)=10
      iyv(1)=iys
      iz=62
      izv(2)=iz-14
      messp(ipuntp)=str(15:62)
      ind=9
      call graphs(ixv,iyv,iz,ind,str,icolor)
c
      return
      end
c-----------------------------------------------------------------------
      subroutine scrf(numset,jstep,jab)
c
c-- plot the content of common /atom/
c
      common/screen/ kscreen,iys,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common /buffer/ ixv(100),iyv(100),dummr(315)
      common /mess/ Message,ifMess,lMess
      character *80 Message
      character aorb*1
      character *80 messh,messp(10),messf(10),messr(10)
      common /scmess/messh,messp,messf,messr,izv(4),ipuntp,ipuntf,ipuntr
c
      if (kscreen.eq.0) return
      call molplo(jab)
      kkprog=mod(kprog,10)
      rfac=erre*100.0
      if (kkprog.eq.1) then
                        rfaco=erreo*100.0
                      else
                        rfaco=errem*100.0
                        if (rfac.lt.rfaco) rfaco=rfac
                      endif
      if (jab.eq.1) then
                      aorb='A'
                    else
                      aorb='B'
                    endif
      if (jstep.eq.1) then
                        write(Message,10) numset,jstep,aorb,rfac
                        call topl
                      else
                        if (kkprog.eq.1) then
                         write(Message,20) numset,jstep,aorb,rfac,rfaco
                        else
                         write(Message,22) numset,jstep,aorb,rfac,rfaco
                        endif
                      endif
      if (jrest.ne.0.and.krecy.eq.1) call topl
c  10 format('Step ',i2,a1,'  R =',f7.2,'%              ')
   10 format('Set #',i4,'     Cycle ',i2,'(',a1,') R =',f7.2,
     *       '%                       ')
   20 format('Set #',i4,'     Cycle ',i2,'(',a1,') R =',f7.2,
     *       '%   (previous =',f7.2,'%)')
   22 format('Set #',i4,' Cycle ',i2,'(',a1,') R =',f7.2,
     *       '%   ( minimum =',f7.2,'%)')
CHAR  Message(57:57)=char(0)
      ifMess = 1
      lMess = 61
      if (kkprog.eq.1) then
                        if (jrecyc.eq.100) then
                            rw0=rfaco
                          else
                            rw0=rfac
                          endif
                        rw1=rfac
                        rw2=rfaco
                      else
                        rw0=rfaco
                        rw1=rfaco
                        rw2=rfaco
                      endif
           if (jrest.eq.0) then
                             write(messf(ipuntf)(1:20),30)  rw0
      else if (jrest.eq.1) then
                             write(messr(ipuntr)(1:20),30)  rw1
                           else
                             write(messr(ipuntr)(1:20),30)  rw2
                           endif
   30 format(' Final R =',f7.2,'%  ')
      izv(3) = 19
      izv(4) = 19
c
      call PrintMess
c
      return
      end
c-----------------------------------------------------------------------
      subroutine scrend(line,lline)
      character str*80,line*(*)
      character beg,commen,allcom(25)*14
      character fname(9)*80,ext(9)*4
      common/dotdat/ fname,ext
      common /charas/ beg,commen,allcom
      common /comdir/ icomq(200,2),maxcom,ipcom,ipdir,icomat
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/screen/ kscreen,iys,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      common /buffer/ ixv(100),iyv(100),dummr(315)
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common /mess/ Message,ifMess,lMess
      character *80 Message
      character *80 messh,messp(10),messf(10),messr(10)
      common /scmess/messh,messp,messf,messr,izv(4),ipuntp,ipuntf,ipuntr
c
        call sirtime(str,icod)
        if (icod.gt.0) then
            Message(1:icod)=str(1:icod)
            Message(icod+1:icod+lline)=line(1:lline)
            lline=icod+lline
            line(1:lline)=Message(1:lline)
          endif
c
      if (kscreen.eq.0) return
      call NewPage
c
      icolor=12
      call SetColr(icolor)
      ind=9
c
c-- draw the Header
c
      iys=60
      ixv(1)=100
      iyv(1)=iys
      iz=izv(1)
      ind=9
      call graphs(ixv,iyv,iz,ind,messh,icolor)
c
      ixv(1)=10
      ipup=0
      ipuf=0
      ipur=0
      do 100 i=1,ipcom
      iz=14
      j=icomq(i,1)
      str=allcom(j)
      iys=iys+ivd
      iyv(1)=iys
      if (str(1:3).eq.'pha') then
                               if (izv(2).gt.0) then
                                         ipup=ipup+1
       write(str,'(a14,a)') allcom(j),messp(ipup)(1:izv(2))
                                         iz=iz+izv(2)
                                       endif
                                     endif
      if (str(1:3).eq.'fou') then
                               if (izv(3).gt.0) then
                                         ipuf=ipuf+1
       write(str,'(a14,a)') allcom(j),messf(ipuf)(1:izv(3))
                                         iz=iz+izv(3)
                                       endif
                                     endif
       if (str(1:3).eq.'res') then
                               if (izv(4).gt.0) then
                                         ipur=ipur+1
       write(str,'(a14,a)') allcom(j),messr(ipur)(1:izv(4))
                                         iz=iz+izv(4)
                                       endif
                                     endif
      if (str(1:3).eq.'end') then
                               ixv(1)=-10
                             endif
CHAR  str(iz+1:iz+1)=char(0)
      call graphs(ixv,iyv,iz,ind,str,icolor)
  100 continue
c
      icolor=12
      call SetColr(icolor)
CHAR  str(lline+1:lline+1)=char(0)
      ixv(1)=100
c     iyv(1)=kscry-ivd-7
      iys=iys+ivd
      iyv(1)=iys
      iz=lline
      ind=9
      call graphs(ixv,iyv,iz,ind,line,icolor)
      rfac = errem*100
      if (rfac.gt.0) then
                       write(Message,140) rfac
                     else
                       write(Message,150) 
                     endif
  140 format('Final R =',f7.2,'%      Quit to finish !              ')
  150 format('                       Quit to finish !              ')
CHAR  Message(80:80)=char(0)
      ixv(1)=10
      iyv(1)=10
      iz=79
      ind=15
      icolor=14
      call SetColr(icolor)
      call graphs(ixv,iyv,iz,ind,Message,icolor)
      key=-1
      call getkey(key)
      call text_mode
      return
      end
c-----------------------------------------------------------------------
      subroutine lastplot(rfac)
      common /tape/ cell(6),neqv,icent,lat,natm,ts(3,24),is(2,3,24),nsym
     *             ,dumb(3)
      common/rc/p(6),cx(9),dumm(9)
      common /const/ nex,np(3),numset,npic,nats,jall,nset,iset(20),factr
      common/screen/ kscreen,iys,ivd,kscrx,kscry,jscreen,kprog,ifMouse
      common /emap/ jrecyc,krecy,erre,erreo,nemap(4),biso,bfac(200),lsx,
     *              oscale,errem,fomin,tsigma,maxcyc,jrest
      common /emap1/ fwhm,npor(3),npror,nngr11,npar11
      character *80 Message
      common /mess/ Message,ifMess,lMess
      integer*2 ier2
c
      ier2=0
      jrest=0
      rfac=-1.0
      if (kscreen.eq.0) return
      kkprog=mod(kprog,10)
      call srlin (15,lsn,lixx,ljxx,lkxx,llxx)
      if(lixx.gt.0) then
                    do 10 i=1,6
   10               cell(i)=cx(i)
                    idisp=1
                    call sfl15(nats,idisp,numset,interp)
                    interp=1
                    jrest=0
                    call frm15(nats,numset,interp)
                    jab=3
c
c-- la seguente e' per X-Window
c
                    call zflush
c
                    rfac = errem*100.0
                    if (rfac.gt.0.1) then
                        write(Message,'(5h R = ,f5.2,1h%)') rfac
                        lMess = 11
                        ifMess = 1
                        if (kkprog.eq.2.and.npar11.ne.0) then
                            ratio=float(nngr11)/float(npar11)
                            write(Message,20) rfac,ratio
                            lMess = 43
                            ifMess = 1
                          endif
                      endif
                    call molplo(jab)
   20 format(5h R = ,f5.2,1h%,'       Groups/Parameters = ',f5.2)
c
c-- le seguenti 3 sono per Molplo(Basic)
c
*                   call text_mode
*                   call cissue('molqb31 fegas.mlp',ier2)
*                   call scr1
c
c--
c
                    call zflush
                  endif
c
      return
      end
c-----------------------------------------------------------------------
      subroutine text_mode
      character*80 string
      common /buffer/ ixv(100),iyv(100),dummr(315)
c
      ind=0
      icolor=1
      call SetColr(icolor)
      call graphs(ixv,iyv,iz,ind,string,icolor)
c
      return
      end
c-----------------------------------------------------------------------
      subroutine scrpd
      character *80 messh,messp(10),messf(10),messr(10)
      common /scmess/messh,messp,messf,messr,izv(4),ipuntp,ipuntf,ipuntr
c
      ipuntp=ipuntp+1
      do 10 i=1,80
   10 messp(ipuntp)(i:i)=' '
      return
      end
c-----------------------------------------------------------------------
      subroutine scrfd
      character *80 messh,messp(10),messf(10),messr(10)
      common /scmess/messh,messp,messf,messr,izv(4),ipuntp,ipuntf,ipuntr
c
      ipuntf=ipuntf+1
      do 10 i=1,80
   10 messf(ipuntf)(i:i)=' '
      return
      end
c-----------------------------------------------------------------------
      subroutine scrrd
      character *80 messh,messp(10),messf(10),messr(10)
      common /scmess/messh,messp,messf,messr,izv(4),ipuntp,ipuntf,ipuntr
c
      ipuntr=ipuntr+1
      do 10 i=1,80
   10 messr(ipuntr)(i:i)=' '
      return
      end
CRYSTALS CODE FOR SEMINV
c-- sir code for seminvariants                   Release 93.02
        subroutine seminv(ier)
c----------------------------------------------------------------------
c         sir -  seminvariant  routine
c----------------------------------------------------------------------
      character cff
      common /dirg/ jss1,jopt,jss2
      common /dir1/ jboth,jrepr,jeli1,jenu1,jknum,soge1,sogk
      common /dir2/ jenu2,glim,soge2,eplim,nca(2)
      common /ss2c/ ip,ku(3),eu,kva(3),ev,kn,epsu,epsv,nsem2,nsem2g
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
      common/ureq/ihx(3),ksigma,knw,jpart,jtran,ipolar,nonos,iprin,iflag
c
      common /inp/  natom,fnat,satm,dumy
      common /inv/  invma(96,3,3),idivv(48)
      common /cost/ pi2,jxa,jxb,jxx,nk1,lfl,nrif,mult,nsem,itype,ang(24)
      common /choi/ mm,iimax,jmax,nsj,jtable(8,16),invet(48)
      common /pro/  jvarma(3,3),kx(3),idoub,kkk,sump(2),icros,
     * jhkl(3),e,scr2(2),ns,sr2(2),jhimrn(3,3),nsemc,nsemg
      common/xdata/isr(100000),matse(350,3),little(350,24,3),limi(9001),
     1 idopp(1000),iel(350),phive(350),list1(1000,2),list2(1000,5),nlis,
     2 gq(8000),gv(8000),idummy(48),itab(8000),itab1(8000),isig(3,8000),
     3 lim0(9001),dummpc(34999)
      common /temp/ ifinv(100,2),hkrj(100,4,24)
      common /sig2/ gs,n8
      common/tst/nt8,ar(26),nn(11,26,3),pp(11,26,3)
      common /nctst/ nt9,br(15),nb(11,15,3),fnb(11,15,3),bcm(11,15,3),
     *                        acm(11,15,3)
      integer dmat(3,500)
      character rescha(2)*32,line(2)*8
      integer result(2,2)
      data rescha/
     *            '     one-phase seminvariants    ',
     *            '     two-phase seminvariants    '/
c
      write(cff,'(i1)') kff
      write(lo,10) cff,itle
   10 format(///,a1 ,120('+'),//,
     1 39h SIR92 : Seminvariants routine         ,68x,14hRelease  93.02
     2 ,//,20x,20a4,/,1h ,120('+'),//)
c-- read directives
      ier=0
      call dirsem(ier)
      if (ier.lt.0)  return
      call initp(ier)
      if (ier.ne.0)  return
      call histor(4,1,ier)
      if (ier.ne.0)  return
      call wrcon
      if (iprin.eq.0) go to 201
      write(lo,19) nrif,ihx
   19 format(/5x,'the number of reflexions is',i6,'   with   ',
     * 'h(max) =',i4,3x,'k(max) =',i4,3x,'l(max) =',i4)
      write(lo,20) natom
   20 format(/5x,'the number of atoms in primitive cell is ',i5)
  201 write(lo,21)
   21 format(/,' The following routines will be executed:')
      if(jss1.eq.1) write(lo,22)
   22 format(41x,'>One-phase seminvariants routine')
      if(jss2.eq.1) write(lo,24)
   24 format(41x,'>Two-phase seminvariants routine')
      if (jss1.eq.0) go to 100
      call ss1(result)
      if (nsem.eq.0) then
                       write(lo,90) 
                       return
                     endif
   90 format(//5x,'**** warning ****  no seminvariants have been estimat
     *ed . Sorry.',//)
  100 continue
      if (jss2.eq.0) go to 1000
      call ss2(dmat,result)
 1000 continue
      write(lo,1100)
 1100 format(//,120('+'),//,40x,'***   output   section   ***',//)
      write(lo,1500)
 1500 format(/,10x,31x,'number of relationships',/,
     *         10x,32x,' calculated   stored   ',/)
      do 2000 i=1,2
      do 1800 j=1,2
      if (result(i,j).eq.0) then
                              write(line(j),1600)
                            else
                              write(line(j),1700) result(i,j)
                            endif
 1600 format('       -')
 1700 format(i8)
 1800 continue
      write(lo,2100) rescha(i),(line(j),j=1,2)
 2100 format(/, 9x,a32,a8,3x,a8)
 2000 continue
      return
      end
c-----------------------------------------------------------------------
      subroutine initp(ier)
c
c---- initialization subroutine
c
      common /dirg/ jss1,jopt,jss2
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
      common/ureq/ihx(3),ksigma,knw,jpart,jtran,ipolar,nonos,iprin,iflag
c
      common /inp/  natom,fnat,satm,dumy
      common /cost/ pi2,jxa,jxb,jxx,nk1,lfl,nrif,mult,nsem,itype,ang(24)
      common/xdata/isr(100000),matse(350,3),little(350,24,3),limi(9001),
     1 idopp(1000),iel(350),phive(350),list1(1000,2),list2(1000,5),nlis,
     2 gq(8000),gv(8000),idummy(48),dummpc(84000)
c
c-- set some values
      lfl=100000
      nk1=350
      pi2=8*atan(1.0)
      do 1 i=1,24
    1 ang( i)=0.0
      ang( 3)=pi2/12
      ang( 4)=pi2/8.0
      ang( 5)=2.0*ang(3)
      ang( 7)=2.0*ang(4)
      ang( 9)=2.0*ang(5)
      ang(10)=3.0*ang(4)
      ang(11)=5.0*ang(3)
c-----------------------------------------------------------
c
c     itype =  1    any phase
c     itype =  3    phase  30,210   degree
c     itype =  4    phase  45,225   degree
c     itype =  5    phase  60,240   degree
c     itype =  7    phase  90,270   degree
c     itype =  9    phase 120,300   degree
c     itype = 10    phase 135,315   degree
c     itype = 11    phase 150,330   degree
c     itype = 13    phase   0,180   degree
c
c-----------------------------------------------------------
c
      do 2 i=1,350
      do 2 j=1,3
    2 matse(i,j)=0
c-- reading of normal file
      call inpts(ier)
      if (ier.ne.0) return
      if (jss2.ne.0) call sigma2
c-- set up reciprocal space for seminvariants
      call fillr
      return
      end
c-----------------------------------------------------------------------
      subroutine inpts(ier)
c---- reading of normal file
      common /dirg/ jss1,jopt,jss2
      common /dir1/ jboth,jrepr,jeli1,jenu1,jknum,soge1,sogk
      common /dir2/ jenu2,glim,soge2,eplim,nca(2)
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/impl/jdir,kform,jfile,jout,nlen,knwr,kenvir,kstory(99),kff
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
      common/sym /jdummy(216),jssn,kdu1,kdu2,jssi,kdu3,ssss,ssssm,ssssp
      common/ureq/ihx(3),ksigma,knw,jpart,jtran,ipolar,nonos,iprin,iflag
c
      common /inp/  natom,fnat,satm,dumy
      common /inv/  invma(96,3,3),idivv(48)
      common /cost/ pi2,jxa,jxb,jxx,nk1,lfl,nrif,mult,nsem,itype,ang(24)
      common /choi/ mm,iimax,jmax,nsj,jtable(8,16),invet(48)
      common /pro/  jvarma(3,3),kx(3),idoub,kkk,sump(2),icros,
     * jhkl(3),e,scr2(2),ns,sr2(2),jhimrn(3,3),nsemc,nsemg
      common/xdata/isr(100000),matse(350,3),little(350,24,3),limi(9001),
     1 idopp(1000),iel(350),phive(350),list1(1000,2),list2(1000,5),nlis,
     2 gq(8000),gv(8000),idummy(48),dummpc(84000)
      integer hkl(3)
      dimension ivet(12),vet(12)
      equivalence (vet(1),ivet(1))
c
      nsem=0
      nlis=0
      iphiv=0
c -----
c     call  sub.  per  lettura  lista  2  :  simmetria
c -----
      call yfl02
c -----
c     call  sub.  per  lettura  preambolo  lista  7
c -----
      call ysfl07(nrif,nstron,nweak,npseud,iy)
      s3s2=ssss
      nsym=jssn
      icc =jssi
      if(npseud.eq.0) go to 20
      write(lo,15)
   15 format(//5x,'**** warning ****  no seminvariants are estimated whe
     *n sir handles pseudotranslations',/)
      ier = 1
      return
   20 continue
c---- check if the space group is ' p 1 '
      icent=icc+1
      msym=nsym*icent
      nsym2=(3-icent)*msym
      if (msym.eq.1) then
                     write(lo,1040)
 1040 format(//5x,'**** warning ****  no seminvariants are estimated whe
     *n the space group is p 1',/)
                     ier = 1
                     return
                     endif
      fnat=(1.0/s3s2)**2.0
      natom=int(fnat+0.05)
      satm=sqrt(fnat)
      do 1050 k=1,nsym
      do 1050 i=1,3
      do 1050 j=1,3
 1050 ksmat(k+nsym,i,j)=-ksmat(k,i,j)
      do 1060 k=1,nsym
      do 1060 i=1,3
 1060 tmat(k+nsym,i)=-tmat(k,i)
c---- compute the number of free vectors used in the 2nd representation
      knum=natom/msym+40
      if (knum.gt.100) knum=100
      if (jenu1.eq.0.and.soge1.eq.0.0) jenu1=nstron
      if (jknum.ne.0.and.jknum.gt.100)jknum=100
      jxa=(2*ihx(2)+1)*(2*ihx(3)+1)
      jxb=2*ihx(3)+1
      jxx=jxa*ihx(1)+jxb*ihx(2)+ihx(3)
      if (jxx.le.lfl) go to 90
      write(lo,1300) ihx,jxa,jxb,jxx,lfl
 1300 format(1x,'maximum value for   h k l   = ',3i5,
     *//,1x,'costants value to compute the addres=',2i8,//
     *  ,1x,'value for the maximum addres   =',i10,
     *//,1x,'maximum allowed value  = ',i6,
     *//,1x,'change the dimension of isr vector',
     *   1x,'and the corrispondent value of lfl',
     *//,1x,'seminvariants cannot be estimated.')
      ier=1
      return
   90 continue
c-- calculation of inverse matricies
      call invers
c-- calculation of generalized inverse matricies
      call geninv
c-- set up the working table
      call choice
c-- set up multiplication matrix
      call mltply(ksmat,nsym2,irot)
c---- reads in reflections from normal file
      if (jeli1.eq.1) write(lo,905)
  905 format(///,22x,'list of reflection to search seminvariant',/,
     1           22x,'-----------------------------------------',//)
      irec=0
      ifin=1000
c -----
c     call  sub.  per  lettura  lista  7  :  riflessi ordinati
c -----
      do 800 i=1,nrif
      call snr07(vet)
      hkl(1)=ivet(1)
      hkl(2)=ivet(2)
      hkl(3)=ivet(3)
      e=vet(4)
      if(e.eq.0.0) e=0.01
      if(e.eq.1.0) e=0.999
      iphi8=mod(ivet(8),2**15)
      iphi=iphi8/32
      itype=mod(iphi8,32)
c-- store reflexion in list1 (only if first rank seminvariant)
      nmat=0
      if (jss2.eq.0) ifin=nsem
      if (nlis.lt.ifin) call fillis(hkl,i,nmat,iphi)
      if (irec.eq.1) go to 1085
      if (i.gt.nk1) irec=1
      if (irec.eq.1) go to 1085
      if (iphi.ge.360) iphi=iphi-360
      if (knw.eq.0) iphi=360
      if (jenu1.eq.0.and.e.ge.soge1) jlim =i
      if (jenu1.ne.0.and.i.eq.jenu1) soge1=e
      if(jeli1.eq.0.or.e.lt.soge1) go to 180
      kmod=mod(i,3)
      if (kmod.eq.1) write(lo,910) i,hkl,e,iphi,itype
  910 format(1h ,i5,1h),2x,3i4,f8.3,i5,i3)
      if (kmod.eq.2) write(lo,920) i,hkl,e,iphi,itype
  920 format(1h+,40x,i5,1h),2x,3i4,f8.3,i5,i3)
      if (kmod.eq.0) write(lo,930) i,hkl,e,iphi,itype
  930 format(1h+,80x,i5,1h),2x,3i4,f8.3,i5,i3)
      if(e.eq.soge1) jeli1=0
  180 if(e.lt.soge1) goto 1085
c---- if reflection is a seminvariant we compute the threshold
      if (nmat.eq.0) goto 1085
      nsem=nsem+1
      matse(nsem,1)=i
      matse(nsem,2)=i
      sop1=e
 1085 call fill(hkl,e,itype,iphi,i,irec)
  800 continue
      if (jeli1.eq.1) write(lo,940)
  940 format(//)
      if (jknum.eq.0) jknum=knum
      if (jenu1.eq.0) jenu1=jlim
      if (jknum.le.0) go to 9000
      if (jenu1.eq.0) soge1=sop1
      if (jenu1.gt.nk1) jenu1=nk1
      if (jenu1.le.nk1) soge1=abs(float(iel(jenu1)))/1000.0
      if (sogk.ne.0.0) go to 899
      sogk=iel(jknum)
      sogk=abs(sogk)/1000.0
  899 continue
 9000 continue
      if(iprin.ne.0) write(lo,9010) nlis,nsem
 9010 format('  number of first rank seminvariants recognized  =',i5,
     *     /,'  number of first rank seminvariants to estimate =',i5)
      return
      end
c----------------------------------------------------------------------
      subroutine invers
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
c
      common /choi/ mm,iimax,jmax,nsj,jtable(8,16),invet(48)
      integer v(3,3)
c
      invet(1)=1
      do 30 i=2,msym
      call invs(i,v)
      do 20 j=1,msym
      do  10 k=1,3
      do  10 l=1,3
      if (ksmat(j,k,l).ne.v(k,l)) go to 20
   10 continue
      invet(i)=j
      go to 30
   20 continue
   30 continue
      return
      end
c---------------------------------------------------------------------
      subroutine invs(j,v)
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
c
      integer v(3,3),a(3,3)
c
      do 1 i1=1,3
      do 1 j1=1,3
    1 a(i1,j1)=ksmat(j,i1,j1)
c
c---- calcola v, la inversa di a
c
      call inv3(a,idet,v)
      if (idet.eq.0) then
                       write(lo,100) j
                       write(lo,*) '****  programming  error  ****'
                       write(lo,*) ' sir ends in error'
                       stop 1234
                      endif
  100 format(1x,'error computing invers no.',i2,' - det.=0  ')
      return
      end
c----------------------------------------------------------------------
      subroutine inv3(a,det,v)
c
c---- calcola l'inversa della matrice a e la
c---- memorizza in v.
c---- a deve essere una matrice  3*3 non-singolare
c---- alfa e' la matrice aggiunta
c
      integer a(3,3),v(3,3),det,alfa(3,3)
c
      alfa(1,1)=a(2,2)*a(3,3)-a(2,3)*a(3,2)
      alfa(1,2)=-1*(a(2,1)*a(3,3)-a(2,3)*a(3,1))
      alfa(1,3)=a(2,1)*a(3,2)-a(2,2)*a(3,1)
      alfa(2,1)=-1*(a(1,2)*a(3,3)-a(1,3)*a(3,2))
      alfa(2,2)=a(1,1)*a(3,3)-a(1,3)*a(3,1)
      alfa(2,3)=-1*(a(1,1)*a(3,2)-a(1,2)*a(3,1))
      alfa(3,1)=a(1,2)*a(2,3)-a(1,3)*a(2,2)
      alfa(3,2)=-1*(a(1,1)*a(2,3)-a(1,3)*a(2,1))
      alfa(3,3)=a(1,1)*a(2,2)-a(1,2)*a(2,1)
      det=a(1,1)*alfa(1,1)+a(1,2)*alfa(1,2)+a(1,3)*alfa(1,3)
      if (det.ne.0) goto 200
      do  5 i=1,3
   5  write(6,6) (a(i,j),j=1,3)
      do 66 i=1,3
  66  write(6,6) (alfa(i,j),j=1,3)
   6  format(5x,3i8)
 200  do 10 i=1,3
      do 10 j=1,3
   10 v(i,j)=alfa(j,i)/det
      return
      end
c-----------------------------------------------------------------------
      subroutine geninv
c
c-- calcola le generalizzate inverse
c-- memorizzandole in 'invma' ed in 'idivv'
c
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
c
      common /inv/  invma(96,3,3),idivv(48)
      integer a(3,3),v(3,3),va(3,3)
c
      lo=6
      do 50 k=1,nsym2
c
c---- calcola la inversa generalizzata   v  della matrice  a
c---- dove  a  e' uguale alla matrice unita' meno la
c---- trasposta della k-esima matrice di rotazione
c
      if (k.eq.1) go to 50
      do 20 i=1,3
      do 10 j=1,3
   10 a(i,j)=-ksmat(k,j,i)
      a(i,i)=1+a(i,i)
   20 continue
      call g12sp(a,v,idiv)
c
c---- calcola  va = v * a
c
      do 30 i=1,3
      do 30 j=1,3
      va(i,j)=0
      do 30 l=1,3
   30 va(i,j)=va(i,j)+v(i,l)*a(l,j)
c
c---- memorizza  v  ed  va  in invma
c
      do 40 i=1,3
      do 40 j=1,3
      invma(k+48,i,j)=va(i,j)
   40 invma(k   ,i,j)= v(i,j)
      idivv(k)=idiv
c
   50 continue
      return
      end
c-----------------------------------------------------------------------
      subroutine g12sp(a,v,idiv)
      integer s(3,3),com(3,3),v(3,3),hold(3,3)
      integer a(3,3),p(3,3),q(3,3)
      do 2 i=1,3
      do 1 j=1,3
      p(i,j)=0
      q(i,j)=0
      s(i,j)=0
    1 hold(i,j)=a(i,j)
      p(i,i)=1
    2 q(i,i)=1
      do 14 ir=1,3
      irr=ir
c
c---- trova il minimo elemento diverso da zero
c
      ip=0
      jp=0
      imin=999
      do 3 i=ir,3
      do 3 j=ir,3
      int=iabs(hold(i,j))
      if (int.eq.0.or.int.ge.imin) go to 3
      imin=int
      ip=i
      jp=j
    3 continue
      if (ir-ip) 4,5,5
c
c---- scambia le righe
c
    4 call rowop(hold,ip,ir,ih,p,1)
    5 if (ir-jp) 6,7,7
c
c---- scambia le colonne
c
    6 call colop(hold,jp,ir,ih,q,1)
    7 iflo=hold(ir,ir)
      if (iflo.eq.0) go to 14
c
c---- azzera la colonna
c
      ip=ir+1
      if (ip-3) 8,8,10
    8 continue
      do 9 i=ip,3
      if (hold(i,ir).eq.0) go to 9
      ih=-1*hold(i,ir)/iflo
      call rowop(hold,i,ir,ih,p,2)
    9 continue
c
c---- azzera la riga
c
   10 jp=ir+1
      if (jp-3) 11,11,13
   11 continue
      do 12 j=jp,3
      if (hold(ir,j).eq.0) go to 12
      ih=-1*hold(ir,j)/iflo
      call colop(hold,j,ir,ih,q,2)
   12 continue
   13 continue
   14 continue
      ir=irr
      ia=hold(irr,irr)
      if (ia) 100,110,100
  100 irr1=irr-1
      ib=hold(irr1,irr1)
      iflo=mod(ia,ib)
      if (iflo) 105,110,105
  105 call colop(hold,irr,irr,ib,q,2)
  110 continue
   22 idiv=hold(ir,ir)
      if (idiv) 21,20,21
   20 ir=ir-1
      if (ir) 22,23,22
   21 continue
      i=ir
   15 i=i-1
      if (i) 16,17,16
   16 s(i,i)=idiv/hold(i,i)
      go to 15
   17 s(ir,ir)=1
      do 18 i=1,3
      do 18 j=1,3
      com(i,j)=0
      do 18 l=1,3
   18 com(i,j)=com(i,j)+q(i,l)*s(l,j)
      do 19 i=1,3
      do 19 j=1,3
      v(i,j)=0
      do 19 l=1,3
   19 v(i,j)=v(i,j)+com(i,l)*p(l,j)
   23 continue
      return
      end
c-----------------------------------------------------------------------
      subroutine colop(a,il,ir,ii,q,ind)
      integer a(3,3),q(3,3),r(3,3),com(3,3),temp(3,3)
      do 1 i=1,3
      do 1 j=1,3
    1 r(i,j)=0
      if (ind-1) 2,2,3
    2 i=6-1*(il+ir)
      r(i,i)=1
      r(il,ir)=1
      r(ir,il)=1
      go to 5
    3 do 4 i=1,3
    4 r(i,i)=1
      r(ir,il)=ii
    5 continue
      do 6 i=1,3
      do 6 j=1,3
      com(i,j)=0
      temp(i,j)=0
      do 6 l=1,3
      temp(i,j)=temp(i,j)+q(i,l)*r(l,j)
    6 com(i,j)=com(i,j)+a(i,l)*r(l,j)
      do 7 i=1,3
      do 7 j=1,3
      q(i,j)=temp(i,j)
    7 a(i,j)=com(i,j)
      return
      end
c-----------------------------------------------------------------------
      subroutine rowop(a,il,ir,ii,p,ind)
      integer a(3,3),p(3,3),r(3,3),com(3,3),temp(3,3)
      do 1 i=1,3
      do 1 j=1,3
    1 r(i,j)=0
      if (ind-1) 2,2,3
    2 i=6-1*(ir+il)
      r(i,i)=1
      r(il,ir)=1
      r(ir,il)=1
      go to 5
    3 do 4 i=1,3
    4 r(i,i)=1
      r(il,ir)=ii
    5 continue
      do 6 i=1,3
      do 6 j=1,3
      com(i,j)=0
      temp(i,j)=0
      do 6 l=1,3
      temp(i,j)=temp(i,j)+r(i,l)*p(l,j)
    6 com(i,j)=com(i,j)+r(i,l)*a(l,j)
      do 7 i=1,3
      do 7 j=1,3
      p(i,j)=temp(i,j)
    7 a(i,j)=com(i,j)
      return
      end
c-----------------------------------------------------------------------
      subroutine choice
c
c-- calcola la 'working table' memorizzandola in 'jtable'
c
      common /dirg/ jss1,jopt,jss2
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
      common/ureq/ihx(3),ksigma,knw,jpart,jtran,ipolar,nonos,iprin,iflag
c
      common /inv/  invma(96,3,3),idivv(48)
      common /choi/ mm,iimax,jmax,nsj,jtable(8,16),invet(48)
      integer v(3,3),vscar(48),mscar(48,3),jrot(48,48)
      data vscar/48*-1/
      data mscar/144*-1/
c
      do 5 i=1,48
      do 5 j=1,48
    5 jrot(i,j)=0
      maxi=1
      ima=1
      jmax=0
      if (ngen.eq.1.and.iprin.gt.2) write(lo,3000)
      if (icent.eq.1.and.iprin.gt.2) write(lo,9002)
      if (icent.eq.2.and.iprin.gt.2) write(lo,9000)
c
c---- elimina la matrice unita'
c
      do 10 i=2,msym
      vscar(i)=i
      mscar(i,1)=i
   10 continue
      if (iprin.gt.2) write(lo,113)
      vscar(1)=-1
c
c---- stiamo trattando un gruppo spaziale fino all'ortorombico ?
c
      if (jsys.le.3) go to 500
c
c---- poiche' e' un gruppo spaziale con simmetria superiore
c---- all'ortorombico ci chiediamo se e' abeliano
c
      if (ngen.eq.1) go to 700
c
c---- non essendo abeliano isoliamo la matrice  -i (se esiste)
c---- memorizzando la sua posizione (*-1) in  nsy
c
      if (icent.eq.1) go to 61
      nsy=msym/2+1
      if (iprin.gt.2) write(lo,9001) nsy
      vscar(nsy)=0
      nsy=-nsy
   61 continue
c
c---- eliminiamo le matrici inverse e le matrici  rj (?)
c----
c----              -1
c----             rj * ri * rj     (k=j+1,m)
c----
      m1m=msym-1
      do 99 i=2,msym
      iflag=0
      do 100 j=2,msym
      if (i.eq.j) go to 100
      iflag=0
c
c---- controlla che la matrice   ri  sia
c---- diversa dalla inversa di  rj .
c
      call invs(j,v)
      do  97 k=1,3
      do  97 l=1,3
      if (ksmat(i,k,l).ne.v(k,l)) iflag=1
   97 continue
      if (iflag.ne.0) go to 100
      mscar(i,2)=j
      if (iprin.gt.2) write(lo,112) j,i
      go to 99
  100 continue
   99 continue
      do 854 i=2,msym
      do 853 j=2  ,msym
      if (i.eq.j) go to 853
      call invs(j,v)
c
c---- elimina le matrici equivalenti
c
      call prodm(i,j,v)
      j1p=j+1
      do 852 jj=2  ,msym
      if (jj.eq.i.or.jj.eq.j) go to 852
      do 851 k=1,3
      do 851 l=1,3
      if (ksmat(jj,k,l).ne.v(k,l)) go to 852
  851 continue
      if (iprin.gt.2) write(lo,204) jj,i,j
      jrot(j,jj)=i
  852 continue
  853 continue
  854 continue
      do 860 j=2,msym
      jrot(1,j)=j
  860 continue
      do 855 j=2,msym
      do 856 i=1,msym
      jj=jrot(i,j)
      if (jj.eq.0) go to 856
      if (jj.eq.j) go to 856
      iflag=0
      jrot(1,jj)=0
      do 857 k=2,msym
      if (jrot(k,jj).eq.0) go to 857
      iflag=1
      jrot(k,jj)=0
  857 continue
      if (iflag.eq.0) jrot(i,j)=0
  856 continue
  855 continue
      jmax=0
      ima =0
      do 861 j=2,msym
      iflag=0
      do 862 i=1,msym
      jj=jrot(i,j)
      if (jj.eq.0) go to 862
      if (mscar(jj,1).eq.0) go to 862
      if (iflag.eq.1) go to 863
      iflag=1
      jmax=jmax+1
      ima =0
  863 continue
      ima=ima+1
      if (ima.gt.maxi) maxi=ima
      jtable(ima,jmax)=jj
      jj=mscar(jj,2)
      if (jj.lt.0) go to 862
      mscar(jj,1)=0
  862 continue
  861 continue
      go to 600
  700 continue
c
c---- essendo un gruppo abeliano deve solo eliminare le inverse
c
      if (iprin.gt.2) write(lo,4000)
      m1m=msym-1
      do 50 i=1,m1m
      if (vscar(i).le.0) go to 50
      iflag=0
      i1p=i+1
      do 45 j=i1p,msym
      if (vscar(j).le.0) go to 45
      call invs(j,v)
      do 40 k=1,3
      do 40 l=1,3
      if (ksmat(i,k,l).ne.v(k,l)) iflag=1
   40 continue
      if (iflag.eq.0) go to 44
      iflag=0
      go to 45
   44 continue
      vscar(j)=0
      if (iprin.gt.2) write(lo,112) j,i
      go to 50
   45 continue
   50 continue
  500 continue
      do 505 i=1,msym
      if (vscar(i).le.0) go to 505
      jmax=jmax+1
      jtable(1,jmax)=vscar(i)
  505 continue
      go to 605
  600 continue
      if (icent.eq.1) go to 605
      if (ngen.gt.1.and.jsys.gt.3) go to 605
      jmax=jmax+1
      jtable(1,jmax)=iabs(nsy)
      nsy=0
  605 continue
      mm=jmax
      if (iprin.lt.2) go to 225
      write(lo,221)
      do 222 i=1,maxi
  222 write(lo,223) (jtable(i,jj),jj=1,jmax)
      write(lo,224)
      write(lo,9004) mm
  225 continue
      if (nsy.lt.0) nsy=0
c &&&&&&&&&&&&&&&&&&&&&&&
c &&&&&&&&&   questa istruzione serve ad evitare l'errore
c &&&&&&&&&   in compilazione - il 2000 non e' riferito
c &&&&&&&&&&&&&&&&&&&&&&&
      ihdgtd=0
      if(ihdgtd.eq.2323) goto 2000
      go to 9900
 2000 continue
      mm=-1
 9900 continue
      iimax=maxi
      ns=nsy
      return
  221 format(///,  5x,'  kk     w o r k i n g     t a b l e',/,
     *           5x,'==kk===========================================',/
     *            ,5x,'  kk')
  223 format(5x,'  kk     ',16i3)
  224 format(5x,'  kk',
     *     /,5x,    '==kk===========================================',/
     *        ,5x,'  kk',//)
  204 format(1x,'matrix # ',i2,' has been eliminated being equivalent to
     * matrix # ',i2,'  j=',i2)
  112 format(1x,'matrix # ',i2,' has been eliminated being the inverse o
     *f matrix # ',i2)
  113 format(1x,'matrix # 1 has been eliminated being the unitary one')
 3000 format(1x,'this is an abelian space group      ')
 4000 format(1x,'space group above orthorombic')
 9000 format(1x,'centrosimmetric space group')
 9002 format(1x,'non-centrosimmetric space group')
 9001 format(1x,'matrix number ',i2,'  is equal to  -i   ')
 9004 format(1x,'..... therefore we get ',i2,' different classes',//)
      end
c-----------------------------------------------------------------------
      subroutine prodm(ind1,ind2,v)
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
c
      integer v(3,3),com1(3,3),com2(3,3)
c
      do 1 i=1,3
      do 1 j=1,3
      com1(i,j)=0
      do 1 l=1,3
    1 com1(i,j)=com1(i,j)+v(i,l)*ksmat(ind1,l,j)
      do 2 i=1,3
      do 2 j=1,3
      com2(i,j)=0
      do 2 l=1,3
    2 com2(i,j)=com2(i,j)+com1(i,l)*ksmat(ind2,l,j)
      do 3 i=1,3
      do 3 j=1,3
    3 v(i,j)=com2(i,j)
      return
      end
c---------------------------------------------------------------------
      subroutine mltply(ksmat,nsym2,irot)
c
c-- set up 'irot', the multiplication matrix
c
      dimension ksmat(48,3,3),iv(3,3),irot(48,48)
c
      do 30 i=1,nsym2
      do 30 j=1,nsym2
      call prod1(ksmat,i,j,iv)
      do 20 n=1,nsym2
      do 10 k=1,3
      do 10 l=1,3
      if (ksmat(n,k,l).ne.iv(k,l)) go to 20
   10 continue
      irot(i,j)=n
      go to 30
   20 continue
   30 continue
      return
      end
c-----------------------------------------------------------------------
      subroutine prod1(ksmat,i1,i2,iv)
      dimension iv(3,3),ksmat(48,3,3)
c
      do 10 i=1,3
      do 10 j=1,3
      iv(i,j)=0
      do 10 k=1,3
   10 iv(i,j)=iv(i,j)+ksmat(i1,i,k)*ksmat(i2,k,j)
      return
      end
c----------------------------------------------------------------------
      subroutine fillis(hkl,nord,nmat,iphi)
c-- store reflexions in list1 & list2 (only if first rank seminvariant)
      common /dirg/ jss1,jopt,jss2
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
      common/ureq/ihx(3),ksigma,knw,jpart,jtran,ipolar,nonos,iprin,iflag
c
      common /inv/  invma(96,3,3),idivv(48)
      common /cost/ pi2,jxa,jxb,jxx,nk1,lfl,nrif,mult,nsem,itype,ang(24)
      common /choi/ mm,iimax,jmax,nsj,jtable(8,16),invet(48)
      common /pro/  jvarma(3,3),kx(3),idoub,kkk,sump(2),icros,
     * jhkl(3),e,scr2(2),ns,sr2(2),jhimrn(3,3),nsemc,nsemg
      common/xdata/isr(100000),matse(350,3),little(350,24,3),limi(9001),
     1 idopp(1000),iel(350),phive(350),list1(1000,2),list2(1000,5),nlis,
     2 gq(8000),gv(8000),idummy(48),dummpc(84000)
      integer hkl(3),imat(5)
      integer balfa(3),h(3,3),congr(16)
      dimension blv(3),sign(3),alf(3)
c  
cdjw99      k=modulo(hkl)
      k=modulx(hkl)
cdjw99      if (modulo(hkl).ne.0) return
      if (modulx(hkl).ne.0) return
      do 10 i=1,3
   10 jhkl(i)=hkl(i)
c---- by means of the working table ( jtable ) consider only
c---- indipendent symmetry operators.
      do 70 j=1,jmax
      do 60 i=1,iimax
      kkk=jtable(i,j)
      if (kkk.eq.0) go to 60
c---- compute the matrix  h = ( i - rs )  where  s = jtable(i,j)
      do 40 i1=1,3
      do 30 j1=1,3
   30 h(i1,j1)=-ksmat(kkk,j1,i1)
   40 h(i1,i1)=h(i1,i1)+1
c---- compute the first rank seminvariant vector
c---- by means of 'cong4' (for print only).
      if (iprin.gt.2) call cong4(ksmat,msym,kkk,congr)
c---- compute the solutions of the diophantine system
c---- if idiof = 1  we do not get integer solutions.
      call diof(h,idiof,balfa,sign,alf,blv)
      if (idiof.ne.0) go to 60
      if (iprin.gt.2.and.nord.le.nk1) write(lo,50) nord,jhkl,kkk,congr
     *, balfa
     1, (kx(i1),i1=1,3)
     2, (sign(i1),alf(i1),blv(i1),i1=1,3),nlis
   50 format(1h ,i3,1h),3i4,3h - ,
     *           'mat. ',i2,2x,10a1,' congruent to 0 mod. (',6a1,
     *  2x,'h = (',2(i3,1h,),i3,1h),
     1  2x,6h x = (,i3,2(1h,,i3),1h),
     2  2x,' + (',3a1,2(1h,,3a1),1h),i5)
      nmat=nmat+1
      if (nmat.le.5) go to 55
      write(lo,1100) jhkl,nord,(imat(i1),i1=1,5)
 1100 format(' seminvariant ',3i4,'  code = ',i4,' uses more than 5 matr
     *ices. (',i3,4(',',i3),' ). they are enough.')
      nmat=5
      go to 75
   55 imat(nmat)=kkk
   60 continue
   70 continue
   75 continue
      if (nmat.eq.0) return
c---- reflection jhkl is a first rank seminvariant
c---- we store in list1 all the information concerned
c---- with this seminvariant
      nlis=nlis+1
      j=0
      do 80 i=1,nmat
   80 j=j+imat(i)*64**(i-1)
      list1(nlis,1)=nord*10+nmat
      list1(nlis,2)=j
      do 90 i=1,3
   90 list2(nlis,i)=hkl(i)
      list2(nlis,4)=int(e*1000.0)
      list2(nlis,5)=itype*1000+iphi
      return
      end
c-----------------------------------------------------------------------
      subroutine cong4(ksmat,m,k,congr)
      dimension ksmat(48,3,3)
      integer sb(3,3),sum(3),syco,congr(16)
c
      do 10 i=1,3
      do 10 j=1,3
   10 sb(i,j)=ksmat(k,i,j)+1
      do 20 i=1,3
      sum(i)=0
      do 20 j=1,3
   20 sum(i)=sum(i)+sb(i,j)*4**(3-j)
      syco=0
      do 30 i=1,3
   30 syco=syco+sum(i)*10**(3-i)
      if (syco.eq.3972) return
      call cong5(syco,congr)
      return
      end
c-----------------------------------------------------------------------
      subroutine cong5(syco,congr)
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      dimension cong1(13)
      integer alpha(10),syvet(2,63),congr(16),cong2(21)
      integer syco,pick1,pick2,blank,opar,cpar,comma
c
      data syvet/2092,0316,0692,0104,2572,0316,2570,0317,2090,0317,
     *           3970,0103,0690,0107,3890,0105,1770,0315,0770,0106,
     *           0772,0101,2892,0214,2890,0215,3892,0102,2052,0318,
     *           0972,0318,2610,0108,3690,0108,4050,0515,1170,0415,
     *           3490,0111,0610,0110,1172,0414,1772,0314,4052,0514,
     *           3492,0112,0612,0113,3692,0109,2612,0109,0970,0319,
     *           2050,0319,2595,1020,2757,1020,2267,1120,2075,1220,
     *           1937,1120,2387,1320,2705,1320,2395,1021,2737,1021,
     *           2587,1021,1925,1220,2725,1021,2275,1021,1957,1021,
     *           1905,1021,2067,1021,2287,0616,3925,0815,3937,0815,
     *           2455,0716,2407,0715,0745,0916,0717,0816,2487,0714,
     *           3945,0914,3917,0814,2255,0614,2207,0617,0725,0817,
     *           0737,0817,2175,0615,2375,0617/
      data cong1/5475760.0,5485760.0,5495760.0,6482576.0,6248576.0,
     *           5496750.0,5486750.0,5475960.0,5475860.0,5485860.0,
     *           5495860.0,5495960.0,5485960.0/
      data cong2/3200,3020,3002,3220,3022,3202,3222,
     *           3112,3110,3102,3012,3010,3100,2000,
     *           2020,2200,2220,2300,2320,1000,1200/
      data alpha/1h0,1h1,1h2,1h3,1hh,1hk,1hl,1h,,1h+,1h-/
      data blank,opar,cpar,comma/1h ,1h(,1h),1h,/
      ifin=63
      do 5 i=1,16
      congr(i)=blank
    5 continue
      do 10 i=1,ifin
      if (syco.eq.syvet(1,i)) go to 20
   10 continue
      write(lo,50) syco
      return
   20 continue
      ind=i
      pick1=syvet(2,ind)/100
      pick2=syvet(2,ind)-pick1*100
      comp=cong1(pick1)
      div=1000000.0
      congr(1)=opar
      ind4=1
      ind2=int(comp/div)
      comp=comp-(ind2)*div
      div=div/10.0
      do 30 i=1,ind2
      ind3=int(comp/div)+1
      rmen=(ind3-1)*div
      comp=comp-rmen
      div=div/10.0
      ind4=ind4+1
      congr(ind4)=alpha(ind3)
   30 continue
      ind4=ind4+1
      congr(ind4)=cpar
      ind4=10
      comp=cong2(pick2)
      div=1000.0
      ind2=int(comp/div)
      comp=comp-ind2*div
      div=div/10.0
      do 40 i=1,ind2
      ind3=int(comp/div)+1
      comp=comp-(ind3-1)*div
      div=div/10.0
      ind4=ind4+1
      congr(ind4)=alpha(ind3)
      ind4=ind4+1
      congr(ind4)=comma
   40 continue
      congr(ind4)=cpar
      return
   50 format(//,120('#'),/,1x,
     *'error in the subroutine cong5 - syco =',i8,/,120('#'),//)
      end
c----------------------------------------------------------------------
      subroutine diof(hmat,idiof,balfa,sign,alf,blv)
      common /dirg/ jss1,jopt,jss2
      common /dir1/ jboth,jrepr,jeli1,jenu1,jknum,soge1,sogk
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
      common/ureq/ihx(3),ksigma,knw,jpart,jtran,ipolar,nonos,iprin,iflag
c
      common /inp/  natom,fnat,satm,dumy
      common /inv/  invma(96,3,3),idivv(48)
      common /cost/ pi2,jxa,jxb,jxx,nk1,lfl,nrif,mult,nsem,itype,ang(24)
      common /choi/ mm,iimax,jmax,nsj,jtable(8,16),invet(48)
      common /pro/  jvarma(3,3),kx(3),idoub,kkk,sump(2),icros,
     * jhkl(3),e,scr2(2),ns,sr2(2),jhimrn(3,3),nsemc,nsemg
      common/xdata/isr(100000),matse(350,3),little(350,24,3),limi(9001),
     1 idopp(1000),iel(350),phive(350),list1(1000,2),list2(1000,5),nlis,
     2 gq(8000),gv(8000),idummy(48),dummpc(84000)
      integer a(3,3),av(3,3),va(3,3)
      integer hmat(3,3),balfa(3)
      dimension y(3),blv(3),sign(3),coef(2),alf(3)
      integer v(3,3),b(3)
c
      data zero,rminus,bl,y,coef/1h0,1h-,1h ,1hh,1hk,1hl,1h2,1h3/
      idiof=0
      do 2 i=1,3
      b(i)=jhkl(i)
      alf(i)=bl
      balfa(i)=b(i)
      do 2 j=1,3
    2 a(i,j)=hmat(i,j)
c
c---- carica v, la (1-2) inversa di a ed  va = v * a
c
      do 3 i=1,3
      do 3 j=1,3
      va(i,j)=invma(kkk+48,i,j)
    3 v(i,j) =invma(kkk   ,i,j)
      idiv=idivv(kkk)
c
c---- calcola av = a * v
c
      do 7 i=1,3
      do 7 j=1,3
      av(i,j)=0
      do 7 l=1,3
    7 av(i,j)=av(i,j)+a(i,l)*v(l,j)
c
c---- controlla che  av * b  e' intero
c
      do 8 i=1,3
      kx(i)=0
      do 9 j=1,3
    9 kx(i)=kx(i)+av(i,j)*b(j)
      if (mod(kx(i),idiv)) 12,11,12
   11 kx(i)=kx(i)/idiv
      if (kx(i)-b(i)) 12,8,12
    8 continue
c
c---- divide  va  per il divisore
c
      do 10 i=1,3
      do 10 j=1,3
      if (mod(va(i,j),idiv)) 12,10,12
   10 va(i,j)=va(i,j)/idiv
c
c---- controlla che  v * b  e' intero
c
      do 20 i=1,3
      kx(i)=0
      do 21 j=1,3
   21 kx(i)=kx(i)+v(i,j)*b(j)
      if (mod(kx(i),idiv))12,22,12
   22 kx(i)=kx(i)/idiv
   20 continue
c
c---- calcola  va = ( i - va )
c
      do 25 i=1,3
      do 24 j=1,3
   24 va(i,j)=-1*va(i,j)
   25 va(i,i)=va(i,i)+1
c
c---- calcola la soluzione
c
      do 39 i=1,3
      ik=0
      isum=0
      do 37 j=1,3
      if (va(i,j).eq.0) go to 37
      isum=va(i,j)
      ik=j
   37 continue
      sign(i)=bl
      blv(i)=zero
      if (isum.eq.0) go to 39
      blv(i)=y(ik)
      if (isum.lt.0) sign(i)=rminus
      isum=iabs(isum)
      if (isum.eq.2) alf(i)=coef(1)
      if (isum.eq.3) alf(i)=coef(2)
   39 continue
      go to 40
   12 continue
      idiof=1
   40 continue
      do 50 i=1,3
      do 50 j=1,3
   50 jvarma(i,j)=va(i,j)
      return
      end
c-----------------------------------------------------------------------
      subroutine fill(hkl,e,itype,iphi,i,irec)
c---- fill work arrays
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
c
      common/xdata/isr(100000),matse(350,3),little(350,24,3),limi(9001),
     1 idopp(1000),iel(350),phive(350),list1(1000,2),list2(1000,5),nlis,
     2 gq(8000),gv(8000),idummy(48),dummpc(84000)
      integer hkl(3),jhkl(3),e1000
c
      e1000=e*1000
      iadd=0
      do 500 j=1,nsym
      call equiv(hkl,jhkl,j,ind)
      if(irec.ne.0) goto 450
c---- expands  reflections  into  'little'
      if (iadd.eq.0) go to 300
      do 200 jj=1,iadd
      do 100 j3=1,3
      if (little(i,jj,j3).ne.jhkl(j3)) go to 200
  100 continue
      go to 400
  200 continue
  300 continue
      iadd=iadd+1
      little(i,j,1)=jhkl(1)
      little(i,j,2)=jhkl(2)
      little(i,j,3)=jhkl(3)
      go to 450
  400 continue
c---- we add 1000 to the equivalent reflection
c---- if it is equal to the k-th. reflection  ( k=1,j-1 ) .
      iadd=iadd+1
      little(i,j,1)=jhkl(1)+1000
      little(i,j,2)=jhkl(2)+1000
      little(i,j,3)=jhkl(3)+1000
  450 continue
  500 continue
      if(irec.ne.0) return
      if (itype.ne.1.and.icent.eq.1) e1000=-e1000
      iel(i)=e1000
      phive(i)=itype*1000+iphi
      return
      end
c----------------------------------------------------------------------
      subroutine equiv(x,x1,k,ind)
c
c-- calcola il riflesso equivalente per la matrice  k-esima
c
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
c
      integer x(3),x1(3)
c
      do 10 i=1,3
      x1(i)=0
      do 10 j=1,3
   10 x1(i)=x1(i)+x(j)*ksmat(k,j,i)
      call indr(x1,ind)
      return
      end
c-----------------------------------------------------------------------
      subroutine indr(ihkl,ind)
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
      common/ureq/ihx(3),ksigma,knw,jpart,jtran,ipolar,nonos,iprin,iflag
c
      common /inp/  natom,fnat,satm,dumy
      common /cost/ pi2,jxa,jxb,jxx,nk1,lfl,nrif,mult,nsem,itype,ang(24)
      common/xdata/isr(100000),matse(350,3),little(350,24,3),limi(9001),
     1 idopp(1000),iel(350),phive(350),list1(1000,2),list2(1000,5),nlis,
     2 gq(8000),gv(8000),idummy(48),dummpc(84000)
      integer ihkl(3),ivet(3)
c
c----- make sure first non-zero index is positive
c
      do 200 i=1,3
      if (iabs(ihkl(i))-ihx(i)) 100,100,800
  100 continue
      ivet(i)=ihkl(i)
  200 continue
      do 300 i=1,3
      if (ivet(i)) 400,300,600
  300 continue
      go to 800
  400 continue
      do 500 i=1,3
      ivet(i)=-ivet(i)
  500 continue
  600 continue
      jklc=iabs(jxa*ivet(1)+jxb*ivet(2)+ivet(3))
      if (jklc.gt.jxx) go to 800
      ind=jklc
      return
  800 continue
      ind=-1
      return
      end
c-----------------------------------------------------------------------
      subroutine sigma2
c--calculate triplets
c
      common /dirg/ jss1,jopt,jss2
      common /dir1/ jboth,jrepr,jeli1,jenu1,jknum,soge1,sogk
      common /dir2/ jenu2,glim,soge2,eplim,nca(2)
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),jjnt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
      common/ureq/ihx(3),ksigma,knw,jpart,jtran,ipolar,nonos,iprin,iflag
c
      common /inp/  natom,fnat,satm,dumy
      common /cost/ pi2,jxa,jxb,jxx,nk1,lfl,nrif,mult,nsem,itype,ang(24)
      common/xdata/isr(100000),matse(350,3),little(350,24,3),limi(9001),
     1 idopp(1000),iel(350),phive(350),list1(1000,2),list2(1000,5),nlis,
     2 gq(8000),gv(8000),idummy(48),itab(8000),itab1(8000),isig(3,8000),
     3 lim0(9001),dummpc(34999)
      common /pross2/ nquar,e2,et(3),ishi,eq(10),epsi(10),iep231,iep132,
     1 jdelta,duen,ssin,scos,istamp,nb1,nb2,nb3,nb4,ns1,ns2,ns3,ns4,ikkk
     2 ,nsu(2),ess(4),jcb(3),sden
      common /sig2/ gs,n8
      dimension ill(3),ist(2,7),gt(7),iphit(7),ivet(48)
      integer jhkl3(3)
      common/tst/nt,ar(26),nn(11,26,3),pp(11,26,3)
      common /nctst/ ns,br(15),nb(11,15,3),fnb(11,15,3),bcm(11,15,3),
     *                        acm(11,15,3)
c--
c  description of some important settings
c
c  h1 = h2 + h3
c  i  h1 code
c  j  h2 code
c in  h3 code
c mh  h,k,l first  reflection
c mk  h,k,l second reflection
c ml  h,k,l third  reflection
c
      s3s2=1./sqrt(fnat)
c--clear the areas
      do 1001 k=1,8000
      itab(k)=0
 1001 continue
      do 1004 i=1,jxx
      isr(i)=0
 1004 continue
c--create the list
      ipu=0
      do 1900 j=1,jenu1
      do 1100 i=1,nsym
      kcav=0
      if (little(j,i,1).ge.127) kcav=1
      do 1111 i1=1,3
 1111 ill(i1)=little(j,i,i1)-kcav*1000
      indr=ill(1)*jxa+ill(2)*jxb+ill(3)
      indrr=indr
      if (i.eq.1) go to 1113
      imen1=i-1
      do 1112 i1=1,imen1
      if (indr.eq.ivet(i1)) indrr=0
 1112 continue
 1113 ipu=ipu+1
      ivet(i)=indrr
      a=little(j,1,1)*tmat(i,1)+little(j,1,2)*tmat(i,2)
     ++little(j,1,3)*tmat(i,3)
      k=nint(a*24.)
      k=mod(k,24)
      if(k.lt.0) k=k+24
      itab(ipu)=indrr
      itab1(ipu)=((ill(2)+64)*128+ill(3)+64)*32+k
      isgn=isign(1,indr)
      indr=iabs(indr)
      if(isr(indr).eq.0)isr(indr)=(j*32+i)*isgn
 1100 continue
 1900 continue
      n8t=8000
      jsup =jenu1-1
c--calculate sigma 2
      jt=0
      n8=0
      n8e=0
      if(iprin.lt.2) go to 1530
      write(lo,1525)
1525  format(/,' set up sigma2 relationships')
1530  continue
c--azzeramento isig
c
      do 50 i=1,3
      do 50 j=1,8000
      isig(i,j)=0
 50   continue
      nsup=jenu1
      inn1=1-nsym
c--first loop
c
      do 2000 nl=1,nlis
      inn1=inn1+nsym
      i=list1(nl,1)/10
c
      llist=list2(nl,4)
      e1=float(llist)/1000.
      if(iprin.lt.2) go to 2005
      llist=list2(nl,5)
      ifi=mod(llist,1000)
      write(lo,2004) (list2(nl,n),n=1,3),i,e1,ifi
2004  format(/,' reflection ',3i4,10x,
     1 'code = ',i4,10x,
     2 'e = ',f7.2,10x,
     3 'phase =',i7,/)
      js=0
 2005 jk1=list2(nl,2)
      jl1=list2(nl,3)
      i1=i
c
c--second loop
c
      do 2100 j=1,nsup
c-- se il secondo riflesso e' uguale al primo , via 
      if (j.eq.i) go to 2100
c
      i0=2*nsym
      do 2110 ii=1,i0
      ivet(ii)=0
 2110 continue
      i0=0
      jn=(j-1)*nsym
      do 2200 k=1,nsym
      jnk=jn+k
      if(little(j,k,1).ge.127) goto 2200
      it=itab1(jnk)/32
      jk2=little(j,k,2)
      jl2=little(j,k,3)
      do 2300 l=1,3,2
      l1=l-2
      do 2301 jjj=1,3
      jhkl3(jjj)=list2(nl,jjj)+little(j,k,jjj)*l1
      if (iabs(jhkl3(jjj)).gt.ihx(jjj)) goto 2300
 2301 continue
      ih3=jxa*jhkl3(1)+jxb*jhkl3(2)+jhkl3(3)
      l3=1
      if(ih3) 2010,2300,2020
 2010 l3=-1
      ih3=-ih3
 2020 if(ih3.gt.jxx) go to 2300
      if(isr(ih3).eq.0) go to 2300
      if(isr(ih3).lt.0) l3=-l3
      isra=isr(ih3)
      isra=iabs(isra)
      in=isra/32
c-- controlla che non ci siano riflessi ripetuti
c-- e/o doppioni
      if (in.eq.i.or.in.ge.j) go to 2300
      if(i0.eq.0)go to 2030
      do 2040  ii=1,i0
      if(in.eq.ivet(ii))go to 2300
 2040 continue
 2030 i0=i0+1
      ivet(i0)=in
      in3=isra-in*32
      ins=(in-1)*nsym+in3
      ns3=mod(itab1(ins),32)
      ns2=mod(itab1(jnk),32)
      is =-ns2*l1+ns3*l3+48
      is =mod(is ,24)
      iss=is*360/24
c  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
c
c  phi(t)=phi(h1)-phi(h2)-phi(h3)+shift(fase)
c  i codici sono per  h1 = h2 + h3
c  cod(h2)= -l1 * j
c  cod(h3)=  l3 * in
c
      ifi=list2(nl,5)
      ifi=ifi-(ifi/1000)*1000
      if2=int(phive(j))
      if2=if2-(if2/1000)*1000
      if3=int(phive(in))
      if3=if3-(if3/1000)*1000
      iphi= ifi+if2*l1-if3*l3+iss
      if(iphi.lt.0)iphi=iphi+3600
      iphi=mod(iphi,360)
      e2=float(iabs(iel(j)))/1000.
      e3=float(iabs(iel(in)))/1000.
      g=s3s2*e1*e2*e3
      g=2.*g
      if (iprin.lt.2) go to 2025
      js=js+1
      jt=jt+1
      ist(1,jt)=-j*l1
      ist(2,jt)=in*l3
      gt(jt)=g
      iphit(jt)=iphi
      if(jt.ne.5) go to 2025
      write(lo,2026) ((ist(n,mm),n=1,2),gt(mm),iphit(mm),mm=1,5)
 2026 format(5(3x,2i5,f7.2,i5))
      jt=0
 2025 continue
      n8=n8+1
      if(g.gt.20.47) g=20.47
      gq(n8)=g
      jg=nint(g*100.)
c *******************************************************
c **  is   =  d-shift del tripletto
c **  i    =  code del primo riflesso
c **  j    =  code del secondo riflesso
c **  in   =  code del terzo riflesso
c **  k    =  operatore di simm. del secondo riflesso
c **  in3  =  operatore di simm. del terzo riflesso
c **  l1   =  segno del secondo riflesso
c **  l3   =  segno del terzo riflesso
c **  jg   =  int(g*100)
c **  iphi =  fase reale del tripletto
c ********************************************************
      isig(1,n8)=((i+2048)*4096+l1*j+2048)*32+k+1
      isig(2,n8)=((-l3*in+2048)*4096+in3+2048)*32+is+1
      isig(3,n8)=(((iphi/15)+2048)*4096+jg+2048)*32+mod(iphi,15)+1
      if(knw.eq.0) goto 2400
c*********************************************************
c    calcolo statistiche
c*********************************************************
      b=float(iphi)*pi/180.
      a=cos(b)
      an=a*g
      if (icent.le.1) go to 4000
      gg=g
c--  esegue test centro
c     call sctst(gg,an,1)
      goto 2400
 4000 g2=g
      call besse(g2,coat)
c--  esegue test noncentro
c     call nctet(g2,coat,a,1)
 2400 if(n8.ge.n8t) go to 2700
 2300 continue
 2200 continue
 2100 continue
      if(iprin.lt.2) go to 2000
      if(jt.eq.0) go to 2002
      write(lo,2026) ((ist(n,mm),n=1,2),gt(mm),iphit(mm),mm=1,jt)
      jt=0
 2002 continue
      write(lo,2101) js
 2101 format(' number of contributors =',i6)
      js=0
 2000 continue
 2700 continue
c -------  costruzione lim0
      do 3048 i=1,9001
 3048 lim0(i)=0
      nseq=0
      ncod=0
      do 3050  i=1,n8
      call unpak3(isig(1,i),ncod1,ncod2,iff)
      if(ncod1.eq.0) goto 3051
      lim0(ncod1+1)=lim0(ncod1+1) + 1
 3050 continue
 3051 nfin=nrif+1
      do 3052 i=2,nfin
 3052 lim0(i)=lim0(i)+lim0(i-1)
      return
      end
c----------------------------------------------------------------------
      subroutine sortgs(um,ndim)
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/ureq/ihx(3),ksigma,knw,jpart,jtran,ipolar,nonos,iprin,iflag
      dimension  um(9001)
c
      if (ndim.gt.1) go to 100
      if (ndim.le.0) write(lo,110)
      iflag=1
      return
  100 continue
      k=1
    1 k=2*k
      if (k.lt.ndim) go to 1
      k=k/2
    7 l=ndim-k
      j=1
    6 if (j.gt.l) go to 2
      i=j
    5 ik=i+k
      m=i
    4 aix=um(m)
      mj=m+k
      aiy=um(mj)
      if (aix.ge.aiy) go to 3
      aicom=um(m)
      um(m)=um(mj)
      um(mj)=aicom
      m=m-k
      i=ik
      if (m.gt.0) go to 4
    3 i=i+k
      if (i.le.l) go to 5
      j=j+1
      if (j.le.k) go to 6
    2 k=k/2
      if (k.gt.0) go to 7
      return
  110 format(//,' **********  warning  **********',/
     1         ,'         no sigma2 exist        ',/
     2         ,'        program is killed       ',/
     3         ,'********************************',//)
      end
c----------------------------------------------------------
      subroutine fillr
c---- reading of normal file
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
c
      common /cost/ pi2,jxa,jxb,jxx,nk1,lfl,nrif,mult,nsem,itype,ang(24)
      common/xdata/isr(100000),matse(350,3),little(350,24,3),limi(9001),
     1 idopp(1000),iel(350),phive(350),list1(1000,2),list2(1000,5),nlis,
     2 gq(8000),gv(8000),idummy(48),dummpc(84000)
      integer hkl(3),jhkl(3)
      dimension vet(12),ivet(12)
      equivalence(ivet(1),vet(1))
c
      do 95 i=1,jxx
   95 isr(i)=-1000
c -----
c     call  sub.  preambolo     lista  7  :  riflessi ordinati
c -----
      call ysfl07(nrif,nstron,nweak,npseud,iy)
c -----
c     call  sub.  per  lettura  lista  7  :  riflessi ordinati
c -----
      do 1090 i=1,nrif
      call snr07(vet)
      hkl(1)=ivet(1)
      hkl(2)=ivet(2)
      hkl(3)=ivet(3)
      e=vet(4)
      if(e.eq.0.0) e=0.01
      if(e.eq.1.0) e=0.999
      iphi8=mod(ivet(8),2**15)
      iphi=iphi8/32
      itype=mod(iphi8,32)
c---- fill reciprocal-space-array
      e1000=e*1000
      do 500 l=1,nsym
      call equiv(hkl,jhkl,l,ind)
  500 isr(ind)=e1000
 1090 continue
      return
      end
c-----------------------------------------------------------------------
      subroutine sorts(num,v,nmax,idim)
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/ureq/ihx(3),ksigma,knw,jpart,jtran,ipolar,nonos,iprin,iflag
      dimension num(idim),v(idim)
c
      if (nmax.gt.1) go to 100
      if (nmax.le.0) write(lo,110)
      num(1)=1
      iflag=1
      return
  100 continue
      do 10 i=1,nmax
      num(i)=i
   10 continue
      k=1
    1 k=2*k
      if (k.lt.nmax) go to 1
      k=k/2
    7 l=nmax-k
      j=1
    6 if (j.gt.l) go to 2
      i=j
    5 ik=i+k
      m=i
    4 x=v(m)
      mj=m+k
      y=v(mj)
      if (x.ge.y) go to 3
      com=num(m)
      num(m)=num(mj)
      num(mj)=com
      com=v(m)
      v(m)=v(mj)
      v(mj)=com
      m=m-k
      i=ik
      if (m.gt.0) go to 4
    3 i=i+k
      if (i.le.l) go to 5
      j=j+1
      if (j.le.k) go to 6
    2 k=k/2
      if (k.gt.0) go to 7
      return
  110 format(//,' **********  warning  **********',/
     1         ,' *    no seminvariants exist   * ',/
     2         ,' *******************************',//)
      end
c-----------------------------------------------------------------------
      subroutine inse(dopma,value,ind,ij)
      dimension dopma(49,8)
      entry=value
      if (ij.eq.1) go to 20
      ij1m=ij-1
      do 10 ii=1,ij1m
      if (value.ne.dopma(ii,ind)) go to 10
      return
   10 continue
   20 continue
      dopma(ij,ind)=entry
      return
      end
c---------------------------------------------------------------------
      subroutine ksym(k1,hp,e4,eps4,h4,id1)
c ----------
c ----------   compute   h + k * r(i)
c ----------
      common/xdata/isr(100000),matse(350,3),little(350,24,3),limi(9001),
     1 idopp(1000),iel(350),phive(350),list1(1000,2),list2(1000,5),nlis,
     2 gq(8000),gv(8000),idummy(48),dummpc(84000)
      integer hp(3),h4(3),k1(3)
c
      h4(1)=hp(1)+k1(1)
      h4(2)=hp(2)+k1(2)
      h4(3)=hp(3)+k1(3)
      call indr(h4,id1)
      if (id1.lt.0) go to 10
      istabs=isr(id1)
      ist=iabs(istabs)
      e4=float(ist)/1000.0
      eps4=e4*e4-1.0
      return
   10 continue
      e4=0.0
      eps4=0.0
      return
      end
c----------------------------------------------------------------------
      subroutine mark(hkl,nord,idoub,jhkl)
c
c-- 'marca' nel reciproco un riflesso gia' utilizzato
c
      common /dirg/ jss1,jopt,jss2
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
      common/ureq/ihx(3),ksigma,knw,jpart,jtran,ipolar,nonos,iprin,iflag
c
      common /inp/  natom,fnat,satm,dumy
      common /cost/ pi2,jxa,jxb,jxx,nk1,lfl,nrif,mult,nsem,itype,ang(24)
      common/xdata/isr(100000),matse(350,3),little(350,24,3),limi(9001),
     1 idopp(1000),iel(350),phive(350),list1(1000,2),list2(1000,5),nlis,
     2 gq(8000),gv(8000),idummy(48),dummpc(84000)
      integer hkl(3),hkle(3),jhkl(3)
c
c
c---- rende negativo il valore di  'e'  e di tutti gli  'e'
c---- equivalenti attraverso  'equi'  in modo che in seguito
c---- non venga piu' utilizzato il riflesso u. inoltre memorizza
c---- l'indirizzo in idopp in modo da resettare il reciproco una volta
c---- completati i calcoli per il s.s.i. in esame.
c
      iflag=0
      do 27 jj=1,nsym
      call equiv(hkl,hkle,jj,ind)
      if (ind.le.0) go to 27
      ist=isr(ind)
      if (ist.le.0) go to 27
      isr(ind)=-ist
      idoub=idoub+1
      if (idoub.le.1000) go to 26
      idoub=idoub-1
      iflag=1
      return
   26 continue
      idopp(idoub)=ind
   27 continue
      return
      end
c----------------------------------------------------------------------
      subroutine sors1(gvet,icont,suma)
c---- sort seminvariants stored in 'matse'
      common /dirg/ jss1,jopt,jss2
      common /dir1/ jboth,jrepr,jeli1,jenu1,jknum,soge1,sogk
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
      common/ureq/ihx(3),ksigma,knw,jpart,jtran,ipolar,nonos,iprin,iflag
c
      common /inp/  natom,fnat,satm,dumy
      common /inv/  invma(96,3,3),idivv(48)
      common /cost/ pi2,jxa,jxb,jxx,nk1,lfl,nrif,mult,nsem,itype,ang(24)
      common /choi/ mm,iimax,jmax,nsj,jtable(8,16),invet(48)
      common /pro/  jvarma(3,3),kx(3),idoub,kkk,sump(2),icros,
     * jhkl(3),e,scr2(2),ns,sr2(2),jhimrn(3,3),nsemc,nsemg
      common/xdata/isr(100000),matse(350,3),little(350,24,3),limi(9001),
     1 idopp(1000),iel(350),phive(350),list1(1000,2),list2(1000,5),nlis,
     2 gq(8000),gv(8000),idummy(48),dummpc(84000)
      dimension suma(2)
      dimension gvet(350),ias(350),nord(350),ihkl(350,3),ee(350)
      dimension num(350),iphi(350),iast(350),iphit(350),igv(350)
      data iblan,istar,iggg/1h ,1h*,1hg/
c
      if (nsem.eq.0) then
                      write(lo,10)
   10 format(//,' **********  warning  **********',/
     1         ,' *    no seminvariants exist   * ',/
     2         ,' *******************************',//)
                      return
                     endif
      scale=1.0
      if (jrepr.eq.2) scale=suma(1)/suma(2)
      if (scale.gt.1.0) scale=1.0
      istron=0
      ig=0
      n11=0
      do 20 i=1,nsem
      if (gvet(i).eq.0.0) go to 20
      n11=n11+1
      ias(i)=iblan
      if (gvet(i).lt.0.0) ias(i)=istar
      gvet(i)=abs(gvet(i))*scale
   20 continue
      icont=0
      if (n11.eq.0) return
      call sorts(num,gvet,nsem,350)
      write(lo,110)
      write(lo,115)
      ari=0.0
      nari=0
      do 30 i=1,nsem
      if (gvet(i).eq.0.0) go to 35
      icont=icont+1
      if (gvet(i).ge.0.8) istron=istron+1
      j=num(i)
      iast(i)=ias(j)
      jpoint=matse(j,1)
      do 25 k=1,3
      ihkl(i,k)=little(jpoint,1,k)
   25 continue
      nord(i)=matse(j,1)
      e=float(iel(jpoint))/1000.0
      ee(i)=abs(e)
      itype  =matse(j,3)/1000
      iphi(i) =matse(j,3)   -itype*1000
      ncode=nord(i)
      if (itype.eq.1) ncode=-ncode
      iphit(i)=jpack1(ncode,gvet(i),iphi(i))
      igv(i)=iblan
      if (itype.ne.1) go to 28
      ig=1
      igv(i)=iggg
      go to 30
   28 if (knw.eq.0) go to 30
      prob=0.5+0.5*tanh(gvet(i))
      if (istar.eq.iast(i)) prob=1.0-prob
      ari=ari+(prob-0.5)*ee(i)/abs(ee(i))
      nari=nari+1
   30 continue
   35 iconts=min0(9,icont)
      write(lo,210) (nord(i),(ihkl(i,k),k=1,3),ee(i),gvet(i),
     1               iphi(i),igv(i),iast(i),i=1,iconts)
      if(icont.gt.iconts) write(lo,230)
      write(lo,240)
      if (ig.eq.1.and.iprin.ne.0) write(lo,250)
      if (knw.eq.0) go to 37
      write(lo,245)
      if (nari.eq.0) nari=1
      ari=2.0*ari/float(nari)
      if (iprin.ne.0) then
                        write(lo,36) ari
   36 format(60x,'ari = ',f8.4)
                      endif
c---- write seminvariants on disk
   37 continue
c ---
c     call sub. scrittura lista 26 : seminvarianti a una fase
c ---
      iprea=0
      call frmxx(iprea,26,icont,icont,istron,nxxe,iccd,iphit)
      return
  210 format(3(i6,1h),3i3,2x,f6.3,1x,f7.3,1x,i4,a1,a1,3x))
  230 format(/,5x,' .... and so on',/)
  240 format(1h ,/)
  245 format(20x,'reflections marked with  *  are wrongly estimated',/)
  250 format(20x,'for reflections with  "g"-phase  alpha is equal to 1/2
     1  the argument of  io bessel  function',//)
  110 format(//,35x,
     *          ' List of one-phase structure seminvariants estimated',
     *//,3x,3('code     H        E     alpha phase       '),
     3 /,1h ,2x,3('----------------------------------------'),/)
  115 format(1h )
      end
c-----------------------------------------------------------------------
      function jpack1(n1,g,ifaz)
      ifz=ifaz/15
      ifz=mod(ifz,24)
      ig100=int(g*100)
      if (ig100.gt.2047) ig100=2047
      jpack1=((n1+2048)*4096+ig100+2048)*32+ifz+1
      return
      end
c-----------------------------------------------------------------------
      subroutine jpack2(ind1,ind2,n1,ise,n2,g,ifaz)
      ig100=int(g*100)
      if (ig100.gt.2047) ig100=2047
      ind1=((n1+2048)*4096+n2*ise+2048)*32
      ind2=((1024+2048)*4096+ig100+2048)*32+(ifaz/15)+1
      return
      end
c-----------------------------------------------------------------------
      subroutine unpk1(ind,n1,g,ifaz)
c---- jpack1=((n1+2048)*4096+int(g*100)+2048)*32+(ifaz/15)+1
      ind=ind-1
      n1=ind/131072-2048
      ig100=ind/32-(n1+2048)*4096-2048
      g=float(ig100)/100.0
      ifaz=(ind-((n1+2048)*4096+ig100+2048)*32)*15
      return
      end
c-----------------------------------------------------------------------
      function h4(ee)
      e=ee
      if (e.eq.0.0) go to 10
      h4=e*e*e*e-6.0*e*e+3.0
      return
   10 continue
      h4=0.0
      return
      end
c----------------------------------------------------------------------
cdjw99      function modulo(hkl)
      function modulx(hkl)
c-- verifies if a reflection is a seminvariant
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
c
      integer hkl(3),mat(3,3)
      equivalence (mat(1,1),jsvet(1))
c
cdjw99      modulo=1
      modulx=1
      do 30 ic=1,3
      isum=0
      do 20 i=1,3
   20 isum=isum+mat(ic,i)*hkl(i)
      if (mod(isum,192).ne.0) return
   30 continue
cdjw99      modulo=0
      modulx=0
      return
      end
c-----------------------------------------------------------------------
      subroutine wrcon
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
c
      common /choi/ mm,iimax,jmax,nsj,jtable(8,16),invet(48)
      integer congr(16)
c--
      write(lo,1160)
      write(lo,1110) isvet
      write(lo,1160)
      write(lo,1150)
      write(lo,1160)
      do 12 i=1,jmax
      k=jtable(1,i)
      call cong4(ksmat,msym,k,congr)
      write(lo,1100) congr,k
   12 continue
      write(lo,1160)
c--
 1100 format(20x,10a1,' congruent to 0 mod. (',6a1,
     *'  because of matrix n. ',i2)
 1110 format(20x,'Seminvariant condition : ',3a2,4x,5a2)
 1150 format(20x,'First rank seminvariant condition(s) :')
 1160 format(1h )
      return
      end
c----------------------------------------------------------------------
      subroutine ss1(result)
c
      common /dirg/ jss1,jopt,jss2
      common /dir1/ jboth,jrepr,jeli1,jenu1,jknum,soge1,sogk
      common /dir2/ jenu2,glim,soge2,eplim,nca(2)
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
      common/ureq/ihx(3),ksigma,knw,jpart,jtran,ipolar,nonos,iprin,iflag
c
      common /inp/  natom,fnat,satm,dumy
      common /inv/  invma(96,3,3),idivv(48)
      common /cost/ pi2,jxa,jxb,jxx,nk1,lfl,nrif,mult,nsem,itype,ang(24)
      common /choi/ mm,iimax,jmax,nsj,jtable(8,16),invet(48)
      common /pro/  jvarma(3,3),kx(3),idoub,kkk,sump(2),icros,
     * jhkl(3),e,scr2(2),ns,sr2(2),jhimrn(3,3),nsemc,nsemg
      common/xdata/isr(100000),matse(350,3),little(350,24,3),limi(9001),
     1 idopp(1000),iel(350),phive(350),list1(1000,2),list2(1000,5),nlis,
     2 gq(8000),gv(8000),idummy(48),dummpc(84000)
      common /pross2/ nquar,e2,et(3),ishi,eq(10),epsi(10),iep231,iep132,
     1 jdelta,duen,ssin,scos,istamp,nb1,nb2,nb3,nb4,ns1,ns2,ns3,ns4,ikkk
     2 ,nsu(2),ess(4),jcb(3),sden
      integer balfa(3)
      dimension blv(3),sign(3),alf(3),gvet(350),imat(5)
      integer h(3,3),congr(16),result(2,2)
      dimension prob(3),arg(3),ias(3),suma(2)
      data iblan,istar/1h ,1h*/
      data gvet,suma /350*0.0,2*0.0/
c
      write(lo,100)
  100 format(///,120('+'),//,
     1 39x,'***   one-phase seminvariants section   ***',//)
      if (jrepr.eq.1) write(lo,110)
      if (jrepr.eq.2) write(lo,120)
  110 format(20x,'First representation formula will be used',/)
  120 format(20x,'Second representation formula will be used',/)
      if (jenu1.lt.200) soge1=abs(float(iel(jenu1)))/1000.0
      write(lo,130) jenu1,soge1
  130 format(20x,'n. of reflections to search s.s.i. = ',i5,
     *'  with  /E/ .ge.', f7.3,/)
      if (jrepr.eq.2) write(lo,131) jknum,sogk
  131 format(20x,'n. of free vectors used            = ',i5,
     *'  with  /E/ .ge.', f7.3,/)
      if (nsem.eq.0) return
      duen = 2. * fnat
      nsemc=0
      nsemg=0
      ilit=0
c---- estract reflections from matse
   40 continue
      ilit=ilit+1
      if (ilit.gt.nsem) go to 1500
      nord   =matse(ilit,1)
      do 50 k=1,3
   50 jhkl(k)=little(nord,1,k)
      e      =iel(nord)/1000.0
      e      =abs(e)
      if (e.lt.soge1) go to 1500
      itype  =phive(nord)/1000
      iphi   =phive(nord)-itype*1000
      phi=iphi
      phic=ang(itype)
      sump(1)=0.0
      sump(2)=0.0
      icros=0
      sr2(1)=0.0
      sr2(2)=0.0
      idoub=0
      j=list1(ilit,1)
      nmat=mod(j,10)
      ixxx=j/10
      j=list1(ilit,2)
      do 60 i=1,nmat
      imat(i)=mod(j,64)
   60 j=j/64
c---- if we have to use the second representation formula
c---- we compute  h +/- krj  (j=1,nsym)
      if (jrepr.eq.2) call ehk
c---- by means of the array imat consider only
c---- indipendent symmetry operators.
      do 70 i=1,nmat
      kkk=imat(i)
      if (kkk.eq.0) then
                      write(lo,*) '**** subroutine ss1 (kkk) ****'
                      write(lo,*) '****  programming  error  ****'
                      write(lo,*) ' sir ends in error'
                      stop 1234
                    endif
c---- compute the matrix  h = ( i - rs )
      do 65 i1=1,3
      do 62 j1=1,3
   62 h(i1,j1)=-ksmat(kkk,j1,i1)
   65 h(i1,i1)=h(i1,i1)+1
c---- compute the first rank seminvariant vector
c---- by means of 'cong4' (for print only).
      if (iprin.gt.2) call cong4(ksmat,msym,kkk,congr)
c---- compute the solutions of the diophantine system
c---- if idiof = 1  we do not get integer solutions.
      call diof(h,idiof,balfa,sign,alf,blv)
      if (idiof.ne.0) then
                      write(lo,*) '**** subroutine ss1 (idiof) ****'
                      write(lo,*) ' ****  programming  error  ****'
                      write(lo,*) ' sir ends in error'
                      stop 1234
                    endif
      if (iprin.gt.2) write(lo,68) nord,jhkl,kkk,congr
     *, balfa
     1, (kx(i1),i1=1,3)
     2, (sign(i1),alf(i1),blv(i1),i1=1,3)
   68 format(1h ,i3,1h),3i4,3h - ,
     *           'mat. ',i2,2x,10a1,' congruent to 0 mod. (',6a1,
     *  2x,'h = (',2(i3,1h,),i3,1h),
     1  2x,6h x = (,i3,2(1h,,i3),1h),
     2  2x,' + (',3a1,2(1h,,3a1),1h))
      nquar=1
      call find1(nord,phic,isbat)
   70 continue
c---- reset reciprocal space
      do 85 i=1,idoub
      ipik=idopp(i)
      ist=isr(ipik)
      if (ist.gt.0) go to 85
      isr(ipik)=-ist
   85 continue
c---- compute probability
      if (icros.eq.0) go to 40
      if (itype.ne.1) go to 91
      nsemg=nsemg+1
      arg(1)=(sqrt(sump(1)*sump(1)+sump(2)*sump(2)))/2.0
      arg(2)=(sqrt(sr2(1)*sr2(1)+sr2(2)*sr2(2)))/2.0
      do 87 i=1,2
   87 arg(i)=arg(i)*e/satm
      prob(1)=atan2(sump(2),sump(1))
      prob(2)=atan2(sr2(2),sr2(1))
      prob(1)=prob(1)*360.0/pi2
      prob(2)=prob(2)*360.0/pi2
      go to 92
   91 continue
      nsemc=nsemc+1
      arg(1)=0.5*e*sump(1)/satm
      arg(2)=0.5*e*sr2(1)/satm
      prob(1)=0.5+0.5*tanh(abs(arg(1)))
      prob(2)=0.5+0.5*tanh(abs(arg(2)))
   92 continue
      do 93 i=1,2
      phicv=phic
      if (itype.eq.1) phicv=prob(i)*pi2/360.0
      if (arg(i).lt.0.0) phicv=phicv+pi2/2.0
      arg(i)=abs(arg(i))
      suma(i)=suma(i)+arg(i)
      ias(i)=iblan
      phicv=phicv*360.0/pi2
      if (knw.eq.0) go to 93
      argj=phicv-phi
      argc=(phicv-phi)*pi2/360.0
      if (cos(argc).lt.0.0.and.itype.ne.1) ias(i)=istar
      if (jrepr.eq.1) go to 95
   93 continue
   95 continue
      i=jrepr
      if (arg(i).ge.0.2) go to 96
      if (itype.eq.1) nsemg=nsemg-1
      if (itype.ne.1) nsemc=nsemc-1
      gvet(ilit)=0.0
      go to 1450
   96 if (itype.eq.1) phicv=prob(i)
      if (phicv.lt.  0.0) phicv=phicv+360
      if (phicv.ge.360.0) phicv=phicv-360
      phic=phicv
      gvet(ilit)=arg(i)
      jphic=phic+0.5
      if (ias(i).eq.istar) gvet(ilit)=-gvet(ilit)
      matse(ilit,3)=itype*1000+jphic
      if (jboth.eq.0) go to 90
      if (itype.ne.1)  write(lo,89) nord,jhkl,e,phi,icros,
     2                 (arg(i),prob(i),ias(i),i=1,2),jphic,itype
      if (itype.eq.1) write(lo,94) nord,jhkl,e,phi,icros,
     2                 (arg(i),        ias(i),i=1,2),jphic,itype
   90 continue
   89 format(1x,i5,1h),3i4,f8.3,f6.1,i4,1x,2(f7.3,1x,f5.3,a1),
     *                  7x,i5,8x,i3,2x,2h  )
   94 format(1x,i5,1h),3i4,f8.3,f6.1,i4,1x,2(f7.3,1x,5x  ,a1),
     *                  7x,i5,8x,i3,'  ')
      if (jboth.eq.1) write(lo,500)
 1450 continue
c
      go to 40
 1500 continue
c---- sort seminvariants
      call sors1(gvet,nsemt,suma)
      if(nsemt.eq.0) then
                       nsem=0
                       return
                     endif
      result(1,1)=nsem
      result(1,2)=nsemt
      if(iprin.ne.0) then
c---- print the number of seminvariants
                       write(lo,2007)
                       write(lo,2008) nsemc
                       if (nsemg.ne.0) write(lo,2009) nsemg
                       write(lo,2011) nsemt
                     endif
      return
 2007 format(1h )
 2008 format(20x,'n. of first rank s.s.i   (restricted-phase)   =',i5)
 2009 format(20x,'n. of first rank s.s.i.    (general phase)    =',i5)
 2011 format(20x,'n. of s.s.i. stored      = ',i5)
  500 format(1x,104('-'))
      end
c---------------------------------------------------------------------
      subroutine ehk
c
      common /dirg/ jss1,jopt,jss2
      common /dir1/ jboth,jrepr,jeli1,jenu1,jknum,soge1,sogk
      common /dir2/ jenu2,glim,soge2,eplim,nca(2)
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
      common/ureq/ihx(3),ksigma,knw,jpart,jtran,ipolar,nonos,iprin,iflag
c
      common /cost/ pi2,jxa,jxb,jxx,nk1,lfl,nrif,mult,nsem,itype,ang(24)
      common /pro/  jvarma(3,3),kx(3),idoub,kkk,sump(2),icros,
     * jhkl(3),e,scr2(2),ns,sr2(2),jhimrn(3,3),nsemc,nsemg
      common/xdata/isr(100000),matse(350,3),little(350,24,3),limi(9001),
     1 idopp(1000),iel(350),phive(350),list1(1000,2),list2(1000,5),nlis,
     2 gq(8000),gv(8000),idummy(48),dummpc(84000)
      common /temp/ ifinv(100,2),hkrj(100,4,24)
c
      integer h3(3),hk(3)
c
      do 100 k=1,jknum
      e3=iel(k)
      ifin1=2
      ifin2=nsym2
      if (icent.eq.2) go to 10
      if (e3.gt.0.0)  go to 10
      ifin1=1
      ifin2=nsym
   10 continue
      ifinv(k,1)=ifin1
      ifinv(k,2)=ifin2
      isegn=-1
c---- loop over the symmetry
      do 30 isy=1,ifin1
      isegn=-isegn
      do 30 i=1,nsym
      do 20 j=1,3
   20 h3(j)=little(k,i,j)*isegn
      call ksym(h3,jhkl,ee,eps,hk,ind)
      hkrj(k,isy  ,i)=ee
      hkrj(k,isy+2,i)=eps
   30 continue
  100 continue
      return
      end
c-----------------------------------------------------------------------
      subroutine secrep(codh,e1,e2,eps2,eps1,nord,coef)
c ----------
c ---------- evaluate the second representation probability
c ----------
      common /dirg/ jss1,jopt,jss2
      common /dir1/ jboth,jrepr,jeli1,jenu1,jknum,soge1,sogk
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
      common/ureq/ihx(3),ksigma,knw,jpart,jtran,ipolar,nonos,iprin,iflag
c
      common /inp/  natom,fnat,satm,dumy
      common /inv/  invma(96,3,3),idivv(48)
      common /cost/ pi2,jxa,jxb,jxx,nk1,lfl,nrif,mult,nsem,itype,ang(24)
      common /choi/ mm,iimax,jmax,nsj,jtable(8,16),invet(48)
      common /pro/  jvarma(3,3),kx(3),idoub,kkk,sump(2),icros,
     * jhkl(3),e,scr2(2),ns,sr2(2),jhimrn(3,3),nsemc,nsemg
      common/xdata/isr(100000),matse(350,3),little(350,24,3),limi(9001),
     1 idopp(1000),iel(350),phive(350),list1(1000,2),list2(1000,5),nlis,
     2 gq(8000),gv(8000),idummy(48),dummpc(84000)
c
      common /temp/ ifinv(100,2),hkrj(100,4,24)
c
      integer h3(3),h3j(3),h4(3),h4j(3)
      dimension sum(2),sum1(2),codh(2),ahks(2),dopma(49,8)
c
      ipr2=iprin
      fatt=coef*(2.0*eps2+1)
      ahks(1)=0.
      ahks(2)=0.
      bhks=0.
      sum(1)=0.0
      sum(2)=0.0
      if (ipr2.ge.1) write(lo,10)jhkl,e1,eps1,kx,e2,eps2,kkk,nk1,sogk
   10 format(1x,'&&&&',2(3i4,2f9.3,5x),' &&&& nmat=',i2,' &&&&',i5,f9.3)
c
c---- sogk = valore di soglia per  ek
c---- jknum = number of free vectors
c
      do 100 ll=1,jknum
      if (nord.eq.ll) go to 100
      h3(1)=little(ll,1,1)
      h3(2)=little(ll,1,2)
      h3(3)=little(ll,1,3)
      e3=iel(ll)
      ifin =ifinv(ll,1)
      ifin2=ifinv(ll,2)
      e3=abs(e3)
      e3=e3*0.001
      if (e3.eq.e2) go to 100
      eps3=e3*e3-1.
      fat=fatt*eps3
      isegn=-1
c
c---- loop over the symmetry
c
      molt5=1
      do 70 isy=1,ifin
      isegn=-isegn
      do 70 i=1,nsym
      ij=i+(isy-1)*nsym
      dopma(ij,2)=1.
      dopma(ij,4)=1.
      dopma(ij,6)=1.
      dopma(ij,8)=1.
      dopma(ij,1)=0.
      dopma(ij,3)=0.
      dopma(ij,5)=0.
      dopma(ij,7)=0.
      if (little(ll,i,1).gt.127) go to 70
      do 20 kk=1,3
   20 h3(kk)=little(ll,i,kk)*isegn
c ----------
      e5  =hkrj(ll,isy  ,i)
      eps5=hkrj(ll,isy+2,i)
c ----------
      call ksym(h3,kx,e4,eps4,h4,ind41)
c ----------
      if (eps4.eq.0.0.and.eps5.eq.0.0) go to 70
      if (e5.le.sogk) go to 25
      if (e3.ge.e5) go to 25
      dopma(ij,4)=0.0
      dopma(ij,6)=0.0
   25 continue
      if (eps4.ne.eps5) go to 30
      if (eps4.eq.0.00) go to 30
      dopma(ij,2)=0.0
      dopma(ij,4)=0.0
      dopma(ij,6)=0.0
      dopma(ij,8)=0.0
      go to 70
   30 continue
      if (e4.le.sogk) go to 35
      if (e3.ge.e4) go to 35
      dopma(ij,2)=0.0
      dopma(ij,4)=0.0
      dopma(ij,6)=0.0
      dopma(ij,8)=0.0
      go to 70
   35 continue
      if (eps4.eq.0.0) go to 40
c=============================
      call inse(dopma,eps4,5,ij)
   40 continue
      if (eps5.eq.0.0) go to 45
c=============================
      call inse(dopma,eps5,1,ij)
   45 continue
      r45=eps4*eps5
      if (r45.eq.0.0) go to 50
c=============================
      call inse(dopma, r45,3,ij)
   50 continue
      j=irot(ij,kkk)
      iseg1=1
      if (j.gt.nsym) iseg1=-1
      if (j.gt.nsym) j=j-nsym
      h3j(1)=little(ll,j,1)
      h3j(2)=little(ll,j,2)
      h3j(3)=little(ll,j,3)
      if (h3j(1).le.127) go to 55
      h3j(1)=h3j(1)-1000
      h3j(2)=h3j(2)-1000
      h3j(3)=h3j(3)-1000
   55 continue
      h3j(1)=h3j(1)*iseg1
      h3j(2)=h3j(2)*iseg1
      h3j(3)=h3j(3)*iseg1
c ----------
      call ksym(h3j,kx,e4j,eps4j,h4j,indj1)
c ----------
      if (e4j.gt.e3) dopma(ij,8)=0.0
      r44=eps4*eps4j
      if (r44.eq.0.0) go to 60
c=============================
      call inse(dopma, r44,7,ij)
   60 continue
      if (e5.eq.e2.and.e5.ne.0.0) molt5=0
      if (e4.eq.e2.and.e4.ne.0.0) molt5=0
      if (e4.eq.e1) molt5=0
      if (molt5.eq.0) go to 100
      if (e5.ne.e3) go to 61
      go to 100
   61 if (e4.ne.e4j) go to 70
      if (e4.eq.0.0) go to 70
      dopma(ij,2)=0.0
      dopma(ij,4)=0.0
      dopma(ij,6)=0.0
      dopma(ij,8)=0.0
   70 continue
      do 78 i=1,7,2
      dopma(49,i)=0.0
      do 75 jj=1,ifin2
   75 dopma(49,i)=dopma(49,i)+dopma(jj,i)*dopma(jj,i+1)
   78 continue
      as=fat*(     dopma(49,3)+dopma(49,7))
     &  -0.5*(eps3*dopma(49,5)+dopma(49,3))
      ahks(1)=ahks(1)+as
      ahks(2)=ahks(2)+as
      qhk=eps1*(eps3*dopma(49,1)+dopma(49,7))
     &   +eps2*(eps3*dopma(49,5)+dopma(49,3))
      bhks=bhks+qhk
      qhk=qhk/(2.0*fnat)
      as=as/fnat
      if(qhk.lt.0.0) qhk=0.0
      sum1(1)=as*codh(1)/(1.0+qhk)
      sum1(2)=as*codh(2)/(1.0+qhk)
      sum(1)=sum(1)+sum1(1)
      sum(2)=sum(2)+sum1(2)
  100 continue
      sr2(1)=sr2(1)+(eps2*codh(1))+sum(1)
      sr2(2)=sr2(2)+(eps2*codh(2))+sum(2)
      if (ipr2.ge.1) write(lo,110)  eps2,coef,codh,sr2,sum
  110 format('  eps2,coef,codh,sr2,sum      ',9x,8f10.4)
      return
      end
c-----------------------------------------------------------
      subroutine ss2(dmat,result)
c
      common /dirg/ jss1,jopt,jss2
      common /dir1/ jboth,jrepr,jeli1,jenu1,jknum,soge1,sogk
      common /dir2/ jenu2,glim,soge2,eplim,nca(2)
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common /ss2c/ ip,ku(3),eu,kva(3),ev,kn,epsu,epsv,nsem2,nsem2g
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
      common/ureq/ihx(3),ksigma,knw,jpart,jtran,ipolar,nonos,iprin,iflag
c
      common /inp/  natom,fnat,satm,dumy
      common /inv/  invma(96,3,3),idivv(48)
      common /cost/ pi2,jxa,jxb,jxx,nk1,lfl,nrif,mult,nsem,itype,ang(24)
      common /choi/ mm,iimax,jmax,nsj,jtable(8,16),invet(48)
      common /pro/  jvarma(3,3),kx(3),idoub,kkk,sump(2),icros,
     * jhkl(3),e,scr2(2),ns,sr2(2),hklt  (3,3),nsemc,nsemg
      common/xdata/isr(100000),matse(350,3),little(350,24,3),limi(9001),
     1 idopp(1000),iel(350),phive(350),list1(1000,2),list2(1000,5),nlis,
     2 gq(8000),gv(8000),idummy(48),itab(8000),itab1(8000),isig(3,8000),
     3 lim0(9001),dummpc(34999)
      common /pross2/ nquar,e2,et(3),ishi,eq(10),epsi(10),iep231,iep132,
     1 jdelta,duen,ssin,scos,istamp,nb1,nb2,nb3,nb4,ns1,ns2,ns3,ns4,ikkk
     2 ,nsu(2),ess(4),jcb(3),sden
      common /sig2/ gs,n8
      common/tst/nt8,ar(26),nn(11,26,3),pp(11,26,3)
      common /nctst/nt9,br(15),nb(11,15,3),fnb(11,15,3),bcm(11,15,3),
     *                        acm(11,15,3)
      integer hklt,sx(3),jx(3),imat(5)
c
      integer dmat(3,500),num(350),h(3,3),balfa(3),congr(16),result(2,2)
      dimension blv(3),asign(3),alf(3)
      istamp=0
      do 1 i=1,350
      do 1 ii=1,3
    1 matse(i,ii)=0
      do 2 i=1,9001
    2 limi(i)=0
      do 5 i=1,nk1
      iel(i)=iabs(iel(i))
    5 continue
      icent=icent-1
c ---
c     call sub. lettura   lista  26  per  seminvarianti  a  una  fase
c ---
      iprea=0
      call sflxx(iprea,26,nsem1g,nsem1g,nstron,nxxe,iccd,num)
      do 10 i=1,nsem1g
      is1=num(i)
      call unpk1(is1,is2,dum1,kp)
      np=iabs(is2)
      matse(i,1)=np
      matse(i,2)=nint(dum1*100.)
      matse(i,3)=kp
      if(matse(i,3).le.0) matse(i,3)=matse(i,3)+360
      itype=phive(np)/1000
      iphi=phive(np)-itype*1000
      if(itype.ne.1) iel(matse(i,1))=-iel(matse(i,1))
   10 continue
      nsem2=0
      nsem2t=0
      ari=0.0
      duen = 2. * fnat
      sqfnat=sqrt(fnat)
c---- estract reflections from list1 & list2
      do 40 nl=1,nlis
      nord=list1(nl,1)/10
      do 41 k=1,3
   41 jhkl(k)=list2(nl,k)
      e      =list2(nl,4)/1000.0
      itype  =list2(nl,5)/1000
      iphi   =list2(nl,5)-itype*1000
      phi=iphi
      phic=ang(itype)
      isem=0
c
c-------------- informazioni utili -----------------
c
c   n1,n2,n3            numeri d'ordine del tripletto
c   nop1,nop2,nop3      operatori del tripletto
c   l1,l2,l3            segni del tripletto
c   ishi                delta-shift del tripletto
c
c-----------------------------------------------------------
      lim1=lim0(nord)
      lim2=lim0(nord+1)
      if(lim1.eq.lim2) goto 40
      iniz=lim1+1
      do 201 jcc=iniz,lim2
      call unpak3(isig(1,jcc),n1,n2,nop2)
      call unpak3(isig(2,jcc),n3,nop3,ishi)
      nop1=1
      l1=1
      l2=-isign(1,n2)
      l3= isign(1,n3)
      na2=-n2
      na3=-n3
      n2=iabs(n2)
      n3=iabs(n3)
      itypu=phive(n2)
      itypu=itypu/1000
      itypv=phive(n3)
      itypv=itypv/1000
      itype=13
      if (itypu.eq.1. or.itypv.eq.1) itype=1
      et(1)=e
      ee=iabs(iel(n2))
      et(2)=ee/1000.0
      ee=iabs(iel(n3))
      et(3)=ee/1000.0
      do 120 i=1,3
  120 hklt(i,1)=jhkl(i)
      do 130 i=1,3
  130 hklt(i,2)=little(n2,nop2,i)*l2
      do 140 i=1,3
  140 hklt(i,3)=-little(n3,nop3,i)*l3
      istamp=0
      if (nca(1).eq.n2.and.nca(2).eq.n3) istamp=1
      if (istamp.ne.0)
     * write(lo,150)       n1,(hklt(i,1),i=1,3),et(1),
     *                    na2,(hklt(i,2),i=1,3),et(2),nop2,
     *                    na3,(hklt(i,3),i=1,3),et(3),nop3,ishi
  150 format(1h ,i5,1h),3i4,f8.3,8x,2(i5,1h),3i4,f8.3,i3,5x),i5)
c
      idoub=0
      ssin = 0.0
      scos = 0.0
c ---
c---- by means of the array imat consider only
c---- indipendent symmetry operators.
c ---
      j=list1(nl,1)
      nmat=mod(j,10)
      j=list1(nl,2)
      do 61 i=1,nmat
      imat(i)=mod(j,64)
   61 j=j/64
      do 70 i=1,nmat
      j=(i-1)*5+1
      kkk=imat(i)
c----
c---- controllo se l'ordine di kkk e' 2 opppure diverso da  2
c----
      ikkk=0
      call prod1(ksmat,kkk,kkk,h)
      do 152 jc8=1,3
      do 152 jc9=1,3
      if(h(jc8,jc9).eq.ksmat(1,jc8,jc9)) goto 152
      ikkk=1
      go to 153
  152 continue
  153 continue
c    controllo  su  u1 * i = - u1 * rm
c    controllo  su  u2 * i = - u2 * rm
c           iep231 = 1 non va calcolato epsi(23,1) = epsi(7)
c           iep132 = 1 non va calcolato epsi(13,2) = epsi(9)
      iep231=0
      iep132=0
      nb1=1
      nb2=1
      do 151 jc8=1,3
  151 sx(jc8)=hklt(jc8,2)
      call equiv(sx,jx,kkk,ind)
      isum=0
      do 53 jc8=1,3
      jcb(jc8)=jx(jc8)+hklt(jc8,2)
   53 isum=isum+jx(jc8)+hklt(jc8,2)
      if(isum.ne.0) go to 54
      iep231=1
      nb1=0
   54 continue
      do 57 jc8=1,3
   57 sx(jc8)=hklt(jc8,3)
      call equiv(sx,jx,kkk,ind)
      isum=0
      do 58 jc8=1,3
   58 isum=isum+jx(jc8)+hklt(jc8,3)
      if(isum.ne.0) go to 60
      iep132=1
      nb2=0
   60 continue
c---- compute the solution vector
      do 63 i1=1,3
      do 62 j1=1,3
   62 h(i1,j1)=-ksmat(kkk,j1,i1)
   63 h(i1,i1)=h(i1,i1)+1
c---- compute the first rank seminvariant vector
c---- by means of 'cong4' (for print only).
      if (istamp.ne.0) call cong4(ksmat,msym,kkk,congr)
c---- compute the solutions of the diophantine system
c---- if idiof = 1  we do not get integer solutions.
      call diof(h,idiof,balfa,asign,alf,blv)
      if (idiof.ne.0) then
                      write(lo,*) '**** subroutine ss1 (idiof) ****'
                      write(lo,*) ' ****  programming  error  ****'
                      write(lo,*) ' sir ends in error'
                      stop 1234
                    endif
      nquar=2
      call find1(nord,phic,isbat)
      if (nquar.lt.0) go to 105
   70 continue
c---- reset reciprocal space
  105 do 110 i=1,idoub
      ipik=idopp(i)
      ist=isr(ipik)
      if (ist.gt.0) go to 110
      isr(ipik)=-ist
  110 continue
c
c--   zona riservata al calcolo della stima
c
      if(isbat.ne.0) goto 200
      sang = ssin * ssin
      cang = scos * scos
      alfa2 = sqrt(sang+cang)
c --------------------------------------------------------------
c   calcolo alfa per la seconda formula
c --------------------------------------------------------------
      alfa1 = abs(eq(1) * eq(2))
      alfa1 = alfa1/fnat
      alfa = alfa1 * alfa2
      if (itype.ne.1) alfa=alfa*2.
      if (scos.ne.0.0) goto 168
      if (ssin.gt.0.0) phicss=90.
      if (ssin.lt.0.0) phicss=270.
      if (ssin.eq.0.0) goto 200
      goto 169
  168 phicss=atan2(ssin,scos)*360./pi2
  169 iphics=phicss+sign(0.5,phicss)
      iphics=mod(iphics+3600,360)
      if (iphics.le.0) iphics=iphics+360
      if2=int(phive(n2))
      if2=if2-(if2/1000)*1000
      l2=isign(1,na2)
      if3=int(phive(n3))
      if3=if3-(if3/1000)*1000
      l3=isign(1,na3)
      iphivs=l2*if2+l3*if3
      iphivs = mod(iphivs,360)
      if (iphivs.le.0) iphivs = iphivs+360
c ------
c  controllo su alfa del seminvariante a fase ristretta
c ------
      if (itype.eq.1) go to 175
      phiu=(ang(itypu)*360.)/pi2
      iphiu=phiu+sign(0.5,phiu)
      iphiu=l2*iphiu
      phiv=(ang(itypv)*360.)/pi2
      iphiv=phiv+sign(0.5,phiv)
      iphiv=l3*iphiv
      iphic=iphiu+iphiv
      iphic=mod(iphic+3600,360)
      if (iphic.le.0) iphic=iphic+360
      idelta=iphics-iphic
      vcos=cos((idelta*pi2)/360.)
      alfar=alfa*vcos
      iphas=iphic
      if(alfar.lt.0.0) iphas=iphas+180
      iphas=mod(iphas,360)
      if(iphas.le.0) iphas=iphas+360
      alfa=abs(alfar)
      iphics=iphas
  175 continue
      jphic=iphics
      idm1=(na2+500)*1000000+(na3+500)*1000+jphic
      alpha=abs(alfa)
      if (itype.eq.1) alpha=-alpha
      if (alfa.le.0.4) go to 200
      nsem2=nsem2+1
      if(istamp.ne.0)
     *write(lo,180) nsem2,na2,(hklt(j,2),j=1,3),et(2),if2,
     1 na3,(hklt(j,3),j=1,3),et(3),if3,alfa,iphics,iphivs
  180 format(/,' *** code *** ',i4,2(i4,'* (',3i3,')',f6.2,i5),
     1 '  alfa ',e12.5,' phic = ',i5,' phiv = ',i5)
c---- store two_phase ss's in dmat
      if (nsem2.le.500) go to 847
      nsem2=nsem2-1
      call sort3s(dmat,nsem2)
      nsem2=401
  847 dmat(1,nsem2)=idm1
      dmat(2,nsem2)=alpha*1000
      dmat(3,nsem2)=iphivs
      nsem2t=nsem2t+1
      limi(nord+1)=limi(nord+1)+1
      itab(nsem2t)=idm1
      itab1(nsem2t)=alpha*1000
  200 if(istamp.ne.0) istamp=0
  201 continue
   40 continue
      do 1970 nl=2,1001
 1970 limi(nl)=limi(nl)+limi(nl-1)
      call sort3s(dmat,nsem2)
      if(nsem2.gt.400) nsem2=400
c---- riscalamento argomenti seminvarianti
      gsom2=0.
      nscal=min0(400,nsem2)
      do 2040 i=1,nscal
      jg=iabs(dmat(2,i))
      g=float(jg)/1000.
      gsom2=gsom2+g
 2040 continue
      if(jopt.ne.0) go to 2046
      do 2045 i=1,n8
      call unpak3(isig(3,i),jg,jg1,is)
      gv(i)=float(jg1)/100.
 2045 continue
 2046 continue
      call sortgs(gv,n8)
      gs=0.
      do 2047 i=1,nscal
      gs=gs+gv(i)
 2047 continue
      gk= gsom2/gs
      if(gk.lt.1.) gk=1.
      gk=gk*2.
      ii=0
      do 2060 i=1,nsem2
      alpha=float(dmat(2,i))/1000.
      alpha=alpha/gk
      if(icent.eq.0)alpha=alpha*0.8
      if(icent.eq.1)alpha=alpha*0.6
      if(abs(alpha).gt.6.00) alpha=6.00
      if(abs(alpha).lt.0.4) goto 2060
      ii=ii+1
      dmat(1,ii)=dmat(1,i)
      dmat(2,ii)=alpha*1000.
      dmat(3,ii)=dmat(3,i)
 2060 continue
      nsem2=ii
c      inserire  blocco  istruzioni  da  opts.f
      write(lo,16)
   16 format(///,120('+'),//,
     1 39x,'***   two-phase seminvariants section   ***',//)
      write(lo,2215)
 2215 format(20x,'First representation formula will be used',/)
      write(lo,2217) jenu1,soge1
 2217 format(20x,'n. of reflections to search s.s.i. = ',i5,
     *'  with  /E/ .ge.', f7.3,/)
      call sors2(dmat,ari,nari,numrp,foms2,nusba)
      istor=numrp+nsem2g
      if(istor.eq.0) return
      result(2,1)=nsem2t
      result(2,2)=istor
      if (knw.eq.0.or.nari.eq.0.or.iprin.eq.0) go to 1510
      ari=ari/float(nari)
      write(lo,2222) ari
 2222 format(60x,'ari = ',f8.4,/)
      write(lo,2223) foms2
 2223 format(60x,'foms2 = ',f8.4,/)
c---- prints the number of seminvariants
 1510 if(iprin.ne.0) then
                       write(lo,333) numrp
                       if (nsem2g.ne.0) write(lo,334) nsem2g
                       if(knw.eq.0) goto 4500
c----
c   stampa statistiche
c----
                       write(lo,5500) nusba
 5500 format(//,1x,'serial number of the first wrong ',
     * 'relationship =',i5,//)
                       if(icent-1)4300,4400,4400
c--  stampa il test (non centro)
CHANGE RIC-OX-98: Remove dummy argument from nstst
 4300 call nstst
C 4300 call nstst(0)
      go to 4500
c--  stampa il test (centro)
CHANGE RIC-OX-98: Remove dummy argument from stst
 4400 call stst
C 4400 call stst(0)
 4500 continue
                   endif
  333 format(20x,'n. of first rank s.s.i   (restricted-phase)   =',i6)
  334 format(20x,'n. of first rank s.s.i.    (general phase)    =',i6)
      return
      end
c----------------------------------------------------------------------
      subroutine find1(nord,phic,isbat)
      common /dirg/ jss1,jopt,jss2
      common /dir1/ jboth,jrepr,jeli1,jenu1,jknum,soge1,sogk
      common /dir2/ jenu2,glim,soge2,eplim,nca(2)
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
      common/ureq/ihx(3),ksigma,knw,jpart,jtran,ipolar,nonos,iprin,iflag
c
      common /inp/  natom,fnat,satm,dumy
      common /inv/  invma(96,3,3),idivv(48)
      common /cost/ pi2,jxa,jxb,jxx,nk1,lfl,nrif,mult,nsem,itype,ang(24)
      common /choi/ mm,iimax,jmax,nsj,jtable(8,16),invet(48)
      common /pro/  jvarma(3,3),kx(3),idoub,kkk,sump(2),icros,
     * jhkl(3),e,scr2(2),ns,sr2(2),  hklt(3,3),nsemc,nsemg
      common /pross2/ nquar,e2,et(3),ishi,eq(10),epsi(10),iep231,iep132,
     1 jdelta,duen,ssin,scos,istamp,nb1,nb2,nb3,nb4,ns1,ns2,ns3,ns4,ikkk
     2 ,nsu(2),ess(4),jcb(3),sden
      common/xdata/isr(100000),matse(350,3),little(350,24,3),limi(9001),
     1 idopp(1000),iel(350),phive(350),list1(1000,2),list2(1000,5),nlis,
     2 gq(8000),gv(8000),idummy(48),dummpc(84000)
      integer var1(3),var2(3),stlh1,sx(3),jx(3),jxc(3)
      integer isegn(3),incr(3),inf(3),sup(3),hklt
      dimension esp(2)
c
      indt=kkk
      ehkl=e
      eps1=ehkl*ehkl-1.0
      stlh1=iabs(jhkl(1))+iabs(jhkl(2))+iabs(jhkl(3))
      ifla1=0
      ifla2=0
      ifla3=0
      if (nquar.eq.1) go to 7
      isbat=0
      e51=e
      do 4 i=1,3
    4 jx(i)=hklt(i,2)
      call equiv(jx,sx,kkk,ind)
      do 1 i=1,3
    1 jxc(i)=sx(i)
      do 3 i=1,3
    3 sx(i)=sx(i)+hklt(i,3)
      call indr(sx,ind)
      if (ind.le.0) go to 7
      e52=isr(ind)
      e52=e52/1000.0
      if (abs(e52).lt.e51) go to 7
      isbat=1
      return
    7 do 8 i=1,3
      isegn(i)=kx(i)
      var1(i)=i
      inf(i)=0
      sup(i)=0
    8 var2(i)=0
      do 10 j=1,3
      do 10 i=1,3
      if (jvarma(i,j).ne.0) var2(j)=j
   10 continue
      do 20 i=1,3
      if (var2(i).eq.0) go to 20
      max=ihx(i)
      ihxi=ihx(i)
      inf(i)=max0(-max-kx(i),-ihxi)
      sup(i)=min0(max+kx(i),ihxi)
   20 continue
      iinf1=inf(1)
      isup1=sup(1)
      do 50 i=iinf1,isup1
      iinf2=inf(2)
      isup2=sup(2)
      if (var2(1).ne.var2(2)) go to 21
      if (var2(1).eq.0) go to 21
      ifla1=1
      iinf2=0
      isup2=0
   21 continue
      do 40 j=iinf2,isup2
      jjj=j
      if (ifla1.eq.1) jjj=i
      iinf3=inf(3)
      isup3=sup(3)
      if (var2(1).ne.var2(3)) go to 22
      if (var2(1).eq.0) go to 22
      ifla2=1
      iinf3=0
      isup3=0
      go to 23
   22 continue
      if (var2(2).ne.var2(3)) go to 23
      if (var2(2).eq.0) go to 23
      ifla3=1
      iinf3=0
      isup3=0
   23 continue
      do 30 l=iinf3,isup3
      i1=i
      j1=jjj
      l1=l
      if (ifla2.eq.1) l1=i1
      if (ifla3.eq.1) l1=j1
      incr(1)=i1
      incr(2)=j1
      incr(3)=l1
      do 250 ii=1,3
      var1(ii)=0
      do 250 jj=1,3
  250 var1(ii)=var1(ii)+jvarma(ii,jj)*incr(jj)
      do 25 k=1,3
      kx(k)=var1(k)+isegn(k)
      if (iabs(kx(k)).gt.ihx(k)) go to 29
   25 continue
      e2=-999.99
      if (kx(1).eq.0.and.kx(2).eq.0.and.kx(3).eq.0) go to 29
      call indr(kx,ind2)
      if (ind2.le.0.0) go to 29
      ist=isr(ind2)
c
c---- if (e.lt.0.0) then we have considered the reflection yet
c----    (ist=e*1000)
c
      if (ist.lt.0) go to 29
c
c---- rende negativo il valore di  'e'  e di tutti gli  'e'
c---- equivalenti attraverso  'equi'  in modo che in seguito
c---- non venga piu' utilizzato. inoltre memorizza l'indirizzo
c---- in idopp in modo da resettare il reciproco una volta
c---- completati i calcoli per il s.s.i. in esame.
c
      e2=float(ist)/1000.0
      if (istamp.ne.0) write(lo,6999) kx,e2,kkk,ikkk
 6999 format(1h ,' kx',3i5,' e2',f7.2,' kkk',i5,' ikkk',i5)
      call mark(kx,nord,idoub,jhkl)
      if (iflag.eq.1) go to 80
      icros=icros+1
      eps2=e2*e2-1.0
      if (e2.eq.ehkl) eps2=(eps2-2.0)/3.0
c
c---- se nquar = 1 ( stima ss1 )
c---- se nquar = 2 ( stima ss2 )
c
      if(nquar.eq.1) goto 291
c---- marco -h1rm nel caso in cui rm e' di ordine 2
      do 283 jc8=1,2
  283 nsu(jc8)=0
      do 285 jc8=1,4
  285 ess(jc8)=0.0
      call quart (nord)
      go to 2828
  291 prod=0.0
      do 295 nn=1,3
  295 prod=prod+kx(nn)*tmat(indt,nn)
      prod=pi2*prod
      esp(1)=cos(phic-prod)
      esp(2)=sin(phic-prod)
      coef=1.0
      if (e2.gt.0.4.and.e2.lt.0.9) go to 28
c
c---- check over sin(theta)/lambda
c
      icodh=iabs(kx(1))+iabs(kx(2))+iabs(kx(3))
      icodh=icodh*stlh1
c
c---- if ( h2 = h/2 )   then   coef = 1/2
c----                   else   coef =  1
c
      if (jhkl(1)/2.eq.kx(1).and.
     *    jhkl(2)/2.eq.kx(2).and.
     *    jhkl(3)/2.eq.kx(3)) coef=0.5
      if (icodh.le.20) go to 28
      if (jrepr.eq.2) call secrep(esp,ehkl,e2,eps2,eps1,nord,coef)
      go to 290
   28 continue
      sr2(1) = sr2(1)+coef*eps2*esp(1)
      sr2(2) = sr2(2)+coef*eps2*esp(2)
  290 continue
      sump(1)=sump(1)+coef*eps2*esp(1)
      sump(2)=sump(2)+coef*eps2*esp(2)
      if (jrepr.eq.1) sr2(1)=sr2(1)+coef*eps2*esp(1)
      if (jrepr.eq.1) sr2(2)=sr2(2)+coef*eps2*esp(2)
 2828 continue
      if (nquar.eq.1) go to 29
c 
      a = epsi(3) + epsi(6)
      if(ikkk.eq.0) a = a+epsi(7)+epsi(9)
      b = epsi(3)*epsi(5)+epsi(6)*epsi(8)+2*epsi(3)*epsi(6)
      if(iep231.eq.0) b = b + 2*epsi(3)*epsi(7)
      if(iep132.eq.0) b = b + 2*epsi(6)*epsi(9)
      if(ikkk.eq.0) b = b + 2 * (epsi(7)*ess(1) + epsi(9)*ess(2) +
     * ess(2)*ess(3) + ess(1)*ess(4))
      h4e31= h4(eq(3))
      h4e32= 0.0
      if(epsi(6).ne.0.0) h4e32= h4(eq(6))
      c1 = epsi(3)*epsi(6) + epsi(3)*epsi(7) + epsi(6)*epsi(9)
      c2 = c1*epsi(1)
      c3 = c1*epsi(2)
      proe = epsi(1)*epsi(2)
      c4 = proe * epsi(5)
      c5 = proe * epsi(8)
      c = 0.25*h4e31*epsi(5) +0.25*h4e32*epsi(8) + c2 +
     * c3 + c4 + c5
      if(ikkk.ne.0) goto 65
      c1kkk=0.0
      if(epsi(9).ne.0.0) c1kkk=c1kkk+0.25*h4(eq(9))*epsi(5)
      if(epsi(7).ne.0.0) c1kkk=c1kkk+0.25*h4(eq(7))*epsi(8)
      c2kkk = epsi(1)*epsi(9)*ess(2) + epsi(1)*epsi(7)*ess(1)
     *      + epsi(2)*epsi(9)*ess(2) + epsi(2)*epsi(7)*ess(1)
      c3kkk = epsi(1)*ess(2)*ess(3)  + epsi(1)*ess(1)*ess(4)
     *      + epsi(2)*ess(2)*ess(3)  + epsi(2)*ess(1)*ess(4)
      c = c + c1kkk + c2kkk + c3kkk
   65 continue
      if (c.lt.0.0) c = 0.0
      qj =  a + b
      deltaj = jdelta * 15.0
      argj=deltaj*pi2/360.
      ssin = ssin + qj * sin(argj)
      scos = scos + qj * cos(argj)
      if(istamp.ne.0)write(lo,70)  qj,argj,ssin,scos
   70 format('0  qj, deltaj ',2f10.3,' ssin,scos ',2f10.3)
   29 continue
      if (ifla2.eq.1.and.ifla1.eq.1) go to 50
      if (ifla2.eq.1) go to 40
      if (ifla3.eq.1) go to 50
   30 continue
      if (ifla1.eq.1) go to 50
   40 continue
   50 continue
   80 continue
      if (iflag.eq.1) nquar=-nquar
      return
      end
c----------------------------------------------------------------------
      subroutine quart(nord)
c
      common /dir1/ jboth,jrepr,jeli1,jenu1,jknum,soge1,sogk
      common /dir2/ jenu2,glim,soge2,eplim,nca(2)
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/ureq/ihx(3),ksigma,knw,jpart,jtran,ipolar,nonos,iprin,iflag
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
c
      common /pro/  jvarma(3,3),kx(3),idoub,kkk,sump(2),icros,
     * jhkl(3),e,src2(2),ns,sr2(2),  hklt(3,3),nsemc,nsemg
      common /pross2/ nquar,e2,et(3),ishi,eq(10),epsi(10),iep231,iep132,
     1 jdelta,duen,ssin,scos,istamp,nb1,nb2,nb3,nb4,ns1,ns2,ns3,ns4,ikkk
     2 ,nsu(2),ess(4),jcb(3),sden
      common/xdata/isr(100000),matse(350,3),little(350,24,3),limi(9001),
     1 idopp(1000),iel(350),phive(350),list1(1000,2),list2(1000,5),nlis,
     2 gq(8000),gv(8000),idummy(48),dummpc(84000)
      integer hklt,sx(3),jx(3),jjx(3),hklq(10,3),hkls(4,3)
      dimension eqs(4)
c
c-------------- informazioni utili ------------------------------------
c
c   hklt(3,3)           h,k,l, della tripletta memorizzati per colonna
c   et(3)               e della tripletta
c
c----------------------------------------------------
c
      iq=0
      nin=1
      nfi=4
      call azzero(eqs,ess,nin,nfi)
      do 5 jc8=1,4
      do 5 jc9=1,3
    5 hkls(jc8,jc9)=0
c
c-- caricamento della matrice hklq relativamente ai base
c
      do 10 j=1,3
   10 hklq(1,j)=hklt(j,2)
      do 20 j=1,3
   20 hklq(2,j)=hklt(j,3)
      do 30 j=1,3
   30 hklq(3,j)=-kx(j)
c----
c-- calcolo di h1 * rm  ( quarto base del quartetto)
c----
      call equiv(kx,sx,kkk,ind)
      do 40 j=1,3
   40 hklq(4,j)=sx(j)
c
c ---
c    controllo  su  h1 * i = - h1 * rm
c           iep231 = 1 non va calcolato epsi(23,1) = epsi(7)
c           iep231 = 1 anche quando  u1 * i = - u1 * rm
c ---
      nb3=1
      if(istamp.ne.0)write(lo,62)
   62 format(/)
      if(iep231.ne.0) go to 66
      iep231=0
      isum=0
      do 63 j=1,3
   63 isum=isum-hklq(3,j)+hklq(4,j)
      if (istamp.ne.0) write(lo,65)(hklq(3,j),j=1,3),(hklq(4,j),j=1,3)
   65 format('  controllo su h1*i=-h1*rm ',3i5,10x,3i5)
      if(isum.ne.0) go to 64
      iep231=1
   64 continue
   66 if (iep231.ne.0) nb3=0
c
c-- calcolo del deltashift del quartetto
c   delh1 = h1 * tm
c
      delh1=0
      delh1=kx(1)*tmat(kkk,1)+kx(2)*tmat(kkk,2)+kx(3)*tmat(kkk,3)
      kdelh1=nint(delh1*24.)
      kdelh1=mod(kdelh1,24)
      if(kdelh1.lt.0) kdelh1=kdelh1+24
      jdelta=-ishi+kdelh1
c
c-- caricamento della matrice hklq relativamente ai cross
c
      do 70 j=1,3
   70 hklq(5,j)=hklq(1,j)+hklq(2,j)
c ---
c  calcolo di -h2 * rbeta e controllo esistenza del suo e
c ---
      do 80 j=1,3
   80 hklq(6,j)=hklq(1,j)+hklq(3,j)
      do 85 j=1,3
   85 sx(j)=hklq(6,j)
      call indr (sx,ind)
      if (ind.gt.0) go to 86
      iq=1
      go to 88
   86 if(isr(ind).ne.-1000) goto 87
      iq=1
      goto 88
c ----------------------------------------------------------
c    controllo  su  h2rbeta * i = - h2rbeta * rm
c           iep132 = 1 non va calcolato epsi(13,2) = epsi(9)
c           iep132 = 1 anche quando  u2 * i = - u2 * rm
c ----------------------------------------------------------
   87 nb4=1
      if(istamp.ne.0)write(lo,62)
      if(iep132.ne.0) go to 166
      iep132=0
      isum=0
      do 162 j=1,3
  162 jx(j)=-hklq(6,j)
      call equiv(jx,sx,kkk,ind)
      do 163 j=1,3
  163 isum=isum-hklq(6,j)+sx(j)
      if (istamp.ne.0) write(lo,165)(hklq(6,j),j=1,3),(sx(j),j=1,3)
  165 format('  controllo su h2rbeta*i=-h2rbeta*rm ',3i5,4x,3i5)
      if(isum.ne.0) go to 164
      iep132=1
  164 continue
  166 if(iep132.ne.0) nb4=0
c----
c----  calcolo  u(23,1)
c----
   88 do 89 j=1,3
      hklq(7,j)=hklq(2,j)+hklq(3,j)
   89 jx(j)=hklq(7,j)
c----
c---- marco  u(s,1)   nel  caso  che  rm  sia  di  ordine  2
c----
      if(istamp.ne.0) write(lo,2323)jcb
 2323 format('  u1(i+rm)  ',3i5)
      if(ikkk.ne.0)  goto 91
      call equiv(jx,sx,kkk,ind)
      if(ind.le.0) goto 91
c----
c---- h1 + u1(i+rm)
c----
      if( (nb1+nb3).ne.2)  goto 200
      nsu(1)=1
      do 196 jc8=1,3
  196 hkls(1,jc8)=kx(jc8)+jcb(jc8)
      do 198 jc8=1,3
  198 sx(jc8)=hkls(1,jc8)
      call indr(sx,ind)
      if(ind.le.0) goto 200
      e7=isr(ind)
      e7=e7/1000.
      eqs(1)=e7
      ess(1)=e7*e7-1.
  200 continue
      call mark(sx,nord,idoub,jhkl)
c----
c---- calcolo u(12,2)
c----
   91 do 92 j=1,3
   92 sx(j)=hklq(1,j)
      call equiv(sx,jx,kkk,ind)
      do 93 j=1,3
   93 hklq(8,j)=jx(j)+hklq(2,j)
c----
c---- calcolo u(13,2)
c----
      do 94 j=1,3
      hklq(9,j)=jx(j)+hklq(6,j)
   94 jx(j)=-hklq(9,j)
c----
c---- marco  -u(13,2)   nel  caso  che  rm  sia  di  ordine 2
c----
      if(ikkk.ne.0)  goto 96
      if(iq.eq.1) goto 96
      call mark(jx,nord,idoub,jhkl)
      if(istamp.ne.0)write(lo,2325) jx
2325  format(' asterisco -u(13,2) ', 3i8)
c----
c---- -h2rbeta + u1(i+rm)
c----
      if( (nb1+nb4).ne.2)  goto 210
      nsu(2)=1
      do 202 jc8=1,3
  202 hkls(2,jc8)=hklq(6,jc8)+jcb(jc8)
      do 204 jc8=1,3
  204 sx(jc8)=hkls(2,jc8)
      call indr(sx,ind)
      if(ind.le.0) goto 210
      e7=isr(ind)
      e7=e7/1000.
      eqs(2)=e7
      ess(2)=e7*e7-1.
  210 continue
c----
c---- marco   u(13,2)rm    nel  caso  che  rm  sia  di  ordine 2
c----
      do 95 jc8=1,3
   95 jx(jc8)=+hklq(9,jc8)
c----
c---- calcolo u(23,2)
c----
   96 do 97 j=1,3
   97 hklq(10,j)=hklq(2,j)+hklq(6,j)
c
      nin=5
      nfi=10
      call azzero (eq,epsi,nin,nfi)
      eq(1)=et(2)
      eq(2)=et(3)
      eq(3)=e2
      eq(4)=e2
      do 98 i=1,4
   98 epsi(i)=eq(i)*eq(i)-1.
      nin=5
      nfi=10
      if(iq.eq.1) nfi=7
      do 100 j=nin,nfi
c --------
c   iep231 = 1 implica epsi(23,1) = epsi(7) = 0.0
c   iep132 = 1 implica epsi(13,2) = epsi(9) = 0.0
c --------
      if (iep231.ne.0.and.j.eq.7) go to 100
      if (iep132.ne.0.and.j.eq.9) go to 100
      do 99 i=1,3
   99 sx(i)=hklq(j,i)
      call indr(sx,ind)
      if (ind.le.0) go to 100
      e7=isr(ind)
      eq(j)=e7/1000.0
      epsi(j)=eq(j)*eq(j)-1.
  100 continue
c----
c----  caso in cui  rm  risulta essere di ordine  2
c----
      if(ikkk.ne.0) goto 240
      if(nsu(2).eq.0) goto 230
      if(iq.eq.1) goto 230
c----
c----   u(13,2) + u1(i+rm)
c----
      do 212 jc8=1,3
  212 hkls(3,jc8)=hklq(9,jc8)+jcb(jc8)
      do 214 jc8=1,3
  214 sx(jc8)=hkls(3,jc8)
      call indr(sx,ind)
      if(ind.le.0) goto 230
      e7=isr(ind)
      e7=e7/1000.
      eqs(3)=e7
      ess(3)=e7*e7-1.
  230 continue
      if(nsu(1).eq.0) goto 240
c----
c----   u(23,1) - u1(i+rm)
c----
      do 242 jc8=1,3
  242 hkls(4,jc8)=hklq(7,jc8)-jcb(jc8)
      do 244 jc8=1,3
  244 sx(jc8)=hkls(4,jc8)
      call indr(sx,ind)
      if(ind.le.0) goto 240
      e7=isr(ind)
      e7=e7/1000.
      eqs(4)=e7
      ess(4)=e7*e7-1.
  240 continue
      if(abs(eqs(2)).eq.abs(eq(6)).and.
     *   abs(eqs(3)).eq.abs(eq(3)) )    goto 247
      if(abs(eqs(1)).eq.abs(eq(3)).and.
     *   abs(eqs(4)).eq.abs(eq(6)) )    goto 248
      goto 245
  247 eqs(2)=-1.0
      ess(2)=0.0
      eqs(3)=-1.0
      ess(3)=0.0
      goto 245
  248 eqs(1)=-1.0
      ess(1)=0.0
      eqs(4)=-1.0
      ess(4)=0.0
  245 if(istamp.ne.0)
     *write(lo,250) ((hklq(i,j),j=1,3),eq(i),i=1,7),jdelta,kdelh1
      do 112 i=1,3
  112 sx(i)=+hklq(1,i)
      call equiv(sx,jx,kkk,ind)
      if (iq.eq.1) go to 300
      do 114 i=1,3
  114 sx(i)=-hklq(6,i)
      call equiv(sx,jjx,kkk,ind)
      if(istamp.ne.0)
     * write(lo,252)jx,(hklq(2,j),j=1,3),(hklq(6,j),j=1,3),jjx,
     * ((hklq(i,j),j=1,3),eq(i),i=8,10)
      if(istamp.ne.0)write(lo,251)
     * ((hkls(i,j),j=1,3),eqs(i),i=1,4)
  250 format(1h ,7(3i3,f7.2,1h*),i4,i4)
  251 format(1h ,51x,4(3i3,f7.2,1h*))
  252 format(1h ,4(3i3,7x,1h*),3(3i3,f7.2,1h*),i4)
  300 return
      end
c----------------------------------------------------------------------
      subroutine azzero  (eq,epsi,nin,nfi)
      dimension eq(10),epsi(10)
      do 90 i=nin,nfi
      eq(i)=-1.0
   90 epsi(i)=0.0
      return
      end
c--------------------------------------------------------------------
      subroutine sort3s(dmat,nsem2)
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/ureq/ihx(3),ksigma,knw,jpart,jtran,ipolar,nonos,iprin,iflag
      integer dmat(3,500)
c
      if (nsem2.gt.1) go to 100
      if (nsem2.le.0) write(lo,110)
      iflag=1
      return
  100 continue
      k=1
    1 k=2*k
      if (k.lt.nsem2) go to 1
      k=k/2
    7 l=nsem2-k
      j=1
    6 if (j.gt.l) go to 2
      i=j
    5 ik=i+k
      m=i
    4 ix=iabs(dmat(2,m))
      mj=m+k
      iy=iabs(dmat(2,mj))
      if (ix.ge.iy) go to 3
      icom=dmat(1,m)
      dmat(1,m)=dmat(1,mj)
      dmat(1,mj)=icom
      icom=dmat(2,m)
      dmat(2,m)=dmat(2,mj)
      dmat(2,mj)=icom
      icom=dmat(3,m)
      dmat(3,m)=dmat(3,mj)
      dmat(3,mj)=icom
      m=m-k
      i=ik
      if (m.gt.0) go to 4
    3 i=i+k
      if (i.le.l) go to 5
      j=j+1
      if (j.le.k) go to 6
    2 k=k/2
      if (k.gt.0) go to 7
      return
  110 format(//,' **********  warning  **********',/
     1         ,'     no seminvariants exist     ',/
     2         ,'        program is killed       ',/
     3         ,'********************************',//)
      end
c-----------------------------------------------------------------------
      subroutine sors2(dmat,ari,nari,numrp,foms2,nusba)
c---- sort seminvariants stored in 'dmat'
      common /dirg/ jss1,jopt,jss2
      common /dir1/ jboth,jrepr,jeli1,jenu1,jknum,soge1,sogk
      common /dir2/ jenu2,glim,soge2,eplim,nca(2)
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
      common/ureq/ihx(3),ksigma,knw,jpart,jtran,ipolar,nonos,iprin,iflag
c
      common /ss2c/ ip,ku(3),eu,kva(3),ev,kn,epsu,epsv,nsem2,nsem2g
      common /inp/  natom,fnat,satm,dumy
      common /inv/  invma(96,3,3),idivv(48)
      common /cost/ pi2,jxa,jxb,jxx,nk1,lfl,nrif,mult,nsem,itype,ang(24)
      common /choi/ mm,iimax,jmax,nsj,jtable(8,16),invet(48)
      common /pro/  jvarma(3,3),kx(3),idoub,kkk,sump(2),icros,
     * jhkl(3),e,scr2(2),ns,sr2(2),jhimrn(3,3),nsemc,nsemg
      common/xdata/isr(100000),matse(350,3),little(350,24,3),limi(9001),
     1 idopp(1000),iel(350),phive(350),list1(1000,2),list2(1000,5),nlis,
     2 gq(8000),gv(8000),idummy(48),dummpc(84000)
      common/tst/nt8,ar(26),nn(11,26,3),pp(11,26,3)
      common /nctst/nt9,br(15),nb(11,15,3),fnb(11,15,3),bcm(11,15,3),
     *                        acm(11,15,3)
      character rescha(13)*9,linex(2)*9
      integer num(400),hklu(3),hklv(3),jtype(400)
      dimension nrif1(400),nrif2(400),iphi(400),alpha(400)
      integer dmat(3,500)
      data iplus,iblan,istar/1h+,1h ,1h*/
      data ibla2,iccc,ibbn/2h  ,2hrp,2h n/
      data rescha/'   any   ','         ','  30,210 ','  45,225 ',
     *'  60,240 ','         ','  90,270 ','         ',' 120,300 ',
     *' 135,315 ',' 150,330 ','         ','   0,180 '/
c
      vec(x) = amin1((x+0.4807)*x/((x+0.8636)*x +
     *  1.3943),1.0)
c
      if (nsem2.eq.0) then
                      write(lo,10)
   10 format(//,' **********  warning  **********',/
     1         ,' *    no seminvariants exist   * ',/
     2         ,' *******************************',//)
                      return
                     endif
c--  prepara il buffer per il test non centro
      if(icent.eq.0) call nclrt
c--  prepara il buffer per il test centro
      if(icent.eq.1) call clrt
      nusba=0
      nari=0
      ns2f=0
      igg=0
      do 20 i=1,nsem2
      ia=1
      ipk=dmat(2,i)
      if (ipk) 18,19,19
   18 ia=-1
      ipk=iabs(ipk)
   19 alpha(i)=float(ipk)/1000.0
      jtype(i)=ia
      iak=dmat(1,i)
      ia=1
      if (iak.lt.0) ia=-1
      iak=iabs(iak)
      nr1=iak/1000000
      nrif1(i)=nr1-500
      jj=nr1*1000000
      nr2=(iak-jj)/1000
      nrif2(i)=nr2-500
      iphi(i)=iak-jj-nr2*1000
      nrif2(i)=nrif2(i)*ia
   20 continue
      call sorts(num,alpha,nsem2,400)
      write(lo,110)
      if (knw.eq.0) then
                      write(lo,115)
                    else
                      write(lo,118)
                    endif
      conv=pi2/360.0
      test=conv*90
      ctest=cos(test)
      nsem2g=0
      numrp=0
      iconts=min0(10,nsem2)
c ++++++++++++++++++++++++++++++++++++++++++++++++++++
      foms2=0.0
      sg2=0.0
c ++++++++++++++++++++++++++++++++++++++++++++++++++++
      do 30 i=1,nsem2
      j=num(i)
      jpont1=iabs(nrif1(j))
      jpont2=iabs(nrif2(j))
      i1=nrif1(j)
      itypu=phive(jpont1)
      itypu=itypu/1000
      write(linex(1),4056)rescha(itypu)
 4056 format(a9)
      iphiu=phive(jpont1)-itypu*1000
      eu=iel(jpont1)
      eu=eu/1000.0
      isegn=iplus
      ise=1
      i2=nrif2(j)
      itypv=phive(jpont2)
      itypv=itypv/1000
      write(linex(2),4056)rescha(itypv)
      iphiv=phive(jpont2)-itypv*1000
      ev=iel(jpont2)
      ev=ev/1000.0
      do 25 k=1,3
      hklu(k)=little(jpont1,1,k)
      hklv(k)=little(jpont2,1,k)
   25 continue
      ig2=iccc
      prob=0.5
      ll=jtype(j)
      if (ll.lt.0) go to 26
      numrp=numrp+1
      ig1=ibla2
      prob=0.5+0.5*tanh(alpha(i))
      go to 27
   26 continue
      nsem2g=nsem2g+1
      igg=1
      ig1=ibbn
   27 iphit=dmat(3,j)
      iphic=iphi(j)
      dphi=iphit-iphic
      if (dphi.lt.0.0) dphi=iphic-iphit
      dphi=dphi*conv
      cdphi=cos(dphi)
      ias=iblan
      itest=1
      if (cdphi.gt.ctest) go to 28
      itest=-1
      ias=istar
   28 ari=ari+(prob-0.5)*itest
      nari=nari+1
c +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
c   calcolo  foms2  come  da foms
c +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      delta=iphit-iphic
      delta=amod(delta+36000,360.)
      foms2=foms2+alpha(i)*cos(delta*conv)
      sg2=sg2+alpha(i)*vec(alpha(i))
c +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      eu=abs(eu)
      ev=abs(ev)
      if(i.le.iconts) then
                       if(knw.eq.0) then
                                 write(lo,210)i1,(hklu(k),k=1,3),eu,
     1                               linex(1),i2,(hklv(k),k=1,3),ev,
     2                               linex(2),iphic,alpha(i)
                                    else
                                 write(lo,212)i1,(hklu(k),k=1,3),eu,
     1                                 iphiu,i2,(hklv(k),k=1,3),ev,
     2                                 iphiv,iphit,iphic,alpha(i),ias
                                    endif
                      endif
  210 format(9x,i4,1h),1x,3i3,f7.3,a9,
     1   1x,i4,1h),1x,3i3,f7.3,a9,4x,i4,3x,f9.3)
  212 format(9x,i4,1h),1x,3i3,f7.3,2x,i4,
     1 4x,i4,1h),1x,3i3,f7.3,2x,i3,6x,i4,5x,i4,2x,f9.3,a1)
c----
c      call of stat subroutine
c----
      if (knw.eq.1) call stats(alpha(i),iphit,iphic,ias,nusba,i)
      if (alpha(i).ge.glim) ns2f=ns2f+1
      ise=1
      call jpack2(dmat(1,i),dmat(2,i),i1,ise,i2,alpha(i),iphic)
   30 continue
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      if(sg2.ge.0.0001) foms2=foms2/sg2
      if(nsem2.gt.iconts) write(lo,230)
      write(lo,240)
      if (igg.eq.1.and.iprin.ne.0) write(lo,250)
      if (knw.eq.1) write(lo,245)
c ---
c     call sub. scrittura lista 27 : seminvarianti a due fasi
c ---
      iprea=0
      call frmxx(iprea,27,nsem2,nsem2,ns2f,nxxe,iccd,dmat)
      iprin=0
      return
  110 format(//,26x,' List of two-phase structure',
     2 ' seminvariants estimated',//)
  115 format(10x,'code     H(1)     E   ph.rest.',
     2        2x,'code     H(2)     E   ph.rest.',
     3 '    phase      alpha',/,8x,86(1h-))
  118 format(10x,'code     H(1)      E  ph.true',
     2        3x,'code     H(2)      E  ph.true',
     3 '  ph.true  ph.calc    alpha',/,8x,90(1h-))
  230 format(/,14x,' .... and so on',/)
  240 format(1h ,/)
  245 format(20x,'seminvariants marked with * are wrongly estimated',/)
  250 format(20x,'for nrp seminvariants alpha is equal to  1/2',
     1'  the argument of  io bessel  function',//)
      end
c----------------------------------------------------------------------
      subroutine stats(g,iphit,iphic,ias,nusba,i)
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
c
      common /erl/ ksmat(48,3,3),tmat(48,3),nt(16),jsys,ngen
     *,irot(48,48),jsvet(10),isvet(8),nori,modul(3),nss(3)
      common/sym2/msym,nsym2,nsym,icent,s3s2
c
      common/tst/nt8,ar(26),nn(11,26,3),pp(11,26,3)
      common /nctst/nt9,br(15),nb(11,15,3),fnb(11,15,3),bcm(11,15,3),
     *                        acm(11,15,3)
      common /cost/ pi2,jxa,jxb,jxx,nk1,lfl,nrif,mult,nsem,itype,ang(24)
      data ibl/1h /
      b=float(iphit)*pi2/360.
      a=cos(b)
      if (icent.gt.0) go to 4200
      g2=g
      call besse(g2,coat)
c--  esegue test non-centro
      call nctet(g2,coat,a,1)
      if(nusba.ne.0.or.ias.eq.ibl)go to 4001
      nusba=i
      go to 4001
 4200 gg=g
      an=a*g
      call sctst(gg,an,1)
      if(nusba.ne.0.or.ias.eq.ibl)go to 4001
      nusba=i
 4001 continue
      return
      end
c-----------------------------------------------------------------------
      subroutine dirsem(ier)
      character line*80,dire*80,diret*80
      character blank,digit*12,card(100)*80,ffile*80
      common /comdir/ icomq(200,2),maxcom,ipcom,ipdir,icomat
      common /chara/ blank,digit,card,ffile
      common /dirg/ jss1,jopt,jss2
      common /dir1/ jboth,jrepr,jeli1,jenu1,jknum,soge1,sogk
      common /dir2/ jenu2,glim,soge2,eplim,nca(2)
c     input/output units, title, flags
      common/unit/ln,lo,ifour,jrel,iscra,jhost,itle(20),jgrap
      common/trig/sint(450),pi,twopi,dtor,rtod
      common/ureq/ihx(3),ksigma,knw,jpart,jtran,ipolar,nonos,iprin,iflag
      dimension vet(40),ivet(40)
c
c-- set default values
      iprin=0
      jss1=1
      jss2=1
      jopt=0
      jboth=0
      jenu1=0
      jenu2=0
      jeli1=0
      soge1=0.0
      soge2=1.4
      sogk=0.0
      jknum=0
      eplim=2.0
      glim=0.8
      jrepr=2
      istop=0
      nca(1)=0
      nca(2)=0
      ic=0
      icmax=icomq(icomat,2)
c
  100 continue
      ic=ic+1
      if (ic.gt.icmax) go to 9000
      ipdir=ipdir+1
      line=card(ipdir)
      diret=line
      call cutst(line,lenp,dire,lend)
      call lcase(dire)
c-- directives with numeric parameters
      iopt=0
      call getnum(line,vet,ivet,iv,iopt)
      if (iopt.eq.-1) go to 8000
      if (dire(1:3).eq.'end') go to 100
      if (dire(1:4).eq.'nss1') then
          if (iv.ne.0) go to 8000
          jss1=0
          go to 100
          endif
      if (dire(1:4).eq.'nss2') then
          if (iv.ne.0) go to 8000
          jss2=0
          go to 100
          endif
      if (dire(1:4).eq.'nopt') then
          if (iv.ne.0) go to 8000
          jopt=0
          go to 100
          endif
      if (dire(1:4).eq.'firs') then
          if (iv.ne.0) go to 8000
          jrepr=1
          go to 100
          endif
      if (dire(1:4).eq.'nrs1') then
          if (iv.ne.1) go to 8000
          jenu1=ivet(1)
          go to 100
          endif
      if (dire(1:4).eq.'list') then
          if (iv.ne.0) go to 8000
          jeli1=1
          go to 100
          endif
      if (dire(1:4).eq.'both') then
          if (iv.ne.0) go to 8000
          jboth=1
          go to 100
          endif
      if (dire(1:4).eq.'prin') then
          if (iv.ne.1) go to 8000
          iprin=ivet(1)
          go to 100
          endif
      if (dire(1:4).eq.'numk') then
          if (iv.ne.1) go to 8000
          numk=ivet(1)
          go to 100
          endif
      if (dire(1:4).eq.'epli') then
          if (iv.ne.1) go to 8000
          eplim=vet(1)
          go to 100
          endif
      if (dire(1:4).eq.'glim') then
          if (iv.ne.1) go to 8000
          glim=vet(1)
          go to 100
          endif
      if (dire(1:4).eq.'nrs2') then
          if (iv.ne.1) go to 8000
          jenu2=ivet(1)
          go to 100
          endif
      if (dire(1:4).eq.'code') then
          if (iv.eq.0) go to 8000
          ncris=min0(iv,2)
          do 150 i=1,ncris
  150     nca(i)=ivet(i)
          go to 100
          endif
      write(lo,6000) diret
 6000 format(' wrong directive on following line:',/a)
 8000 continue
      ier=-1
      return
 9000 continue
      if (iprin.gt.1) jboth=1
      if (jenu1.ne.0) soge1=1.4
      return
      end

#if defined(_DVF_) || defined (_GID_) 
      LOGICAL FUNCTION INITIALSETTINGS( )
      USE DFLIB
      TYPE (qwinfo) qwi
11    DO I = 7,1,-1
         II = DELETEMENUQQ(I, 0)
      END DO
      i = clickqq( QWIN$STATUS )
      qwi%x = 0
      qwi%y = 0
      qwi%w = 640
      qwi%h = 480
      qwi%type = QWIN$SET
      i = SetWSizeQQ( QWIN$FRAMEWINDOW, qwi )
      INITIALSETTINGS= .true.
      END 

#endif
