C $Log: not supported by cvs2svn $
C Revision 1.3  2001/12/12 17:48:59  Administrator
C matrix calculator
C
C Revision 1.2  2001/02/26 10:29:08  richard
C Added changelog to top of file
C
CODE FOR SMATRX
      SUBROUTINE SMATRX
C      A BASIC MATRIX CALCULATOR
C   1.A        
C   2.B        
C   3.MM       
C   4.TM       
C   5.MT       
C   6.MM       
C   7.TRANS    
C   8.INV      
C   9.EIG      
C  10.ACC2A    
C  11.ACC2B    
C  12.EXECUTE  
C  13.MATRIX   
C
      DIMENSION A(3,3),B(3,3),C(3,3),TEMP(3,3),ROW(9)
      DIMENSION ACC(3,3)
\ISTORE
\STORE
\XUNITS
\XSSVAL
\XLISTI
\XCNTRL
\XCONST
\XLEXIC
\XCHARS
\XERVAL
\XOPVAL
\XIOBUF
C
\QSTORE
C
C
      DATA IVERSN /100/
C
C--SET UP THE TIMING CONTROL
      CALL XTIME1(2)
C--CLEAR THE CORE
      CALL XCSAE
      LEF1 = 0
C----- WORKSPACE FOR REPLACEMENT
      IWORK = KSTALL(3)
      JWORK = KSTALL(9)
C----- SPACE FOR HEADERS
      MQ = KSTALL (100)
C----- COMMAND BUFFER
      IDIMBF = 50
      ICOMBF = KSTALL (IDIMBF)
C----- ZERO THE BUFFER
      CALL XZEROF (ISTORE(ICOMBF), IDIMBF)
C----- COMMON BLOCK OFFSET(-1) FOR INPUT LIST
      IMDINP = 35
C----- INITIALSE LEXICAL PROCESSING
      ICHNG = 1
      CALL XLXINI (INEXTD, ICHNG)
C
C--MAIN INSTRUCTION CYCLING LOOP
C
1100  CONTINUE
      IDIRNM = KLXSNG (ISTORE(ICOMBF), IDIMBF, INEXTD)
      IF (IDIRNM .LT. 0) GOTO 1100
      IF (IDIRNM .EQ. 0) GOTO 4910
C--NEXT RECORD HAS BEEN LOADED  -  BRANCH ON THE TYPE
      GOTO (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 
     1  1100, 1210, 1200), IDIRNM
1200  CONTINUE
      GOTO 9910
C
1210  CONTINUE
C----- MATRIX ITSELF
C--SET UP THE INITIAL CONTROL FLAGS
      CALL XZEROF(A(1,1),9)
      CALL XZEROF(B(1,1),9)
      CALL XZEROF(C(1,1),9)
      CALL XZEROF(TEMP(1,1),9)
      CALL XZEROF(ROW(1),9)
      GOTO 1100
C
C
C--'A' INSTRUCTION
1     CONTINUE
      Z=1.
C--CHECK FOR SOME ARGUMENTS
      IF(KFDARG(I))1300,1320,1320
C--ERROR(S)  -  INCREMENT THE ERROR COUNT
1300  CONTINUE
      LEF1=LEF1+1
      GOTO 1100
C--CHECK IF THERE ARE MORE ARGUMENTS ON THIS CARD
1320  CONTINUE
      DO 1550 I = 1,9
1350  CONTINUE
      IF(KOP(8))1850,1400,1400
C--CHECK IF NEXT ARGUMENT IS A NUMBER
1400  CONTINUE
      IF(KSYNUM(Z))3950,1450,3950
1450  CONTINUE
      ROW(I) = Z
      ME=ME-1
      MF=MF+LK2
1550  CONTINUE
1850  CONTINUE
C      CONVERT TO COLUMN-WISE
      IF (IDIRNM .EQ.1 ) THEN
       CALL XTRANS(ROW,A,3,3)
      ELSE IF (IDIRNM .EQ.2 ) THEN
       CALL XTRANS(ROW,B,3,3)
      ENDIF
      WRITE(CMON,'(9F8.3)') ROW
      CALL ZMORE(CMON,0)
      GOTO 1100
C
C
C
C--'B' INSTRUCTION
2     CONTINUE
      CALL XZEROF(ROW(1),9)
C--CHECK FOR SOME ARGUMENTS
      IF(KFDARG(I))1300,3860,3860
3860  CONTINUE
C----- LOOP FOR 9 ELEMEMNTS ROW-WISE
      DO 4400 I = 1,9
      IF(KOP(8))4450,3900,3900
C--CHECK IF THERE IS A NUMBER NEXT ON THE CARD
3900  CONTINUE
      IF(ME)3950,3950,4050
C--READ THE NUMBER
4050  CONTINUE
      IF(KSYNUM(Z))3950,4100,3950
C--WE HAVE FOUND A NUMBER  -  UPDATE THE CARD POSITION
4100  CONTINUE
      ROW(I) = Z
      ME=ME-1
      MF=MF+LK2
4400  CONTINUE
4450  CONTINUE
C      CONVERT TO COLUMN-WISE
      IF (IDIRNM .EQ.1 ) THEN
       CALL XTRANS(ROW,A,3,3)
      ELSE IF (IDIRNM .EQ.2 ) THEN
       CALL XTRANS(ROW,B,3,3)
      ENDIF
      WRITE(CMON,'(9F8.3)') ROW
      CALL ZMORE(CMON,0)
      GOTO 1100
C
C--ERROR IN THE INPUT NUMBER
3950  CONTINUE
      CALL XPCLNN(LN)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4000)
      ENDIF
      WRITE(NCAWU,4000)
4000  FORMAT(/34H Argument missing or of wrong type)
      GOTO 4910
C
C-----MM     
3     CONTINUE
C--MATRIX MULTIPLICATION OF 'A' BY 'B' TO GIVE 'C'.
C  A(L,M).B(M,N)=C(L,N)
      CALL XMLTMM(A,B,ACC,3,3,3)
      GOTO 101
C-----TM     
4     CONTINUE
C--MATRIX MULTIPLICATION OF 'A' TRANSPOSED BY 'B' TO GIVE 'C'.
C  A(M,L)'.B(M,N)=C(L,N)
      CALL XMLTTM(A,B,ACC,3,3,3)
      GOTO 101
C-----MT
5     CONTINUE
C--MATRIX MULTIPLICATION OF 'A' BY 'B' TRANSPOSED  TO GIVE 'C'.
C  A(M,L).B'(M,N)=C(L,N)
      CALL XMLTMT(A,B,ACC,3,3,3)
      GOTO 101
C-----TT
6     CONTINUE
C--MATRIX MULTIPLICATION OF 'A' TRANS BY 'B' TRANS TO GIVE 'C'.
C  A(M,L)'.B'(M,N)=C(L,N)
      CALL XMLTTT(A,B,ACC,3,3,3)
      GOTO 101
C-----TRANS   
7     CONTINUE
C--MATRIC TRANSPOSITION ROUTINE
C  C(N,L)=A(L,N)'
      CALL XTRANS(A,ACC,3,3)
      GOTO 101
C-----INV     
8     CONTINUE
      CALL MATINV(A,ACC,D)
      WRITE(CMON,'(A, F12.5)') 'Determinant = ', D
      CALL ZMORE(CMON,0)
      GOTO 101
C-----EIG     
9     CONTINUE
      call zmore('Not yet implemented',0)
      GOTO 101
C-----ACC2A 
10     CONTINUE
      CALL XMOVE (ACC,A,9)
      GOTO 1100
C-----ACC2B 
11     CONTINUE
      CALL XMOVE (ACC,B,9)
      GOTO 1100
C
101    CONTINUE
      WRITE(CMON,'(9F8.3)') ACC
      CALL ZMORE(CMON,0)
      GOTO 1100
C
C--MAIN TERMINATION ROUTINES
4910  CONTINUE
4960  CONTINUE
9910  CONTINUE
      CALL XOPMSG ( IOPAXS , IOPEND , IVERSN )
      CALL XTIME2(2)
      RETURN
      END
C
C
CODE FOR XMLTMM
      SUBROUTINE XMLTMM(A,B,C,L,M,N)
C--MATRIX MULTIPLICATION OF 'A' BY 'B' TO GIVE 'C'.
C
C--THE PARAMETERS CAN BEST BE DESCRIBED BY THE MATRIX OPERATION :
C
C  A(L,M).B(M,N)=C(L,N)
C
C--
C
      DIMENSION A(L,M),B(M,N),C(L,N)
C
C--LOOP OVER ROWS OF THE OUTPUT MATRIX
      DO 1000 K=1,N
C--LOOP OVER COLUMNS OF THE OUTPUT MATRIX
      DO 1000 I=1,L
      C(I,K)=0.
C--LOOP OVER THE CONTRIBUTIONS OF THIS ELEMENT
      DO 1000 J=1,M
1000  C(I,K)=C(I,K)+A(I,J)*B(J,K)
      RETURN
      END
C
CODE FOR XMLTMT
      SUBROUTINE XMLTMT(A,B,C,L,M,N)
C--MATRIX MULTIPLICATION OF 'A' BY 'B' TRANSPOSED TO GIVE 'C'.
C
C--THE PARAMETERS CAN BEST BE DESCRIBED BY THE MATRIX OPERATION :
C
C  A(L,M).B(N,M)'=C(L,N)
C
C
C--
C
      DIMENSION A(L,M),B(N,M),C(L,N)
C
C--LOOP OVER ROWS OF THE OUTPUT MATRIX
      DO 1000 K=1,N
C--LOOP OVER COLUMNS OF THE OUTPUT MATRIX
      DO 1000 I=1,L
      C(I,K)=0.
C--LOOP OVER THE CONTRIBUTIONS OF THIS ELEMENT
      DO 1000 J=1,M
1000  C(I,K)=C(I,K)+A(I,J)*B(K,J)
      RETURN
      END
C
CODE FOR XMLTTM
      SUBROUTINE XMLTTM(A,B,C,L,M,N)
C--MATRIX MULTIPLICATION OF 'A' TRANSPOSED BY 'B' TO GIVE 'C'.
C
C--THE PARAMETERS CAN BEST BE DESCRIBED BY THE MATRIX OPERATION :
C
C  A(M,L)'.B(M,N)=C(L,N)
C
C--
C
      DIMENSION A(M,L),B(M,N),C(L,N)
C
C--LOOP OVER ROWS OF THE OUTPUT MATRIX
      DO 1000 K=1,N
C--LOOP OVER COLUMNS OF THE OUTPUT MATRIX
      DO 1000 I=1,L
      C(I,K)=0.
C--LOOP OVER THE CONTRIBUTIONS OF THIS ELEMENT
      DO 1000 J=1,M
1000  C(I,K)=C(I,K)+A(J,I)*B(J,K)
      RETURN
      END
C
CODE FOR XMLTTT
      SUBROUTINE XMLTTT(A,B,C,L,M,N)
C--MATRIX MULTIPLICATION OF 'A' TRANSPOSED BY 'B' TRANSPOSED TO GIVE 'C'
C
C--THE PARAMETERS CAN BEST BE DESCRIBED BY THE MATRIX OPERATION :
C
C  A(M,L)'.B(N,M)'=C(L,N)
C
C--
C
      DIMENSION A(M,L),B(N,M),C(L,N)
C
C--LOOP OVER ROWS OF THE OUTPUT MATRIX
      DO 1000 K=1,N
C--LOOP OVER COLUMNS OF THE OUTPUT MATRIX
      DO 1000 I=1,L
      C(I,K)=0.
C--LOOP OVER THE CONTRIBUTIONS OF THIS ELEMENT
      DO 1000 J=1,M
1000  C(I,K)=C(I,K)+A(J,I)*B(K,J)
      RETURN
      END
C
CODE FOR XTRANS
      SUBROUTINE XTRANS(A,C,L,N)
C--MATRIC TRANSPOSITION ROUTINE
C
C--IN MATRIX NOTATION, THIS MAY BE REPRESENTED AS :
C
C  C(N,L)=A(L,N)'
C
C--
C
      DIMENSION A(L,N),C(N,L)
C
      DO 1000 I=1,L
      DO 1000 J=1,N
1000  C(J,I)=A(I,J)
      RETURN
      END
C
CODE FOR MTRANS
      SUBROUTINE MTRANS(A)
C IN-PLACE TRANSPOSITION OF 3X3 MATRIX
C
      DIMENSION A(3,3)
      T = A(2,1)
      A(2,1) = A(1,2)
      A(1,2) = T
C
      T = A(2,3)
      A(2,3) = A(3,2)
      A(3,2) = T
C
      T = A(3,1)
      A(3,1) = A(1,3)
      A(1,3) = T
      END
CODE FOR XNEGTR
      SUBROUTINE XNEGTR(A,B,N)
C--NEGATE THE 'N' ELEMENTS OF 'A' TO 'B'.
C
C  A  INPUT VECTOR.
C  B  OUTPUT VECTOR.
C  N  THE NUMBER OF ELEMENTS IN 'A' AND 'B'.
C
C--
C
      DIMENSION A(N),B(N)
C
C
      DATA I/0/
C
C--CHECK FOR SOME ELEMENTS
      IF(N)1100,1100,1000
1000  CONTINUE
      DO 1050 I=1,N
      B(I)=-A(I)
1050  CONTINUE
C--AND NOW RETURN
1100  CONTINUE
      RETURN
      END
C
CODE FOR XADDR
      SUBROUTINE XADDR(A,B,C,N)
C--ADD THE 'N' ELEMENTS OF 'A' TO 'B' AND STORE THE RESULTS IN 'C'
C
C  A  FIRST INPUT VECTOR.
C  B  SECOND INPUT VECTOR.
C  C  THE RESULTS VECTOR.
C  N  THE ORDER OF 'A', 'B' AND 'C'.
C
C--
C
      DIMENSION A(N),B(N),C(N)
C
C
      DATA I/0/
C
C--CHECK FOR SOME ELEMNTS
      IF(N)1100,1100,1000
1000  CONTINUE
      DO 1050 I=1,N
      C(I)=A(I)+B(I)
1050  CONTINUE
C--AND NOW RETURN
1100  CONTINUE
      RETURN
      END
C
CODE FOR XSUBTR
      SUBROUTINE XSUBTR(A,B,C,N)
C--SUBTRACT THE 'N' ELEMENTS OF 'B' FROM 'A' AND STORE THE RESULTS IN 'C
C
C  A  FIRST INPUT VECTOR.
C  B  SECOND INPUT VECTOR.
C  C  THE RESULTS VECTOR.
C  N  THE ORDER OF 'A', 'B' AND 'C'.
C
C--
C
      DIMENSION A(N),B(N),C(N)
C
C
      DATA I/0/
C
C--CHECK FOR SOME ELEMNTS
      IF(N)1100,1100,1000
1000  CONTINUE
      DO 1050 I=1,N
      C(I)=A(I)-B(I)
1050  CONTINUE
C--AND NOW RETURN
1100  CONTINUE
      RETURN
      END
C
CODE FOR XMULTR
      SUBROUTINE XMULTR(A,B,C,N)
C--MULTIPLY THE 'N' ELEMENTS OF 'A' BY THE SCALAR 'B'
C  AND STORE THE RESULTS IN 'C'.
C
C  A  THE INPUT VECTOR.
C  B  THE SCALAR MULTIPLIER.
C  C  THE OUTPUT VECTOR.
C  N  THE NUMBER OF ELEMENTS IN 'A' AND 'C'.
C
C--
C
      DIMENSION A(N),C(N)
C
C
      DATA I/0/
C
C--CHECK FOR SOME ELEMENTS
      IF(N)1100,1100,1000
1000  CONTINUE
      DO 1050 I=1,N
      C(I)=A(I)*B
1050  CONTINUE
1100  CONTINUE
      RETURN
      END
C
CODE FOR XDVDR
      SUBROUTINE XDVDR(A,B,C,N)
C--DIVIDE THE 'N' ELEMENTS OF 'A' BY THE SCALAR 'B'
C  AND STORE THE RESULTS IN 'C'.
C
C  A  THE INPUT VECTOR.
C  B  THE SCALAR MULTIPLIER.
C  C  THE OUTPUT VECTOR.
C  N  THE NUMBER OF ELEMENTS IN 'A' AND 'C'.
C
C--
C
      DIMENSION A(N),C(N)
C
C
      DATA I/0/
C
C--CHECK FOR SOME ELEMENTS
      IF(N)1100,1100,1000
1000  CONTINUE
      DO 1050 I=1,N
      C(I)=A(I)/B
1050  CONTINUE
1100  CONTINUE
      RETURN
      END
C
CODE FOR XDETR3
      FUNCTION XDETR3(AMAT)
C--COMPUTE THE DETERMINANT OF THE 3 BY 3 MATRIX 'AMAT'.
C
C  AMAT  THE MATRIX.
C
C--THE RETURN VALUE IS THE VALUE OF THE DETERMINANT.
C
C--
C
      DIMENSION AMAT(9)
C
      XDETR3=(AMAT(5)*AMAT(9)-AMAT(8)*AMAT(6))*AMAT(1)-(AMAT(2)*AMAT(9)
     2 -AMAT(8)*AMAT(3))*AMAT(4)+(AMAT(2)*AMAT(6)-AMAT(5)*AMAT(3))
     3 *AMAT(7)
      RETURN
      END
C
C
CODE FOR XMTCEX
      SUBROUTINE XMTCEX (A,B,K,L)
C----- EXCHANGE ORDER OF COLUMNS OF MATRIX A(K,L)
      DIMENSION  A(K,L), B(K,L)
      N = L + 1
      DO 200 J = 1, L
      DO 100 I = 1, K
      B(I,J) = A(I,N-J)
100   CONTINUE
200   CONTINUE
      RETURN
      END
C
CODE FOR XMTREX
      SUBROUTINE XMTREX (A,B,K,L)
C----- EXCHANGE ORDER OF ROWS OF MATRIX A(K,L)
      DIMENSION  A(K,L), B(K,L)
      N = K + 1
      DO 200 I = 1, L
      DO 100 J = 1, K
      B(J,I) = A(N-J,I)
100   CONTINUE
200   CONTINUE
      RETURN
      END
C
CODE FOR MATINV
      SUBROUTINE MATINV(A,B,D)
C
C
      DIMENSION A(3,3),B(3,3)
      CALL VMULT(A(1,2),A(1,3),B(1,1))
      CALL VMULT(A(1,3),A(1,1),B(1,2))
      CALL VMULT(A(1,1),A(1,2),B(1,3))
      D=A(1,1)*B(1,1)+A(2,1)*B(2,1)+A(3,1)*B(3,1)
      IF(D.EQ.0.0)RETURN
      N=1
1000  K=1
1100  B(K,N)=B(K,N)/D
      K=K+1
      IF(K.LE.3)GOTO 1100
      N=N+1
      IF(N.LE.3)GOTO 1000
      CALL MTRANS(B)
      RETURN
      END
CODE FOR XUNTM
      SUBROUTINE XUNTM(AMAT, N)
C--SET UP A UNIT MATRIX IN 'AMAT'
C
C  AMAT  THE MATRIX TO BE SET UP AS A UNIT MATRIX.
C  N     DIMENSION OF SQUARE MATRIX
C--
C
      DIMENSION AMAT(N*N)
C
C--ZERO THE MATRIX
      CALL XZEROF(AMAT(1),N*N)
      IZAP = 1
      DO JZAP=1,N
       AMAT(IZAP)=1.
       IZAP=IZAP+N+1
      ENDDO
      RETURN
      END
CODE FOR XUNTM3
      SUBROUTINE XUNTM3(AMAT)
C--SET UP A 3*3 UNIT MATRIX IN 'AMAT'
C
C  AMAT  THE MATRIX TO BE SET UP AS A UNIT MATRIX.
C
C--
C
      DIMENSION AMAT(9)
C
C--ZERO THE MATRIX
      CALL XZEROF(AMAT(1),9)
      AMAT(1)=1.
      AMAT(5)=1.
      AMAT(9)=1.
      RETURN
      END
C
CODE FOR NROT
      FUNCTION NROT(AL,T,AMAT)
C--COMPUTE THE ROTATION MATRIX RESULTING FROM A ROTATION OF 'T' DEGREES
C  ABOUT THE AXIS WITH DIRECTION COSINES GIVEN BY 'AL'.
C
C  AL    THE DIRECTION COSINES OF THE LINE ABOUT WHICH THE ROTATION IS
C        TO BE PERFORMED. THIS SET OF COSINES MUST BE WITH RESPECT TO AN
C        ORTHOGONAL SYSTEM OF AXES.
C  T     THE ANGLE OF ROTATION IN DEGREES.
C  AMAT  THE RESULTANT ROTATION MATRIX. THE MATRIX IS STORED BY COLUMNS.
C
C--RETURN VALUES OF 'NROT' ARE :
C
C  -1  THE VECTOR IN 'AL' HAS ZERO LENGTH.
C  >0  MATRIX COMPUTED CORRECTLY.
C
C--
C
      DIMENSION AL(3),AMAT(9)
C
\XCONST
C
C
      DATA E/0.0/,S/0.0/,C/0.0/,D/0.0/
C
C--NORMALISE THE INPUT VECTOR
      CALL XZEROF(AMAT(1),9)
      NROT=-1
      IF(NORM3(AL))1050,1050,1000
C--CONVERT THE ANGLE TO DEGREES
1000  CONTINUE
      NROT=1
      E=T*PI/180.0
      S=SIN(E)
      C=COS(E)
      D=1.-C
C--COMPUTE THE REQUIRED ELEMENTS
      AMAT(1)=C+AL(1)*AL(1)*D
      AMAT(2)=AL(1)*AL(2)*D+AL(3)*S
      AMAT(3)=AL(3)*AL(1)*D-AL(2)*S
      AMAT(4)=AL(1)*AL(2)*D-AL(3)*S
      AMAT(5)=C+AL(2)*AL(2)*D
      AMAT(6)=AL(2)*AL(3)*D+AL(1)*S
      AMAT(7)=AL(3)*AL(1)*D+AL(2)*S
      AMAT(8)=AL(2)*AL(3)*D-AL(1)*S
      AMAT(9)=C+AL(3)*AL(3)*D
1050  CONTINUE
      RETURN
      END
C
CODE FOR NCROP3
      FUNCTION NCROP3(A,B,C)
C--COMPUTES THE CROSS PRODUCT OF THE VECTORS A AND B AND STORES THE
C  RESULT IN C.
C
C  A  THE FIRST VECTOR.
C  B  THE SECOND VECTOR.
C  C  THE CROSS PRODUCT OF A WITH B. (C = A CROSS B).
C
C--THE RETURN VALUES OF 'NCROP' ARE :
C
C  -1  THE INPUT VECTORS ARE PARALLEL  RESULTANT VECTOR HAS ZERO LENGTH.
C  >0  THE RESULTANT VECTOR IS NOT ZERO.
C
C--THE OUTPUT VECTOR IN 'C' IS NORMALISED BEFORE RETURN.
C
C--
C
      DIMENSION A(3),B(3),C(3)
C
      NCROP3=1
      CALL VMULT(A,B,C)
      IF(NORM3(C))1000,1000,1050
C--ZERO LENGTH VECTOR
1000  CONTINUE
      NCROP3=-1
1050  CONTINUE
      RETURN
      END
C
CODE FOR VMULT
      SUBROUTINE VMULT(A,B,C)
C----- FORM THE UN-NORMALISED VECTOR PRODUCT
      DIMENSION A(3),B(3),C(3)
      C(1)=A(2)*B(3)-A(3)*B(2)
      C(2)=A(3)*B(1)-A(1)*B(3)
      C(3)=A(1)*B(2)-A(2)*B(1)
      RETURN
      END
CODE FOR VPROD
      SUBROUTINE VPROD(A,B,C)
C----- FORM THE SCALAR PRODUCT.
      DIMENSION A(3),B(3)
      C=A(1)*B(1)+A(2)*B(2)+A(3)*B(3)
      RETURN
      END
CODE FOR NORM3
      FUNCTION NORM3(X)
C--NORMALISE THE VECTOR 'X' SO THAT THE SUM OF THE SQUARES
C  OF ITS THREE ELEMENTS IS UNITY.
C
C  X  THE VECTOR, CONTAINING THREE ELEMENTS.
C
C--THE RETURN VALUES OF 'NORM' ARE :
C
C  -1  THE VECTOR HAS ZERO LENGTH  (<0.0001).
C  >0  ALL OKAY.
C
C--
C
      DIMENSION X(3)
C
\XCONST
C
C
      DATA D/0.0/
C
C--SUM THE SQUARES
      D=X(1)*X(1)+X(2)*X(2)+X(3)*X(3)
C--CHECK THAT THE VECTOR IS NOT OF ZERO LENGTH
      NORM3=-1
      IF(D-ZEROSQ)1050,1050,1000
C--NORMALISE THE COMPONENTS
1000  CONTINUE
      D=1./SQRT(D)
      X(1)=X(1)*D
      X(2)=X(2)*D
      X(3)=X(3)*D
      NORM3=1
C--AND NOW RETURN
1050  CONTINUE
      RETURN
      END
C
CODE FOR KINV2
      FUNCTION KINV2(N,A,B,NA,NM,C,D,NC)
C--MATRIX INVERSION AND SOLUTION OF SIMULTANEOUS LINEAR EQUATIONS
C
C  N       ORDER OF THE MATICES TO BE INVERTED.
C  A       MATRIX TO BE INVERTED  I.E. A(N,N)
C  B       INVERSE MATRIX  -  CALCULATED BY THIS SUBROUTINE  -  B(N,N)
C  NA      THE ORDER OF 'A' AND 'B'  -  GREATER THAN OR EQUAL
C          TO 'N*N'.
C  NM      NUMBER OF COLUMN VECTORS TO BE MULTIPLIED ONTO THE INVERSE
C          MATRIX
C  C       COLUMN VECTORS TO BE MULTIPLIED ONTO THE INVERSE MATRIX C(N,M
C  D       RESULTS OF MULTIPLICATION ON TO THE INVERSE MATRIX  -  D(N,M)
C  NC      THE ORDER OF 'C' AND 'D'  -  GREATER THAN OR EQUAL
C          TO THE MAXIMUM OF 'N' AND 'N*NM'. THIS MEANS THAT A COLUMN
C          VECTOR AT LEAST MUST BE PROVIDED FOR BOTH.
C
C--IN MATRIX NOTATION
C
C  D=B.C
C  C=A.D
C
C--RETURN VALUES OF 'KINV2' ARE :
C
C   0  INVERSION ETC. WENT OKAY.
C  >0  SINGULAR  -  RETURN VALUE INDICATES FIRST SIGNULAR ELEMENT FOUND.
C
C--
      DOUBLE PRECISION  X02ABF,DUMMY
C
      DIMENSION A(NA),B(NA),C(NC),D(NC)
C
\XUNITS
\XSSVAL
\XERVAL
\XIOBUF
C
      DATA ASING/0.0/,BSING/0.0/,CSING/0.0/,E/0.0/,F/0.0/
      DATA M1/0/,M2/0/,M3/0/,M4/0/,M5/0/,M6/0/,M7/0/,M8/0/
      DATA I/0/,J/0/,K/0/,L/0/,M/0/
C
      KINV2=0
C--SET 'EPS', SUCH THAT 'EPS' IS THE SMALLEST NUMBER FOR 1.0+EPS>1.0
      BSING=16.0**(-5)
C--SET THE SMALLEST NUMBER THAT CAN BE EXACTLY REPRESENTED ON THE MACHIN
      CSING=SNGL(X02ABF(DUMMY))
C--SET THE SINGULARITY CHECK LIMITS
      CSING=CSING/BSING
      BSING=BSING*16.
C--SET ROW INTERCHANGE FLAGS
      DO 1000 I=1,N
      D(I)=FLOAT(I)
1000  CONTINUE
C--COMMENCE DECOMPOSITION A=L.U  -  BY ROWS WITH INTERCHANGES
      M5=1
      M6=1
      M1=M5
      M2=M6
      DO 1100 I=1,N
      DO 1050 J=1,N
      B(M2)=A(M1)
      M1=M1+1
      M2=M2+1
1050  CONTINUE
1100  CONTINUE
      M8=1
      DO 1900 J=1,N
      M2=M6
      M7=M8
      F=-1.
      L=J-1
C--CALCULATE THE L PART , EXCEPT FOR THE DIVISION BY U(I,I)
      DO 1450 I=J,N
      E=B(M2)
      ASING=BSING*ABS(E)
      IF(L)1250,1250,1150
1150  CONTINUE
      M3=I
      M4=M7
      DO 1200 K=1,L
      E=E-B(M3)*B(M4)
      M3=M3+N
      M4=M4+1
1200  CONTINUE
C--TRANSFER TO THE B ARRAY AND CHECK FOR THE MAXIMUM VALUE
1250  CONTINUE
      B(M2)=E
      M2=M2+1
      IF(F-ABS(E))1300,1450,1450
C--THIS IS THE CURRENT MAXIMUM
1300  CONTINUE
      F=ABS(E)
      M=I
      D(M)=ABS(D(M))
C--CHECK SINGULARITY FOR THIS ELEMENT
      IF(ASING-F)1350,1400,1400
1350  CONTINUE
      IF(CSING-F)1450,1400,1400
1400  CONTINUE
      D(M)=-D(M)
1450  CONTINUE
C--CHECK IF THE MAXIMUM VALUE IS INDICATED AS SINGULAR
      IF(D(M))1500,1500,1550
1500  CONTINUE
      KINV2=J
      GOTO 3100
C--INTERCHANGE ROWS
1550  CONTINUE
      CALL XINT2(N,B,NA,D,NC,J,M,N)
      E=1./B(M6)
      B(M6)=E
      IF(J-N)1600,1900,1600
1600  CONTINUE
      M=J+1
      M3=M6+1
      DO 1650 I=M,N
      B(M3)=B(M3)*E
      M3=M3+1
1650  CONTINUE
      IF(L)1850,1850,1700
C--COMPLETE CALCULATION OF U
1700  CONTINUE
      M2=M6+N
      M7=M7+N
      DO 1800 I=M,N
      M3=J
      M4=M7
      DO 1750 K=1,L
      B(M2)=B(M2)-B(M3)*B(M4)
      M3=M3+N
      M4=M4+1
1750  CONTINUE
      M2=M2+N
      M7=M7+N
1800  CONTINUE
C--UPDATE VARIOUS FLAGS
1850  CONTINUE
      M6=M6+N+1
      M8=M8+N
1900  CONTINUE
C--DECOMPOSITION ENDS.
C
C--INVERT THE LOWER TRIANGULAR MATRIX L
      M5=2
C--PROCESS BY ROWS
      DO 2150 I=2,N
      M4=M5
C--PROCESS BY COLUMNS
      DO 2100 J=I,N
      B(M5)=-B(M5)
      K=J-I
      IF(K)2050,2050,1950
1950  CONTINUE
      M1=M5+N
      M2=M4
      DO 2000 L=1,K
      B(M5)=B(M5)-B(M1)*B(M2)
      M1=M1+N
      M2=M2+1
2000  CONTINUE
2050  CONTINUE
      M5=M5+1
2100  CONTINUE
      M5=M5+I
2150  CONTINUE
C
C--INVERT THE UPPER TRIANGULAR MATRIX U
      M5=N*N-1
      DO 2300 I=2,N
      M4=M5+1
      DO 2250 J=I,N
      K=J-I+1
      M1=M5
      M2=M4
      E=0.
      DO 2200 L=1,K
      E=E-B(M1)*B(M2)
      M1=M1-N
      M2=M2-1
2200  CONTINUE
      B(M5)=E*B(M1)
      M5=M5-1
2250  CONTINUE
      M5=M5-I
2300  CONTINUE
C
C--ASSEMBLY OF THE FINAL MATRIX  -  STILL WITH ROWS INTERCHANGED
      M5=1
      DO 2700 J=1,N
      M3=M5+N
      M4=M5+J
      DO 2650 I=1,N
      M1=M3
      M2=M4
      IF(I-J)2350,2350,2400
2350  CONTINUE
      E=B(M5)
      M3=M3+1
      K=N-J
      GOTO 2450
2400  CONTINUE
      E=0.
      M3=M3+N+1
      M4=M4+1
      K=N-I+1
2450  CONTINUE
      IF(K)2600,2600,2500
2500  CONTINUE
      DO 2550 L=1,K
      E=E+B(M1)*B(M2)
      M1=M1+N
      M2=M2+1
2550  CONTINUE
2600  CONTINUE
      B(M5)=E
      M5=M5+1
2650  CONTINUE
2700  CONTINUE
C--ASSEMBLY ENDS.
C
C--SORT OUT THE INTERCHANGES AND STORE FINAL INVERSE MATRIX
      DO 2850 I=1,N
      DO 2800 J=1,N
      K=NINT(D(J))
      IF(K-I)2800,2750,2800
2750  CONTINUE
      CALL XINT2(N,B,NA,D,NC,I,J,1)
      GOTO 2850
2800  CONTINUE
      WRITE(NCAWU,2830)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2830)
      ENDIF
      WRITE ( CMON, 2830)
      CALL XPRVDU(NCVDU, 1,0)
2830  FORMAT(' Inverter fails  ')
      CALL XERHND ( IERSEV )
2850  CONTINUE
C--FINAL ASSEMBLY ENDS.
C
C--SOLVE THE GIVEN EQUATIONS IF ANY
      IF(NM)3100,3100,2900
2900  M3=1
      M4=1
      DO 3050 I=1,NM
      DO 3000 J=1,N
      M1=J
      M2=M3
      D(M4)=0.
      DO 2950 K=1,N
      D(M4)=D(M4)+B(M1)*C(M2)
      M1=M1+N
2950  M2=M2+1
3000  M4=M4+1
3050  M3=M3+N
C
3100  RETURN
      END
C
CODE FOR XINT2
      SUBROUTINE XINT2(N,B,NB,D,ND,J,K,ITYPE)
C--INTERCHANGES EITHER ROWS OR COLUMNS J AND K
C
C--THE TYPE OF INTERCHANGE IS DETERMINATED BY 'ITYPE' :
C
C  1  COLUMNS.
C  2  ROWS.
C
C--
C
      DIMENSION B(NB),D(ND)
C
C
      DATA I/0/,L/0/,M/0/
      DATA F/0.0/
C
      IF(J-K)1000,1100,1000
1000  CONTINUE
      L=(J-1)*(N/ITYPE)+1
      M=(K-1)*(N/ITYPE)+1
      F=D(J)
      D(J)=D(K)
      D(K)=F
      DO 1050 I=1,N
      F=B(L)
      B(L)=B(M)
      B(M)=F
      L=L+ITYPE
      M=M+ITYPE
1050  CONTINUE
1100  CONTINUE
      RETURN
      END
C
CODE FOR XCHOLS
      SUBROUTINE XCHOLS(N,IBASE,IRES)
C--INVERSION OF A SYMMETRIC UPPER TRIANGULAR MATRIX BY THE CHOLESKI
C  METHOD
C
C--THE MATRIX IS HELD IN THE ARRAY 'STORE' IN THE COMMON BLOCK 'XDATA'.
C  THE MATRIX IS STORED AS ITS UPPER TRIANGLE BY ROWS.
C
C  N      ORDER OF THE MATRIX
C  IBASE  ADDRESS OF THE FIRST ELEMENT
C  IRES   ADDRESS OF WORK SPACE OF LENGTH N
C
C--
C
C----- IF THE MATRIX HAS BEEN ACCUMULATED DOUBLE PRECISION,
C      THE FOLLOWING VARIABLES WOULD BEST BE IN QUADRUPLE PRECISION.
C      SINCE QUAD PRECISION IS NOT PART OF FORTRAN77, WE USE DOUBLE
C      LENGTH VARIABLES FOR BOTH SINGLE AND DOUBLE LENGTH MATRICES.
C
\TYPDBL
C      REAL *16  DPV,ASING,BSING,CSING,DSING,EPV,ONE
C
\TYPE11
C
\STORE
\XSTR11
\XUNITS
\XIOBUF
\XSSVAL
C
\QSTR11
C
C
      DATA ONE/0.1D1/
C      DATA ONE/0.1Q1/
C
C--ASSIGN THE SINGULARITY CHECK LIMITS
      CSING=0.2D1**(-32)
C      CSING=0.2Q1**(-32)
      BSING = SQRT(CSING)
C      BSING = QSQRT(CSING)
C--DECOMPOSE THE MATRIX INTO L.L'
      LU=IRES
      N1=N-1
      K=IBASE
      DPV=STR11(K)
      ASING=BSING
      IF ((N1 .GT. 100) .AND. (IQUN .EQ. JQUN) .AND. (ISSSPD .EQ. 2))
     1THEN
        MDISP = 1
      ELSE
        MDISP = 0
      ENDIF
C--CHECK THE FIRST ELEMENT OF THE FIRST ROW
      IF(N1)2000,2050,1000
1000  CONTINUE
      IF(DPV-BSING)1050,1050,1100
1050  CONTINUE
      CALL XSING(0,N,IBASE,K)
      STR11(LU)=0.
      GOTO 1200
1100  CONTINUE
      DPV = SQRT(DPV)
C      DPV = QSQRT(DPV)
      STR11(K)=DPV
      STR11(LU) = 1.D0/DPV
      K=K+1
      DO 1150 I=1,N1
      STR11(K)=STR11(K)*STR11(LU)
      K=K+1
1150  CONTINUE
C--CONTINUE WITH THE REST OF THE MATRIX
      IF (MDISP .EQ. 1)
     1 CALL XWHIZZ ( '        Decomposing the matrix ', 2 )
1200  CONTINUE
      LU=LU+1
      DO 1650 I=1,N1
      IF (MDISP .EQ. 1) THEN
            IF (ISSTML .EQ. 4) THEN
             CALL SLIDER (I, N1)
            ELSE
             CALL XWHIZZ('  ', I)
            ENDIF
      ENDIF
      DPV=STR11(K)
      ASING=DPV*CSING
      L=IBASE+I
      DO 1250 J=1,I
         DPV = DPV - DPROD( STR11(L), STR11(L) )
C      DPV = DPV- QLEN(STR11(L)*STR11(L))
      L=L+N-J
1250  CONTINUE
      IF(DPV-BSING)1350,1350,1300
1300  CONTINUE
      IF(DPV-ASING)1350,1350,1400
1350  CONTINUE
      CALL XSING(I,N,IBASE,K)
      STR11(LU)=0.
      GOTO 1600
1400  CONTINUE
      DPV = SQRT(DPV)
C      DPV = QSQRT(DPV)
      EPV=ONE/DPV
      STR11(K)=DPV
      STR11(LU) = EPV
      K=K+1
      IF(I-N1)1450,1600,1450
1450  CONTINUE
      LW=I+1
      DO 1550 J=LW,N1
      DPV=STR11(K)
      LS=IBASE+I
      LT=IBASE+J
      DO 1500 M=1,I
         DPV = DPV - DPROD( STR11(LS), STR11(LT) )
C      DPV= DPV- QLEN(STR11(LS)*STR11(LT))
      LS=LS+N-M
      LT=LT+N-M
1500  CONTINUE
      STR11(K)=DPV*EPV
      K=K+1
1550  CONTINUE
1600  CONTINUE
      LU=LU+1
1650  CONTINUE
C
C--INVERSION OF THE TRIANGULAR MATRIX L
      LV=K
      K=K-1
      LU=LU-1
      STR11(K)=STR11(LU)
      K=K-1
      LU=LU-1
      IF (MDISP .EQ. 1)
     1 CALL XWHIZZ ( '        Inverting the triangular matrix ', 2)
      DO 1800 I=1,N1
      IF (MDISP .EQ. 1) THEN
            IF (ISSTML .EQ. 4) THEN
             CALL SLIDER (I, N1)
            ELSE
             CALL XWHIZZ('  ', I)
            ENDIF
      ENDIF
      LW=LV
      DO 1750 J=1,I
      ADD=0.0
      LW=LW-J
      LT=K
      LS=LW
      DO 1700 L=J,I
        ADD = ADD - DPROD( STR11(LS), STR11(LT) )
      LT=LT-1
      LS=LS-L
1700  CONTINUE
      STR11(K)=ADD*STR11(LU)
      K=K-1
1750  CONTINUE
      STR11(K)=STR11(LU)
      K=K-1
      LU=LU-1
1800  CONTINUE
C
C--FORM THE INVERSE MATRIX FROM THE TWO INVERTED TRIANGLES
      K=IBASE
      LS=IBASE-1
      IF (MDISP .EQ. 1)
     1 CALL XWHIZZ ( '        Forming the full inverse matrix ', 2)
      DO 1950 I=1,N
      IF (MDISP .EQ. 1) THEN
            IF (ISSTML .EQ. 4) THEN
             CALL SLIDER (I, N)
            ELSE
             CALL XWHIZZ('  ', I)
            ENDIF
      ENDIF
      LT=LS
      DO 1900 J=I,N
      ADD=0.0
      DO 1850 M=J,N
      LV=M+LT
      LW=M+LS
        ADD = ADD + DPROD( STR11(LV), STR11(LW) )
1850  CONTINUE
      STR11(K)=ADD
      K=K+1
      LT=LT+N-J
1900  CONTINUE
      LS=LS+N-I
1950  CONTINUE
C
2000  CONTINUE
      WRITE ( CMON,'(1X)' )
      CALL XPRVDU(NCVDU, 1,0)
      RETURN
C
C--ONLY ONE ELEMENT
2050  CONTINUE
      IF(DPV-ASING)2100,2100,2150
2100  CONTINUE
      CALL XSING(0,N,IBASE,K)
      STR11(LU)=0.
      GOTO 2000
2150  CONTINUE
      STR11(K)=1.0/STR11(K)
      GOTO 2000
      END
C
CODE FOR XSOLVE
      SUBROUTINE XSOLVE(N,IBASE,IVECT,IRES)
C--SOLVE THE NORMAL EQUATIONS
C
C  N     ORDER OF THE MATRIX
C  IBASE FIRST LOCATION OF THE MATRIX
C  IVECT FIRST LOCATION OF THE VECTOR
C  IRES  FIRST LOCATION OF THE RESULTS
C
C--
C
C
\TYPE11
C
\STORE
\XSTR11
C
\QSTR11
C
C--WORK OUT THE ANSWERS
      K=IRES
      DO 1250 I=1,N
      LS=IBASE+I-1
      STR11(K)=0.0
      LT=IVECT
      DO 1200 J=1,N
      STR11(K)=STR11(K)+STR11(LT)*STR11(LS)
      IF(J-I)1050,1100,1100
1050  CONTINUE
      LS=LS+N-J
      GOTO 1150
1100  CONTINUE
      LS=LS+1
1150  CONTINUE
      LT=LT+1
1200  CONTINUE
      K=K+1
1250  CONTINUE
      RETURN
      END
C
CODE FOR XSING
      SUBROUTINE XSING(NOC,N,IBASE,K)
C--SINGULARITY ERROR
C
C  NOC     THE SINGULAR PARAMETER MINUS ONE.
C  N       THE ORDER OF THE MATRIX.
C  IBASE   THE ADDRESS OF THE FIRST WORD.
C
C--
\TYPE11
C
\STORE
\XSTR11
\XUNITS
\XSSVAL
\XIOBUF
C
\QSTR11
C
      LS=NOC+1
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1000)LS
      ENDIF
      WRITE(NCAWU,1000) LS
      WRITE ( CMON, 1000) LS
      CALL XPRVDU(NCVDU, 1,0)
1000  FORMAT(' Singularity - relative parameter',I5)
      LS=IBASE+NOC
      DO 1150 LT=1,N
      STR11(LS)=0.0
      IF(NOC-LT)1100,1050,1050
1050  CONTINUE
      LS=LS+N-LT
      GOTO 1150
1100  CONTINUE
      LS=LS+1
      K=K+1
1150  CONTINUE
      RETURN
      END
C
CODE FOR XMXMPI
      SUBROUTINE XMXMPI(A,B,N)
C -- B = INVERSE (A)
C----- MOORE-PENROSE INVERTOR
C----- ACTA (1977),A33 212-215. A. L. MACKAY
      DIMENSION A(N,N)
      DIMENSION B(N,N)
\ISTORE
C
\STORE
\XUNITS
\XSSVAL
\XERVAL
\XIOBUF
C --
\QSTORE
C --
C -- SET UP NUMBERS REQUIRED LATER
      NSQ=N*N
C -- ILIMIT IS THE MAXIMUM NUMBER OF ITERATIONS FOR ANY MATRIX
      ILIMIT=20
C -- ITRLIM IS THE MAXIMUM NUMBER OF INITIAL TRIALS MADE
      ITRLIM=5
C --
      CALL XZEROF(B(1,1),NSQ)
C -- ALLOCATE WORKING SPACE FOR CALCULATIONS
      IPMAT=KSTALL(NSQ)
      IQMAT=KSTALL(NSQ)
      IRMAT=KSTALL(NSQ)
      IINIT=KSTALL(NSQ)
      ISCALE=KSTALL(N)
C -- SAVE INITIAL MATRIX
      CALL XMOVE(A(1,1),STORE(IINIT),NSQ)
C -- CALCULATE SCALE FACTORS FOR MATRIX
      DO 1050 I=1,N
      NSCALE=ISCALE+I-1
      STORE(NSCALE)=10.
      IF (ABS(A(I,I)) .LT. 0.01) GO TO 1050
      STORE(NSCALE)=1/SQRT(ABS(A(I,I)))
1050  CONTINUE
C -- SCALE INITIAL MATRIX
      CALL XMXSCL(A(1,1),A(1,1),STORE(ISCALE),N)
C -- SUM ELEMENTS - NECCESSARY FOR DETERMINING FIRST TRIAL INVERSE
      CALL XMXSEL(A(1,1),N,N,ALP)
C -- IF ALP=0. THEN WE HAVE A ZERO MATRIX
      IF (ALP .LE. 0.000001) GOTO 9500
      ALP=1./ALP
C -- SET P = 2I
      CALL XZEROF(STORE(IPMAT),NSQ)
      NDIAG=IPMAT
      DO 1200 I=1,N
      STORE(NDIAG)=2.
      NDIAG=NDIAG+N+1
1200  CONTINUE
C -- SET ATTEMPTS COUNTER
      ITRIES=1
1300  CONTINUE
C -- INITIAL TRY IS ALP*TRANSPOSE(A)
      CALL XTRANS (A(1,1),STORE(IQMAT),N,N)
      CALL XMULTR (STORE(IQMAT),ALP,STORE(IQMAT),NSQ)
C --
      ITIMES=1
C -- INITIAL VALUE OF OLD TRACE = 0
      TR=0.
1500  CONTINUE
C -- ITERATION LOOP
C -- R = AQ
      CALL XMLTMM(A(1,1),STORE(IQMAT),STORE(IRMAT),N,N,N)
C -- CALCULATE TRACE OF R
      X=XMXTRC(STORE(IRMAT),N)
C -- R = P - R
      CALL XSUBTR(STORE(IPMAT),STORE(IRMAT),STORE(IRMAT),NSQ)
C -- B = Q R
      CALL XMLTMM(STORE(IQMAT),STORE(IRMAT),B(1,1),N,N,N)
C -- CHECK FOR CONVERGENCE
      IF (ABS(X-TR).LT.0.01) GOTO 4000
C -- NOT CONVERGED
C -- IF TRACE IS NEGATIVE OR GREATER THAN ORDER THEN TRY
C    ANOTHER INITIAL MATRIX
      IF ( (X .LE. 0.) .OR. (X .GT. N) ) GOTO 3000
      ITIMES=ITIMES+1
C -- IF WE HAVE HAD ENOUGH ATTEMPTS WITH THIS MATRIX TRY ANOTHER
      IF (ITIMES.GE.(ILIMIT+1)) GOTO 3000
C -- REMEMBER TRACE FOR COMPARISON
      TR=X
C -- SET NEXT TRIAL MATRIX
      CALL XMOVE(B(1,1),STORE(IQMAT),NSQ)
C -- REPEAT
      GO TO 1500
3000  CONTINUE
C -- THIS ATTEMPT HAS NOT WORKED
C -- INCREMENT TRIES COUNT
        ITRIES=ITRIES+1
C -- IF WE HAVE DONE THE MAXIMUM NUMBER OF LOOPS THEN GIVE UP HOPE
      IF (ITRIES.GT.(ITRLIM+1)) GOTO 9800
C -- TRY AGAIN WITH A DIFFERENT INITIAL MATRIX
      ALP=.3*ALP
      GOTO 1300
4000  CONTINUE
C -- PROCESS HAS APPARENTLY CONVERGED
C    IF THE CURRENT TRACE IS NEARLY ZERO THEN ABANDON ATTEMPT
      IF (X.LT.0.01) GOTO 9810
C -- PROCESS HAS SUCCESSFULLY CONVERGED
C -- SCALE MATRIX AGAIN TO RELATE IT TO THE INITIAL VALUES
      CALL XMXSCL(B(1,1),B(1,1),STORE(ISCALE),N)
9500  CONTINUE
C -- RESTORE INITIAL MATRIX
      CALL XMOVE(STORE(IINIT),A(1,1),NSQ)
C -- RELEASE WORK SPACE
      CALL XSTRLL(IINIT)
      CALL XSTRLL(IPMAT)
      CALL XSTRLL(IQMAT)
      CALL XSTRLL(IRMAT)
      CALL XSTRLL(ISCALE)
      RETURN
9800  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE (NCWU,9801)
      ENDIF
      WRITE (NCAWU,9801)
      WRITE ( CMON, 9801)
      CALL XPRVDU(NCVDU, 1,0)
9801  FORMAT (' Inversion process has failed to converge  ')
      GO TO 9900
9810  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE (NCWU,9811)
      ENDIF
      WRITE (NCAWU,9811)
      WRITE ( CMON, 9811)
      CALL XPRVDU(NCVDU, 1,0)
9811  FORMAT (' Trace of inverse has become zero   ')
9900  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE (NCWU,9901)
      ENDIF
      WRITE (NCAWU,9901)
      WRITE ( CMON, 9901)
      CALL XPRVDU(NCVDU, 1,0)
9901  FORMAT (' Error in Moore-Penrose inverter   ')
C -- CALL ERROR ROUTINE
      CALL XERHND ( IERERR )
      RETURN
      END
C
C --
C
CODE FOR XMXSCL
      SUBROUTINE XMXSCL(A,B,SCALE,N)
C -- B(I,J)=A(I,J)*SCALE(I)*SCALE(J)
      DIMENSION A(N,N)
      DIMENSION B(N,N)
      DIMENSION SCALE(N)
C --
      DO 1200 I=1,N
      DO 1100 J=1,N
      B(I,J)=A(I,J)*SCALE(I)*SCALE(J)
1100  CONTINUE
1200  CONTINUE
      RETURN
      END
C
C --
C
CODE FOR XMXSEL
      SUBROUTINE XMXSEL(A,N,M,SUM)
C -- SUM=A(1,1)+A(1,2)+... A(N,M)
      DIMENSION A(N,M)
      SUM=0.
      DO 1200 J=1,N
      DO 1100 I=1,M
      SUM=SUM+A(I,J)
1100  CONTINUE
1200  CONTINUE
      RETURN
      END
C
C --
C
CODE FOR XMXTRC
      FUNCTION XMXTRC(A,N)
C -- XMXTRC = TRACE ( A )
      DIMENSION A(N,N)
C --
      SUM=0.
      DO 2000 I=1,N
      SUM=SUM+A(I,I)
2000  CONTINUE
      XMXTRC=SUM
      RETURN
      END
C
C --
C
CODE FOR XMXPRM
      SUBROUTINE XMXPRM(RMAT)
C -- PRINTS ROTATION MATRIX
      DIMENSION RMAT(3,3)
\XUNITS
\XSSVAL
C --
      IF (ISSPRT .EQ. 0) THEN
      WRITE (NCWU,2010)
      ENDIF
2010  FORMAT (1X)
      DO 3000 J=1,3
      IF (ISSPRT .EQ. 0) THEN
      WRITE (NCWU,2020) (RMAT(I,J),I=1,3)
      ENDIF
2020  FORMAT (1X,3F10.5)
3000  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE (NCWU,3010)
      ENDIF
3010  FORMAT (/)
      RETURN
      END
C
C --
C
CODE FOR XMXEGV
      SUBROUTINE XMXEGV(XM1,XM2,XM3)
      DOUBLE PRECISION DM1,DM2,DM3,DWORK
      DIMENSION XM1(3,3),XM2(3,3),XM3(3)
      DIMENSION DM1(3,3),DM2(3,3),DM3(3),DWORK(10)
C --
      DO 2000 J=1,3
      DO 1500 I=1,3
      DM1(I,J)=DBLE(XM1(I,J))
1500  CONTINUE
2000  CONTINUE
      I=0
      CALL F02ABF (DM1(1,1),3,3,DM3(1),DM2(1,1),3,DWORK(1),I)
      DO 3000 J=1,3
      DO 2500 I=1,3
      XM2(I,J)=SNGL(DM2(I,J))
      XM3(I)=SNGL(DM3(I))
2500  CONTINUE
3000  CONTINUE
      RETURN
      END
C
C --
C
CODE FOR XMXMFV
      SUBROUTINE XMXMFV(VECTOR,XMATR,NDIM)
C -- CONVERTS VECTOR TO MATRIX
      DIMENSION VECTOR(NDIM)
      DIMENSION XMATR(NDIM,NDIM)
C --
      DO 2000 J=1,NDIM
      DO 1500 I=1,NDIM
      IF (I-J) 1200,1300,1200
1200  CONTINUE
      XMATR(I,J)=0.
      GOTO 1500
1300  CONTINUE
      XMATR(I,J)=VECTOR(J)
1500  CONTINUE
2000  CONTINUE
      RETURN
      END
C
C --
C
CODE FOR XMXRTI
      SUBROUTINE XMXRTI (ATOMS,XMATR,MDATM,NATM)
C -- APPLIES XMATR TO ATOMS
      DIMENSION ATOMS(MDATM,NATM)
      DIMENSION XMATR(3,3)
      DIMENSION RESULT(3)
C --
      DO 2000 J=1,NATM
      CALL XMLTMT(XMATR(1,1),ATOMS(1,J),RESULT(1),3,3,1)
      CALL XMOVE (RESULT(1),ATOMS(1,J),3)
2000  CONTINUE
      RETURN
      END
C
C --
C
CODE FOR XMXTRL
      SUBROUTINE XMXTRL (ATOMS,VECTOR,MDATM,NATM)
C -- TRANSLATES ATOMS BY VECTOR
C    FINAL ATOM COORDINATES ARE MULTIPLIED BY WEIGHT
C    (SETTING THOSE WITH ZERO WEIGHT TO 0. 0. 0.)
C --
      DIMENSION ATOMS(MDATM,NATM)
      DIMENSION VECTOR(3)
C --
      DO 2000 I=1,3
      DO 1000 J=1,NATM
      ATOMS(I,J)=ATOMS(I,J)-VECTOR(I)
      ATOMS(I,J)=ATOMS(I,J)*ATOMS(4,J)
1000  CONTINUE
2000  CONTINUE
      RETURN
      END
C
C --
C
CODE FOR XMXCLO
      SUBROUTINE XMXCLO(DATA,XMATR)
      DIMENSION DATA(6)
      DIMENSION XMATR(9)
C --
      XMATR(1)=DATA(1)*SIN(DATA(5))*SIN(DATA(6))
      XMATR(2)=0.
      XMATR(3)=0.
      XMATR(4)=-DATA(1)*SIN(DATA(5))*COS(DATA(6))
      XMATR(5)=DATA(2)*SIN(DATA(4))
      XMATR(6)=0.
      XMATR(7)=DATA(1)*COS(DATA(5))
      XMATR(8)=DATA(2)*COS(DATA(4))
      XMATR(9)=DATA(3)
C --
      RETURN
      END
C
C --
C
CODE FOR XMXCRM
      SUBROUTINE XMXCRM(ROTN,XMATR)
      DIMENSION ROTN(3)
      DIMENSION XMATR(3,3)
\STORE
C --
      ITMP1=KSTALL(9)
      ITMP2=KSTALL(27)
C -- GET UNIT MATRIX
      CALL XUNTM3(STORE(ITMP1))
C -- CALCULATE ROTATION MATRIX ABOUT X,Y,Z, AXES
      DO 2000 I=1,3
      IPL1=3*(I-1)
      IPL2=9*(I-1)
      J=NROT(STORE(IPL1+ITMP1),ROTN(I),STORE(ITMP2+IPL2))
2000  CONTINUE
      CALL XMLTMM(STORE(ITMP2+9),STORE(ITMP2),STORE(ITMP1),3,3,3)
      CALL XMLTMM(STORE(ITMP2+18),STORE(ITMP1),XMATR(1,1),3,3,3)
C -- RELEASE WORK SPACE
      CALL XSTRLL(ITMP1)
      CALL XSTRLL(ITMP2)
      RETURN
      END
