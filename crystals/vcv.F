C $Log: not supported by cvs2svn $
C Revision 1.9  2012/09/17 12:24:53  rich
C DPROD subroutine name clashes with intrinsic function. Renamed DVPROD.
C
C Revision 1.8  2012/03/23 13:53:43  rich
C Get atom details for second atom.
C
C Revision 1.7  2012/01/04 14:31:25  rich
C Fix some uninitialized variables, and output format mistakes.
C
C Revision 1.6  2011/11/03 09:16:09  rich
C Added SUSCAL routine
C
C Revision 1.5  2011/08/08 10:44:34  djw
C Move print of vcv matrix from torsion into igetvcv in vcv
C
C Revision 1.4  2011/08/04 16:07:10  djw
C More or less works. The outer process xvcv does not use KATOMS to apply symmetry.  See TORSION for a better example.
C xgetvcv seems to work ok if a distance-type stack is set up. In TORSION the atomic coordinates are also available and were used
C to verify that the torsion esd routine could calculate the same torsion value as the otiginal code.
C
C outstanding:
c
c The module vcv (used during development) needs updating to use KATOMS 
c (see TORSION) and probably no longer works. (july 2011)
c
C remember variance is esd ^ 2
C only accepts atom names.
C returns inverse matrix for named atom positions only
C 
C FORMAT OF THE KATOMU OUTPUT STACK:
C
C   0  LINK LOCATION OR 'NOWT'
C   1  LENGTH OF THE ENTRY  (NOT SET HERE)
C   2  TYPE
C   3  SERIAL
C   4  NOT USED ('NOWT')
C   5  NUMBER OF PARAMETERS
C   6  ADDRESS OF THE FIRST PARAMETER REL. TO MQ OR 'NOWT'
C   7  S
C   8  L
C   9  T(X)
C  10  T(Y)
C  11  T(Z)
C  12  ADDRESS OF THE ATOM IN LIST 5 ('NOWT')
C  13  ADDRESS OF THE ATOM IN LIST 12 ('NOWT')
C  14  NOT USED ('NOWT')
C  15  ADDRESS OF THE GENERATED PARAMETERS ('NOWT')
C  16  ADDRESS OF THE PARAMETERS TO BE USED ('NOWT')
C
C LIST 5 PARAMETER FORMAT:
C
C   0  TYPE
C   1  SERIAL
C   2  OCC
C   3  FLAG
C   4  X
C   5  Y
C   6  Z
C   7-12 UIJ
C
C
C DISTANCE-TYPE STACK (SOME ITEMS NOT USED IN THIS CONTEXT):
C
C   0 I  ADDRESS OF ATOM IN L5 (USE THIS TO FIND THE ATOM TYPE & SERIAL)
C   1    ACCEPTANCE FLAG (NOT USED) 
C   2 I  S, THE SYMMETRY MATRIX TO BE USED (NEGATIVE FOR CofS)
C   3 I  NON-PRIMITIVE LATTICE INDICATOR
C   4 I  T(X)
C   5 I  T(Y)
C   6 I  T(Z)
C   7 R  TRANSFORMED X
C   8 R  TRANSFORMED Y
C   9 R  TRANSFORMED Z
C  10    DISTANCE (NOT USED)
C  11    DISTANCE SQUARED (NOT USED)
C  12 I  ADDRESS IN LIST 12.
C  13    TARGET CONTACT DISTANCE FOR RESTRAINTS (NOT USED)
C
CODE FOR VCV
      SUBROUTINE VCV
C 
C     CREATE THE vCv MATRIX FOR THE SPECIFIED ATOMS
C--
      INCLUDE 'ICOM12.INC'
      INCLUDE 'ISTORE.INC'
      INCLUDE 'TYPE11.INC'
      INCLUDE 'STORE.INC'
      INCLUDE 'XSTR11.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XFLAGS.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST11.INC'
      INCLUDE 'XLST12.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XWORKA.INC'
C 
      INCLUDE 'QLST12.INC'
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QSTR11.INC'
C 
      CHARACTER*4 CTYPE
C 
      DATA IVERSN/001/
C 
C--SET UP THE TIMING CONTROL
      CALL XTIME1 (2)
C--PRINT THE PAGE HEADING
      CALL XPRTCN
C--CLEAR THE CORE
      CALL XCSAE
      CTYPE = 'Test'
C----- SPACE FOR ATOM HEADERS
      MQ = KSTALL(100)
C----- COMMAND BUFFER
      IDIMBF = 50
      ICOMBF = KSTALL(IDIMBF)
C----- ZERO THE BUFFER
      CALL XZEROF (ISTORE(ICOMBF),IDIMBF)
C----- COMMON BLOCK OFFSET(-1) FOR INPUT LIST
      IMDINP = 35
C----- INITIALSE LEXICAL PROCESSING
      ICHNG = 1
      CALL XLXINI (INEXTD,ICHNG)
      INCLUDE 'IDIM12.INC'
C 
C--MAIN INSTRUCTION CYCLING LOOP
50    CONTINUE
      IDIRNM = KLXSNG(ISTORE(ICOMBF),IDIMBF,INEXTD)
      IF (IDIRNM.LT.0) GO TO 50
      IF (IDIRNM.EQ.0) GO TO 1950
C--NEXT RECORD HAS BEEN LOADED  -  BRANCH ON THE TYPE
C   1.ATOMS  2.ACTION  3. EVALUATE 4. EXECUTE 5.QUIT 6.DIRECTIVE
      GO TO (300,1500,850,50,1850,150,100),IDIRNM
100   CONTINUE
      GO TO 1800
C 
C  ---- vcv DIRECTIVE ITSELF
150   CONTINUE
C -- LOAD THE RELEVANT LISTS 
C    DONE HERE BECAUSE WE NEED TO KNOW INPUT TYPE (MAY BE 5 OR 10)
      CALL XFAL01
      CALL XFAL02
      IF (IERFLG.LT.0) GO TO 1850
      IULN5 = KTYP05(ISTORE(ICOMBF+IMDINP))
      CALL XLDR05 (IULN5)
      IF (IERFLG.LT.0) GO TO 1850
C----- LOAD LIST 12
      JQ = 0
      JS = 1
C--LOAD LIST 12
      CALL XFAL12 (JS,JQ,JU,JV)
C--LOAD LIST 11
      CALL XFAL11 (1,0)
      IF (IERFLG.LT.0) THEN
         GO TO 1850
      END IF
      IF (ISTORE(L11P+15).GE.0) THEN
         IF (ISSPRT.EQ.0) WRITE (NCWU,200)
         WRITE (CMON,200)
         CALL XPRVDU (NCVDU,3,0)
200      FORMAT (' Matrix is wrong type for e.s.d.''s')
         CALL XERHND (IERWRN)
         IESD = -1
         GO TO 1850
      END IF
C--APPLY THE CORRECT MULTIPLICATION FACTOR TO THE MATRIX
C      NOTE THAT PUNCH 11 C LISTS JUST THE UNSCALED INVERSE MATRIX
      C = STORE(L11P+17)/STORE(L11P+16)
      M11 = L11+N11-1
      DO 250 I = L11,M11
         STR11(I) = STR11(I)*C
250   CONTINUE
C      SAVE THE STORE ADDRESSES
      NFLSAV = NFL
      LFLSAV = LFL
      GO TO 50
C 
C 
C--'ATOM' INSTRUCTION
300   CONTINUE
      NATOM = 0
C     RECOVER MEMORY
      LFL = LFLSAV
      NFL = NFLSAV
      LEF1 = -1
      LEF = 0
C  Z NOT USED AT THE MOMENT.
      Z = 1.
      IERR = +1
C  Create an atom stack similar to the D/A stack
      JSTACK = LFL
      ISTACK = JSTACK
      LSTACK = 14      !SHOULD THIS BE THE SAME AS NW LATER?
C--CHECK FOR SOME ARGUMENTS
      IF (KFDARG(I)) 350,450,450
C--ERROR(S)  -  INCREMENT THE ATOM ERROR COUNT
350   CONTINUE
      LEF2 = LEF2+1
      IERR = -1
      GO TO 50
C--CHECK IF THERE ARE MORE ARGUMENTS ON THIS CARD
400   CONTINUE
      IF (KOP(8)) 750,450,450
C--CHECK IF NEXT ARGUMENT IS A NUMBER
450   CONTINUE
      IF (KSYNUM(Z)) 550,500,550
500   CONTINUE
      ME = ME-1
      MF = MF+LK2
C--READ THE NEXT GROUP OF ATOMS
550   CONTINUE
C--PROCESS THE OUTPUT FROM THE LEXICAL SCANNER TO FIND ATOMS
      IF (KATOMU(LN)) 600,600,650
C--ERRORS  -  INCREMENT THE ATOM ERROR COUNT
600   CONTINUE
      LEF2 = LEF2+1
      IERR = -1
      GO TO 1750
C 
C--MOVE ATOMS TO STACK WITH CORRECT L5 and L12 addresses
650   CONTINUE
C
C
      write(ncwu,'(a)') ' Distance Stack'

      MSTART = MQ
      M5TMP = M5A
      L12TMP = L12A
C 
700   CONTINUE   !loop back here until katomu stack exhausted
C     create a distance-type stack
C 
      ISTACK = ISTACK-LSTACK
      LFL = LFL-LSTACK
      ISTORE(ISTACK) = M5TMP
      ISTORE(ISTACK+12) = L12TMP
C           S,L,T,T,T
      CALL XMOVEI (ISTORE(MSTART+7),ISTORE(ISTACK+2),5)
C           x', y', z'
      CALL XMOVE (STORE(M5TMP+4),STORE(ISTACK+7),3)
      NATOM = NATOM+1

      write(ncwu,6543) natom, istore(istack),
     1 (istore(istack+kkdjw),kkdjw=2,6),
     2 (store(istack+kkdjw),kkdjw=7,9),istore(istack+12)
6543  format('*',i4,2x,i12,5i4,3f10.3,i12)




      MSTART = ISTORE(MSTART)
      M5TMP = M5TMP+MD5A
      L12TMP = L12TMP+MD12A
      IF (MSTART.GT.0) THEN
         GO TO 700
      END IF
      GO TO 400
C 
750   CONTINUE
C     END OF CARD
      LEF2 = LEF2+LEF
C--CHECK THAT THERE IS AT LEAST ONE ATOM ON THIS CARD
C----- save the start of the stack
      JSTACK = ISTACK
      LFL = LFL-1
      IF (NATOM.GE.1) GO TO 50
C--NO ATOMS ON THIS CARD
      CALL XPCLNN (LN)
      IF (ISSPRT.EQ.0) WRITE (NCWU,800)
      WRITE (CMON,800)
      CALL XPRVDU (NCVDU,1,0)
800   FORMAT (' No atoms found')
      GO TO 350
C 
C 
1500  CONTINUE
C      'ACTION'
      IF (NATOM.LE.0) GO TO 50
      LEVEL = 1
      I = IGETVCV(NATOM, JSTACK, LSTACK, IOUT,LEVEL)
c
      IF ( I .LE. 0 ) THEN
            LEF1 = LEF1 + 1
      ELSE
            LEF1 = 0
      ENDIF
C
c     GET NEXT INPUT
      GO TO 50
C
C
C--'EVALUATE' INSTRUCTION  -  CURRENTLY NOT USED
C   cOULD BE USED TO COMPUTE FUNCTIONS OF ATOMS AND THE ESDS
850   CONTINUE
      IF (LEF1) 900,1000,900
C--ERROR BECAUSE NO GROUP HAS BEEN PROCESSED
900   CONTINUE
      CALL XPCLNN (LN)
      IF (ISSPRT.EQ.0) WRITE (NCWU,950) CTYPE
      WRITE (NCWU,950) CTYPE
      WRITE (CMON,950) CTYPE
      CALL XPRVDU (NCVDU,1,0)
c      WRITE (123,'(a)') CMON(1)(:)
950   FORMAT (' Instruction ignored','  -  no ',A,' has been calculated
     1',' or errors have been detected')
      GO TO 50
C--START TO PROCESS THE CARD
1000  CONTINUE
C      IF (KFDARG(I)) 50,1050,1050
C--PRINT A CAPTION
1050  CONTINUE
C--CHECK THE CORE AREA
C      LFL = LFL-MD5A
C      IF (NFL+27-LFL) 1100,1100,1900
1100  CONTINUE
C      CALL XMLTMM (ROF,XCA,XCR,3,3,1)
C--CHECK THE TYPE OF THE NEXT ARGUMENT
C      IF (ISTORE(MF)) 1150,1250,1250
C--CHARACTERS  -  CHECK FOR 'ALL'
1150  CONTINUE
C      IF (KCOMP(1,ISTORE(MF+2),CTARG,1,1)) 1250,1250,1450
C--CHECK IF THERE ARE MORE ARGUMENTS TO BE PROCESSED
1200  CONTINUE
C      IF (KOP(8)) 50,1250,1250
C--FIND THE NEXT GROUP OF ATOMS
1250  CONTINUE
C      IF (KATOMU(LN)) 1850,1850,1300
C--LOOP OVER EACH OF THE ATOMS WE HAVE FOUND
1300  CONTINUE
C      IF (JPUNCH.NE.0) WRITE (NCPU,'(a)') '# EVALUATED ATOMS'
C      DO 1400 J = 1,N5A
C--GENERATE THE TRANSFORMED COORDS.
C         IF (KATOMS(MQ,M5A,LFL)) 1750,1750,1350
C--COMPUTE THE BEST PLANE COORDS.
1350     CONTINUE
C         CALL XMLTMM (RCA,STORE(LFL+4),STORE(LFL+7),3,3,1)
C         M5A = M5A+MD5A
1400  CONTINUE
C      GO TO 1200
C 
C--PRINT ALL THE ATOMS IN LIST 5
1450  CONTINUE
C      J = L5
C
C PRINT VCV MATRIX AS TEST 
C
      WRITE (NCWU,'(//a)') 
     1 ' Variance-covariance matrix of selected atoms'
C
      NWP = NATOM*3
      JDJW = IOUT
      DO 1700 KDJW = 1,NWP
         WRITE (NCWU,'(/)')
         WRITE (NCWU,'(9G12.3)') (STORE(IDJW),IDJW = JDJW,JDJW+NWP-1)
         JDJW = JDJW+NWP
1700  CONTINUE
c
c
      nparam = 3*natom
      IDJW = NFL
      JDJW = NFL+nparam
      KDJW = NFL+2*nparam
      CALL XFILL(1.0, STORE(IDJW), nparam)
      CALL XMLTMM (STORE(IOUT),STORE(IDJW),STORE(JDJW),nparam,nparam,1)
      CALL XMLTTM (STORE(IDJW),STORE(JDJW),STORE(KDJW),1,nparam,1)
      WRITE(NCWU,'(//A,2G15.4)') 
     1' DPROD', STORE(KDJW), sqrt(STORE(KDJW))

      GO TO 50
C
C 
1750  CONTINUE
C   PROCESSING OF CARD ABANDONED
      LEF = LEF+1
      CALL XPCA (I)
      GO TO 50
C 
C--MAIN TERMINATION ROUTINES
C 
1830  continue
      write(ncwu,'(a)') '1830'
C -- ERRORS
1850  CONTINUE
C -- ERRORS
      CALL XOPMSG (IOPAXS,IOPABN,0)
      GO TO 1950
C -- INPUT ERRORS
1800  CONTINUE
      CALL XOPMSG (IOPAXS,IOPCMI,0)
      GO TO 1850
C 
C--NOT ENOUGH CORE
1900  CONTINUE
C -- INSUFFICIENT SPACE
      CALL XOPMSG (IOPREF,IOPSPC,0)
      I = 0
      J = 0
      CALL XSTICA (I,J)
      GO TO 1950
C 
1950  CONTINUE
      CALL XOPMSG (IOPTLS,IOPEND,IVERSN)
      CALL XTIME2 (2)
      CALL XCSAE
      CALL XRSL
      RETURN
      END
C


CODE FOR IGETVCV
      FUNCTION IGETVCV(NATOM, JSTACK, LSTACK, IOUT, LEVEL)
C
C      RETURN VALUES
C      -1 FAIL
C       1 OK
C
C IMPORTANT. NOTE STACK IS STORED AT THE TOP OF STORE
C
C      NATOM - NUMBER OF ATOMS IN STACK
C      JSTACK - START OF STACK
C      LSTACK - LENGTH OF EACH ENTRY IN STACK - PROBABLY 14
C      START OF VCV MATRIX - SET HERE
C      LEVEL 0 NO OUTPUT / 1 STACK OUTPUT
C
C      CREATE A VCV MATRIX FOR ATOMS STORED IN A STACK
C DISTANCE-TYPE STACK (SOME ITEMS NOT USED IN THIS CONTEXT):
C
C   0 I  ADDRESS OF ATOM IN L5 (USE THIS TO FIND THE ATOM TYPE & SERIAL)
C   1    ACCEPTANCE FLAG (NOT USED) 
C   2 I  S, THE SYMMETRY MATRIX TO BE USED (NEGATIVE FOR CofS)
C   3 I  NON-PRIMITIVE LATTICE INDICATOR
C   4 I  T(X)
C   5 I  T(Y)
C   6 I  T(Z)
C   7 R  TRANSFORMED X
C   8 R  TRANSFORMED Y
C   9 R  TRANSFORMED Z
C  10    DISTANCE (NOT USED)
C  11    DISTANCE SQUARED (NOT USED)
C  12 I  ADDRESS IN LIST 12.
C  13    TARGET CONTACT DISTANCE FOR RESTRAINTS (NOT USED)
C
      DIMENSION SMAT(3,3)
      INCLUDE 'ICOM12.INC'
      INCLUDE 'ISTORE.INC'
      INCLUDE 'TYPE11.INC'
      INCLUDE 'STORE.INC'
      INCLUDE 'XSTR11.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST11.INC'
      INCLUDE 'XLST12.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XUNITS.INC'
c---- removed by djw July 2011 - not needed here and clashes with
c     calling routines
c      INCLUDE 'XCONST.INC'
c      INCLUDE 'XFLAGS.INC'
c      INCLUDE 'XCHARS.INC'
c      INCLUDE 'XLEXIC.INC'
c      INCLUDE 'XLISTI.INC'
C      INCLUDE 'XWORKA.INC'
C 
      INCLUDE 'QLST12.INC'
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QSTR11.INC'
C
C----- SET NPARAM PER ATOM (3 for x,y,z)
      NPARAM = 3
C--SET UP THE WORKSPACE FOR E.S.D.'S
      NWP = NATOM*NPARAM
      NWS = 4
      NW = 13
      JU = 1
      JV = 3
C--SET A FEW AREAS OF CORE FOR E.S.D. CALCLATION
      JA = NFL
      MXPPP = 50       ! MAXIMUM NUMBER OF PARTS PER PARAMETER.
      JD = JA+NWP*NWS*MXPPP
      NZ = NWP*NWP      !NWP
      JE = JD+NZ
      JF = JE+NZ
      JG = JF+NZ
      JPART = JG+NWP*NWP
      NPARAM = 3
      NWP = NATOM*NPARAM
C 
C--COMPUTE THE LENGTH OF THE DATA AREA
      JS = JPART+MXPPP-NFL
C--ALLOCATE THE SPACE
      LN = 9
      IREC = 1001
      I = KCHNFL(JS)
C--ZERO THE AREA INITIALLY
      CALL XZEROF (STORE(JA),JS)
C      save space for the initial vcv matrix, the overall
C      symmetry matrices, work area and the final vcv matrix
      IAREA = NWP*NWP
      IIN = NFL
      IOUT = NFL+IAREA
      ISYMM = IOUT+IAREA
      IWORK = ISYMM+IAREA
      I = KCHNFL(4*IAREA)
      CALL XZEROF (STORE(IIN),4*IAREA)
C 
C----- now loop over the stored atoms
      ISTACK = JSTACK+(NATOM-1)*LSTACK
      IPART = JPART
      JB = JA
C 
      DO 1650 I = 1,NATOM
         IRES = KATOMZ(ISTACK+2,SMAT)
         IF (IRES.LE.0) GO TO 1850
         IF ((ISSPRT.EQ.0).AND.(LEVEL.EQ.1))
     1    WRITE (NCWU,'(A4,I5, 5I4,3F8.4)') STORE(ISTORE(ISTACK)),
     2    NINT(STORE(ISTORE(ISTACK)+1)),
     2   (ISTORE(IDJW),IDJW = ISTACK+2,ISTACK+6),
     2   (STORE(IDJW),IDJW = ISTACK+7,ISTACK+9)
C 
C  FORM THE TOTAL SYMMETRY MATRIX
C 
C      column and row addresses
         IADD = (I-1)*NPARAM*NWP
         IROW = (I-1)*NPARAM
         DO 1600 K = 1,NPARAM
            KADD = (K-1)*NWP
            DO 1550 J = 1,NPARAM
               ICELL = IADD+IROW+KADD+J-1
               STORE(ISYMM+ICELL) = SMAT(J,K)
1550        CONTINUE
1600     CONTINUE
C 
         M12TMP = ISTORE(ISTACK+12)
C 
C      FORM POSITIONAL COORDINATE ERROR STACK
C
         KB = JB

         CALL XFPCES (M12TMP,JB,NWS,ISTORE(IPART))



c         WRITE(CMON,'(2(A,I9))')'Atom ',I, ' parts: ', ISTORE(IPART)
c         CALL XPRVDU (NCVDU,1,0)

c         DO JJ = 1, ISTORE(IPART)*3
c           WRITE(CMON,'(A,4I9,F10.6)')'Part ',JJ,
c     1      ISTORE(KB+(JJ-1)*4),ISTORE(KB+1+(JJ-1)*4),
c     1      ISTORE(KB+2+(JJ-1)*4),STORE(KB+3+(JJ-1)*4)
c         CALL XPRVDU (NCVDU,1,0)
c         END DO
C 
         IPART = IPART+1
         ISTACK = ISTACK-LSTACK
1650  CONTINUE
C--CALCULATE THE V/CV MATRIX FOR THE POSITIONAL ERRORS
C 
      CALL XCOVAR (JA,NWP,NWS,JD,JE,ISTORE(JPART),NATOM)
      CALL XMOVE (STORE(JD),STORE(IIN),IAREA)
C pre and post multiply VCV by symmetry matrix
      CALL XMLTMM (STORE(ISYMM),STORE(IIN),STORE(IWORK),NWP,NWP,NWP)
C 
      CALL XMLTMT (STORE(IWORK),STORE(ISYMM),STORE(IOUT),NWP,NWP,NWP)
C
C      SCALE BY CELL EDGES - 
C      sHOULD THIS BE PRE/POST MULT BY ORTHOGONALISATION MATRIX?
      CALL XZEROF(STORE(IIN), IAREA)
      J = IWORK
      DO I=1, NATOM
        STORE(J) = STORE(L1P1)
        STORE(J+NWP+1) = STORE(L1P1+1)
        STORE(J+NWP+NWP+2) = STORE(L1P1+2)
        J = J + 3*NWP+NPARAM
      ENDDO
      CALL XMLTMM (STORE(IWORK),STORE(IOUT),STORE(IIN),NWP,NWP,NWP)
      CALL XMLTMM (STORE(IIN),STORE(IWORK),STORE(IOUT),NWP,NWP,NWP)
C 
        NWP = NATOM*3
        IF((ISSPRT.EQ.0).AND.(LEVEL.EQ.1)) THEN
         WRITE (NCWU,'(/a/)')
     1  'Variance-covariance matrix of selected atoms (x10^6)'
         JDJW = IOUT
         DO 7700 KDJW = 1,NWP
          WRITE (NCWU,'(12F8.3)') 
     1    (1000000*STORE(IDJW),IDJW = JDJW,JDJW+NWP-1)
          JDJW = JDJW+NWP
7700     CONTINUE
         WRITE (NCWU,'(//)')
        ENDIF
c
      IGETVCV = 1
      GOTO 1900
1850  CONTINUE
C      FAIL
      IGETVCV = -1
1900  CONTINUE
      RETURN
      END
C
C
C
CODE FOR KATOMZ
      FUNCTION KATOMZ (LOCD,SMAT)
C--GET SYMMETRY INFORMATION STORED
C  IN AN ATOM HEADER.
C  SMAT IS THE ROTATIONAL PART OF THE SYMMETRY
C 
C  LOCD  LOCATION OF THE SYMMETRY DATA s, l, tx, ty,tz
C  SMAT  3X3 SYMMETRY MATRIX
C 
C--RETURN VALUES ARE :
C 
C  -1  ERROR IN FORMING THE ATOM
C  >0  ok
C 
      DIMENSION SMAT(9)
C 
C--
      INCLUDE 'ISTORE.INC'
C 
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST02.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'QSTORE.INC'
C 
C 
C--CHECK THAT THE SYMMETRY OPERATORS ARE VALID
      M = IABS(ISTORE(LOCD))-1
      IF (M) 450,50,50
50    CONTINUE
      IF (M-N2) 100,450,450
100   CONTINUE
      IF (ISTORE(LOCD+1)) 450,450,150
150   CONTINUE
      IF (ISTORE(LOCD+1)-N2P) 200,200,450
200   CONTINUE
      A = FLOAT(ISTORE(LOCD))
      A = SIGN(1.,A)
C--APPLY THE SYMMETRY MATRIX
      M = M*MD2+L2
C      SAVE THE SYMMETRY MATRIX
      CALL XMOVE (STORE(M),SMAT,9)
      DO 300 III = 1,9
         SMAT(III) = A*SMAT(III)
300   CONTINUE
      KATOMZ = 1
400   CONTINUE
      RETURN
C 
C--ERRORS FOUND
450   CONTINUE
      I = LOCD
      J = LOCD+4
      CALL XERHDR (0)
      IF (ISSPRT.EQ.0) THEN
         WRITE (NCWU,500) (ISTORE(K),K = I,J)
      END IF
      WRITE (CMON,500) (ISTORE(K),K = I,J)
      CALL XPRVDU (NCVDU,1,0)
500   FORMAT (' Illegal symmetry operators specified',3X,'S(I)  = ',I4,
     13X,'L  = ',I4,3X,'With translations : ',3I4)
      I = 100
      KATOMZ = -1
      GO TO 400
      END






CODE FOR SUSCAL
      SUBROUTINE SUSCAL
C--MAIN DISTANCE ESD IMPROVEMENT ROUTINE
C
C---- NOTE THAT THIS USES THE ORIGINAL LEXICAL SCANNER, NOT THE
C     LATER SINGLE-STEP SCANNER.
C--
      DIMENSION VCVVEC(8192)
      REAL VCVVSZ
	  COMMON /VCVTMP/ VCVVSZ, VCVVEC
	  
      DIMENSION LATOM(4)
      DIMENSION R(2,3), SD(2,3), XYZ(3)
      DIMENSION RI(3,2),  VCV(6,6)
	  DIMENSION ZZZ(1)
      CHARACTER *12 CBUFF
      CHARACTER *32 CATOM(2), CBLANK
      INCLUDE 'ICOM12.INC'
      INCLUDE 'ICOM30.INC'
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'TYPE11.INC'
      INCLUDE 'XSTR11.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XTAPES.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XLST02.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST11.INC'
      INCLUDE 'XLST12.INC'
      INCLUDE 'XLST30.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XWORKA.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QLST12.INC'
      INCLUDE 'QLST30.INC'
C 
      INCLUDE 'QSTR11.INC'
C 

      DATA IVERSN  /1/
      DATA CBLANK /' '/
      DATA AZERO /0.0/
C
      REWIND (MTE)
c----- Set print flag to no
CDJWJAN06
c      MY = 0
c      MW = 0
c      MV = 0
C
C--SET UP THE TIMING CONTROL
      CALL XTIME1(2)
C--READ THE INPUT CONTROL CARDS WITH THE LEXICAL SCANNER
      ISTAT = KLEXAN ( IULN , IFIRST , LENGTH )
      IF ( ISTAT .LT. 0 ) GO TO 9910
C----- GET THE PUBLICATION ETC FLAG FROM THE LEXICAL COMMON BLOCK
      IPBFLG = MY
      LEVEL = MW
      JESD = 1
      write(ncwu,*)'IPBFLG, LEVEL, JESD', my,mw,mv,mx
C--CLEAR THE CORE
      CALL XRSL
      CALL XCSAE
C----- SET UP A DISTANCE-TYPE STACK OF ONLY 2 ATOM FOR THE ESDS
C      FROM THE FULL VCV MATRIX
C      (SOME ITEMS NOT USED IN THIS CONTEXT):
C
C   0 I  ADDRESS OF ATOM IN L5 (USE THIS TO FIND THE ATOM TYPE & SERIAL)
C   1    ACCEPTANCE FLAG (NOT USED) 
C   2 I  S, THE SYMMETRY MATRIX TO BE USED (NEGATIVE FOR CofS)
C   3 I  NON-PRIMITIVE LATTICE INDICATOR
C   4 I  T(X)
C   5 I  T(Y)
C   6 I  T(Z)
C   7 R  TRANSFORMED X
C   8 R  TRANSFORMED Y
C   9 R  TRANSFORMED Z
C  10    DISTANCE (NOT USED)
C  11    DISTANCE SQUARED (NOT USED)
C  12 I  ADDRESS IN LIST 12.
C  13    TARGET CONTACT DISTANCE FOR RESTRAINTS (NOT USED)
C
      NATOMAX = 2 ! MAXIMUM NUMBER OF ATOMS IS A SINGLE TORSION SET
      JSTACK = LFL
      ISTACK = JSTACK
      LSTACK = 14      !SHOULD THIS BE THE SAME AS NW LATER?
      LFL = LFL - LSTACK*NATOMAX !NATOMAX ATOMS
C
C--LOAD THE RELEVANT LISTS
      CALL XFAL01
      CALL XFAL02
c
C----- GET THE LIST TYPE FROM THE LEXICAL COMMON BLOCK
      IULN5=KTYP05(MX)
      CALL XLDR05(IULN5)
      IF ( IERFLG .LT. 0 ) GO TO 9900
      INCLUDE 'IDIM12.INC'
C-----------------------------------------------------------
      IESD = -1
      ESD = 0.
      IF (JESD .GE. 1) THEN
       IF ((KEXIST(12).LE.0).OR.(KEXIST(11).LE.0)
     1                      .OR. (KEXIST(22).LE.0)) THEN
C       INDICATE THAT LIST 12 IS NOT TO BE USED
         DO  I=1,IDIM12
           ICOM12(I)=NOWT
         ENDDO
         GOTO 2851
       ELSE
C----- LOAD LIST 12
         JQ = 0
         JS = 1
C--LOAD LIST 12
         CALL XFAL12 (JS,JQ,JU,JV)
         IF (IERFLG.GE.0) I = KSET52(0,-1)
C--LOAD LIST 11
         IF (IERFLG.GE.0) CALL XFAL11 (1,0)
         IF (IERFLG.LT.0) THEN
C        CLEAR ERROR FLAG 
          IERFLG = 0
         ELSE
          IF (ISTORE(L11P+15).GE.0) THEN
            IF (ISSPRT.EQ.0) WRITE (NCWU,200)
            WRITE (CMON,200)
            CALL XPRVDU (NCVDU,3,0)
200         FORMAT (' Matrix is wrong type for e.s.d.''s')
            CALL XERHND (IERWRN)
          ELSE
C        APPLY THE CORRECT MULTIPLICATION FACTOR TO THE MATRIX
C        NOTE THAT PUNCH 11 C LISTS JUST THE UNSCALED INVERSE MATRIX
            C = STORE(L11P+17)/STORE(L11P+16)

            WRITE(CMON,'(A,F12.8)')'VCv multiplier: ', C
            CALL XPRVDU (NCVDU,1,0)
			SRTC = SQRT(C)
c            M11 = L11+N11-1
c            DO I = L11,M11
c              STR11(I) = STR11(I)*C
c            END DO
            IESD = 1
         ENDIF
        ENDIF
       ENDIF
      ENDIF
C--LIST READ IN OKAY  -  SET UP THE INITIAL CONTROL FLAGS
      CALL XILEXP(IULN,IFIRST)
C-----------------------------------------------------------
c
C--PRINT THE INITIAL CAPTIONS
      CALL XPRTCN

      IF (JESD .GE.1)  THEN
        IF  (IESD .LE. 0) THEN
            WRITE(CMON,'(A)') 
     1 '{E Matrix for e.s.ds missing. Using mean errors instead'
        ELSE
            WRITE(CMON,'(A)') 
     1 ' The SU is computed from the full VcV matrix if available'
        ENDIF
      ELSE
        WRITE(CMON,'(A)')
     1 ' The su is computed from the mean atomic variances'
      ENDIF
      CALL XPRVDU (NCVDU,1,0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') CMON(1)(:)
C
      WRITE ( CMON,1150)
      CALL XPRVDU(NCVDU, 1,0)
      IF (ISSPRT .EQ. 0) THEN
        IF (IESD .EQ. 1) THEN
            WRITE(NCWU, 1151)
        ELSE
            WRITE(NCWU, 1150) 
        ENDIF
      ENDIF
1150  FORMAT(53X, ' Dist & su')
1151  FORMAT(53X, ' Dist & su    VcV-su')
C--SET THE ERROR COUNTERS
      LEF=0
      LSTLEF=0
C
C--PROCESS THE NEXT CARD FROM THE DISC
1200  CONTINUE
      IF(KLDNLR(I))2950,1250,1200
C--CHECK THAT THE FUNCTION IS FOR AN 'ATOM' CARD
1250  CONTINUE
      IF(MG-1)1200,1300,1200
C--CHECK IF A NEW CAPTION IS REQUIRED
1300  CONTINUE
      IF(LEF-LSTLEF)1350,1400,1350
C--NEW CAPTION IS REQUIRED
1350  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1150)
      ENDIF
C--RESET THE ERROR COUNTER
1400  CONTINUE
      LSTLEF=LEF
C
C--START OF 'ATOM' CARD
      NATOM=0
c---- re-set the start of the distance-type stack for the vcv
      ISTACK = JSTACK
C--SET ASIDE AN AREA IN WHICH GENERATED PARAMETERS CAN BE STORED
      JUNK=NFL
      NFL=NFL+MD5
      IONES=NFL
      NFL=NFL+6
      ISCRAT=NFL
      NFL=NFL+N12
	  DO I=0,5
	    STORE(IONES+I)=1.0
      END DO
C
C--SET UP THE POINTER FOR THE FIRST ATOM FOUND  -  A STACK IS FORMED HER
      IBASE=NFL
C--SET UP THE NUMBER OF WORDS IN THE STACK
      NWS=9
c----- save room for 2 blocks of atom data
      IDJW = KCHNFL(2*NWS)
C--SET THE RUNNING POINTER TO THE STACK  -  'JD'
c-- step backwards because later we step forwards!!
      JD=IBASE-NWS
C--CHECK FOR ARGUMENTS
      IF(ME)1500,1500,1600
C--NO ARGUMENTS FOUND
1500  CONTINUE
      CALL XPCLNN(LN)
      WRITE ( CMON,1550)
      CALL XPRVDU(NCVDU, 1,0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') CMON(1 )(:)
1550  FORMAT(' No arguments found')
      GOTO 1200
C--ARGUMENTS TO BE PROCESSED  -  CHECK FOR AN OPERAND
1600  CONTINUE
      IF(ISTORE(MF))1750,1650,1650
C--ARGUMENT IS OF THE WRONG TYPE
1650  CONTINUE
      CALL XPCLNN(LN)
      WRITE ( CMON,1700)
      CALL XPRVDU(NCVDU, 1,0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') CMON(1 )(:)
1700  FORMAT(' Only atoms may appear on an ''ATOM'' card')
      GOTO 2650
C--PICK UP ATOM SPECIFICATION AND FIND THE ATOMS IN LIST 5
1750  CONTINUE
      JC = 0
      IF(KATOMU(JC))2650,2650,1800
C--UPDATE THE NUMBER OF ATOMS FOUND
1800  CONTINUE
C
      NATOM=NATOM+N5A
C--= RESTRICT STACK
      IF (NATOM .GT. NATOMAX) THEN
        NATOM =NATOMAX
C TODO: RE-SET N5A if too many atoms
        WRITE(CMON,'(A,I4,a)')'List restricted to',natom,' atoms'
        CALL XPRVDU(NCVDU,1,0)
      ENDIF
650   CONTINUE
c
C----- THE DISTANCE STACK DETAILS
C----- LOOP OVER THE ATOMS FOUND AND STORE THEM
C
C      FIRST CREATE A DISTANCE-TYPE STACK FOR THE VCV CODE
      MSTART = MQ
      M5TMP = M5A
      IF (IESD .EQ. 1)  L12TMP = L12A
c
c  NOW CREATE THE ORIGINAL hOURANI sTACK FOR THE OLD CODE
C  NOTE THAT WE HAVE POSITIONS IN BOTH STACKS FOR THE MOMNET
C  THE HOURANI STACK CAN GO ONCE WE ARE HAPPY WITH THE NEW CODE
      DO 1950 JE=1,N5A
      JD=JD+NWS
      NFL=NFL+NWS
      IF(NFL+27-LFL)1850,1850,2800
1850  CONTINUE
C--GENERATED THE MOVED PARAMETERS
c
      IF(KATOMS(MQ,M5A,JUNK))2650,2650,1900
1900  CONTINUE
C--MOVE THE GENERATED COORDINATES TO THEIR PLACE ON THE STACK
      CALL XMOVE(STORE(JUNK+4),STORE(JD),3)
C--STORE THE ADDRESS OF THE ATOM IN LIST 5
      ISTORE(JD+3)=M5A
C--STORE THE SYMMETRY OPERATORS USED TO GENERATE THE NEW COORDS.
      ISTORE(JD+4)=ISTORE(MQ+7)
      ISTORE(JD+5)=ISTORE(MQ+8)
      ISTORE(JD+6)=ISTORE(MQ+9)
      ISTORE(JD+7)=ISTORE(MQ+10)
      ISTORE(JD+8)=ISTORE(MQ+11)
C
      IF (IESD .EQ. 1) THEN
C     CREATE THE DISTANCE-TYPE STACK
       ISTACK = ISTACK-LSTACK
       ISTORE(ISTACK) = M5TMP
       ISTORE(ISTACK+12) = L12TMP
C           S,L,T,T,T
       CALL XMOVEI (ISTORE(MSTART+7),ISTORE(ISTACK+2),5)
C           x', y', z'
       CALL XMOVE (STORE(junk+4),STORE(ISTACK+7),3)
C--UPDATE FOR THE NEXT ATOM
       L12TMP = ISTORE(L12TMP)
      ENDIF
      M5TMP = M5TMP+MD5A
      M5A=M5A+MD5A
1950  CONTINUE
c
C--CHECK FOR END OF CARD NOW
      IF(KOP(8))2000,1600,1600
C--END OF CARD  -  CHECK THE NUMBER OF ATOMS FOUND
2000  CONTINUE
      IF(NATOM.LT.2)THEN
C--NOT ENOUGH ATOMS
        CALL XPCLNN(LN)
        WRITE ( CMON,2100)
        CALL XPRVDU(NCVDU, 1,0)
        IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') CMON(1 )(:)
2100    FORMAT(' Not enough atoms provided')
        GOTO 2650
      END IF

C--SET POINTERS TO THE FIRST THREE ATOMS IN THE STACK
2150  CONTINUE
C---- SAVE THE START OF THE DISTANCE-TYPE STACK
      JSTACK = ISTACK
c
c      write(ncwu,*)'Stack dump', jstack, lstack, natom
c      ikdjw = jstack
c      do iidjw = 1, natom
c        write(ncwu,*) (istore(ikdjw+ildjw),ildjw=0,lstack-1)
c        ikdjw = ikdjw + lstack
c        write(ncwu,'(/)')
c      enddo
c
      IBASE1=IBASE
      IBASE2=IBASE+NWS
CDJWAPR07      
      CALL XMLTTM(STORE(L1O1),STORE(ibase1),xyz,3,3,1)
      r(1,1)=xyz(1)
      r(1,2)=xyz(2)
      r(1,3)=xyz(3)
      CALL XMLTTM(STORE(L1O1),STORE(ibase2),xyz,3,3,1)
      r(2,1)=xyz(1)
      r(2,2)=xyz(2)
      r(2,3)=xyz(3)

      JF=ISTORE(IBASE1+3)
C--FIX THE SERIAL NUMBER
      JB=JA+4

C----- COMPRESS ATOMS INTO CHARACTER FORM
      CALL CATSTR (STORE(JF)    ,STORE(JF+1)  ,ISTORE(JB)
     1 ,ISTORE(JB+1) ,ISTORE(JB+2) ,ISTORE(JB+3) ,ISTORE(JB+4),
     2 CATOM(1), LATOM(1))

      JF=ISTORE(IBASE2+3)
C--FIX THE SERIAL NUMBER
      JB=JA+4

C----- COMPRESS ATOMS INTO CHARACTER FORM
      CALL CATSTR (STORE(JF)    ,STORE(JF+1)  ,ISTORE(JB)
     1 ,ISTORE(JB+1) ,ISTORE(JB+2) ,ISTORE(JB+3) ,ISTORE(JB+4),
     2 CATOM(2), LATOM(2))

C--CALCULATE DISTANCE
      DIST = SQRT((R(1,1)-R(2,1))**2 +
     1            (R(1,2)-R(2,2))**2 +
     2            (R(1,3)-R(2,3))**2)
      IF (IESD .EQ. 1) THEN
c        I = IGETVCV(2, JSTACK, LSTACK, IOUT, LEVEL)
        CALL XTRANS(R, RI, 2, 3)
        CALL XTDFUN(RI, IONES)
        WRITE(CMON,'(A,6F10.6)')'IOnes ',(STORE(JJ+IONES),JJ=0,5)
 	    CALL XPRVDU (NCVDU,1,0)

        I = JGETVCV(2, JSTACK, LSTACK, IOUT, LEVEL, IONES)
        NWP = 2*3
	
		DO I = 0, N12-1
		  STORE(IOUT+I) = STORE(IOUT+I)*SRTC
c		  WRITE(123,'(F15.10)') STORE(IOUT+I)
		END DO

		CALL XMOVE ( STORE(IOUT), VCVVEC(1), N12 )
		VCVVSZ = N12
		
C Test Variance calc
c 	    WRITE(123,'(a)') ' ' 
c        DO I = 0, N11
c		   WRITE(123,'(F15.10)') STR11(L11+I)
c		END DO
c 	    WRITE(123,'(a)') ' ' 

        CALL XZEROF(STORE(ISCRAT),N12)
        DO I = 0,N12-1
 		  DO J = 0,N12-1
		   IF ( J .GE. I ) THEN  ! 1,1; 2,1; 2,2; 3,1; etc.
			   II = N12-I
     		   IROW = N11-((II)*(II+1)/2)  ! -0,-1,-3,-6,-10...
		       IOFF = J-I
		   ELSE
			   JJ = N12-J
    		   IROW = N11-((JJ)*(JJ+1)/2) 
		       IOFF = I-J
		   END IF
  		   
c		   WRITE(123,'(F15.10)') STR11(L11+IROW+IOFF)

		   WRITE(CMON,'(4(A,I4),A)') 'TMP(',I, ') += VCV(',I, 
     1		                        ',',J, ') * IOUT(',J ,')'
   	       CALL XPRVDU (NCVDU,1,0)
		   WRITE(CMON,'(2(A,I4),A,F15.12)') 'VCV(',I,  ',',J, ') = ', 
     1                              STR11(L11+IROW+IOFF)
   	       CALL XPRVDU (NCVDU,1,0)
		   STORE(ISCRAT+I) = STORE(ISCRAT+I) 
     1	 	   + STORE(IOUT+J)*STR11(L11+IROW+IOFF)
	      END DO
		END DO

        CALL XMLTMM(STORE(ISCRAT),STORE(IOUT),ZZZ,1,N12,1)
				
        ESD = SQRT(ZZZ(1))
      ENDIF
c
c
        WRITE ( CMON ,2806) (
     1 CBLANK(1: 10-LATOM(II)), CATOM(II)(1:LATOM(II)),II=1,2)
     2 ,DIST, DIST2, ESD
      CALL XPRVDU(NCVDU, 1, 0)
c
      IF (ISSPRT .EQ. 0) THEN
        IF (IESD .EQ. 1) THEN
       WRITE(NCWU, 2806)(
     1 CBLANK(1: 10-LATOM(II)), CATOM(II)(1:LATOM(II)),II=1,2)
     2 ,DIST, ESD2 
        ELSE
       WRITE(NCWU, 2806)(
     1 CBLANK(1: 10-LATOM(II)), CATOM(II)(1:LATOM(II)),II=1,2)
     2 ,DIST, ESD
        ENDIF
      ENDIF
2806  FORMAT (2A, ' to ', 2A, T30,4F10.6)
      GOTO 1200
C
C--CARD PROCESSING ABANDONED
2650  CONTINUE
      CALL XPCA(ISTORE(MD+4))
      GOTO 1200
C
C--NOT ENOUGH CORE AVAILABLE
2800  CONTINUE
      CALL XICA
      GOTO 2950

C--VCV not available
2851  CONTINUE
      CALL XPCLNN(LN)
      WRITE ( CMON,2901)
      CALL XPRVDU(NCVDU, 1,0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') CMON(1 )(:)
2901  FORMAT(' Covariance matrix not available. Do some refinement.')
      GOTO 2650
C
C--TERMINATION OF THE PROCESSING
2950  CONTINUE
      IESD = 0
      IF (IPBFLG .EQ. 1) THEN
        CALL XPRTDA (4,IESD,NCPU)
      ELSE  IF (IPBFLG .EQ. 2) THEN
        CALL XPRTDA (14,IESD,NCPU)
      ENDIF
      CALL XOPMSG (IOPTOR, IOPEND, IVERSN)
      CALL XTIME2(2)
      RETURN
C
9900  CONTINUE
C -- ERRORS
      CALL XOPMSG ( IOPTOR , IOPABN , 0 )
      GO TO 2950
9910  CONTINUE
C -- INPUT ERROR
      CALL XOPMSG ( IOPTOR , IOPABN , 0 )
      GO TO 9900
      END
C


CODE FOR XTDIST
      SUBROUTINE XTDIST(RI, VCV, DIST, ESD)
C
C      COMPUTE THE DISTANCE AND ITS
C      ESD FROM THE FULL VCV MATRIX, INCLUDING SYMMETRY
C
C      RI 3,2 MATRIX OF ORTHOGONAL POSTITIONS
C      VCV 6X6 ORTHOGONAL VCV MATRIX
C
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XCONST.INC'
      DIMENSION RI(3,2), VCV(6,6)
      DIMENSION VECTOR(6), SCRATCH(6), ZZZ(1)
      DIMENSION RDEL(3)
C
      DO I = 1,3
            RDEL(I) = RI(I,1) - RI(I,2)
      ENDDO
C
      CALL DVPROD(RDEL,RDEL,DISTS)
      DIST = SQRT(DISTS)
C
      DO I = 1,3
         VECTOR(I) = RDEL(I)/DIST
         VECTOR(I+3) = -VECTOR(I)
         WRITE(CMON,'(2F11.7)') VECTOR(I), VECTOR(I+3)
         CALL XPRVDU(NCVDU, 1, 0)
      ENDDO
C
      DO I = 1,6
         WRITE(CMON,'(6F11.7)') (VCV(I,J),J=1,6)
         CALL XPRVDU(NCVDU, 1, 0)
      ENDDO
      

      CALL XMLTMM(VCV, VECTOR, SCRATCH, 6, 6, 1)

      WRITE(CMON,'(6F11.7)') (SCRATCH(J),J=1,6)
      CALL XPRVDU(NCVDU, 1, 0)


      CALL XMLTMM(VECTOR, SCRATCH, ZZZ, 1, 6, 1)

      WRITE(CMON,'(3F15.9)') ZZZ(1), ZERO, ZEROSQ
      CALL XPRVDU(NCVDU, 1, 0)


C----- CHECK FOR -VE VARIANCE DUE TO ROUNDING ERRORS
C      ALLOW TO FAIL (ZZZ SET TO NaN) IF VERY -VE.
      IF (ABS(ZZZ(1)).LE. ZEROSQ)  ZZZ(1) = ZEROSQ
C
      ESD = SQRT(ZZZ(1))
C
      RETURN
      END
C
CODE FOR XTDFUN
      SUBROUTINE XTDFUN(RI, JFUNC)
C
C      COMPUTE THE DISTANCE DERIVATIVES
C
C      RI 3,2 MATRIX OF ORTHOGONAL POSTITIONS
C      JFUNC TO receive 6 derivatives for distance
C
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XCONST.INC'
	  INCLUDE 'STORE.INC'
      DIMENSION RI(3,2)
      DIMENSION RDEL(3)
C
      DO I = 1,3
            RDEL(I) = RI(I,1) - RI(I,2)
      ENDDO
      CALL DVPROD(RDEL,RDEL,DISTS)
      DIST = SQRT(DISTS)
      DO I = 1,3
         STORE(JFUNC+I-1) = RDEL(I)/DIST
         STORE(JFUNC+I+2) = -STORE(JFUNC+I-1)
         WRITE(CMON,'(2F11.7)') STORE(JFUNC+I-1), STORE(JFUNC+I+2)
         CALL XPRVDU(NCVDU, 1, 0)
      END DO
      RETURN
      END


C Like IGETVCV, but returns the matrix to pre and post multiply the VCV to get results.
CODE FOR JGETVCV
      FUNCTION JGETVCV(NATOM, JSTACK, LSTACK, IOUT, LEVEL, JFUNC)
C
C      RETURN VALUES
C      -1 FAIL
C       1 OK
C
C IMPORTANT. NOTE STACK IS STORED AT THE TOP OF STORE
C
C      NATOM - NUMBER OF ATOMS IN STACK
C      JSTACK - START OF STACK
C      LSTACK - LENGTH OF EACH ENTRY IN STACK - PROBABLY 14
C      IOUT - START OF VCV MULTIPLIER - SET HERE
C      LEVEL - 0 NO OUTPUT / 1 STACK OUTPUT
C      JFUNC - deriv of function wrt atom params

C E.g. distance between two atoms is
C     a'.g'.S'.C'.V.C.S.g.a 
C  where a is the derivative of the distance function wrt c1x c1y c1z c2x c2y c2z
C        g is the diagonal of cell edges (twice)
C        S is the block diagonal symmetry ops
C        C maps c1x, ..., c2z onto the VCV matrix.
C  we return C.S.g.a at IOUT. Length is n lsq params
C
C DISTANCE-TYPE STACK (SOME ITEMS NOT USED IN THIS CONTEXT):
C
C   0 I  ADDRESS OF ATOM IN L5 (USE THIS TO FIND THE ATOM TYPE & SERIAL)
C   1    ACCEPTANCE FLAG (NOT USED) 
C   2 I  S, THE SYMMETRY MATRIX TO BE USED (NEGATIVE FOR CofS)
C   3 I  NON-PRIMITIVE LATTICE INDICATOR
C   4 I  T(X)
C   5 I  T(Y)
C   6 I  T(Z)
C   7 R  TRANSFORMED X
C   8 R  TRANSFORMED Y
C   9 R  TRANSFORMED Z
C  10    DISTANCE (NOT USED)
C  11    DISTANCE SQUARED (NOT USED)
C  12 I  ADDRESS IN LIST 12.
C  13    TARGET CONTACT DISTANCE FOR RESTRAINTS (NOT USED)
C
      DIMENSION SMAT(3,3)
      INCLUDE 'ICOM12.INC'
      INCLUDE 'ISTORE.INC'
      INCLUDE 'TYPE11.INC'
      INCLUDE 'STORE.INC'
      INCLUDE 'XSTR11.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST11.INC'
      INCLUDE 'XLST12.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XUNITS.INC'
c---- removed by djw July 2011 - not needed here and clashes with
c     calling routines
c      INCLUDE 'XCONST.INC'
c      INCLUDE 'XFLAGS.INC'
c      INCLUDE 'XCHARS.INC'
c      INCLUDE 'XLEXIC.INC'
c      INCLUDE 'XLISTI.INC'
C      INCLUDE 'XWORKA.INC'
C 
      INCLUDE 'QLST12.INC'
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QSTR11.INC'
C
C----- SET NPARAM PER ATOM (3 for x,y,z)
      NPARAM = 3
C--SET UP THE WORKSPACE FOR E.S.D.'S
      NWP = NATOM*NPARAM
      NWS = 4
      NW = 13
      JU = 1
      JV = 3
C--SET A FEW AREAS OF CORE FOR E.S.D. CALCLATION
      JA = NFL
      MXPPP = 50       ! MAXIMUM NUMBER OF PARTS PER PARAMETER.
      JD = JA+NWP*NWS*MXPPP
      NZ = NWP*NWP      !NWP
      JE = JD+NZ
      JF = JE+NZ
      JG = JF+NZ
      JPART = JG+NWP*NWP
      NPARAM = 3
      NWP = NATOM*NPARAM
C 
C--COMPUTE THE LENGTH OF THE DATA AREA
      JS = JPART+MXPPP-NFL
C--ALLOCATE THE SPACE
      LN = 9
      IREC = 1001
      I = KCHNFL(JS)
C--ZERO THE AREA INITIALLY
      CALL XZEROF (STORE(JA),JS)
C      save space for the initial vcv matrix, the overall
C      symmetry matrices, work area and the final vcv matrix
      IAREA = NWP*NWP
      IOUT = NFL ! Our special output vector.
      ISYMM = IOUT+N12  ! The symmetry block diagonal
      IWORK = ISYMM+IAREA   ! Work space
      IWORK2 = IWORK+6   ! Work space
      I = KCHNFL(N12 + IAREA + 12)
      CALL XZEROF (STORE(IOUT),N12+IAREA+12)
C 
      ISTACK = JSTACK+(NATOM-1)*LSTACK
      JB = JA
      DO I = 1,NATOM
         IRES = KATOMZ(ISTACK+2,SMAT)
         IF (IRES.LE.0) GO TO 1850
C  FORM THE TOTAL SYMMETRY MATRIX
C      column and row addresses
         IADD = (I-1)*NPARAM*NWP
         IROW = (I-1)*NPARAM
         DO K = 1,NPARAM
            KADD = (K-1)*NWP
            DO J = 1,NPARAM
               ICELL = IADD+IROW+KADD+J-1
               STORE(ISYMM+ICELL) = SMAT(J,K)
c               STORE(ISYMM+ICELL) = 1.0
c               WRITE(CMON,'(A,I4)')'Symm add ',ICELL
c         	   CALL XPRVDU (NCVDU,1,0)
			END DO
		 END DO
         ISTACK = ISTACK-LSTACK
	  END DO

  
      DO JJ = 0,5
        WRITE(CMON,'(A,6F10.6)')'Symm ',(STORE(JJ*6+ISYMM+KK),KK=0,5)
		CALL XPRVDU (NCVDU,1,0)
	  END DO
  
C WORK2(6x1) = CELL EDGES(6x6) * INPUT VECTOR (6x1)
      DO I=0, NATOM-1
	    DO J = 0,2
          STORE(IWORK2+J+(I*3)) = STORE(JFUNC+J+(I*3)) * STORE(L1P1+J)
		ENDDO
      ENDDO

 	  DO JJ = 1, 6
        WRITE(CMON,'(A,F10.6)')'WORK2 ',STORE(JJ-1+IWORK2)
		CALL XPRVDU (NCVDU,1,0)
	  END DO

      DO JJ = 0,5
        WRITE(CMON,'(A,6F10.6)')'Symm ',(STORE(JJ*6+ISYMM+KK),KK=0,5)
		CALL XPRVDU (NCVDU,1,0)
	  END DO
	  
C WORK (6x1) = SYMM(6x6) * WORK2(6x1)
      CALL XMLTMM (STORE(ISYMM),STORE(IWORK2),STORE(IWORK),NWP,NWP,1)

	  DO JJ = 1, 6
        WRITE(CMON,'(A,F10.6)')'WORK ',STORE(JJ-1+IWORK)
		CALL XPRVDU (NCVDU,1,0)
	  END DO

	  
C----- now loop over the stored atoms
      ISTACK = JSTACK+(NATOM-1)*LSTACK
      IPART = JPART
      JB = JA
      DO I = 1,NATOM
         IRES = KATOMZ(ISTACK+2,SMAT)
         IF (IRES.LE.0) GO TO 1850
         IF ((ISSPRT.EQ.0).AND.(LEVEL.EQ.1))
     1    WRITE (NCWU,'(A4,I5, 5I4,3F8.4)') STORE(ISTORE(ISTACK)),
     2    NINT(STORE(ISTORE(ISTACK)+1)),(STORE(IDJW),IDJW = ISTACK+2,
     3    ISTACK+9)

C 
C      FORM POSITIONAL COORDINATE ERROR STACK
C
  	     M12TMP = ISTORE(ISTACK+12)
         KB = JB
         CALL XFPCES (M12TMP,JB,NWS,ISTORE(IPART))

         WRITE(CMON,'(2(A,I9))')'Atom ',I, ' parts: ', ISTORE(IPART)
         CALL XPRVDU (NCVDU,1,0)

         DO JJ = 1, ISTORE(IPART)
		   DO KK = 0,2
		     NPART = KK+(JJ-1)*3
             WRITE(CMON,'(A,4I9,F10.6)')'Part ',NPART+1,
     1      ISTORE(KB+NPART*4),ISTORE(KB+1+NPART*4),
     1      ISTORE(KB+2+NPART*4),STORE(KB+3+NPART*4)
    	     CALL XPRVDU (NCVDU,1,0)
             IF ( ISTORE(KB+NPART*4) .GT. 0 ) THEN
               IIWORK = (I-1)*3 + KK
               IIOUT = ISTORE(KB+NPART*4)-1
			   RWEIG = STORE(KB+3+NPART*4)
               WRITE(CMON,'(2(A,I6),A,F10.6)')'IIWORK ',IIWORK,
     1           'IIOUT ',IIOUT,
     1           'RWEIG ',RWEIG
    	       CALL XPRVDU (NCVDU,1,0)
			   STORE(IOUT+IIOUT) = STORE(IOUT+IIOUT) + 
     1                             RWEIG * STORE(IWORK+IIWORK)
			 END IF
		   END DO
         END DO
         IPART = IPART+1
         ISTACK = ISTACK-LSTACK
      END DO


	  DO JJ = 1, N12
        WRITE(CMON,'(A,F10.6)')'IOUT ',STORE(JJ-1+IOUT)
		CALL XPRVDU (NCVDU,1,0)
	  END DO
	  
      JGETVCV = 1
      GOTO 1900
1850  CONTINUE
C      FAIL
      JGETVCV = -1
1900  CONTINUE
      RETURN
      END

	  
