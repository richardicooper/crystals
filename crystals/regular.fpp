C $Log: not supported by cvs2svn $
C
CODE FOR XREGUL
      SUBROUTINE XREGUL
C
C -- THESE ROUTINES IMPLEMENT THE FUNCTIONS OF THE CRYSTALS INSTRUCTION
C    'REGULARISE'
C
C -- THEY ALLOW A GROUP OF ATOMS IN THE LIST 5 STORED ON THE DISC TO BE
C    COMPARED WITH ANOTHER GROUP OF ATOMS. THE SECOND GROUP MAY ALSO BE
C    IN LIST 5. ALTERNATIVELY IT MAY BE SPECIFIED BY DIRECTIVES FOLLOW-
C    ING 'REGULARISE', WHICH EITHER EXPLICITLY GIVE THE CO-ORDINATES OF
C    THE ATOMS IN SOME CO-ORDINATE SYSTEM, OR SPECIFY A GROUP PRE-DEF-
C    INED BY THE PROGRAM.
C
C -- THE MAIN ROUTINE XREGUL BEHAVES AS FOLLOWS :-
C
C            INITIALISATION         READ INPUT ( LEXICAL SCANNER ), SET
C                                   INITIAL VALUES, LOAD LISTS ETC.
C
C            SETTING UP OF GROUPS   CONTROLLED BY DIRECTIVES.
C
C            CALCULATION            INITIATED BY BEGINNING OF NEXT
C                                   GROUP OR END OF DIRECTIVES.
C
C            COMPLETION             WRITE NEW LIST 5 ( IF REQUIRED ),
C                                   RELEASE STORAGE, ETC.
C
C -- REFERENCES TO CRYSTALS SYSTEM FEATURES :-
C
C            ERROR HANDLING         USES XERHND
C
C            SPACE IN STORE ETC.    CLAIMED USING XSTALL ETC.
C
C            COMMAND INPUT          USES LEXICAL SCANNER. THIS IS USED
C                                   TO ALLOW ATOM SPECIFICATIONS TO BE
C                                   PROCESSED READILY.
C
C -- VALUES SET IN THIS MODULE - INITIAL OR DEFAULT VALUES,OR CONSTANT
C    PARAMETERS PASSED TO SUBROUTINES
C
C            MDATMD                 SPACE FOR EACH ATOM IN THE INTERNAL
C                                   COPY OF LIST 5.
C            VALUE (VARIABLE)    : MD5
C
C            ATOM (NATOMP)        : DUMMY ATOM WITH NATOMP COORDINATES
C
C
C
C            MDOLD,MDNEW            SPACE REQUIRED FOR EACH SET OF OLD
C                                   AND NEW CO-ORDINATES. ( X,Y,Z, AND
C                                   A WEIGHT )
C                  VALUE ( FIXED ) : 4
C
C
C            IMETHD                 CALCULATION METHOD.A NUMBER BETWEEN
C                                   1 AND 3. DEFAULT VALUE SET IS 1.
C                                   UPPER LIMIT IS CHECKED BY ROUTINE
C                                   XRGSMD
C                  VALUE ( ONE OF ) : 1/2/3 ( SEE XRGCLC FOR MEANINGS )
C
C
C            ICMPDF         SETS COMPARE/REPLACE/KEEP FLAG FOR
C                           GROUP, UNLESS EXPLICIT DIRECTIVE
C                           GIVEN. THE VALUE OF ICMPDF IF DETERMINED BY
C                           PARAMETER TO 'REGULARISE' . THIS IS AT
C                           OFFSET 35 IN THE LEXICAL SCANNER COMMON
C                           BLOCK
C                  VALUE ( ONE OF ) : 1          2          3
C                                     (REPLACE)  (COMPARE)  (KEEP)
C                                    4
C                                    (AUGMENT)
C
C
C            IFLCMP         THE FLAG WHICH DETERMINES WHETHER THE
C                           CURRENT GROUP IS THE SUBJECT OF A COMP-
C                           ARE/REPLACE/KEEP OPERATION. ITS DEFAULT
C                           VALUE IS 'ICMPDF'
C                  VALUE ( ONE OF ) : THOSE FOR ICMPDF
C
C
C            NEWLIS         NEW LIST 5 TO BE CREATED. DEFAULT 'NO'
C                  VALUE ( ONE OF ) :  0              1
C                                     (NO NEW LIST)  (NEW LIST)
C
C
C            SIZE OF PHENYL GROUP
C                           DETERMINES THE SIZE OF HEXAGON PRODUCED
C                           BY THE 'PHENYL' DIRECTIVE. SET IN
C                                   CALL TO XRGPLG
C                  VALUE ( FIXED ) : 1.39
C
C
C            CALLS TO XRGRDS
C                           2 OF THESE. THE PARAMETER PASSED DETER-
C                           MINES WHETHER THE INPUT IS TREATED AS
C                           SPECIFYING 'OLD' OR 'NEW' ATOMS.
C                  VALUE ( ONE OF ) :  1       2
C                                     (OLD)   (NEW)
C
C
C            CALLS TO XRGPLG
C                           NUMEROUS. THE NUMBER OF ATOMS IN THE GROUP
C                           IS A PARAMETER.
C                  VALUE ( TYPE ) : INTEGER    ( THE RIGHT ONE ! )
C
C
C            CALLS TO XLXRDV
C                           NUMEROUS. THESE CONTAIN E.G. DEFAULT SCALES
C                           FOR PRE-DEFINED GROUPS.
C                  VALUE ( TYPE ) : REAL    ( IN GENERAL = 1.0 )
C
C
C
C
C -- THE FOLLOWING PARTS OF THIS PROGRAM COULD WELL BE IMPROVED.
C
C            COMMAND PROCESSING
C                           THIS WAS DONE WITH THE LEXICAL SCANNER
C                           TO ALLOW EASY PROCESSING OF ATOMIC SPEC-
C                           IFICATIONS IN THE STANDARD CRYSTALS FOR-
C                           MAT. HOWEVER IT WOULD BE USEFUL TO SET
C                           SCALE FACTORS ETC. IN THE COMMAND FILE.
C                           THE SPECIFICATION OF PRE-DEFINED GROUPS
C                           WOULD ALSO BE IMPROVED BY NOT USING THE
C                           LEXICAL SCANNER.
C
C            PRE-DEFINED GROUPS
C                           THE STORAGE AND INTERNAL GENERATION OF
C                           THESE MIGHT BE IMPROVED.
C
C            ** FIX **      THE LEXICAL SCANNER PROCESSOR IS 'NON-
C                           MODULAR' IN THE WAY IT USES THE ARRAY
C                           'STORE' . A GAP OF 400 LOACATIONS IS LEFT
C                           FOR IT.
C
C
C            CONSTANTS      USE SYMBOLS. SET VALUES IN 'DATA'
C
C
      DIMENSION OTEMP(3)
      DIMENSION UNITMX(9)
      DIMENSION ZEROSH(3)
\ICOM12
\ISTORE
C
\STORE
\XUNITS
\XSSVAL
\XLISTI
\XCARDS
\XLST01
\XLST05
\XLST12
\XLST50
\XLEXIC
\XPDS
\XCONST
\XRGCOM
\XRGLST
\XRGRP
\XERVAL
\XOPVAL
\XIOBUF
C
\QSTORE
\QLST12
C --
C --
C -- THE ARRAY 'GRPATM' OF CO-ORDINATES IS USED TO DEFINE GROUPS.
C    THE INDEX OF THE REQUIRED CO-ORDINATE TRIPLET IS AN ELEMENT IN AN
C    ARRAY, WHICH IS PASSED TO THE ROUTINE XRGPLG.
C
C          E.G. IHEX, A 6 ELEMENT ARRAY, IS INITIALISED
C                         WITH THE VALUES /1/ /2/ /3/ /4/ /5/ /6/
C                         WHICH CORRESPOND TO THE CO-ORDINATES :-
C
C    / 0.0 , 0.0 , 0.0 /  / 0.5 , 0.86603 , 0.0 /  ...
C
C    THE VALUE N REPRESENTS THE CO-ORDINATES IN : -
C         GRPATM(1,N) GRPATM(2,N) GRPATM(3,N)
C
C -- UNIT MATRIX AND ZERO SHIFT FOR GROUP PLACEMENT
      DATA UNITMX(1) /1./ UNITMX(2) /0./ UNITMX(3) /0./
      DATA UNITMX(4) /0./ UNITMX(5) /1./ UNITMX(6) /0./
      DATA UNITMX(7) /0./ UNITMX(8) /0./ UNITMX(9) /1./
      DATA ZEROSH(1) /0./ ZEROSH(2) /0./ ZEROSH(3) /0./
C --
      DATA IVERS /211/
      CALL XTIME1(2)
C --
C -- READ THE INPUT DATA
      I=KLEXAN(IULN,IFIRST,LENGTH)
      IF (I) 9500,1000,1000
1000  CONTINUE
C -- SET THE INPUT LIST TYPE TO LIST 5
      LA=KTYP05(1)
C -- SET THE OUTPUT LIST TYPE TO LIST 5
      LB=KTYP05(1)
C -- CLEAR THE STORE
      CALL XRSL
      CALL XCSAE
C -- LOAD LISTS 1 AND 2
      CALL XFAL01
      CALL XFAL02
C -- LOAD LIST 50
      CALL XFAL50
C -- LOAD LIST 5
      CALL XLDRO5(LA)
      IF ( IERFLG .LT. 0 ) GO TO 9250
C -- INITIALISE VALUES FOR REGULARISE
C -- INDICATE THAT LIST 12 IS NOT TO BE USED
\IDIM12
      DO 1100 I = 1,IDIM12
      ICOM12(I) = NOWT
1100  CONTINUE
C -- SAVE LAST CARD IMAGE READ IN AND THE REST OF THE COMMON BLOCK
      CALL XMOVEI(IMAGE(1),ISAVE,99)
C -- SET INITIAL VALUES IN COMMON
      MDATMD = MD5
CDJWNOV99      NATOMP = 14
      NATOMP = MDATMD
      NATMD = 0
      MDOLD = 4
      NOLD = 0
      MDNEW = 4
      NNEW = 0
C -- DEFAULT METHOD IS 1 (ROTATION COMPONENT OF ROTATION-DILATION
C    MATRIX ONLY)
      IMETHD=1
C -- SET GROUP SERIAL NUMBER TO ZERO
      IGRPNO=0
C
C -- SET THE DEFAULT VALUE OF THE 'DEFAULT COMPARE/REPLACE/KEEP' FLAG
C
      ICMPDF=MW
C -- SET REPLACE/COMPARE FLAG TO DEFAULT VALUE
      IFLCMP=ICMPDF
C
C -- SET THE DEFAULT VALUE OF THE 'NEW LIST' FLAG
C
      NEWLIS=0
C -- SET DEFAULT COORDINATES SYSTEM TO (1. 1. 1. 90. 90. 90.)
      CALL XMOVE(STORE(L1O2),RGOM(1,1),9)
C -- ZERO ORIGIN
      CALL XZEROF(ORIGIN(1),3)
C -- SET TO ZERO ROTATION
      CALL XUNTM3(RGMAT(1,1))
C -- SET UNIT MATRIX AND ZERO SHIFT
      CALL XUNTM3(UNITMX(1))
      CALL XZEROF(ZEROSH(1),3)
C -- ALLOCATE SPACE FOR A BUFFER FOR LEXICAL SCANNER
      LLXSPC = KSTALL(4000)
C -- SET VALUES IN ATOM
C -- OCCUPANCY=1.
      ATOM(3)=1.
CDJWNOV99
C----- FLAG
      ATOM(4)=1.0
C----- U'S ETC
      CALL XZEROF(ATOM(8), NATOMP-7 )
C----- SET UISO
      ATOM(8) = 0.05
C -- PREPARE FOR PROCESSING OF THE LEXICAL SCANNER OUTPUT
      CALL XILEXP(IULN,IFIRST)
C
C -- THE LOOP THAT FOLLOWS IS THE MAIN LOOP OF THIS SUBROUTINE. EACH
C    DIRECTIVE IS RECOVERED FROM THE LEXICAL SCANNER IN TURN, AND THE
C    APPROPRIATE ACTION IS TAKEN. ( THIS IS USUALLY A SUBROUTINE
C    CALL . ) AFTER THE DIRECTIVE HAS BEEN FULLY PROCESSED, THE ERROR
C    FLAG IS CHECKED, AND PROCESSING IS ABORTED IF AN ERROR HAS
C    OCCURED. OTHERWISE, THE NEXT DIRECTIVE IS PROCESSED, UNTIL THE
C    CYCLE IS BROKEN BY THE END OF THE DIRECTIVES.
C
C----  MAKE A COPY OF LIST 5 ATOMS AFTER THE LEXICAL WORK AREA
      LNEWL5 = KSTALL (N5 * MD5)
      CALL XMOVE (STORE(L5), STORE(LNEWL5), N5*MD5)
C      RESET THE ADDRESSES
      L5 = LNEWL5
      NL5 = 5
      IREC = 101
C----- LOCATE RECORD 101 AND UPDATE
      I = KHUNTR (NL5, IREC, IADDL, IADDR, IADDD, 0)
      ISTORE(IADDR+3) = L5
      CALL XUDRH (NL5, IREC, 0 , N5)
C
1200  CONTINUE
C
C -- SAVE VALUE OF NFL AND GIVE POSITION TO STORE LEXICAL
C    SCANNER OUTPUT
      ISVNFL=NFL
      MD=LLXSPC
      IF(KLDNLR(I))9000,1250,1200
1250  CONTINUE
C -- RESTORE NFL
      NFL=ISVNFL
C -- BRANCH ON THE FUNCTION
C>DJWOCT96
      GO TO (2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,
     2 3100, 3200, 3300, 3400, 3500, 3600, 3700, 3800, 3900,
     3 2200, 2300, 2000,
     4 2000, 2000, 2000), MG
2000  CONTINUE
      CALL XERHND ( IERPRG )
      GOTO 8000
C<DJWOCT96
C
2100  CONTINUE
C -- 'GROUP' DIRECTIVE
      CALL XRGGRP
      GO TO 8000
2200  CONTINUE
C -- 'OLD' DIRECTIVE
      CALL XRGRDS ( 1 )
      GO TO 8000
2300  CONTINUE
C -- 'NEW' DIRECTIVE
      CALL XRGRDS ( 2 )
      GO TO 8000
2400  CONTINUE
C -- 'SYSTEM' DIRECTIVE
      CALL XRGRCS
      GO TO 8000
2500  CONTINUE
C -- 'ATOM' DIRECTIVE
      CALL XRGRDA
      GO TO 8000
2600  CONTINUE
C -- 'ORIGIN' DIRECTIVE
      DO 2620 I=1,3
      OTEMP(I)=XLXRDV(0.)
2620  CONTINUE
C -- CONVERT ORIGIN TO CRYSTAL FRACTIONS
      CALL XMLTMM(RGOM(1,1),OTEMP(1),ORIGIN(1),3,3,1)
      GO TO 8000
2700  CONTINUE
C -- 'PHENYL' DIRECTIVE
      CALL XRGPLG (IHEX(1),6,1.39,1.39,0.0,ZEROSH(1),UNITMX(1))
      GO TO 8000
2800  CONTINUE
C -- 'HEXAGON' DIRECTIVE
      SCALE=XLXRDV(1.)
      CALL XRGPLG (IHEX(1),6,SCALE,SCALE,0.0,ZEROSH(1),UNITMX(1))
      GO TO 8000
2900  CONTINUE
C -- 'METHOD' DIRECTIVE
C -- READ METHOD NUMBER
      ZMETHD=XLXRDV(0.)
C -- CONVERT TO NEAREST INTEGER
      IMETH=NINT(ZMETHD)
C -- SET METHOD TO THIS VALUE
      CALL XRGSMD(IMETH)
      GO TO 8000
3000  CONTINUE
C -- 'SQUARE' DIRECTIVE
C -- READ SCALE FACTOR
      XSCAL = XLXRDV( 1.)
      YSCAL = XLXRDV( XSCAL)
C -- PLACE GROUP. SCALE FACTOR IS APPLIED TO X AND Y
      CALL XRGPLG(ISQR(1),4,XSCAL, YSCAL,0.0,ZEROSH(1),UNITMX(1))
      GO TO 8000
3100  CONTINUE
C -- 'OCTAHEDRON' DIRECTIVE
C -- READ SCALE FACTOR FOR X AND Y
      XSCAL = XLXRDV( 1.)
      YSCAL = XLXRDV( XSCAL)
C -- READ SCALE FACTOR FOR Z. THE DEFAULT VALUE FOR THIS IS WHATEVER
C    HAS BEEN SPECIFIED FOR X AND Y
      ZSCAL = XLXRDV( YSCAL)
C -- PLACE GROUP, USING SCALE FACTORS
      CALL XRGPLG(IOCT(1),7,XSCAL, YSCAL, ZSCAL,ZEROSH(1),UNITMX(1))
      GO TO 8000
3200  CONTINUE
C -- 'SQP' = 'SQUARE PYRAMID' DIRECTIVE
C -- SEE COMMENTS AFTER 'OCTAHEDRON'
      XSCAL = XLXRDV( 1.)
      YSCAL = XLXRDV( XSCAL)
      ZSCAL = XLXRDV( YSCAL)
      CALL XRGPLG(IOCT(1),6,XSCAL, YSCAL, ZSCAL,ZEROSH(1),UNITMX(1))
      GO TO 8000
3300  CONTINUE
C -- TRIGONAL BIPYRAMID
C -- SEE COMMENTS AFTER 'OCTAHEDRON'
      XYSCAL=XLXRDV(1.)
      ZSCAL=XLXRDV(XYSCAL)
      CALL XRGPLG(ITBP(1),6,XYSCAL,XYSCAL,ZSCAL,ZEROSH(1),UNITMX(1))
      GO TO 8000
3400  CONTINUE
C -- COMPARE DIRECTIVE
C    SET FLAG TO COMPARE
      IFLCMP=2
      GO TO 8000
3500  CONTINUE
C -- REPLACE DIRECTIVE
C    SET FLAG TO REPLACE
      IFLCMP=1
      GO TO 8000
3600  CONTINUE
C -- KEEP DIRECTIVE
C    SET FLAG
      IFLCMP=3
      GO TO 8000
3700  CONTINUE
C----- AUGMENT
      IFLCMP = 4
      GO TO 8000
C TETRAHEDRON -  LISA PEARCE
3800  CONTINUE
      SCALE=XLXRDV(1.)
      CALL XRGPLG(ITET(1),5,SCALE,SCALE,SCALE,ZEROSH(1),UNITMX(1))
      GOTO 8000
3900  CONTINUE
C CP RING -  LISA PEARCE
      SCALE=XLXRDV(1.4)
C 1.17557 IS 2* SIN OF 36 DEGREES
      SCALE=SCALE/1.17557
      CALL XRGPLG(ICPR(1),5,SCALE,SCALE,0.0,ZEROSH(1),UNITMX(1))
      GOTO 8000
C
8000  CONTINUE
C -- CHECK FOR ERRORS AND ABANDON THIS ROUTINE IF AN ERROR
C    HAS OCCURED
      IF (IERFLG.GT.0) GO TO 1200
C -- SET FLAG TO PRODUCE NO NEW LIST
      NEWLIS=0
9000  CONTINUE
C -- END OF DIRECTIVES
C -- THERE MAY BE A CALCULATION OUTSTANDING WHICH SHOULD BE PERFORMED
C    IF THERE HAS BEEN NO ERROR
      IF (IERFLG.GE.0) CALL XRGCLC
C -- CHECK IF A NEW LIST 5 IS TO BE PRODUCED
      IF (NEWLIS) 9050,9100,9150
9050  CONTINUE
      CALL XERHND ( IERPRG )
9100  CONTINUE
C -- NO NEW LIST TO BE PRODUCED
      WRITE ( CMON,9110)
      CALL XPRVDU(NCVDU, 1,0)
      WRITE(NCAWU, '(A)') CMON(1)(:)
      IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') CMON(1)(:)
9110  FORMAT (' No new list 5 will be created ')
      GO TO 9200
9150  CONTINUE
C -- WRITE OUT NEW LIST
C --
C --  MODIFY LIST 5
      LN=5
      IREC=101
C -- LOCATE RECORD 101
      I=KHUNTR(LN,IREC,IADDL,IADDR,IADDD,0)
C -- CHANGE ADDRESS
      ISTORE(IADDR+3)=L5
C -- UPDATE RECORD HEADER
      CALL XUDRH(LN,IREC,0,N5)
C -- STORE LIST 5
      CALL XSTR05(5,0,1)
C -- WRITE FINAL MESSAGE
      WRITE ( CMON,9155) N5
      CALL XPRVDU(NCVDU, 2,0)
      WRITE(NCAWU, '(A)') (CMON(II)(:), II=1,2)
      IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') (CMON(II)(:),II=1,2)
9155  FORMAT (' List 5 now contains ',I4,' atoms  ',/,
     2 ' list modification complete  ')
C -- FINISH ROUTINE
9200  CONTINUE
C -- RESTORE LAST CARD IMAGE READ IN
      CALL XMOVEI(ISAVE(1),IMAGE(1),99)
C -- RELEASE STORE ALLOCATED
      CALL XSTRLL (LLXSPC)
C
C
C
9250  CONTINUE
C
C -- THIS IS THE ONLY WAY OUT OF THE ROUTINE
C    ( WITHOUT AN UNEXPECTED ERROR )
C
C -- WRITE FINAL MESSAGE
C
      CALL XOPMSG( IOPREG, IOPEND, IVERS)
      CALL XTIME2(2)
      RETURN
C
C -- THE FOLLOWING SECTION DEALS WITH ERRORS DETECTED IN THIS
C    SUBROUTINE
9500  CONTINUE
      WRITE ( CMON,9510)
      CALL XPRVDU(NCVDU, 1,0)
      WRITE(NCAWU, '(A)') CMON(1)(:)
      IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') CMON(1)(:)
9510  FORMAT (' Errors detected by lexical scanner  ')
      CALL XERHND ( IERERR )
C
C -- EXIT THIS ROUTINE,PRINTING ONLY THE FINAL MESSAGE AND ELAPSED
C    TIME.
      GO TO 9250
      END
C
C --
C
CODE FOR XRGCLC
      SUBROUTINE XRGCLC
C
C -- THIS SUBROUTINE CONTROLS THE ACTUAL CALCULATION PERFORMED BY
C    REGULARISE.
C
C    DATA SHOULD HAVE BEEN STORED BY THE OTHER ROUTINES, AND THE BEST
C    FIT MATRIX WILL NOW BE CALCULATED BY THE CHOSEN METHOD.
C
C
C -- THIS PROCEDURE DOES THE FOLLOWING
C
C          DATA CHECK       CHECK THAT ALL DATA REQUIRED IS PRESENT.
C                           INSUFFICIENT DATA IS AN ERROR.
C
C          TRANSFORM CO-ORDINATES
C                           CO-ORDINATES ARE CONVERTED TO ORTHOGONAL
C                           SYSTEM. THE CENTROIDS OF THE GROUPS ARE
C                           MADE TO CO-INCIDE, AND THEY ARE ROTATED
C                           TO THEIR 'BEST PLANES' .
C
C          CALCULATION USING 'XRGCRD' OR 'XRGCKB'
C                           THE BEST-FIT MATRIX IS CALCULATED
C
C          CHECK MATRIX AND APPLY TO 'NEW' COORDINATES
C                           CHECK MATRIX DEFINES ALL ROTATIONS THAT
C                           WILL BE REQUIRED TO TRANSFORM CO-ORDIN-
C                           ATES. MATRIX APPLIED TO COORDINATES WHICH
C                           ARE THEN RETURNED TO ORIGINAL SYSTEM.
C
C          FORM NEW LIST 5
C                           THE INTERNAL COPY OF LIST 5 IS UPDATED.
C                           THIS WILL BE WRITTEN TO DISC IF THIS HAS
C                           BEEN REQUESTED.
C
C -- THERE ARE 3 WAYS, AT PRESENT, OF CALCULATING THE BEST FIT MATRIX.
C    THE PARTICULAR ONE OF THESE USED IN EACH CASE DEPENDS ON THE
C    VALUE OF THE VARIABLE 'IMETHD'.
C    THIS IS USED IN THIS SUBROUTINE TO SELECT ONE OF THE POSSIBLE
C    CALLS WHICH WILL CALCULATE A MATRIX.
C
C
      DIMENSION ITEMP(3), ATEMP(3)
C
      DIMENSION WSPAC1(3,3),WSPAC2(3,3),WSPAC3(3,3)
cdjwnov99      DIMENSION CENTO(3),CENTN(3)
      DIMENSION CENTO(4),CENTN(4)
      DIMENSION ROOTO(3),ROOTN(3)
      DIMENSION VECTO(3,3),VECTN(3,3)
      DIMENSION COSNO(3,3),COSNN(3,3)
      DIMENSION RESULT(3,3)
      DIMENSION DELCNT(3), AVCNT(3)
      DIMENSION CFBPOL(3,3) , CFBPNE(3,3)
      DIMENSION BPCFOL(3,3) , BPCFNE(3,3)
C
      CHARACTER*6 CELEMT
      CHARACTER *2 CSYM
      CHARACTER*1 CAXIS(3)
      CHARACTER*12 CFUNC(2)
      CHARACTER *2 CTEMP(3)
C
C
\ISTORE
\STORE
\XUNITS
\XSSVAL
\XLST01
\XLST05
\XRGCOM
\XRGLST
\XCONST
\XERVAL
\XOPVAL
\XIOBUF
C
\QSTORE
C
      DATA CELEMT /'23461m'/
      DATA CAXIS / 'X' , 'Y' , 'Z' /
      DATA CFUNC / 'Replacement' , 'Comparison' /
C
C
C
C
C -- IF THERE ARE NO ATOM DEFINITIONS THEN THERE IS NO CALCULATION
C
      IF (NATMD.EQ.0) RETURN
C
C -- CHECK DATA FOR COMPLETENESS.
C    THE NUMBER OF 'OLD' AND 'NEW' ATOMS SHOULD NOT BE LESS THAN THE
C    NUMBER STATED TO BE IN THE GROUP. ANY EXCESS WILL ALREADY HAVE
C    CAUSED AN ERROR.
C
      IF (NOLD.LT.NATMD) GO TO 9800
      IF (NNEW.LT.NATMD) GO TO 9810
C----- COPY OLD WEIGHT TO NEW
      MOLD = LOLD
      MNEW = LNEW
      DO 1200 I = 1, NOLD
      STORE (MNEW + 3) = STORE (MOLD + 3)
      MOLD = MOLD + MDOLD
      MNEW = MNEW + MDNEW
1200  CONTINUE
C
C
C -- PRINT HEADER TEXT
      NFUNC = 1
      IF ( IFLCMP .EQ. 2 ) NFUNC = 2
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 1405 ) CFUNC(NFUNC) , IGRPNO
      ENDIF
1405  FORMAT ( // , 1X , 50X , A , ' of group number ' , I3 , // )
C
C -- CALCULATE THE CENTROIDS, USING WEIGHTS OF 1. AND 0. TO REPRESENT
C    ATOMS WHICH ARE AND ARE NOT DEFINED IN THE 'OLD' GROUP.
C
      CALL XRGCNT (CENTO,STORE(LOLD),STORE(LOLD),MDOLD,MDOLD,NOLD)
      CALL XRGCNT(CENTN,STORE(LNEW),STORE(LOLD),MDNEW,MDOLD,NOLD)
C
C -- PRINT CENTROIDS AVERAGE, AND THE DIFFERENCE BETWEEN THEM
      CALL XSUBTR ( CENTN , CENTO , DELCNT , 3 )
      CALL XADDR  ( CENTN , CENTO , ROOTO  , 3 )
      CALL XMULTR ( ROOTO , 0.5   , AVCNT  , 3 )
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 2005 ) (CENTO(i),i=1,3) ,
     1  (CENTN(i),i=1,3)
2005  FORMAT ( 1X,15X , 'Centroids of old and new groups ' ,
     2 '( in crystal fractions ) ' , / ,
     3 1X , 2 ( 9X , 3F9.5 ) )
      ENDIF
C
cdjwnov99      WRITE ( CMON , 2006 ) CENTO , CENTN
      WRITE ( CMON , 2006 ) (CENTO(I),I=1,3) ,
     1  (CENTN(i),i=1,3)
      CALL XPRVDU(NCVDU, 2,0)
      WRITE(NCAWU, '(/A)') (CMON(II)(:), II=1,2)
2006  FORMAT ( 1X, 'Centroids of old and new groups ' ,
     2 '( in crystal fractions ) ' , / ,
     3 1X , 2 (3F8.4, 3X ) )
C
C
C
C -- CALCULATE THE BEST PLANE THROUGH THE ATOMS IN EACH GROUP
C
      I=KMOLAX(STORE(LOLD),NOLD,MDOLD,WSPAC1(1,1),ROOTO(1),
     2 VECTO(1,1),COSNO(1,1),WSPAC2(1,1))
C
      I=KMOLAX(STORE(LNEW),NNEW,MDNEW,WSPAC1(1,1),ROOTN(1),
     2 VECTN(1,1),COSNN(1,1),WSPAC2(1,1))
C-----
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2010)ROOTO,ROOTN
      ENDIF
2010  FORMAT(1X,' Principal moments of inertia of old and new groups',//
     1 1X,2(10X,3F8.3),//)
      WRITE ( CMON,  2011) ROOTO, ROOTN
      CALL XPRVDU(NCVDU, 2,0)
      WRITE(NCAWU, '(/A)') (CMON(II )(:),II=1,2)
      IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') (CMON( II)(:),II=1,2)
2011  FORMAT(1X,'Principal moments of inertia of old and new groups',/
     1 1X, 2 (3F8.3, 3X))
C
C----- RESTORE 'NEW' WEIGHTS TO UNITY
      MNEW = LNEW
      DO 2100 I = 1, NNEW
      STORE (MNEW + 3) = 1.
      MNEW = MNEW + MDNEW
2100  CONTINUE
C
C
C -- NOW TRANSFORM CO-ORDINATES
C    TRANSLATE CO-ORDINATES TO PLACE CENTROIDS AT ORIGIN.
      CALL XMXTRL ( STORE(LOLD) , CENTO, MDOLD , NOLD )
      CALL XMXTRL ( STORE(LNEW) , CENTN, MDNEW , NNEW )
C
C -- CALCULATE MATRIX TRANSFORMING FROM CRYSTAL SYSTEM TO BEST PLANE
C    AND BACK
      CALL XMLTMT ( VECTO , STORE(L1O1) , CFBPOL , 3 , 3 , 3 )
      CALL XMLTMT ( VECTN , STORE(L1O1) , CFBPNE , 3 , 3 , 3 )
C
      CALL XMLTMM ( STORE(L1O2) , COSNO , BPCFOL , 3 , 3 , 3 )
      CALL XMLTMM ( STORE(L1O2) , COSNN , BPCFNE , 3 , 3 , 3 )
C
C -- ROTATE GROUPS TO THEIR BEST PLANE AXES.
      CALL XMXRTI ( STORE(LOLD) , CFBPOL , MDOLD , NOLD )
      CALL XMXRTI ( STORE(LNEW) , CFBPNE , MDNEW , NNEW )
C
C
C
C -- CALCULATE BEST FIT MATRIX BY CALLING THE APPROPRIATE ROUTINE
C
      GO TO ( 2600 , 2650 , 2700 , 9910 ) , IMETHD
      GO TO 9910
C
2600  CONTINUE
C
C -- CALCULATE ROTATION COMPONENT OF ROTATION-DILATION MATRIX
      CALL XRGCRD ( RESULT , 1 )
      GO TO 2900
C
2650  CONTINUE
C
C -- CALCULATE FULL ROTATION-DILATION MATRIX
      CALL XRGCRD ( RESULT , 2 )
C
      GO TO 2900
2700  CONTINUE
C -- CALCULATE ROTATION MATRIX BY KABSCH METHOD
      CALL XRGCKB (RESULT(1,1))
      GO TO 2900
2900  CONTINUE
C -- CHECK FOR ERRORS IN CALCULATION
      IF (IERFLG.LT.0) GO TO 9000
C
C -- CALCULATE TRANSFORMATION MATRIX IN OTHER COORDINATE SYSTEMS
C
C    ORTHOGONAL SYSTEM IN (W2)
      CALL XMLTMM ( RESULT , VECTN , WSPAC1 , 3 , 3 , 3 )
      CALL XMLTMM ( COSNO , WSPAC1 , WSPAC2 , 3 , 3 , 3 )
C
C    CRYSTAL SYSTEM IN (W3)
      CALL XMLTMM ( RESULT , CFBPNE , WSPAC1 , 3 , 3 , 3 )
      CALL XMLTMM ( BPCFOL , WSPAC1 , WSPAC3 , 3 , 3 , 3 )
C
C
C
C -- COMPLETE CALCULATION
C
C -- BEFORE APPLYING THE CALCULATED MATRIX TO THE 'NEW' COORDINATES, A
C    CHECK MUST BE DONE , IN CASE THE MATRIX WILL LEAVE THE ROTATION OF
C    SOME ATOMIC COORDINATES UNDEFINED.
C
      MNEW = LNEW + ( NNEW - 1 ) * MDNEW
      IDEFIN = 1
C
      DO 3200 I = 1 , 3
      DEFIND = RESULT(1,I) + RESULT(2,I) + RESULT(3,I)
      IF ( ABS ( DEFIND ) .GT. ( 3 * ZERO ) ) GO TO 3200
C
C -- ROTATION FOR THIS COORDINATE IS UNDEFINED. THIS IS HOWEVER OK
C    IF THERE ARE NO NON-ZERO VALUES FOR THIS COORDINATE
C
      DO 3100 J = LNEW , MNEW , MDNEW
      INDNEW = J + I
      IF ( ABS ( STORE(INDNEW) ) .GT. ZERO ) GO TO 3100
C -- ERROR
      NUMATM =  ( ( J - LNEW ) / MDNEW ) + 1
      WRITE ( CMON , 3055 ) CAXIS(I) , NUMATM
      CALL XPRVDU(NCVDU, 1,0)
      WRITE(NCAWU, '(A)') CMON( 1)(:)
      IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') CMON( 1)(:)
3055  FORMAT ( 1X , 'Rotation of ' , A1 , ' coordinate is undefined ' ,
     2 ' for atom number ' , I5 )
      IDEFIN = -1
C
3100  CONTINUE
3200  CONTINUE
C
      IF ( IDEFIN .LT. 0 ) GO TO 9920
C
C -- MATRIX CHECKED. APPLY MATRIX TO OLD COORDINATES
      CALL XMXRTI ( STORE(LNEW) , RESULT , MDNEW , NNEW )
C
C -- PRINT COORDINATES AFTER FITTING AND THE DEVIATIONS BETWEEN THEM
C
      CALL XRGPCS ( 2 , 3 )
C
C----- WRITE THE IMPORTANT MATRICES AND VECTORS
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 3001 ) AVCNT, DELCNT
3001  FORMAT ( /
     4         1X,15X , 'Average and difference of centroids ' ,
     5 '( in crystal fractions ) ' , / ,
     3 7X , 2 ( 9X , 3F9.5 ) )
C
      WRITE ( NCWU , 3005 )
3005  FORMAT (/,1X , 'Transformation matrix relating new and old' ,
     2 ' coordinates' ,/ , 1X , 15X ,
     2 'In best plane system                ' ,
     3 'In orthogonal system                ' ,
     4 'In crystal system ' /)
C
      WRITE ( NCWU , 3015 ) (
     2 ( RESULT(I,J) , I=1,3 ) ,
     3 ( WSPAC2(I,J) , I=1,3 ) ,
     4 ( WSPAC3(I,J) , I=1,3 ) , J=1,3 )
3015  FORMAT ( 3 ( 1X , 15X , 3 ( 3F10.6 , 5X ) , / ) )
      ENDIF
C
      WRITE ( CMON, 3002 ) AVCNT, DELCNT
      CALL XPRVDU(NCVDU, 2,0)
      WRITE(NCAWU, '(/A)') (CMON(II )(:),II=1,2)
3002  FORMAT (
     4         1X, 'Average and difference of centroids ' ,
     5 '( in crystal fractions ) ' , / ,
     6 1X , 2 (3F8.4, 3X ) )
C
      WRITE(NCAWU,3006)
3006  FORMAT(/1X,'Tranformation matrix between new and old coordinates',
     1 / ' in crystal system'/)
      WRITE(NCAWU,3016) ( (WSPAC3(I,J), I = 1,3), J = 1,3)
3016  FORMAT( 3 ( 6X, 3F10.6,/))
CDJWMAR2000
C FIND PSEUDO OPERATOR - GIACOVAZZO, PAGE 43
C      GET THE DETERMINANT AND TRACE
      DET = XDETR3(WSPAC3)
      TRACE= WSPAC3(1,1)+WSPAC3(2,2)+WSPAC3(3,3)
      DETTRC = DET + TRACE
      IF (ABS (1.-ABS(DET)) .LE. .05) THEN
        I = 1 + NINT(ABS(DETTRC))
        CSYM = ' '
        CSYM(2:2) = CELEMT(I:I)
        IF ((NINT(TRACE) .EQ. 1) .AND. (NINT(DET) .EQ. -1)) THEN
            CSYM=' m'
        ELSE
            IF (DET .LT. ZERO) CSYM(1:1) = '-'
        ENDIF
       WRITE(CMON,3019) CSYM(1:2)
       CALL XPRVDU(NCVDU, 1,0)
       WRITE(NCAWU, '(//A//)') CMON( 1)(:)
       IF (ISSPRT .EQ. 0) WRITE(NCWU, '(/A/)') CMON( 1)(:)
3019  FORMAT (' Pseudo-symmetry element ',A2,' detected')
      ENDIF
C
      DO 3025 J = 1, 3
        ITEMP(J) = 0
        DO 3020 I = 1, 3
          IF (ABS (1. - ABS(WSPAC3(I,J))) .LE. 0.05)
     1    ITEMP(J) = I * INT (SIGN(1., WSPAC3(I,J)))
3020    CONTINUE
3025  CONTINUE
      IF (IABS(ITEMP(1))+ IABS(ITEMP(2))+ IABS(ITEMP(3)) .EQ. 6) THEN
       DO 3026 J = 1, 3
        CTEMP(J) = ' '
        IF (ITEMP(J) .LE. 0) THEN
            ATEMP(J) = 2. * AVCNT(J)
            CTEMP(J)(1:2) = '-'//CAXIS(IABS(ITEMP(J)))
        ELSE
            ATEMP(J) = DELCNT(J)
            CTEMP(J)(1:2) = '+'//CAXIS(IABS(ITEMP(J)))
        ENDIF
3026  CONTINUE
       WRITE(CMON,3027) (ATEMP(J), CTEMP(J) , J = 1, 3)
       CALL XPRVDU(NCVDU, 1,0)
       WRITE(NCAWU, '(//A//)') CMON( 1)(:)
       IF (ISSPRT .EQ. 0) WRITE(NCWU, '(/A/)') CMON( 1)(:)
3027  FORMAT (' Pseudo-symmetry operator of form :-  ',
     1  3( F6.2, A2, 2X))
      ENDIF
C -- ROTATE COORDINATES BACK TO ORTHOGONAL SYSTEM DEFINED BY
C    CRYSTAL
C
      CALL XMXRTI ( STORE(LNEW) , BPCFOL , MDNEW , NNEW )
C
C -- CALCULATE TRANSLATION TO RETURN COORDINATES TO CORRECT
C    ORIGIN. THIS IS MINUS THE CENTROID OF THE OLD GROUP
      DO 3500 I=1,3
      CENTO(I)=-CENTO(I)
3500  CONTINUE
C -- TRANSLATE TO RETURN TO THE CRYSTAL SYSTEM
      CALL XMXTRL(STORE(LNEW),CENTO(1),MDNEW,NNEW)
C -- PRINT THESE COORDINATES
      IF (ISSPRT .EQ. 0) THEN
      WRITE (NCWU,4000)
      ENDIF
4000  FORMAT (/49H Final new atom coordinates in crystal fractions  )
      DO 4250 I=1,NNEW
      INDATM=LATMD+(I-1)*MDATMD
      INDNEW=LNEW+(I-1)*MDNEW
      IF (ISSPRT .EQ. 0) THEN
      WRITE (NCWU,4200) STORE(INDATM),STORE(INDATM+1),
     2 STORE(INDNEW),STORE(INDNEW+1),STORE(INDNEW+2)
      ENDIF
4200  FORMAT (1X,A4,3X,F5.0,5X,3(F8.4,5X))
4250  CONTINUE
C -- CHECK REPLACE/COMPARE FLAG, TO DETERMINE WHETHER LIST 5
C    SHOULD BE CHANGED.
      GOTO ( 4300, 6000, 4300, 4300), IFLCMP
4300  CONTINUE
C -- COPY COORDINATES BACK TO ATOM DEFINTION BLOCK
      DO 4500 I=1,NATMD
C -- CALCULATE THE POSITIONS TO MOVE THE COORDINATES BETWEEN
      INDATM=LATMD+(I-1)*MDATMD+4
      INDNEW=LNEW+(I-1)*MDNEW
      CALL XMOVE (STORE(INDNEW),STORE(INDATM),3)
4500  CONTINUE
C -- FORM NEW LIST 5
C -- SET COUNT OF ATOMS IN THIS LIST TO 0
      NNEWL5=0
C -- REMEMBER WHERE THE LIST STARTS
      LNEWL5=NFL
      DO 5000 I=1,N5
C -- FOR EACH ATOM IN THE OLD LIST 5
C    CALCULATE ITS POSITION IN THE LIST
      INDL5=L5+(I-1)*MD5
C -- IF IFLCMP=3 THEN COPY COMPLETE OLD LIST
      IF (IFLCMP.EQ.3) GO TO 4700
C -- CHECK IF THE ATOM IN LIST 5 IS ONE OF THOSE IN THE GROUP
C    JUST PROCESSED
C -- SET POINTERS FOR SEARCHING FOR ATOMS IN THE CURRENT GROUP
      MLST=LATMD
      NLST=NATMD
      MDLST=MDATMD
      IATOMF=KATOMF(STORE(INDL5),MLST,NLST,MDLST,-1)
C----- IF ATOM NOT IN GROUP, KEEP IT
      IF (IATOMF .NE. 0) GOTO 4700
      IF (IFLCMP .EQ. 4) THEN
C----- FLAG IS 'AUGMENT', SO REMOVE FOUND ATOMS FROM GROUP
        IF(NLST .NE. 0) THEN
          LL5 = MLST
          DO 4600 J = 1, NLST
            LL5N = LL5 + MDLST
            CALL XMOVE( STORE(LL5N), STORE(LL5), MDLST)
            LL5 = LL5 + MDLST
4600      CONTINUE
          NATMD = NATMD - 1
        ENDIF
      ELSE
        GOTO 5000
      ENDIF
4700  CONTINUE
C -- COPY THE ATOM TO THE NEW LIST
      IADDR=KSTALL(MD5)
      CALL XMOVE(STORE(INDL5),STORE(IADDR),MD5)
C -- INCREMENT ATOM COUNT
      NNEWL5=NNEWL5+1
5000  CONTINUE
C --
C -- COPY ATOMS IN GROUP TO THE END OF THE NEW LIST 5
      IF (NATMD .GT. 0) THEN
      ISIZE=MDATMD*NATMD
      IADDR=KSTALL(ISIZE)
      CALL XMOVE(STORE(LATMD),STORE(IADDR),ISIZE)
      ENDIF
C -- INCREASE NUMBER OF ATOMS
      NNEWL5=NNEWL5+NATMD
C----   COPY NEW LIST 5 OVER ORIGINAL LIST 5
      L5ITEM = NNEWL5 * MDATMD
      CALL XMOVE (STORE(LNEWL5), STORE(L5), L5ITEM)
      NFL = L5 + L5ITEM +1
      N5 = NNEWL5
C
C --  MODIFY LIST 5 DETAILS
      LN=5
      IREC=101
C -- LOCATE RECORD 101
      I=KHUNTR(LN,IREC,IADDL,IADDR,IADDD,0)
C -- CHANGE ADDRESS
      ISTORE(IADDR+3)=L5
C -- UPDATE RECORD HEADER
      CALL XUDRH(LN,IREC,0,N5)
C -- SET FLAG TO SHOW NEW LIST 5 IS TO BE PRODUCED
      NEWLIS=1
      GO TO 9000
6000  CONTINUE
C -- COMPARE ONLY
      GO TO 9000
9000  CONTINUE
C -- FINAL TIDY UP
C -- SET COUNTS TO ZERO
      NOLD=0
      NNEW=0
C -- FINISHED CALCULATION
C
      CALL XLINES
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 9005 ) CFUNC(NFUNC) , IGRPNO
      ENDIF
      WRITE ( NCAWU , 9005 ) CFUNC(NFUNC) , IGRPNO
9005  FORMAT ( 1X , A , ' of group number ' , I3 , ' completed' , / )
      RETURN
9800  CONTINUE
      WRITE(CMON,9801) NOLD
      CALL XPRVDU(NCVDU,1,0)
      IF (ISSPRT .EQ. 0) WRITE (NCWU,'(A)') CMON(1)
      WRITE (NCAWU,'(A)') CMON(1)
9801  FORMAT ( ' Too few old atom positions have been given -',I5 )
      CALL XERHND(4)
      RETURN
9810  CONTINUE
      WRITE(CMON,9811) NNEW
      CALL XPRVDU(NCVDU,1,0)
      IF (ISSPRT .EQ. 0) WRITE (NCWU,'(A)') CMON(1)
      WRITE (NCAWU,'(A)') CMON(1)
9811  FORMAT ( ' Too few new atom positions have been given -',I5 )
      CALL XERHND(4)
      RETURN
9900  CONTINUE
C
C -- **** ERRORS ****
C
      CALL XLINES
      WRITE(CMON,9905) IGRPNO
      CALL XPRVDU(NCVDU,1,0)
      IF (ISSPRT .EQ. 0) WRITE (NCWU,'(A)') CMON(1)
      WRITE (NCAWU,'(A)') CMON(1)
9905  FORMAT ( 1X , 'Calculation abandoned for group number ' , I3 )
      GO TO 9000
C
9910  CONTINUE
C -- INTERNAL ERROR
      CALL XOPMSG ( IOPREG , IOPINT , 0 )
      GO TO 9900
C
9920  CONTINUE
      WRITE(CMON,9925)
      CALL XPRVDU(NCVDU,1,0)
      IF (ISSPRT .EQ. 0) WRITE (NCWU,'(A)') CMON(1)
      WRITE (NCAWU,'(A)') CMON(1)
9925  FORMAT ( 1X , 'Attempt to change undefined coordinates' )
      CALL XERHND ( IERERR )
      GO TO 9900
C
      END
C
C --
C
CODE FOR XRGCRD
      SUBROUTINE XRGCRD(RESULT,METHOD)
C -- SUBROUTINE TO CALCULATE A ROTATION DILATION MATRIX TO
C    MATCH THE COORDINATES (IN ORTHOGONAL COORDINATES ROTATED
C    TO INERTIAL SYSTEMS) AT STORE(LOLD) AND STORE(LNEW)
C    RESULT IS :-
C
C    ROTATION COMPONENT OF MATRIX, IF METHOD=1
C    ROTATION-DILATION MATRIX,     IF METHOD=2
C --
      DIMENSION RESULT(3,3)
      DIMENSION WSPAC1(3,3),WSPAC2(3,3),WSPAC3(3,3)
      DIMENSION ROTDIL(3,3),DILATN(3,3),ROTATN(3,3)
      DIMENSION VMAT(3,3),UMAT(3,3),UVEC(3)
      DIMENSION DILNEV(3), DETERM(3)
C --
\ISTORE
\STORE
\XUNITS
\XSSVAL
\XRGLST
\QSTORE
\XIOBUF
C --
C --
      IF (ISSPRT .EQ. 0) WRITE (NCWU,1100)
      WRITE (NCAWU,1100)
1100  FORMAT ( 1X , 'Calculation of rotation-dilation matrix ' ,
     2 'and decomposition into component parts' , / )
C --
C -- CALCULATE ROTATION DILATION MATRIX
C --
C -- W1 = (NEW) * TRANSPOSE (NEW)
      CALL XRGMMT (STORE(LNEW),STORE(LNEW),WSPAC1(1,1),MDOLD,MDOLD,NOLD)
C -- W3 = (OLD) * TRANSPOSE (NEW)
      CALL XRGMMT (STORE(LOLD),STORE(LNEW),WSPAC3(1,1),MDOLD,MDNEW,NOLD)
C -- W2 = INVERSE (W1)
      CALL XMXMPI(WSPAC1(1,1),WSPAC2(1,1),3)
      IF (IERFLG.LT.0) RETURN
C------ ROTATION-DILATION MATRIX D = (W3) * (W2)
      CALL XMLTMM ( WSPAC3(1,1),WSPAC2(1,1),ROTDIL(1,1) , 3,3,3 )
C----- CHECK THAT THIS MATRIX IS PROPERLY DEFINED
C
      DET3 = XDETR3(ROTDIL)
      IF (ABS(ROTDIL(1,1)) .LE. 0.0001*NNEW) ROTDIL(1,1)=
     1 SQRT(1.-ROTDIL(1,2)*ROTDIL(1,2)-ROTDIL(1,3)*ROTDIL(1,3))
C
      IF (ABS(ROTDIL(2,2)) .LE. 0.0001*NNEW) THEN
        WRITE(CMON,1300) ROTDIL(2,2)
        CALL XPRVDU(NCVDU,1,0)
        IF (ISSPRT .EQ. 0) WRITE (NCWU,'(A)') CMON(1)
        WRITE (NCAWU,'(A)') CMON(1)
1300    FORMAT(1X, 'One group is almost colinear - sigma(Y**2) = '
     1  ,F12.8)
        ROTDIL(2,2)=SIGN( SQRT(1.-ROTDIL(2,1)*ROTDIL(2,1)-
     1  ROTDIL(2,3)*ROTDIL(2,3)), ROTDIL(2,2))
      END IF
C
      IF (ABS(ROTDIL(3,3)) .LE. 0.0001*NNEW) THEN
        WRITE(CMON,1200) ROTDIL(3,3)
        CALL XPRVDU(NCVDU,1,0)
        IF (ISSPRT .EQ. 0) WRITE (NCWU,'(A)') CMON(1)
        WRITE (NCAWU,'(A)') CMON(1)
1200    FORMAT(1X, 'One group is almost coplanar - sigma(Z**2) = '
     1  ,F12.8)
        ROTDIL(3,3)= SQRT(1.-ROTDIL(3,1)*ROTDIL(3,1)-
     1  ROTDIL(3,2)*ROTDIL(3,2))
        DETR = XDETR3(ROTDIL)
        IF ( SIGN(1., DET3*DETR) .LT. 0.) ROTDIL(3,3) = -ROTDIL(3,3)
      END IF
C
C -- DECOMPOSE ROTATION-DILATION MATRIX INTO DILATION AND ROTATION
C    COMPONENTS
C
C --
C------ FORM D'D
      CALL XMLTTM ( ROTDIL(1,1),ROTDIL(1,1),WSPAC1(1,1) , 3,3,3 )
C----- EXTRACT U AND V
      CALL XMXEGV (WSPAC1(1,1),VMAT(1,1),UVEC(1))
C -- CHANGE ORDER
C -- INTERCHANGE COLUMNS 1 AND 3 SO THAT EIGENVALUES
C    ARE IN DESCENDING ORDER
      CALL XINT2 (3,VMAT(1,1),9,UVEC(1),3,1,3,1)
C -- CALCULATE SQUARE ROOTS OF EIGENVALUES
      DO 7100 I=1,3
C -- IF UVEC(I) IS CLOSE TO ZERO THEN DO NOT ATTEMPT SQUARE ROOT
      IF (UVEC(I)) 7100,7100,7050
7050  CONTINUE
      UVEC(I)=SQRT(UVEC(I))
7100  CONTINUE
      CALL XMXMFV (UVEC(1),UMAT(1,1),3)
C----- CALCULATE DILATION MATRIX (T)
C    DILATION MATRIX = V*U*TRANSPOSE(V)
      CALL XMLTMT (UMAT(1,1),VMAT(1,1),WSPAC2(1,1),3,3,3)
      CALL XMLTMM (VMAT(1,1),WSPAC2(1,1),DILATN(1,1),3,3,3)
C
C
C -- CALCULATE ROTATION COMPONENT
C
C    (W3) = INVERSE ( DILATION )
C    ( ROTATION ) = ( ROTATION-DILATION ) * ( W3 )
      CALL XMXMPI ( DILATN(1,1) , WSPAC3(1,1) , 3 )
      IF ( IERFLG .LT. 0 ) RETURN
      CALL XMLTMM ( ROTDIL(1,1),WSPAC3(1,1),ROTATN(1,1) , 3,3,3 )
C
C
C -- CALCULATE EIGENVALUES AND VECTORS OF CALCULATED MATRICES
      CALL XMXEGV ( DILATN(1,1) , WSPAC1(1,1) , DILNEV(1) )
C
C -- DISPLAY RESULTS OF CALCULATION
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 3005 )
      ENDIF
3005  FORMAT ( 1X , /18X ,
     2 'Rotation dilation matrix            ' ,
     3 'Dilation component                  ' ,
     4 'Rotation component                  '/ )
C
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 3015 ) (
     2 ( ROTDIL(I,J) , I=1,3 ) ,
     3 ( DILATN(I,J) , I=1,3 ) ,
     4 ( ROTATN(I,J) , I=1,3 ) , J=1,3 )
      ENDIF
3015  FORMAT ( 3 ( 1X , 15X , 3 ( 3F10.5 , 5X ) , / ) )
C
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 3025 )
      ENDIF
3025  FORMAT (1X , 'Eigenvalues' )
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3030) DILNEV
      ENDIF
3030  FORMAT(1X,15X , 35X, 3F10.5  )
      CALL XTRANS(WSPAC1(1,1),WSPAC2(1,1),3,3)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3040)
      ENDIF
3040  FORMAT(1X, 'Eigenvectors')
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3030) WSPAC2
      ENDIF
C----- DETERMINANTS
      DETERM(1)=XDETR3(ROTDIL)
      DETERM(2)=XDETR3(DILATN)
      DETERM(3)=XDETR3(ROTATN)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3050)
      ENDIF
3050  FORMAT(1X, 'Determinants')
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3060) DETERM
      ENDIF
3060  FORMAT(1X,15X,3(10X,F10.5,15X),//)
C
C
C -- COPY RESULT MATRIX TO APPROPRIATE PLACE
C
      IF ( METHOD .EQ. 1 ) CALL XMOVE ( ROTATN(1,1) , RESULT(1,1) ,9 )
      IF ( METHOD .EQ. 2 ) CALL XMOVE ( ROTDIL(1,1) , RESULT(1,1) ,9 )
C
C -- FINISHED
      RETURN
      END
C
C --
C
CODE FOR XRGCKB
      SUBROUTINE XRGCKB(RESULT)
      DIMENSION RESULT(3,3)
      DIMENSION WSPAC1(3,3),WSPAC2(3,3),WSPAC3(3,3)
      DIMENSION VMAT(3,3),UVEC(3)
      DIMENSION SIG(3)
C --
\ISTORE
\STORE
\XUNITS
\XSSVAL
\XRGLST
\QSTORE
C --
      IF (ISSPRT .EQ. 0) THEN
      WRITE (NCWU,1500)
      ENDIF
1500  FORMAT (' Calculation of rotation matrix by Kabsch method  ',//)
C --
      DO 1600 I=1,3
      SIG(I)=1.0
1600  CONTINUE
      E0=0.
      DO 2000 I=1,NATMD
      INDOLD=LOLD+(I-1)*MDOLD
      INDNEW=LNEW+(I-1)*MDNEW
      W=STORE(INDOLD+3)
      E0=E0+W*(STORE(INDOLD)**2+STORE(INDOLD+1)**2+STORE(INDOLD+2)**2)
      E0=E0+W*(STORE(INDNEW)**2+STORE(INDNEW+1)**2+STORE(INDNEW+2)**2)
2000  CONTINUE
      CALL XRGMMT(STORE(LOLD),STORE(LNEW),WSPAC3(1,1),MDOLD,MDNEW,NOLD)
C -- R=TRANSPOSE OF THIS
      CALL XTRANS(WSPAC3(1,1),WSPAC1(1,1),3,3)
C -- T=TRANSPOSE(R)*R
      CALL XMLTTM (WSPAC1(1,1),WSPAC1(1,1),WSPAC2(1,1),3,3,3)
C -- U,V = EIGENVALUES,VECTORS OF T
      CALL XMXEGV(WSPAC2(1,1),VMAT(1,1),UVEC(1))
C -- CHANGE ORDER
C -- INTERCHANGE COLUMNS 1 AND 3 SO THAT EIGENVALUES
C    ARE IN DESCENDING ORDER
      CALL XINT2 (3,VMAT(1,1),9,UVEC(1),3,1,3,1)
C -- SET THIRD VECTOR TO CROSS PRODUCT OF OTHER TWO
      I=NCROP3 (VMAT(1,1),VMAT(1,2),VMAT(1,3))
C -- B=RV
      CALL XMLTMM(WSPAC1(1,1),VMAT(1,1),WSPAC3(1,1),3,3,3)
C -- NORMALISE B VECTORS AND FORM CROSS PRODUCT
      J=NORM3(WSPAC3(1,1))
      J=NORM3(WSPAC3(1,2))
      DETB=XDETR3(WSPAC3(1,1))
      IF (DETB.LT.0) SIG(3)=-1.
      I=NCROP3 (WSPAC3(1,1),WSPAC3(1,2),WSPAC3(1,3))
C -- U=B*TRANSPOSE(V)
      CALL XMLTMT (WSPAC3(1,1),VMAT(1,1),RESULT(1,1),3,3,3)
C -- CALCULATE E
      E=E0
      DO 2050 I=1,3
      IF (UVEC(I) .LT. 0.0001) GO TO 2050
      E=E-SIG(I)*UVEC(I)
2050  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 2105 ) RESULT
      ENDIF
2105  FORMAT ( 1X , 'Pure rotation matrix' , / ,
     2 3 ( 1X , 3F10.5 , / ) )
C
C
      RETURN
      END
C
C --
C
CODE FOR XRGGRP
      SUBROUTINE XRGGRP
C -- THIS SUBROUTINE PROCESSES A GROUP DIRECTIVE, SETTING THE NUMBER
C    OF ATOMS IN THE GROUP.
C    IT ALSO ALLOCATES SPACE IN STORE FOR THE NECESSARY BLOCKS
C    CONTAINING THE ATOM DEFINITIONS AND THE OLD AND NEW
C    COORDINATES.
C --
\XUNITS
\XSSVAL
\XRGCOM
\XRGLST
C --
C -- DO CALCULATION FOR PREVIOUS GROUP IF NECESSARY
      CALL XRGCLC
C -- IF ERROR DURING CALCULATION THEN END
      IF (IERFLG.LT.0) RETURN
C -- SET NUMBER OF ATOMS
      ZGRP=XLXRDV(0.)
C -- FIX THE NUMBER OF ATOMS TO BE READ
      NATMD=NINT(ZGRP)
C -- SET CURRENT NUMBER OF OLD AND NEW ATOMS TO 0
      NOLD=0
      NNEW=0
C -- SET UP BLOCKS
      LATMD=KSTALL(NATMD*MDATMD)
      LOLD=KSTALL(NATMD*MDOLD)
      LNEW=KSTALL(NATMD*MDNEW)
C -- INCREMENT GROUP SERIAL NUMBER
      IGRPNO=IGRPNO+1
C -- SET REPLACE/COMPARE FLAG TO DEFAULT VALUE
      IFLCMP=ICMPDF
      RETURN
      END
C
C --
C
CODE FOR XRGPLA
      SUBROUTINE XRGPLA( PLATOM, NLATOM, XMATR)
C -- THIS SUBROUTINE IS USED TO DEFINE EACH NEW ATOM IN THE GROUP
C    PLATOM( ) CONTAINS THE DETAILS OF THE ATOM IN THE USUAL LIST 5
C    FORMAT. THE ROTATION MATRIX XMATR(9) IS APPLIED TO THE COORDINATES
C    A ORIGIN SHIFT AND GENERAL ROTATION MATRIX ARE ALSO APPLIED
      DIMENSION XMATR(9), PLATOM(NLATOM)
      DIMENSION TEMP(3)
\STORE
\XUNITS
\XSSVAL
\XRGCOM
\XRGLST
\XIOBUF
C --
C -- INCREMENT NEW ATOM COUNT
      NNEW=NNEW+1
      IF (NNEW.GT.NATMD) GO TO 9500
C -- SET (TEMPORARILY) ORIGIN TO ZERO
      CALL XZEROF(ORIGIN(1),3)
C -- CALCULATE WHERE THIS ATOM IS GOING TO GO
      INDATM=LATMD+(NNEW-1)*MDATMD
      INDNEW=LNEW+(NNEW-1)*MDNEW
C -- COPY ATOM EXCEPT TYPE AND SERIAL
      CALL XMOVE( PLATOM(3), STORE(INDATM+2), NLATOM-2)
C -- APPLY REQUIRED MATRIX TO COORDINATES
      CALL XMLTMM (XMATR(1),PLATOM(5),TEMP(1),3,3,1)
C -- APPLY OFFSET TO COORDINATES
cdjwnov99      CALL XSUBTR (TEMP(1),ORIGIN(1),STORE(INDATM+5),3)
      CALL XSUBTR (TEMP(1),ORIGIN(1),STORE(INDATM+4),3)
C -- COPY COORDINATES TO APPROPRIATE PLACE
cdjwnov99      CALL XMOVE (STORE(INDATM+5),STORE(INDNEW),3)
      CALL XMOVE (STORE(INDATM+4),STORE(INDNEW),3)
C -- SET WEIGHT FOR THIS ATOM TO 1
      STORE(INDNEW+3)=1.
      RETURN
9500  CONTINUE
C -- ERROR
        WRITE(CMON,9510) NNEW
        CALL XPRVDU(NCVDU,1,0)
        IF (ISSPRT .EQ. 0) WRITE (NCWU,'(A)') CMON(1)
        WRITE (NCAWU,'(A)') CMON(1)
9510  FORMAT ( ' Too many new atom positions have been given -',I5 )
      CALL XERHND(4)
      RETURN
      END
C
C --
C
CODE FOR XRGPLG
      SUBROUTINE XRGPLG(IATOMS,NATOMS,XSCALE,YSCALE,ZSCALE,SHIFT,ROTN)
C -- SUBROUTINE TO PLACE A GROUP OF NEW ATOMS
C    IATOMS CONTAINS LIST OF THE ATOM INDEXES REFERING TO
C    AN ARRAY GRPATM(3,NNNNN) IN COMMON BLOCK XRGGRP
C    NATOMS IS THE NUMBER OF ATOMS IN THE GROUP
C    XSCALE,YSCALE,ZSCALE ARE THE SCALE FACTORS APPLIED TO
C    X,Y,Z COORDINATES
C --
      DIMENSION IATOMS(NATOMS)
      DIMENSION SHIFT(3)
      DIMENSION ROTN(3)
\STORE
\XUNITS
\XSSVAL
\XLST01
\XRGCOM
\XRGRP
C --
C -- CALCULATE ROTATION MATRIX
      ITMP1=KSTALL(9)
      CALL XMXCRM(ROTN(1),STORE(ITMP1))
C -- ALLOCATE WORK SPACE FOR ATOM COORDINATES
      ITMP2=KSTALL(3)
      ITMP3=KSTALL(3)
cdjw nov99
      DO 4000 I=1,NATOMS
C -- MOVE COORDINATES FOR EACH ATOM AND THEN CREATE THE ATOM
      INDEXF=IATOMS(I)
C -- FOR EACH ATOM CALCULATE EACH COORDINATE IN TURN
      STORE(ITMP2) = GRPATM(1,INDEXF) * XSCALE
      STORE(ITMP2+1) = GRPATM(2,INDEXF) * YSCALE
      STORE(ITMP2+2) = GRPATM(3,INDEXF) * ZSCALE
C -- APPLY ROTATION TO ATOMS
      CALL XMLTMM(STORE(ITMP1),STORE(ITMP2),STORE(ITMP3),3,3,1)
C -- APPLY SHIFT
      CALL XADDR(STORE(ITMP3),SHIFT(1),ATOM(5),3)
      CALL XRGPLA (ATOM(1), NATOMP, STORE(L1O2) )
C -- CHECK FOR ERROR
      IF (IERFLG.LT.0) RETURN
4000  CONTINUE
C -- RELEASE SPACE
      CALL XSTRLL(ITMP1)
      RETURN
      END
C
C --
C
CODE FOR XRGRDA
      SUBROUTINE XRGRDA
C -- READ X,Y,Z COORDINATES. NO DEFAULTS ARE ALLOWED
\XUNITS
\XSSVAL
\XRGCOM
C --
      ATOM(5)=XLXRVN(98765.)
      ATOM(6)=XLXRVN(98765.)
      ATOM(7)=XLXRVN(98765.)
C -- PLACE THIS ATOM USING CURRENT COORDINATE SYSTEM
      CALL XRGPLA (ATOM(1), NATOMP, RGOM(1,1) )
      RETURN
      END
C
C --
C
CODE FOR XRGRDS
      SUBROUTINE XRGRDS (ICODE)
C -- SUBROUTINE TO READ ATOM SPECIFICATIONS
C -- ICODE    1    OLD ATOM SPECIFICATIONS ARE TO BE READ
C             2    NEW ATOM SPECIFICATIONS ARE TO BE READ
C --
      DIMENSION UNIT(3,3)
\ISTORE
\STORE
\XUNITS
\XSSVAL
\XLISTI
\XLST05
\XLEXIC
\XRGCOM
\XRGLST
\QSTORE
\XIOBUF
C -- SET UNIT MATRIX
      CALL XUNTM3 (UNIT(1,1))
C -- ALLOCATE WORK SPACE TO TEMPORARILY HOLD ATOMS
      LATMP=KSTALL(MD5)
C -- SAVE L5
      L5SAVE=L5
C -- SET ADDRESS FOR TEMPORARY STORAGE OF OLD ATOMS TO ZERO
      IADR=0
1500  CONTINUE
C -- CHECK FOR END OF CARD OR '*'
      IF ( KOP(4).LE.0) GO TO 9000
C -- SET L5 TO ZERO TO INHIBIT SEARCHES OF LIST 5
      L5=0
C -- READ THE NEXT ITEM OF DATA AS AN UNTIL SEQUENCE
      I=KATOMU(LN)
C -- CHECK FOR ERRORS IN ATOM SPECIFICATIONS
      IF (I) 9000,9800,3100
3100  CONTINUE
C -- SPECIFICATION IS OK
C -- RESTORE L5
      L5=L5SAVE
C -- SET ADDRESSES OF ATOM HEADERS
C -- FIRST ATOM HEADER IS AT MQ
      IHEADA=MQ
C -- ASSUME NO UNTIL SEQUENCE, THEN SECOND ATOM HEADER IS THE SAME
C    AS FIRST
      IHEADB=IHEADA
C -- IF AN UNTIL SEQUENCE HAS BEEN GIVEN THEN SET SECOND ATOM HEADER
C    ADDRESS
      IF (ISTORE(IHEADA) .GT. 0) IHEADB=ISTORE(IHEADA)
C -- SET POINTERS TO LIST 5
      MLST5A=L5SAVE
      MLST5B=L5SAVE
      NLST5A=N5
      NLST5B=N5
C -- SEARCH FOR FIRST AND SECOND ATOMS IN LIST 5
      IA=KATOMF(STORE(IHEADA+2),MLST5A,NLST5A,MD5,0)
      IB=KATOMF(STORE(IHEADB+2),MLST5B,NLST5B,MD5,0)
C -- CALCULATE NUMBER OF ATOMS IN SEQUENCE
      NATOMA=NLST5A-NLST5B+1
C -- BRANCH ON PRESENCE OF ATOMS IN LIST 5
      IF (IA) 3500,3700,3450
3450  CONTINUE
      CALL XERHND(7)
3500  CONTINUE
C -- FIRST ATOM NOT IN LIST 5
C -- IF WE ARE NOT CONSIDERING OLD ATOMS THEN ERROR
      IF (ICODE.NE.1) GO TO 9820
C -- IF SECOND ATOM IS IN LIST 5 THEN ERROR-MIXED SEQUENCES OF
C    ABSENT AND PRESENT ATOMS ARE NOT ALLOWED
      IF (IB) 3520,9810,3510
3510  CONTINUE
      CALL XERHND(7)
C -- IF TYPES OF FIRST AND SECOND ATOM ARE DIFFERENT THEN ERROR
3520  CONTINUE
      IF (ABS(STORE(IHEADA+2)-STORE(IHEADB+2)) .GT. 0.01 ) GO TO 9830
C -- CALCULATE NUMBER OF ATOMS TO BE CREATED
      NATOMA=NINT(STORE(IHEADB+3))-NINT(STORE(IHEADA+3))+1
C -- ERROR IF THIS NUMBER IS ZERO OR LESS
      IF (NATOMA .LE. 0) GO TO 9840
C -- CREATE ATOM NAME DETAILS
C -- RELEASE PREVIOUS WORK SPACE
      CALL XSTRLL(IADR)
C -- GET NEW SPACE
      IADR=KSTALL(NATOMA*2)
      SERIAL=STORE(IHEADA+3)
      DO 3530 I=1,NATOMA
      INDEXF=IADR+(I-1)*2
      STORE(INDEXF)=STORE(IHEADA+2)
      STORE(INDEXF+1)=SERIAL
      SERIAL=SERIAL+1.
3530  CONTINUE
C -- SET DETAILS FOR CREATION OF ATOMS
      IADATM=IADR
      INCR=2
      WEIGHT=0.
C -- CREATE ATOMS
      GO TO 4000
3700  CONTINUE
C -- FIRST ATOM FOUND IN LIST 5
C -- IF SECOND NOT FOUND THEN ERROR
      IF (IB) 9810,3720,3710
3710  CONTINUE
      CALL XERHND(7)
3720  CONTINUE
      IF (NATOMA.LE.0) GO TO 9840
C -- SET ADDRESSES
      IADATM=MLST5A
      INCR=MD5
      WEIGHT=1.
C -- CREATE ATOMS
4000  CONTINUE
C -- ATOM CREATION
C -- CHECK FOR ONE OR MORE ATOMS
      IF (NATOMA .LE. 0) GO TO 9840
      DO 4900 I=1,NATOMA
C -- APPLY SYMMETRY
C    FIRST CHECK IF A VALID HEADER IS AVAILIBLE
      IF (NINT(WEIGHT)) 4030,4030,4020
4020  CONTINUE
C -- APPLY SYMMETRY
      J=KATOMS(IHEADA,IADATM,LATMP)
      IF (J) 9870,4030,4030
4030  CONTINUE
C -- BRANCH ON OLD OR NEW ATOMS
      GO TO (4400,4600), ICODE
      CALL XERHND(7)
4400  CONTINUE
C -- OLD ATOMS
C -- INCREASE COUNT OF OLD ATOMS
      NOLD=NOLD+1
C -- CHECK COUNT OF OLD ATOMS
      IF (NOLD.GT.NATMD) GO TO 9850
C -- CALCULATE DESTINATIONS FOR THIS ATOM
      INDATM=LATMD+(NOLD-1)*MDATMD
      INDOLD=LOLD+(NOLD-1)*MDOLD
C -- CHECK IF AN ATOM WITH THIS SERIAL AND TYPE IS ALREADY IN THE LIST
C    IF NO ATOMS HAVE BEEN GIVEN BEFORE, SKIP THIS CHECK TO AVOID THE
C    CONSEQUENCES (I.E. FINDING ATOMS BELONGING TO PREVIOUS GROUP)
      IF (NOLD.LE.1) GO TO 4420
      MLST5=LATMD
      MDLST5 = MDATMD
C -- CHECK FOR EACH OLD ATOM SPECIFICATION GIVEN SO FAR
      NLST5=NOLD-1
      J=KATOMF(STORE(IADATM),MLST5,NLST5,MDLST5,0)
      IF (J) 4420,9860,4410
4410  CONTINUE
      CALL XERHND(7)
4420  CONTINUE
C -- ATOM IS NOT IN LIST ALREADY
C----- CLEAR THE AREA
      CALL XZEROF(STORE(INDATM+4), MDATMD-4)
C -- COPY SERIAL AND TYPE
      CALL XMOVE(STORE(IADATM),STORE(INDATM),2)
C -- COPY COORDINATES*WEIGHT
      CALL XMULTR(STORE(LATMP+4),WEIGHT,STORE(INDOLD),3)
C -- SET WEIGHT
      STORE(INDOLD+3)=WEIGHT
      GO TO 4800
4600  CONTINUE
C -- NEW ATOMS
      CALL XRGPLA (STORE(LATMP), MDATMD, UNIT(1,1) )
4800  CONTINUE
C -- SET ADDRESS OF NEXT ATOM
      IADATM=IADATM+INCR
4900  CONTINUE
C -- REPEAT OPERATION FOR ANY SUBSEQUENT ATOM SPECIFICATIONS
      GOTO 1500
9000  CONTINUE
C -- THE NEXT ARGUMENT IS A STAR OR THIS IS THE END OF THE CARD
C    RELEASE WORK SPACE
      CALL XSTRLL(LATMP)
C -- RELEASE OLD ATOM SPACE
      CALL XSTRLL(IADR)
C -- RESTORE LIST 5
      L5=L5SAVE
      RETURN
9800  CONTINUE
        WRITE(CMON,9801)
        CALL XPRVDU(NCVDU,1,0)
        IF (ISSPRT .EQ. 0) WRITE (NCWU,'(A)') CMON(1)
        WRITE (NCAWU,'(A)') CMON(1)
9801  FORMAT (' Error -- not an valid atom specification')
      CALL XERHND(4)
      RETURN
9810  CONTINUE
        WRITE(CMON,9811)
        CALL XPRVDU(NCVDU,1,0)
        IF (ISSPRT .EQ. 0) WRITE (NCWU,'(A)') CMON(1)
        WRITE (NCAWU,'(A)') CMON(1)
9811  FORMAT (' Until specification mixes atoms in and not in list 5')
      CALL XERHND(4)
      RETURN
9820  CONTINUE
      CALL XMISL5 (1,0,IHEADA+2)
      CALL XERHND(4)
      RETURN
9830  CONTINUE
        WRITE(CMON,9831)
        CALL XPRVDU(NCVDU,1,0)
        IF (ISSPRT .EQ. 0) WRITE (NCWU,'(A)') CMON(1)
        WRITE (NCAWU,'(A)') CMON(1)
9831  FORMAT (' Atoms have different types')
      CALL XERHND(4)
      RETURN
9840  CONTINUE
        WRITE(CMON,9841)
        CALL XPRVDU(NCVDU,1,0)
        IF (ISSPRT .EQ. 0) WRITE (NCWU,'(A)') CMON(1)
        WRITE (NCAWU,'(A)') CMON(1)
9841  FORMAT (' Atoms appear to be out of sequence')
      CALL XERHND(4)
      RETURN
9850  CONTINUE
        WRITE(CMON,9851) NOLD
        CALL XPRVDU(NCVDU,1,0)
        IF (ISSPRT .EQ. 0) WRITE (NCWU,'(A)') CMON(1)
        WRITE (NCAWU,'(A)') CMON(1)
9851  FORMAT (' Too many old atoms have been given -',I6)
      CALL XERHND(4)
      RETURN
9860  CONTINUE
        WRITE(CMON,9861)ISTORE(IADATM),STORE(IADATM+1)
        CALL XPRVDU(NCVDU,1,0)
        IF (ISSPRT .EQ. 0) WRITE (NCWU,'(A)') CMON(1)
        WRITE (NCAWU,'(A)') CMON(1)
9861  FORMAT (' An atom with this type and serial already given - '
     1 A4,I6)
      CALL XERHND(4)
      RETURN
9870  CONTINUE
        WRITE(CMON,9871)
        CALL XPRVDU(NCVDU,1,0)
        IF (ISSPRT .EQ. 0) WRITE (NCWU,'(A)') CMON(1)
        WRITE (NCAWU,'(A)') CMON(1)
9871  FORMAT (' Error in applying symmetry operation')
      CALL XERHND(4)
      RETURN
      END
C
C --
C
CODE FOR XRGPCS
      SUBROUTINE XRGPCS ( ICODE , IHDR )
C
C -- PRINT THE STORED COORDINATED DATA POINTED TO BY LOLD AND LNEW
C
C      VALUES FOR ICODE :-
C
C            1            PRINT COORDINATES
C            2            PRINT DEVIATIONS ( FOR ATOMS FOR WHICH THIS
C                           QUANTITY IS DEFINED )
C
C      VALUES FOR IHDR :-
C
C            0            NO HEADER
C            1            ORIGINAL COORDINATES
C            2            COORDINATES IN BEST PLANES FOR GROUP
C            3            FITTED COORDINATES
C            4            FINAL COORDINATES
C
C
      CHARACTER*12 PRTTYP(2)
      CHARACTER*24 PRTUNT(2)
C
      DIMENSION DELTA(5)
      DIMENSION SUM(4)
      DIMENSION RMSDEV(4)
C
\ISTORE
\STORE
\XUNITS
\XSSVAL
\XRGCOM
\XRGLST
\XCONST
\XERVAL
\XOPVAL
\XIOBUF
C
\QSTORE
C
      DATA MAXCOD / 2 / , MAXHDR / 4 /
      DATA PRTTYP(1) / 'Coordinates ' / , PRTTYP(2) / 'Deviations  ' /
      DATA PRTUNT(1) / ' ( Crystal fractions )  ' /
      DATA PRTUNT(2) / ' ( Angstrom )           ' /
C
C
C -- CHECK INPUT VALUES
C
      IF ( ICODE .LE. 0 ) GO TO 9910
      IF ( ICODE .GT. MAXCOD ) GO TO 9910
      IF ( IHDR .LT. 0 ) GO TO 9910
      IF ( IHDR .GT. MAXHDR ) GO TO 9910
C
      CALL XZEROF ( SUM(1) , 4 )
      RADIUS = 0.0
C
C -- PRINT HEADER
C
      IF ( IHDR .LE. 0 ) GO TO 1900
C
      GO TO ( 1100 , 1200 , 1300 , 1400 , 9910 ) , IHDR
      GO TO 9910
C
1100  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 1105 ) PRTTYP(ICODE) , PRTUNT(1)
      ENDIF
1105  FORMAT ( 1X , A12 , 'in crystal system' , A24 )
      GO TO 1700
1200  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 1205 ) PRTTYP(ICODE) , PRTUNT(2)
      ENDIF
1205  FORMAT ( 1X , A12 , 'in best plane system before fitting' , A24 )
      GO TO 1700
1300  CONTINUE
      WRITE ( CMON , 1305 ) PRTTYP(ICODE) , PRTUNT(2)
      CALL XPRVDU(NCVDU, 1,0)
      WRITE(NCAWU, '(A)') CMON(1 )(:)
      IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') CMON(1 )(:)
1305  FORMAT ( 1X , A12 , 'in best plane system after fitting' , A24 )
      GO TO 1700
1400  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 1405 ) PRTTYP(ICODE) , PRTUNT(1)
      ENDIF
1405  FORMAT ( 1X , A12 , 'in crystal system after fitting' , A24 )
      GO TO 1700
C
C
1700  CONTINUE
C -- WRITE NEXT LINE FOR EITHER COORDINATES OR DEVIATIONS
      GO TO ( 1710 , 1720 , 9910 ) , ICODE
      GO TO 9910
C
1710  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 1715 )
      ENDIF
1715  FORMAT ( 1X , 44X , 'Old' , 35X , 'New'  , / ,
     2 1X ,'Position' , 5X ,'Type   Serial   ' ,
     3 2 ( 5X , 'x' , 9X , 'y' , 9X , 'z' , 9X ) )
      GO TO 1900
C
1720  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 1725 )
      ENDIF
1725  FORMAT ( /,1X , 'Position' , 2X , 'Type  Serial' ,4X,
     2 'old(x)',2X,'old(y)',2X, 'old(z)',7X, 'new(x)',2X,
     3 'new(y)',2X,'new(z)', 8X,'d(x)',4X,'d(y)',4X,'d(z)',
     4 7X,'Distance',4X,'Angle',/)
      WRITE ( NCAWU , 1726 )
1726  FORMAT ( /,1X , 'Position' , 2X , 'Type  Serial' ,
     2 4X,'d(x)',4X,'d(y)',4X,'d(z)',
     4 7X,'Distance',4X,'Angle',/)
      GO TO 1900
C
1900  CONTINUE
C
      DO 2000 I=1,NOLD
      INDOLD=LOLD+MDOLD*(I-1)
      INDNEW=LNEW+MDNEW*(I-1)
      INDATM=LATMD+MDATMD*(I-1)
C -- PRINT APPROPRIATE DATA
      IF ( ICODE .EQ. 1 ) THEN
      IF (ISSPRT .EQ. 0) THEN
            WRITE ( NCWU , 2005 ) I , ( STORE(J) , J =INDATM,INDATM+1),
     2 ( STORE(J) , J=INDOLD,INDOLD+2) , ( STORE(J) ,J=INDNEW,INDNEW+2)
      ENDIF
2005        FORMAT ( 1X , I8 , 5X , A4 , 3X , F6.0 , 3X , 3F10.4 , 5X ,
     2 3F10.4 )
      ELSE IF ( ICODE .EQ. 2 ) THEN
            IF ( ABS ( STORE(INDOLD+3) ) .LE. ZERO ) THEN
      IF (ISSPRT .EQ. 0) THEN
            WRITE ( NCWU , 2015 ) I , ( STORE(J) , J =INDATM,INDATM+1),
     2 ( STORE(J) , J=INDOLD,INDOLD+2) , ( STORE(J) ,J=INDNEW,INDNEW+2)
      ENDIF
            GO TO 2020
            ELSE
            DISTSQ = 0.
            DO 2010 J = 1 , 3
            DELTA(J) = STORE(INDNEW+J-1) - STORE(INDOLD+J-1)
            DELTSQ = DELTA(J) ** 2
            SUM(J) = SUM(J) + DELTSQ
            DISTSQ = DISTSQ + DELTSQ
            RBAR=0.5*(STORE(INDNEW+J-1)+STORE(INDOLD+J-1))
            RADIUS=RADIUS+RBAR*RBAR
2010        CONTINUE
            DELTA(4) = SQRT ( DISTSQ )
            RADIUS=SQRT(RADIUS)
            DELTA(5)=RTD*ATAN2(DELTA(4),RADIUS)
C
      IF (ISSPRT .EQ. 0) THEN
            WRITE ( NCWU , 2015 ) I , ( STORE(J) , J =INDATM,INDATM+1),
     2 ( STORE(J) , J=INDOLD,INDOLD+2) , ( STORE(J) ,J=INDNEW,INDNEW+2),
     3 DELTA
      ENDIF
            WRITE ( NCAWU , 2015 ) I , ( STORE(J) , J =INDATM,INDATM+1),
     3 DELTA
            ENDIF
2015        FORMAT ( 1X,2X,I4, 4X,A4,2X, F6.0,2X, 4(3F8.3,5X))
2020        CONTINUE
      ELSE
            GO TO 9910
      ENDIF
C
C
2000  CONTINUE
C -- CHECK IF PRINT OF DEVIATIONS IS REQUIRED
C
      IF ( ICODE .EQ. 2 ) THEN
C
C -- CALCULATE TOTAL SQUARED DEVIATION AND RMS DEVIATIONS
C
            SUM(4) = SUM(1) + SUM(2) + SUM(3)
C
            DO 2500 I = 1,4
            RMSDEV(I) = SQRT ( SUM(I)/NATMD )
2500        CONTINUE
C
      IF (ISSPRT .EQ. 0) THEN
            WRITE ( NCWU , 2505 ) SUM , RMSDEV
      ENDIF
2505  FORMAT ( // ,
     2 1X,53X , 'Total squared deviations     ' , 3F8.3 ,
     3 1X , 'Total' , F8.3 , / ,
     4 1X,53X , 'RMS deviations               ' , 3F8.3 ,
     5 2X , 'Mean' , F8.3 )
            WRITE ( CMON , 1727 )
            CALL XPRVDU(NCVDU, 1,0)
1727        FORMAT ( 23X ,
     2      6X,'d(x)',4X,'d(y)',4X,'d(z)',
     4      9X,'Distance')
            WRITE ( CMON , 2506 ) SUM , RMSDEV
            CALL XPRVDU(NCVDU, 2,0)
            WRITE(NCAWU, '(/A)') (CMON( II)(:),II=1,2)
2506  FORMAT (
     2 1X , 'Total squared deviations' , 3F8.3 ,
     3 1X , 'Total' , F8.3 , / ,
     4 1X , 'RMS deviations          ' , 3F8.3 ,
     5 2X , 'Mean' , F8.3 )

C
      ENDIF
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 9010 )
      ENDIF
9010  FORMAT (//)
      RETURN
C
9910  CONTINUE
      CALL XOPMSG ( IOPREG , IOPINT , 0 )
      RETURN
      END
C
C --
C
CODE FOR XRGMMT
      SUBROUTINE XRGMMT(ATOMS1,ATOMS2,RESULT,MDATM1,MDATM2,NATM)
C -- FORMS ATOMS1 MULTIPLIED BY TRANSPOSE (ATOMS2)
C    ATOMSN(MNATMN,NATM) CONTAINS
C    ITEM 1: X
C    ITEM 2: Y
C    ITEM 3: Z
C    ITEM 4-MDATMN: ANYTHING
C    FOR EACH OF THE NATM ATOMS
C    EACH CONTRIBUTION IS WEIGHTED BY WEIGHT FOR OLD ATOM
C --
      DIMENSION ATOMS1(MDATM1,NATM)
      DIMENSION ATOMS2 (MDATM2,NATM)
      DIMENSION RESULT (3,3)
C --
\STORE
\XRGLST
      DO 1000 I=1,3
      DO 2000 J=1,3
      RESULT(I,J)=0.
      DO 3000 K=1,NATM
C -- CALCULATE EACH ITEM APPLYING APPROPRIATE WEIGHT TO OLD ATOM
C -- CALCULATE WEIGHTING TERM FOR THIS PAIR OF VECTORS
      INDOLD=LOLD+(K-1)*MDOLD
      WTERM=STORE(INDOLD+3)
C -- CALCULATE CONTRIBUTION FROM THIS PAIR OF VECTORS,APPROPRIATELY
C    WEIGHTED
      RESULT(I,J)=RESULT(I,J)+ATOMS1(I,K)*ATOMS2(J,K)*WTERM
3000  CONTINUE
2000  CONTINUE
1000  CONTINUE
      RETURN
      END
C
C --
C
CODE FOR XRGRCS
      SUBROUTINE XRGRCS
C -- SUBROUTINE TO READ COORDINATE SYSTEM
\STORE
\XLST01
\XRGCOM
\XCONST
\XUNITS
\XIOBUF
\XSSVAL
C --
C -- ALLOCATE SPACE TO READ IN DATA
      ITMP1=KSTALL(6)
C -- ALLOCATE SPACE TO HOLD INTERMEDIATE MATRIX
      ITMP2=KSTALL(9)
      DO 2000 I=ITMP1,ITMP1+2
      STORE(I)=XLXRDV(1.)
2000  CONTINUE
C -- READ ANGLES
      DO 2050 I=ITMP1+3,ITMP1+5
      STORE(I)=XLXRDV(90.)*DTR
2050  CONTINUE
C----- COMPUTE GAMMA*
      TEMP = (SIN(STORE(ITMP1+3))*SIN(STORE(ITMP1+4)))
      IF (TEMP .LE. ZERO) THEN
          WRITE ( CMON, 2052)
          CALL XPRVDU(NCVDU, 1,0)
          WRITE(NCAWU, 2052)
          IF (ISSPRT .EQ. 0) WRITE(NCWU,2052)
2052  FORMAT( ' Angles not correctly specified on SYSTEM card')
          GOTO 2060
      ENDIF
      TEMP = (COS(STORE(ITMP1+3))*COS(STORE(ITMP1+4)) -
     1 COS(STORE(ITMP1+5)))/ TEMP
      STORE(ITMP1+5) = ACOS(TEMP)
C -- CALCULATE ORTHOGONALISATION MATRIX
      CALL XMXCLO(STORE(ITMP1),STORE(ITMP2))
      CALL XMLTMT ( STORE(L1O2) , STORE(ITMP2) , RGOM , 3 , 3 , 3 )
2060  CONTINUE
C -- RELEASE WORK SPACE
      CALL XSTRLL(ITMP1)
      RETURN
      END
C
C --
C
CODE FOR XRGSMD
      SUBROUTINE XRGSMD(IVALUE)
\XUNITS
\XSSVAL
\XRGCOM
\XIOBUF
C --
      IMETHD=IVALUE
      IF ( IMETHD.LT.0 ) GO TO 9800
      IF ( IMETHD.EQ.0 ) GO TO 9900
      IF ( IMETHD.GT.3 ) GO TO 9800
      RETURN
9800  CONTINUE
        WRITE(CMON,9810)
        CALL XPRVDU(NCVDU,1,0)
        IF (ISSPRT .EQ. 0) WRITE (NCWU,'(A)') CMON(1)
        WRITE (NCAWU,'(A)') CMON(1)
9810  FORMAT ( ' Method number is not in allowed range ')
9900  CONTINUE
C -- SET DEFAULT METHOD NUMBER
      IMETHD = 1
        WRITE(CMON,9910)
        CALL XPRVDU(NCVDU,1,0)
        IF (ISSPRT .EQ. 0) WRITE (NCWU,'(A)') CMON(1)
        WRITE (NCAWU,'(A)') CMON(1)
9910  FORMAT (' Method set to default value')
      RETURN
      END
C
C --
C
CODE FOR XRGCNT
      SUBROUTINE XRGCNT (CENT,A,B,MDA,MDB,NAB )
      DIMENSION A(MDA,NAB)
      DIMENSION B(MDB,NAB)
      DIMENSION CENT(3)
C --
      CALL XZEROF(CENT(1),3)
      SW = 0
      DO 3000 I=1,NAB
      W=B(4,I)
      SW=SW+W
      DO 2500 J=1,3
      CENT(J)=CENT(J)+A(J,I)*W
2500  CONTINUE
3000  CONTINUE
      DO 4000 J=1,3
      CENT(J)=CENT(J)/SW
4000  CONTINUE
      RETURN
      END
