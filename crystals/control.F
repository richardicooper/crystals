C Log: control.fpp,v $
C Revision 1.12  2012/01/04 14:31:25  rich
C Fix some uninitialized variables, and output format mistakes.
C
C Revision 1.11  2011/03/21 13:57:21  rich
C Update files to work with gfortran compiler.
C
C Revision 1.10  2005/01/23 08:29:11  rich
C Reinstated CVS change history for all FPP files.
C History for very recent (January) changes may be lost.
C
C Revision 1.1.1.1  2004/12/13 11:16:11  rich
C New CRYSTALS repository
C
C Revision 1.9  2004/03/16 14:50:56  rich
C Fix syntax of previous change (this morning), and also run through
C removing WRITEs to NCAWU as part of an ongoing project.
C
C Revision 1.8  2004/03/16 12:19:00  rich
C Double size of store arrays to 64Mb.
C
C If a directive has a maximum count of >= 9999, then treat this as a
C special case, allowing an infinite number of directives of this
C type to be issued. (Suggest that if any directives really do
C need a maximum count to prevent, e.g. a runaway loop somewhere, then
C they be set to 9998).
C
C Revision 1.7  2004/03/10 10:31:05  rich
C Catch buffer overflow during the printing of the error condition:
C "This directive may not follow a card containing the directive ...."
C
C Revision 1.6  2003/11/06 17:02:06  rich
C Try to avoid skipping spaces when parsing long strings in
C e.g. space group class, crystal colour and shape fields.
C So 'Pale Pink' should now stay 'Pale Pink' and not become 'PalePink'.
C
C Revision 1.5  2003/08/05 11:11:10  rich
C Commented out unused routines - saves 50Kb off the executable.
C
C Revision 1.4  2003/05/15 17:26:28  rich
C Addition of one extra ENDFILE statement seems to
C make the system request queue work properly under g77.
C
C Revision 1.3  2001/02/26 10:24:14  richard
C Added changelog to top of file
C
C
cCODE FOR XFRGN1
c      SUBROUTINE XFRGN1
cC--SUBROUTINE TO INITIALISE THE CALL TO A FOREIGN PROGRAM.
cC
cC--THIS ROUTINE ALSO SEARCHES THE INPUT STREAM FOR THE NEXT '#INSTRUCTIO
cC  CARD, AND CHECKS THAT THE SYSTEM REQUEST QUEUE IS EMPTY.
cC
cC--
c\XUNITS
c\XSSVAL
c\XERVAL
c\XIOBUF
cC
cC--LOAD THE NEXT '#INSTRUCTION' CARD
c      J=KFNHF(LSTOP,LSTNO,ICLASS)
cC--CHECK THAT THE SYSTEM REQUEST QUEUE IS EMPTY
c      IF(KPSRQ(-1))1000,1100,1000
cC--THE QUEUE IS NOT EMPTY
c1000  CONTINUE
c      CALL XERHDR(-1)
c      IF (ISSPRT .EQ. 0) THEN
c      WRITE(NCWU,1050)
c      ENDIF
c      WRITE(NCAWU,1050)
c      WRITE ( CMON, 1050)
c      CALL XPRVDU(NCEROR, 1,0)
c1050  FORMAT(' System request queue should be empty')
c      CALL XERHND ( IERPRG )
cC--AND NOW RETURN
c1100  CONTINUE
c      RETURN
c      END
cC
cCODE FOR XFRGN2
c      SUBROUTINE XFRGN2(ICOM)
cC--THIS ROUTINE TERMINATES THE OUTPUT TO THE SYSTEM REQUEST QUEUE AND LO
cC  THE PROGRAM REQUIRED FOR THE COMMAND STORED IN 'ICOM'.
cC
cC  ICOM   A FOUR CHARACTER COMMAND NAME, DEFINING THE NEXT OPERATION
cC        TO BE PERFORMED.
cC
cC--
cC
c      DIMENSION ICOM(4)
c\ISTORE
cC
c\STORE
c\XLST50
c\XCHARS
c\XCARDS
c\XPRGNM
cC
c\QSTORE
cC
cC--TERMINATE THE SYSTEM REQUEST QUEUE
c      WRITE(NUSRQ,1000)(IH,IB,(IH,I=1,78),J=1,5)
c1000  FORMAT(80A1)
cC--WRITE OUT A '#END'
c      WRITE(NUSRQ,1050)IH,(IH,I=1,76)
c1050  FORMAT(A1,'END',76A1)
cC--WRITE THE NEXT PROGRAM NAME TO BE LOADED
c      MR64=LR64+19
c      WRITE(NUSRQ,1100)(ISTORE(I),I=LR64,MR64)
c1100  FORMAT(2I4,18A4)
c      ENDFILE(NUSRQ)
c      REWIND(NUSRQ)
cC--PRESERVE THE CURRENT DETAILS OF THE COMMON BLOCKS
c      NILAST=NI
cC--COPY THE PROGRAM NAME THAT WE WILL ENTER AFTER THE FOREIGN CALL
c      CALL XMOVE(STORE(LR64+2),KPRGNM(1),MDR64-2)
cC--OUTPUT THE COMMON BLOCK DETAILS
c      CALL XSYSDC(0,0)
cC--BLANK OUT THE CURRENT COMMAND
c      CALL XMVSPD(IB,IMAGE(2),LASTCH-1)
cC--ADD IN THE REQUIRED COMMAND
c      CALL XMOVEI (ICOM(1),IMAGE(2),4)
cC--LOAD THE DETAILS
c      I=KFNHF(LSTOP,LSTNO,ICLASS)
cC--LOAD THE PROGRAM
c      CALL XCONT1(ISTORE(MR64),MDR64)
c      RETURN
c      END
cC
cCODE FOR XFRGN3
c      SUBROUTINE XFRGN3(NRU,NWU)
cC--ROUTINE TO RETURN FROM A FOREIGN LINK
cC
cC  NRU   DEVICE NUMBER OF THE SYSTEM REQUEST QUEUE FOR THIS LINK.
cC  NWU  LINE PRINTER DEVICE NUMBER.
cC
cC--
cC
c      DIMENSION IBUFF(20),ICON(2)
cC
c\XUNITS
c\XSSVAL
cC
cC
c      DATA ICON(1)/'#'/,ICON(2)/'END '/
cC
cC--SET THE UNIT NUMBER FOR THE L/P
c      NCWU=NWU
cC--CHECK FOR UNUSED CARDS
c      I=0
cC--READ THE NEXT CARD
c1000  CONTINUE
c      READ(NRU,1050)(IBUFF(J),J=1,2)
c1050  FORMAT(A1,A3)
cC--CHECK FOR A '#' IN COLUMN 1
c      IF(KCOMP(1,IBUFF(1),ICON(1),1,2))1100,1100,1150
cC--INCREMENT THE UNUSED COUNT
c1100  CONTINUE
c      I=I+1
c      GOTO 1000
cC--CHECK FOR ANY UNUSED CARDS
c1150  CONTINUE
c      IF(I)1300,1300,1200
cC--PRINT THE UNUSED CARD COUNT
c1200  CONTINUE
c      CALL XERHDR(-1)
c      IF (ISSPRT .EQ. 0) THEN
c      WRITE(NCWU,1250)I
c      ENDIF
c1250  FORMAT(1X,I4,'  Card(s) ignored by the last program link')
cC--PRINT THE TIME USED
c1300  CONTINUE
c      CALL XTIME2(2)
cC--FIND THE '#END' CARD
c1350  CONTINUE
c      IF(KCOMP(2,IBUFF,ICON(1),1,2))1400,1400,1450
cC--READ ANOTHER CARD
c1400  CONTINUE
c      READ(NRU,1050)(IBUFF(J),J=1,2)
c      GOTO 1350
cC--READ THE LOAD DETAILS FOR THE NEXT PROGRAM LINK
c1450  CONTINUE
c      READ(NRU,1500)(IBUFF(I),I=1,20)
c1500  FORMAT(2I4,18A4)
cC--REWIND THE SYSTEM REQUEST QUEU
c      REWINDNRU
cC--LOAD THE NEXT PROGRAM
c      CALL XCONT1(IBUFF,20)
c      RETURN
c      END
C
CODE FOR KNXTOP
      FUNCTION KNXTOP(LSTOP,LSTNO,ICLASS)
C--THIS FUNCTION FINDS THE NEXT '#INSTRUCTION' CARD AND LOADS THE PROGRA
C  SHOULD EXECUTE THE INSTRUCTION. IF THE PROGRAM IS ALREADY LOADED,
C  AS HAPPENS WHEN A PROGRAM IS FIRST ENTERED, THIS ROUTINE SIMPLY RETUR
C  WITHOUT CHANGING PROGRAM.
C
C  LSTOP   THIS PARAMETER IS SET ONLY WHEN A LIST OPERATION IS INDICATED
C          AND IS SET IN THIS CASE TO THE OPERATION REQUIRED. VALUES AVA
C          AT PRESENT ARE :
C
C          0  NO LIST OPERATION.
C          1  INPUT, VIA A '#LIST' INSTRUCTION.
C          2  PRINT, VIA A '#PRINT' INSTRUCTION.
C          3  PUNCH, VIA A '#PUNCH' INSTRUCTION.
C
C  LSTNO   WHEN A LIST OPERATION IS INDICATED, THIS VARIABLE IS SET TO T
C          LIST NUMBER ON RETURN. IN ALL OTHER CASES, THIS VARIABLE IS S
C          ZERO.
C
C  ICLASS  WHEN A LIST OPERATION IS INDICATED, THIS VARIABLE IS SET TO T
C          OPERATION CLASS ON RETURN. IN ALL OTHER CASES, THIS VARIABLE
C          SET TO ZERO.
C
C--THE RETURN VALUES OF 'KNXTOP' ARE :
C
C  -1  THE CURRENT INSTRUCTION CANNOT BE EXECUTED BY THIS PROGRAM. THIS
C      IS USED BY THIS VERSION OF THE ROUTINE.
C  >0  THE VALUE EXPECTED BY THE CALLING PROGRAM FOR THIS OPERATION.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XCARDS.INC'
      INCLUDE 'XPRGNM.INC'
      INCLUDE 'XLST50.INC'
      INCLUDE 'XERVAL.INC'
C
      INCLUDE 'QSTORE.INC'
C
C----- WE COULD COME HERE AFTER AN ERROR - TRY A RESTART.
C--CHECK FOR A '#INSTRUCTION' CARD
      I=KFNHF(LSTOP,LSTNO,ICLASS)
C--CHECK IF WE MUST CHANGE PROGRAMS
      MR64=KCOMP(MDR64-2,KPRGNM,STORE(LR64+2),NR64,MDR64)
      IF(MR64)1050,1050,1000
C--THIS ROUTINE CAN PROCESS THIS '#INSTRUCTION'  -  SET THE RETURN VALUE
1000  CONTINUE
C
C----- COPY THE INSTRUCTION TO THE SNOOPER
      CALL XSPY ( 2 )
C
      MR64=LR64+(MR64-1)*MDR64
      KNXTOP=ISTORE(MR64)
      RETURN
C--STORE THE NEW FILE NAME AWAY
1050  CONTINUE
      CALL XMOVE(STORE(LR64+2),KPRGNM(1),MDR64-2)
C--MARK THE '#INSTRUCTION' AS READY FOR PROCESSING
      IHFLAG=0
C--CHECK THAT THIS IS NOT THE SAME CARD THAT WE FOUND ON ENTERING
      NILAST=NI
C--DUMP THE COMMON BLOCK VALUES
      CALL XSYSDC(0,0)
C--LOAD THE NEXT PROGRAM
      CALL XCONT1(ISTORE(LR64),MDR64)
      KNXTOP=-1
      RETURN
      END
C
CODE FOR XCONT1
      SUBROUTINE XCONT1(LOAD,IDIMN)
C--THIS SUBROUTINE LOADS THE NEXT PROGRAM
C
C  LOAD    THE LOAD DETAILS :
C
C          1  THE ENTRY NUMBER FOR THE CURRENT OPERATION.
C          2  THE CORE SIZE REQUIRED.
C          3  THE FIRST WORD OF THE LOAD DETAILS.
C          4  THE SECOND WORD OF THE LOAD DETAILS, ETC.
C
C  IDIMN    THE DIMENSION OF 'LOAD'.
C
C--
C
      DIMENSION LOAD(IDIMN)
      DIMENSION MESS(11)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XSIZES.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XCARDS.INC'
      INCLUDE 'XPRGNM.INC'
      INCLUDE 'XLST50.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSIZST.INC'
C
#ifdef _HOL_
      DATA MESS(1)/4HCRYS /,MESS(2)/4HTALS/,MESS(3)/4HLOAD/
      DATA MESS(4)/4HNAME/,MESS(5)/4H:= "/,MESS(11)/4H"   /
#else
      DATA MESS(1)/'CRYS'/,MESS(2)/'TALS'/,MESS(3)/'LOAD'/
      DATA MESS(4)/'NAME'/,MESS(5)/':= "'/,MESS(11)/'"   '/
#endif
C
C--CHECK THE CORE SIZE FOR THE NEW PROGRAM
      J=KORE(ITEMP)
      IF(LOAD(2)-J)1100,1100,1000
C--NOT ENOUGH CORE
1000  CONTINUE
      CALL XMONTR(0)
      CALL XERHDR(0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1050)LOAD(2),J
      WRITE ( CMON, 1050) LOAD(2),J
      CALL XPRVDU(NCEROR, 1,0)
1050  FORMAT(' Next program requires ',I8,'  words of core  -  ',I8,
     2 '  words is too little')
      CALL XERHND ( IERSEV )
1100  CONTINUE
      CALL XMOVEI (LOAD(3),MESS(6),5)
      CALL XFCCS(MESS(1),MESS(1),9)
C--OUTPUT THE MESSAGE
      IF(KIGC(11,MESS(1)))1150,1250,1250
C--ERROR DURING THE ASSIGN
1150  CONTINUE
      CALL XMONTR(0)
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1200)
      WRITE ( CMON, 1200)
      CALL XPRVDU(NCEROR, 1,0)
1200  FORMAT(' Error on assigning next program')
      CALL XERHND ( IERPRG )
C--LOAD THE NEXT PROGRAM
1250  CONTINUE
      CALL XQUIT
      RETURN
      END
C
CODE FOR XSYSDC
      SUBROUTINE XSYSDC(IN,IND)
C--INITIALISE OR TERMINATE THE DATA AREAS FOR A CRYSTALS PROGRAM.
C
C  IN      PROGRAM START/END CONTROL :
C          -1  START OF A PROGRAM.
C           0  END OF A PROGRAM, BEFORE CONTROL PASSES TO ANOTHER PROGRA
C
C  IND     THE TYPE OF INITIALISATION REQUIRED :
C
C          -1  JOB TO INITIALISE A DISC FILE.
C           0  FIRST LOAD OF A JOB.
C          +1  ANY BUT THE FIRST LOAD OF A JOB.
C
C--
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XSIZES.INC'
      INCLUDE 'XTIMES.INC'
      INCLUDE 'XDISC.INC'
      INCLUDE 'XDISCB.INC'
      INCLUDE 'XDISCS.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XFILEC.INC'
      INCLUDE 'XCOMPD.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLIMIT.INC'
      INCLUDE 'XCARDS.INC'
      INCLUDE 'XSYSHF.INC'
      INCLUDE 'XSYSDR.INC'
      INCLUDE 'XDIRTP.INC'
      INCLUDE 'XTAPES.INC'
      INCLUDE 'XLST50.INC'
      INCLUDE 'XPRGNM.INC'
      INCLUDE 'XLEXCH.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XERCNT.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSIZST.INC'
C
C
C--CHECK IF THIS IS THE START OR END FOR THE CALLING PROGRAM
      IF(IN)1000,1500,1500
C--CHECK IF THIS IS AN INITIAL CALL OR A RECALL LATER
1000  CONTINUE
      IF(IND)1050,1050,1100
C--AN INITIAL CALL
1050  CONTINUE
      CALL XTIME1(0)
      GOTO 1350
C
1100  CONTINUE
C -- NOT AN INITIAL CALL. IF THE PROGRAM IS SEGMENTED, READ IN DATA
      IF ( ISSSEG .LE. 0 ) GO TO 1600
      WRITE ( CMON, '(A)') ' Reading common blocks'
      CALL XPRVDU(NCVDU, 1,0)
      REWINDNCCBU
C--READ THE TIME CONTROL CONSTANTS
      READ(NCCBU,1550)Q,QQ
C--READ THE DISC UNITS
      READ(NCCBU,1150)NCDFU,NCIFU,NCLDU
1150  FORMAT(16I5)
C--READ THE BASIC PERIPHERAL UNIT NUMBERS AND CONSTANTS
      READ(NCCBU,1150)NCRU,NCRRU,NCWU,NCPU,IPAGE,NCARU,NCAWU
      READ(NCCBU,1155) IQUN,JQUN
1155  FORMAT(2I5)
C--READ THE CURRENT CARD IN
      READ(NCCBU,1200)IMAGE
      READ ( NCCBU , 1200 ) LCMAGE
1200  FORMAT(80A1)
C--READ THE CARD CONSTANTS
      READ(NCCBU,1250)NC,ND,LASTCH,NI,NILAST,NS,MON,ICAT,IEOF,IHFLAG,
     2 NUSRQ,NREC,IPOSRQ,ITYPFL,INSTR,IDIRFL,IPARAM,IPARAD,MAPS
1250  FORMAT(8I10)
C--READ THE M/T FILE NUMBERS
      READ(NCCBU,1150)MTA,MTB,MT1,MT2,MT3,MTE
C--READ THE NAME OF THE CURRENT PROGRAM
      READ(NCCBU,1300)KPRGNM
1300  FORMAT(20A4)
C -- READ THE ERROR CONTROL FLAGS
      READ ( NCCBU , 1305 ) IERCNT
      READ ( NCCBU , 1305 ) IERLIM , IERCOU , IERMAX
1305  FORMAT ( 19I4 )
C--COMPUTE THE REST OF THE CONSTANTS
1350  CONTINUE
C - now parameters
c      PI=ACOS(-1.0)
c      TWOPI=2.*PI
c      TWOPIS=TWOPI*PI
c      RTD=180./PI
c      DTR=PI/180.
c      ZEROSQ=ZERO*ZERO
c      VALUSQ=VALUE*VALUE
C--ASSIGN THE DATA FILE UNIT NUMBER
      NU=NCDFU
C--ALLOCATE SOME CORE BUFFERS
      CALL XGIVE
C
C -- SET LIMITS OF ARRAY 'STORE'
C
      NFL = 1
      LFL=KORE(ITEMP)
      NUL=LFL-NFL+1
C--SET THE CORE LIMITS
      CALL XSSL(NFL,LFL,NUL)
C--CHECK IF THIS IS TO ESTABLISH A DISC OR A NORMAL LOAD
      IF(IND)1450,1400,1400
C--LOAD THE LIST CONTROL DATA
1400  CONTINUE
      CALL XLC
C--SET UP THE CORE CHAIN POINTERS
1450  CONTINUE
      L0=NOWT
      M0=NOWT
C--REPOSITION THE SYSTEM REQUEST QUEUE
      CALL XRPSRQ
      GOTO 1600
C
C
1500  CONTINUE
C -- 'PROGRAM' TERMINATION. IF SYSTEM IS SEGMENTED , WRITE OUT DATA
      IF ( ISSSEG .LE. 0 ) GO TO 1600
      WRITE ( CMON, '(A)') ' Dumping common blocks'
      CALL XPRVDU(NCVDU, 1,0)
      REWINDNCCBU
C--WRITE THE CURRENT TIME OUT TO THE CONTROL FILE
      WRITE(NCCBU,1550)Q,QQ
1550  FORMAT(4E20.10)
C--WRITE THE DISC UNITS
      WRITE(NCCBU,1150)NCDFU,NCIFU,NCLDU
C--WRITE THE BASIC PERIPHERAL UNIT NUMBERS AND CONSTANTS
      WRITE(NCCBU,1150)NCRU,NCRRU,NCWU,NCPU,IPAGE,NCARU,NCAWU
      WRITE(NCCBU,1155) IQUN,JQUN
C--WRITE THE CURRENT CARD OUT
      WRITE(NCCBU,1200)IMAGE
      WRITE ( NCCBU , 1200 ) LCMAGE
C--WRITE THE CARD CONSTANTS
      WRITE(NCCBU,1250)NC,ND,LASTCH,NI,NILAST,NS,MON,ICAT,IEOF,IHFLAG,
     2 NUSRQ,NREC,IPOSRQ,ITYPFL,INSTR,IDIRFL,IPARAM,IPARAD,MAPS
C--WRITE THE M/T FILE NUMBERS
      REWINDMTA
      REWINDMTB
      REWINDMTE
      WRITE(NCCBU,1150)MTA,MTB,MT1,MT2,MT3,MTE
C--WRITE THE NAME OF THE CURRENT PROGRAM
      WRITE(NCCBU,1300)KPRGNM
C -- WRITE ERROR CONTROLS
      WRITE ( NCCBU , 1305 ) IERCNT
      WRITE ( NCCBU , 1305 ) IERLIM , IERCOU , IERMAX
      REWINDNCCBU
C--REPOSITION THE SYSTEM REQUEST QUEUE
      REWINDNUSRQ
C--AND NOW RETURN
1600  CONTINUE
      RETURN
      END
C
CODE FOR KFNHF
      FUNCTION KFNHF(LSTOP,LSTNO,ICLASS)
C--THIS ROUTINE FINDS THE NEXT '#INSTRUCTION' CARD.
C
C  LSTOP   THIS PARAMETER IS SET ONLY WHEN A LIST OPERATION IS INDICATED
C          AND IS SET IN THIS CASE TO THE OPERATION REQUIRED. VALUES AVA
C          AT PRESENT ARE :
C
C          0  NO LIST OPERATION.
C          1  INPUT, VIA A '#LIST' INSTRUCTION.
C          2  PRINT, VIA A '#PRINT' INSTRUCTION.
C          3  PUNCH, VIA A '#PUNCH' INSTRUCTION.
C
C  LSTNO   WHEN A LIST OPERATION IS INDICATED, THIS VARIABLE IS SET TO T
C          LIST NUMBER ON RETURN. IN ALL OTHER CASES, THIS VARIABLE IS S
C          ZERO.
C
C  ICLASS  WHEN A LIST OPERATION IS INDICATED, THIS VARIABLE IS SET TO T
C          OPERATION CLASS ON RETURN. IN ALL OTHER CASES, THIS VARIABLE
C          SET TO ZERO.
C
C--THE RETURN VALUE OF 'KFNHF' IS THE NUMBER OF THE '#INSTRUCTION'
C  WHICH THE CALLING PROGRAM CAN USE. THIS NUMBER IS IN THE RANGE
C  1 TO N, WHERE 'N' IS THE MAXIMUM NUMBER OF '#INSTRUCTIONS' THAT
C  THE GIVEN PROGRAM CAN PROCESS.
C
C--THERE ARE NO ERROR RETURNS FROM THIS ROUTINE  -  ERRORS LEAD TO
C  PROGRAM TERMINATION.
C
C--ON EXIT THE CONTROL RECORDS (60 ONWARDS) FOR THE '#INSTRUCTION'
C  FOUND ARE LOADED AT THE TOP OF CORE, WITH 'NFL' AND 'LFL' SET
C  CORRECTLY. 'XRSL' MUST BE CALLED BEFORE THE WHOLE OF CORE BECOMES
C  AVAILABLE AGAIN.
C
C--WITHIN LIST 50, SEVERAL TYPES OF DATA RECORD ARE USED :
C
C  50  RECORD TYPE 50 CONTAINS THE NAMES OF THE INSTRUCTIONS, EACH ONE
C      FOLLOWING DIRECTLY AFTER THE ONE BEFORE IT. THE FORMAT IS
C      ONE CHARACTER PER WORD, AND MAY BE REPRESENTED AS :
C
C      0  MAXIMUM NUMBER OF CHARACTERS IN THIS NAME
C      1  NAME 1, WORD 1.
C      2  NAME 1, WORD 2.
C
C -51  RECORD TYPE 51 CONTAINS A SET OF DISC POINTERS TO
C      RECORDS 60, 61, 62, 63 AND 64 FOR EACH INSTRUCTION. THE
C      FORMAT OF EACH ENTRY IS AS FOLLOWS :
C
C      0  DISC ADDRESS OF THE RECORD HEADER PRECEDING RECORD 60.
C      1  DISC ADDRESS OF THE RECORD HEADER FOR RECORD TYPE 60.
C      3  DISC ADDRESS OF THE RECORD HEADER PRECEDING RECORD 61.
C
C      THIS FORMAT IS REPEATED FOR EACH RECORD TYPE FOR A INSTRUCTION,
C      AND THEN FOR EACH INSTRUCTION. THIS RECORD IS USED TO RAPIDLY
C      ACCESS DATA FOR A GIVEN INSTRUCTION.
C
C  52  THIS RECORD IS PRESENT ONCE IN THE LIST, AND CONTAINS THE
C      NECESSARY INSTRUCTIONS TO GENERATE LISTS INTERNALLY. THESE
C      INSTRUCTIONS CONTAIN THEIR '#' DELIMITERS, AND STORED IN
C      THE FOLLOWING FORMAT :
C
C      0  THE LIST TYPE NUMBER TO BE GENERATED.
C      1  THE FIRST WORD OF THE COMMAND  -  FORMAT 19A4.
C      2  THE SECOND WORD OF THE COMMAND.
C
C  60  EACH TYPE 60 RECORD CONTAINS THE NAMES OF THE DIRECTIVES
C      THAT ARE AVAILABLE WITH ONE '#' INSTRUCTION, IN THE SAME FORMAT
C      AS A TYPE 50 RECORD. EACH INSTRUCTION CAN HAVE A TYPE 60 RECORD.
C
C  61  EACH TYPE 61 RECORD CONTAINS THE DETAILS FOR THE DIRECTIVES
C      ASSOCIATED WITH ONE '#' INSTRUCTION. THE DETAILS IN A TYPE 61
C      RECORD ARE USED TO ACCESS THE PARAMETER DETAILS WHICH ARE
C      STORED IN A TYPE 62 RECORD. THE DATA IN TYPE 61 RECORDS IS
C      ARRANGED SERIALLY, AND THE ENTRY FOR EACH DIRECTIVE IS AS
C      FOLLOWS :
C
C       0  RELATIVE ADDRESS OF THE DETAILS OF THE PARAMETERS FOR THIS
C          DIRECTIVE.
C       1  NUMBER OF WORDS PER PARAMETER NAME.
C       2  NUMBER OF WORDS REQUIRED FOR THE COMPLETE PARAMETER ENTRY.
C       3  NUMBER OF PARAMETERS FOR THIS DIRECTIVE.
C       4  RELATIVE ADDRESS OF THE DIRECTIVES EXCLUDED FROM INPUT WHEN
C          THIS DIRECTIVE HAS BEEN FOUND.
C       5  NUMBER OF WORDS PER EXCLUDED DIRECTIVE.
C       6  NUMBER OF EXCLUDED DIRECTIVES.
C          THIS VALUE IS SET NEGATIVE WHEN THIS DIRECTIVE HAS BEEN
C          EXCLUDED. THE ABSOLUTE VALUE GIVES THE DIRECTIVE THAT HAS
C          EXCLUDED IT.
C       7  NUMBER OF TIMES THIS DIRECTIVE MAY APPEAR.
C          THIS VALUE IS SET FROM THE GROUP REPEAT COUNT FOR
C          DIRECTIVES THAT DEFINE DATA RECORDS.
C       8  NUMBER OF TIMES THIS DIRECTIVE HAS APPEARED.
C          DURING PROCESSING THIS LOCATION MAY BE SET AS FOLLOWS :
C
C          NEGATIVE  THIS DIRECTIVE HAS ALREADY GENERATED ERRORS.
C          OTHER     THE NUMBER OF TIMES THE DIRECTIVE HAS APPEARED.
C
C       9  THE NUMBER OF WORDS PER GROUP FOR THE RECORD DEFINED BY
C          THIS DIRECTIVE, IF THERE IS ONE.
C      10  THE NUMBER OF GROUPS FOR THE RECORD DEFINED BY THIS DIRECTIVE
C          IF THERE IS ONE.
C      11  THE RECORD TYPE DEFINED BY THIS DIRECTIVE.
C      12  THE COMMON BLOCK OFFSET FOR THE RECORD DEFINED BY THIS DIRECT
C      13  THE LIST TYPE FOR THE RECORD TO BE CREATED.
C      14  THE NUMBER OF WORDS OCCUPIED BY THE TITLE OF THIS RECORD.
C      15  THE NUMBER OF TIMES THE TITLE SHOULD BE PRINTED PER LINE.
C      16  THE RELATIVE ADDRESS IN RECORD TYPE 62 OF THE TITLE.
C      17  THE NUMBER OF WORDS OCCUPIED BY THE PRINT FORMAT FOR THE
C          PARAMETER KEYWORDS FOR THIS RECORD.
C      18  THE NUMBER OF TIMES THE PARAMETER KEYWORDS ARE TO BE PRINTED
C          PER LINE.
C      19  THE RELATIVE ADDRESS IN RECORD TYPE 62 OF THE PRINT FORMAT
C          FOR THE KEYWORDS FOR THIS RECORD.
C      20  THE NUMBER OF WORDS OCCUPIED BY THE PRINT FORMAT FOR THE
C          ELEMENTS OF THIS RECORD.
C      21  THE NUMBER OF GROUPS TO BE PRINTED PER LINE.
C      22  THE RELATIVE ADDRESS IN RECORD TYPE 62 OF THE PRINT FORMAT
C          FOR THE ELEMENTS IN THIS RECORD.
C      23  THE NUMBER OF WORDS OCCUPIED BY THE PUNCH FORMAT FOR THE
C          PARAMETER KEYWORDS FOR THIS RECORD.
C      24  THE NUMBER OF TIMES THE PARAMETER KEYWORDS ARE TO BE PUNCHED
C          PER LINE.
C      25  THE RELATIVE ADDRESS IN RECORD TYPE 62 OF THE PUNCH FORMAT
C          FOR THE KEYWORDS FOR THIS RECORD.
C      26  THE NUMBER OF WORDS OCCUPIED BY THE PUNCH FORMAT FOR THE
C          ELEMENTS OF THIS RECORD.
C      27  THE NUMBER OF GROUPS TO BE PUNCHED PER LINE.
C      28  THE RELATIVE ADDRESS IN RECORD TYPE 62 OF THE PUNCH FORMAT
C          FOR THE ELEMENTS IN THIS RECORD.
C      29  THE RELATIVE ADDRESS OF THE ENABLING DATA FOR THIS
C          DIRECTIVE.
C      30  THE NUMBER OF WORDS PER ENABLING DIRECTIVE.
C      31  THE NUMBER OF ENABLING DIRECTIVES.
C
C      THE BLOCK ABOVE IS REPEATED FOR EACH DIRECTIVE FOR THE CURRENT
C      '#' INSTRUCTION, AND ALL THE ADDRESSES ARE RELATIVE TO THE START
C      OF THE DATA STORED IN RECORD TYPE 62.
C
C  62  ASSOCIATED WITH EACH TYPE 61 RECORD IS A TYPE 62 RECORD, WHICH
C      CONTAINS DETAILS OF THE PARAMETERS FOR EACH DIRECTIVE. EACH
C      DIRECTIVE HAS A POINTER IN RECORD TYPE 61 INDICATING THE START
C      OF ITS PARAMETERS, WHICH ARE STORED SERIALLY AND
C      FORM THE FIRST PART OF THIS RECORD. THE REST OF THE
C      RECORD IS TAKEN WITH FURTHER DATA ADDRESSED VIA THE PARAMETER
C      INFORMATION. THE FORMAT OF AN ENTRY FOR A PARAMETER STARTS
C      WITH THE PARAMETER NAME AS FOLLOWS :
C
C      0  NAME 1, WORD 1.
C      1  NAME 1, WORD 2.
C
C      AFTER THE NAME, THE REST OF THE PARAMETER INFORMATION IS STORED,
C      ATTHE OFFSET GIVEN IN WORD 2 ABOVE, RELATIVE TO THE START OF THE
C      CURRENT PARAMETER. THE NUMBER OF WORDS OF ADDITIONAL DATA
C      IS GIVEN BY WORD 2 MINUS WORD 1 ABOVE.
C      THE FORMAT OF THE REST OF THE DATA FOR EACH PARAMETER IS :
C
C       0  PARAMETER TYPE ON INPUT :
C
C          +1  FIXED POINT NUMBER.
C          +2  FLOATING POINT NUMBER.
C          +3  CHARACTER STRING.
C          +4  STRING TO BE INTERPRETED BY THE CALLING ROUTINE.
C
C       1  RELATIVE ADDRESS OF THE PERMITTED VALUES FOR THIS PARAMETER
C          ON INPUT.
C       2  NUMBER OF WORDS PER PERMISSABLE VALUE.
C       3  NUMBER OF PERMISSABLE VALUES.
C       4  COMMON BLOCK OFFSET FOR THIS PARAMETER.
C       5  TYPE OF ARGUMENT TO BE STORED IN THE COMMON BLOCK. IF THE
C          NUMBER OF PERMISSABLE VALUES IS ZERO, WORD 5 IS SET EQUAL
C          TO WORD 0. IF PERMISSABLE VALUES ARE ALLOWED, WORD 5 IS SET T
C          1, INDICATING AN INTEGER WHICH CAN GIVE THE POSITION OF THE
C          FOUND PERMISSABLE VALUE.
C          NUMBER OF PERMISSABLE VALUES IS ZERO, WORD 5 MUST EQUAL WORD
C          0. IF THE NUMBER OF PERMISSABLE VALUES IS NOT ZERO, THE
C          VALUE FOUND MAY BE STORED (WORD 0 EQUALS WORD 5), OR
C          ANOTHER TYPE OF ARGUMENT MAY BE STORED. THE MOST COMMON
C          EXAMPLE OF THIS IS TO STORE AN INTEGER TO INDICATE THE
C          POSITION OF THE PERMISSABLE VALUE FOUND ON INPUT.
C          IN THIS CASE, WORD 0 WOULD BE 3 AND WORD 5 WOULD BE 1.
C       6  VALUE TO BE ASSIGNED IF THE FIRST PERMISSABLE VALUE
C          IS FOUND. THIS IS AN INTEGER, AND SUCCESSIVE PERMISSABLE
C          VALUES ARE INCREMENTED ACCORDINGLY FROM THIS VALUE.
C       7  DEFAULT INDICATOR :
C
C          -1  NO DEFAULT AVAILABLE.
C           0  DEFAULT VALUE STORED.
C
C       8  DEFAULT VALUE, TYPE GIVEN BY WORD 5.
C       9  NUMBER OF TIMES THIS PARAMETER MAY OCCUR.
C      10  THE NUMBER OF TIMES THIS PARAMETER HAS BEEN INPUT.
C
C      THE REST OF THE TYPE 62 RECORD IS DATA POINTED TO BY THE FIRST
C      PART OF THE RECORD.
C
C  63  THIS RECORD CONTAINS A LIST OF THE LISTS THAT THE '#' INSTRUCTION
C      REQUIRES. THE LISTS ARE STORED BY NUMBER, ONE AFTER THE OTHER.
C
C  64  THIS RECORD CONTAINS THE LOAD DETAILS, WHICH ARE SPECIFIC TO
C      EACH MACHINE. ON THE ICL 1906A, THE FORMAT IS :
C
C      0  THE INSTRUCTION NUMBER FOR THE GIVEN PROGRAM.
C      1  MINIMUM CORE SIZE REQUIRED.
C      2  WORD 1 OF THE FILE NAME TO 'CONT'.
C      3  WORD 2.
C
C--RECORD TYPE 50 IS STORED AS ABOVE, BUT AS EACH INSTRUCTION
C  REQUIRES A RECORD OF TYPE 60, 61, 62, 63 AND 64, THESE ARE STORED
C  WITH RECORD NUMBERS OF -(10000*N + M). 'N' IS THE NUMBER OF THE
C  CURRENT INSTRUCTION IN THE INPUT STREAM, AND M IS THE 60 VALUE.
C  THIS MEANS THAT ONLY RECORD 50 IS LOADED IMMEDIATELY, BUT THAT
C  POINTERS ARE SET UP TO THE REST.
C
C--
C
C
      CHARACTER CFORM*9, CFMRQ*6, CEND*3
      CHARACTER CIMAGE*80
      INCLUDE 'HEADES.INC'
      INCLUDE 'ISTORE.INC'
      INCLUDE 'ICOM50.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XCARDS.INC'
      INCLUDE 'XLST50.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XLSVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QCOM50.INC'
C
C
C
      DATA CFORM / '(19A4,4X)'/
      DATA CFMRQ / '(20A4)'/, CEND / 'END' /
C
900   CONTINUE
C----- WE COULD COME BACK HERE AFTER AN ERROR - RESET FLAG
C--INITIAL SCAN  -  LAST CARD WAS OKAY
1000  CONTINUE
      I=-1
C--SET THE LIST FLAGS TO ZERO INITIALLY
      LSTOP=0
      LSTNO=0
      ITYPFL = 1
      INSTR = 0
      ICLASS=-1
      IDIRFL=-1
      IPARAM=-1
C--CHECK IF THE CURRENT CARD CONTAINS A '#INSTRUCTION' CARD
1050  CONTINUE
      IF(IHFLAG)1100,1150,1150
C--NO '#INSTRUCTION'  -  READ THE NEXT RECORD
1100  CONTINUE
      CALL XMONTR(I)
C--ALL SUBSEQUENT CARDS ARE IN ERROR
      I=0
      IF(KRDREC(I))1100,1050,1050
C--'#' CARD FOUND  -  CHECK FOR END OF FILE
1150  CONTINUE
      IF(IEOF)1100,1200,1200
C--'#INSTRUCTION' CARD FOUND  -  SET THE CHARACTER POINTERS
1200  CONTINUE
      NC=2
      ND=KEQUAL(NC,IB)
C--CLEAR THE ERROR INDICATORS
      IERFLG = 1
      LEF=0
      LSTLEF=LEF
C--CLEAR CORE
      CALL XCSAE
      CALL XRSL
C--LOAD PART OF LIST 50
      CALL XFAL50
C--SEARCH FOR THE FOUND '#INSTRUCTION' IN LIST 50
      ITYPFL=1
      INSTR=KCNXTS(MDR50-1,ISTORE(LR50),NR50,MDR50)
C--CHECK IF WE HAVE FOUND ANYTHING
      IF(INSTR)1250,1250,1350
C--ILLEGAL OR UNKNOWN INSTRUCTION
1250  CONTINUE
      CALL XMONTR(0)
      IF (ISSPRT .EQ. 0)  WRITE(NCWU,1300)IH
      WRITE ( CMON, 1300) IH
      CALL XPRVDU(NCEROR, 1,0)
1300  FORMAT(' Unknown or illegal ''',A1,
     2 'Instruction'' on the last card')
      CALL XERHND ( IERERR )
C -- CLEAR INDICATION OF INSTRUCTION, TO STOP LOOPING
      IHFLAG = -1
      GO TO 900
C--SUCCESS  -  CHECK FOR '#LIST', '#PRINT' OR '#PUNCH'
1350  CONTINUE
      LFL=LR52-1
      IF(INSTR-LSTOFF)1400,1400,1410
1410  CONTINUE
C----- CHECK FOR 'CONCEALED' LIST, EXCEPT SFLS
      I= INSTR - LSTOFF
      IF ((I .GT. 49) .OR. (I .EQ. 33)) GOTO 1700
      LSTNO = I
      LSTOP = 1
      ICLASS = -1
      GOTO 1700
C--THIS IS A LIST CALL  -  PROCESS THE LIST TYPE
1400  CONTINUE
      JB=LFL
      CALL XLL50R(INSTR)
      CALL XZEROF(IBUFF(1),4)
C--READ THE DIRECTIVE
      IF(KRDNDC(IBUFF(1),4)-1)1250,1450,1250
C--LOOP OVER THE INPUT PARAMETERS ON THIS DIRECTIVE
1450  CONTINUE
      DO 1550 I=1,NR62D
C--FIND THE PARAMETER
      IF(KFNDNP(I))1250,1550,1500
C--READ THE VALUE
1500  CONTINUE
      IF(KRDPV(IBUFF(1),4))1250,1550,1550
1550  CONTINUE
C--CHECK THAT THERE ARE NO MORE PARAMETERS ON THIS CARD
      IF(KCHKUP(IBUFF(1),4))1250,1600,1600
C--INSERT ANY NECESSARY DEFAULTS
1600  CONTINUE
      IF(KCHKPV(1,IBUFF(1),4,-1))1250,1650,1650
C--ALTER 'INSTR' TO REFLECT THIS CHANGE
1650  CONTINUE
      LSTOP=INSTR
      LSTNO=IBUFF(1)
      INSTR=IBUFF(1)+LSTOFF
C--RESET THE CORE LIMIT
      LFL=JB
C--SET THE CLASS TYPE
      ICLASS=IBUFF(2)
C -- CHECK THAT THE REQUESTED LIST NUMBER IS ALLOWED
      ISTAT = KLSCHK ( LSTNO , 0 , 0 , ILSCLN , ILSMSG , I , IERNOP )
      IF ( ISTAT .LE. 0 ) GO TO 1250
C--SUCCESS  -  LOAD THE DETAILS FOR THIS COMMAND
1700  CONTINUE
      CALL XLL50R(INSTR)
C--CHECK IF THERE IS A LIST OF LISTS TO BE USED
      IF(NR63)2800,2800,1750
C--LISTS TO BE USED ARE GIVEN  -  CHECK FOR ANY LIST GENERATION CALLS
1750  CONTINUE
      NLIST=0
      MR63=LR63
C--INDICATE THAT WE HAVE NOT EMPTIED THE SYSTEM REQUEST QUEUE
      KA=0
C--LOOP OVER THE LISTS TO BE USED FOR THIS '#INSTRUCTION'
      DO 2600 I=1,NR63
      MR52=LR52
C--CHECK AGAINST THOSE LISTS PROVIDED FOR INTERNAL GENERATION
      DO 2500 K=1,NR52
      IF(ISTORE(MR52)-ISTORE(MR63))2450,1800,2450
C--AGREEMENT  -  CHECK IF THE LIST EXISTS
1800  CONTINUE
      CALL XRLIND(ISTORE(MR52),NA,NB,NC,ND,NE,IBUFF(1))
      IF(NB)2200,2200,1850
C--CHECK THE WRITE/OVERWRITE STATUS
1850  CONTINUE
      IF(ND)2200,1900,2200
C--CHECK THE ERROR STATUS
1900  CONTINUE
      IF(NE)2200,1950,1950
C--LIST IS OKAY  -  FIND ITS INTERDEPENDENCIES RECORD
1950  CONTINUE
      IF(KFNDRI(ISTORE(MR52),1,IADDR,IBUFF))2550,2000,2000
C--RECORD FOUND  -  PRESERVE THE CORE LIMITS
2000  CONTINUE
      JA=NFL
      JB=LFL
C--MAKE SPACE FOR THE DATA IN THE RECORD
      KK=IBUFF(5)*IBUFF(6)
      L=KCHLFL(KK)
C--BRING DOWN THE DATA
      CALL XDOWNF(IBUFF(4),STORE(L),KK)
C--RESET THE CORE POINTERS
      NFL=JA
      LFL=JB
      N=IBUFF(5)
C--LOOP OVER EACH LIST TYPE FOR THIS ONE ON DISC
2050  CONTINUE
      IF(N)2450,2450,2100
C--READ THE DATA FOR THIS LIST
2100  CONTINUE
      CALL XRLIND(ISTORE(L),NA,NB,NC,ND,NE,IBUFF(1))
C--CHECK IF THIS LIST EXISTS
      IF(NB)2400,2400,2150
C--CHECK IF THE CURRENT VERSION IS THE ONE USED TO MAKE THIS LIST
2150  CONTINUE
      M=L+IBUFF(5)
      IF(IABS(NE)-ISTORE(M))2200,2400,2200
C--COMMAND TO BE ISSUED  -  CHECK IF THERE IS DATA IN THE S.R.Q.
2200  CONTINUE
      IF(NLIST)2250,2250,2350
C--WE HAVE NOT EMPTIED THE QUEUE YET  -  CHECK IF WE SHOULD
2250  CONTINUE
      IF(NREC)2350,2350,2300
C--EMPTY THE SYSTEM REQUEST QUEUE
2300  CONTINUE
      KA=NREC
      KB=20
      KC=KA*KB
C--ALLOCATE A BUFFER TO HOLD THE RECORDS
      KD=KCHLFL(KC)
C--READ THE RECORDS
      KC=KD+KC-1
      READ(NUSRQ,CFMRQ) (ISTORE(KE), KE=KD, KC)
C--SORT THE QUEUE OUT
      NREC=0
      IEOF=NREC
      IPOSRQ=0
      REWIND NUSRQ
C--NEW LIST IS REQUIRED OF THIS TYPE  -  ISSUE A COMMAND
2350  CONTINUE
      WRITE (CIMAGE, CFORM) (ISTORE(IZ), IZ= MR52+1, MR52+MDR52-2)
      CALL XISRC (CIMAGE)
C--ADD AN 'END' CARD
      CALL XISRC (CEND)
      NLIST=NLIST+1
      GOTO 2550
C--UPDATE FOR THE NEXT LIST STORED HERE
2400  CONTINUE
      L=L+1
      N=N-1
      GOTO 2050
C--UPDATE FOR THE NEXT LIST ON THE GENERATION STACK
2450  CONTINUE
      MR52=MR52+MDR52
2500  CONTINUE
C--UPDATE FOR THE NEXT LIST TO BE USED BY THIS '#INSTRUCTION'
2550  CONTINUE
      MR63=MR63+MDR63
2600  CONTINUE
C--CHECK IF ANY REQUEST HAVE BEEN ISSUED
      IF(NLIST)2800,2800,2650
C--PROCESS SOME MORE REQUESTS
2650  CONTINUE
      I=KPSRQ(1)
C--CHECK IF WE MUST ADD THE REQUESTS WE HAVE STORED IN CORE
      IF(KA)1000,1000,2700
C--LOOP OVER EACH REQUEST
2700  CONTINUE
      DO 2750 I=1,KA
      WRITE(CIMAGE,CFMRQ) (ISTORE(IZ), IZ= KD, KD+KB-1)
      CALL XISRC (CIMAGE)
      KD=KD+KB
2750  CONTINUE
      GOTO 1000
C--CLEAR CORE AND RELOAD THE DETAILS FOR THIS COMMAND
2800  CONTINUE
      CALL XRSL
      CALL XCSAE
      CALL XLL50R(INSTR)
C--ASSIGN THE RETURN VALUES
      KFNHF=ISTORE(LR64)
C--RESET THE DIRECTIVE POINTERS
      IDIRFL=-1
      IPARAM=-1
      IPARAD=NOWT
      RETURN
      END
C
CODE FOR KRDDPV
      FUNCTION KRDDPV(ICOMMN,IDIMN)
C--THIS ROUTINE READS A SET OF DIRECTIVES, TOGETHER WITH THE PARAMETERS
C  OFF THE DIRECTIVE CARDS.
C
C  ICOMMN  THE COMMON BLOCK FOR THIS INPUT OPERATION.
C  IDIMN    THE DIMENSION OF THE COMMON BLOCK.
C----- IDIM SET IN XRDLN, CURRENTLY TO 512
C
C--RETURN VALUES OF 'KRDDPV' ARE :
C
C  -1  ERRORS.
C   0  ALL PROCESSED OKAY.
C
C--
C
      DIMENSION ICOMMN(IDIMN)
C
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
C--ZERO THE COMMON BLOCK INITIALLY
      CALL XZEROF(ICOMMN,IDIMN)
C--READ THE NEXT DIRECTIVE
1000  CONTINUE
      IF(KRDNDC(ICOMMN,IDIMN))1250,1050,1050
C--FIND THE NEXT PARAMETER
1050  CONTINUE
      IDWZAP = 0
      IF(KFNDNP(IDWZAP))1000,1000,1100
C--READ THE PARAMETER VALUE
1100  CONTINUE
      IF(KRDPV(ICOMMN,IDIMN))1000,1050,1150
C--STRING FOR INTERPRETATION  -  NOT BY US!
1150  CONTINUE
      CALL XMONTR(0)
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1200)
      WRITE ( CMON, 1200)
      CALL XPRVDU(NCEROR, 1,0)
1200  FORMAT(' Parameter type is illegal for ''KRDDPV''')
      CALL XERHND ( IERPRG )
C--END OF THE DATA  -  CHECK FOR ERRORS
1250  CONTINUE
      KRDDPV=0
      IF(LEF)1300,1350,1300
C--ERRORS FOUND
1300  CONTINUE
      KRDDPV=-1
1350  CONTINUE
      RETURN
      END
C
CODE FOR KRDNDC
      FUNCTION KRDNDC(ICOMMN,IDIMN)
C--READ THE NEXT DIRECTIVE CARD.
C
C  ICOMMN  THE DATA OR COMMON BLOCK AREA BEING SET UP FOR THIS
C          INSTRUCTION.
C  IDIMN    THE SIZE OF 'ICOMMN'.
C
C--THE COMMON BLOCK 'XCARDS' IS USED BY THIS AND OTHER ROUTINES
C  FOR CARD I/O CONTROL. THE VARIABLES ARE :
C
C  IMAGE   THE INPUT CARD BUFFER.
C  NC      THE CURRENT PROCESSING POSITION IN 'IMAGE'.
C  ND      EITHER 'NC' OR THE END OF THE CURRENT INFORMATION TO BE
C          PROCESSED IN 'IMAGE'.
C  LASTCH  THE LAST CHARACTER ON THE CURRENT INPUT RECORD TO BE USED.
C  NI      THE NUMBER OF THE CURRENT INPUT CARD.
C  NILAST  THE NUMBER OF THE CARD FOR THE LAST '#INSTRUCTION' FOUND.
C  NS      THE INCREMENT BETWEEN SUCCESSIVE INPUT RECORDS. THIS IS ONE
C          FOR DATA FROM THE USER AND 10000 FOR DATA ON THE SYSTEM
C          REQUEST QUEUE.
C  MON     THE NUMBER OF THE LAST CARD PRINTED BY 'XMONTR'.
C  ICAT    THE TYPE OF LISTING REQUEST FOR THE CARDS THAT ARE
C          PROCESSED. THIS VARIABLE IS USED BY 'XMONTR'.
C  IEOF    END OF FILE AND SYSTEM REQUEST QUEUE FLAG :
C
C          -1  LAST STATEMENT READ END OF FILE, AND THUS THE NEXT WILL
C              CALL WILL FAIL THE JOB.
C           0  NORMAL READING FROM THE CONTROL STREAM.
C          >0  READING FROM THE SYSTEM REQUEST QUEUE.
C
C  IHFLAG  THIS VARIABLE INDICATES WHETHER THE LAST CARD CONTAINED
C          A '#INSTRUCTION' WHICH HAS NOT YET BEEN PROCESSE :
C
C          -1  NO '#INSTRUCTION' ON THE LAST CARD.
C           0  UNPROCESSED '#INSTRUCTION' ON THE LAST CARD.
C          +1    PROCESSED '#INSTRUCTION' ON THE LAST CARD.
C
C  NUSRQ   THE UNIT TO BE USED FOR THE SYSTEM REQUEST QUEUE.
C  NREC    THE NUMBER OF REQUESTS OUTSTANDING ON THE SYSTEM REQUEST
C          QUEUE.
C  IPOSRQ  THE CURRENT POSITION OF THE REQUEST QUEUE.
C  ITYPFL  THIS VARIBLE INDICATES THE TYPE OF KEYWORD BEING PROCESSED
C          AT PRESENT :
C
C          1  INSTRUCTION.
C          2  DIRECTIVE.
C          3  PARAMETER.
C          4  REQUIRED INPUT VALUE.
C
C  INSTR   THE NUMBER OF THE CURRENT INSTRUCTION.
C  IDIRFL  THIS CONTAINS THE NUMBER OF THE CURRENT DIRECTIVE, OR
C          -1  IF NO DIRECTIVE IS BEING PROCESSED.
C  IPARAM  THIS CONTAINS THE NUMBER OF THE CURRENT PARAMETER, OR
C          -1  IF NO PARAMETER IS BEING PROCESSED.
C  IPARAD  THIS CONTAINS THE ADDRESS OF THE CURRENT GROUP IN THE
C          DATA AREA FOR THE CURRENT DIRECTIVE OR 'NOWT'.
C
C--RETURN VALUES OF 'KRDNDC' ARE :
C
C  -1  END OF DIRECTIVES FOR THIS '#INSTRUCTION'
C   0  CONTINUATION CARD.
C  >0  THE DIRECTIVE FOUND.
C
C--THIS ROUTINE EXPECTS THAT TYPE 60 RECORDS WILL ALREADY BE
C  LOADED.
C
C--
      INCLUDE 'ICOM50.INC'
      INCLUDE 'ISTORE.INC'
C
C
      DIMENSION ICOMMN(IDIMN)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST50.INC'
      INCLUDE 'XCARDS.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XSYSHF.INC'
      INCLUDE 'XSYSDR.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QCOM50.INC'
C
C--PRESERVE THE PARAMETER POINTERS
      JPARAM=IPARAM
      JPARAD=IPARAD
C--INDICATE THAT NO PARAMETERS ARE BEING PROCESSED
      IPARAM=-1
      IPARAD=NOWT
C--SET THE TYPE OF CHARACTER STRING WE ARE SEARCHING FOR
      ITYPFL=2
C--CHECK IF WE ARE PROCESSING A '#INSTRUCTION' CARD STILL
      IF(IHFLAG)1100,1000,1000
C--'#INSTRUCTION' CARD  -  CHECK FOR THE NAME AMONGST THE DIRECTIVES
1000  CONTINUE
      IHFLAG=-1
      IF(NR60)1100,1100,1050
C--SOME TO USE  -  MAKE THE COMPARISON
1050  CONTINUE
      NC=2
      ND=KEQUAL(NC,IB)
      NUM=KCNXTS(MDR60-1,ISTORE(LR60),NR60,MDR60)
C--CHECK THE REPLY
      NC=ND
      IF(NUM)1100,1100,1850
C--END OF THE LAST CARD  -  CHECK FOR UNACCESSED PARAMETERS
1100  CONTINUE
      IF(KCHKUP(ICOMMN,IDIMN))1300,1150,1150
C--READ THE NEXT CARD FROM THE APPROPIATE STREAM
1150  CONTINUE
C&RIC{
      I=0
C&RIC}
      IF(KRDREC(I))2600,1200,2600
C--THIS IS A NORMAL CARD WITHOUT A '#' IN COLUMN ONE
1200  CONTINUE
      IF(IMAGE(1).NE.IB)GOTO 1350
C--THIS CARD HAS NOTHING IN COLUMN ONE  -  THIS IS AN ERROR
      I=KCHKPV(IDIRFL,ICOMMN,IDIMN,1)
C--NOW PRINT SOME ERROR MESSAGE
      CALL XMONTR(0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1250)
      WRITE ( CMON, 1250)
      CALL XPRVDU(NCEROR, 1,0)
1250  FORMAT(' The user directive has been omitted',
     2 ' or does not begin in column one')
C--GENERAL ERROR AREA
1300  CONTINUE
      LEF=LEF+1
      IDIRFL=-1
      CALL XMONTR(0)
      GOTO 1150
C--FIND THE NEXT BLANK TO TERMINATE THE USER DIRECTIVE
1350  CONTINUE
      ND=KEQUAL(NC,IB)
C--CHECK FOR SYSTEM DEFINED DIRECTIVE
      I=KCNXTS(NWSPD,ISPD,NSPD,LSPD)
C--CHECK THE REPLY
      IF(I)1150,1700,1400
C--SUCCESS  -  CHECK THAT THERE IS NOT AN IDENTITY CLASH
1400  CONTINUE
      NC=1
      IF(NR60)1500,1500,1420
1420  CONTINUE
      IF(KCNXTS(MDR60-1,ISTORE(LR60),NR60,MDR60))1150,1500,1450
C--DIRECTIVE NAME CLASH  -  ERROR
1450  CONTINUE
      I=KCHKPV(IDIRFL,ICOMMN,IDIMN,1)
      CALL XMDCS
      GOTO 1150
C--A SYSTEM DEFINED DIRECTIVE HAS BEEN FOUND  -  BRANCH ON ITS TYPE
1500  CONTINUE
      IF(I-1)1550,1550,2600
C--THIS IS A 'CONTINUE' DIRECTIVE  -  CHECK FOR A DIRECTIVE
1550  CONTINUE
      IF(IDIRFL)1300,1600,1600
C--DIRECTIVE OKAY  -  CARRY ON
1600  CONTINUE
      KRDNDC=0
      IPARAM=JPARAM
      IPARAD=JPARAD
C--RESET THE CURRENT POSITION
1650  CONTINUE
      NC=ND
      RETURN
C
1700  CONTINUE
C -- NOT A SYSTEM DIRECTIVE. CHECK FOR A DIRECTIVE FROM THE COMMAND
C    FILE, IF THERE ARE ANY
      IF ( NR60 .LE. 0 ) GO TO 1750
      NUM=KCNXTS(MDR60-1,ISTORE(LR60),NR60,MDR60)
      IF(NUM)1150,1750,1850
C--NOT A USER DIRECTIVE EITHER  -  PRINT AN ERROR MESSAGE
1750  CONTINUE
      I=KCHKPV(IDIRFL,ICOMMN,IDIMN,1)
      CALL XMONTR(0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1800)IH
      WRITE ( CMON, 1800) IH
      CALL XPRVDU(NCEROR, 1,0)
1800  FORMAT(' The directive on the last card is illegal',
     2 ' with this ''',A1,'Instruction''')
      GOTO 1300
C--ENSURE THAT THE LAST USER DIRECTIVE TERMINATED OKAY
1850  CONTINUE
      I=KCHKPV(IDIRFL,ICOMMN,IDIMN,1)
C--SET UP THE REST OF THE POINTERS FOR THIS DIRECTIVE
      CALL XDIRFL(NUM,ICOMMN,IDIMN)
      IDIRFL=NUM
C--CHECK IF THIS DIRECTIVE HAS BEEN ENABLED
      IF(KINCLD(ICOMMN,IDIMN))1900,2000,2000
C--THIS DIRECTIVE HAS NOT BEEN ENABLED FOR INPUT FOR CREATION
1900  CONTINUE
      CALL XMONTR(0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1950)
      WRITE ( CMON, 1950)
      CALL XPRVDU(NCEROR, 2,0)
1950  FORMAT(' At least one other directive or parameter',
     2 ' has been omitted'/' The directive above',
     3 ' cannot be processed')
      GOTO 1300
C--CREATE ANY DATA AREAS THAT ARE REQUIRED
2000  CONTINUE
      IF(KCDRFI(ICOMMN,IDIMN,-1))1150,2050,2050
C--CHECK IF THIS DIRECTIVE IS VALID HERE
2050  CONTINUE
      IF(ISTORE(MR61+6))2100,2200,2200
C--THIS DIRECTIVE HAS BEEN DISALLOWED BY ANOTHER DIRECTIVE
2100  CONTINUE
      J=LR60+(IABS(ISTORE(MR61+6))-1)*MDR60
      K=J+MDR60-2
      CALL XMONTR(0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,2150)(STORE(I+1),I=J,K)
      WRITE ( CMON, 2300)
      CALL XPRVDU(NCEROR, 1,0)
2300  FORMAT(' The last directive should have appeared before',
     2 ' and will be ignored here')
      GOTO 1300
C--CHECK IF THIS DIRECTIVE CAN BE INPUT HERE
2200  CONTINUE
      IF(ISTORE(MR61+8))2250,2350,2350
C--NOT ALLOWED ANY MORE
2250  CONTINUE
      J=LR60+(IABS(ISTORE(MR61+6))-1)*MDR60
      K=J+MDR60-2
      CALL XMONTR(0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,2300)
      WRITE ( CMON, 2150) (STORE(I+1),I=J,MIN(J+40,K))
      CALL XPRVDU(NCEROR, 2,0)
2150  FORMAT(' The directive above may not follow',
     2 ' a card containing the directive : '/40A1)
      GOTO 1300
C--CHECK IF THIS DIRECTIVE HAS ALREADY BEEN DEFAULTED
2350  CONTINUE
      IF(ISTORE(MR61+8)-1000000)2400,2400,2250
C--CHECK IF THIS DIRECTIVE HAS BEEN REPEATED TOO MANY TIMES
2400  CONTINUE
      ISTORE(MR61+8)=ISTORE(MR61+8)+1
C RIC: If max directive count is 9999, then ignore this check.      
      IF((ISTORE(MR61+8).GT.ISTORE(MR61+7)).AND.
     1   (ISTORE(MR61+7).LT.9999)) THEN
C--THIS DIRECTIVE HAS APPEARED TOO MANY TIMES
        CALL XMONTR(0)
        IF (ISSPRT .EQ. 0) WRITE(NCWU,2500)
        WRITE ( CMON, 2500)
        CALL XPRVDU(NCEROR, 2,0)
2500  FORMAT(' The last directive has appeared too many times,',
     2 /' or should not have appeared at all')
C -- MARK DIRECTIVE AS BEING IN ERROR
        ISTORE(MR61+8) = -1
        GOTO 1300
      END IF

C--CHECK IF THIS DIRECTIVE EXCLUDES ANY OTHER DIRECTIVES
      CALL XCLUDE(NUM)

C--SET THE RETURN VALUES AT THIS POINT
      KRDNDC=NUM
C--SET THE POINTERS UP AGAIN FOR THE BENEFIT OF THE DATA RECORD POINTER
      CALL XDIRFL(IDIRFL,ICOMMN,IDIMN)
C--ZERO THE PARAMETER REPEAT COUNTS IF NECESSARY
      CALL XZROPC
      GOTO 1650

C--'#INSTRUCTION' OR 'END' DIRECTIVE  -  CHECK THE LAST IF NECCESSARY
2600  CONTINUE
      I=KCHKPV(IDIRFL,ICOMMN,IDIMN,1)
C--CHECK IF THERE IS AN 'END' CARD TO PRINT
      IF(IHFLAG)2650,2700,2700
C--PRINT THE LAST CARD
2650  CONTINUE
      CALL XMONTR(-1)
C--CHECK IF THERE ARE ANY DIRECTIVES FOR THIS INSTRUCTION
2700  CONTINUE
      IF(NR60)3450,3450,2750
C--LOOP OVER EACH DIRECTIVE, CHECKING IF IT HAS BEEN INPUT
2750  CONTINUE
      DO 3400 I=1,NR60
      CALL XDIRFL(I,ICOMMN,IDIMN)
      IDIRFL=I
C--CHECK IF THIS DIRECTIVE HAS BEEN INPUT
      IF(ISTORE(MR61+8))3400,2950,2800
C--DIRECTIVE INPUT  -  CHECK IF IT DEFINED A DATA RECORD
2800  CONTINUE
      IF(ISTORE(MR61+11))3400,3400,2850
C--RECORD DEFINED  -  CHECK IF ALL THE DATA HAS BEEN INPUT
2850  CONTINUE
      IF(ISTORE(MR61+7)-ISTORE(MR61+8))2900,3400,2900
C--ALL THE DATA IS NOT THERE  -  SET UP SOME DEFAULTS
2900  CONTINUE
      ISTORE(MR61+8)=ISTORE(MR61+8)+1
      GOTO 3100
C--CREATE ANY ASSOCIATED DATA AREAS
2950  CONTINUE
      IF(KINCLD(ICOMMN,IDIMN))3400,3000,3000
C--AND NOW THE DATA RECORD
3000  CONTINUE
      IF(KCDRFI(ICOMMN,IDIMN,0))3400,3050,3050
C--SET UP THE NUMBER OF PASSES
3050  CONTINUE
      ISTORE(MR61+8)=1
C--EXCLUDE ANY DIRECTIVES FOR THIS ONE
      CALL XCLUDE(I)
C--NOW SET UP THE DEFAULTS FOR ONE GROUP
3100  CONTINUE
      CALL XZROPC
      IF(KCHKPV(I,ICOMMN,IDIMN,0))3400,3150,3150
C--CHECK IF THIS DIRECTIVE DEFINED A DATA RECORD
3150  CONTINUE
      IF(ISTORE(MR61+11))3400,3400,3200
C--DATA RECORD IN CORE  -  CHECK IF ALL THE GROUPS HAVE BEEN SET
3200  CONTINUE
      N=ISTORE(MR61+7)-ISTORE(MR61+8)
      IF(N)3400,3400,3250
C--CHECK IF THERE ANY PARAMETERS FROM WHICH TO FIND DEFAULTS
3250  CONTINUE
      IF(NR62D)3400,3400,3300
C--SET UP THE REST OF THE GROUPS IN THE RECORD
3300  CONTINUE
      L=IPARAD
      DO 3350 J=1,N
      L=L+ISTORE(MR61+9)
      CALL XMOVE(STORE(IPARAD),STORE(L),ISTORE(MR61+9))
3350  CONTINUE
3400  CONTINUE
C--INDICATE END OF DIRECTIVES FOR THIS '#INSTRUCTION'
3450  CONTINUE
      KRDNDC=-1
      IDIRFL=-1
      GOTO 1650
      END
C
CODE FOR KCHKUP
      FUNCTION KCHKUP(ICOMMN,IDIMN)
C--CHECK THE LAST DIRECTIVE FOR UNACCESSED PARAMETERS
C
C  ICOMMN  THE COMMON BLOCK FOR TIS INPUT.
C  IDIMN    THE DIMENSION OF THE COMON BLOCK.
C
C--THIS ROUTINE RETURNS VALUES OF :
C
C  -1  THE LAST CARD CONTAINED UNACCESSED PARAMETERS.
C   0  THE LAST CARD WAS PROCESSED CORRECTLY
C
C--
C
      DIMENSION ICOMMN(IDIMN)
C
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XCARDS.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XIOBUF.INC'
C
C--SET AN OKAY RETURN VALUE
      KCHKUP=0
C--CHECK IF THE LAST CARD CONTAINS A DIRECTIVE
      IF(IDIRFL)1000,1000,1050
1000  CONTINUE
      RETURN
C--DIRECTIVE TO LOOK AT
1050  CONTINUE
      NC=KNEQUL(NC,IB)
      IF(NC)1000,1000,1100
C--UNACCESSED PARAMETERS
1100  CONTINUE
      CALL XMONTR(0)
      J=NC-1
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1150)J
      WRITE ( CMON, 1150) J
      CALL XPRVDU(NCEROR, 1,0)
1150  FORMAT(' The last card contains',
     2 ' unaccessed parameter(s) beyond column ',I4)
C--NOW CHECK THE LAST RECORD INPUT
      I=KCHKPV(IDIRFL,ICOMMN,IDIMN,-1)
      IDIRFL=-1
      LEF=LEF+1
      KCHKUP=-1
      GOTO 1000
      END
C
CODE FOR XCLUDE
      SUBROUTINE XCLUDE(NUM)
C--CHECK IF THIS DIRECTIVE EXCLUDES ANY OTHER DIRECTIVES
C
C  NUM     THE NUMBER OF THE DIRECTIVE TO EXCLUDE.
C
C--THIS ROUTINE EXPECTS THE LIST 50 POINTERS TO BE SET UP.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST50.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CHECK IF THIS DIRECTIVE EXCLUDES ANY OTHER DIRECTIVES
      IF(ISTORE(MR61+6))1100,1100,1000
C--MARK THE DIRECTIVES TO BE EXCLUDED
1000  CONTINUE
      J=ISTORE(MR61+4)+LR62
      N=ISTORE(MR61+6)
C--LOOP OVER EACH DIRECTIVE TO BE EXCLUDED
      DO 1050 I=1,N
      K=LR61+(ISTORE(J)-1)*MDR61
      ISTORE(K+6)=-NUM
      J=J+ISTORE(MR61+5)
1050  CONTINUE
C--AND NOW RETURN
1100  CONTINUE
      RETURN
      END
C
CODE FOR KINCLD
      FUNCTION KINCLD(ICOMMN,IDIMN)
C -- CHECK IF THE CURRENT DIRECTIVE HAS BEEN ENABLED
C
C  ICOMMN  THE CURRENT COMMON BLOCK.
C  IDIMN    THE DIMENSION OF THE COMMON BLOCK.
C
C--RETURN VALUES ARE :
C
C  -1  THIS DIRECTIVE REQUIRES OTHER DIRECTIVES BEFORE IT CAN INCLUDED,
C      AND THESE HAVE NOT YET BEEN GIVEN.
C   0  ALL OKAY TO INCLUDE THIS DIRECTIVE.
C
C--
      INCLUDE 'ISTORE.INC'
C
C
      DIMENSION ICOMMN(IDIMN)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST50.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--ASSIGN THE INITIAL OKAY RETURN VALUE
      KINCLD=0
C--CHECK IF THIS DIRECTIVE DEFINES A DATA RECORD
C--CHECK IF THERE ARE ANY ENABLING DIRECTIVES FOR THIS DIRECTIVE
      IF(ISTORE(MR61+31))1500,1500,1050
C--THERE ARE ENABLING DIRECTIVES GIVEN  -  LOOP OVER THEM
1050  CONTINUE
      N=ISTORE(MR61+31)
      M=ISTORE(MR61+29)+LR62
      DO 1450 I=1,N
C--COMPUTE THE ADDRESS OF THE CURRENT DIRECTIVE
      L=LR61+(ISTORE(M)-1)*MDR61
C--CHECK IF THE GIVEN DIRECTIVE HAS BEEN INPUT
      IF(ISTORE(L+8))1400,1400,1100
C--THIS DIRECTIVE HAS BEEN INPUT  -  CHECK IF A PARAMETER VALUE IS REQUI
1100  CONTINUE
      IF(ISTORE(M+1))1150,1150,1200
C--NO VALUE IS REQUIRED  -  ALLOW THIS DIRECTIVE
1150  CONTINUE
      KINCLD=0
      GOTO 1500
C--A VALUE IS REQUIRED  -  CHECK THE PARAMETER VALUE GIVEN
1200  CONTINUE
      IF(ISTORE(M+1)-ISTORE(L+3))1250,1250,1400
C--CHECK IF WE ARE IN A DATA RECORD FOR THIS DIRECTIVE
1250  CONTINUE
      IF(ISTORE(L+11))1400,1300,1350
C--COMMON BLOCK DATA  -  FIND THE COMMON BLOCK ADDRESS
1300  CONTINUE
      K=LR62+ISTORE(L)+ISTORE(L+1)+(ISTORE(M+1)-1)*ISTORE(L+2)
      IF(KVALCM(ISTORE(K+4),ICOMMN,IDIMN)-ISTORE(M+2))1400,1150,1400
C--IN A DATA RECORD  -  HUNT FOR THE RECORD
1350  CONTINUE
      J=KHUNTR(ISTORE(L+13),ISTORE(L+11),IADDL,IADDR,IADDD,0)
      K=ISTORE(M+1)+IADDD
      IF(ISTORE(K-1)-ISTORE(M+2))1400,1150,1400
C--UPDATE FOR THE NEXT ENABLING DIRECTIVE
1400  CONTINUE
      M=M+ISTORE(MR61+30)
1450  CONTINUE
      KINCLD=-1
C--AND NOW RETURN
1500  CONTINUE
      RETURN
      END
C
CODE FOR XZROPC
      SUBROUTINE XZROPC
C--ZERO THE REPEAT COUNTS FOR THE PARAMETERS OF THE CURRENT DIRECTIVE
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST50.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CHECK IF THERE ARE ANY PARAMETERS FOR THIS DIRECTIVE
      IF(NR62D)1100,1100,1000
C--THERE ARE SOME PARAMETERS  -  ZERO THEIR INPUT COUNTS
1000  CONTINUE
      MR62D=LR62D
C--PASS OVER EACH PARAMETER
      DO 1050 I=1,NR62D
      ISTORE(MR62D+10)=0
      MR62D=MR62D+MDR62D
1050  CONTINUE
1100  CONTINUE
      RETURN
      END
C
CODE FOR KFNDNP
      FUNCTION KFNDNP(IN)
C--THIS FUNCTION FINDS THE NEXT PARAMETER ON A DIRECTIVE CARD
C
C  IN  A DUMMY ARGUMENT.
C
C--RETURN VALUES OF 'KFNDNP' ARE :
C
C  -1  NO MATCH OR ANY OTHER TYPE OF ERROR.
C   0  END OF CARD FOUND, OR THIS DIRECTIVE HAS NO PARAMETERS.
C  >0  THE PARAMETER THAT HAS BEEN FOUND.
C
C--THIS ROUTINE SETS 'IPARAM' AND THE POINTERS IN LIST 50 WHEN
C  A SUCCESSFUL FIND IS MADE.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XCARDS.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLST50.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
C
      IDWZAP = IN
C--SET THE TYPE OF ARGUMENT FLAG
      ITYPFL=3
      KFNDNP=0
C--CHECK FOR SOME PARAMETERS TO SEARCH FOR
      IF(NR62D)1300,1300,1000
C--FIND THE NEXT NON-BLANK CHARACTER
1000  CONTINUE
      IONC = NC
      NC=KNEQUL(NC,IB)
C--CHECK FOR THE END OF THE CARD
      ND=NC
      IF(ND)1300,1300,1050
C--CHECK IF THE NEXT CHARACTER IS A BLANK
1050  CONTINUE
      IF(IMAGE(ND).EQ.IB)GOTO 1400
C--CHECK FOR A COMMA
      IF(IMAGE(ND).EQ.ICOMMA)GOTO 1500
C--CHECK FOR AN EQUALS SIGN TO TERMINATE THE PARAMETER KEYWORD
      NND=ND
      IF(IMAGE(ND).EQ.IEQUAL)GOTO 1100
C--UPDATE FOR THE NEXT CHARACTER
      ND=ND+1
C--CHECK FOR THE END OF THE CARD
      IF(ND-LASTCH)1050,1050,1500
C--EQUALS SIGN  -  SEARCH FOR THE KEYWORD
1100  CONTINUE
      IPARAM=KCNXTS(MDR62N-1,ISTORE(LR62N),NR62N,MDR62D)
C--CHECK FOR SUCCESS
      IF(IPARAM)1250,1150,1350
C--NO MATCH  -  ERROR MESSAGE
1150  CONTINUE
      CALL XMONTR(0)
      ND=ND-1
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1200)(IMAGE(I),I=NC,ND)
      WRITE ( CMON, 1200) (IMAGE(I),I=NC,ND)
      CALL XPRVDU(NCEROR, 2,0)
1200  FORMAT(' Unknown parameter keyword : ',/,1X, 80A1)
C--ERROR RETURN
1250  CONTINUE
      IDIRFL=-1
      LEF=LEF+1
      KFNDNP=-1
C--AND NOW RETURN
1300  CONTINUE
      RETURN
C--KEYWORD FOUND  -  UPDATE THE CHARACTER COUNT
1350  CONTINUE
      NC=NND+1
      NC=KNEQUL(NC,IB)
      GOTO 1550
C--BLANK FOUND  -  SEARCH FOR '=' AFTER IT
1400  CONTINUE
      NND=ND+1
      NND=KNEQUL(NND,IB)
      IF(NND)1500,1500,1450
C--ANOTHER CHARACTER  -  CHECK IT
1450  CONTINUE
      IF(IMAGE(NND).EQ.IEQUAL)GOTO 1100
C--CHARACTER FOUND THAT CANNOT BE PART OF A KEYWORD  -  THUS NO KEYWORD
1500  CONTINUE
      IPARAM=MIN0(IPARAM+1,NR62D)
C If type is 5, then this may be a series of values of type 5's.
C Try to avoid omiting spaces that occur at posn. 5,9,13 etc.
      IF ((IPARAM.GT.1).AND.(ISTORE(LR62D+(IPARAM-1)*MDR62D).EQ.5)) THEN
        NC = IONC
      END IF
C--SET UP THE POINTERS IN LIST 50
1550  CONTINUE
      I=(IPARAM-1)*MDR62D
      MR62D=LR62D+I
      MR62N=LR62N+I
C--UPDATE THE NUMBER OF TIMES WE HAVE FOUND THIS PARAMETER
      ISTORE(MR62D+10)=ISTORE(MR62D+10)+1
C--CHECK THAT WE HAVE NOT READ THIS TOO MANY TIMES
      IF(ISTORE(MR62D+10)-ISTORE(MR62D+9))1700,1700,1600
C--PARAMETER GIVEN TOO MANY TIMES
1600  CONTINUE
      CALL XMONTR(0)
      J=MR62N+MDR62N-2
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1650)IPARAM,(ISTORE(I+1),I=MR62N,J)
      WRITE ( CMON, 1650) IPARAM,(ISTORE(I+1),I=MR62N,J)
      CALL XPRVDU(NCEROR, 2,0)
1650  FORMAT(' Parameter ',I5,'  has appeared too many times',
     2 /' Parameter keyword : ',40A1)
      GOTO 1250
C--ASSIGN THE RETURN VALUE
1700  CONTINUE
      KFNDNP=IPARAM
      GOTO 1300
      END
C
CODE FOR KRDPV
      FUNCTION KRDPV(ICOMMN,IDIMN)
C--THIS ROUTINE READS THE NEXT PARAMETER VALUE, WHICH SHOULD HAVE BEEN
      INCLUDE 'XIOBUF.INC'
C  FOUND BY 'KFNDNP'.
C
C  ICOMMN  THE COMMON BLOCK FOR THE CURRENT INPUT.
C  IDIMN    THE DIMENSION OF THE COMMON BLOCK.
C
C--RETURN VALUES OF 'KRDPV' ARE :
C
C  -1  ERROR.
C   0  PARAMETER READ OKAY.
C  +1  PARAMETER IS NOT A NUMBER OF SIMPLE CHARACTER STRING  -  MUST
C      READ BY THE CALLING ROUTINE.
C
C--
      INCLUDE 'ISTORE.INC'
C
C
      DIMENSION ICOMMN(IDIMN)
      DIMENSION AA(1)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XCARDS.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLST50.INC'
C
      INCLUDE 'QSTORE.INC'
C
C
      EQUIVALENCE (AA(1),A),(AA(1),IAA)
C
C--SET THE TYPE OF ARGUMENT WE ARE PROCESSING
      ITYPFL=4
C--CHECK IF THIS ROUTNE CAN PROCESS THE INPUT ARGUMENT VALUE
      KRDPV=1
      IF (ISTORE(MR62D) .EQ. 5) THEN
            GOTO 1000
      ENDIF
      IF(ISTORE(MR62D)-4)1000,1200,1200
C--VALUE CAN BE PROCESSED HERE  -  CHECK THAT THERE IS AN ARGUMENT
1000  CONTINUE
      ND=KNEQUL(NC,IB)
      IF(ND)1050,1050,1250
C--NO ARGUMENT  -  THIS IS AN ERROR
1050  CONTINUE
      CALL XMONTR(0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1100)LASTCH
      WRITE ( CMON, 1100) LASTCH
      CALL XPRVDU(NCEROR, 1,0)
1100  FORMAT(' Missing parameter value at about column ',I4)
C--ERROR RETURN
1150  CONTINUE
      IDIRFL=-1
      LEF=LEF+1
      KRDPV=-1
C--AND NOW RETURN
1200  CONTINUE
      RETURN
C--CHECK THE TYPE OF ARGUMENT TO READ
1250  CONTINUE
      KRDPV=0
      NNC=NC
C----- CHECK NUMBER OR STRING
      IF(ISTORE(MR62D)-3)1300,2100,2100
C--NUMBER TO BE READ  -  INPUT IT
1300  CONTINUE
      IF(KINPUT(A))1350,1400,1350
C--ERROR DURING THE NUMBER
1350  CONTINUE
      CALL XSPCH
      GOTO 1150
C--CHECK IF WE ARE READING AN INTEGER OR FLOATING POINT NUMBER
1400  CONTINUE
      IF(ISTORE(MR62D)-1)1500,1450,1500
C--AN INTEGER
1450  CONTINUE
      IAA=NINT(A)
C--CHECK IF THERE ARE ANY PERMITTED VALUES FOR THIS ARGUMENT
1500  CONTINUE
      IF(ISTORE(MR62D+3))1950,1950,1550
C--CHECK THE ALLOWED VALUES
1550  CONTINUE
      N=ISTORE(MR62D+3)
      M=ISTORE(MR62D+1)+LR62
C--CHECK EACH VALUE IN TURN
      DO 1800 I=1,N
C--CHECK THE TYPE OF ARGUMENT
      IF(ISTORE(MR62D)-1)1600,1600,1700
C--AN INTEGER TO BE COMPARED
1600  CONTINUE
      IF(IAA-ISTORE(M))1750,1650,1750
C--A MATCH  -  SET THE POINTER
1650  CONTINUE
      IAA=I+ISTORE(MR62D+6)-1
      GOTO 1950
C--CHECK FOR FLOATING POINT MATCH
1700  CONTINUE
      IF(ABS(A-STORE(M))-ZERO)1650,1750,1750
C--UPDATE FOR THE NEXT PERMITTED  VALUE
1750  CONTINUE
      M=M+ISTORE(MR62D+2)
1800  CONTINUE
C--NO MATCH  -  THIS IS AN ERROR
1850  CONTINUE
      CALL XMONTR(0)
      J=MR62N+MDR62N-2
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1900)NNC,(ISTORE(I+1),I=MR62N,J)
      WRITE ( CMON, 1900) NNC,(ISTORE(I+1),I=MR62N,J)
      CALL XPRVDU(NCEROR, 2,0)
1900  FORMAT(' Value provided at about column ',I4,
     2 '  is not one of those expected.'/' Parameter keyword : ',20A1)
      GOTO 1150
C--CHECK IF THIS VALUE IS TO BE STORED IN A DATA RECORD
1950  CONTINUE
      IF(ISTORE(MR61+11))2000,2050,2000
C--TO BE STORED IN A DATA RECORD
2000  CONTINUE
      J=IPARAD+IPARAM
      CALL XMOVE(AA(1),STORE(J-1),1)
      GOTO 1200
C--TO BE STORED IN THE COMMON BLOCK  -  CHECK THE ADDRESS
2050  CONTINUE
      J=ISTORE(MR62D+4)
      K=KVALCM(J,ICOMMN,IDIMN)
      CALL XMOVEI (IAA,ICOMMN(J),1)
      GOTO 1200
C--CHARACTER STRING TO BE READ  -  SEARCH FOR THE NEXT BLANK
2100  CONTINUE
      IF (ISTORE(MR62D ) .EQ. 5) THEN
C----- LONG TEXT STRING - GET UP TO 4 CHARACTERS, INCLUDING BLANK
        I = MIN0( NC, LASTCH)
        J = MIN0( NC+4, LASTCH)
        ND = J
        IF ( J .EQ. I) GOTO 1350
C----- PACK THE CHARACTERS
        CALL XFA4CS(IMAGE(NC),AA(1),MIN0(4,ND-NC))
C----- UPDATE POINTERS
        NC = ND
        GOTO 1950
      ENDIF
      I=KEQUAL(NC,IB)
C--CHECK FOR END OF CARD
      IF(I)2150,2150,2200
C--ADJUST FOR END OF CARD
2150  CONTINUE
      I=LASTCH
C--SEARCH FOR THE NEXT COMMA
2200  CONTINUE
      J=KEQUAL(NC,ICOMMA)
C--CHECK FOR END OF CARD
      IF(J)2250,2250,2300
C--ADJUST FOR END OF CARD
2250  CONTINUE
      J=LASTCH
C--COMPUTE THE PARAMETER VALUE LENGTH
2300  CONTINUE
      ND=MIN0(I,J)
      IF(ND)1350,1350,2310
C--CHECK FOR SOME ALLOWED VALUES
2310  CONTINUE
      IF(ISTORE(MR62D+3))2350,2350,2450
C--STRING ITELF IS REQUIRED  -  PACK THE CHARACTERS UP
2350  CONTINUE
      CALL XFA4CS(IMAGE(NC),AA(1),MIN0(4,ND-NC))
C--UPDATE THE POINTER
2400  CONTINUE
      NC=ND+1
      GOTO 1950
C--PERMITTED VALUE TO BE FOUND
2450  CONTINUE
      J=LR62+ISTORE(MR62D+1)
      I=KCNXTS(ISTORE(MR62D+2)-1,ISTORE(J),ISTORE(MR62D+3),
     2 ISTORE(MR62D+2))
C--CHECK FOR SUCCESS
      IF(I)1150,1850,2500
C--SUCCESS  -  COMPUTE THE STORED VALUE
2500  CONTINUE
      IAA=I+ISTORE(MR62D+6)-1
      GOTO 2400
      END
C
CODE FOR KCDRFI
      FUNCTION KCDRFI(ICOMMN,IDIMN,ITYPE)
C--THIS ROUTINE CREATES A DATA RECORD SUITABLE FOR INPUT,
C  AND THEN SETS UP THE DATA RECORD REPEAT COUNT AREA.
C
C  ICOMMN  THE COMMON BLOCK BEING USED.
C  IDIMN    THE DIMENSION OF 'ICOMMN'.
C  ITYPE   SOURCE OF DATA FLAG :
C
C          -1  DATA HAS JUST BEEN INPUT FROM CARDS FOR THIS DIRECTIVE.
C           0  NO DATA HAS BEEN INPUT  -  CHECK NO DEFAULTS ARE MISSING.
C          +1  DATA CONTEXT IS ALREADY KNOWN  -  NO OUTPUT REQUIRED FOR
C
C--RETURN VALUES OF 'KCDRFI' ARE :
C
C  -1  ERRORS FOUND.
C   0  ALL OKAY.
C
C--THIS ROUTINE EXPECTS THE POINTERS SET UP BY 'XDIRFL' TO BE
C  CORRECT.
C
C--
      INCLUDE 'ISTORE.INC'
      INCLUDE 'ICOM50.INC'
C
C
      DIMENSION ICOMMN(IDIMN)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST50.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XCARDS.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QCOM50.INC'
C
C--SET AN INITIAL RETURN VALUE
      KCDRFI=0
C--CHECK IF THE DIRECTIVE FOUND USES A DATA RECORD
      IF(ISTORE(MR61+11))1000,1100,1000
C--DATA RECORD USED  -  CHECK IF THIS IS THE FIRST TIME FOR THIS RECORD
1000  CONTINUE
      IF(ISTORE(MR61+8))1100,1150,1100
C--ERROR  -  RECORD CANNOT BE SET UP
1050  CONTINUE
      KCDRFI=-1
1100  CONTINUE
      RETURN
C--FIND THE NUMBER OF ELEMENTS PER REPEAT GROUP
1150  CONTINUE
      IF(KINVAL(ISTORE(MR61+9),I,ICOMMN,IDIMN))1200,1400,1400
C--ERROR IN FINDING THIS PARAMETER
1200  CONTINUE
      IF(ITYPE)1250,1350,1350
C--CARD INPUT  -  PRINT THE CARD AND AN ERROR MESSAGE
1250  CONTINUE
      CALL XMONTR(0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1300)
      WRITE ( CMON, 1300 )
      CALL XPRVDU(NCEROR, 1,0)
1300  FORMAT(' Previous errors prevent processing',
     2 ' of the last directive')
1350  CONTINUE
      IDIRFL=-1
      LEF=LEF+1
      GOTO 1050
C--FIND THE NUMBER OF GROUPS
1400  CONTINUE
      IF(KINVAL(ISTORE(MR61+10),J,ICOMMN,IDIMN))1200,1450,1450
C--PARAMETERS FOUND  -  SET THE REPEAT COUNT FOR THE DIRECTIVE
1450  CONTINUE
      ISTORE(MR61+7)=J
C--SET THE GROUP PARAMETERS
      ISTORE(MR61+9)=I
      ISTORE(MR61+10)=J
      K=J
C--CHECK IF WE SHOULD CREATE A DATA AREA
      IF(ISTORE(MR61+11))1500,1550,1550
C--NO DATA AREA REQUIRED
1500  CONTINUE
      K=0
C--CREATE THE DATA RECORD AND UPDATE ITS PROPERTIES
1550  CONTINUE
      L=KCEDR(ISTORE(MR61+13),1,ISTORE(MR61+11),I,K,ISTORE(MR61+12))
      CALL XUDRH(ISTORE(MR61+13),ISTORE(MR61+11),I,J)
C--FIND THE COMMON BLOCK OFFSET
      M=ISTORE(MR61+12)
C--CHECK THAT THE OFFSET IS VALID
      N=KVALCM(M,ICOMMN,IDIMN)
C--SET UP THE PARAMETER STORAGE POINTERS
      IPARAM=0
      IPARAD=L
C--SET UP THE COMMON BLOCK
      ICOMMN(M)=L
      ICOMMN(M+1)=L
      ICOMMN(M+2)=I
      ICOMMN(M+3)=J
C--CHECK IF THIS RECORD IS IN CORE
      IF(ISTORE(MR61+11))1600,1650,1650
C--NOT IN CORE
1600  CONTINUE
      ICOMMN(M)=NOWT
      GOTO 1750
C--RECORD IS IN CORE  -  ZERO IT INITIALLY
1650  CONTINUE
      N=I*J
      IF(N)1750,1750,1700
C--SPACE TO ZERO
1700  CONTINUE
      CALL XZEROF(STORE(L),N)
C--CHECK IF THIS DIRECTIVE HAS ONE PARAMETER KEYWORD ONLY
1750  CONTINUE
      IF(ISTORE(MR61+3)-1)2100,1800,2100
C--ONLY ONE PARAMETER KEYWORD  -  SUBSCRIPTION IS POSSIBLE
1800  CONTINUE
      NW=5
C--FIND THE POINTERS TO THE ORIGINAL SET OF PARAMETER KEYWORDS
      L=ISTORE(MR61)+LR62
      M=ISTORE(MR61+1)
      N=ISTORE(MR61+2)
C--INCREMENT THE PARAMETER LENGTHS TO ALLOW FOR THE SUBSCRIPT
      ISTORE(MR61+1)=ISTORE(MR61+1)+NW
      ISTORE(MR61+2)=ISTORE(MR61+2)+NW
C--RESET THE NUMBER OF ALLOWED KEYWORDS
      ISTORE(MR61+3)=ISTORE(MR61+9)
C--CHECK THE NUMBER OF PARAMETERS BEING USED NOW
      ISTORE(MR61)=NOWT
      IF(ISTORE(MR61+3))2100,2100,1850
C--FIND THE LOCATION FOR THE NEW KEYWORD CONTROL BLOCK
1850  CONTINUE
      LR62N=KCHLFL(ISTORE(MR61+2)*ISTORE(MR61+3))
      ISTORE(MR61)=LR62N-LR62
C--RESET ALL THE CONTROL VALUES
      I=(MR61-LR61)/MDR61+1
      CALL XDIRFL(I,ICOMMN,IDIMN)
C--LOOP OVER THE CURRENT NUMBER OF KEYWORDS, GENERATING INDEXED NAMES
      DO 2050 I=1,NR62D
C--MOVE THE CURRENT NAME ACROSS
      CALL XMOVE(STORE(L),STORE(MR62N),M)
C--BLANK OUT THE REST OF THE NAME
      J=MR62N+M
      CALL XMVSPD(IB,ISTORE(J),NW)
C--FIND THE END OF THE CURRENT NAME
      K=MR62N+ISTORE(MR62N)
C--INSERT A '('
      ISTORE(K+1)=ILB
C--ZERO THE INCLUDE ZEROES FLAG
      NUM2=0
C--ASSIGN THE CURRENT INDEX
      NUM=I
C--COMPUTE THE DIVISOR
      NUMDVD=10**(NW-3)
C--INSERT A MAXIMUM OF 'NW-2' INDEX CHARACTERS
      DO 2000 J=3,NW
      NUM1=NUM/NUMDVD
      NUM=NUM-NUM1*NUMDVD
      NUM1=MOD(NUM1,10)
      NUMDVD=NUMDVD/10
C--CHECK IF ALL NUMBERS MUST BE INCLUDED
      IF(NUM2)1900,1900,1950
C--NO NUMBERS IN YET  -  CHECK FOR LEADING ZEROES
1900  CONTINUE
      IF(NUM1)2000,2000,1950
C--INCLUDE THIS NUMBER
1950  CONTINUE
      NUM2=1
      ISTORE(K+2)=NUMB(NUM1+1)
C--UPDATE THE ADDRESS AND COUNTS
      K=K+1
      ISTORE(MR62N)=ISTORE(MR62N)+1
2000  CONTINUE
C--INSERT A ')'
      ISTORE(K+2)=IRB
      ISTORE(MR62N)=ISTORE(MR62N)+2
C--FIND THE ADDRESS OF THE REST OF THE DATA
      K=L+M
C--MOVE IT ACROSS
      CALL XMOVE(STORE(K),STORE(MR62D),MDR62D-MDR62N)
C--UPDATE FOR THE NEXT
      MR62N=MR62N+MDR62D
      MR62D=MR62D+MDR62D
2050  CONTINUE
C--AND NOW EXIT
2100  CONTINUE
      ISTORE(MR61+3)=MIN0(ISTORE(MR61+3),ISTORE(MR61+9))
      NR62D=ISTORE(MR61+3)
      GOTO 1100
      END
C
CODE FOR KINVAL
      FUNCTION KINVAL(IADD,IANS,ICOMMN,IDIMN)
C--FETCH THE VALUE STORED IN A COMMON BLOCK OR DATA AREA.
C
C  IADD    THE INITIAL POINTER :
C
C          <0  THE ABSOLUTE VALUE OF 'IADD' POINTS TO AN ADDRESS IN
C              'ICOMMN' WHICH CONTAINS THE NEXT ADDRESS OR THE REQUIRED
C              VALUE.
C          >0  (OR EQUAL TO 0) THIS IS THE VALUE REQUIRED.
C
C  IANS    THE REQUURED ANSWER IS RETURNED HERE.
C  ICOMMN  THE COMMON BLOCK.
C  IDIMN    THE DIMENSION OF 'ICOMMN'.
C
C--THE RETURN VALUES OF 'KINVAL' ARE :
C
C  -1  AN ERROR HAS OCCURRED  -  NO VALUE GIVEN.
C   0  ALL OKAY.
C
C--
      INCLUDE 'ISTORE.INC'
C
C
      DIMENSION ICOMMN(IDIMN)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST50.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--INITIAL ASSIGNMENT
      IANS=IADD
      KINVAL=0
C--CHECK IF WE HAVE A VALUE YET
1000  CONTINUE
      IF(IANS)1050,1020,1020
1020  CONTINUE
      RETURN
C--FIND THE NEXT POINT ALONG THE CHAIN
1050  CONTINUE
      JANS=IABS(IANS)
      KANS=KVALCM(JANS,ICOMMN,IDIMN)
C--SEARCH FOR THIS ADDRESS AMONGST THE POSSIBLE INPUT VALUES
      JB=LR61
C--CHECK IF THIS INSTRUCTION HAS ANY DIRECTIVES
      IF(NR61)1650,1650,1100
C--LOOP OVER EACH DIRECTIVE
1100  CONTINUE
      DO 1600 JA=1,NR61
C--CHECK IF THIS DIRECTIVE CONTAINS SIMPLE PARAMETERS
      IF(ISTORE(JB+11))1550,1150,1550
C--CHECK IF THERE ARE ANY PARAMETERS FOR THIS DIRECTIVE
1150  CONTINUE
      IF(ISTORE(JB+3))1550,1550,1200
C--THERE ARE SOME PARAMETERS  -  SCAN ALONG THEM
1200  CONTINUE
      JE=ISTORE(JB)+LR62
      JF=ISTORE(JB+1)+JE
      JD=ISTORE(JB+3)
C--LOOP OVER THE PARAMETERS
      DO 1500 JC=1,JD
C--CHECK IF THE STORAGE POINT HERE EQUALS THE INPUT ADDRESS
      IF(ISTORE(JF+4)-JANS)1450,1250,1450
C--THIS IS THE PARAMETER  -  CHECK IF IT HAS BEEN INPUT
1250  CONTINUE
      IF(KCHKPV(JA,ICOMMN,IDIMN,0))1300,1400,1400
C--NO PROCESSING IS POSSIBLE
1300  CONTINUE
      KINVAL=-1
      RETURN
C--PARAMETER SET OKAY  -  STOP ANY FURTHER INPUT OF THIS DIRECTIVE
1400  CONTINUE
      ISTORE(JB+8)=1000001
C--FIND THE VALUE THAT IS NOW PRESENT IN THE COMMON BLOCK
      KANS=KVALCM(JANS,ICOMMN,IDIMN)
      GOTO 1650
C--UPDATE FOR THE NEXT PARAMETER
1450  CONTINUE
      JE=JE+ISTORE(JB+2)
      JF=JF+ISTORE(JB+2)
1500  CONTINUE
C--UPDATE FOR THE NEXT DIRECTIVE
1550  CONTINUE
      JB=JB+MDR61
1600  CONTINUE
C--ASSIGN THE NEXT VALUE IN THE CHAIN
1650  CONTINUE
      IANS=KANS
      GOTO 1000
      END
C
CODE FOR KCHKPV
      FUNCTION KCHKPV(IDIR,ICOMMN,IDIMN,ITYPE)
C--THIS ROUTINE CHECKS THAT THE DIRECTIVE INDICATED BY THE
C  VALUE OF 'IDIR' HAS BEEN PROPERLY INPUT.
C
C  IDIR    THE DIRECTIVE NUMBER.
C  ICOMMN  THE COMMON BLOCK BEING FILLED BY THIS PROCESS.
C  IDIMN    THE DIMENSION OF THE COMMON BLOCK.
C  ITYPE   SOURCE OF DATA FLAG :
C
C          -1  DATA HAS JUST BEEN INPUT FROM CARDS FOR THIS DIRECTIVE.
C           0  NO DATA HAS BEEN INPUT  -  CHECK NO DEFAULTS ARE MISSING.
C          +1  DATA CONTEXT IS ALREADY KNOWN  -  NO OUTPUT REQUIRED FOR
C
C--RETURN VALUES OF 'KCHKPV' ARE :
C
C  -1  AN ERROR HAS BEEN FOUND.
C   0  ALL OKAY.
C
C--
      INCLUDE 'ISTORE.INC'
C
C
      DIMENSION ICOMMN(IDIMN)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCARDS.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST50.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
C
      KCHKPV=0 !Default return.
      JTYPE=ITYPE
C--RECORD THE NUMBER OF ERRORS SO FAR
      MYLEF=LEF
C--CHECK IF A DIRECTIVE IS BEING PROCESSED
      IF(IDIR)2050,2050,1000
C--SET UP THE POINTERS FOR THIS DIRECTIVE
1000  CONTINUE
      CALL XDIRFL(IDIR,ICOMMN,IDIMN)
C--CHECK IF THIS DIRECTIVE HAS ALREADY GENERATED ERRORS
      KCHKPV=-1
      IF(ISTORE(MR61+8))2050,1050,1050
C--DIRECTIVE BEING PROCESSED  -  CHECK IF IT HAS ANY PARAMETERS
1050  CONTINUE
      KCHKPV=0
C--CHECK IF THIS DIRECTIVE HAS ALREADY BEEN DEFAULTED
      IF(ISTORE(MR61+8)-1000000)1100,1100,2050
C--NOW CHECK THE NUMBER OF PARAMETERS
1100  CONTINUE
      IF(NR62D)2050,2050,1150
C--PARAMETERS REQUIRED  -  CHECK FOR A DATA RECORD
1150  CONTINUE
      IF(ISTORE(MR61+11))2050,1250,1200
C--CHECK FOR A NON-ZERO REPEAT COUNT  -  I.E. SOMEWHERE TO PUT THE DATA
1200  CONTINUE
      IF(ISTORE(MR61+10))2050,2050,1250
C--LOOP OVER EACH PARAMETER FOR THIS DIRECTIVE
1250  CONTINUE
      DO 2000 I=1,NR62D
C--CHECK IF THIS PARAMETER HAS BEEN INPUT
      IF(ISTORE(MR62D+10))1300,1300,1950
C--PARAMETER NOT INPUT  -  CHECK FOR A DEFAULT VALUE
1300  CONTINUE
      IF(ISTORE(MR62D+7))1350,1800,1800
C--NO DEFAULT VALUE  -  CHECK IF THIS PARAMETER SHOULD BE INPUT
1350  CONTINUE
      IF(ISTORE(MR62D+9))1950,1950,1400
C--NO DEFAULT VALUE  -  CHECK FOR AN EXCLUDED DIRECTIVE
1400  CONTINUE
      IF(ISTORE(MR61+6))1950,1450,1450
C--ERROR  -  CHECK ON THE TYPE OF STATEMENT PRINT REQUIRED
1450  CONTINUE
      IF(JTYPE)1600,1500,1650
C--NOT A READ  -  SIMPLY A CHECK
1500  CONTINUE
      L=MR60+MDR60-2
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1550)(ISTORE(J+1),J=MR60,L)
      WRITE ( CMON, 1550) (ISTORE(J+1),J=MR60,L)
      CALL XPRVDU(NCEROR, 1,0)
1550  FORMAT(' A directive has been omitted',
     2 ' leaving the parameters below undefined',
     3 /' Directive : ', 20A1)
C--MARK THIS DIRECTIVE AS TOO LATE
      ISTORE(MR61+8)=-1
      GOTO 1650
C--INPUT FROM CARDS  -  PRINT THE LAST CARD IF NECESSARY
1600  CONTINUE
      CALL XMONTR(0)
C--JUMP ON THE TYPE OF ERROR GENERATED
1650  CONTINUE
      JTYPE=1
      K=MR62N+MDR62N-2
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1700)I,(ISTORE(J+1),J=MR62N,K)
      WRITE ( CMON, 1700) I,(ISTORE(J+1),J=MR62N,K)
      CALL XPRVDU(NCEROR, 2,0)
1700  FORMAT(' Parameter ',I3,
     2 '  has no default value and has been omitted',/
     3 ' Parameter keyword : ',20A1)
C--UPDATE THE ERROR COUNTER
      LEF=LEF+1
      KCHKPV=-1
      GOTO 1950
C--CHECK IF THIS IS A DATA AREA OR A COMMON BLOCK
1800  CONTINUE
      IF(ISTORE(MR61+11))1850,1900,1850
C--THIS IS A DATA AREA  -  INSERT THE DEFAULT VALUE
1850  CONTINUE
      CALL XMOVE(STORE(MR62D+8),STORE(IPARAD),1)
      GOTO 1950
C--ASSIGN THE DEFAULT VALUE
1900  CONTINUE
      J=ISTORE(MR62D+4)
C--CHECK THAT THE COMMON BLOCK ADDRESS IS VALID
      K=KVALCM(J,ICOMMN,IDIMN)
C--MOVE THE DEFAULT VALUE OVER
      CALL XMOVEI (ISTORE(MR62D+8),ICOMMN(J),1)
C--UPDATE FOR THE NEXT PARAMETER
1950  CONTINUE
      MR62N=MR62N+MDR62D
      MR62D=MR62D+MDR62D
      IPARAD=IPARAD+1
2000  CONTINUE
C--AND NOW RETURN
2050  CONTINUE
      CALL XDIRFL(IDIRFL,ICOMMN,IDIMN)
C--CHECK IF WE GENERATED ANY ERRORS
      IF(LEF-MYLEF)2100,2200,2100
C--ERRORS  -  PRINT A BLANK LINE
2100  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU,2150)
2150  FORMAT(1X)
C--AND NOW RETURN
2200  CONTINUE
      RETURN
      END
C
CODE FOR XDIRFL
      SUBROUTINE XDIRFL(NUM,ICOMMN,IDIMN)
C--SET UP THE POINTERS TO THE TYPE 60 RECORDS FOR A DIRECTIVE.
C
C  NUM     THE NUMBER OF THE DIRECTIVE.
C  ICOMMN  THE COMMON BLOCK BEING USED FOR THIS INPUT.
C  IDIMN    THE DIMENSION OF THE COMMON BLOCK.
C
C--
      INCLUDE 'ISTORE.INC'
C
C
      DIMENSION ICOMMN(IDIMN)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST50.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XCARDS.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CHECK IF A DIRECTIVE IS INDICATED
      IF(NUM)1100,1100,1000
1000  CONTINUE
C--POINTERS TO THE DIRECTIVE NAME
      MR60=LR60+(NUM-1)*MDR60
C--POINTER TO THE DIRECTIVE DETAILS
      MR61=LR61+(NUM-1)*MDR61
C--POINTERS TO THE PARAMETER NAMES AND DETAILS
      LR62N=ISTORE(MR61)+LR62
      MR62N=LR62N
      LR62D=LR62N+ISTORE(MR61+1)
      MR62D=LR62D
C--INCREMENTS OVER THE PARAMETERS
      MDR62N=ISTORE(MR61+1)
      MDR62D=ISTORE(MR61+2)
C--NUMBER OF PARAMETERS
      NR62N=ISTORE(MR61+3)
      NR62D=NR62N
C--SET UP THE POINTERS TO THE DATA AREA IF NECESSARY
      IPARAM=0
      IPARAD=NOWT
C--CHECK IF THIS INPUT IS FOR A DATA AREA
      IF(ISTORE(MR61+11))1050,1100,1050
C--DATA AREA  -  SET THE POINTERS
1050  CONTINUE
      IPARAD=KVALCM(ISTORE(MR61+12),ICOMMN,IDIMN)+MAX0(0,ISTORE(MR61+8)
     2 -1)*ISTORE(MR61+9)
C--AND NOW RETURN
1100  CONTINUE
      RETURN
      END
C
CODE FOR KVALCM
      FUNCTION KVALCM(IADD,ICOMMN,IDIMN)
C--THIS ROUTINE FETCHES THE VALUE FROM 'ICOMMN(IADD)', AFTER CHECKING TH
C  'IADD' IS A VALID ADDRESS.
C
C  IADD    THE ADDRESS IN THE COMMON BLOCK.
C  ICOMMN  THE COMMON BLOCK.
C  IDIMN    THE DIMENSION OF 'ICOMMN'.
C
C--THE RETURN VALUE OF 'KVALCM' IS THE CONTENTS OF THE REQUIRED LOCATION
C
C--
C
      DIMENSION ICOMMN(IDIMN)
C
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
C--CHECK IF THE LOCATION GIVEN IS VALID
      IF(KVALID(1,IADD,IDIMN))1000,1100,1100
C--INVALID LOCATION
1000  CONTINUE
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1050)IADD,LN,IREC
      WRITE ( CMON, 1050) IADD,LN,IREC
      CALL XPRVDU(NCEROR, 2,0)
1050  FORMAT(' Invalid common block address ',I8,/,'List type ',I5,
     2 5X,'Record type ',I8)
      CALL XERHND ( IERPRG )
C--FETCH THE CONTENTS
1100  CONTINUE
      KVALCM=ICOMMN(IADD)
      RETURN
      END
C
CODE FOR XFAL50
      SUBROUTINE XFAL50
C--LOAD THE CONTROL RECORDS FOR LIST 50  -  THE INPUT AND LIST FORMAT LI
C
C--
C
      DIMENSION IRECS(3)
      INCLUDE 'ICOM50.INC'
      INCLUDE 'HEADES.INC'
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'XDISCS.INC'
      INCLUDE 'XDISC.INC'
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLST50.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QCOM50.INC'
C
C
      DATA IRECS(1)/52/,IRECS(2)/-51/,IRECS(3)/50/
C
C--SWITCH TO THE INSTRUCTION DEFINITION DISC
      KA = KSWPDU ( NCIFU )
C--ZERO THE COMMON BLOCK
      CALL XZEROF(ICOM50(1),IDIM50)
C--SET UP THE LIST TYPE
      LN=50
C--LOAD THE CONTROL RECORDS ONE BY ONE
      DO 1150 I=1,3
      IF(KFNDRI(LN,IRECS(I),IADDR,IBUFF))1000,1100,1100
C--NO SUCH RECORD
1000  CONTINUE
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1050)IRECS(I)
      WRITE ( CMON, 1050) IRECS(I)
      CALL XPRVDU(NCEROR, 1,0)
1050  FORMAT(' Missing control record ',I8)
      CALL XERHND ( IERPRG )
C--LOAD THE RECORD
1100  CONTINUE
      CALL XLDREC(LN,1,IBUFF,ICOM50,IDIM50,0)
1150  CONTINUE
C--SWITCH DISCS AGAIN
      N = KSWPDU ( KA )
      RETURN
      END
C
CODE FOR XLL50R
      SUBROUTINE XLL50R(NUMB)
C--LOAD RECORDS FROM LIST 50 FOR INSTRUCTION NUMBER 'NUMB'.
C
C  NUMB  THE NUMBER OF THE INSTRUCTION WHOSE DETAILS ARE TO BE LOADED
C
C--
      INCLUDE 'ICOM50.INC'
      INCLUDE 'HEADES.INC'
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'XDISCS.INC'
      INCLUDE 'XDISC.INC'
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST50.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QCOM50.INC'
C
C--SWITCH TO THE INSTRUCTION DEFINITION DISC
      KA = KSWPDU ( NCIFU )
C--BLANK OUT THE COMMON BLOCK
      DO 1000 I=LCOM,MCOM,MDCOM
      ICOM50(I)=NOWT
      ICOM50(I+2)=0
      ICOM50(I+3)=0
1000  CONTINUE
C--MOVE THE COMMON BLOCK DETAILS INTO THE COMMON BLOCK
      LN=50
      IREC=51
C--ALLOCATE SPACE FOR THE LOAD DETAILS
      MR51=KCHLFL(MDR51)
C--FIND THE DISC ADDRESS
      J=LR51+KINCRF((NUMB-1)*MDR51)
C--LOAD THIS SET OF LOAD DETAILS
      CALL XDOWNF(J,STORE(MR51),MDR51)
      J=MR51+MDR51-2
C--LOOP OVER EACH AVAILABLE RECORD TYPE
      DO 1100 K=MR51,J,2
C--CHECK IF THE RECORD EXISTS
      IF(ISTORE(K+1))1100,1100,1050
C--FIND THE DETAILS OF THIS RECORD
1050  CONTINUE
      L=ISTORE(K)
      M=ISTORE(K+1)
      N=KLDDRH(L,M,IBUFF)
C--MAKE THIS RECORD A RECORD THAT CAN BE LOADED
      IBUFF(7)=IABS(IBUFF(7))
      CALL XLDREC(LN,1,IBUFF,ICOM50,IDIM50,0)
1100  CONTINUE
C--SET UP A THE REST OF THE POINTERS
      DO 1150 I=LCOM,MCOM,MDCOM
      ICOM50(I+1)=ICOM50(I)
1150  CONTINUE
C--SWITCH BACK TO THE ORIGINAL DISC
      N = KSWPDU ( KA )
      RETURN
      END

