C $Log: not supported by cvs2svn $
C Revision 1.3  2001/02/26 10:24:14  richard
C Added changelog to top of file
C
C
CODE FOR XFRGN1
      SUBROUTINE XFRGN1
C--SUBROUTINE TO INITIALISE THE CALL TO A FOREIGN PROGRAM.
C
C--THIS ROUTINE ALSO SEARCHES THE INPUT STREAM FOR THE NEXT '#INSTRUCTIO
C  CARD, AND CHECKS THAT THE SYSTEM REQUEST QUEUE IS EMPTY.
C
C--
\XUNITS
\XSSVAL
\XERVAL
\XIOBUF
C
C--LOAD THE NEXT '#INSTRUCTION' CARD
      J=KFNHF(LSTOP,LSTNO,ICLASS)
C--CHECK THAT THE SYSTEM REQUEST QUEUE IS EMPTY
      IF(KPSRQ(-1))1000,1100,1000
C--THE QUEUE IS NOT EMPTY
1000  CONTINUE
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1050)
      ENDIF
      WRITE(NCAWU,1050)
      WRITE ( CMON, 1050)
      CALL XPRVDU(NCEROR, 1,0)
1050  FORMAT(' System request queue should be empty')
      CALL XERHND ( IERPRG )
C--AND NOW RETURN
1100  CONTINUE
      RETURN
      END
C
CODE FOR XFRGN2
      SUBROUTINE XFRGN2(ICOM)
C--THIS ROUTINE TERMINATES THE OUTPUT TO THE SYSTEM REQUEST QUEUE AND LO
C  THE PROGRAM REQUIRED FOR THE COMMAND STORED IN 'ICOM'.
C
C  ICOM   A FOUR CHARACTER COMMAND NAME, DEFINING THE NEXT OPERATION
C        TO BE PERFORMED.
C
C--
C
      DIMENSION ICOM(4)
\ISTORE
C
\STORE
\XLST50
\XCHARS
\XCARDS
\XPRGNM
C
\QSTORE
C
C--TERMINATE THE SYSTEM REQUEST QUEUE
      WRITE(NUSRQ,1000)(IH,IB,(IH,I=1,78),J=1,5)
1000  FORMAT(80A1)
C--WRITE OUT A '#END'
      WRITE(NUSRQ,1050)IH,(IH,I=1,76)
1050  FORMAT(A1,'END',76A1)
C--WRITE THE NEXT PROGRAM NAME TO BE LOADED
      MR64=LR64+19
      WRITE(NUSRQ,1100)(ISTORE(I),I=LR64,MR64)
1100  FORMAT(2I4,18A4)
      ENDFILE(NUSRQ)
      REWIND(NUSRQ)
C--PRESERVE THE CURRENT DETAILS OF THE COMMON BLOCKS
      NILAST=NI
C--COPY THE PROGRAM NAME THAT WE WILL ENTER AFTER THE FOREIGN CALL
      CALL XMOVE(STORE(LR64+2),KPRGNM(1),MDR64-2)
C--OUTPUT THE COMMON BLOCK DETAILS
      CALL XSYSDC(0,0)
C--BLANK OUT THE CURRENT COMMAND
      CALL XMVSPD(IB,IMAGE(2),LASTCH-1)
C--ADD IN THE REQUIRED COMMAND
      CALL XMOVEI (ICOM(1),IMAGE(2),4)
C--LOAD THE DETAILS
      I=KFNHF(LSTOP,LSTNO,ICLASS)
C--LOAD THE PROGRAM
      CALL XCONT1(ISTORE(MR64),MDR64)
      RETURN
      END
C
CODE FOR XFRGN3
      SUBROUTINE XFRGN3(NRU,NWU)
C--ROUTINE TO RETURN FROM A FOREIGN LINK
C
C  NRU   DEVICE NUMBER OF THE SYSTEM REQUEST QUEUE FOR THIS LINK.
C  NWU  LINE PRINTER DEVICE NUMBER.
C
C--
C
      DIMENSION IBUFF(20),ICON(2)
C
\XUNITS
\XSSVAL
C
C
      DATA ICON(1)/'#'/,ICON(2)/'END '/
C
C--SET THE UNIT NUMBER FOR THE L/P
      NCWU=NWU
C--CHECK FOR UNUSED CARDS
      I=0
C--READ THE NEXT CARD
1000  CONTINUE
      READ(NRU,1050)(IBUFF(J),J=1,2)
1050  FORMAT(A1,A3)
C--CHECK FOR A '#' IN COLUMN 1
      IF(KCOMP(1,IBUFF(1),ICON(1),1,2))1100,1100,1150
C--INCREMENT THE UNUSED COUNT
1100  CONTINUE
      I=I+1
      GOTO 1000
C--CHECK FOR ANY UNUSED CARDS
1150  CONTINUE
      IF(I)1300,1300,1200
C--PRINT THE UNUSED CARD COUNT
1200  CONTINUE
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1250)I
      ENDIF
1250  FORMAT(1X,I4,'  Card(s) ignored by the last program link')
C--PRINT THE TIME USED
1300  CONTINUE
      CALL XTIME2(2)
C--FIND THE '#END' CARD
1350  CONTINUE
      IF(KCOMP(2,IBUFF,ICON(1),1,2))1400,1400,1450
C--READ ANOTHER CARD
1400  CONTINUE
      READ(NRU,1050)(IBUFF(J),J=1,2)
      GOTO 1350
C--READ THE LOAD DETAILS FOR THE NEXT PROGRAM LINK
1450  CONTINUE
      READ(NRU,1500)(IBUFF(I),I=1,20)
1500  FORMAT(2I4,18A4)
C--REWIND THE SYSTEM REQUEST QUEU
      REWINDNRU
C--LOAD THE NEXT PROGRAM
      CALL XCONT1(IBUFF,20)
      RETURN
      END
C
CODE FOR KNXTOP
      FUNCTION KNXTOP(LSTOP,LSTNO,ICLASS)
C--THIS FUNCTION FINDS THE NEXT '#INSTRUCTION' CARD AND LOADS THE PROGRA
C  SHOULD EXECUTE THE INSTRUCTION. IF THE PROGRAM IS ALREADY LOADED,
C  AS HAPPENS WHEN A PROGRAM IS FIRST ENTERED, THIS ROUTINE SIMPLY RETUR
C  WITHOUT CHANGING PROGRAM.
C
C  LSTOP   THIS PARAMETER IS SET ONLY WHEN A LIST OPERATION IS INDICATED
C          AND IS SET IN THIS CASE TO THE OPERATION REQUIRED. VALUES AVA
C          AT PRESENT ARE :
C
C          0  NO LIST OPERATION.
C          1  INPUT, VIA A '#LIST' INSTRUCTION.
C          2  PRINT, VIA A '#PRINT' INSTRUCTION.
C          3  PUNCH, VIA A '#PUNCH' INSTRUCTION.
C
C  LSTNO   WHEN A LIST OPERATION IS INDICATED, THIS VARIABLE IS SET TO T
C          LIST NUMBER ON RETURN. IN ALL OTHER CASES, THIS VARIABLE IS S
C          ZERO.
C
C  ICLASS  WHEN A LIST OPERATION IS INDICATED, THIS VARIABLE IS SET TO T
C          OPERATION CLASS ON RETURN. IN ALL OTHER CASES, THIS VARIABLE
C          SET TO ZERO.
C
C--THE RETURN VALUES OF 'KNXTOP' ARE :
C
C  -1  THE CURRENT INSTRUCTION CANNOT BE EXECUTED BY THIS PROGRAM. THIS
C      IS USED BY THIS VERSION OF THE ROUTINE.
C  >0  THE VALUE EXPECTED BY THE CALLING PROGRAM FOR THIS OPERATION.
C
C--
\ISTORE
C
\STORE
\XUNITS
\XSSVAL
\XCARDS
\XPRGNM
\XLST50
\XERVAL
C
\QSTORE
C
C----- WE COULD COME HERE AFTER AN ERROR - TRY A RESTART.
C--CHECK FOR A '#INSTRUCTION' CARD
      I=KFNHF(LSTOP,LSTNO,ICLASS)
C--CHECK IF WE MUST CHANGE PROGRAMS
      MR64=KCOMP(MDR64-2,KPRGNM,STORE(LR64+2),NR64,MDR64)
      IF(MR64)1050,1050,1000
C--THIS ROUTINE CAN PROCESS THIS '#INSTRUCTION'  -  SET THE RETURN VALUE
1000  CONTINUE
C
C----- COPY THE INSTRUCTION TO THE SNOOPER
      CALL XSPY ( 2 )
C
      MR64=LR64+(MR64-1)*MDR64
      KNXTOP=ISTORE(MR64)
      RETURN
C--STORE THE NEW FILE NAME AWAY
1050  CONTINUE
      CALL XMOVE(STORE(LR64+2),KPRGNM(1),MDR64-2)
C--MARK THE '#INSTRUCTION' AS READY FOR PROCESSING
      IHFLAG=0
C--CHECK THAT THIS IS NOT THE SAME CARD THAT WE FOUND ON ENTERING
      NILAST=NI
C--DUMP THE COMMON BLOCK VALUES
      CALL XSYSDC(0,0)
C--LOAD THE NEXT PROGRAM
      CALL XCONT1(ISTORE(LR64),MDR64)
      KNXTOP=-1
      RETURN
      END
C
CODE FOR XCONT1
      SUBROUTINE XCONT1(LOAD,IDIMN)
C--THIS SUBROUTINE LOADS THE NEXT PROGRAM
C
C  LOAD    THE LOAD DETAILS :
C
C          1  THE ENTRY NUMBER FOR THE CURRENT OPERATION.
C          2  THE CORE SIZE REQUIRED.
C          3  THE FIRST WORD OF THE LOAD DETAILS.
C          4  THE SECOND WORD OF THE LOAD DETAILS, ETC.
C
C  IDIMN    THE DIMENSION OF 'LOAD'.
C
C--
C
      DIMENSION LOAD(IDIMN)
      DIMENSION MESS(11)
C
\STORE
\XSIZES
\XUNITS
\XSSVAL
\XCARDS
\XPRGNM
\XLST50
\XERVAL
\XIOBUF
C
\QSIZST
C
      DATA MESS(1)/'CRYS'/,MESS(2)/'TALS'/,MESS(3)/'LOAD'/
      DATA MESS(4)/'NAME'/,MESS(5)/':= "'/,MESS(11)/'"   '/
C
C--CHECK THE CORE SIZE FOR THE NEW PROGRAM
      J=KORE(ITEMP)
      IF(LOAD(2)-J)1100,1100,1000
C--NOT ENOUGH CORE
1000  CONTINUE
      CALL XMONTR(0)
      CALL XERHDR(0)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1050)LOAD(2),J
      ENDIF
      WRITE(NCAWU,1050) LOAD(2),J
      WRITE ( CMON, 1050) LOAD(2),J
      CALL XPRVDU(NCEROR, 1,0)
1050  FORMAT(' Next program requires ',I8,'  words of core  -  ',I8,
     2 '  words is too little')
      CALL XERHND ( IERSEV )
1100  CONTINUE
      CALL XMOVEI (LOAD(3),MESS(6),5)
      CALL XFCCS(MESS(1),MESS(1),9)
C--OUTPUT THE MESSAGE
      IF(KIGC(11,MESS(1)))1150,1250,1250
C--ERROR DURING THE ASSIGN
1150  CONTINUE
      CALL XMONTR(0)
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1200)
      ENDIF
      WRITE(NCAWU,1200)
      WRITE ( CMON, 1200)
      CALL XPRVDU(NCEROR, 1,0)
1200  FORMAT(' Error on assigning next program')
      CALL XERHND ( IERPRG )
C--LOAD THE NEXT PROGRAM
1250  CONTINUE
      CALL XQUIT
      RETURN
      END
C
CODE FOR XSYSDC
      SUBROUTINE XSYSDC(IN,IND)
C--INITIALISE OR TERMINATE THE DATA AREAS FOR A CRYSTALS PROGRAM.
C
C  IN      PROGRAM START/END CONTROL :
C          -1  START OF A PROGRAM.
C           0  END OF A PROGRAM, BEFORE CONTROL PASSES TO ANOTHER PROGRA
C
C  IND     THE TYPE OF INITIALISATION REQUIRED :
C
C          -1  JOB TO INITIALISE A DISC FILE.
C           0  FIRST LOAD OF A JOB.
C          +1  ANY BUT THE FIRST LOAD OF A JOB.
C
C--
C
\STORE
\XSIZES
\XTIMES
\XDISC
\XDISCB
\XDISCS
\XUNITS
\XSSVAL
\XFILEC
\XCOMPD
\XCHARS
\XCONST
\XLISTI
\XLIMIT
\XCARDS
\XSYSHF
\XSYSDR
\XDIRTP
\XTAPES
\XLST50
\XPRGNM
\XLEXCH
\XERVAL
\XERCNT
\XIOBUF
C
\QSIZST
C
C
C--CHECK IF THIS IS THE START OR END FOR THE CALLING PROGRAM
      IF(IN)1000,1500,1500
C--CHECK IF THIS IS AN INITIAL CALL OR A RECALL LATER
1000  CONTINUE
      IF(IND)1050,1050,1100
C--AN INITIAL CALL
1050  CONTINUE
      CALL XTIME1(0)
      GOTO 1350
C
1100  CONTINUE
C -- NOT AN INITIAL CALL. IF THE PROGRAM IS SEGMENTED, READ IN DATA
      IF ( ISSSEG .LE. 0 ) GO TO 1600
      WRITE ( CMON, '(A)') ' Reading common blocks'
      CALL XPRVDU(NCVDU, 1,0)
      REWINDNCCBU
C--READ THE TIME CONTROL CONSTANTS
      READ(NCCBU,1550)Q,QQ
C--READ THE DISC UNITS
      READ(NCCBU,1150)NCDFU,NCIFU,NCLDU
1150  FORMAT(16I5)
C--READ THE BASIC PERIPHERAL UNIT NUMBERS AND CONSTANTS
      READ(NCCBU,1150)NCRU,NCRRU,NCWU,NCPU,IPAGE,NCARU,NCAWU
      READ(NCCBU,1155) IQUN,JQUN
1155  FORMAT(2I5)
C--READ THE CURRENT CARD IN
      READ(NCCBU,1200)IMAGE
      READ ( NCCBU , 1200 ) LCMAGE
1200  FORMAT(80A1)
C--READ THE CARD CONSTANTS
      READ(NCCBU,1250)NC,ND,LASTCH,NI,NILAST,NS,MON,ICAT,IEOF,IHFLAG,
     2 NUSRQ,NREC,IPOSRQ,ITYPFL,INSTR,IDIRFL,IPARAM,IPARAD,MAPS
1250  FORMAT(8I10)
C--READ THE M/T FILE NUMBERS
      READ(NCCBU,1150)MTA,MTB,MT1,MT2,MT3,MTE
C--READ THE NAME OF THE CURRENT PROGRAM
      READ(NCCBU,1300)KPRGNM
1300  FORMAT(20A4)
C -- READ THE ERROR CONTROL FLAGS
      READ ( NCCBU , 1305 ) IERCNT
      READ ( NCCBU , 1305 ) IERLIM , IERCOU , IERMAX
1305  FORMAT ( 19I4 )
C--COMPUTE THE REST OF THE CONSTANTS
1350  CONTINUE
      PI=ACOS(-1.0)
      TWOPI=2.*PI
      TWOPIS=TWOPI*PI
      RTD=180./PI
      DTR=PI/180.
      ZEROSQ=ZERO*ZERO
      VALUSQ=VALUE*VALUE
C--ASSIGN THE DATA FILE UNIT NUMBER
      NU=NCDFU
C--ALLOCATE SOME CORE BUFFERS
      CALL XGIVE
C
C -- SET LIMITS OF ARRAY 'STORE'
C
      NFL = 1
      LFL=KORE(ITEMP)
      NUL=LFL-NFL+1
C--SET THE CORE LIMITS
      CALL XSSL(NFL,LFL,NUL)
C--CHECK IF THIS IS TO ESTABLISH A DISC OR A NORMAL LOAD
      IF(IND)1450,1400,1400
C--LOAD THE LIST CONTROL DATA
1400  CONTINUE
      CALL XLC
C--SET UP THE CORE CHAIN POINTERS
1450  CONTINUE
      L0=NOWT
      M0=NOWT
C--REPOSITION THE SYSTEM REQUEST QUEUE
      CALL XRPSRQ
      GOTO 1600
C
C
1500  CONTINUE
C -- 'PROGRAM' TERMINATION. IF SYSTEM IS SEGMENTED , WRITE OUT DATA
      IF ( ISSSEG .LE. 0 ) GO TO 1600
      WRITE ( CMON, '(A)') ' Dumping common blocks'
      CALL XPRVDU(NCVDU, 1,0)
      REWINDNCCBU
C--WRITE THE CURRENT TIME OUT TO THE CONTROL FILE
      WRITE(NCCBU,1550)Q,QQ
1550  FORMAT(4E20.10)
C--WRITE THE DISC UNITS
      WRITE(NCCBU,1150)NCDFU,NCIFU,NCLDU
C--WRITE THE BASIC PERIPHERAL UNIT NUMBERS AND CONSTANTS
      WRITE(NCCBU,1150)NCRU,NCRRU,NCWU,NCPU,IPAGE,NCARU,NCAWU
      WRITE(NCCBU,1155) IQUN,JQUN
C--WRITE THE CURRENT CARD OUT
      WRITE(NCCBU,1200)IMAGE
      WRITE ( NCCBU , 1200 ) LCMAGE
C--WRITE THE CARD CONSTANTS
      WRITE(NCCBU,1250)NC,ND,LASTCH,NI,NILAST,NS,MON,ICAT,IEOF,IHFLAG,
     2 NUSRQ,NREC,IPOSRQ,ITYPFL,INSTR,IDIRFL,IPARAM,IPARAD,MAPS
C--WRITE THE M/T FILE NUMBERS
      REWINDMTA
      REWINDMTB
      REWINDMTE
      WRITE(NCCBU,1150)MTA,MTB,MT1,MT2,MT3,MTE
C--WRITE THE NAME OF THE CURRENT PROGRAM
      WRITE(NCCBU,1300)KPRGNM
C -- WRITE ERROR CONTROLS
      WRITE ( NCCBU , 1305 ) IERCNT
      WRITE ( NCCBU , 1305 ) IERLIM , IERCOU , IERMAX
      REWINDNCCBU
C--REPOSITION THE SYSTEM REQUEST QUEUE
      REWINDNUSRQ
C--AND NOW RETURN
1600  CONTINUE
      RETURN
      END
C
CODE FOR KFNHF
      FUNCTION KFNHF(LSTOP,LSTNO,ICLASS)
C--THIS ROUTINE FINDS THE NEXT '#INSTRUCTION' CARD.
C
C  LSTOP   THIS PARAMETER IS SET ONLY WHEN A LIST OPERATION IS INDICATED
C          AND IS SET IN THIS CASE TO THE OPERATION REQUIRED. VALUES AVA
C          AT PRESENT ARE :
C
C          0  NO LIST OPERATION.
C          1  INPUT, VIA A '#LIST' INSTRUCTION.
C          2  PRINT, VIA A '#PRINT' INSTRUCTION.
C          3  PUNCH, VIA A '#PUNCH' INSTRUCTION.
C
C  LSTNO   WHEN A LIST OPERATION IS INDICATED, THIS VARIABLE IS SET TO T
C          LIST NUMBER ON RETURN. IN ALL OTHER CASES, THIS VARIABLE IS S
C          ZERO.
C
C  ICLASS  WHEN A LIST OPERATION IS INDICATED, THIS VARIABLE IS SET TO T
C          OPERATION CLASS ON RETURN. IN ALL OTHER CASES, THIS VARIABLE
C          SET TO ZERO.
C
C--THE RETURN VALUE OF 'KFNHF' IS THE NUMBER OF THE '#INSTRUCTION'
C  WHICH THE CALLING PROGRAM CAN USE. THIS NUMBER IS IN THE RANGE
C  1 TO N, WHERE 'N' IS THE MAXIMUM NUMBER OF '#INSTRUCTIONS' THAT
C  THE GIVEN PROGRAM CAN PROCESS.
C
C--THERE ARE NO ERROR RETURNS FROM THIS ROUTINE  -  ERRORS LEAD TO
C  PROGRAM TERMINATION.
C
C--ON EXIT THE CONTROL RECORDS (60 ONWARDS) FOR THE '#INSTRUCTION'
C  FOUND ARE LOADED AT THE TOP OF CORE, WITH 'NFL' AND 'LFL' SET
C  CORRECTLY. 'XRSL' MUST BE CALLED BEFORE THE WHOLE OF CORE BECOMES
C  AVAILABLE AGAIN.
C
C--WITHIN LIST 50, SEVERAL TYPES OF DATA RECORD ARE USED :
C
C  50  RECORD TYPE 50 CONTAINS THE NAMES OF THE INSTRUCTIONS, EACH ONE
C      FOLLOWING DIRECTLY AFTER THE ONE BEFORE IT. THE FORMAT IS
C      ONE CHARACTER PER WORD, AND MAY BE REPRESENTED AS :
C
C      0  MAXIMUM NUMBER OF CHARACTERS IN THIS NAME
C      1  NAME 1, WORD 1.
C      2  NAME 1, WORD 2.
C
C -51  RECORD TYPE 51 CONTAINS A SET OF DISC POINTERS TO
C      RECORDS 60, 61, 62, 63 AND 64 FOR EACH INSTRUCTION. THE
C      FORMAT OF EACH ENTRY IS AS FOLLOWS :
C
C      0  DISC ADDRESS OF THE RECORD HEADER PRECEDING RECORD 60.
C      1  DISC ADDRESS OF THE RECORD HEADER FOR RECORD TYPE 60.
C      3  DISC ADDRESS OF THE RECORD HEADER PRECEDING RECORD 61.
C
C      THIS FORMAT IS REPEATED FOR EACH RECORD TYPE FOR A INSTRUCTION,
C      AND THEN FOR EACH INSTRUCTION. THIS RECORD IS USED TO RAPIDLY
C      ACCESS DATA FOR A GIVEN INSTRUCTION.
C
C  52  THIS RECORD IS PRESENT ONCE IN THE LIST, AND CONTAINS THE
C      NECESSARY INSTRUCTIONS TO GENERATE LISTS INTERNALLY. THESE
C      INSTRUCTIONS CONTAIN THEIR '#' DELIMITERS, AND STORED IN
C      THE FOLLOWING FORMAT :
C
C      0  THE LIST TYPE NUMBER TO BE GENERATED.
C      1  THE FIRST WORD OF THE COMMAND  -  FORMAT 19A4.
C      2  THE SECOND WORD OF THE COMMAND.
C
C  60  EACH TYPE 60 RECORD CONTAINS THE NAMES OF THE DIRECTIVES
C      THAT ARE AVAILABLE WITH ONE '#' INSTRUCTION, IN THE SAME FORMAT
C      AS A TYPE 50 RECORD. EACH INSTRUCTION CAN HAVE A TYPE 60 RECORD.
C
C  61  EACH TYPE 61 RECORD CONTAINS THE DETAILS FOR THE DIRECTIVES
C      ASSOCIATED WITH ONE '#' INSTRUCTION. THE DETAILS IN A TYPE 61
C      RECORD ARE USED TO ACCESS THE PARAMETER DETAILS WHICH ARE
C      STORED IN A TYPE 62 RECORD. THE DATA IN TYPE 61 RECORDS IS
C      ARRANGED SERIALLY, AND THE ENTRY FOR EACH DIRECTIVE IS AS
C      FOLLOWS :
C
C       0  RELATIVE ADDRESS OF THE DETAILS OF THE PARAMETERS FOR THIS
C          DIRECTIVE.
C       1  NUMBER OF WORDS PER PARAMETER NAME.
C       2  NUMBER OF WORDS REQUIRED FOR THE COMPLETE PARAMETER ENTRY.
C       3  NUMBER OF PARAMETERS FOR THIS DIRECTIVE.
C       4  RELATIVE ADDRESS OF THE DIRECTIVES EXCLUDED FROM INPUT WHEN
C          THIS DIRECTIVE HAS BEEN FOUND.
C       5  NUMBER OF WORDS PER EXCLUDED DIRECTIVE.
C       6  NUMBER OF EXCLUDED DIRECTIVES.
C          THIS VALUE IS SET NEGATIVE WHEN THIS DIRECTIVE HAS BEEN
C          EXCLUDED. THE ABSOLUTE VALUE GIVES THE DIRECTIVE THAT HAS
C          EXCLUDED IT.
C       7  NUMBER OF TIMES THIS DIRECTIVE MAY APPEAR.
C          THIS VALUE IS SET FROM THE GROUP REPEAT COUNT FOR
C          DIRECTIVES THAT DEFINE DATA RECORDS.
C       8  NUMBER OF TIMES THIS DIRECTIVE HAS APPEARED.
C          DURING PROCESSING THIS LOCATION MAY BE SET AS FOLLOWS :
C
C          NEGATIVE  THIS DIRECTIVE HAS ALREADY GENERATED ERRORS.
C          OTHER     THE NUMBER OF TIMES THE DIRECTIVE HAS APPEARED.
C
C       9  THE NUMBER OF WORDS PER GROUP FOR THE RECORD DEFINED BY
C          THIS DIRECTIVE, IF THERE IS ONE.
C      10  THE NUMBER OF GROUPS FOR THE RECORD DEFINED BY THIS DIRECTIVE
C          IF THERE IS ONE.
C      11  THE RECORD TYPE DEFINED BY THIS DIRECTIVE.
C      12  THE COMMON BLOCK OFFSET FOR THE RECORD DEFINED BY THIS DIRECT
C      13  THE LIST TYPE FOR THE RECORD TO BE CREATED.
C      14  THE NUMBER OF WORDS OCCUPIED BY THE TITLE OF THIS RECORD.
C      15  THE NUMBER OF TIMES THE TITLE SHOULD BE PRINTED PER LINE.
C      16  THE RELATIVE ADDRESS IN RECORD TYPE 62 OF THE TITLE.
C      17  THE NUMBER OF WORDS OCCUPIED BY THE PRINT FORMAT FOR THE
C          PARAMETER KEYWORDS FOR THIS RECORD.
C      18  THE NUMBER OF TIMES THE PARAMETER KEYWORDS ARE TO BE PRINTED
C          PER LINE.
C      19  THE RELATIVE ADDRESS IN RECORD TYPE 62 OF THE PRINT FORMAT
C          FOR THE KEYWORDS FOR THIS RECORD.
C      20  THE NUMBER OF WORDS OCCUPIED BY THE PRINT FORMAT FOR THE
C          ELEMENTS OF THIS RECORD.
C      21  THE NUMBER OF GROUPS TO BE PRINTED PER LINE.
C      22  THE RELATIVE ADDRESS IN RECORD TYPE 62 OF THE PRINT FORMAT
C          FOR THE ELEMENTS IN THIS RECORD.
C      23  THE NUMBER OF WORDS OCCUPIED BY THE PUNCH FORMAT FOR THE
C          PARAMETER KEYWORDS FOR THIS RECORD.
C      24  THE NUMBER OF TIMES THE PARAMETER KEYWORDS ARE TO BE PUNCHED
C          PER LINE.
C      25  THE RELATIVE ADDRESS IN RECORD TYPE 62 OF THE PUNCH FORMAT
C          FOR THE KEYWORDS FOR THIS RECORD.
C      26  THE NUMBER OF WORDS OCCUPIED BY THE PUNCH FORMAT FOR THE
C          ELEMENTS OF THIS RECORD.
C      27  THE NUMBER OF GROUPS TO BE PUNCHED PER LINE.
C      28  THE RELATIVE ADDRESS IN RECORD TYPE 62 OF THE PUNCH FORMAT
C          FOR THE ELEMENTS IN THIS RECORD.
C      29  THE RELATIVE ADDRESS OF THE ENABLING DATA FOR THIS
C          DIRECTIVE.
C      30  THE NUMBER OF WORDS PER ENABLING DIRECTIVE.
C      31  THE NUMBER OF ENABLING DIRECTIVES.
C
C      THE BLOCK ABOVE IS REPEATED FOR EACH DIRECTIVE FOR THE CURRENT
C      '#' INSTRUCTION, AND ALL THE ADDRESSES ARE RELATIVE TO THE START
C      OF THE DATA STORED IN RECORD TYPE 62.
C
C  62  ASSOCIATED WITH EACH TYPE 61 RECORD IS A TYPE 62 RECORD, WHICH
C      CONTAINS DETAILS OF THE PARAMETERS FOR EACH DIRECTIVE. EACH
C      DIRECTIVE HAS A POINTER IN RECORD TYPE 61 INDICATING THE START
C      OF ITS PARAMETERS, WHICH ARE STORED SERIALLY AND
C      FORM THE FIRST PART OF THIS RECORD. THE REST OF THE
C      RECORD IS TAKEN WITH FURTHER DATA ADDRESSED VIA THE PARAMETER
C      INFORMATION. THE FORMAT OF AN ENTRY FOR A PARAMETER STARTS
C      WITH THE PARAMETER NAME AS FOLLOWS :
C
C      0  NAME 1, WORD 1.
C      1  NAME 1, WORD 2.
C
C      AFTER THE NAME, THE REST OF THE PARAMETER INFORMATION IS STORED,
C      ATTHE OFFSET GIVEN IN WORD 2 ABOVE, RELATIVE TO THE START OF THE
C      CURRENT PARAMETER. THE NUMBER OF WORDS OF ADDITIONAL DATA
C      IS GIVEN BY WORD 2 MINUS WORD 1 ABOVE.
C      THE FORMAT OF THE REST OF THE DATA FOR EACH PARAMETER IS :
C
C       0  PARAMETER TYPE ON INPUT :
C
C          +1  FIXED POINT NUMBER.
C          +2  FLOATING POINT NUMBER.
C          +3  CHARACTER STRING.
C          +4  STRING TO BE INTERPRETED BY THE CALLING ROUTINE.
C
C       1  RELATIVE ADDRESS OF THE PERMITTED VALUES FOR THIS PARAMETER
C          ON INPUT.
C       2  NUMBER OF WORDS PER PERMISSABLE VALUE.
C       3  NUMBER OF PERMISSABLE VALUES.
C       4  COMMON BLOCK OFFSET FOR THIS PARAMETER.
C       5  TYPE OF ARGUMENT TO BE STORED IN THE COMMON BLOCK. IF THE
C          NUMBER OF PERMISSABLE VALUES IS ZERO, WORD 5 IS SET EQUAL
C          TO WORD 0. IF PERMISSABLE VALUES ARE ALLOWED, WORD 5 IS SET T
C          1, INDICATING AN INTEGER WHICH CAN GIVE THE POSITION OF THE
C          FOUND PERMISSABLE VALUE.
C          NUMBER OF PERMISSABLE VALUES IS ZERO, WORD 5 MUST EQUAL WORD
C          0. IF THE NUMBER OF PERMISSABLE VALUES IS NOT ZERO, THE
C          VALUE FOUND MAY BE STORED (WORD 0 EQUALS WORD 5), OR
C          ANOTHER TYPE OF ARGUMENT MAY BE STORED. THE MOST COMMON
C          EXAMPLE OF THIS IS TO STORE AN INTEGER TO INDICATE THE
C          POSITION OF THE PERMISSABLE VALUE FOUND ON INPUT.
C          IN THIS CASE, WORD 0 WOULD BE 3 AND WORD 5 WOULD BE 1.
C       6  VALUE TO BE ASSIGNED IF THE FIRST PERMISSABLE VALUE
C          IS FOUND. THIS IS AN INTEGER, AND SUCCESSIVE PERMISSABLE
C          VALUES ARE INCREMENTED ACCORDINGLY FROM THIS VALUE.
C       7  DEFAULT INDICATOR :
C
C          -1  NO DEFAULT AVAILABLE.
C           0  DEFAULT VALUE STORED.
C
C       8  DEFAULT VALUE, TYPE GIVEN BY WORD 5.
C       9  NUMBER OF TIMES THIS PARAMETER MAY OCCUR.
C      10  THE NUMBER OF TIMES THIS PARAMETER HAS BEEN INPUT.
C
C      THE REST OF THE TYPE 62 RECORD IS DATA POINTED TO BY THE FIRST
C      PART OF THE RECORD.
C
C  63  THIS RECORD CONTAINS A LIST OF THE LISTS THAT THE '#' INSTRUCTION
C      REQUIRES. THE LISTS ARE STORED BY NUMBER, ONE AFTER THE OTHER.
C
C  64  THIS RECORD CONTAINS THE LOAD DETAILS, WHICH ARE SPECIFIC TO
C      EACH MACHINE. ON THE ICL 1906A, THE FORMAT IS :
C
C      0  THE INSTRUCTION NUMBER FOR THE GIVEN PROGRAM.
C      1  MINIMUM CORE SIZE REQUIRED.
C      2  WORD 1 OF THE FILE NAME TO 'CONT'.
C      3  WORD 2.
C
C--RECORD TYPE 50 IS STORED AS ABOVE, BUT AS EACH INSTRUCTION
C  REQUIRES A RECORD OF TYPE 60, 61, 62, 63 AND 64, THESE ARE STORED
C  WITH RECORD NUMBERS OF -(10000*N + M). 'N' IS THE NUMBER OF THE
C  CURRENT INSTRUCTION IN THE INPUT STREAM, AND M IS THE 60 VALUE.
C  THIS MEANS THAT ONLY RECORD 50 IS LOADED IMMEDIATELY, BUT THAT
C  POINTERS ARE SET UP TO THE REST.
C
C--
C
C
      CHARACTER CFORM*9, CFMRQ*6, CEND*3
      CHARACTER CIMAGE*80
\HEADES
\ISTORE
\ICOM50
C
\STORE
\XUNITS
\XSSVAL
\XCARDS
\XLST50
\XLISTI
\XCHARS
\XCONST
\XERVAL
\XLSVAL
\XIOBUF
C
\QSTORE
\QCOM50
C
C
C
      DATA CFORM / '(19A4,4X)'/
      DATA CFMRQ / '(20A4)'/, CEND / 'END' /
C
900   CONTINUE
C----- WE COULD COME BACK HERE AFTER AN ERROR - RESET FLAG
C--INITIAL SCAN  -  LAST CARD WAS OKAY
1000  CONTINUE
      I=-1
C--SET THE LIST FLAGS TO ZERO INITIALLY
      LSTOP=0
      LSTNO=0
      ITYPFL = 1
      INSTR = 0
      ICLASS=-1
      IDIRFL=-1
      IPARAM=-1
C--CHECK IF THE CURRENT CARD CONTAINS A '#INSTRUCTION' CARD
1050  CONTINUE
      IF(IHFLAG)1100,1150,1150
C--NO '#INSTRUCTION'  -  READ THE NEXT RECORD
1100  CONTINUE
      CALL XMONTR(I)
C--ALL SUBSEQUENT CARDS ARE IN ERROR
      I=0
      IF(KRDREC(I))1100,1050,1050
C--'#' CARD FOUND  -  CHECK FOR END OF FILE
1150  CONTINUE
      IF(IEOF)1100,1200,1200
C--'#INSTRUCTION' CARD FOUND  -  SET THE CHARACTER POINTERS
1200  CONTINUE
      NC=2
      ND=KEQUAL(NC,IB)
C--CLEAR THE ERROR INDICATORS
      IERFLG = 1
      LEF=0
      LSTLEF=LEF
C--CLEAR CORE
      CALL XCSAE
      CALL XRSL
C--LOAD PART OF LIST 50
      CALL XFAL50
C--SEARCH FOR THE FOUND '#INSTRUCTION' IN LIST 50
      ITYPFL=1
      INSTR=KCNXTS(MDR50-1,ISTORE(LR50),NR50,MDR50)
C--CHECK IF WE HAVE FOUND ANYTHING
      IF(INSTR)1250,1250,1350
C--ILLEGAL OR UNKNOWN INSTRUCTION
1250  CONTINUE
      CALL XMONTR(0)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1300)IH
      ENDIF
      WRITE(NCAWU,1300) IH
      WRITE ( CMON, 1300) IH
      CALL XPRVDU(NCEROR, 1,0)
1300  FORMAT(' Unknown or illegal ''',A1,
     2 'Instruction'' on the last card')
      CALL XERHND ( IERERR )
C -- CLEAR INDICATION OF INSTRUCTION, TO STOP LOOPING
      IHFLAG = -1
      GO TO 900
C--SUCCESS  -  CHECK FOR '#LIST', '#PRINT' OR '#PUNCH'
1350  CONTINUE
      LFL=LR52-1
      IF(INSTR-LSTOFF)1400,1400,1410
1410  CONTINUE
C----- CHECK FOR 'CONCEALED' LIST, EXCEPT SFLS
      I= INSTR - LSTOFF
      IF ((I .GT. 49) .OR. (I .EQ. 33)) GOTO 1700
      LSTNO = I
      LSTOP = 1
      ICLASS = -1
      GOTO 1700
C--THIS IS A LIST CALL  -  PROCESS THE LIST TYPE
1400  CONTINUE
      JB=LFL
      CALL XLL50R(INSTR)
      CALL XZEROF(IBUFF(1),4)
C--READ THE DIRECTIVE
      IF(KRDNDC(IBUFF(1),4)-1)1250,1450,1250
C--LOOP OVER THE INPUT PARAMETERS ON THIS DIRECTIVE
1450  CONTINUE
      DO 1550 I=1,NR62D
C--FIND THE PARAMETER
      IF(KFNDNP(I))1250,1550,1500
C--READ THE VALUE
1500  CONTINUE
      IF(KRDPV(IBUFF(1),4))1250,1550,1550
1550  CONTINUE
C--CHECK THAT THERE ARE NO MORE PARAMETERS ON THIS CARD
      IF(KCHKUP(IBUFF(1),4))1250,1600,1600
C--INSERT ANY NECESSARY DEFAULTS
1600  CONTINUE
      IF(KCHKPV(1,IBUFF(1),4,-1))1250,1650,1650
C--ALTER 'INSTR' TO REFLECT THIS CHANGE
1650  CONTINUE
      LSTOP=INSTR
      LSTNO=IBUFF(1)
      INSTR=IBUFF(1)+LSTOFF
C--RESET THE CORE LIMIT
      LFL=JB
C--SET THE CLASS TYPE
      ICLASS=IBUFF(2)
C -- CHECK THAT THE REQUESTED LIST NUMBER IS ALLOWED
      ISTAT = KLSCHK ( LSTNO , 0 , 0 , ILSCLN , ILSMSG , I , IERNOP )
      IF ( ISTAT .LE. 0 ) GO TO 1250
C--SUCCESS  -  LOAD THE DETAILS FOR THIS COMMAND
1700  CONTINUE
      CALL XLL50R(INSTR)
C--CHECK IF THERE IS A LIST OF LISTS TO BE USED
      IF(NR63)2800,2800,1750
C--LISTS TO BE USED ARE GIVEN  -  CHECK FOR ANY LIST GENERATION CALLS
1750  CONTINUE
      NLIST=0
      MR63=LR63
C--INDICATE THAT WE HAVE NOT EMPTIED THE SYSTEM REQUEST QUEUE
      KA=0
C--LOOP OVER THE LISTS TO BE USED FOR THIS '#INSTRUCTION'
      DO 2600 I=1,NR63
      MR52=LR52
C--CHECK AGAINST THOSE LISTS PROVIDED FOR INTERNAL GENERATION
      DO 2500 K=1,NR52
      IF(ISTORE(MR52)-ISTORE(MR63))2450,1800,2450
C--AGREEMENT  -  CHECK IF THE LIST EXISTS
1800  CONTINUE
      CALL XRLIND(ISTORE(MR52),NA,NB,NC,ND,NE,IBUFF(1))
      IF(NB)2200,2200,1850
C--CHECK THE WRITE/OVERWRITE STATUS
1850  CONTINUE
      IF(ND)2200,1900,2200
C--CHECK THE ERROR STATUS
1900  CONTINUE
      IF(NE)2200,1950,1950
C--LIST IS OKAY  -  FIND ITS INTERDEPENDENCIES RECORD
1950  CONTINUE
      IF(KFNDRI(ISTORE(MR52),1,IADDR,IBUFF))2550,2000,2000
C--RECORD FOUND  -  PRESERVE THE CORE LIMITS
2000  CONTINUE
      JA=NFL
      JB=LFL
C--MAKE SPACE FOR THE DATA IN THE RECORD
      KK=IBUFF(5)*IBUFF(6)
      L=KCHLFL(KK)
C--BRING DOWN THE DATA
      CALL XDOWNF(IBUFF(4),STORE(L),KK)
C--RESET THE CORE POINTERS
      NFL=JA
      LFL=JB
      N=IBUFF(5)
C--LOOP OVER EACH LIST TYPE FOR THIS ONE ON DISC
2050  CONTINUE
      IF(N)2450,2450,2100
C--READ THE DATA FOR THIS LIST
2100  CONTINUE
      CALL XRLIND(ISTORE(L),NA,NB,NC,ND,NE,IBUFF(1))
C--CHECK IF THIS LIST EXISTS
      IF(NB)2400,2400,2150
C--CHECK IF THE CURRENT VERSION IS THE ONE USED TO MAKE THIS LIST
2150  CONTINUE
      M=L+IBUFF(5)
      IF(IABS(NE)-ISTORE(M))2200,2400,2200
C--COMMAND TO BE ISSUED  -  CHECK IF THERE IS DATA IN THE S.R.Q.
2200  CONTINUE
      IF(NLIST)2250,2250,2350
C--WE HAVE NOT EMPTIED THE QUEUE YET  -  CHECK IF WE SHOULD
2250  CONTINUE
      IF(NREC)2350,2350,2300
C--EMPTY THE SYSTEM REQUEST QUEUE
2300  CONTINUE
      KA=NREC
      KB=20
      KC=KA*KB
C--ALLOCATE A BUFFER TO HOLD THE RECORDS
      KD=KCHLFL(KC)
C--READ THE RECORDS
      KC=KD+KC-1
      READ(NUSRQ,CFMRQ) (ISTORE(KE), KE=KD, KC)
C--SORT THE QUEUE OUT
      NREC=0
      IEOF=NREC
      IPOSRQ=0
      REWIND NUSRQ
C--NEW LIST IS REQUIRED OF THIS TYPE  -  ISSUE A COMMAND
2350  CONTINUE
      WRITE (CIMAGE, CFORM) (ISTORE(IZ), IZ= MR52+1, MR52+MDR52-2)
      CALL XISRC (CIMAGE)
C--ADD AN 'END' CARD
      CALL XISRC (CEND)
      NLIST=NLIST+1
      GOTO 2550
C--UPDATE FOR THE NEXT LIST STORED HERE
2400  CONTINUE
      L=L+1
      N=N-1
      GOTO 2050
C--UPDATE FOR THE NEXT LIST ON THE GENERATION STACK
2450  CONTINUE
      MR52=MR52+MDR52
2500  CONTINUE
C--UPDATE FOR THE NEXT LIST TO BE USED BY THIS '#INSTRUCTION'
2550  CONTINUE
      MR63=MR63+MDR63
2600  CONTINUE
C--CHECK IF ANY REQUEST HAVE BEEN ISSUED
      IF(NLIST)2800,2800,2650
C--PROCESS SOME MORE REQUESTS
2650  CONTINUE
      I=KPSRQ(1)
C--CHECK IF WE MUST ADD THE REQUESTS WE HAVE STORED IN CORE
      IF(KA)1000,1000,2700
C--LOOP OVER EACH REQUEST
2700  CONTINUE
      DO 2750 I=1,KA
      WRITE(CIMAGE,CFMRQ) (ISTORE(IZ), IZ= KD, KD+KB-1)
      CALL XISRC (CIMAGE)
      KD=KD+KB
2750  CONTINUE
      GOTO 1000
C--CLEAR CORE AND RELOAD THE DETAILS FOR THIS COMMAND
2800  CONTINUE
      CALL XRSL
      CALL XCSAE
      CALL XLL50R(INSTR)
C--ASSIGN THE RETURN VALUES
      KFNHF=ISTORE(LR64)
C--RESET THE DIRECTIVE POINTERS
      IDIRFL=-1
      IPARAM=-1
      IPARAD=NOWT
      RETURN
      END
C
CODE FOR KRDDPV
      FUNCTION KRDDPV(ICOMMN,IDIMN)
C--THIS ROUTINE READS A SET OF DIRECTIVES, TOGETHER WITH THE PARAMETERS
C  OFF THE DIRECTIVE CARDS.
C
C  ICOMMN  THE COMMON BLOCK FOR THIS INPUT OPERATION.
C  IDIMN    THE DIMENSION OF THE COMMON BLOCK.
C----- IDIM SET IN XRDLN, CURRENTLY TO 512
C
C--RETURN VALUES OF 'KRDDPV' ARE :
C
C  -1  ERRORS.
C   0  ALL PROCESSED OKAY.
C
C--
C
      DIMENSION ICOMMN(IDIMN)
C
\XUNITS
\XSSVAL
\XLISTI
\XERVAL
\XIOBUF
C
C--ZERO THE COMMON BLOCK INITIALLY
      CALL XZEROF(ICOMMN,IDIMN)
C--READ THE NEXT DIRECTIVE
1000  CONTINUE
      IF(KRDNDC(ICOMMN,IDIMN))1250,1050,1050
C--FIND THE NEXT PARAMETER
1050  CONTINUE
      IDWZAP = 0
      IF(KFNDNP(IDWZAP))1000,1000,1100
C--READ THE PARAMETER VALUE
1100  CONTINUE
      IF(KRDPV(ICOMMN,IDIMN))1000,1050,1150
C--STRING FOR INTERPRETATION  -  NOT BY US!
1150  CONTINUE
      CALL XMONTR(0)
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1200)
      ENDIF
      WRITE(NCAWU,1200)
      WRITE ( CMON, 1200)
      CALL XPRVDU(NCEROR, 1,0)
1200  FORMAT(' Parameter type is illegal for ''KRDDPV''')
      CALL XERHND ( IERPRG )
C--END OF THE DATA  -  CHECK FOR ERRORS
1250  CONTINUE
      KRDDPV=0
      IF(LEF)1300,1350,1300
C--ERRORS FOUND
1300  CONTINUE
      KRDDPV=-1
1350  CONTINUE
      RETURN
      END
C
CODE FOR KRDNDC
      FUNCTION KRDNDC(ICOMMN,IDIMN)
C--READ THE NEXT DIRECTIVE CARD.
C
C  ICOMMN  THE DATA OR COMMON BLOCK AREA BEING SET UP FOR THIS
C          INSTRUCTION.
C  IDIMN    THE SIZE OF 'ICOMMN'.
C
C--THE COMMON BLOCK 'XCARDS' IS USED BY THIS AND OTHER ROUTINES
C  FOR CARD I/O CONTROL. THE VARIABLES ARE :
C
C  IMAGE   THE INPUT CARD BUFFER.
C  NC      THE CURRENT PROCESSING POSITION IN 'IMAGE'.
C  ND      EITHER 'NC' OR THE END OF THE CURRENT INFORMATION TO BE
C          PROCESSED IN 'IMAGE'.
C  LASTCH  THE LAST CHARACTER ON THE CURRENT INPUT RECORD TO BE USED.
C  NI      THE NUMBER OF THE CURRENT INPUT CARD.
C  NILAST  THE NUMBER OF THE CARD FOR THE LAST '#INSTRUCTION' FOUND.
C  NS      THE INCREMENT BETWEEN SUCCESSIVE INPUT RECORDS. THIS IS ONE
C          FOR DATA FROM THE USER AND 10000 FOR DATA ON THE SYSTEM
C          REQUEST QUEUE.
C  MON     THE NUMBER OF THE LAST CARD PRINTED BY 'XMONTR'.
C  ICAT    THE TYPE OF LISTING REQUEST FOR THE CARDS THAT ARE
C          PROCESSED. THIS VARIABLE IS USED BY 'XMONTR'.
C  IEOF    END OF FILE AND SYSTEM REQUEST QUEUE FLAG :
C
C          -1  LAST STATEMENT READ END OF FILE, AND THUS THE NEXT WILL
C              CALL WILL FAIL THE JOB.
C           0  NORMAL READING FROM THE CONTROL STREAM.
C          >0  READING FROM THE SYSTEM REQUEST QUEUE.
C
C  IHFLAG  THIS VARIABLE INDICATES WHETHER THE LAST CARD CONTAINED
C          A '#INSTRUCTION' WHICH HAS NOT YET BEEN PROCESSE :
C
C          -1  NO '#INSTRUCTION' ON THE LAST CARD.
C           0  UNPROCESSED '#INSTRUCTION' ON THE LAST CARD.
C          +1    PROCESSED '#INSTRUCTION' ON THE LAST CARD.
C
C  NUSRQ   THE UNIT TO BE USED FOR THE SYSTEM REQUEST QUEUE.
C  NREC    THE NUMBER OF REQUESTS OUTSTANDING ON THE SYSTEM REQUEST
C          QUEUE.
C  IPOSRQ  THE CURRENT POSITION OF THE REQUEST QUEUE.
C  ITYPFL  THIS VARIBLE INDICATES THE TYPE OF KEYWORD BEING PROCESSED
C          AT PRESENT :
C
C          1  INSTRUCTION.
C          2  DIRECTIVE.
C          3  PARAMETER.
C          4  REQUIRED INPUT VALUE.
C
C  INSTR   THE NUMBER OF THE CURRENT INSTRUCTION.
C  IDIRFL  THIS CONTAINS THE NUMBER OF THE CURRENT DIRECTIVE, OR
C          -1  IF NO DIRECTIVE IS BEING PROCESSED.
C  IPARAM  THIS CONTAINS THE NUMBER OF THE CURRENT PARAMETER, OR
C          -1  IF NO PARAMETER IS BEING PROCESSED.
C  IPARAD  THIS CONTAINS THE ADDRESS OF THE CURRENT GROUP IN THE
C          DATA AREA FOR THE CURRENT DIRECTIVE OR 'NOWT'.
C
C--RETURN VALUES OF 'KRDNDC' ARE :
C
C  -1  END OF DIRECTIVES FOR THIS '#INSTRUCTION'
C   0  CONTINUATION CARD.
C  >0  THE DIRECTIVE FOUND.
C
C--THIS ROUTINE EXPECTS THAT TYPE 60 RECORDS WILL ALREADY BE
C  LOADED.
C
C--
\ICOM50
\ISTORE
C
C
      DIMENSION ICOMMN(IDIMN)
C
\STORE
\XLST50
\XCARDS
\XCONST
\XUNITS
\XSSVAL
\XCHARS
\XSYSHF
\XSYSDR
\XLISTI
\XIOBUF
C
\QSTORE
\QCOM50
C
C--PRESERVE THE PARAMETER POINTERS
      JPARAM=IPARAM
      JPARAD=IPARAD
C--INDICATE THAT NO PARAMETERS ARE BEING PROCESSED
      IPARAM=-1
      IPARAD=NOWT
C--SET THE TYPE OF CHARACTER STRING WE ARE SEARCHING FOR
      ITYPFL=2
C--CHECK IF WE ARE PROCESSING A '#INSTRUCTION' CARD STILL
      IF(IHFLAG)1100,1000,1000
C--'#INSTRUCTION' CARD  -  CHECK FOR THE NAME AMONGST THE DIRECTIVES
1000  CONTINUE
      IHFLAG=-1
      IF(NR60)1100,1100,1050
C--SOME TO USE  -  MAKE THE COMPARISON
1050  CONTINUE
      NC=2
      ND=KEQUAL(NC,IB)
      NUM=KCNXTS(MDR60-1,ISTORE(LR60),NR60,MDR60)
C--CHECK THE REPLY
      NC=ND
      IF(NUM)1100,1100,1850
C--END OF THE LAST CARD  -  CHECK FOR UNACCESSED PARAMETERS
1100  CONTINUE
      IF(KCHKUP(ICOMMN,IDIMN))1300,1150,1150
C--READ THE NEXT CARD FROM THE APPROPIATE STREAM
1150  CONTINUE
C&RIC{
      I=0
C&RIC}
      IF(KRDREC(I))2600,1200,2600
C--THIS IS A NORMAL CARD WITHOUT A '#' IN COLUMN ONE
1200  CONTINUE
      IF(IMAGE(1).NE.IB)GOTO 1350
C--THIS CARD HAS NOTHING IN COLUMN ONE  -  THIS IS AN ERROR
      I=KCHKPV(IDIRFL,ICOMMN,IDIMN,1)
C--NOW PRINT SOME ERROR MESSAGE
      CALL XMONTR(0)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1250)
      ENDIF
      WRITE(NCAWU,1250)
      WRITE ( CMON, 1250)
      CALL XPRVDU(NCEROR, 1,0)
1250  FORMAT(' The user directive has been omitted',
     2 ' or does not begin in column one')
C--GENERAL ERROR AREA
1300  CONTINUE
      LEF=LEF+1
      IDIRFL=-1
      CALL XMONTR(0)
      GOTO 1150
C--FIND THE NEXT BLANK TO TERMINATE THE USER DIRECTIVE
1350  CONTINUE
      ND=KEQUAL(NC,IB)
C--CHECK FOR SYSTEM DEFINED DIRECTIVE
      I=KCNXTS(NWSPD,ISPD,NSPD,LSPD)
C--CHECK THE REPLY
      IF(I)1150,1700,1400
C--SUCCESS  -  CHECK THAT THERE IS NOT AN IDENTITY CLASH
1400  CONTINUE
      NC=1
      IF(NR60)1500,1500,1420
1420  CONTINUE
      IF(KCNXTS(MDR60-1,ISTORE(LR60),NR60,MDR60))1150,1500,1450
C--DIRECTIVE NAME CLASH  -  ERROR
1450  CONTINUE
      I=KCHKPV(IDIRFL,ICOMMN,IDIMN,1)
      CALL XMDCS
      GOTO 1150
C--A SYSTEM DEFINED DIRECTIVE HAS BEEN FOUND  -  BRANCH ON ITS TYPE
1500  CONTINUE
      IF(I-1)1550,1550,2600
C--THIS IS A 'CONTINUE' DIRECTIVE  -  CHECK FOR A DIRECTIVE
1550  CONTINUE
      IF(IDIRFL)1300,1600,1600
C--DIRECTIVE OKAY  -  CARRY ON
1600  CONTINUE
      KRDNDC=0
      IPARAM=JPARAM
      IPARAD=JPARAD
C--RESET THE CURRENT POSITION
1650  CONTINUE
      NC=ND
      RETURN
C
1700  CONTINUE
C -- NOT A SYSTEM DIRECTIVE. CHECK FOR A DIRECTIVE FROM THE COMMAND
C    FILE, IF THERE ARE ANY
      IF ( NR60 .LE. 0 ) GO TO 1750
      NUM=KCNXTS(MDR60-1,ISTORE(LR60),NR60,MDR60)
      IF(NUM)1150,1750,1850
C--NOT A USER DIRECTIVE EITHER  -  PRINT AN ERROR MESSAGE
1750  CONTINUE
      I=KCHKPV(IDIRFL,ICOMMN,IDIMN,1)
      CALL XMONTR(0)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1800)IH
      ENDIF
      WRITE ( NCAWU,1800 ) IH
      WRITE ( CMON, 1800) IH
      CALL XPRVDU(NCEROR, 1,0)
1800  FORMAT(' The directive on the last card is illegal',
     2 ' with this ''',A1,'Instruction''')
      GOTO 1300
C--ENSURE THAT THE LAST USER DIRECTIVE TERMINATED OKAY
1850  CONTINUE
      I=KCHKPV(IDIRFL,ICOMMN,IDIMN,1)
C--SET UP THE REST OF THE POINTERS FOR THIS DIRECTIVE
      CALL XDIRFL(NUM,ICOMMN,IDIMN)
      IDIRFL=NUM
C--CHECK IF THIS DIRECTIVE HAS BEEN ENABLED
      IF(KINCLD(ICOMMN,IDIMN))1900,2000,2000
C--THIS DIRECTIVE HAS NOT BEEN ENABLED FOR INPUT FOR CREATION
1900  CONTINUE
      CALL XMONTR(0)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1950)
      ENDIF
      WRITE ( NCAWU,1950 )
      WRITE ( CMON, 1950)
      CALL XPRVDU(NCEROR, 2,0)
1950  FORMAT(' At least one other directive or parameter',
     2 ' has been omitted'/' The directive above',
     3 ' cannot be processed')
      GOTO 1300
C--CREATE ANY DATA AREAS THAT ARE REQUIRED
2000  CONTINUE
      IF(KCDRFI(ICOMMN,IDIMN,-1))1150,2050,2050
C--CHECK IF THIS DIRECTIVE IS VALID HERE
2050  CONTINUE
      IF(ISTORE(MR61+6))2100,2200,2200
C--THIS DIRECTIVE HAS BEEN DISALLOWED BY ANOTHER DIRECTIVE
2100  CONTINUE
      J=LR60+(IABS(ISTORE(MR61+6))-1)*MDR60
      K=J+MDR60-2
      CALL XMONTR(0)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2150)(STORE(I+1),I=J,K)
      ENDIF
      WRITE(NCAWU,2150) (STORE(I+1),I=J,K)
      WRITE ( CMON, 2300)
      CALL XPRVDU(NCEROR, 1,0)
2300  FORMAT(' The last directive should have appeared before',
     2 ' and will be ignored here')
      GOTO 1300
C--CHECK IF THIS DIRECTIVE CAN BE INPUT HERE
2200  CONTINUE
      IF(ISTORE(MR61+8))2250,2350,2350
C--NOT ALLOWED ANY MORE
2250  CONTINUE
      CALL XMONTR(0)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2300)
      ENDIF
      WRITE(NCAWU,2300)
      WRITE ( CMON, 2150) (STORE(I+1),I=J,K)
      CALL XPRVDU(NCEROR, 2,0)
2150  FORMAT(' The directive above may not follow',
     2 ' a card containing the directive : '/40A1)
      GOTO 1300
C--CHECK IF THIS DIRECTIVE HAS ALREADY BEEN DEFAULTED
2350  CONTINUE
      IF(ISTORE(MR61+8)-1000000)2400,2400,2250
C--CHECK IF THIS DIRECTIVE HAS BEEN REPEATED TOO MANY TIMES
2400  CONTINUE
      ISTORE(MR61+8)=ISTORE(MR61+8)+1
      IF(ISTORE(MR61+7)-ISTORE(MR61+8))2450,2550,2550
C--THIS DIRECTIVE HAS APPEARED TOO MANY TIMES
2450  CONTINUE
      CALL XMONTR(0)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2500)
      ENDIF
      WRITE ( NCAWU,2500 )
      WRITE ( CMON, 2500)
      CALL XPRVDU(NCEROR, 2,0)
2500  FORMAT(' The last directive has appeared too many times,',
     2 /' or should not have appeared at all')
C -- MARK DIRECTIVE AS BEING IN ERROR
      ISTORE(MR61+8) = -1
      GOTO 1300
C--CHECK IF THIS DIRECTIVE EXCLUDES ANY OTHER DIRECTIVES
2550  CONTINUE
      CALL XCLUDE(NUM)
C--SET THE RETURN VALUES AT THIS POINT
      KRDNDC=NUM
C--SET THE POINTERS UP AGAIN FOR THE BENEFIT OF THE DATA RECORD POINTER
      CALL XDIRFL(IDIRFL,ICOMMN,IDIMN)
C--ZERO THE PARAMETER REPEAT COUNTS IF NECESSARY
      CALL XZROPC
      GOTO 1650
C
C--'#INSTRUCTION' OR 'END' DIRECTIVE  -  CHECK THE LAST IF NECCESSARY
2600  CONTINUE
      I=KCHKPV(IDIRFL,ICOMMN,IDIMN,1)
C--CHECK IF THERE IS AN 'END' CARD TO PRINT
      IF(IHFLAG)2650,2700,2700
C--PRINT THE LAST CARD
2650  CONTINUE
      CALL XMONTR(-1)
C--CHECK IF THERE ARE ANY DIRECTIVES FOR THIS INSTRUCTION
2700  CONTINUE
      IF(NR60)3450,3450,2750
C--LOOP OVER EACH DIRECTIVE, CHECKING IF IT HAS BEEN INPUT
2750  CONTINUE
      DO 3400 I=1,NR60
      CALL XDIRFL(I,ICOMMN,IDIMN)
      IDIRFL=I
C--CHECK IF THIS DIRECTIVE HAS BEEN INPUT
      IF(ISTORE(MR61+8))3400,2950,2800
C--DIRECTIVE INPUT  -  CHECK IF IT DEFINED A DATA RECORD
2800  CONTINUE
      IF(ISTORE(MR61+11))3400,3400,2850
C--RECORD DEFINED  -  CHECK IF ALL THE DATA HAS BEEN INPUT
2850  CONTINUE
      IF(ISTORE(MR61+7)-ISTORE(MR61+8))2900,3400,2900
C--ALL THE DATA IS NOT THERE  -  SET UP SOME DEFAULTS
2900  CONTINUE
      ISTORE(MR61+8)=ISTORE(MR61+8)+1
      GOTO 3100
C--CREATE ANY ASSOCIATED DATA AREAS
2950  CONTINUE
      IF(KINCLD(ICOMMN,IDIMN))3400,3000,3000
C--AND NOW THE DATA RECORD
3000  CONTINUE
      IF(KCDRFI(ICOMMN,IDIMN,0))3400,3050,3050
C--SET UP THE NUMBER OF PASSES
3050  CONTINUE
      ISTORE(MR61+8)=1
C--EXCLUDE ANY DIRECTIVES FOR THIS ONE
      CALL XCLUDE(I)
C--NOW SET UP THE DEFAULTS FOR ONE GROUP
3100  CONTINUE
      CALL XZROPC
      IF(KCHKPV(I,ICOMMN,IDIMN,0))3400,3150,3150
C--CHECK IF THIS DIRECTIVE DEFINED A DATA RECORD
3150  CONTINUE
      IF(ISTORE(MR61+11))3400,3400,3200
C--DATA RECORD IN CORE  -  CHECK IF ALL THE GROUPS HAVE BEEN SET
3200  CONTINUE
      N=ISTORE(MR61+7)-ISTORE(MR61+8)
      IF(N)3400,3400,3250
C--CHECK IF THERE ANY PARAMETERS FROM WHICH TO FIND DEFAULTS
3250  CONTINUE
      IF(NR62D)3400,3400,3300
C--SET UP THE REST OF THE GROUPS IN THE RECORD
3300  CONTINUE
      L=IPARAD
      DO 3350 J=1,N
      L=L+ISTORE(MR61+9)
      CALL XMOVE(STORE(IPARAD),STORE(L),ISTORE(MR61+9))
3350  CONTINUE
3400  CONTINUE
C--INDICATE END OF DIRECTIVES FOR THIS '#INSTRUCTION'
3450  CONTINUE
      KRDNDC=-1
      IDIRFL=-1
      GOTO 1650
      END
C
CODE FOR KCHKUP
      FUNCTION KCHKUP(ICOMMN,IDIMN)
C--CHECK THE LAST DIRECTIVE FOR UNACCESSED PARAMETERS
C
C  ICOMMN  THE COMMON BLOCK FOR TIS INPUT.
C  IDIMN    THE DIMENSION OF THE COMON BLOCK.
C
C--THIS ROUTINE RETURNS VALUES OF :
C
C  -1  THE LAST CARD CONTAINED UNACCESSED PARAMETERS.
C   0  THE LAST CARD WAS PROCESSED CORRECTLY
C
C--
C
      DIMENSION ICOMMN(IDIMN)
C
\XCHARS
\XCARDS
\XUNITS
\XSSVAL
\XLISTI
\XIOBUF
C
C--SET AN OKAY RETURN VALUE
      KCHKUP=0
C--CHECK IF THE LAST CARD CONTAINS A DIRECTIVE
      IF(IDIRFL)1000,1000,1050
1000  CONTINUE
      RETURN
C--DIRECTIVE TO LOOK AT
1050  CONTINUE
      NC=KNEQUL(NC,IB)
      IF(NC)1000,1000,1100
C--UNACCESSED PARAMETERS
1100  CONTINUE
      CALL XMONTR(0)
      J=NC-1
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1150)J
      ENDIF
      WRITE(NCAWU,1150)J
      WRITE ( CMON, 1150) J
      CALL XPRVDU(NCEROR, 1,0)
1150  FORMAT(' The last card contains',
     2 ' unaccessed parameter(s) beyond column ',I4)
C--NOW CHECK THE LAST RECORD INPUT
      I=KCHKPV(IDIRFL,ICOMMN,IDIMN,-1)
      IDIRFL=-1
      LEF=LEF+1
      KCHKUP=-1
      GOTO 1000
      END
C
CODE FOR XCLUDE
      SUBROUTINE XCLUDE(NUM)
C--CHECK IF THIS DIRECTIVE EXCLUDES ANY OTHER DIRECTIVES
C
C  NUM     THE NUMBER OF THE DIRECTIVE TO EXCLUDE.
C
C--THIS ROUTINE EXPECTS THE LIST 50 POINTERS TO BE SET UP.
C
C--
\ISTORE
C
\STORE
\XLST50
C
\QSTORE
C
C--CHECK IF THIS DIRECTIVE EXCLUDES ANY OTHER DIRECTIVES
      IF(ISTORE(MR61+6))1100,1100,1000
C--MARK THE DIRECTIVES TO BE EXCLUDED
1000  CONTINUE
      J=ISTORE(MR61+4)+LR62
      N=ISTORE(MR61+6)
C--LOOP OVER EACH DIRECTIVE TO BE EXCLUDED
      DO 1050 I=1,N
      K=LR61+(ISTORE(J)-1)*MDR61
      ISTORE(K+6)=-NUM
      J=J+ISTORE(MR61+5)
1050  CONTINUE
C--AND NOW RETURN
1100  CONTINUE
      RETURN
      END
C
CODE FOR KINCLD
      FUNCTION KINCLD(ICOMMN,IDIMN)
C -- CHECK IF THE CURRENT DIRECTIVE HAS BEEN ENABLED
C
C  ICOMMN  THE CURRENT COMMON BLOCK.
C  IDIMN    THE DIMENSION OF THE COMMON BLOCK.
C
C--RETURN VALUES ARE :
C
C  -1  THIS DIRECTIVE REQUIRES OTHER DIRECTIVES BEFORE IT CAN INCLUDED,
C      AND THESE HAVE NOT YET BEEN GIVEN.
C   0  ALL OKAY TO INCLUDE THIS DIRECTIVE.
C
C--
\ISTORE
C
C
      DIMENSION ICOMMN(IDIMN)
C
\STORE
\XLST50
C
\QSTORE
C
C--ASSIGN THE INITIAL OKAY RETURN VALUE
      KINCLD=0
C--CHECK IF THIS DIRECTIVE DEFINES A DATA RECORD
C--CHECK IF THERE ARE ANY ENABLING DIRECTIVES FOR THIS DIRECTIVE
      IF(ISTORE(MR61+31))1500,1500,1050
C--THERE ARE ENABLING DIRECTIVES GIVEN  -  LOOP OVER THEM
1050  CONTINUE
      N=ISTORE(MR61+31)
      M=ISTORE(MR61+29)+LR62
      DO 1450 I=1,N
C--COMPUTE THE ADDRESS OF THE CURRENT DIRECTIVE
      L=LR61+(ISTORE(M)-1)*MDR61
C--CHECK IF THE GIVEN DIRECTIVE HAS BEEN INPUT
      IF(ISTORE(L+8))1400,1400,1100
C--THIS DIRECTIVE HAS BEEN INPUT  -  CHECK IF A PARAMETER VALUE IS REQUI
1100  CONTINUE
      IF(ISTORE(M+1))1150,1150,1200
C--NO VALUE IS REQUIRED  -  ALLOW THIS DIRECTIVE
1150  CONTINUE
      KINCLD=0
      GOTO 1500
C--A VALUE IS REQUIRED  -  CHECK THE PARAMETER VALUE GIVEN
1200  CONTINUE
      IF(ISTORE(M+1)-ISTORE(L+3))1250,1250,1400
C--CHECK IF WE ARE IN A DATA RECORD FOR THIS DIRECTIVE
1250  CONTINUE
      IF(ISTORE(L+11))1400,1300,1350
C--COMMON BLOCK DATA  -  FIND THE COMMON BLOCK ADDRESS
1300  CONTINUE
      K=LR62+ISTORE(L)+ISTORE(L+1)+(ISTORE(M+1)-1)*ISTORE(L+2)
      IF(KVALCM(ISTORE(K+4),ICOMMN,IDIMN)-ISTORE(M+2))1400,1150,1400
C--IN A DATA RECORD  -  HUNT FOR THE RECORD
1350  CONTINUE
      J=KHUNTR(ISTORE(L+13),ISTORE(L+11),IADDL,IADDR,IADDD,0)
      K=ISTORE(M+1)+IADDD
      IF(ISTORE(K-1)-ISTORE(M+2))1400,1150,1400
C--UPDATE FOR THE NEXT ENABLING DIRECTIVE
1400  CONTINUE
      M=M+ISTORE(MR61+30)
1450  CONTINUE
      KINCLD=-1
C--AND NOW RETURN
1500  CONTINUE
      RETURN
      END
C
CODE FOR XZROPC
      SUBROUTINE XZROPC
C--ZERO THE REPEAT COUNTS FOR THE PARAMETERS OF THE CURRENT DIRECTIVE
C
C--
\ISTORE
C
\STORE
\XLST50
C
\QSTORE
C
C--CHECK IF THERE ARE ANY PARAMETERS FOR THIS DIRECTIVE
      IF(NR62D)1100,1100,1000
C--THERE ARE SOME PARAMETERS  -  ZERO THEIR INPUT COUNTS
1000  CONTINUE
      MR62D=LR62D
C--PASS OVER EACH PARAMETER
      DO 1050 I=1,NR62D
      ISTORE(MR62D+10)=0
      MR62D=MR62D+MDR62D
1050  CONTINUE
1100  CONTINUE
      RETURN
      END
C
CODE FOR KFNDNP
      FUNCTION KFNDNP(IN)
C--THIS FUNCTION FINDS THE NEXT PARAMETER ON A DIRECTIVE CARD
C
C  IN  A DUMMY ARGUMENT.
C
C--RETURN VALUES OF 'KFNDNP' ARE :
C
C  -1  NO MATCH OR ANY OTHER TYPE OF ERROR.
C   0  END OF CARD FOUND, OR THIS DIRECTIVE HAS NO PARAMETERS.
C  >0  THE PARAMETER THAT HAS BEEN FOUND.
C
C--THIS ROUTINE SETS 'IPARAM' AND THE POINTERS IN LIST 50 WHEN
C  A SUCCESSFUL FIND IS MADE.
C
C--
\ISTORE
C
\STORE
\XUNITS
\XSSVAL
\XCHARS
\XCARDS
\XLISTI
\XLST50
\XIOBUF
C
\QSTORE
C
      IDWZAP = IN
C--SET THE TYPE OF ARGUMENT FLAG
      ITYPFL=3
      KFNDNP=0
C--CHECK FOR SOME PARAMETERS TO SEARCH FOR
      IF(NR62D)1300,1300,1000
C--FIND THE NEXT NON-BLANK CHARACTER
1000  CONTINUE
      NC=KNEQUL(NC,IB)
C--CHECK FOR THE END OF THE CARD
      ND=NC
      IF(ND)1300,1300,1050
C--CHECK IF THE NEXT CHARACTER IS A BLANK
1050  CONTINUE
      IF(IMAGE(ND).EQ.IB)GOTO 1400
C--CHECK FOR A COMMA
      IF(IMAGE(ND).EQ.ICOMMA)GOTO 1500
C--CHECK FOR AN EQUALS SIGN TO TERMINATE THE PARAMETER KEYWORD
      NND=ND
      IF(IMAGE(ND).EQ.IEQUAL)GOTO 1100
C--UPDATE FOR THE NEXT CHARACTER
      ND=ND+1
C--CHECK FOR THE END OF THE CARD
      IF(ND-LASTCH)1050,1050,1500
C--EQUALS SIGN  -  SEARCH FOR THE KEYWORD
1100  CONTINUE
      IPARAM=KCNXTS(MDR62N-1,ISTORE(LR62N),NR62N,MDR62D)
C--CHECK FOR SUCCESS
      IF(IPARAM)1250,1150,1350
C--NO MATCH  -  ERROR MESSAGE
1150  CONTINUE
      CALL XMONTR(0)
      ND=ND-1
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1200)(IMAGE(I),I=NC,ND)
      ENDIF
      WRITE(NCAWU,1200) (IMAGE(I),I=NC,ND)
      WRITE ( CMON, 1200) (IMAGE(I),I=NC,ND)
      CALL XPRVDU(NCEROR, 2,0)
1200  FORMAT(' Unknown parameter keyword : ',/,1X, 80A1)
C--ERROR RETURN
1250  CONTINUE
      IDIRFL=-1
      LEF=LEF+1
      KFNDNP=-1
C--AND NOW RETURN
1300  CONTINUE
      RETURN
C--KEYWORD FOUND  -  UPDATE THE CHARACTER COUNT
1350  CONTINUE
      NC=NND+1
      NC=KNEQUL(NC,IB)
      GOTO 1550
C--BLANK FOUND  -  SEARCH FOR '=' AFTER IT
1400  CONTINUE
      NND=ND+1
      NND=KNEQUL(NND,IB)
      IF(NND)1500,1500,1450
C--ANOTHER CHARACTER  -  CHECK IT
1450  CONTINUE
      IF(IMAGE(NND).EQ.IEQUAL)GOTO 1100
C--CHARACTER FOUND THAT CANNOT BE PART OF A KEYWORD  -  THUS NO KEYWORD
1500  CONTINUE
      IPARAM=MIN0(IPARAM+1,NR62D)
C--SET UP THE POINTERS IN LIST 50
1550  CONTINUE
      I=(IPARAM-1)*MDR62D
      MR62D=LR62D+I
      MR62N=LR62N+I
C--UPDATE THE NUMBER OF TIMES WE HAVE FOUND THIS PARAMETER
      ISTORE(MR62D+10)=ISTORE(MR62D+10)+1
C--CHECK THAT WE HAVE NOT READ THIS TOO MANY TIMES
      IF(ISTORE(MR62D+10)-ISTORE(MR62D+9))1700,1700,1600
C--PARAMETER GIVEN TOO MANY TIMES
1600  CONTINUE
      CALL XMONTR(0)
      J=MR62N+MDR62N-2
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1650)IPARAM,(ISTORE(I+1),I=MR62N,J)
      ENDIF
      WRITE(NCAWU,1650)IPARAM,(ISTORE(I+1),I=MR62N,J)
      WRITE ( CMON, 1650) IPARAM,(ISTORE(I+1),I=MR62N,J)
      CALL XPRVDU(NCEROR, 2,0)
1650  FORMAT(' Parameter ',I5,'  has appeared too many times',
     2 /' Parameter keyword : ',40A1)
      GOTO 1250
C--ASSIGN THE RETURN VALUE
1700  CONTINUE
      KFNDNP=IPARAM
      GOTO 1300
      END
C
CODE FOR KRDPV
      FUNCTION KRDPV(ICOMMN,IDIMN)
C--THIS ROUTINE READS THE NEXT PARAMETER VALUE, WHICH SHOULD HAVE BEEN
\XIOBUF
C  FOUND BY 'KFNDNP'.
C
C  ICOMMN  THE COMMON BLOCK FOR THE CURRENT INPUT.
C  IDIMN    THE DIMENSION OF THE COMMON BLOCK.
C
C--RETURN VALUES OF 'KRDPV' ARE :
C
C  -1  ERROR.
C   0  PARAMETER READ OKAY.
C  +1  PARAMETER IS NOT A NUMBER OF SIMPLE CHARACTER STRING  -  MUST
C      READ BY THE CALLING ROUTINE.
C
C--
\ISTORE
C
C
      DIMENSION ICOMMN(IDIMN)
      DIMENSION AA(1)
C
\STORE
\XUNITS
\XSSVAL
\XCONST
\XCHARS
\XCARDS
\XLISTI
\XLST50
C
\QSTORE
C
C
      EQUIVALENCE (AA(1),A),(AA(1),IAA)
C
C--SET THE TYPE OF ARGUMENT WE ARE PROCESSING
      ITYPFL=4
C--CHECK IF THIS ROUTNE CAN PROCESS THE INPUT ARGUMENT VALUE
      KRDPV=1
      IF (ISTORE(MR62D) .EQ. 5) THEN
            GOTO 1000
      ENDIF
      IF(ISTORE(MR62D)-4)1000,1200,1200
C--VALUE CAN BE PROCESSED HERE  -  CHECK THAT THERE IS AN ARGUMENT
1000  CONTINUE
      ND=KNEQUL(NC,IB)
      IF(ND)1050,1050,1250
C--NO ARGUMENT  -  THIS IS AN ERROR
1050  CONTINUE
      CALL XMONTR(0)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1100)LASTCH
      ENDIF
      WRITE(NCAWU,1100)LASTCH
      WRITE ( CMON, 1100) LASTCH
      CALL XPRVDU(NCEROR, 1,0)
1100  FORMAT(' Missing parameter value at about column ',I4)
C--ERROR RETURN
1150  CONTINUE
      IDIRFL=-1
      LEF=LEF+1
      KRDPV=-1
C--AND NOW RETURN
1200  CONTINUE
      RETURN
C--CHECK THE TYPE OF ARGUMENT TO READ
1250  CONTINUE
      KRDPV=0
      NNC=NC
C----- CHECK NUMBER OR STRING
      IF(ISTORE(MR62D)-3)1300,2100,2100
C--NUMBER TO BE READ  -  INPUT IT
1300  CONTINUE
      IF(KINPUT(A))1350,1400,1350
C--ERROR DURING THE NUMBER
1350  CONTINUE
      CALL XSPCH
      GOTO 1150
C--CHECK IF WE ARE READING AN INTEGER OR FLOATING POINT NUMBER
1400  CONTINUE
      IF(ISTORE(MR62D)-1)1500,1450,1500
C--AN INTEGER
1450  CONTINUE
      IAA=NINT(A)
C--CHECK IF THERE ARE ANY PERMITTED VALUES FOR THIS ARGUMENT
1500  CONTINUE
      IF(ISTORE(MR62D+3))1950,1950,1550
C--CHECK THE ALLOWED VALUES
1550  CONTINUE
      N=ISTORE(MR62D+3)
      M=ISTORE(MR62D+1)+LR62
C--CHECK EACH VALUE IN TURN
      DO 1800 I=1,N
C--CHECK THE TYPE OF ARGUMENT
      IF(ISTORE(MR62D)-1)1600,1600,1700
C--AN INTEGER TO BE COMPARED
1600  CONTINUE
      IF(IAA-ISTORE(M))1750,1650,1750
C--A MATCH  -  SET THE POINTER
1650  CONTINUE
      IAA=I+ISTORE(MR62D+6)-1
      GOTO 1950
C--CHECK FOR FLOATING POINT MATCH
1700  CONTINUE
      IF(ABS(A-STORE(M))-ZERO)1650,1750,1750
C--UPDATE FOR THE NEXT PERMITTED  VALUE
1750  CONTINUE
      M=M+ISTORE(MR62D+2)
1800  CONTINUE
C--NO MATCH  -  THIS IS AN ERROR
1850  CONTINUE
      CALL XMONTR(0)
      J=MR62N+MDR62N-2
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1900)NNC,(ISTORE(I+1),I=MR62N,J)
      ENDIF
      WRITE(NCAWU,1900) NNC,(ISTORE(I+1),I=MR62N,J)
      WRITE ( CMON, 1900) NNC,(ISTORE(I+1),I=MR62N,J)
      CALL XPRVDU(NCEROR, 2,0)
1900  FORMAT(' Value provided at about column ',I4,
     2 '  is not one of those expected.'/' Parameter keyword : ',20A1)
      GOTO 1150
C--CHECK IF THIS VALUE IS TO BE STORED IN A DATA RECORD
1950  CONTINUE
      IF(ISTORE(MR61+11))2000,2050,2000
C--TO BE STORED IN A DATA RECORD
2000  CONTINUE
      J=IPARAD+IPARAM
      CALL XMOVE(AA(1),STORE(J-1),1)
      GOTO 1200
C--TO BE STORED IN THE COMMON BLOCK  -  CHECK THE ADDRESS
2050  CONTINUE
      J=ISTORE(MR62D+4)
      K=KVALCM(J,ICOMMN,IDIMN)
      CALL XMOVEI (IAA,ICOMMN(J),1)
      GOTO 1200
C--CHARACTER STRING TO BE READ  -  SEARCH FOR THE NEXT BLANK
2100  CONTINUE
      IF (ISTORE(MR62D ) .EQ. 5) THEN
C----- LONG TEXT STRING - GET UP TO 4 CHARACTERS, INCLUDING BLANK
        I = MIN0( NC, LASTCH)
        J = MIN0( NC+4, LASTCH)
        ND = J
        IF ( J .EQ. I) GOTO 1350
C----- PACK THE CHARACTERS
        CALL XFA4CS(IMAGE(NC),AA(1),MIN0(4,ND-NC))
C----- UPDATE POINTERS
        NC = ND
        GOTO 1950
      ENDIF
      I=KEQUAL(NC,IB)
C--CHECK FOR END OF CARD
      IF(I)2150,2150,2200
C--ADJUST FOR END OF CARD
2150  CONTINUE
      I=LASTCH
C--SEARCH FOR THE NEXT COMMA
2200  CONTINUE
      J=KEQUAL(NC,ICOMMA)
C--CHECK FOR END OF CARD
      IF(J)2250,2250,2300
C--ADJUST FOR END OF CARD
2250  CONTINUE
      J=LASTCH
C--COMPUTE THE PARAMETER VALUE LENGTH
2300  CONTINUE
      ND=MIN0(I,J)
      IF(ND)1350,1350,2310
C--CHECK FOR SOME ALLOWED VALUES
2310  CONTINUE
      IF(ISTORE(MR62D+3))2350,2350,2450
C--STRING ITELF IS REQUIRED  -  PACK THE CHARACTERS UP
2350  CONTINUE
      CALL XFA4CS(IMAGE(NC),AA(1),MIN0(4,ND-NC))
C--UPDATE THE POINTER
2400  CONTINUE
      NC=ND+1
      GOTO 1950
C--PERMITTED VALUE TO BE FOUND
2450  CONTINUE
      J=LR62+ISTORE(MR62D+1)
      I=KCNXTS(ISTORE(MR62D+2)-1,ISTORE(J),ISTORE(MR62D+3),
     2 ISTORE(MR62D+2))
C--CHECK FOR SUCCESS
      IF(I)1150,1850,2500
C--SUCCESS  -  COMPUTE THE STORED VALUE
2500  CONTINUE
      IAA=I+ISTORE(MR62D+6)-1
      GOTO 2400
      END
C
CODE FOR KCDRFI
      FUNCTION KCDRFI(ICOMMN,IDIMN,ITYPE)
C--THIS ROUTINE CREATES A DATA RECORD SUITABLE FOR INPUT,
C  AND THEN SETS UP THE DATA RECORD REPEAT COUNT AREA.
C
C  ICOMMN  THE COMMON BLOCK BEING USED.
C  IDIMN    THE DIMENSION OF 'ICOMMN'.
C  ITYPE   SOURCE OF DATA FLAG :
C
C          -1  DATA HAS JUST BEEN INPUT FROM CARDS FOR THIS DIRECTIVE.
C           0  NO DATA HAS BEEN INPUT  -  CHECK NO DEFAULTS ARE MISSING.
C          +1  DATA CONTEXT IS ALREADY KNOWN  -  NO OUTPUT REQUIRED FOR
C
C--RETURN VALUES OF 'KCDRFI' ARE :
C
C  -1  ERRORS FOUND.
C   0  ALL OKAY.
C
C--THIS ROUTINE EXPECTS THE POINTERS SET UP BY 'XDIRFL' TO BE
C  CORRECT.
C
C--
\ISTORE
\ICOM50
C
C
      DIMENSION ICOMMN(IDIMN)
C
\STORE
\XLST50
\XLISTI
\XUNITS
\XSSVAL
\XCARDS
\XCHARS
\XCONST
\XIOBUF
C
\QSTORE
\QCOM50
C
C--SET AN INITIAL RETURN VALUE
      KCDRFI=0
C--CHECK IF THE DIRECTIVE FOUND USES A DATA RECORD
      IF(ISTORE(MR61+11))1000,1100,1000
C--DATA RECORD USED  -  CHECK IF THIS IS THE FIRST TIME FOR THIS RECORD
1000  CONTINUE
      IF(ISTORE(MR61+8))1100,1150,1100
C--ERROR  -  RECORD CANNOT BE SET UP
1050  CONTINUE
      KCDRFI=-1
1100  CONTINUE
      RETURN
C--FIND THE NUMBER OF ELEMENTS PER REPEAT GROUP
1150  CONTINUE
      IF(KINVAL(ISTORE(MR61+9),I,ICOMMN,IDIMN))1200,1400,1400
C--ERROR IN FINDING THIS PARAMETER
1200  CONTINUE
      IF(ITYPE)1250,1350,1350
C--CARD INPUT  -  PRINT THE CARD AND AN ERROR MESSAGE
1250  CONTINUE
      CALL XMONTR(0)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1300)
      ENDIF
      WRITE ( CMON, 1300 )
      CALL XPRVDU(NCEROR, 1,0)
1300  FORMAT(' Previous errors prevent processing',
     2 ' of the last directive')
1350  CONTINUE
      IDIRFL=-1
      LEF=LEF+1
      GOTO 1050
C--FIND THE NUMBER OF GROUPS
1400  CONTINUE
      IF(KINVAL(ISTORE(MR61+10),J,ICOMMN,IDIMN))1200,1450,1450
C--PARAMETERS FOUND  -  SET THE REPEAT COUNT FOR THE DIRECTIVE
1450  CONTINUE
      ISTORE(MR61+7)=J
C--SET THE GROUP PARAMETERS
      ISTORE(MR61+9)=I
      ISTORE(MR61+10)=J
      K=J
C--CHECK IF WE SHOULD CREATE A DATA AREA
      IF(ISTORE(MR61+11))1500,1550,1550
C--NO DATA AREA REQUIRED
1500  CONTINUE
      K=0
C--CREATE THE DATA RECORD AND UPDATE ITS PROPERTIES
1550  CONTINUE
      L=KCEDR(ISTORE(MR61+13),1,ISTORE(MR61+11),I,K,ISTORE(MR61+12))
      CALL XUDRH(ISTORE(MR61+13),ISTORE(MR61+11),I,J)
C--FIND THE COMMON BLOCK OFFSET
      M=ISTORE(MR61+12)
C--CHECK THAT THE OFFSET IS VALID
      N=KVALCM(M,ICOMMN,IDIMN)
C--SET UP THE PARAMETER STORAGE POINTERS
      IPARAM=0
      IPARAD=L
C--SET UP THE COMMON BLOCK
      ICOMMN(M)=L
      ICOMMN(M+1)=L
      ICOMMN(M+2)=I
      ICOMMN(M+3)=J
C--CHECK IF THIS RECORD IS IN CORE
      IF(ISTORE(MR61+11))1600,1650,1650
C--NOT IN CORE
1600  CONTINUE
      ICOMMN(M)=NOWT
      GOTO 1750
C--RECORD IS IN CORE  -  ZERO IT INITIALLY
1650  CONTINUE
      N=I*J
      IF(N)1750,1750,1700
C--SPACE TO ZERO
1700  CONTINUE
      CALL XZEROF(STORE(L),N)
C--CHECK IF THIS DIRECTIVE HAS ONE PARAMETER KEYWORD ONLY
1750  CONTINUE
      IF(ISTORE(MR61+3)-1)2100,1800,2100
C--ONLY ONE PARAMETER KEYWORD  -  SUBSCRIPTION IS POSSIBLE
1800  CONTINUE
      NW=5
C--FIND THE POINTERS TO THE ORIGINAL SET OF PARAMETER KEYWORDS
      L=ISTORE(MR61)+LR62
      M=ISTORE(MR61+1)
      N=ISTORE(MR61+2)
C--INCREMENT THE PARAMETER LENGTHS TO ALLOW FOR THE SUBSCRIPT
      ISTORE(MR61+1)=ISTORE(MR61+1)+NW
      ISTORE(MR61+2)=ISTORE(MR61+2)+NW
C--RESET THE NUMBER OF ALLOWED KEYWORDS
      ISTORE(MR61+3)=ISTORE(MR61+9)
C--CHECK THE NUMBER OF PARAMETERS BEING USED NOW
      ISTORE(MR61)=NOWT
      IF(ISTORE(MR61+3))2100,2100,1850
C--FIND THE LOCATION FOR THE NEW KEYWORD CONTROL BLOCK
1850  CONTINUE
      LR62N=KCHLFL(ISTORE(MR61+2)*ISTORE(MR61+3))
      ISTORE(MR61)=LR62N-LR62
C--RESET ALL THE CONTROL VALUES
      I=(MR61-LR61)/MDR61+1
      CALL XDIRFL(I,ICOMMN,IDIMN)
C--LOOP OVER THE CURRENT NUMBER OF KEYWORDS, GENERATING INDEXED NAMES
      DO 2050 I=1,NR62D
C--MOVE THE CURRENT NAME ACROSS
      CALL XMOVE(STORE(L),STORE(MR62N),M)
C--BLANK OUT THE REST OF THE NAME
      J=MR62N+M
      CALL XMVSPD(IB,ISTORE(J),NW)
C--FIND THE END OF THE CURRENT NAME
      K=MR62N+ISTORE(MR62N)
C--INSERT A '('
      ISTORE(K+1)=ILB
C--ZERO THE INCLUDE ZEROES FLAG
      NUM2=0
C--ASSIGN THE CURRENT INDEX
      NUM=I
C--COMPUTE THE DIVISOR
      NUMDVD=10**(NW-3)
C--INSERT A MAXIMUM OF 'NW-2' INDEX CHARACTERS
      DO 2000 J=3,NW
      NUM1=NUM/NUMDVD
      NUM=NUM-NUM1*NUMDVD
      NUM1=MOD(NUM1,10)
      NUMDVD=NUMDVD/10
C--CHECK IF ALL NUMBERS MUST BE INCLUDED
      IF(NUM2)1900,1900,1950
C--NO NUMBERS IN YET  -  CHECK FOR LEADING ZEROES
1900  CONTINUE
      IF(NUM1)2000,2000,1950
C--INCLUDE THIS NUMBER
1950  CONTINUE
      NUM2=1
      ISTORE(K+2)=NUMB(NUM1+1)
C--UPDATE THE ADDRESS AND COUNTS
      K=K+1
      ISTORE(MR62N)=ISTORE(MR62N)+1
2000  CONTINUE
C--INSERT A ')'
      ISTORE(K+2)=IRB
      ISTORE(MR62N)=ISTORE(MR62N)+2
C--FIND THE ADDRESS OF THE REST OF THE DATA
      K=L+M
C--MOVE IT ACROSS
      CALL XMOVE(STORE(K),STORE(MR62D),MDR62D-MDR62N)
C--UPDATE FOR THE NEXT
      MR62N=MR62N+MDR62D
      MR62D=MR62D+MDR62D
2050  CONTINUE
C--AND NOW EXIT
2100  CONTINUE
      ISTORE(MR61+3)=MIN0(ISTORE(MR61+3),ISTORE(MR61+9))
      NR62D=ISTORE(MR61+3)
      GOTO 1100
      END
C
CODE FOR KINVAL
      FUNCTION KINVAL(IADD,IANS,ICOMMN,IDIMN)
C--FETCH THE VALUE STORED IN A COMMON BLOCK OR DATA AREA.
C
C  IADD    THE INITIAL POINTER :
C
C          <0  THE ABSOLUTE VALUE OF 'IADD' POINTS TO AN ADDRESS IN
C              'ICOMMN' WHICH CONTAINS THE NEXT ADDRESS OR THE REQUIRED
C              VALUE.
C          >0  (OR EQUAL TO 0) THIS IS THE VALUE REQUIRED.
C
C  IANS    THE REQUURED ANSWER IS RETURNED HERE.
C  ICOMMN  THE COMMON BLOCK.
C  IDIMN    THE DIMENSION OF 'ICOMMN'.
C
C--THE RETURN VALUES OF 'KINVAL' ARE :
C
C  -1  AN ERROR HAS OCCURRED  -  NO VALUE GIVEN.
C   0  ALL OKAY.
C
C--
\ISTORE
C
C
      DIMENSION ICOMMN(IDIMN)
C
\STORE
\XUNITS
\XSSVAL
\XLISTI
\XCONST
\XLST50
C
\QSTORE
C
C--INITIAL ASSIGNMENT
      IANS=IADD
      KINVAL=0
C--CHECK IF WE HAVE A VALUE YET
1000  CONTINUE
      IF(IANS)1050,1020,1020
1020  CONTINUE
      RETURN
C--FIND THE NEXT POINT ALONG THE CHAIN
1050  CONTINUE
      JANS=IABS(IANS)
      KANS=KVALCM(JANS,ICOMMN,IDIMN)
C--SEARCH FOR THIS ADDRESS AMONGST THE POSSIBLE INPUT VALUES
      JB=LR61
C--CHECK IF THIS INSTRUCTION HAS ANY DIRECTIVES
      IF(NR61)1650,1650,1100
C--LOOP OVER EACH DIRECTIVE
1100  CONTINUE
      DO 1600 JA=1,NR61
C--CHECK IF THIS DIRECTIVE CONTAINS SIMPLE PARAMETERS
      IF(ISTORE(JB+11))1550,1150,1550
C--CHECK IF THERE ARE ANY PARAMETERS FOR THIS DIRECTIVE
1150  CONTINUE
      IF(ISTORE(JB+3))1550,1550,1200
C--THERE ARE SOME PARAMETERS  -  SCAN ALONG THEM
1200  CONTINUE
      JE=ISTORE(JB)+LR62
      JF=ISTORE(JB+1)+JE
      JD=ISTORE(JB+3)
C--LOOP OVER THE PARAMETERS
      DO 1500 JC=1,JD
C--CHECK IF THE STORAGE POINT HERE EQUALS THE INPUT ADDRESS
      IF(ISTORE(JF+4)-JANS)1450,1250,1450
C--THIS IS THE PARAMETER  -  CHECK IF IT HAS BEEN INPUT
1250  CONTINUE
      IF(KCHKPV(JA,ICOMMN,IDIMN,0))1300,1400,1400
C--NO PROCESSING IS POSSIBLE
1300  CONTINUE
      KINVAL=-1
      RETURN
C--PARAMETER SET OKAY  -  STOP ANY FURTHER INPUT OF THIS DIRECTIVE
1400  CONTINUE
      ISTORE(JB+8)=1000001
C--FIND THE VALUE THAT IS NOW PRESENT IN THE COMMON BLOCK
      KANS=KVALCM(JANS,ICOMMN,IDIMN)
      GOTO 1650
C--UPDATE FOR THE NEXT PARAMETER
1450  CONTINUE
      JE=JE+ISTORE(JB+2)
      JF=JF+ISTORE(JB+2)
1500  CONTINUE
C--UPDATE FOR THE NEXT DIRECTIVE
1550  CONTINUE
      JB=JB+MDR61
1600  CONTINUE
C--ASSIGN THE NEXT VALUE IN THE CHAIN
1650  CONTINUE
      IANS=KANS
      GOTO 1000
      END
C
CODE FOR KCHKPV
      FUNCTION KCHKPV(IDIR,ICOMMN,IDIMN,ITYPE)
C--THIS ROUTINE CHECKS THAT THE DIRECTIVE INDICATED BY THE
C  VALUE OF 'IDIR' HAS BEEN PROPERLY INPUT.
C
C  IDIR    THE DIRECTIVE NUMBER.
C  ICOMMN  THE COMMON BLOCK BEING FILLED BY THIS PROCESS.
C  IDIMN    THE DIMENSION OF THE COMMON BLOCK.
C  ITYPE   SOURCE OF DATA FLAG :
C
C          -1  DATA HAS JUST BEEN INPUT FROM CARDS FOR THIS DIRECTIVE.
C           0  NO DATA HAS BEEN INPUT  -  CHECK NO DEFAULTS ARE MISSING.
C          +1  DATA CONTEXT IS ALREADY KNOWN  -  NO OUTPUT REQUIRED FOR
C
C--RETURN VALUES OF 'KCHKPV' ARE :
C
C  -1  AN ERROR HAS BEEN FOUND.
C   0  ALL OKAY.
C
C--
\ISTORE
C
C
      DIMENSION ICOMMN(IDIMN)
C
\STORE
\XUNITS
\XSSVAL
\XLISTI
\XCARDS
\XCONST
\XLST50
\XIOBUF
C
\QSTORE
C
      JTYPE=ITYPE
C--RECORD THE NUMBER OF ERRORS SO FAR
      MYLEF=LEF
C--CHECK IF A DIRECTIVE IS BEING PROCESSED
      IF(IDIR)2050,2050,1000
C--SET UP THE POINTERS FOR THIS DIRECTIVE
1000  CONTINUE
      CALL XDIRFL(IDIR,ICOMMN,IDIMN)
C--CHECK IF THIS DIRECTIVE HAS ALREADY GENERATED ERRORS
      KCHKPV=-1
      IF(ISTORE(MR61+8))2050,1050,1050
C--DIRECTIVE BEING PROCESSED  -  CHECK IF IT HAS ANY PARAMETERS
1050  CONTINUE
      KCHKPV=0
C--CHECK IF THIS DIRECTIVE HAS ALREADY BEEN DEFAULTED
      IF(ISTORE(MR61+8)-1000000)1100,1100,2050
C--NOW CHECK THE NUMBER OF PARAMETERS
1100  CONTINUE
      IF(NR62D)2050,2050,1150
C--PARAMETERS REQUIRED  -  CHECK FOR A DATA RECORD
1150  CONTINUE
      IF(ISTORE(MR61+11))2050,1250,1200
C--CHECK FOR A NON-ZERO REPEAT COUNT  -  I.E. SOMEWHERE TO PUT THE DATA
1200  CONTINUE
      IF(ISTORE(MR61+10))2050,2050,1250
C--LOOP OVER EACH PARAMETER FOR THIS DIRECTIVE
1250  CONTINUE
      DO 2000 I=1,NR62D
C--CHECK IF THIS PARAMETER HAS BEEN INPUT
      IF(ISTORE(MR62D+10))1300,1300,1950
C--PARAMETER NOT INPUT  -  CHECK FOR A DEFAULT VALUE
1300  CONTINUE
      IF(ISTORE(MR62D+7))1350,1800,1800
C--NO DEFAULT VALUE  -  CHECK IF THIS PARAMETER SHOULD BE INPUT
1350  CONTINUE
      IF(ISTORE(MR62D+9))1950,1950,1400
C--NO DEFAULT VALUE  -  CHECK FOR AN EXCLUDED DIRECTIVE
1400  CONTINUE
      IF(ISTORE(MR61+6))1950,1450,1450
C--ERROR  -  CHECK ON THE TYPE OF STATEMENT PRINT REQUIRED
1450  CONTINUE
      IF(JTYPE)1600,1500,1650
C--NOT A READ  -  SIMPLY A CHECK
1500  CONTINUE
      L=MR60+MDR60-2
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1550)(ISTORE(J+1),J=MR60,L)
      ENDIF
      WRITE(NCAWU,1550) (ISTORE(J+1),J=MR60,L)
      WRITE ( CMON, 1550) (ISTORE(J+1),J=MR60,L)
      CALL XPRVDU(NCEROR, 1,0)
1550  FORMAT(' A directive has been omitted',
     2 ' leaving the parameters below undefined',
     3 /' Directive : ', 20A1)
C--MARK THIS DIRECTIVE AS TOO LATE
      ISTORE(MR61+8)=-1
      GOTO 1650
C--INPUT FROM CARDS  -  PRINT THE LAST CARD IF NECESSARY
1600  CONTINUE
      CALL XMONTR(0)
C--JUMP ON THE TYPE OF ERROR GENERATED
1650  CONTINUE
      JTYPE=1
      K=MR62N+MDR62N-2
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1700)I,(ISTORE(J+1),J=MR62N,K)
      ENDIF
      WRITE(NCAWU,1700) I,(ISTORE(J+1),J=MR62N,K)
      WRITE ( CMON, 1700) I,(ISTORE(J+1),J=MR62N,K)
      CALL XPRVDU(NCEROR, 2,0)
1700  FORMAT(' Parameter ',I3,
     2 '  has no default value and has been omitted',/
     3 ' Parameter keyword : ',20A1)
C--UPDATE THE ERROR COUNTER
      LEF=LEF+1
      KCHKPV=-1
      GOTO 1950
C--CHECK IF THIS IS A DATA AREA OR A COMMON BLOCK
1800  CONTINUE
      IF(ISTORE(MR61+11))1850,1900,1850
C--THIS IS A DATA AREA  -  INSERT THE DEFAULT VALUE
1850  CONTINUE
      CALL XMOVE(STORE(MR62D+8),STORE(IPARAD),1)
      GOTO 1950
C--ASSIGN THE DEFAULT VALUE
1900  CONTINUE
      J=ISTORE(MR62D+4)
C--CHECK THAT THE COMMON BLOCK ADDRESS IS VALID
      K=KVALCM(J,ICOMMN,IDIMN)
C--MOVE THE DEFAULT VALUE OVER
      CALL XMOVEI (ISTORE(MR62D+8),ICOMMN(J),1)
C--UPDATE FOR THE NEXT PARAMETER
1950  CONTINUE
      MR62N=MR62N+MDR62D
      MR62D=MR62D+MDR62D
      IPARAD=IPARAD+1
2000  CONTINUE
C--AND NOW RETURN
2050  CONTINUE
      CALL XDIRFL(IDIRFL,ICOMMN,IDIMN)
C--CHECK IF WE GENERATED ANY ERRORS
      IF(LEF-MYLEF)2100,2200,2100
C--ERRORS  -  PRINT A BLANK LINE
2100  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2150)
      ENDIF
2150  FORMAT(1X)
C--AND NOW RETURN
2200  CONTINUE
      RETURN
      END
C
CODE FOR XDIRFL
      SUBROUTINE XDIRFL(NUM,ICOMMN,IDIMN)
C--SET UP THE POINTERS TO THE TYPE 60 RECORDS FOR A DIRECTIVE.
C
C  NUM     THE NUMBER OF THE DIRECTIVE.
C  ICOMMN  THE COMMON BLOCK BEING USED FOR THIS INPUT.
C  IDIMN    THE DIMENSION OF THE COMMON BLOCK.
C
C--
\ISTORE
C
C
      DIMENSION ICOMMN(IDIMN)
C
\STORE
\XLST50
\XCONST
\XCARDS
C
\QSTORE
C
C--CHECK IF A DIRECTIVE IS INDICATED
      IF(NUM)1100,1100,1000
1000  CONTINUE
C--POINTERS TO THE DIRECTIVE NAME
      MR60=LR60+(NUM-1)*MDR60
C--POINTER TO THE DIRECTIVE DETAILS
      MR61=LR61+(NUM-1)*MDR61
C--POINTERS TO THE PARAMETER NAMES AND DETAILS
      LR62N=ISTORE(MR61)+LR62
      MR62N=LR62N
      LR62D=LR62N+ISTORE(MR61+1)
      MR62D=LR62D
C--INCREMENTS OVER THE PARAMETERS
      MDR62N=ISTORE(MR61+1)
      MDR62D=ISTORE(MR61+2)
C--NUMBER OF PARAMETERS
      NR62N=ISTORE(MR61+3)
      NR62D=NR62N
C--SET UP THE POINTERS TO THE DATA AREA IF NECESSARY
      IPARAM=0
      IPARAD=NOWT
C--CHECK IF THIS INPUT IS FOR A DATA AREA
      IF(ISTORE(MR61+11))1050,1100,1050
C--DATA AREA  -  SET THE POINTERS
1050  CONTINUE
      IPARAD=KVALCM(ISTORE(MR61+12),ICOMMN,IDIMN)+MAX0(0,ISTORE(MR61+8)
     2 -1)*ISTORE(MR61+9)
C--AND NOW RETURN
1100  CONTINUE
      RETURN
      END
C
CODE FOR KVALCM
      FUNCTION KVALCM(IADD,ICOMMN,IDIMN)
C--THIS ROUTINE FETCHES THE VALUE FROM 'ICOMMN(IADD)', AFTER CHECKING TH
C  'IADD' IS A VALID ADDRESS.
C
C  IADD    THE ADDRESS IN THE COMMON BLOCK.
C  ICOMMN  THE COMMON BLOCK.
C  IDIMN    THE DIMENSION OF 'ICOMMN'.
C
C--THE RETURN VALUE OF 'KVALCM' IS THE CONTENTS OF THE REQUIRED LOCATION
C
C--
C
      DIMENSION ICOMMN(IDIMN)
C
\XLISTI
\XUNITS
\XSSVAL
\XERVAL
\XIOBUF
C
C--CHECK IF THE LOCATION GIVEN IS VALID
      IF(KVALID(1,IADD,IDIMN))1000,1100,1100
C--INVALID LOCATION
1000  CONTINUE
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1050)IADD,LN,IREC
      ENDIF
      WRITE(NCAWU,1050)IADD,LN,IREC
      WRITE ( CMON, 1050) IADD,LN,IREC
      CALL XPRVDU(NCEROR, 2,0)
1050  FORMAT(' Invalid common block address ',I8,/,'List type ',I5,
     2 5X,'Record type ',I8)
      CALL XERHND ( IERPRG )
C--FETCH THE CONTENTS
1100  CONTINUE
      KVALCM=ICOMMN(IADD)
      RETURN
      END
C
CODE FOR XFAL50
      SUBROUTINE XFAL50
C--LOAD THE CONTROL RECORDS FOR LIST 50  -  THE INPUT AND LIST FORMAT LI
C
C--
C
      DIMENSION IRECS(3)
\ICOM50
\HEADES
\ISTORE
C
\XDISCS
\XDISC
\STORE
\XLISTI
\XUNITS
\XSSVAL
\XLST50
\XERVAL
\XIOBUF
C
\QSTORE
\QCOM50
C
C
      DATA IRECS(1)/52/,IRECS(2)/-51/,IRECS(3)/50/
C
C--SWITCH TO THE INSTRUCTION DEFINITION DISC
      KA = KSWPDU ( NCIFU )
C--ZERO THE COMMON BLOCK
      CALL XZEROF(ICOM50(1),IDIM50)
C--SET UP THE LIST TYPE
      LN=50
C--LOAD THE CONTROL RECORDS ONE BY ONE
      DO 1150 I=1,3
      IF(KFNDRI(LN,IRECS(I),IADDR,IBUFF))1000,1100,1100
C--NO SUCH RECORD
1000  CONTINUE
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1050)IRECS(I)
      ENDIF
      WRITE(NCAWU,1050) IRECS(I)
      WRITE ( CMON, 1050) IRECS(I)
      CALL XPRVDU(NCEROR, 1,0)
1050  FORMAT(' Missing control record ',I8)
      CALL XERHND ( IERPRG )
C--LOAD THE RECORD
1100  CONTINUE
      CALL XLDREC(LN,1,IBUFF,ICOM50,IDIM50,0)
1150  CONTINUE
C--SWITCH DISCS AGAIN
      N = KSWPDU ( KA )
      RETURN
      END
C
CODE FOR XLL50R
      SUBROUTINE XLL50R(NUMB)
C--LOAD RECORDS FROM LIST 50 FOR INSTRUCTION NUMBER 'NUMB'.
C
C  NUMB  THE NUMBER OF THE INSTRUCTION WHOSE DETAILS ARE TO BE LOADED
C
C--
\ICOM50
\HEADES
\ISTORE
C
\XDISCS
\XDISC
\STORE
\XLISTI
\XCONST
\XLST50
C
\QSTORE
\QCOM50
C
C--SWITCH TO THE INSTRUCTION DEFINITION DISC
      KA = KSWPDU ( NCIFU )
C--BLANK OUT THE COMMON BLOCK
      DO 1000 I=LCOM,MCOM,MDCOM
      ICOM50(I)=NOWT
      ICOM50(I+2)=0
      ICOM50(I+3)=0
1000  CONTINUE
C--MOVE THE COMMON BLOCK DETAILS INTO THE COMMON BLOCK
      LN=50
      IREC=51
C--ALLOCATE SPACE FOR THE LOAD DETAILS
      MR51=KCHLFL(MDR51)
C--FIND THE DISC ADDRESS
      J=LR51+KINCRF((NUMB-1)*MDR51)
C--LOAD THIS SET OF LOAD DETAILS
      CALL XDOWNF(J,STORE(MR51),MDR51)
      J=MR51+MDR51-2
C--LOOP OVER EACH AVAILABLE RECORD TYPE
      DO 1100 K=MR51,J,2
C--CHECK IF THE RECORD EXISTS
      IF(ISTORE(K+1))1100,1100,1050
C--FIND THE DETAILS OF THIS RECORD
1050  CONTINUE
      L=ISTORE(K)
      M=ISTORE(K+1)
      N=KLDDRH(L,M,IBUFF)
C--MAKE THIS RECORD A RECORD THAT CAN BE LOADED
      IBUFF(7)=IABS(IBUFF(7))
      CALL XLDREC(LN,1,IBUFF,ICOM50,IDIM50,0)
1100  CONTINUE
C--SET UP A THE REST OF THE POINTERS
      DO 1150 I=LCOM,MCOM,MDCOM
      ICOM50(I+1)=ICOM50(I)
1150  CONTINUE
C--SWITCH BACK TO THE ORIGINAL DISC
      N = KSWPDU ( KA )
      RETURN
      END
