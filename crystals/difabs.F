C $Log: not supported by cvs2svn $
C Revision 1.12  2011/05/13 11:16:51  djw
C Calls to Kallow now return a key to the test which failed and a value to indicate if it was Max or Min. The argument of KALLOW must be a variable
C
C Revision 1.11  2008/04/29 15:31:30  djw
C Correct some captions
C
C Revision 1.10  2005/01/23 08:29:11  rich
C Reinstated CVS change history for all FPP files.
C History for very recent (January) changes may be lost.
C
C Revision 1.1.1.1  2004/12/13 11:16:10  rich
C New CRYSTALS repository
C
C Revision 1.9  2004/07/02 13:26:01  rich
C Remove dependency on HARWELL and NAG libraries. Replaced with LAPACK
C and BLAS code (and a home-made bessel function approximation).
C
C Revision 1.8  2004/06/18 13:56:51  rich
C Fix common block length.
C
C Revision 1.7  2004/05/27 12:21:12  rich
C Move DIFABS routines out of the harwell library source.
C
C Revision 1.6  2003/02/14 17:09:02  djw
C Extend codes to work wih list 6 and list 7.  Note that sfls, calc and
C recine have the parameter ityp06, which corresponds to the types
C pickedip for lists 6 and 7  from the command file
C
C Revision 1.5  2001/03/07 17:54:28  CKP2
C Proper List 13 checking
C
C Revision 1.4  2001/02/26 10:25:31  richard
C Added changelog to top of file
C
C
CODE FOR XDFABS
      SUBROUTINE XDFABS
C     **************
C
C   EMPIRICAL ABSORPTION CORRECTION PROGRAM
C
C   A low order term Fourier series is used to model an absorption surfa
C   for differences between the observed structure factors and those
C   obtained from a structure factor calculation (after isotropic least
C   squares refinement).   Spherical polar angles are used to define the
C   incident and diffracted beam path directions.   This reduces the num
C   of angles required to four - viz. PHI(p), MU(p), PHI(s) and MU(s).
C   A theta-dependent correction is evaluated to allow for diffracted
C   beams with different path lengths occurring at the same polar angles
C   Again, a low order term Fourier series is used; in Bragg angle, THET
C   This version is general for any 4-circle diffractometer data collect
C   geometry: however, routine ANGLES may require extra code for the
C   calculation of the Eulerian angles from the Miller indices using the
C   orientation matrix.
C
C   Author - Nigel Walker, Chemistry Dept., Queen Mary College, London E
C   Reference - WALKER & STUART (1983) Acta Cryst. A39, 158-166.
C               WALKER & STUART (1984) Acta Cryst. (in preparation).
C
C   DIMENSIONING OF ARRAYS IN COMMON /NORMAL/ AND  SUBROUTINE SOLVEN
C   ----------------------------------------------------------------
C   If NCO=NACOEF+NBCOEF, then arrays ANORM & VEC should have minimum
C   dimensions (NCO,NCO); ATB & TERMS (NCO); ROWJ (2*NCO); and WORK (5*N
C
C   VERSION 8.08
C   THIS VERSION USES NON-LINEAR LEAST-SQUARES WITH UNIT WEIGHTS
C   INPUTS SHELX 'LIST 5' DATA AND OUTPUTS 'HKLF 3' TYPE DATA
C   GENERAL ROUTINE FOR CALCULATION OF SPHERICAL POLAR ANGLES
C
C   SET UP DIFFRACTOMETER CHARACTERISTICS
C     IDIFRT=0   Enraf-Nonius CAD4
C     IDIFRT=1   Syntex P-1
C     IDIFRT=2   Syntex P21
C     IDIFRT=3   Picker FACS-I
C     IDIFRT=4   Philips PW1100
C
C   SET UP GEOMETRY CHARACTERISTICS
C     IPOS=0   bisecting geometry
C     IPOS=1   data collected in parallel position
C     IPOS=2     "      "      " a general   "
C
C      IACTN  -1 = TEST, 0 = UPDATE LIST 6, 1 = WRITE NEW LIST 6
C      MODE    0 = MODIFY FO, 1 = MODIFY FC, 2 = TRANFER FROM FC TO FO
C
      LOGICAL TCOR
      REAL X(3) , MU , MUMIN , MUMAX
      INTEGER NP(16)
      COMMON /NORMAL/ ANORM(44,44),ATB(44),ROWJ(88),TERMS(44)
      COMMON /SOLVE/ NSIZE,FILTER,FILSTA,FILDEC,FILEND
      COMMON /REFL/ FC,FO,FM,PHI(2),MU(2),SINTH,COSTH
      COMMON /DRVR/ LI,LD,LO,lf,lp,ncy,NSHAPE,NACOEF,NBCOEF,SFMU,TCOR
     1 ,IMAP
      COMMON /SRES/ NUMREF,SUMRES,SUMFS,SUMRSQ,SUMFSQ
      COMMON/ORIENT/TWOTHZ,OMZ,PHIZ,PLUS(3),IPOS,IDIFRT,ORIENT(3,3),DST
      COMMON /CELLP/ TA,TB,TC,ZA,ZB,ZC
C
C
      PARAMETER (IDIMN=7)
      DIMENSION IPROCS(IDIMN)
C
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XTAPES.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST06.INC'
      INCLUDE 'XLST13.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
C
C
C
      DATA  STHMAX / 0.0 / , MUMIN / 100.0 / , MUMAX / -100.0 /
C
      DATA IVERSN /901/
C----- CAN EITHER COMPUTE CORRECTION AS FUNCTION OF FO OR  FC
C      IF FO, THE CORRECTION IS APPLIED DIRECTLY.
C      IF FC, IT COMPUTES CORRECTION TO FC, AND STORES IT IN M6+27
C
C
C
      CALL XTIME1 ( 2 )
C
      CALL XCSAE
      CALL XRSL
C
      I=KRDDPV ( IPROCS , IDIMN )
      IF (I.LT.0) GO TO 9910
C
      IS     = IPROCS(1)
      IDIFRT = IPROCS(2)
      IPOS   = IPROCS(3)
      IACTN = IPROCS(4)
      IMODE = IPROCS(5)
      IMAP = IPROCS(6)
C--FIND THE TYPE OF LISTS   IULN IS USUALY 6
      IULN=KTYP06(IPROCS(7))

C
C     LOAD A FEW LISTS
C
      CALL XFAL01
      CALL XFAL05
      CALL XFAL13
C
C---------------------------------------------------------------------
C
C   SET UP I/O UNIT NUMBERS
cdjw99[       change from MT1 to MT2 to permit contouring file on MT1
      LF=MT2
      REWIND MT2
      LP = NCWU
C
C   OUTPUT HEADER.
      WRITE(CMON,1200) FLOAT(IVERSN)*.01
      CALL XPRVDU(NCVDU, 1,0)
      WRITE(NCAWU, '(A)') CMON(1 )(:)
      IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') CMON(1 )(:)
1200  FORMAT(' DIFABS Version ', F5.2, ' Applied to Fo or Fc')
C
C     *********
      NACOEF=34
      NBCOEF=10
C     *********
C
C
C     **************
      NSIZE=44
      FILTER=0.00005
      FILSTA=0.0001
      FILDEC=0.00005
      FILEND=0.0
      NCYCLE=5
C----- SCALE MU TO GET INTERVALS
      WAVE = STORE(L13DC)
      SFACT = STORE(L5O)
      SFMU = WAVE * 7.0
C
C
C----- IF IMODE IS 2, TRANSFER 1./FC CORRECTION TO FO.
C      THE CORRECTION IS NOT RECOMPUTED
      IF (IMODE .EQ. 2) THEN
            CALL ABSPLY(NREF, IACTN, IMODE, IULN)
            GOTO 9000
      ENDIF
C
C
CDJWMAR2001
      IF (L13OM.GT.0) THEN
            A=ABS(XDETR3(STORE(L13OM)))
      ELSE
            A=0.
      ENDIF
      IF (A .GT. ZERO) THEN
C----- COPY OVER THE ORIENTATION MATRIX
        CALL XMOVE (STORE(L13OM),ORIENT(1,1),9)
      ELSE
        WRITE(CMON,'(A/A)')' There is no orientation matrix.',
     1  ' DIFABS correction will not be optimal'
      CALL XPRVDU(NCVDU, 2,0)
      WRITE(NCAWU, '(A)') (CMON( II)(:),II=1,2)
      IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') (CMON( II)(:),II=1,2)
C----- COPY OVER THE ORTHOGONALISATION MATRIX
        CALL XMOVE (STORE(L1O2), ORIENT(1,1), 9)
        CALL MTRANS(ORIENT)
      ENDIF
      IF(SFACT.LE.0.0)SFACT=1.0
      TCOR=.FALSE.
      IF(IS.EQ.1)TCOR=.TRUE.
C       READ(LI,*)NCYCLE,FILTER,FILSTA,FILDEC,FILEND
      IF(.NOT.TCOR)NCYCLE=NCYCLE-1
C
C   GET CELL PARAMETERS
      CALL CELL
C
C   SET UP DIFFRACTOMETER CHARACTERISTICS
C   SET ANGLE ZEROES AND DIRECTION SENSES.
C
      TWOTHZ=0.0
      OMZ=0.0
      PHIZ=0.0
      IF(IDIFRT.EQ.4) GO TO 110
      PLUS(1)=1.0
      PLUS(2)=-1.0
      PLUS(3)=-1.0
      GO TO 120
110   PLUS(1)=1.0
      PLUS(2)=1.0
      PLUS(3)=1.0
120   CONTINUE
C
C   INITIALIZE RESIDUES
      NF=-1
      CALL RES(NF)
C
C   SET COUNTERS
      NREF=0
      NTOT=0
      NCUTO=0
      NCUTC=0
      NLOW=0
      DO 15 J=1,16
15    NP(J)=0
C
C   SET UP COEFFICIENT STARTING VALUES (ZERO)
C   AND INITIALIZE NORM EQUATIONS
      NCO=NACOEF+NBCOEF
      DO 20 I=1,NCO
      ATB(I)=0.0
      TERMS(I)=0.0
      DO 25 J=1,I
      ANORM(I,J)=0.0
25    CONTINUE
20    CONTINUE
C
C
C
C   NOW GET TO WORK...
C
      NCY=1
      NSHAPE=NACOEF
C
C     SET UP LIST 6 FOR PROCESSING
      CALL XFAL06(IULN,0)
C
      GO TO 260
C
C
C
1000  CONTINUE
C
      IH=NINT(STORE(M6))
      IK=NINT(STORE(M6+1))
      IL=NINT(STORE(M6+2))
      FOBS=STORE(M6+3)
C----- REMOVE ANY EXISTING CORRECTION
      FCALC = STORE(M6+5) / STORE(M6+27)
      SIGF=STORE(M6+12)
      IF (SIGF.LE.0) SIGF=SQRT(FOBS)
C
      IF(IH.EQ.0.AND.IK.EQ.0.AND.IL.EQ.0)GOTO 290
      NREF=NREF+1
      IUSE=0
C----- CHECK IF THIS REFLECTION IS ALLOWED
      IF (KALLOW(IALLOW) .LE. -1) GOTO 250
C   IF UNOBSERVED, WRITE DUMMY RECORD
      IF(FOBS.LE.0.0) GO TO 250
      NTOT=NTOT+1
C
C
C   CALCULATE SETTING ANGLES FROM ORIENTATION MATRIX.
      STHLSQ=0.25*(IH*IH*TA+IK*IK*TB+IL*IL*TC+IL*IH*ZB
     ++IK*IL*ZA+IH*IK*ZC)
      SINL=SQRT(STHLSQ)
      DST=2.0*SINL
      X(1)=IH
      X(2)=IK
      X(3)=IL
      CALL ANGLES (OMEGA,PHIE,CHIE,X,IERR)
      IF(IERR.NE.1) GOTO 147
      IF (ISSPRT .EQ. 0)  WRITE (NCWU,1220) IH,IK,IL
1220  FORMAT(' *** ERROR IN SETTING ANGLES FOR REFLECTION',3I4,' ***')
      GOTO 250
C
147   SINTH=WAVE*SINL
      COSTH=SQRT(1. - SINTH*SINTH)
C   MAX THETA
      IF(SINTH.LE.STHMAX) GOTO 148
      STHMAX=SINTH
      CTHMAX=COSTH
148   CONTINUE
C
C   CALCULATE SPHERICAL POLAR COORDS FROM 4-CIRCLE DIFFRACT. EULERIAN AN
C   calculate primary & secondary beam angles
C   for bisecting geometry (not Picker)
      IF(IPOS.EQ.0.AND.IDIFRT.NE.3) CALL BISECT (CHIE,PHIE)
C   or for the general case
      IF(IPOS.NE.0.OR.IDIFRT.EQ.3) CALL GEN4C (OMEGA,CHIE,PHIE)
C
C   MIN AND MAX MU
      IF(MU(1).LT.MUMIN) MUMIN=MU(1)
      IF(MU(1).GT.MUMAX) MUMAX=MU(1)
      IF(IPOS.EQ.0)GOTO 149
      IF(MU(2).LT.MUMIN) MUMIN=MU(2)
      IF(MU(2).GT.MUMAX) MUMAX=MU(2)
C
C   TAKE THE SQUARE ROOT OF MU * SFMU
149   IF(MU(1).GT.0.) MU(1)=SQRT(MU(1))*SFMU
      IF(MU(1).LT.0.) MU(1)=-SQRT(ABS(MU(1)))*SFMU
      IF(IPOS.EQ.0)GOTO 150
      IF(MU(2).GT.0.) MU(2)=SQRT(MU(2))*SFMU
      IF(MU(2).LT.0.) MU(2)=-SQRT(ABS(MU(2)))*SFMU
      GOTO 155
C   FOR BISECTING GEOMETRY
150   MU(2)=MU(1)
C
C   COUNT REFLS. IN EACH OCTANT
155   DO 160 J=1,2
      JJ=(J-1)*4
      M=0
      IF(MU(J).LT.0.)M=8
      N=PHI(J)/90. + 1.
      IOCT=N+JJ+M
      NP(IOCT)=NP(IOCT) + 1
160   CONTINUE
C
C
      FO=FOBS
      FC=FCALC*SFACT
C
C   TEST FOR INCLUSION IN COEFFICIENT DETERMINATION
C
C   DON'T ALLOW REFLS .LT. 3*SIGF
      FCUT=FO/SIGF
      IF(FCUT.GE.3.) GOTO 200
      NCUTO=NCUTO + 1
      GOTO 250
C
C   DON'T ALLOW REFLS WITH FCALC .LT. 3*SIGF(OBS)
200   FCUT=FC/SIGF
      IF(FCUT.GE.3.) GOTO 202
      NCUTC=NCUTC + 1
      GOTO 250
C
C   DON'T ALLOW REFLS IF SCALED FOBS .LT. 0.5*FCALC (POSSIBLE EXTINCTION
202   TWOBS=FO*2.
      IF(FC.LT.TWOBS) GOTO 205
      NLOW=NLOW + 1
      GOTO 250
C
C   STORE PHI,MU AND THETA FOR LATER USE
205   IUSE=1
250   CONTINUE
C----- INTERCHANGE FO&FC, TO COMPUTE CORRECTION WRTO FC
C      BY RE-ORDERING WRITE STATEMENT.
      IF (IMODE .EQ. 0) THEN
       WRITE(LF) IUSE, FC, FO, PHI, MU, SINTH, COSTH
      ELSE
       WRITE(LF) IUSE, FO, FC, PHI, MU, SINTH, COSTH
      ENDIF
C
C
C   SET UP OBSERVATIONAL AND NORMAL EQUATIONS
      IF(IUSE.EQ.1) CALL ABNORM
C     FETCH NEXT REFLECTION
260   CONTINUE
      IF (KLDRNR(0)) 290, 1000, 1000
C
C
290   CONTINUE
C
C     CHECK THAT WE HAVE USED SOME REFLECTIONS
      IF(NREF)9900,9900,291
291   CONTINUE
C
      CALL XCSAE
C
C     START PROCESSING THE ACCUMULATED DATA
C
C   REPORT REFLECTION SUMMARY
      NZERO=NREF-NTOT
      IF (ISSPRT .EQ. 0)WRITE(NCWU,1600)NREF,NZERO,NCUTO,NCUTC,NLOW
      WRITE(NCAWU,1601)NREF, NLOW
1601  FORMAT(/I6,' Reflections input',
     +       /I6,' Rejected with Fcalc .GT. 2*Fobs')
1600  FORMAT(/I6,' Reflections input',
     +       /I6,' Rejected with Fobs=0',
     +       /I6,' Rejected with Fobs/SigFobs .LT. 3',
     +       /I6,' Rejected with Fcalc/SigFobs .LT. 3',
     +       /I6,' Rejected with Fcalc .GT. 2*Fobs')
C
      CALL ARCTAN (THMAX,CTHMAX,STHMAX)
C
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,1700)THMAX,MUMIN,MUMAX,NP
1700  FORMAT(/' Maximum THETA =',F6.2,' degrees',
     +       /' Minimum MU =',F6.2,' degrees',
     +       /' Maximum MU =',F6.2,' degrees',
     + //' NUMBER OF REFLECTION PATHS IN EACH OCTANT',
     + /12X,'Primary',20X,'Secondary'/2(5X,'0-90 -180 -270 -360',4X)
     + /' +MU',4I5,8X,4I5 / ' -MU',4I5,8X,4I5)
      ENDIF
C
C   REPORT RESIDUALS BEFORE CORRECTION
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1800)
1800  FORMAT(//' RESIDUALS BEFORE CORRECTION')
      NF=1
      CALL RES(NF)
C
C   SOLVE EQUATIONS
      CALL SOLVEN
C
C
C   LOOP ROUND DOING CYCLES
C
      IF(TCOR)NSHAPE=NACOEF+NBCOEF
C
      DO 300 NCY=2,NCYCLE
C
C   INITIALIZE RESIDUALS AND NORMAL EQUATIONS
      NF=-1
      CALL RES(NF)
      DO 310 I=1,NSHAPE
      ATB(I)=0.0
      DO 320 J=1,I
      ANORM(I,J)=0.0
320   CONTINUE
310   CONTINUE
C
      REWIND LF
      DO 400 NRECRD=1,NREF
      READ(LF)IUSE,FC,FO,PHI,MU,SINTH,COSTH
      IF(IUSE.EQ.1)CALL ABNORM
400   CONTINUE
      CALL SOLVEN
300   CONTINUE
C
      IF (ISSPRT .EQ. 0)  WRITE(NCWU,1900)NCY-1
1900  FORMAT(//' RESIDUALS AFTER CYCLE',I2)
      NF=1
      CALL RES(NF)
C
C
C
C   APPLY CORRECTION TO ALL DATA
      CALL ABSPLY ( NREF, IACTN, IMODE, IULN)
      IF(NREF)9900,9900,209
209   CONTINUE
C
      IF (ISSPRT .EQ. 0)  WRITE(NCWU,210) (TERMS(J),J=1,NSHAPE)
210   FORMAT(/' ***VALUES FOR COEFFICIENTS***'//,
     +  2(6F10.4/)/ , 2(4F10.4/)/ , 2(7F10.4/)/  , 2(5F10.4/)/ )
C
C   PRINT EXAMPLE OF ABSORPTION SURFACE
      CALL ABSPRI(MUMIN,MUMAX,THMAX)
C
C
C
C
C
9000  CONTINUE
C
      CALL XOPMSG ( IOPDAB , IOPEND , IVERSN )
      CALL XTIME2 ( 2 )
C
      RETURN
C
C
C
C
9900  CONTINUE
      CALL XOPMSG ( IOPDAB , IOPABN , 0 )
      GO TO 9000
9910  CONTINUE
      CALL XOPMSG ( IOPDAB , IOPCMI , 0 )
      GO TO 9900
      END
C
C
C
CSUBROUTINESSUBROUTINESSUBROUTINESSUBROUTINESSUBROUTINESSUBROUTINESSUBRO
CSUBROUTINESSUBROUTINESSUBROUTINESSUBROUTINESSUBROUTINESSUBROUTINESSUBRO
CSUBROUTINESSUBROUTINESSUBROUTINESSUBROUTINESSUBROUTINESSUBROUTINESSUBRO
CSUBROUTINESSUBROUTINESSUBROUTINESSUBROUTINESSUBROUTINESSUBROUTINESSUBRO
C
C
C
C
CODE FOR ABNORM
      SUBROUTINE ABNORM
C     *****************
C
C
C  ROUTINE TO DERIVE ABSORPTION COEFFICIENTS.
C
C   To be modelled:-    Fc = k Fo . A(p,s)
C   where:
C         A(p,s) = A(p).A(s).A(p-s)
C   using model:
C         A(p,s) = SUM {Pn,m [sin(nop+mup) + Qn,m cos(nop+mup)]}
C                 *SUM {Pn,m [sin(nos+mus) + Qn,m cos(nos+mus)]}
C                 *SUM {Rn sin(nO) + Sn cos(nO)}
C   where:
C     o=phi, u=mu and O=theta
C     p=primary and s=secondary, p-s=2O, and n and m are integers.
C     k = scale factor from least squares refinement.
C
C   Coefficients for zero order terms are set to unity and taken out
C   of summation, hence:
C                   Fc = k Fo . {1 + A'(p)}.{1 + A'(s)}.{1 + A'(O)}
C
C   Terms Pn,m and Qn,m used are:-
C    a) n=1,2,3,4,5,6 and m=0  b) n=0 and m=1,2,3,4
C    c) n=1,2,3,4 and m=1, and n=m=2,3,4    ie. a total of 34
C   and terms Rn and Sn used are:-
C      n=1,2,3,4,5    ie. a total of 10
C
C   All coefficients have starting values of zero.
C
C
      LOGICAL TCOR
      REAL MU
      COMMON /NORMAL/ ANORM(44,44),ATB(44),ROWJ(88),TERMS(44)
      COMMON /REFL/ FC,FO,FM,PHI(2),MU(2),SINTH,COSTH
      COMMON /DRVR/ LI,LD,LO,lf,lp,ncy,NSHAPE,NACOEF,NBCOEF,SFMU,TCOR
     1 ,IMAP
C
C
C   GET TRIG TERMS
      CALL ABSTOR
C
C   APPLY CORRECTION FACTOR FROM PREVIOUS CYCLE TO FOBS
      IF(NCY.EQ.1) GOTO 5
      CALL AFACT(PS1,PS2,PS3,ABSFAC)
      FM=FO*ABSFAC
      GOTO 6
C
5     FM=FO
      PS1=1.0
      PS2=1.0
      PS3=1.0
C
6     NF=0
      CALL RES(NF)
C
      DEL=FC-FM
C
C   CALCULATE DERIVATIVES
C
      DCONST=FO*PS3
      DO 10 J=1,NACOEF
      JJ=J+NACOEF
      ROWJ(J)=DCONST *(ROWJ(J)*PS2 + PS1*ROWJ(JJ))
10    CONTINUE
C
      IF(.NOT.TCOR.OR.NCY.EQ.1) GOTO 30
C
      NSTART=NACOEF+1
      DCONST=FO*PS1*PS2
      DO 20 J=NSTART,NSHAPE
      JJ=J+NACOEF
      ROWJ(J)=DCONST*ROWJ(JJ)
20    CONTINUE
C
C
C   NOTE... SHAPE DERIVS. ARE IN ROWJ (1 thro' NSHAPE)
C
C   ADD INTO NORMAL EQUATIONS
C
C
30    DO 40 K=1,NSHAPE
      DO 50 L=1,K
      ANORM(K,L)=ANORM(K,L) + ROWJ(K)*ROWJ(L)
50    CONTINUE
C
C   R.H.S.
      ATB(K)=ATB(K) + ROWJ(K)*DEL
40    CONTINUE
C
C
      RETURN
      END
C
C
C
C
CODE FOR BISECT
      SUBROUTINE BISECT (CHIE,PHIE)
C     *****************************
C
C   CALCULATE SPHERICAL POLAR COORDINATES PHI AND MU
C   FROM EULERIAN DIFFRACTOMETER ANGLES PHIE, CHIE AND THETA
C   FOR A CRYSTAL IN THE BISECTING POSITION.
C   ALL ANGLES IN DEGREES.
C
      REAL MU
      COMMON /REFL/ FC,FO,FM,PHI(2),MU(2),SINTH,COSTH
C
      DATA DTOR/0.0174533/
      DATA RAD/57.2957795/
C
      RCHIE=CHIE*DTOR
      SCHI= SIN(RCHIE)
      CCHI= COS(RCHIE)
C
C...CALCULATE MU
      SMU= SINTH * SCHI
      CMU= SQRT(1. - SMU*SMU)
      CALL ARCTAN(XMU,CMU,SMU)
C
C
C...CALCULATE DELTA PHI
      TANTH= SINTH/COSTH
      DPHI= ATAN(TANTH * CCHI)*RAD
C
C
C   CALCULATE PHI AND MU FOR PRIMARY AND SECONDARY BEAM PATHS
C   ONLY ASSUMPTION IS A(p)=A(-s)
C   Huber & Kopfmann (1969) Acta Cryst. A25, 143-152
C
C
C
      PHI(1)= PHIE + DPHI
      PHI(2)= PHIE + 180. - DPHI
      CALL NORM(PHI(1))
      CALL NORM(PHI(2))
C
      MU(1)= XMU
      MU(2)= XMU
C
      RETURN
      END
C
C
C
C
CODE FOR GEN4C
      SUBROUTINE GEN4C (OMEGA,CHIE,PHIE)
C     **********************************
C
C   GENERAL ROUTINE TO CALCULATE SPHERICAL POLAR COORDINATES
C   PHI AND MU FROM EULERIAN DIFFRACTOMETER ANGLES -
C   ALL ANGLES IN DEGREES.
C   NOTE: OMEGA is defined such that the CHI axis makes an angle
C         of THETA + OMEGA with the primary beam direction,
C         ie. OMEGA=0 in the bisecting position.
C
      REAL MU,MUP,MUS
      COMMON /REFL/ FC,FO,FM,PHI(2),MU(2),SINTH,COSTH
C
      DATA DTOR/0.0174533/
      DATA RAD/57.2957795/
C
      THETA= ATAN(SINTH/COSTH)
      ROMEGA= OMEGA*DTOR
      OMP= THETA + ROMEGA
      OMS= THETA - ROMEGA
      RCHIE=CHIE*DTOR
      SCHI= SIN(RCHIE)
      CCHI= COS(RCHIE)
C
C...CALCULATE MU
      SMU= SIN(OMP) * SCHI
      CMU= SQRT(1. - SMU*SMU)
      CALL ARCTAN(MUP,CMU,SMU)
      SMU= SIN(OMS) * SCHI
      CMU= SQRT(1. - SMU*SMU)
      CALL ARCTAN(MUS,CMU,SMU)
C
C
C...CALCULATE DELTA PHI
      DPHIP= ATAN(CCHI * TAN(OMP))*RAD
      DPHIS= ATAN(CCHI * TAN(OMS))*RAD
C
C
C   CALCULATE PHI AND MU FOR PRIMARY AND SECONDARY BEAM PATHS
C   ONLY ASSUMPTION IS A(p)=A(-s)
C   Huber & Kopfmann (1969) Acta Cryst. A25, 143-152
C
C
C
      PHI(1)= PHIE + DPHIP
      PHI(2)= PHIE + 180. - DPHIS
      CALL NORM(PHI(1))
      CALL NORM(PHI(2))
C
      MU(1)= MUP
      MU(2)= MUS
C
      RETURN
      END
C
C
C
C
C
CODE FOR ABSTOR
      SUBROUTINE ABSTOR
C     *****************
C
C   CALCULATES SIN & COS OF POLAR ANGLES
C
C   WORK OUT TERMS USING EXPANSIONS FOR TRIG FUNCTIONS.
C
C   NOTE: if bisecting geometry, MU expansions only performed once
C         since MU(s)=MU(p).
C
      LOGICAL TCOR
      REAL MU
      COMMON /NORMAL/ ANORM(44,44),ATB(44),ROWJ(88),TERMS(44)
      COMMON /REFL/ FC,FO,FM,PHI(2),MU(2),ST,CT
      COMMON/ORIENT/TWOTHZ,OMZ,PHIZ,PLUS(3),IPOS,IDIFRT,ORIENT(3,3),DST
      COMMON /DRVR/ LI,LD,LO,lf,lp,ncy,NSHAPE,NACOEF,NBCOEF,SFMU,TCOR
     1 ,IMAP
C
      DATA DTOR/0.0174533/
C
C
      SPP=SIN(PHI(1)*DTOR)
      CPP=COS(PHI(1)*DTOR)
C
      SPS=SIN(PHI(2)*DTOR)
      CPS=COS(PHI(2)*DTOR)
C
      SMP=SIN(MU(1)*DTOR)
      CMP=COS(MU(1)*DTOR)
C
      IF(IPOS.EQ.0.AND.IDIFRT.NE.3)GOTO 5
      SMS=SIN(MU(2)*DTOR)
      CMS=COS(MU(2)*DTOR)
C
C
5     SPP2=CPP*SPP
      SPP2=SPP2+SPP2
      CPP2=CPP*CPP-SPP*SPP
C
      SPP3=CPP*SPP2+CPP2*SPP
      CPP3=CPP*CPP2-SPP*SPP2
C
      SPP4=CPP2*SPP2
      SPP4=SPP4+SPP4
      CPP4=CPP2*CPP2-SPP2*SPP2
C
      SPP5=CPP2*SPP3+CPP3*SPP2
      CPP5=CPP2*CPP3-SPP2*SPP3
C
      SPP6=CPP3*SPP3
      SPP6=SPP6+SPP6
      CPP6=CPP3*CPP3-SPP3*SPP3
C
      SPS2=CPS*SPS
      SPS2=SPS2+SPS2
      CPS2=CPS*CPS-SPS*SPS
C
      SPS3=CPS*SPS2+CPS2*SPS
      CPS3=CPS*CPS2-SPS*SPS2
C
      SPS4=CPS2*SPS2
      SPS4=SPS4+SPS4
      CPS4=CPS2*CPS2-SPS2*SPS2
C
      SPS5=CPS2*SPS3+CPS3*SPS2
      CPS5=CPS2*CPS3-SPS2*SPS3
C
      SPS6=CPS3*SPS3
      SPS6=SPS6+SPS6
      CPS6=CPS3*CPS3-SPS3*SPS3
C
      SMP2=CMP*SMP
      SMP2=SMP2+SMP2
      CMP2=CMP*CMP-SMP*SMP
C
      SMP3=CMP2*SMP+CMP*SMP2
      CMP3=CMP2*CMP-SMP2*SMP
C
      SMP4=CMP2*SMP2
      SMP4=SMP4+SMP4
      CMP4=CMP2*CMP2-SMP2*SMP2
C
      IF(IPOS.EQ.0.AND.IDIFRT.NE.3)GOTO 10
      SMS2=CMS*SMS
      SMS2=SMS2+SMS2
      CMS2=CMS*CMS-SMS*SMS
C
      SMS3=CMS2*SMS+CMS*SMS2
      CMS3=CMS2*CMS-SMS2*SMS
C
      SMS4=CMS2*SMS2
      SMS4=SMS4+SMS4
      CMS4=CMS2*CMS2-SMS2*SMS2
      GOTO 15
C
C   FOR BISECTING GEOMETRY
10    SMS=SMP
      CMS=CMP
      SMS2=SMP2
      CMS2=CMP2
      SMS3=SMP3
      CMS3=CMP3
      SMS4=SMP4
      CMS4=CMP4
C
15    SXP11=CPP*SMP+SPP*CMP
      CXP11=CPP*CMP-SPP*SMP
      SXS11=CPS*SMS+SPS*CMS
      CXS11=CPS*CMS-SPS*SMS
C
      SXP22=CPP2*SMP2+SPP2*CMP2
      CXP22=CPP2*CMP2-SPP2*SMP2
      SXS22=CPS2*SMS2+SPS2*CMS2
      CXS22=CPS2*CMS2-SPS2*SMS2
C
      SXP33=CPP3*SMP3+SPP3*CMP3
      CXP33=CPP3*CMP3-SPP3*SMP3
      SXS33=CPS3*SMS3+SPS3*CMS3
      CXS33=CPS3*CMS3-SPS3*SMS3
C
      SXP44=CPP4*SMP4+SPP4*CMP4
      CXP44=CPP4*CMP4-SPP4*SMP4
      SXS44=CPS4*SMS4+SPS4*CMS4
      CXS44=CPS4*CMS4-SPS4*SMS4
C
      SXP21=CPP2*SMP+SPP2*CMP
      CXP21=CPP2*CMP-SPP2*SMP
      SXS21=CPS2*SMS+SPS2*CMS
      CXS21=CPS2*CMS-SPS2*SMS
C
      SXP31=CPP3*SMP+SPP3*CMP
      CXP31=CPP3*CMP-SPP3*SMP
      SXS31=CPS3*SMS+SPS3*CMS
      CXS31=CPS3*CMS-SPS3*SMS
C
      SXP41=CPP4*SMP+SPP4*CMP
      CXP41=CPP4*CMP-SPP4*SMP
      SXS41=CPS4*SMS+SPS4*CMS
      CXS41=CPS4*CMS-SPS4*SMS
C
C
      ROWJ(1)=SPP
      ROWJ(2)=SPP2
      ROWJ(3)=SPP3
      ROWJ(4)=SPP4
      ROWJ(5)=SPP5
      ROWJ(6)=SPP6
C
      ROWJ(7)=CPP
      ROWJ(8)=CPP2
      ROWJ(9)=CPP3
      ROWJ(10)=CPP4
      ROWJ(11)=CPP5
      ROWJ(12)=CPP6
C
      ROWJ(13)=SMP
      ROWJ(14)=SMP2
      ROWJ(15)=SMP3
      ROWJ(16)=SMP4
C
      ROWJ(17)=CMP
      ROWJ(18)=CMP2
      ROWJ(19)=CMP3
      ROWJ(20)=CMP4
C
      ROWJ(21)=SXP11
      ROWJ(22)=SXP21
      ROWJ(23)=SXP31
      ROWJ(24)=SXP41
      ROWJ(25)=SXP22
      ROWJ(26)=SXP33
      ROWJ(27)=SXP44
C
      ROWJ(28)=CXP11
      ROWJ(29)=CXP21
      ROWJ(30)=CXP31
      ROWJ(31)=CXP41
      ROWJ(32)=CXP22
      ROWJ(33)=CXP33
      ROWJ(34)=CXP44
C
      ROWJ(35)=SPS
      ROWJ(36)=SPS2
      ROWJ(37)=SPS3
      ROWJ(38)=SPS4
      ROWJ(39)=SPS5
      ROWJ(40)=SPS6
C
      ROWJ(41)=CPS
      ROWJ(42)=CPS2
      ROWJ(43)=CPS3
      ROWJ(44)=CPS4
      ROWJ(45)=CPS5
      ROWJ(46)=CPS6
C
      ROWJ(47)=SMS
      ROWJ(48)=SMS2
      ROWJ(49)=SMS3
      ROWJ(50)=SMS4
C
      ROWJ(51)=CMS
      ROWJ(52)=CMS2
      ROWJ(53)=CMS3
      ROWJ(54)=CMS4
C
      ROWJ(55)=SXS11
      ROWJ(56)=SXS21
      ROWJ(57)=SXS31
      ROWJ(58)=SXS41
      ROWJ(59)=SXS22
      ROWJ(60)=SXS33
      ROWJ(61)=SXS44
C
      ROWJ(62)=CXS11
      ROWJ(63)=CXS21
      ROWJ(64)=CXS31
      ROWJ(65)=CXS41
      ROWJ(66)=CXS22
      ROWJ(67)=CXS33
      ROWJ(68)=CXS44
C
      IF(.NOT.TCOR.OR.NCY.EQ.1) GOTO 20
C
      ST2=CT*ST
      ST2=ST2+ST2
      CT2=CT*CT-ST*ST
C
      ST3=CT*ST2+CT2*ST
      CT3=CT*CT2-ST*ST2
C
      ST4=CT2*ST2
      ST4=ST4+ST4
      CT4=CT2*CT2-ST2*ST2
C
      ST5=CT2*ST3+CT3*ST2
      CT5=CT2*CT3-ST2*ST3
C
C
      ROWJ(69)=ST
      ROWJ(70)=ST2
      ROWJ(71)=ST3
      ROWJ(72)=ST4
      ROWJ(73)=ST5
C
      ROWJ(74)=CT
      ROWJ(75)=CT2
      ROWJ(76)=CT3
      ROWJ(77)=CT4
      ROWJ(78)=CT5
C
20    RETURN
      END
C
C
C
C
CODE FOR AFACT
      SUBROUTINE AFACT (PS1,PS2,PS3,ABSFAC)
C     *************************************
C
C   ROUTINE TO CALCULATE ABSORPTION FACTOR
C
      LOGICAL TCOR
      COMMON /NORMAL/ ANORM(44,44),ATB(44),ROWJ(88),TERMS(44)
      COMMON /DRVR/ LI,LD,LO,lf,lp,ncy,NSHAPE,NACOEF,NBCOEF,SFMU,TCOR
     1 ,IMAP
C
C
      PS1=1.0
      PS2=1.0
      PS3=1.0
C
      DO 10 J=1,NACOEF
      JJ=J+NACOEF
      PS1=PS1 + TERMS(J)*ROWJ(J)
      PS2=PS2 + TERMS(J)*ROWJ(JJ)
10    CONTINUE
C
      IF(.NOT.TCOR.OR.NCY.LE.2) GOTO 30
C
      NSTART=NACOEF+1
      DO 20 J=NSTART,NSHAPE
      JJ=J+NACOEF
      PS3=PS3 + TERMS(J)*ROWJ(JJ)
20    CONTINUE
C
30    ABSFAC = PS1*PS2*PS3
C
C
      RETURN
      END
C
C
C
C
C
C
C
C
CODE FOR RES
      SUBROUTINE RES (NF)
C     *******************
C
C  ROUTINE TO ACCUMULATE RESIDUAL INFORMATION
C
C
      LOGICAL TCOR
      REAL MU
      COMMON /REFL/ FC,FO,FM,PHI(2),MU(2),SINTH,COSTH
      COMMON /DRVR/ LI,LD,LO,lf,lp,ncy,NSHAPE,NACOEF,NBCOEF,SFMU,TCOR
     1 ,IMAP
      COMMON /SRES/ NUMREF,SUMRES,SUMFS,SUMRSQ,SUMFSQ
C
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XTAPES.INC'
      IF(NF.NE.-1) GOTO 100
C
C  NF=-1      INITIALIZE
      NUMREF=0
      SUMRES=0.0
      SUMFS=0.0
      SUMRSQ=0.0
      SUMFSQ=0.0
      RETURN
C
100   IF(NF.NE.0) GOTO 200
C
C  NF=0       ADD IN THIS REFLECTION
      NUMREF=NUMREF+1
      SUMFS=SUMFS + FC
      SUMFSQ=SUMFSQ + FC*FC
      RESID=ABS( FC-FM )
      SUMRES=SUMRES + RESID
      SUMRSQ=SUMRSQ + RESID*RESID
      RETURN
C
C  NF=1/2       END      REPORT RESULTS
200   CONTINUE
      RM=SUMRES/SUMFS
      RMS=SQRT(SUMRSQ/SUMFSQ)
      WRITE(CMON,210) NUMREF, RM , RMS
      IF (NF .EQ.2) CALL XPRVDU(NCVDU, 3,0)
      WRITE(NCAWU, '(A)') (CMON(II )(:),II=1,3)
      IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') (CMON( II)(:),II=1,3)
210   FORMAT(' For the',I6,
     +' reflections'/' the relative residual was ',F6.4,
     +'   and the relative rms residual was ',F6.4/)
      RETURN
      END
C
C
C
C
CODE FOR ABSPRI
      SUBROUTINE ABSPRI (MUMIN,MUMAX,THMAX)
C     *************************************
C
C
C   PRINT ABSORPTION SURFACE AND THETA CURVE
C
C
      INCLUDE 'TSSCHR.INC'
      LOGICAL TCOR
      REAL MU,MUMIN,MUMAX,A(18)
      COMMON /NORMAL/ ANORM(44,44),ATB(44),ROWJ(88),TERMS(44)
      COMMON /REFL/ FC,FO,FM,PHI(2),MU(2),SINTH,COSTH
      COMMON /DRVR/ LI,LD,LO,lf,lp,ncy,NSHAPE,NACOEF,NBCOEF,SFMU,TCOR
     1 ,IMAP
C
      INCLUDE 'STORE.INC'
      INCLUDE 'ISTORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'UFILE.INC'
      INCLUDE 'XSSCHR.INC'
      INCLUDE 'XTAPES.INC'
      INCLUDE 'QSTORE.INC'
C
c----- djwnov99 - set ioufil = 1 for now - make parmeter later
      DIMENSION KDEV(4)
      data ioufil / 1/
      DATA DTOR/0.0174533/
C
C   PRINT PHI AT INTERVALS OF 10 DEGREES
C   AND MU AT INTERVALS OF 5 DEGREES
      IMAX=MUMAX/5. + 0.8
      IMIN=MUMIN/5. - 0.8
      MRANGE=IMAX-IMIN + 1
      MUS=IMAX*5
      MUF=IMIN*5
C
CDJW99[  CREATE SCRATCH AREA FOR MAP
      KMAP = KSTALL(36 * MRANGE)
      CALL XZEROF (STORE(KMAP), 36 * MRANGE)
      IF (IMAP .GE. 1) THEN
       REWIND MT1
       WRITE (MT1) 'INFO DOWN, ACROSS AND SECTION'
       WRITE (MT1) 'TRAN', (STORE(I),I=KMAP,KMAP+11)
       WRITE (MT1) 'CELL', (STORE(I),I=KMAP,KMAP+5)
       WRITE (MT1) 'L14 ', (STORE(I),I=KMAP,KMAP+11)
       WRITE (MT1) 'SIZE', 36, MRANGE, 1
      ENDIF
cdjwnov99 - pinched from richards slant bodge
      IF (IOUFIL .GT. 0 ) THEN
           CALL XMOVEI(KEYFIL(1,23), KDEV, 4)
           CALL XRDOPN(6, KDEV , CSSMAP, LSSMAP)
1651       FORMAT(A)
1652       FORMAT(F15.8)
1653       FORMAT(I8)
           WRITE (NCFPU1,1651) 'INFO  DOWN, ACROSS AND SECTION '
           WRITE (NCFPU1,1651) 'TRAN'
           WRITE (NCFPU1,1652) (0.0,I=1,12)
           WRITE (NCFPU1,1651) 'CELL'
           WRITE (NCFPU1,1652) (0.0,I=1,6)
           WRITE (NCFPU1,1651) 'L14 '
           WRITE (NCFPU1,1652) (0.0,I=1,12)
           WRITE (NCFPU1,1651) 'SIZE'
           WRITE (NCFPU1,1653) 36, MRANGE, 1
      ENDIF
      ISTORE(KMAP) = 36
      ISTORE(KMAP+1) = 1
CDJW99]
C
      DO 100 J=1,2
      NPS=(J-1)*180
      NPF=NPS+170
CDJW99[
      MPS = NPS/10
CDJW99]
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,50)NPS,NPF,MUF,MUS,(JJ,JJ=NPS,NPF,10)
50    FORMAT(//' ABSORPTION SURFACE FOR PHI =',I4,' --->',I4,
     +' WITH MU RANGE =',I3,' --->',I3, / 6X,18(I3,2X) )
      ENDIF
C
      DO 90 I=1,MRANGE
      II=(IMAX - (I-1))*5
      RMU=II
      IF(II.GT.0) RMU=SQRT(RMU)*SFMU
      IF(II.LT.0) RMU=-SQRT(ABS(RMU))*SFMU
      MU(1)=RMU
      MU(2)=RMU
C
      DO 80 K=1,18
      KK=(K-1)*10 + NPS
      PHI(1)=KK
      PHI(2)=KK
C
      CALL ABSTOR
      CALL AFACT (PS1,PS2,PS3,ABSFAC)
      A(K)=PS1*PS2
80    CONTINUE
C
CDJW99[
      JMAP = KMAP +(I-1)*36 + MPS
      CALL XMOVE(A(1), STORE(JMAP), 18)
CDJW99]
      IF (ISSPRT .EQ. 0)  WRITE(NCWU,200)II,A
200   FORMAT(I4,1X,18F5.2)
90    CONTINUE
C
100   CONTINUE
CDJW99[^
      MPS = 36 * MRANGE
      JMAP = KSTALL(36 * MRANGE)
c----- TRANSPOSE MAP FOR BETTER VIEWING
       DO 101 I = KMAP,KMAP-1+ MPS
       STORE(I) = 100.*STORE(I)
101    CONTINUE
       CALL XTRANS (STORE(KMAP), STORE(JMAP), 36, MRANGE)
      IF (IMAP .GE. 1) THEN
       WRITE(MT1) MPS, (STORE(K),K=JMAP, JMAP+MPS-1)
      ENDIF
cdjwnov99
      IF (IOUFIL .GT. 0) THEN
2801    FORMAT (A)
2802    FORMAT (I8)
2803    FORMAT (F15.8)
        WRITE(NCFPU1,2801) 'BLOCK'
        WRITE(NCFPU1,2802) mps
        WRITE(NCFPU1,2803) (STORE(K),K=JMAP, JMAP+MPS-1)
C
        WRITE (NCFPU1,1651) 'LIST5'
        WRITE (NCFPU1,1653) 0, 0
C Close the map file
        CALL XMOVEI(KEYFIL(1,23), KDEV, 4)
        CALL XRDOPN(7, KDEV , CSSMAP, LSSMAP)
      ENDIF
CDJW99]
C
      IF(.NOT.TCOR) GOTO 500
C
C   PRINT THETA DEPENDENT CURVE AT 5 DEGREE INTERVALS
      IMAX=THMAX/5. + 0.8
      MRANGE=IMAX+1
      MEND=IMAX*5
C
      DO 350 I=1,MRANGE
      THET=(I-1)*5.
      SINTH=SIN(THET*DTOR)
      COSTH=COS(THET*DTOR)
      CALL ABSTOR
      CALL AFACT(PS1,PS2,PS3,ABSFAC)
      A(I)=PS3
C
350   CONTINUE
C
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,400) MEND,(I,I=0,MEND,5)
400   FORMAT(/' Curve for THETA = 0 --->',I3,/3X,18(I7))
        WRITE(NCWU,410) (A(I),I=1,MRANGE)
410   FORMAT(5X,18F7.3)
      ENDIF
C
C
500   RETURN
      END
C
C
C
C
CODE FOR ABSPLY
      SUBROUTINE ABSPLY ( NREF, IACTN, IMODE, IULN)
C     ************************
C
C
C------ IACTN -1 DONT WRITE THE CORRECTED DATA TO DISK
C              0 TRY TO UPDATE THE EXISTING LIST 6
C              1 CREATE A NEW LIST 6
C
C
      LOGICAL TCOR
      REAL MU
C
      DIMENSION IBUF(7)
      INCLUDE 'ICOM30.INC'
      INCLUDE 'ISTORE.INC'
C
      COMMON /NORMAL/ ANORM(44,44),ATB(44),ROWJ(88),TERMS(44)
      COMMON /REFL/ FC,FO,FM,PHI(2),MU(2),SINTH,COSTH
      COMMON /DRVR/ LI,LD,LO,lf,lp,ncy,NSHAPE,NACOEF,NBCOEF,SFMU,TCOR
     1 ,IMAP
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XDISCS.INC'
      INCLUDE 'XTAPES.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST06.INC'
      INCLUDE 'XLST30.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QLST30.INC'
C
C----- INITIALISE MIN AND MAX CORRECTION
      AMIN =  10000.
      AMAX = -10000.
      SFACT = STORE(L5O)
C
cdjwapr08
      if (iactn . ne. -1 ) then
       IF (IMODE .EQ. 0) THEN
            WRITE(CMON,110) 'Fo'
       ELSE IF (IMODE .EQ. 1) THEN
            WRITE(CMON,110) 'Fc'
       ELSE
            WRITE(CMON,111)
       ENDIF
       CALL XPRVDU(NCVDU, 1,0)
       WRITE(NCAWU, '(A)') CMON( 1)(:)
       IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') CMON(1 )(:)
110    FORMAT ('       DIFABS correction applied to ', A)
111    FORMAT (' Transfering correction from Fc to Fo')
      endif
C
C
C      READ LIST 6 AGAIN
      CALL XFAL06(IULN,0)
C     START WRITING NEW LIST 6
      IF (IACTN .EQ. 1) THEN
      WRITE(NCAWU, 120)
      IF (ISSPRT .EQ. 0)  WRITE(NCWU, 120)
120    FORMAT( ' Creating new reflection list')
C----- FIND OUT HOW MUCH ROOM WE NEED
        LN = 6
        I =  KRCLI (LN,IBUF(1),IBUF(2),IBUF(3),IBUF(4),IBUF(5),
     1                 IBUF(6))
        LENTOT = (IBUF(3) - IBUF(2)) + 1
        CALL XDACVI (IBUF(1),IBUF(2),IBUF(3))
        LSTLEN = (LENTOT / IBUF(1)) + 1
        IEXTN =  KDAFRE (NCDFU, -1, LSTLEN)
      IF (ISSPRT .EQ. 0) WRITE(NCWU, 150) IEXTN
        WRITE(NCAWU, 150) IEXTN
150     FORMAT (/,' Disc file extended by ', I6, ' records')
        CALL XSTR06( IULN, 0, 0, 0, 0)
      ELSE IF (IACTN .EQ. 0) THEN
        CALL XSTR06 (IULN, 0, 1, -1, 0)
      END IF
C
      NTOT=0
      ATOT=0.
      NSET=1
      SFMUSQ=SFMU*SFMU
C     SET REFLECTION PROCESSED TO ZERO
C
C   INITIALIZE RESIDUALS
      NF=-1
      CALL RES(NF)
C
C
      NF=0
      REWIND LF
C     START FETCHING THE REFLECTIONS
20    CONTINUE
      IF ( KLDRNR(0) .LE. -1) GOTO 100
C
      FO = STORE(M6+3)
      FOBS = FO
      SIGF = STORE(M6+12)
      FC = STORE(M6+5) * SFACT
C
      IF (IMODE .LE. 1) THEN
      READ(LF) IUSED,FC,FO,PHI,MU,SINTH,COSTH
      IF(FOBS.LE.0.0) GOTO 30
C
      CALL ABSTOR
      CALL AFACT(PS1,PS2,PS3,A)
      IF(A.GT.AMIN) GOTO 2
      APHINP=PHI(1)
      APHINS=PHI(2)
      AMUNP=MU(1)*ABS(MU(1))/SFMUSQ
      AMUNS=MU(2)*ABS(MU(2))/SFMUSQ
2     IF(A.LT.AMAX) GOTO 4
      APHIXP=PHI(1)
      APHIXS=PHI(2)
      AMUXP=MU(1)*ABS(MU(1))/SFMUSQ
      AMUXS=MU(2)*ABS(MU(2))/SFMUSQ
4     CONTINUE
      ELSE
            A = 1. / STORE(M6+27)
            IUSED = 1
      ENDIF
      AMAX = MAX (AMAX, A)
      AMIN = MIN (AMIN, A)
      ATOT = ATOT + A
      NTOT = NTOT + 1
C
C
      IF(IUSED.NE.1) GOTO 10
      FM=FO*A
      CALL RES(NF)
C
10     CONTINUE
30    CONTINUE
      IF (IMODE .EQ. 0) THEN
C----- ENSURE FC MODIFIER IS UNITY
       STORE(M6+27) =  1.0
       STORE(M6+3) = STORE(M6+3) * A
       STORE(M6+12) = STORE(M6+12) * A
      ELSE IF (IMODE .EQ. 1) THEN
C----- STORE Fc MODIFIER
       STORE(M6+27) =  A
      ELSE
C----- MOVE CORRECTION FROM FC TO FO
       STORE(M6+27) = 1.0
       STORE(M6+3) = STORE(M6+3) * A
       STORE(M6+12) = STORE(M6+12) * A
      ENDIF
      NREF=NREF+1
C
C
C     STORE THIS REFLECTION
      IDWZAP = 0
      IF (IACTN .GE. 0) CALL XSLR(IDWZAP)
C     LOOP FOR NEXT REFLECTION
      GO TO 20
100   CONTINUE
C
C     CLOSE NEW LIST 6
      IF (IACTN .GE. 0) CALL XERT(IULN)
C
C
C   REPORT RESIDUALS AFTER CORRECTION
      IF (ISSPRT .EQ. 0) WRITE(NCWU,300)
300   FORMAT(//' RESIDUALS AFTER CORRECTION')
      NF=2
      CALL RES(NF)
C
C
C   REPORT CORRECTION SUMMARY
      AVER=ATOT/NTOT
      IF (IMODE .LE.1 ) THEN
         WRITE ( CMON,197) NTOT
         WRITE(NCAWU, '(A)') CMON(1 )(:)
         IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') CMON(1 )(:)
197   FORMAT(I6,' Reflections corrected')
         WRITE ( CMON,198) AMIN,APHINP,AMUNP
         WRITE(NCAWU, '(A)') CMON( 1)(:)
         IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') CMON(1 )(:)
         WRITE ( CMON,199) APHINS,AMUNS
         WRITE(NCAWU, '(A)') CMON(1 )(:)
         IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') CMON(1 )(:)
198   FORMAT( ' Minimum absorption correction =',F6.3,
     2        5X,'at  PHI(P)=',F5.1,' MU(P)=',F5.1 )
199   FORMAT(47X,    'PHI(S)=',F5.1,' MU(S)=',F5.1 )
         WRITE ( CMON,200) AMAX,APHIXP,AMUXP
         WRITE(NCAWU, '(A)') CMON(1 )(:)
         IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') CMON(1 )(:)
         WRITE ( CMON,201) APHIXS,AMUXS,AVER
         WRITE(NCAWU, '(A)') (CMON(II )(:),II=1,2)
         IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') (CMON(II )(:),II=1,2)
200   FORMAT( ' Maximum absorption correction =',F6.3,
     2        5X,'at  PHI(P)=',F5.1,' MU(P)=',F5.1)
201   FORMAT(47X,    'PHI(S)=',F5.1,' MU(S)=',F5.1,/
     2 ' Average absorption correction =',F6.3)
C----- WRITE MINIMUM INFO TO VDU
         WRITE ( CMON,202) NTOT, AVER, AMIN, AMAX
         CALL XPRVDU(NCVDU, 2,0)
      ELSE
         WRITE ( CMON,202) NTOT, AVER, AMIN, AMAX
         CALL XPRVDU(NCVDU, 2,0)
202      FORMAT( I6, ' Reflections corrected.',
     +      ' Average correction =',F6.3,' (On Fo)',
     +   /'   Minimum correction =',F6.3,
     +      ' Maximum correction =',F6.3)
      ENDIF
C
      IF (IACTN .GE. 0) THEN
C----- UPDATE AND STORE LIST 30
        CALL XFAL30
        STORE(L30AB + 6) = AMIN
        STORE(L30AB + 7) = AMAX
        ISTORE(L30AB + 8) = 1
        CALL XWLSTD ( 30, ICOM30, IDIM30, -1, -1)
      ENDIF
C
      RETURN
      END
C
C
C
C
C
C
CODE FOR CELL
      SUBROUTINE CELL
C     ***************
C
C   GENERAL SUBROUTINE TO CALCULATE CELL PARAMETERS FROM THE
C   ORIENTATION MATRIX
C
      INCLUDE 'ISTORE.INC'
      INCLUDE 'STORE.INC'
      LOGICAL TCOR
      COMMON /DRVR/ LI,LD,LO,lf,lp,ncy,NSHAPE,NACOEF,NBCOEF,SFMU,TCOR
     1 ,IMAP
      COMMON/ORIENT/TWOTHZ,OMZ,PHIZ,PLUS(3),IPOS,IDIFRT,ORIENT(3,3),DST
      COMMON /CELLP/ TA,TB,TC,ZA,ZB,ZC
      REAL DIRECT(3,3),W(3),X(3),Y(3),Z(3)
      INCLUDE 'XLST01.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XTAPES.INC'
C
      INCLUDE 'QSTORE.INC'
C
      DATA RAD / 57.2957795 /
C
      CALL AMI3(ORIENT,DIRECT,DET)
C
      IFAIL = 0
      DO 11 I=1,3
      W(I)=0.
      Y(I)=0.
      DO 12 J=1,3
      W(I)=W(I)+ORIENT(J,I)**2
      Y(I)=Y(I)+DIRECT(I,J)**2
12    CONTINUE
      Y(I)=SQRT(Y(I))
      IF (ABS( Y(I) - STORE(L1P1+I-1)) .GT. .01) IFAIL = I
11    CONTINUE
C
      DO 13 I=1,3
      J=I+1
      K=J+1
      IF(J.GT.3)J=J-3
      IF(K.GT.3)K=K-3
      X(I)=0.
      Z(I)=0.
      DO 14 L=1,3
      X(I)=X(I) + ORIENT(L,J)*ORIENT(L,K)
      Z(I)=Z(I) + DIRECT(J,L)*DIRECT(K,L)
14    CONTINUE
      X(I)=2*X(I)
      COSZ=Z(I)/Y(J)/Y(K)
      SINZ=SQRT(1. - COSZ*COSZ)
      Z(I) = ATAN2( SINZ, COSZ)
      IF (ABS(Z(I) - STORE(L1P1+I+2)) .GT. .1) IFAIL = I + 3
      Z(I) = Z(I) * RAD
      IF(Z(I).LT.0.)Z(I)=Z(I)+180.
13    CONTINUE
C
      TA=W(1)
      TB=W(2)
      TC=W(3)
      ZA=X(1)
      ZB=X(2)
      ZC=X(3)
C
      IF (IFAIL .NE. 0) THEN
       WRITE(CMON,202) I
       CALL XPRVDU(NCVDU, 1,0)
       WRITE(NCAWU, '(A)') CMON(1 )(:)
       IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') CMON(1 )(:)
202    FORMAT(' WARNING - Cell/orientation matrix mis-match',I2)
       WRITE(CMON,200) (STORE(J),J = L1P1, L1P1+2),
     1 (STORE(J)*RAD,J = L1P1+3, L1P1+5)
200    FORMAT(' LIST 1  CELL', 6F 8.3)
       CALL XPRVDU(NCVDU, 1,0)
       WRITE(NCAWU, '(A)') CMON(1 )(:)
       IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') CMON(1 )(:)
       WRITE(CMON,201) Y,Z
201    FORMAT(' LIST 13 CELL', 6F8.3)
       CALL XPRVDU(NCVDU, 1,0)
       WRITE(NCAWU, '(A)') CMON(1 )(:)
       IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') CMON(1 )(:)
      ENDIF
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,100)((ORIENT(I,J),J=1,3),I=1,3),Y,Z
100   FORMAT(/' Orientation Matrix:'/,3(5X,3F10.6/),/
     +' Unit Cell Parameters:'/,'  a=',F7.3,'  b=',F7.3,'  c=',F7.3,
     +'   alpha=',F7.2,'  beta=',F7.2,'  gamma=',F7.2/)
      ENDIF
C
      RETURN
      END
C
C
C
C
C
CODE FOR ANGLES
      SUBROUTINE ANGLES (OMEGA,PHI,CHI,X,IERR)
C     ****************************************
C
C.... CALCULATES DIFFRACTOMETER SETTING ANGLES GIVEN OMEGA
C
      COMMON/ORIENT/TWOTHZ,OMZ,PHIZ,PLUS(3),IPOS,IDIFRT,ORIENT(3,3),DST
      DIMENSION X(3),E(3)
      DATA RAD/57.2957795/
      DATA PI/3.1415926563/
C
      DO 14 I=1,3
      E(I)=0.
      DO 12 J=1,3
   12 E(I)=E(I)+ORIENT(I,J)*X(J)
   14 E(I)=E(I)/DST
      IERR=0
C
      IF(IPOS.NE.1) GO TO 36
C
C     CHI=90, DATA COLLECTED IN PARALLEL POSITION.
C
      CHI=90.
      IF(ABS(E(3)).GT.1.) GO TO 64
      OMEGA = ACOS ( ABS( E(3) ) )
      IF(-E(3).GE.0.) GO TO 20
      OMEGA = PI - OMEGA
   20 CPHI=E(1)/SIN(OMEGA)
      SPHI=-E(2)/SIN(OMEGA)
      IF (CPHI.GT.1..OR.SPHI.GT.1.) GO TO 64
      CALL ARCTAN (PHI,CPHI,SPHI)
      IF ( E(1) .LE. 0.0 ) GO TO 26
      IF ( E(2) ) 30 , 30 , 28
   26 IF (E(2))34,34,32
   28 PHI=360. - ACOS(CPHI)*RAD
      GO TO 35
   30 PHI=ACOS(CPHI)*RAD
      GO TO 35
C*****THIS MAY BE IN ERROR BECAUSE OF THE WAY ARCTAN WORKS:
   32 PHI= 180. + PHI
      GO TO 35
   34 PHI=180. - PHI
   35 OMEGA=OMEGA*RAD
      GO TO 62
C
   36 IF(IDIFRT.NE.3) GO TO 80
C
C    DATA COLLECTED IN BISECTING POSITION.  (PICKER GEOMETRY).
C
      C=ABS(COS(OMEGA/RAD))
      IF (C-0.000001) 38,38,42
   38 IF(ABS(E(3))-0.000001) 40,40,64
   40 CHI=0.0
      CPHI=E(1)
      SPHI=-E(2)
      GO TO 58
   42 SCHI=-E(3)/C
      IF(ABS(SCHI).GT.1.0) SCHI=SIGN(1.0,SCHI)
      A=SIN(OMEGA/RAD)
      CCHI=SQRT(1.0-SCHI**2)
      CALL ARCTAN (CHI,CCHI,SCHI)
      B=C*CCHI
      DENO=A**2+B**2
      IF (DENO-0.000001) 46,46,48
   46 PHI=0.0
      GO TO 62
   48 CPHI=(A*E(1)+B*E(2))/DENO
      IF(ABS(CPHI).GT.1.0) CPHI=SIGN(1.0,CPHI)
      IF (B-0.0000001) 52,52,54
   52 SPHI=-E(2)/A
      GO TO 56
   54 SPHI=(E(1)-A*CPHI)/B
   56 IF(ABS(SPHI).GT.1.0) SPHI=SIGN(1.0,SPHI)
   58 CALL ARCTAN (PHI,CPHI,SPHI)
   62 OMEGA=OMZ+OMEGA/PLUS(1)
      GO TO 90
   64 IERR=1
      RETURN
C
C     DATA COLLECTED IN BISECTING POSITION.  (NONIUS & SYNTEX GEOMETRY)
C
   80 OMEGA=0.0
      C=1.0
      A=0.0
      SCHI=-E(3)
      IF(ABS(SCHI).GT.1.0) SCHI=SIGN(1.0,SCHI)
C
C     COS(CHI) ALWAYS POSITIVE IF COLLECTING IN LOWER
C     HEMISPHERE  (-90<CHI<+90).
C
      CCHI=SQRT(1.0-SCHI**2)
      CALL ARCTAN (CHI,CCHI,SCHI)
      IF(CCHI-0.0001) 46,46,84
   84 CPHI=E(2)/CCHI
      IF(ABS(CPHI).GT.1.0) CPHI=SIGN(1.0,CPHI)
      SPHI=E(1)/CCHI
      IF(ABS(SPHI).GT.1.0) SPHI=SIGN(1.0,SPHI)
      CALL ARCTAN (PHI,CPHI,SPHI)
   90 PHI=PHIZ+PHI/PLUS(2)
      CHI=CHI/PLUS(3)
      RETURN
      END
C
C
C
C
CODE FOR ARCTAN
      SUBROUTINE ARCTAN (A,COSA,SINA)
C     *******************************
C
      DATA RAD/57.2957795/
C
C   CALCULATES ARC TAN IN DEGREES.
C
      IF(COSA) 10,20,10
10    A=ATAN(SINA/COSA)*RAD
      IF(COSA) 30,30,40
20    A=90.0
      IF(SINA) 30,30,40
30    A=A+180.0
40    RETURN
      END
C
C
C
CODE FOR NORM
      SUBROUTINE NORM (A)
C     *******************
C
      DO 14 I=1,10
      IF (A) 12,16,16
12    A=A+360.
14    CONTINUE
16    A=AMOD(A,360.0)
      RETURN
      END



CODE FOR SOLVEN
      SUBROUTINE SOLVEN
C Added line to test the CVS system problems.
C     *****************
C----- THE ROUTINES IN THIS FILE ARE FROM THE HARWELL SUBROUTINE
C      LIBRARY, AND HAVE BEEN INCORPORATED INTO CRYSTALS IN
C      CONJUNCTION WITH THE DIFABS ROUTINE OF NIGEL WALKER
C
C
      LOGICAL TCOR
      REAL VEC(44,44),EIG(44),UM1(44),WORK(220),RDASH(44),SDASH(44)
      COMMON /NORMAL/ ANORM(44,44),ATB(44),ROWJ(88),TERMS(44)
      COMMON /SOLVE/ NSIZE,FILTER,FILSTA,FILDEC,FILEND
      COMMON /DRVR/ LI,LD,LO,LF,LP,NCY,NSHAPE,NACOEF,NBCOEF,SFMU,TCOR
     1 ,IMAP
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XIOBUF.INC'
C   FOLLOWING EQUIVALENCING TO SAVE SOME SPACE
      EQUIVALENCE (WORK(1),RDASH(1)),(WORK(45),SDASH(1))
      EQUIVALENCE (ROWJ(1),EIG(1)),(ROWJ(45),UM1(1))
C
C Pre-scale normal matrix.
C Invert normal matrix using HARWELL s/r for eigenvalue inversion.
C
C Get inverse diagonal scaling matrix UM1 (U**-1) from normal matrix.
C The elements are SQRT(diagonal element of normal matrix)
C
C
      AINFL=FILSTA - (NCY-1)*FILDEC
      IF(AINFL.LT.FILEND)AINFL=FILEND
C      WRITE(LP,1030)FILTER,AINFL
C1030  FORMAT(/' Eigenvalue filtering; filter value=',F10.6,
C     +',  inflation constant=',F10.6)
C
      DO 10 I=1,NSHAPE
      UM1(I)=1.0
      IF(ANORM(I,I).NE.0.0) UM1(I)=1.0/SQRT(ANORM(I,I))
10    CONTINUE
C
C Scale matrix and vector(ATB) by UM1
C
      DO 20 J=1,NSHAPE
      UM1J=UM1(J)
      ATB(J)=ATB(J)*UM1J
      DO 30 K=1,J
      ANORM(J,K)=ANORM(J,K)*UM1(K)*UM1J
30    CONTINUE
20    CONTINUE
C
C Solve normal equations, EA06C returns eigenvectors and eigenvalues
C
C      CALL EA06C(ANORM,EIG,VEC,NSHAPE,NSIZE,NSIZE,WORK)
C
C Replace Harwell routine with LAPACK one. Differences: The LAPACK
C one overwrites the normal matrix with the eigenvectors. That's OK,
C ANORM isn't used again, as far as I can tell.
C

c      DO I = 1,NSHAPE
c       DO J = 1, NSHAPE          
c        ANORM(I,J) = ANORM(J,I)
c        WRITE(NCWU,'(2I4,F12.3)') I,J,ANORM(I,J)
c       END DO
c      END DO

      INFO=0
      CALL SSYEV('V','L', NSHAPE, ANORM, NSIZE, EIG, WORK, 220, INFO)

      DO I = 1,NSHAPE
       DO J = 1, NSHAPE
        VEC(I,J) = ANORM(I,J)
c        WRITE(NCWU,'(2I4,F12.3)') I,J,ANORM(I,J)
       END DO
      END DO
C
C Write eigenvalues
C
C      WRITE(LP,1000)
C1000  FORMAT(/,' Eigenvalues')
C      WRITE(LP,1010)(EIG(I),I=1,NSHAPE)
C1010  FORMAT(10F8.4)
C
C To diagonalize, premultiply by column eigenvectors
C  VEC is matrix of eignvectors.
C
      DO 40 I=1,NSHAPE
      SUM=0.0
      DO 50 J=1,NSHAPE
      SUM=SUM+VEC(J,I)*ATB(J)
50    CONTINUE
      RDASH(I)=SUM
40    CONTINUE
C
C Solve diagonalization with inflated eigenvalue weighting & filtering
C
      DO 60 I=1,NSHAPE
      SDASH(I)=0.0
      IF(EIG(I).GT.FILTER)SDASH(I)=RDASH(I)/(EIG(I)+AINFL)
60    CONTINUE
C
C Rotate shifts back and rescale using UM1
C
      DO 70 J=1,NSHAPE
      SUM=0.0
      DO 80 I=1,NSHAPE
      SUM=SUM+VEC(J,I)*SDASH(I)
80    CONTINUE
      ATB(J)=SUM*UM1(J)
70    CONTINUE
C
C
C Write coefficient shifts
C
      WRITE(LP,1040)
1040  FORMAT(/,' Coefficient shifts')
      WRITE(LP,1050)(ATB(I),I=1,NSHAPE)
cRIC13:1050  FORMAT(1X,10F8.5)
1050  FORMAT(8(1X,G9.2))
C
C Apply shifts to original defining variables
      DO 90 J=1,NSHAPE
      TERMS(J)=TERMS(J)+ATB(J)
90    CONTINUE
C
C Write coefficients of absorption factor expansion
C
C      WRITE(LP,1020)
C1020  FORMAT(/,' New coefficients')
C      WRITE(LP,*)(TERMS(I),I=1,NSHAPE)
      RETURN
      END



CODE FOR AMI3
      SUBROUTINE AMI3 (A,B,DET)
C     *************************
C
C.... INVERTS ASYMMETRIC 3X3 MATRIX
C
      REAL A(3,3),B(3,3)
C
      B(1,1)=A(2,2)*A(3,3)-A(3,2)*A(2,3)
      B(2,1)=A(2,1)*A(3,3)-A(3,1)*A(2,3)
      B(3,1)=A(2,1)*A(3,2)-A(3,1)*A(2,2)
      DET=A(1,1)*B(1,1)-A(1,2)*B(2,1)+A(1,3)*B(3,1)
      IF (DET) 12,16,12
12    B(1,2)=A(1,2)*A(3,3)-A(3,2)*A(1,3)
      B(2,2)=A(1,1)*A(3,3)-A(3,1)*A(1,3)
      B(3,2)=A(1,1)*A(3,2)-A(3,1)*A(1,2)
      B(1,3)=A(1,2)*A(2,3)-A(2,2)*A(1,3)
      B(2,3)=A(1,1)*A(2,3)-A(2,1)*A(1,3)
      B(3,3)=A(1,1)*A(2,2)-A(2,1)*A(1,2)
      DO 14 I=1,3
      DO 14 J=1,3
      B(I,J)=(-1.)**(I+J)*B(I,J)/DET
14    CONTINUE
C
16    RETURN
      END
C
C
C

