C $Log: list26.F,v $
C Revision 1.27  2013/12/11 16:54:14  rich
C Some mismatched subroutine argument lengths following previous update.f
C
C Revision 1.26  2013/12/08 20:32:26  rich
C Ensure IASYM is passed throughout required routines. Thanks Pascal.
C
C Revision 1.25  2013/11/06 13:52:52  rich
C Fix use of uninit variable
C
C Revision 1.24  2013/09/19 21:35:39  rich
C Change precision of listing output where not important to reduce differences across platforms.
C Important changes - SFLS now uses builtin cos() and sin() functions rather than Chebyshev
C approximations.
C
C Revision 1.23  2012/11/09 15:05:00  rich
C *** empty log message ***
C
C Revision 1.22  2012/08/29 09:53:57  djw
C New format for listing Derivatives
C Values of Uij taken directly from input rather than be computed from derived parameters
C
C Revision 1.21  2012/07/11 14:07:01  djw
C remove debugging prints
C
C Revision 1.20  2011/10/14 13:48:09  djw
C Fix interaction between A-DIST and MEAN and DiIFF restraints
C
C Revision 1.19  2011/10/13 14:41:31  djw
C Add asymmetric distacne restraint
C
C Revision 1.18  2011/09/30 11:20:39  djw
C Add asymmetric vib and Uij restraints
C
C Revision 1.17  2011/05/04 11:28:51  rich
C TODO note.
C
C Revision 1.16  2011/03/21 13:57:21  rich
C Update files to work with gfortran compiler.
C
C Revision 1.15  2010/10/26 09:51:24  djw
C Sort out more writes to NCAWU, provide more output from EXEC directive
C
C Revision 1.14  2009/06/17 13:41:49  djw
C Fix #CHECK HI crash.  Actual error was in wrong values for idjw1 & idjw2 for DELU
C  restraint in LIST 16.  Several messages cleaned up, more diagnostics for error conditions.
C
C Revision 1.13  2005/01/23 08:29:11  rich
C Reinstated CVS change history for all FPP files.
C History for very recent (January) changes may be lost.
C
C Revision 1.2  2004/12/13 16:16:08  rich
C Changed GIL to _GIL_ etc.
C
C Revision 1.1.1.1  2004/12/13 11:16:09  rich
C New CRYSTALS repository
C
C Revision 1.12  2004/03/25 10:16:56  rich
C Fix bug in FORMAT statement when #CHECKing an 'AVERAGE' restraint on
C layer scale factors. Obscure.
C
C Revision 1.11  2003/03/20 16:11:28  rich
C Fix. I accidentally removed a GOTO when clearing out NCAWU writes the other
C week... with disasterous consquences for anyone typing #CHECK.
C
C Revision 1.10  2003/02/26 12:13:27  rich
C Removed some writes to the monitor file, as part of an
C ongoing (quite boring) project.
C
C Revision 1.9  2002/12/05 11:51:51  rich
C Things look better without the debugging messages.
C
C Revision 1.8  2002/12/04 14:31:11  rich
C Reformat output during refinement.
C
C Allow punching to MATLAB files, including restraints.
C
C Tidy some routines.
C
C Revision 1.7  2002/12/02 15:48:54  rich
C XADCPD was looking at PUNCH YES/NO, should have been looking at MATRIX OLD/NEW
C in LIST 33.
C
C Revision 1.6  2001/02/26 10:28:01  richard
C RIC: Added changelog to top of file
C
C
CODE FOR XCHK16
      SUBROUTINE XCHK16
C--CHECK THE VALUES OF THE APPLIED RESTRAINTS
C
C  THIS SUBROUTINE READS DOWN THE LIST 26 AND CALCULATES THE
C  REQUIRED RESTRAINTS.
C
C--THE COMMON BLOCK 'XCNTRL' CONTROLS THE FORMAT OF THE
C  INFORMATION OUTPUT TO THE DISC. WHILE THE LIST IS STILL IN
C  CORE, THE VARIABLES HAVE THE FOLLOWING SIGNIFICANCE :
C
C  LC      BASE ADDRESS OF THE WORK STACK, WHICH HOLDS CONSTANTS
C          AND VARIABLES GENERATED BY THE CODE.
C          THIS VARIABLE SET UP DYNAMICALLY BOTH DURING SYNTAX
C          ANALYSIS AND DURING EXECUTION, AND IS THUS NOT OUTPUT TO
C          DISC.
C  ISTAT2  THIS IS A PRINT CONTROL FLAG :
C
C          -1  PRINT THE CARD IMAGES AS THEY ARE PROCESSED.
C           0  NO PRINTING.
C          +1  PRINT THE CARD IMAGES AND THE GENERATED CODE.
C
C
C      IASYM ASYMMETRIC RESTRAINT
C           1 ASYMMETRYIC
C           0 NORMAL
C
C--THE REMAINING 12 WORDS OF THIS COMMON BLOCK ARE OUTPUT TO THE
C  DISC AND DEFINE THE LOCATIONS AND LENGTH OF THE REMAINING BLOCKS
C  ASSOCIATED WITH THIS INSTRUCTION. IN CORE THE FORMAT OF THIS CONTROL
C  BLOCK IS :
C
C  LCG   ADDRESS IN CORE OF THE HEADER BLOCK FOR THE GENERAL CHAIN.
C        FOR OUTPUT PRODUCED BY THE PARSE ROUTINES, THIS CHAIN CONTAINS
C        ONLY INSTRUCTIONS OR CODE. IN OTHER CASES THE CONTENTS
C        OF THE CHAIN ARE DEFINED BY THE FUNCTION OF THE ROUTINE
C        THAT SET IT UP.
C        (ON THE DISC, THIS VARIABLE IS STORED RELATIVE TO 'LCG',
C        THAT IS AS ZERO).
C  MCG   CURRENT ADDRESS IN CORE OF THE NEXT FREE WORD FOR THE GENERAL,
C        PARAMETER HEADER AND CONSTANT CHAINS. THESE CHAINS MOVE UP THE
C        STORE AND MUST UPDATE 'MCG' AS THEY DO SO.
C  MDCG  CURRENT ADDRESS IN CORE OF THE LAST GENERAL (OR INSTRUCTION)
C        BLOCK INSERTED.
C  NCG   NOT DEFINED.
C        (ON THE DISC, THIS VARIABLE IS SET TO THE TOTAL LENGTH
C        OF ALL THE CHAINS FORMED AT THE BOTTOM OF CORE  -  THE
C        GENERAL, PARAMETER AND CONSTANT CHAINS).
C
C  LCA   ADDRESS IN CORE OF THE FIRST BLOCK ON THE PARAMETER HEADER
C        BLOCK CHAIN.
C        (ON THE DISC, THIS VARIABLE IS STORED WITH ITS ADDRESS
C        SET RELATIVE TO 'LCG').
C  MCA   USED TO PROCESS THE PARAMETER HEADER BLOCK CHAIN.
C  MDCA  USED TO PROCESS THE PARAMETER HEADER BLOCK CHAIN.
C  NCA   NUMBER OF PARAMETER HEADER BLOCKS ON THE CHAIN.
C
C  LCS   ADDRESS IN CORE OF THE CONSTANT AND WORK STACK HEADER BLOCK.
C        (ON THE DISC, THIS VARIABLE IS STORED WITH ITS ADDRESS
C        SET RELATIVE TO 'LCG').
C  MCS   CURRENT ADDRESS OF THE LAST BLOCK INSERTED ON THE CONSTANT
C        CHAIN. THIS MUST BE UPDATED WHEN A NEW BLOCK IS ADDED.
C  MDCS  NEXT FREE ADDRESS IN THE WORK STACK. THIS STACK STARTS AT
C        'LC' AND COMES DOWN THE STORE.
C        (THIS PARAMETER SHOULD BE UPDATED WHENEVER SPACE IS
C        ALLOCATED IN THE WORK STACK).
C
C--DURING ALL OPERATIONS EXCEPT PARSING BY 'KPARSE', THE NEXT FREE
C  LOCATION IS STORED IN 'MCG' AND THE LAST FREE LOCATION IS HELD IN 'LF
C
C--FORMAT OF THE GENERAL CHAIN HEADER BLOCK IS :
C
C  0  ADDRESS OF THE FIRST BLOCK ON THE CHAIN REL. TO 'LCG' OR 'NOWT'.
C  1  TYPE OF OPERATION DESCRIBED BY THIS HEADER BLOCK AND ALL THE
C     OTHER HEADER BLOCKS DEFINED BY THE CONTROL BLOCK.
C  2  NOT DEFINED  -  FOR RESTRAINTS MAY BE A WORK STACK ADDRESS REL.
C                     TO 'LC'..
C  3  NOT DEFINED  -  FOR RESTRAINTS THE WEIGHT.
C  4  NOT DEFINED  -  FOR RESTRAINTS THE INPUT OR OBSERVED VALUE.
C  5  The index of the restraint in the user list `list 16` starting from zero
C
C--THE FORMAT OF THE INSTRUCTION BLOCKS ON THE CHAIN IS :
C
C  0  ADDRESS OF THE NEXT BLOCK RELATIVE TO 'LCG' OR 'NOWT'.
C  1  FUNCTION OF THIS BLOCK.
C  2  ADDRESS IN THE WORK STACK RELATIVE TO 'LC'  -  OPERAND 1.
C  3  ADDRESS IN THE WORK STACK RELATIVE TO 'LC'  -  OPERAND 2.
C  4  ADDRESS IN THE WORK STACK RELATIVE TO 'LC'  -  THE RESULT.
C
C--THE TERMS IN WORDS 2, 3 AND 4 ARE THOSE SET UP BY THE PARSE ROUTINES,
C  AND THE ADDRESSES ARE CONVERTED TO ABSOLUTE VALUES BY 'KLOADR' WHEN
C  THE INFORMATION IS READ BACK FROM THE DISC.
C  THE FORMAT OF THE BLOCK BEYOND WORD 4 IS NOT DEFINED, AND THESE
C  LOCATIONS MAY BE USED AS REQUIRED.
C
C--THE PARAMETER HEADER BLOCKS ARE DIVIDED INTO THOSE FOR ATOMS
C  AND THOSE FOR OVERALL PARAMETERS. THE FORMAT OF THE FORMER IS
C  AS FOLLOWS :
C
C  0   ADDR. OF NEXT HEADER BLOCK REL. TO LCG OR 'NOWT'
C  1   TYPE OF HEADER BLOCK :
C         0  HEADER BLOCK FOR ONE ATOM
C      1024  HEADER BLOCK FOR THE FIRST ATOM OF AN 'UNTIL' SEQUENCE
C  2   ATOM TYPE
C  3   ATOM SERIAL
C  4   NOT USED
C  5   NUMBER OF PARAMETERS
C  6   ADDR. OF FIRST PARAMETER ENTRY REL. TO 'LCG'
C  7   S
C  8   L
C  9   T(X)
C  10  T(Y)
C  11  T(Z)
C  12  ADDR. OF THIS ATOM IN LIST 5 (NOT SET HERE)
C  13  ADDR. OF THIS ATOM IN LIST 12 (NOT SET HERE)
C  14  NOT USED
C  15  ADDR. OF GENERATED PARAMETERS IN WORK STACK REL. TO 'LC'
C  16  ADDR. OF PARAMETERS TO BE USED IN WORK STACK REL. TO 'LC'
C
C--FOR EACH PARAMETER :
C
C  0   LINK TO NEXT PARAMETER REL. TO 'LCG' OR 'NOWT'.
C  1   REL. ADDR. IN LIST 5 (X=5, FOR EXAMPLE).
C  2   PARTIAL DERIVATIVE WHEN CALCULATED.
C  .
C
C--THE INFORMATION FOR EACH OVERALL PARAMETER ALSO CONSISTS OF A HEADER
C  WITH THE SPECIFIED PARAMETER GIVEN AS THE COORDINATE ON THE CHAIN AT
C  WORD 6.
C
C  0   ADDR. OF NEXT HEADER BLOCK REL. TO 'LCG' OR 'NOWT'.
C  1   TYPE :
C      1  OVERALL PARAMETER
C      2  LAYER SCALE
C      3  ELEMENT SCALE
C  2   THE POSITION OF THE PARAMETER IN ITS GROUP
C  3   0.0
C  4   NOT USED
C  5   THE NUMBER OF PARAMETERS ON THE CHAIN GIVEN AT WORD 6.
C  6   ADDRESS OF THE PARAMETER CHAIN REL. TO 'LCG' (STARTS AT WORD 7).
C  7   'NOWT'  LINK TO THE NEXT PARAMETER ON THE CHAIN
C  8   THE POSITION OF THE PARAMETER IN ITS GROUP (STARTING FROM 1).
C  9   NOT USED
C  10  'NOWT'
C  11  'NOWT'
C  12  ADDR. OF THE GROUP CONTAINING THIS PARAMETER IN LIST 5 ('NOWT')
C  13  ADDR. OF THE GROUP CONTAINING THIS PARAMETER IN LIST 12 ('NOWT'
C  14  NOT USED
C  15  ADDR. OF THE PARAMETER IN THE WORK STACK REL. TO 'LC'
C  16  ADDR. OF THE SPACE TO BE USED IN THE WORK STACK REL. TO 'LC'
C
C--THE FORMAT OF THE CONSTANT AND WORK STACK HEADER IS :
C
C  0  ADDRESS OF THE NEXT CONSTANT OR WORK STACK HEADER RELATIVE
C     TO 'LCG' OR 'NOWT'.
C  1  LENGTH OF THIS BLOCK (=6)
C  2  ADDRESS AT WHICH THE WORK STACK BEGINS REL. TO 'LC' OR 'NOWT'
C  3  NUMBER OF WORDS REQUIRED FOR THE WORK STACK.
C  4  ADDRESS OF THE FIRST CONSTANT BLOCK ON THE CONSTANT CHAIN REL. TO
C     'LCG' OR 'NOWT'.
C  5  NUMBER OF CONSTANTS ON THE CONSTANT CHAIN.
C
C--THE FORMAT OF THE CONSTANT CHAIN IS :
C
C  0  ADDRESS OF THE NEXT CONSTANT BLOCK RELATIVE TO 'LCG' OR 'NOWT'
C  1  ADDRESS OF THIS CONSTANT IN THE WORK STACK RELATIVE TO 'LC'.
C  2  THE VALUE TO BE PLACED IN THE WORK STACK.
C
C--THE COMPUTED DERIVATIVES ARE OUTPUT IN A CHAINED LIST TO
C  THE DISC, UNDER THE CONTROL OF THE 'L22PD' VARIABLES. THE VARIABLES
C  ARE USED AS FOLLOWS :
C
C  L22PD   THE ADDRESS OF THE STACK OF OUTPUT PARTIAL DERIVATIVES.
C  M22PD   THE CURRENT OUTPUT DISC ADDRESS.
C  MD22PD  THE NUMBER OF WORDS PER P.D. (=2).
C  N22PD   THE LENGTH OF THE CURRENT P.D. STACK ON DISC.
C
C--THE FORMAT OF THE STACK IS :
C
C  ISTORE(L22PD  )  LENGTH OF THE ENTRY
C   STORE(L22PD+1)  WEIGHT
C   STORE(L22PD+2)  CALC. DELTA
C   STORE(L22PD+3)  OBSERVED VALUE SQUARED
C
C  ISTORE(L22PD+4)  PARAMETER 1
C   STORE(L22PD+5)  P. D. FOR PARAMETER 1
C  .
C  .
C
C----- COMMAND FILE SWITCHES
C
C   1.DEFINE         2.RESTRAIN       3.DISTANCES      4.ANGLES
C   5.VIBRATIONS     6.COMPILER       7.EXECUTION      8.NO
C   9.FUNCTION      10.U(IJ)'S       11.TERM          12.EQUATE
C  13.PLANAR        14.SUM           15.FORM          16.AVERAGE
C  17.LIMIT         18.ENERGY        19.ORIGIN
C
C----- ISTORE (LCG+1) OPERATIONS
C      1  DEFINE    2  RESTRAIN  3  DISTANCE 4
C      5            6  ANGLE     7           8
C      9  VIBRATION 10 EXECUTION 11 NOLIST   12 UIJ
C      13 EQUATE    14 PLANAR    15 SUM      16 FORM
C      17 AVERAGE   18 LIMIT     19 ENERGY   20 ORIGIN
C
C      21 UXZBAR    22 UYZBAR    23 UZZBAR   24 UPERP
C      25 UPERP2    26 UALIGN    27 RIGU     28 ULIJ     
C      29 UPLANE    30 UXXQIV    31 UXYQIV   32 UXZQIV   
C      33 UYYQIV    34 UYZQIV    35 UZZQIV 
C--
C
      use list26_mod
C
      interface 
          subroutine XCVCV(iaxis,iasym, results)
              use list26_mod
              integer, intent(in) :: iaxis
              integer, intent(in) :: iasym
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
      interface 
          subroutine XCVCV2(iasym, results)
              use list26_mod
              integer, intent(in) :: iasym
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
      interface 
          subroutine XCVCW(iaxis,iasym, results)
              use list26_mod
              integer, intent(in) :: iaxis
              integer, intent(in) :: iasym
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
      interface 
          subroutine XCVCA(iasym, results)
              use list26_mod
              integer, intent(in) :: iasym
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
      interface 
          subroutine XCVCR(iasym, results)
              use list26_mod
              integer, intent(in) :: iasym
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
      interface 
          subroutine XAPP16(calconlyarg)
              logical, optional, intent(in) :: calconlyarg
          end subroutine
      end interface
      
      character(len=1024) :: formatstr
      CHARACTER *24 CTEXT
      DIMENSION A1(3)
      INTEGER DIST, ANGLE, STROM, DEG
      DIMENSION DIST(3),ANGLE(3),MSD(3),STROM(2),DEG(2)
      INTEGER UIJ, CONT
      INTEGER CYCLER
      DIMENSION UIJ(3), CONT(3)
      DIMENSION KF1(1),IQ1(1),IB1(1)
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XLST02.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST12.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XAPK.INC'
      INCLUDE 'XOPK.INC'
      INCLUDE 'XSCALE.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'XL26WK.INC'
C
      INCLUDE 'QSTORE.INC'
      
      
      
      
      INCLUDE 'ICOM12.INC'
      
      
      
      
C
      EQUIVALENCE (KF,KF1(1)),(IQ,IQ1(1)),(IB,IB1(1))
C
      DATA IVERSN /404/
C
#ifdef _HOL_ 
      DATA DIST(1)/4Hdist/,DIST(2)/4Hance/,DIST(3)/4Hs   /
      DATA ANGLE(1)/4H ang/,ANGLE(2)/4Hles /,ANGLE(3)/4H    /
      DATA MSD(1)/4H M.S/,MSD(2)/4H.D.'/,MSD(3)/4Hs   /
      DATA STROM(1)/4HAngs/,STROM(2)/4Htrom/
      DATA DEG(1)/4Hdegr/,DEG(2)/4Hees /
      DATA UIJ(1)/4H  U(/,UIJ(2)/4HIJ)'/,UIJ(3)/4Hs   /
      DATA CONT(1)/4Hcont/,CONT(2)/4Hacts/,CONT(3)/4H    /
C
#else
      DATA DIST(1)/'dist'/,DIST(2)/'ance'/,DIST(3)/'s   '/
      DATA ANGLE(1)/' ang'/,ANGLE(2)/'les '/,ANGLE(3)/'    '/
      DATA MSD(1)/' M.S'/,MSD(2)/'.D.'''/,MSD(3)/'s   '/
      DATA STROM(1)/'Angs'/,STROM(2)/'trom'/
      DATA DEG(1)/'degr'/,DEG(2)/'ees '/
      DATA UIJ(1)/'  U('/,UIJ(2)/'IJ)'''/,UIJ(3)/'s   '/
      DATA CONT(1)/'cont'/,CONT(2)/'acts'/,CONT(3)/'    '/
#endif
C
      ircpt=0 ! counter for the restraints as in list 16
C--INITIATE THE TIMING
      CALL XTIME1(2)
C--READ THE REMAINING CONTROL CARDS
      I=KRDDPV(ISTORE(NFL),1)
      IF ( I .LT. 0 ) GO TO 9910
C----- SET MONITOR LEVEL
      IMON = ISTORE(NFL)
C--WRITE OUT A COUPLE OF CAPTIONS
      CALL XPRTCN
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1000)
1000  FORMAT(26H  Restraints checking  -  ,/,
     2 42H  restraints that produce no contributions,
     3 22H are marked with a '?')
C
C---- SET TYPE AND INITIALISE THE NO DERIVATIVES FOUND COUNTER
      L26TYP = 0       ! 0 = CHECK 
      L26WRN = 0
      
      ! Hijacking sfls subroutine to setup the object from list26_mod.F90
      ! it also stores the derivatives
      call XAPP16(calconlyarg=.true.)
      
      ! Load the list of parameter names
            
C--LOAD LIST 5 FROM THE DISC
      CALL XFAL05
      IF ( IERFLG .LT. 0 ) GO TO 9900
      JQ=2
      JS=1
      CALL XFAL12(JS,JQ,JR,JN)

C--PUNCH OUT THE LIST HEADING
      LN22 = 22
      CALL XPCHLH (LN22,NCPU)

C      JT            ABSOLUTE L.S. PARAMETER NO.
C      JS            PHYSICAL PARAMETER NO FROM WHICH TO START SEARCH
C      JX            RELATIVE PARAMETER NO

      JX = 12
      M5 = L5 - MD5
      M12 = L12O
      L12A = NOWT
      JS = 0

      DO WHILE(M12 .GE. 0)   ! More stuff in L12
        IF(ISTORE(M12+1).GT.0) THEN ! Any refined params
C--COMPUTE THE ADDRESS OF THE FIRST PART FOR THIS GROUP
          L12A=ISTORE(M12+1)
C--CHECK IF THIS PART CONTAINS ANY REFINABLE PARAMETERS
12250  CONTINUE
          DO WHILE(L12A.GT.0) ! --CHECK IF THERE ARE ANY MORE PARTS FOR THIS ATOM OR GROUP
            IF(ISTORE(L12A+3).LT.0) EXIT
C--SET UP THE CONSTANTS TO PASS THROUGH THIS PART
            MD12A=ISTORE(L12A+1)
            JU=ISTORE(L12A+2) 
            JV=ISTORE(L12A+3)
            JS=ISTORE(L12A+4)+1
C--SEARCH THIS PART OF THIS ATOM
            DO JW=JU,JV,MD12A
              JT=ISTORE(JW)
              NB=17
              ILEBP = 0
              DO NA=1,NSC
                IF(ICOM12(NB).EQ.M12) THEN
C--LAYER OR ELEMENT BATCH OR PARAMETER PRINT
                   ILEBP = 1
                   EXIT
                END IF
                NB=NB+4
              END DO

              IF ( ILEBP .EQ. 1 ) THEN
                call extend(parameters_list)
                write(formatstr, '(A)') KSCAL(:,NA+2)
                parameters_list(size(parameters_list))%index=JT
                parameters_list(size(parameters_list))%name=
     1            trim(formatstr)

C--CHECK IF THIS IS AN OVERALL PARAMETER
              ELSE IF (M12.EQ.L12O) THEN
                call extend(parameters_list)
                write(formatstr, '(100A)') KVP(:,JS)
                parameters_list(size(parameters_list))%index=JT
                parameters_list(size(parameters_list))%name=
     1            trim(formatstr)
              ELSE  
C-C-C-DISTINCTION BETWEEN ANISO'S AND ISO/SPECIAL'S FOR PRINT
                IF((STORE(M5+3) .GE. 1.0) .AND. (JS .GE. 8)) THEN
                 call extend(parameters_list)
                 write(formatstr, '(100A)') ICOORD(:,JS+NKAO)
                 parameters_list(size(parameters_list))%index=JT
                 parameters_list(size(parameters_list))%label=
     1             transfer(STORE(M5), 'aaaa')
                 parameters_list(size(parameters_list))%serial=
     1             NINT(STORE(M5+1))
                 parameters_list(size(parameters_list))%name=
     1            trim(formatstr)
                ELSE
                 call extend(parameters_list)
                write(formatstr, '(100A)') ICOORD(:,JS)
                 parameters_list(size(parameters_list))%index=JT
                 parameters_list(size(parameters_list))%label=
     1             transfer(STORE(M5), 'aaaa')
                 parameters_list(size(parameters_list))%serial=
     1             NINT(STORE(M5+1))
                 parameters_list(size(parameters_list))%name=
     1            trim(formatstr)
                ENDIF
              ENDIF
C
C--INCREMENT TO THE NEXT PARAMETER OF THIS PART
              JS=JS+1
            END DO
C--CHANGE PARTS FOR THIS ATOM OR GROUP
            L12A=ISTORE(L12A)
          END DO
        END IF
C--MOVE TO THE NEXT GROUP OR ATOM
        M5=M5+MD5
        M12=ISTORE(M12)
      END DO
      
      !do icpt=1, size(parameters_list)
      !   call parameters_list(icpt)%print
      !end do
      
C
C--CLEAR THE CORE AREA
      CALL XRSL
      CALL XCSAE
C----- LOAD LIST 3 IF IT EXISTS
      KLST3 = -1
        IF (KEXIST(3) .GT. 0) CALL XFAL03
C--LOAD LIST 5
      CALL XFAL05
C--SET UP THE SYSTEM VARIABLES IN CORE
      CALL XLSV
C--LOAD LIST 12
      CALL XFAL12(-1,1,JR,JN)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--LINK LIST 5 AND LIST 12
      I=KSET52(0,-1)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--SET UP THE POINTERS FOR THE DERIVATIVE QUEUE ON DISC
      CALL XIPDQF
C--LOAD THE COMPILED LIST FOR PROCESSING
      IULN=26
      CALL XLCLFP(IULN)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--SET THE CARD NUMBER FLAG
      A=-1.
C--BRING DOWN THE NEXT BLOCK OF CODE AND RELOCATE IT
1050  CONTINUE
      A=A+1.
      NN=1
C--LOAD THE NEXT CARD FOR PROCESSING
      IF(KLOADR(LN))3900,1100,3800
C--JUMP ON THE FUNCTION
1100  CONTINUE
      I=ISTORE(LCG+1)
cdjwsep2011
      if(i .lt. 1) then
       iasym = 1
       i = abs(i)
      else
       iasym = 0
      endif
      M22PD=KNEXTF(L22PD)
C--FETCH THE OBSERVED VALUE AND CALCULATE THE E.S.D.
      B=STORE(LCG+4)
C--CHECK IF WE CAN COMPUTE THE WEIGHT IN THIS CASE
      IF(I-16)1150,1200,1150
C--COMPUTE THE SQUARE ROOT OF THE WEIGHT
1150  CONTINUE
      C=1./SQRT(STORE(LCG+3))
C--SET THE CONVERSION FACTOR
1200  CONTINUE
      CONV=1.
C 1300 DEFINE
C 1350 RESTRAIN
C 1550 SINGLE DISTANCE
C 1750 DIFFERENCE DISTANCE
C 1850 MEAN DISTANCE
C 1950 SINGLE ANGLE
C 2100 DIFFERENCE ANGLE
C 2150 MEAN ANGLE
C 2200 VIBRATION
C 2350 EXECUTION
C 2400 NO(THING)
C 2450 U(IJ)
C 1050 equate
C 4000 PLANAR
C 4300 SUM
C 1050 form
C 4400 AVERAGE
C 4370 LIMIT
C 1710 ENERGY 
C 5000 ORIGIN
C 5010 UXZBAR
C 5020 UYZBAR
C 5030 UZZBAR
C 5040 UPERP
C 5050 UPERP2
C 5060 UALIGN
C 5070 RIGU
C 5080 ULIJ
C 5090 UPLANE
C 5500 UXXQIV
C 5510 UXYQIV
C 5520 UXZQIV
C 5530 UYYQIV
C 5540 UYZQIV
C 5550 UZZQIV
C 1250
c
      write(cmon,'(/)')
      call xprvdu(ncvdu,1,0)
      ircpt=ircpt+1
      
      if(.not. allocated(restraints_list)) then
        write(cmon,'(A,A)') "{E Error: Run a refinement cycle ",
     1    "before issuing \check"
        call xprvdu(ncvdu,1,0)
        return
      end if
      
      ! Write user restraint, first element is index in list 16 from zero
      if(i/=10) then ! skip exec
        if(ircpt<1 .or. ircpt>size(restraints_list)) then
          IF (ISSPRT .EQ. 0) then
            WRITE(NCWU,'(/,A)') '___________'
            WRITE(NCWU,'(1X, "(",I0,")",1X, A)') 
     1        sign(ircpt,-1), 'Unknown restraint'
          end if

          WRITE(CMON,'(1X, "(",I0,")",1X, A)') 
     1      sign(ircpt,-1), 'Unknown restraint'
          CALL XPRVDU(NCVDU, 1,0)      
        else
          IF (ISSPRT .EQ. 0) then
            WRITE(NCWU,'(/,A)') '___________'
            WRITE(NCWU,'(1X, "(",I0,")",1X, A)') 
     1        restraints_list(ircpt)%user_index,
     2        trim(restraints_list(ircpt)%restraint_text)
          end if

          WRITE(CMON,'(1X, "(",I0,",",I0,")",1X, A)') 
     1      restraints_list(ircpt)%user_index, ircpt, 
     2      trim(restraints_list(ircpt)%restraint_text)          
          icptn=0
          do ii=1, len_trim(
     1      restraints_list(ircpt)%restraint_text)
            if(restraints_list(ircpt)%restraint_text(ii:ii)==char(10))
     1        then
              icptn=icptn+1
            end if
          end do
          CALL XPRVDU(NCVDU, icptn+1,0)      
        end if
      end if
      
      GOTO(1300,1350,1550,1750,1850,1950,2100,2150,2200,2350,2400,2450,
     2 1050,4000,4300,1050,4400,4370,1710,5000,5010,5020,5030,5040,5050,
     2 5060,5070,5080,5090,5500,5510,5520,5530,5540,5550,1250) ,I
1250  CONTINUE
      CALL XOPMSG (IOPL16, IOPINT, 0)
      GOTO 9900
C
C--'DEFINE' FUNCTION
1300  CONTINUE
      CALL XCDEF
      GOTO 1050
C
C--'RESTRAIN' FUNCTION
1350  CONTINUE
      CALL XCC
      CALL XMOVE(IB1(1),KF1(1),1)
C--CHECK IF ANY DERIVATIVES HAVE BEEN PRODUCED
      IF(ISTORE(L22PD)-4)1450,1400,1450
C--NO DERIVATIVES
1400  CONTINUE
      CALL XMOVE(IQ1(1),KF1(1),1)
       WRITE(CMON,'(A)')'{I  General Restraint: No derivatives found'
       CALL XPRVDU(NCVDU,1,0)
       IF(ISSPRT.EQ.0)
     1 WRITE(NCWU,'(A)')'   General Restraint: No derivatives found'
1450  CONTINUE
C--CALCULATE THE COMPUTED VALUE AND PRINT THE RESULTS
      D=B-STORE(L22PD+2)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1500)A,B,C,KF,D,STORE(L22PD+2)
1500  FORMAT(//1H ,F4.0,26H  General restraint to be ,E20.10,
     2 19H  with an E.S.D. of,E20.10/3X,A1,1X,18H  Calculated value,
     3 8X,E20.10,19H  giving a delta of,E20.10)
      WRITE(CMON,1610)NINT(A), '   General restraint', B,C
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 1050
C
C--'SINGLE DISTANCE' RESTRAINTS
1550  CONTINUE
      CALL XCDC(iasym)
      N=2
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1600)A,(DIST(M),M=1,3),B,(STROM(M),M=1,2),C
      ENDIF
1600  FORMAT(/1X,F4.0,' Restrain these ',2A4,A1,' to be',
     2 F9.3,1X,2A4,',',/15X,' with an E.S.D. of',F8.3)
      WRITE(CMON,1610)NINT(A), '      Given distance', B,C
      CALL XPRVDU(NCVDU, 1,0)
1610  FORMAT(I5, 1X, A, '. ', 'Target ',F7.3, ' esd ', F7.3)
C
1650  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1700)(NUMB(M),M=2,3),(DIST(M),M=1,3),(IB,M=1,N)
      ENDIF
1700  FORMAT(/5X,2(7X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ),3X,2A4,A1,
     2 2A1,2X,5HDelta)
      GOTO 2500
C
C
C--'ENERGY ' RESTRAINTS
1710  CONTINUE
      CALL XCEC(iasym)
      N=2
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1720)A,(CONT(M),M=1,3),B,(STROM(M),M=1,2),C
      ENDIF
1720  FORMAT(/1H ,F4.0,16H Restrain these ,2A4,A1,6H to be,
     2 F9.3,1X,2A4,22H, with Power Factor of,F4.1)
      WRITE(CMON,1610)NINT(A), ' non-bonded distance', B,C
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 1650
C
C--'DISTANCE DIFFERENCE' RESTRAINTS
1750  CONTINUE
      CALL XCDDC(iasym)
      N=1
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1800)A,(DIST(M),M=1,3),B,(STROM(M),M=1,2),C
      ENDIF
1800  FORMAT(/1X ,F4.0,
     2 '   Restrain the differences between the following ',2A4,A1,
     3 ' to be' /,F9.3,2X,2A4,',',' with an E.S.D. of ',F8.3)
      WRITE(CMON,1610)NINT(A), ' distance difference', B,C
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 1650
C
C--'MEAN DISTANCE' RESTRAINT
1850  CONTINUE
      CALL XCMDC(iasym)
      N=2
      B=STORE(LCG+4)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1900)A,(DIST(M),M=1,3),B,(STROM(M),M=1,2),C
      ENDIF
1900  FORMAT(/1H ,F4.0,'   Restrain the following ',2A4,A1,
     2 ' to their common mean of ',F9.3,1X,2A4,/
     3 49X,'with an E.S.D. of', F8.3)
      WRITE(CMON,1610)NINT(A), '       Mean distance', B,C
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 1650
C
C--'SINGLE ANGLE' RESTRAINTS
1950  CONTINUE
      CALL XCAC
      N=2
      CONV=RTD
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1600)A,(ANGLE(M),M=1,3),B,(DEG(M),M=1,2),C
      ENDIF
      WRITE(CMON,1960)NINT(A), '         Given angle', B,C
      CALL XPRVDU(NCVDU, 1,0)
1960  FORMAT(I5, 1X, A, '. ', 'Target ',F7.2, ' esd ', F7.2)
C
C
2000  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2050)(NUMB(M),M=2,4),(ANGLE(M),M=1,2),(IB,M=1,N)
      ENDIF
2050  FORMAT(/5X,3(7X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ),3X,A4,A3,2A1,
     2 5HDelta)
      GOTO 2500
C
C--'ANGLE DIFFERENCE' RESTRAINTS
2100  CONTINUE
      CALL XCADC
      N=1
      CONV=RTD
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1800)A,(ANGLE(M),M=1,3),B,(DEG(M),M=1,2),C
      ENDIF
      WRITE(CMON,1960)NINT(A), '    angle difference', B,C
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 2000
C
C--'MEAN ANGLE' RESTRAINT
2150  CONTINUE
      CALL XCMAC
      N=2
      B=STORE(LCG+4)
      CONV=RTD
      B=B*CONV
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1900)A,(ANGLE(M),M=1,3),B,(DEG(M),M=1,2),C
      ENDIF
      WRITE(CMON,1960)NINT(A), '          Mean angle', B,C
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 2000
C
C--'VIBRATION' RESTRAINT
2200  CONTINUE
      CALL XCVC(IASYM)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2250)A,(MSD(M),M=1,3),B,C
      ENDIF
2250  FORMAT(/1X,F4.0,'DELU - Restrain the difference in the',2A4,A1,
     2 ' along a bond to be',/6x,F9.5,
     3 '  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,2260)NINT(A), 'Vibration difference', B,C
      CALL XPRVDU(NCVDU, 1,0)
2260  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)

      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2300)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
2300  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500
C
C--'UXZBAR' RESTRAINT
5010  CONTINUE
C To be replaced with JA routine:
      CALL XCVCX(1,IASYM)
      WRITE(*,*)'Hello UXZBar'
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,5011)A,B,C
      ENDIF
5011  FORMAT(/1X,F4.0,
     1 'UXZBAR - Restrain the covariance perp. to X and bond to be '
     2 /6x,F9.5,'  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,5012)NINT(A+1), 'Covariance difference XZ ', B,C
      CALL XPRVDU(NCVDU, 1,0)
5012  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)
      IF (ISSPRT .EQ. 0) THEN
         WRITE(NCWU,5013)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
5013  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500
C
C--'UYZBAR' RESTRAINT
5020  CONTINUE
C To be replaced with JA routine:
      CALL XCVCX(2,IASYM)
      WRITE(*,*)'Hello UYZBar'
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,5021)A,B,C
      ENDIF
5021  FORMAT(/1X,F4.0,
     1'UYZBAR - Restrain the covariance perp to UXZBAR and bond to be '
     2 /6x,F9.5,'  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,5022)NINT(A+1), 'Covariance difference YZ', B,C
      CALL XPRVDU(NCVDU, 1,0)
5022  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)

      IF (ISSPRT .EQ. 0) THEN
         WRITE(NCWU,5023)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
5023  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500

C--'UZZBAR' RESTRAINT
5030  CONTINUE
C To be replaced with JA routine:
      CALL XCVCX(3,IASYM)
      WRITE(*,*)'Hello UZZBar'
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,5031)A,B,C
      ENDIF
5031  FORMAT(/1X,F4.0,
     1 'UZZBAR - Restrain the covariance perp. to X and bond to be '
     2 /6x,F9.5,'  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,5032)NINT(A+1), 'Variance difference ZZ ', B,C
      CALL XPRVDU(NCVDU, 1,0)
5032  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)
      IF (ISSPRT .EQ. 0) THEN
         WRITE(NCWU,5033)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
5033  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500
      
C--'UPERP' RESTRAINT
5040  CONTINUE
      CALL XCVCV(1,IASYM)
      
      ! lis file output
5041  FORMAT(6x,'Restrain U[13] and U[23] to ',F0.5,
     2 ' angstrom squared,',
     3 /6x, 'with an E.S.D. of',1PE10.3)
5043  FORMAT(/2X,(10X,'Atom',2X,1X,4X,'S(I) L TX TY TZ',7X,'Value'),
     2 8X,'Delta',2X,'Parameter')
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,'(/1X,F4.0,A,A,"(",I0,") to ", A, "(",I0,")")') 
     1    A,'UPERP from ', 
     1    trim(restraints_list(ircpt)%subrestraints(1)%atoms(1)%label), 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(1)%serial, 
     1    trim(restraints_list(ircpt)%subrestraints(1)%atoms(2)%label), 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(2)%serial
        WRITE(NCWU,5041)B,C
        WRITE(NCWU,'(6X, A)') 'Transformation matrix:'
        WRITE(NCWU,'(6X, 3(1PE10.3,1X))') 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(1)%M(1,:)
        WRITE(NCWU,'(6X, 3(1PE10.3,1X))') 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(1)%M(2,:)
        WRITE(NCWU,'(6X, 3(1PE10.3,1X))') 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(1)%M(3,:)
        if(allocated(restraints_list(ircpt)%subrestraints(1)%blocks)) 
     1    then
          WRITE(NCWU,'(6X, A)') 'Derivatives:'
          do it=1, size(restraints_list(ircpt)%subrestraints)
            associate(block => 
     1        restraints_list(ircpt)%subrestraints(it)%blocks(0))
              WRITE(NCWU,'(6X,A)') block%printp(.true.)
              WRITE(NCWU,'(6X,A,3X,A)') block%print(), 
     1        trim(restraints_list(ircpt)%subrestraints(it)%description)
            end associate
          end do
        end if
        WRITE(NCWU,5043) 
      ENDIF
      
      ! screen output
5042  FORMAT(1X, A, ' from ', A,'(',I0,') to ',A,'(',I0,'). ', 
     1  'Target ',F7.4,' esd ', 1PE10.3)
      WRITE(CMON,5042) 'UPERP', 
     1     trim(restraints_list(ircpt)%subrestraints(1)%atoms(1)%label), 
     1     restraints_list(ircpt)%subrestraints(1)%atoms(1)%serial, 
     1     trim(restraints_list(ircpt)%subrestraints(1)%atoms(2)%label), 
     1     restraints_list(ircpt)%subrestraints(1)%atoms(2)%serial, B,C
      CALL XPRVDU(NCVDU, 1,0)      
5044  FORMAT(8X, 'Atom', 8X, 'Value',8X,'Delta',4X,'Parameter')
      WRITE(CMON,5044)
      CALL XPRVDU(NCVDU, 1,0)      
      
      N=2
c      Print *, 'X End'
      GOTO 2500
      
C--'UPERP2' RESTRAINT
5050  CONTINUE
      CALL XCVCV2(IASYM)

      ! lis file output
5051  FORMAT(6x,'Restrain U[13] and U[23] to ',F0.5,
     2 ' angstrom squared,',
     3 /6x, 'with an E.S.D. of',1PE10.3)
5053  FORMAT(/2X,(10X,'Atom',2X,1X,4X,'S(I) L TX TY TZ',7X,'Value'),
     2 8X,'Delta',2X,'Parameter')
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,'(/1X,F4.0,A,A,"(",I0,") to ", A, "(",I0,"), ", '//
     1     'A, "(",I0,")")')          
     1    A,'UPERP2 from ',      
     1    trim(restraints_list(ircpt)%subrestraints(1)%atoms(1)%label), 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(1)%serial, 
     1    trim(restraints_list(ircpt)%subrestraints(1)%atoms(2)%label), 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(2)%serial,
     1    trim(restraints_list(ircpt)%subrestraints(1)%atoms(3)%label), 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(3)%serial
        WRITE(NCWU,5051)B,C
        WRITE(NCWU,'(6X, A)') 'Transformation matrix:'
        WRITE(NCWU,'(6X, 3(1PE10.3,1X))') 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(1)%M(1,:)
        WRITE(NCWU,'(6X, 3(1PE10.3,1X))') 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(1)%M(2,:)
        WRITE(NCWU,'(6X, 3(1PE10.3,1X))') 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(1)%M(3,:)
        if(allocated(restraints_list(ircpt)%subrestraints(1)%blocks)) 
     1    then
          WRITE(NCWU,'(6X, A)') 'Derivatives:'
          do it=1, size(restraints_list(ircpt)%subrestraints)
            associate(block => 
     1        restraints_list(ircpt)%subrestraints(it)%blocks(0))
              WRITE(NCWU,'(6X,A)') block%printp(.true.)
              WRITE(NCWU,'(6X,A,3X,A)') block%print(), 
     1        trim(restraints_list(ircpt)%subrestraints(it)%description)
            end associate
          end do
        end if
        WRITE(NCWU,5053) 
      ENDIF
      
      ! screen output
5052  FORMAT(1X, A, ' from ', A,'(',I0,') to ',
     1   A,'(',I0,'), ',A,'(',I0,'). ', 
     1  'Target ',F7.4,' esd ', 1PE10.3)
      WRITE(CMON,5052) 'UPERP2', 
     1     trim(restraints_list(ircpt)%subrestraints(1)%atoms(1)%label), 
     1     restraints_list(ircpt)%subrestraints(1)%atoms(1)%serial, 
     1     trim(restraints_list(ircpt)%subrestraints(1)%atoms(2)%label), 
     1     restraints_list(ircpt)%subrestraints(1)%atoms(2)%serial, 
     1     trim(restraints_list(ircpt)%subrestraints(1)%atoms(3)%label), 
     1     restraints_list(ircpt)%subrestraints(1)%atoms(3)%serial, B,C
      CALL XPRVDU(NCVDU, 1,0)      
5054  FORMAT(8X, 'Atom', 8X, 'Value',8X,'Delta',4X,'Parameter')
      WRITE(CMON,5054)
      CALL XPRVDU(NCVDU, 1,0) 

      N=2
      GOTO 2500
C
C--'UALIGN' RESTRAINT
5060  CONTINUE
      CALL XCVCA(IASYM)

      ! lis file output
5061  FORMAT(6x,'Restrain Delta eigenvectors ',F0.5,
     2 ' angstrom squared,',
     3 /6x, 'with an E.S.D. of',1PE10.3)
5063  FORMAT(/2X,(10X,'Atom',2X,1X,4X,'S(I) L TX TY TZ',7X,'Value'),
     2 8X,'Delta',2X,'Parameter')
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,'(/1X,F4.0,A,A,"(",I0,") to ", A, "(",I0,")")')          
     1    A,'UALIGN from ',      
     1    trim(restraints_list(ircpt)%subrestraints(1)%atoms(1)%label), 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(1)%serial, 
     1    trim(restraints_list(ircpt)%subrestraints(1)%atoms(2)%label), 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(2)%serial
        WRITE(NCWU,5061)B,C
        WRITE(NCWU,'(6X, A)') 'Transformation matrix:'
        WRITE(NCWU,'(6X, 3(1PE10.3,1X), 6X, 3(1PE10.3,1X))') 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(1)%M(1,:),
     1    restraints_list(ircpt)%subrestraints(1)%atoms(2)%M(1,:)
        WRITE(NCWU,'(6X, 3(1PE10.3,1X), 6X, 3(1PE10.3,1X))') 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(1)%M(2,:),
     1    restraints_list(ircpt)%subrestraints(1)%atoms(2)%M(2,:)
        WRITE(NCWU,'(6X, 3(1PE10.3,1X), 6X, 3(1PE10.3,1X))') 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(1)%M(3,:),
     1    restraints_list(ircpt)%subrestraints(1)%atoms(2)%M(3,:)
        if(allocated(restraints_list(ircpt)%subrestraints(1)%blocks)) 
     1    then
          WRITE(NCWU,'(6X, A)') 'Derivatives: '
          do it=1, size(restraints_list(ircpt)%subrestraints)
            associate(block => 
     1        restraints_list(ircpt)%subrestraints(it)%blocks(0))
              WRITE(NCWU,'(6X,A)') block%printp(.true.)
              WRITE(NCWU,'(6X,A,3X,A)') block%print(), 
     1        trim(restraints_list(ircpt)%subrestraints(it)%description)
            end associate
          end do
        end if
        WRITE(NCWU,5063) 
      ENDIF
      
      ! screen output
5062  FORMAT(1X, A, ' from ', A,'(',I0,') to ',
     1   A,'(',I0,'). ', 
     1  'Target ',F7.4,' esd ', 1PE10.3)
      WRITE(CMON,5062) 'UALIGN', 
     1     trim(restraints_list(ircpt)%subrestraints(1)%atoms(1)%label), 
     1     restraints_list(ircpt)%subrestraints(1)%atoms(1)%serial, 
     1     trim(restraints_list(ircpt)%subrestraints(1)%atoms(2)%label), 
     1     restraints_list(ircpt)%subrestraints(1)%atoms(2)%serial, B,C
      CALL XPRVDU(NCVDU, 1,0)      
5064  FORMAT(8X, 'Atom', 8X, 'Value',8X,'Delta',4X,'Parameter')
      WRITE(CMON,5064)
      CALL XPRVDU(NCVDU, 1,0) 
     
      N=2
      GOTO 2500
C
C--'RIGU' RESTRAINT
5070  CONTINUE
      CALL XCVCR(IASYM)

      ! lis file output
5071  FORMAT(6x,'Enhanced rigid body restraint ',F0.5,
     2 ' angstrom squared,',
     3 /6x, 'with an E.S.D. of',1PE10.3)
5073  FORMAT(/2X,(10X,'Atom',2X,1X,4X,'S(I) L TX TY TZ',7X,'Value'),
     2 8X,'Delta',2X,'Parameter')
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,'(/1X,F4.0,A,A,"(",I0,") to ", A, "(",I0,")")')          
     1    A,'RIGU from ',      
     1    trim(restraints_list(ircpt)%subrestraints(1)%atoms(1)%label), 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(1)%serial, 
     1    trim(restraints_list(ircpt)%subrestraints(1)%atoms(2)%label), 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(2)%serial
        WRITE(NCWU,5071)B,C
        WRITE(NCWU,'(6X, A)') 'Transformation matrix:'
        WRITE(NCWU,'(6X, 3(1PE10.3,1X), 6X, 3(1PE10.3,1X))') 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(1)%M(1,:),
     1    restraints_list(ircpt)%subrestraints(1)%atoms(2)%M(1,:)
        WRITE(NCWU,'(6X, 3(1PE10.3,1X), 6X, 3(1PE10.3,1X))') 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(1)%M(2,:),
     1    restraints_list(ircpt)%subrestraints(1)%atoms(2)%M(2,:)
        WRITE(NCWU,'(6X, 3(1PE10.3,1X), 6X, 3(1PE10.3,1X))') 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(1)%M(3,:),
     1    restraints_list(ircpt)%subrestraints(1)%atoms(2)%M(3,:)
        if(allocated(restraints_list(ircpt)%subrestraints(1)%blocks)) 
     1    then
          WRITE(NCWU,'(6X, A)') 'Derivatives: '
          do it=1, size(restraints_list(ircpt)%subrestraints)
            associate(block => 
     1        restraints_list(ircpt)%subrestraints(it)%blocks(0))
              WRITE(NCWU,'(6X,A)') block%printp(.true.)
              WRITE(NCWU,'(6X,A,3X,A)') block%print(), 
     1        trim(restraints_list(ircpt)%subrestraints(it)%description)
            end associate
          end do
        end if
        WRITE(NCWU,5073) 
      ENDIF
      
      ! screen output
5072  FORMAT(1X, A, ' from ', A,'(',I0,') to ',
     1   A,'(',I0,'). ', 
     1  'Target ',F7.4,' esd ', 1PE10.3)
      WRITE(CMON,5072) 'RIGU', 
     1     trim(restraints_list(ircpt)%subrestraints(1)%atoms(1)%label), 
     1     restraints_list(ircpt)%subrestraints(1)%atoms(1)%serial, 
     1     trim(restraints_list(ircpt)%subrestraints(1)%atoms(2)%label), 
     1     restraints_list(ircpt)%subrestraints(1)%atoms(2)%serial, B,C
      CALL XPRVDU(NCVDU, 1,0)      
5074  FORMAT(8X, 'Atom', 8X, 'Value',8X,'Delta',4X,'Parameter')
      WRITE(CMON,5074)
      CALL XPRVDU(NCVDU, 1,0) 
      
      N=2
      GOTO 2500
C
C--'ULIJ' RESTRAINT
5080  CONTINUE
C To be replaced with JA routine:
      CALL XCVCL(IASYM)
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,5051)A,B,C
      ENDIF
5081  FORMAT(/1X,F4.0,
     1 'ULIJ - Restrain eigenvalues to be equal '
     2 /6x,F9.5,'  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,5082)NINT(A+1), 'Variance difference ZZ ', B,C
      CALL XPRVDU(NCVDU, 1,0)
5082  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)
      IF (ISSPRT .EQ. 0) THEN
         WRITE(NCWU,5083)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
5083  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500

C--'UPLANE' RESTRAINT
5090  CONTINUE
      CALL XCVCW(0,IASYM)

      ! lis file output
5091  FORMAT(6x,'Restrain U[12] and U[23] to ',F0.5,
     2 ' angstrom squared,',
     3 /6x, 'with an E.S.D. of',1PE10.3)
5093  FORMAT(/2X,(10X,'Atom',2X,1X,4X,'S(I) L TX TY TZ',7X,'Value'),
     2 8X,'Delta',2X,'Parameter')
      IF (ISSPRT .EQ. 0) THEN
        formatstr='(/1X,F4.0,A,A,"(",I0,") to ",'//
     1    'A, "(",I0,"), ", A, "(",I0,")")'
        WRITE(NCWU,formatstr) 
     2    A,'UPLANE from ', 
     2    trim(restraints_list(ircpt)%subrestraints(1)%atoms(1)%label), 
     2    restraints_list(ircpt)%subrestraints(1)%atoms(1)%serial, 
     2    trim(restraints_list(ircpt)%subrestraints(1)%atoms(2)%label), 
     2    restraints_list(ircpt)%subrestraints(1)%atoms(2)%serial,
     2    trim(restraints_list(ircpt)%subrestraints(1)%atoms(3)%label), 
     2    restraints_list(ircpt)%subrestraints(1)%atoms(3)%serial
        WRITE(NCWU,5091)B,C
        WRITE(NCWU,'(6X, A)') 'Transformation matrix:'
        WRITE(NCWU,'(6X, 3(1PE10.3,1X))') 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(1)%M(1,:)
        WRITE(NCWU,'(6X, 3(1PE10.3,1X))') 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(1)%M(2,:)
        WRITE(NCWU,'(6X, 3(1PE10.3,1X))') 
     1    restraints_list(ircpt)%subrestraints(1)%atoms(1)%M(3,:)
        if(allocated(restraints_list(ircpt)%subrestraints(1)%blocks)) 
     1    then
          WRITE(NCWU,'(6X, A)') 'Derivatives:'
          do it=1, size(restraints_list(ircpt)%subrestraints)
            associate(block => 
     1        restraints_list(ircpt)%subrestraints(it)%blocks(0))
              WRITE(NCWU,'(6X,A)') block%printp(.true.)
              WRITE(NCWU,'(6X,A, 3X, A)') block%print(),
     1        trim(restraints_list(ircpt)%subrestraints(it)%description)
            end associate
          end do
        end if
        WRITE(NCWU,5093) 
      ENDIF
      
      ! screen output
5092  FORMAT(1X, A, ' from ', A,'(',I0,') to ',A,'(',I0,'), ', 
     1  A,'(',I0,'). Target ',F7.4,' esd ', 1PE10.3)
      WRITE(CMON,5092) 'UPLANE', 
     1     trim(restraints_list(ircpt)%subrestraints(1)%atoms(1)%label), 
     1     restraints_list(ircpt)%subrestraints(1)%atoms(1)%serial, 
     1     trim(restraints_list(ircpt)%subrestraints(1)%atoms(2)%label), 
     1     restraints_list(ircpt)%subrestraints(1)%atoms(2)%serial, 
     1     trim(restraints_list(ircpt)%subrestraints(1)%atoms(3)%label), 
     1     restraints_list(ircpt)%subrestraints(1)%atoms(3)%serial, B,C
      CALL XPRVDU(NCVDU, 1,0)      
5094  FORMAT(8X, 'Atom', 8X, 'Value',8X,'Delta',4X,'Parameter')
      WRITE(CMON,5094)
      CALL XPRVDU(NCVDU, 1,0)      
      N=2
      GOTO 2500
C
C--'UXXQIV' RESTRAINT
5500  CONTINUE
C To be replaced with JAA routine:
      CALL XCVCY(1,IASYM)
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,5501)A,B,C
      ENDIF
5501  FORMAT(/1X,F4.0,
     1 'UXXQIV - Restrain the covariance perp. to X and bond to be '
     2 /6x,F9.5,'  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,5502)NINT(A+1), 'Difference XX ', B,C
      CALL XPRVDU(NCVDU, 1,0)
5502  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)
      IF (ISSPRT .EQ. 0) THEN
         WRITE(NCWU,5503)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
5503  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500
C
C--'UXYQIV' RESTRAINT
5510  CONTINUE
C To be replaced with JAA routine:
      CALL XCVCY(2,IASYM)
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,5511)A,B,C
      ENDIF
5511  FORMAT(/1X,F4.0,
     1 'UXYQIV - Restrain the covariance perp. to X and bond to be '
     2 /6x,F9.5,'  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,5512)NINT(A+1), 'Difference XY ', B,C
      CALL XPRVDU(NCVDU, 1,0)
5512  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)
      IF (ISSPRT .EQ. 0) THEN
         WRITE(NCWU,5513)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
5513  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500
C
C--'UXZQIV' RESTRAINT
5520  CONTINUE
C To be replaced with JAA routine:
      CALL XCVCY(3,IASYM)
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,5521)A,B,C
      ENDIF
5521  FORMAT(/1X,F4.0,
     1 'UXZQIV - Restrain the covariance perp. to X and bond to be '
     2 /6x,F9.5,'  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,5522)NINT(A+1), 'Difference XZ ', B,C
      CALL XPRVDU(NCVDU, 1,0)
5522  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)
      IF (ISSPRT .EQ. 0) THEN
         WRITE(NCWU,5533)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
5523  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500
C
C--'UYYQIV' RESTRAINT
5530  CONTINUE
C To be replaced with JAA routine:
      CALL XCVCY(4,IASYM)
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,5531)A,B,C
      ENDIF
5531  FORMAT(/1X,F4.0,
     1 'UYYQIV - Restrain the covariance perp. to X and bond to be '
     2 /6x,F9.5,'  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,5532)NINT(A+1), 'Difference YY ', B,C
      CALL XPRVDU(NCVDU, 1,0)
5532  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)
      IF (ISSPRT .EQ. 0) THEN
         WRITE(NCWU,5533)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
5533  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500
C
C--'UYZQIV' RESTRAINT
5540  CONTINUE
C To be replaced with JAA routine:
      CALL XCVCY(5,IASYM)
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,5541)A,B,C
      ENDIF
5541  FORMAT(/1X,F4.0,
     1 'UYZQIV - Restrain the covariance perp. to X and bond to be '
     2 /6x,F9.5,'  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,5542)NINT(A+1), 'Difference YZ ', B,C
      CALL XPRVDU(NCVDU, 1,0)
5542  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)
      IF (ISSPRT .EQ. 0) THEN
         WRITE(NCWU,5543)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
5543  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500
C
C--'UZZQIV' RESTRAINT
5550  CONTINUE
C To be replaced with JAA routine:
      CALL XCVCY(6,IASYM)
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,5551)A,B,C
      ENDIF
5551  FORMAT(/1X,F4.0,
     1 'UZZQIV - Restrain the covariance perp. to X and bond to be '
     2 /6x,F9.5,'  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,5552)NINT(A+1), 'Difference ZZ ', B,C
      CALL XPRVDU(NCVDU, 1,0)
5552  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)
      IF (ISSPRT .EQ. 0) THEN
         WRITE(NCWU,5553)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
5553  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500
C
C
C--'EXECUTION LISTING'
2350  CONTINUE
      ISTAT2=1
      GOTO 1050
C
C--'NO LISTING'
2400  CONTINUE
      WRITE(CMON,'(6X,A)') 'No output'
      CALL XPRVDU(NCVDU, 1,0)
      ISTAT2=0
      GOTO 1050
C
C--'U(IJ)' RESTRAINT
2450  CONTINUE
      CALL XDUIJ(iasym)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2251)A,(UIJ(M),M=1,3),B,C
2251  FORMAT(/4X ,F4.0,'SIMU - Restrain the difference',
     1 ' in the components of',  2A4,A1,
     2 ' to be',/6x,F9.5,
     3 '  angstrom squared, with an E.S.D. of',F9.5)
      ENDIF
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2300)(NUMB(N),(UIJ(M),M=1,3),N=2,3),IB
      ENDIF
      WRITE(CMON,2460)NINT(A), '      Uij difference', B,C
      CALL XPRVDU(NCVDU, 1,0)
2460  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)
      N=2
      GOTO 2500
C
C--GENERAL PRINT ROUTINES
2500  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,2900)
      ENDIF
      M22PD=KNEXTF(L22PD)
      JA=LCA
      O=0.
      P=0.
      Q=0.
      NCA=0
      JI=JH
      ITEMPA=M22PD
C--LOOP FOR PRINTING EACH INDIVIDUAL RESTRAINT
2550  CONTINUE
      CALL XDOWNF(M22PD,STORE(L22PD),4)
      M22PD=M22PD+KINCRF(ISTORE(L22PD))
C--CHECK IF THIS RESTRAINT IS USEFUL
C Watch out for Uij - this can have up to 6 individual restraints 
c per atom - dealt with under Uij
      if(i.ne.12) then
        CALL XMOVE(IB1(1),KF1(1),1)
        IF(ISTORE(L22PD).eq.4) THEN
         WRITE(CMON,'(A,2x,A,A,A)')'{I ', 
     1   COPERATION(I)(1:NCTRIM(COPERATION(I))),
     1 ' restraint:', ' No derivatives found'
         CALL XPRVDU(NCVDU,1,0)
         IF(ISSPRT.EQ.0)
     1 WRITE(NCWU,'(2x,A,A,A)')COPERATION(I)(1:nctrim(COPERATION(I))),
     1 ' restraint: ', ' No derivatives found'
         CALL XMOVE(IQ1(1),KF1(1),1)
        ENDIF
      endif
2650  CONTINUE
C--SET UP A FEW CONSTANTS
      JD=JA+7
      JE=JA+11
      JB=ISTORE(JA)
      JF=JB+7
      JG=JB+11
      NCA=NCA+1
      ISTORE(JA+3)=NINT(STORE(JA+3))
C--CHECK IF THERE IS MORE THAN ONE ATOM IN THIS RESTRAINT
      IF(NN)2750,2750,2700
2700  CONTINUE
      ISTORE(JB+3)=NINT(STORE(JB+3))
C--CALCULATE THE 'DELTA' AND 'CALCULATED' VALUES
2750  CONTINUE
      A1(2)=STORE(L22PD+2)*CONV
      A1(1)=B-A1(2)
C--BRANCH ON THE TYPE OF RESTRAINTS
      GOTO(1050,1050,2850,3000,2850,3050,3150,3050,3200,1050,1050,3300,
     2 1050,4150,1050,1050,4550,4540,2850,1050,3280,3290,3270,3285,3295,
     2 3260,3261,3262,3263,3264,3265,3266,3267,3268,3269,2800),I
2800  CONTINUE
      CALL XOPMSG (IOPL16, IOPINT, 0)
      GOTO 9900
C
C--PRINT A DISTANCE RESTRAINT
2850  CONTINUE
C----- GET THE EQUIVALENT SIGMA FOR A 'ENERGY' CARD
      ESIGMA = AMIN1( 1./(SQRT( STORE(L22PD + 1) ) ), 10.)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2900)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=1,N)
      ENDIF
2900  FORMAT(2H  ,A1,2X,2(6X,A4,I5,I6,4I3),F11.3,F10.3)
      IF ((IMON .GE. 1) .AND. (ABS(A1(2)) .GE. ESIGMA) ) THEN
         WRITE(CMON ,2901)KF,STORE(JA+2),ISTORE(JA+3),STORE(JB+2),
     2   ISTORE(JB+3),A1(1),A1(2)
         CALL XPRVDU(NCVDU, 1,0)
      ENDIF
2901  FORMAT(1X,A1, 12X, 2(2X,A4,I4),F11.3,F10.3,F12.7)
C--RESET FOR THE NEXT RESTRAINT
2950  CONTINUE
      JA=ISTORE(JB)
      GOTO 3550
C--RESET FOR DISTANCES WHEN DIFFERENCES HAVE BEEN COMPUTED
3000  CONTINUE
      M22PD=ITEMPA
      A1(1)=STORE(JI)
      JI=JI+1
      GOTO 2850
C
C--ANGLES RESTRAINT PRINT
3050  CONTINUE
      JC=ISTORE(JB)
      ISTORE(JC+3)=NINT(STORE(JC+3))
      JL=JC+7
      JM=JC+11
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3100)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),STORE(JC+2),
     3 ISTORE(JC+3),(ISTORE(M),M=JL,JM),(A1(M),M=1,N)
      ENDIF
3100  FORMAT(2H  ,A1,2X,3(6X,A4,I5,I6,4I3),F10.2,F7.2)
      IF ((IMON .GE. 1) .AND. (ABS(A1(2)) .GE. C) ) THEN
         WRITE(CMON,3101)KF,STORE(JA+2),ISTORE(JA+3),STORE(JB+2),
     2   ISTORE(JB+3),STORE(JC+2),ISTORE(JC+3),A1(1),A1(2)
         CALL XPRVDU(NCVDU, 1,0)
      ENDIF
3101  FORMAT(1X,A1, 2X, 3(2X,A4,I4),F7.2,F7.2)
      JA=ISTORE(JC)
      GOTO 3550
C--ANGLE RESTRAINT PRINT FOR DIFFERENCES
3150  CONTINUE
      M22PD=ITEMPA
      A1(1)=STORE(JI)*CONV
      JI=JI+1
      GOTO 3050
C
C--VIBRATION RESTRAINTS PRINT
3200  CONTINUE
      A1(3)=A1(2)
      A1(2)=2.*SQRT(STORE(L22PD+3))
      A1(1)=0.5*(A1(2)-A1(3))
      A1(2)=A1(2)-A1(1)-B
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(1),STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=2,3)
      ENDIF
3250  FORMAT(2H  ,A1,2(8X,A4,I5,I6,4I3,F12.5,1X),F9.5,5X,5A4)
      IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C )) THEN
         WRITE(CMON, 3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         CALL XPRVDU(NCVDU, 1,0)
      ENDIF
3251  FORMAT(1X,A1,2X,2(2X,A4,I4,F9.5,1X),F9.5,2X,5A4)
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
      GOTO 2950
C--UXZBAR RESTRAINTS PRINT
3280  CONTINUE
      A1(3)=A1(2)
       A1(2)=2.*SQRT(STORE(L22PD+3))
       A1(1)=0.5*(A1(2)-A1(3))
       A1(2)=A1(2)-A1(1)-B
c       write(123,'(i6,2f8.5,2x,2f8.5,5x,3f8.5))') 
c     1 jdjw,adjw,bdjw,store(l22pd+2),store(l22pd+3),a1(1),a1(2),a1(3)
c
c Extracting Uij as a1(1) and a1(2) from Store(l22pd+ ) does not 
c recover the original values because L22pd+3 is a squared value, so the
c sign is lost.
c It might be better to use original values at JS and JT.
c
       IF (ISSPRT .EQ. 0) THEN
       WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 adjw,STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),bdjw,A1(3)
     3 ,(ICOORD(idjw,JJ),idjw=1,NWKA)
       ENDIF
       IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C ))  THEN
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C ))THEN
         WRITE(CMON,3251) KF, STORE(JA+2), ISTORE(JA+3), adjw,
     2   STORE(JB+2),ISTORE(JB+3),bdjw,A1(3),
     3   (ICOORD(idjw,JJ),idjw=1,NWKA)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
       ENDIF
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
      GOTO 2950
CC--UYZBAR RESTRAINTS PRINT
3290  CONTINUE
      A1(3)=A1(2)
      A1(2)=2.*SQRT(STORE(L22PD+3))
      A1(1)=0.5*(A1(2)-A1(3))
      A1(2)=A1(2)-A1(1)-B
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(1),STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=2,3)
      ENDIF
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C )) THEN
c         WRITE(NCAWU,3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
c     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C )) THEN
         WRITE(CMON, 3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
      CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
      GOTO 2950
C--UZZBAR RESTRAINTS PRINT
3270  CONTINUE
      A1(3)=A1(2)
      A1(2)=2.*SQRT(STORE(L22PD+3))
      A1(1)=0.5*(A1(2)-A1(3))
      A1(2)=A1(2)-A1(1)-B
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(1),STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=2,3)
      ENDIF
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C )) THEN
c         WRITE(NCAWU,3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
c     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C )) THEN
         WRITE(CMON, 3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
      GOTO 2950
C
C--UPERP and UPERP2 RESTRAINTS PRINT
3285  CONTINUE
3295  CONTINUE

      do jj=1, 2 ! loop over the 2 U(ij) U[13] and U[23]
C--CHECK IF THIS RESTRAINT IS USEFUL
        CALL XMOVE(IB1(1),KF1(1),1)
        IF(ISTORE(L22PD).eq.4) THEN
          WRITE(CMON,'(A,2x,A,A,A)')'{I ', 
     1      COPERATION(I)(1:NCTRIM(COPERATION(I))),
     1      ' restraint:', ' No derivatives found'
          CALL XPRVDU(NCVDU,1,0)
          IF(ISSPRT.EQ.0)
     1      WRITE(NCWU,'(2x,A,A,A)') 
     2        COPERATION(I)(1:nctrim(COPERATION(I))),
     1        ' restraint: ', ' No derivatives found'
            CALL XMOVE(IQ1(1),KF1(1),1)
        ENDIF
                   
        CALL XDOWNF(M22PD,STORE(L22PD),4)
        if(ISTORE(L22PD)>=0) then
          M22PD=M22PD+KINCRF(ISTORE(L22PD))
        else 
          WRITE(CMON,*)'{E No more derivative to find, programmer error'
          CALL XPRVDU(NCVDU, 1,0)
          WRITE(CMON,*)'{E Please seek advice with the authors'
          CALL XPRVDU(NCVDU, 1,0)
          exit
        end if
      end do
    
3296  FORMAT('  ',A1,(8X,A4,I5,I6,4I3,F12.7,1X),1PE12.3,6X,A)    

      associate(subrestraint => restraints_list(ircpt)%subrestraints(1))

      IF (ISSPRT .EQ. 0) THEN              
        WRITE(NCWU,3296) KF,
     1    subrestraint%atoms(1)%label,subrestraint%atoms(1)%serial,
     2    (ISTORE(M),M=JD,JE), subrestraint%atoms(1)%adps_cart(1,3),
     3    subrestraint%atoms(1)%adps_cart(1,3)-B, 'U[13]'
        WRITE(NCWU,3296) KF, 
     1    subrestraint%atoms(1)%label,subrestraint%atoms(1)%serial,
     2    (ISTORE(M),M=JD,JE), subrestraint%atoms(1)%adps_cart(1,3),
     3    subrestraint%atoms(1)%adps_cart(2,3)-B, 'U[23]'     
      ENDIF      
       
3297  FORMAT(1X,A1,2X, (2X,A4,I4,1X,E10.3,1X),2X,1PE10.3,8X,A)
      WRITE(CMON, 3297) KF,subrestraint%atoms(1)%label,
     1   subrestraint%atoms(1)%serial,
     2   subrestraint%atoms(1)%adps_cart(1,3),
     3   subrestraint%atoms(1)%adps_cart(1,3)-B, ! B is the target
     4   'U[13]'
      CALL XPRVDU(NCVDU, 1,0)
       
      WRITE(CMON, 3297) KF,subrestraint%atoms(1)%label,
     1   subrestraint%atoms(1)%serial,
     2   subrestraint%atoms(1)%adps_cart(2,3),
     3   subrestraint%atoms(1)%adps_cart(2,3)-B, ! B is the target
     4   'U[23]'
      CALL XPRVDU(NCVDU, 1,0)
       
      Q=subrestraint%atoms(1)%adps_cart(1,3)+
     1  subrestraint%atoms(1)%adps_cart(2,3)
      O=subrestraint%atoms(1)%adps_cart(1,3)-B + 
     1  subrestraint%atoms(1)%adps_cart(2,3)-B
      P=(subrestraint%atoms(1)%adps_cart(1,3)-B)**2 + 
     1  (subrestraint%atoms(1)%adps_cart(2,3)-B)**2
      NCA = 2

      end associate
       
      goto 3600   
      
C
C--UALIGN RESTRAINTS PRINT
3260  CONTINUE
      do jj=1, 3 ! loop over the U(ij)
C--CHECK IF THIS RESTRAINT IS USEFUL
        CALL XMOVE(IB1(1),KF1(1),1)
        IF(ISTORE(L22PD).eq.4) THEN
          WRITE(CMON,'(A,2x,A,A,A)')'{I ', 
     1      COPERATION(I)(1:NCTRIM(COPERATION(I))),
     1      ' restraint:', ' No derivatives found'
          CALL XPRVDU(NCVDU,1,0)
          IF(ISSPRT.EQ.0)
     1      WRITE(NCWU,'(2x,A,A,A)') 
     2        COPERATION(I)(1:nctrim(COPERATION(I))),
     1        ' restraint: ', ' No derivatives found'
            CALL XMOVE(IQ1(1),KF1(1),1)
        ENDIF
                   
        CALL XDOWNF(M22PD,STORE(L22PD),4)
        if(ISTORE(L22PD)>=0) then
          M22PD=M22PD+KINCRF(ISTORE(L22PD))
        else 
          WRITE(CMON,*)'{E No more derivative to find, programmer error'
          CALL XPRVDU(NCVDU, 1,0)
          WRITE(CMON,*)'{E Please seek advice with the authors'
          CALL XPRVDU(NCVDU, 1,0)
          exit
        end if
      end do
    
3286  FORMAT('  ',A1,(8X,A4,I5,I6,4I3,F12.7,1X),1PE12.3,6X,A,I0,I0,A)    
3288  FORMAT('  ',A1,(8X,A4,I5,I6,4I3,F12.7,1X),A12,6X,A,I0,I0,A)    

      associate(subrestraint => restraints_list(ircpt)%subrestraints(1))

      IF (ISSPRT .EQ. 0) THEN       
        it=1
        jt=2
        WRITE(NCWU,3288) KF,
     1    subrestraint%atoms(1)%label,subrestraint%atoms(1)%serial,
     2    (ISTORE(M),M=JD,JE),subrestraint%atoms(1)%adps_cart(it,jt),
     3    'Fixed', 'U[',it,jt,']'
        WRITE(NCWU,3286) KF, 
     1    subrestraint%atoms(2)%label,subrestraint%atoms(2)%serial,
     2    (ISTORE(M),M=JD,JE),subrestraint%atoms(2)%adps_cart(it,jt),
     3    subrestraint%atoms(2)%adps_cart(it,jt)-B, 'U[',it,jt,']'
        it=1
        jt=3
        WRITE(NCWU,3288) KF,
     1    subrestraint%atoms(1)%label,subrestraint%atoms(1)%serial,
     2    (ISTORE(M),M=JD,JE),subrestraint%atoms(1)%adps_cart(it,jt),
     3    'Fixed', 'U[',it,jt,']'
        WRITE(NCWU,3286) KF, 
     1    subrestraint%atoms(2)%label,subrestraint%atoms(2)%serial,
     2    (ISTORE(M),M=JD,JE),subrestraint%atoms(2)%adps_cart(it,jt),
     3    subrestraint%atoms(2)%adps_cart(it,jt)-B, 'U[',it,jt,']'
        it=2
        jt=3
        WRITE(NCWU,3288) KF,
     1    subrestraint%atoms(1)%label,subrestraint%atoms(1)%serial,
     2    (ISTORE(M),M=JD,JE),subrestraint%atoms(1)%adps_cart(it,jt),
     3    'Fixed', 'U[',it,jt,']'
        WRITE(NCWU,3286) KF, 
     1    subrestraint%atoms(2)%label,subrestraint%atoms(2)%serial,
     2    (ISTORE(M),M=JD,JE),subrestraint%atoms(2)%adps_cart(it,jt),
     3    subrestraint%atoms(2)%adps_cart(it,jt)-B, 'U[',it,jt,']'
      ENDIF      
       
3287  FORMAT(1X,A1,2X, (2X,A4,I4,1X,E10.3,1X),2X,1PE10.3,8X,A,I0,I0,A)
      it=1
      jt=2
      WRITE(CMON, 3287) KF,subrestraint%atoms(1)%label,
     1  subrestraint%atoms(1)%serial,
     2  subrestraint%atoms(1)%adps_cart(it,jt),
     3  subrestraint%atoms(1)%adps_cart(it,jt)-B, ! B is the target
     4  'U[',it,jt,']'
      CALL XPRVDU(NCVDU, 1,0)
      WRITE(CMON, 3287) KF,subrestraint%atoms(2)%label,
     1  subrestraint%atoms(2)%serial,
     2  subrestraint%atoms(2)%adps_cart(it,jt),
     3  subrestraint%atoms(2)%adps_cart(it,jt)-B, ! B is the target
     4  'U[',it,jt,']'
      CALL XPRVDU(NCVDU, 1,0)
      it=1
      jt=3
      WRITE(CMON, 3287) KF,subrestraint%atoms(1)%label,
     1  subrestraint%atoms(1)%serial,
     2  subrestraint%atoms(1)%adps_cart(it,jt),
     3  subrestraint%atoms(1)%adps_cart(it,jt)-B, ! B is the target
     4  'U[',it,jt,']'
      CALL XPRVDU(NCVDU, 1,0)
      WRITE(CMON, 3287) KF,subrestraint%atoms(2)%label,
     1  subrestraint%atoms(2)%serial,
     2  subrestraint%atoms(2)%adps_cart(it,jt),
     3  subrestraint%atoms(2)%adps_cart(it,jt)-B, ! B is the target
     4  'U[',it,jt,']'
      CALL XPRVDU(NCVDU, 1,0)
      it=2
      jt=3
      WRITE(CMON, 3287) KF,subrestraint%atoms(1)%label,
     1  subrestraint%atoms(1)%serial,
     2  subrestraint%atoms(1)%adps_cart(it,jt),
     3  subrestraint%atoms(1)%adps_cart(it,jt)-B, ! B is the target
     4  'U[',it,jt,']'
      CALL XPRVDU(NCVDU, 1,0)
      WRITE(CMON, 3287) KF,subrestraint%atoms(2)%label,
     1  subrestraint%atoms(2)%serial,
     2  subrestraint%atoms(2)%adps_cart(it,jt),
     3  subrestraint%atoms(2)%adps_cart(it,jt)-B, ! B is the target
     4  'U[',it,jt,']'
      CALL XPRVDU(NCVDU, 1,0)
       
      Q=sum(subrestraint%atoms(1)%adps_cart)
      O=sum(subrestraint%atoms(1)%adps_cart-B)
      P=sum(subrestraint%atoms(1)%adps_cart-B)**2 2
      NCA = 2

      end associate
      
      GOTO 3600
C
C--RIGU RESTRAINTS PRINT
3261  CONTINUE
      do jj=1, 3 ! loop over the U(ij)
C--CHECK IF THIS RESTRAINT IS USEFUL
        CALL XMOVE(IB1(1),KF1(1),1)
        IF(ISTORE(L22PD).eq.4) THEN
          WRITE(CMON,'(A,2x,A,A,A)')'{I ', 
     1      COPERATION(I)(1:NCTRIM(COPERATION(I))),
     1      ' restraint:', ' No derivatives found'
          CALL XPRVDU(NCVDU,1,0)
          IF(ISSPRT.EQ.0)
     1      WRITE(NCWU,'(2x,A,A,A)') 
     2        COPERATION(I)(1:nctrim(COPERATION(I))),
     1        ' restraint: ', ' No derivatives found'
            CALL XMOVE(IQ1(1),KF1(1),1)
        ENDIF
                   
        CALL XDOWNF(M22PD,STORE(L22PD),4)
        if(ISTORE(L22PD)>=0) then
          M22PD=M22PD+KINCRF(ISTORE(L22PD))
        else 
          WRITE(CMON,*)'{E No more derivative to find, programmer error'
          CALL XPRVDU(NCVDU, 1,0)
          WRITE(CMON,*)'{E Please seek advice with the authors'
          CALL XPRVDU(NCVDU, 1,0)
          exit
        end if
      end do
    
!3286  FORMAT('  ',A1,(8X,A4,I5,I6,4I3,F12.7,1X),1PE12.3,6X,A,I0,I0,A)    
!3288  FORMAT('  ',A1,(8X,A4,I5,I6,4I3,F12.7,1X),A12,6X,A,I0,I0,A)    

      associate(subrestraint => restraints_list(ircpt)%subrestraints(1))

      IF (ISSPRT .EQ. 0) THEN       
        it=1
        jt=3
        WRITE(NCWU,3286) KF,
     1    subrestraint%atoms(1)%label,subrestraint%atoms(1)%serial,
     2    (ISTORE(M),M=JD,JE),subrestraint%atoms(1)%adps_cart(it,jt),
     3    subrestraint%atoms(1)%adps_cart(it,jt)-
     4    subrestraint%atoms(2)%adps_cart(it,jt)+B, 'U[',it,jt,']'
        WRITE(NCWU,3286) KF, 
     1    subrestraint%atoms(2)%label,subrestraint%atoms(2)%serial,
     2    (ISTORE(M),M=JD,JE),subrestraint%atoms(2)%adps_cart(it,jt),
     3    subrestraint%atoms(2)%adps_cart(it,jt)-
     4    subrestraint%atoms(1)%adps_cart(it,jt)+B, 'U[',it,jt,']'
        it=2
        jt=3
        WRITE(NCWU,3286) KF,
     1    subrestraint%atoms(1)%label,subrestraint%atoms(1)%serial,
     2    (ISTORE(M),M=JD,JE),subrestraint%atoms(1)%adps_cart(it,jt),
     3    subrestraint%atoms(1)%adps_cart(it,jt)-
     4    subrestraint%atoms(2)%adps_cart(it,jt)+B, 'U[',it,jt,']'
        WRITE(NCWU,3286) KF, 
     1    subrestraint%atoms(2)%label,subrestraint%atoms(2)%serial,
     2    (ISTORE(M),M=JD,JE),subrestraint%atoms(2)%adps_cart(it,jt),
     3    subrestraint%atoms(2)%adps_cart(it,jt)-
     4    subrestraint%atoms(1)%adps_cart(it,jt)+B, 'U[',it,jt,']'
        it=3
        jt=3
        WRITE(NCWU,3286) KF,
     1    subrestraint%atoms(1)%label,subrestraint%atoms(1)%serial,
     2    (ISTORE(M),M=JD,JE),subrestraint%atoms(1)%adps_cart(it,jt),
     3    subrestraint%atoms(1)%adps_cart(it,jt)-
     4    subrestraint%atoms(2)%adps_cart(it,jt)+B, 'U[',it,jt,']'
        WRITE(NCWU,3286) KF, 
     1    subrestraint%atoms(2)%label,subrestraint%atoms(2)%serial,
     2    (ISTORE(M),M=JD,JE),subrestraint%atoms(2)%adps_cart(it,jt),
     3    subrestraint%atoms(2)%adps_cart(it,jt)-
     4    subrestraint%atoms(1)%adps_cart(it,jt)+B, 'U[',it,jt,']'
      ENDIF      
       
!3287  FORMAT(1X,A1,2X, (2X,A4,I4,1X,E10.3,1X),2X,1PE10.3,8X,A,I0,I0,A)
      it=1
      jt=3
      WRITE(CMON, 3287) KF,subrestraint%atoms(1)%label,
     1  subrestraint%atoms(1)%serial,
     2  subrestraint%atoms(1)%adps_cart(it,jt),
     3  subrestraint%atoms(1)%adps_cart(it,jt)-
     4  subrestraint%atoms(2)%adps_cart(it,jt)+B, ! B is the target
     5  'U[',it,jt,']'
      CALL XPRVDU(NCVDU, 1,0)
      WRITE(CMON, 3287) KF,subrestraint%atoms(2)%label,
     1  subrestraint%atoms(2)%serial,
     2  subrestraint%atoms(2)%adps_cart(it,jt),
     3  subrestraint%atoms(2)%adps_cart(it,jt)- ! B is the target
     4  subrestraint%atoms(1)%adps_cart(it,jt)+B, ! B is the target
     4  'U[',it,jt,']'
      CALL XPRVDU(NCVDU, 1,0)
      it=2
      jt=3
      WRITE(CMON, 3287) KF,subrestraint%atoms(1)%label,
     1  subrestraint%atoms(1)%serial,
     2  subrestraint%atoms(1)%adps_cart(it,jt),
     3  subrestraint%atoms(1)%adps_cart(it,jt)-
     4  subrestraint%atoms(2)%adps_cart(it,jt)+B, ! B is the target
     5  'U[',it,jt,']'
      CALL XPRVDU(NCVDU, 1,0)
      WRITE(CMON, 3287) KF,subrestraint%atoms(2)%label,
     1  subrestraint%atoms(2)%serial,
     2  subrestraint%atoms(2)%adps_cart(it,jt),
     3  subrestraint%atoms(2)%adps_cart(it,jt)- ! B is the target
     4  subrestraint%atoms(1)%adps_cart(it,jt)+B, ! B is the target
     4  'U[',it,jt,']'
      CALL XPRVDU(NCVDU, 1,0)
      it=3
      jt=3
      WRITE(CMON, 3287) KF,subrestraint%atoms(1)%label,
     1  subrestraint%atoms(1)%serial,
     2  subrestraint%atoms(1)%adps_cart(it,jt),
     3  subrestraint%atoms(1)%adps_cart(it,jt)-
     4  subrestraint%atoms(2)%adps_cart(it,jt)+B, ! B is the target
     5  'U[',it,jt,']'
      CALL XPRVDU(NCVDU, 1,0)
      WRITE(CMON, 3287) KF,subrestraint%atoms(2)%label,
     1  subrestraint%atoms(2)%serial,
     2  subrestraint%atoms(2)%adps_cart(it,jt),
     3  subrestraint%atoms(2)%adps_cart(it,jt)- ! B is the target
     4  subrestraint%atoms(1)%adps_cart(it,jt)+B, ! B is the target
     4  'U[',it,jt,']'
      CALL XPRVDU(NCVDU, 1,0)
       
      Q=sum(subrestraint%atoms(1)%adps_cart)
      O=sum(subrestraint%atoms(1)%adps_cart-B)
      P=sum(subrestraint%atoms(1)%adps_cart-B)**2 2
      NCA = 2

      end associate
      goto 3600
      
C--ULIJ RESTRAINTS PRINT
3262  CONTINUE
      A1(3)=A1(2)
      A1(2)=2.*SQRT(STORE(L22PD+3))
      A1(1)=0.5*(A1(2)-A1(3))
      A1(2)=A1(2)-A1(1)-B
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(1),STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=2,3)
      ENDIF
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C )) THEN
c         WRITE(NCAWU,3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
c     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C )) THEN
         WRITE(CMON, 3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
      CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
      JB=ISTORE(JA)
      JC=ISTORE(JB)
      JA=ISTORE(JC)
      GOTO 3550
      
C--UPLANE RESTRAINTS PRINT
3263  CONTINUE
      do jj=1, 2 ! loop over the 2 U(ij) U[12] and U[23]
C--CHECK IF THIS RESTRAINT IS USEFUL
        CALL XMOVE(IB1(1),KF1(1),1)
        IF(ISTORE(L22PD).eq.4) THEN
          WRITE(CMON,'(A,2x,A,A,A)')'{I ', 
     1      COPERATION(I)(1:NCTRIM(COPERATION(I))),
     1      ' restraint:', ' No derivatives found'
          CALL XPRVDU(NCVDU,1,0)
          IF(ISSPRT.EQ.0)
     1      WRITE(NCWU,'(2x,A,A,A)') 
     2        COPERATION(I)(1:nctrim(COPERATION(I))),
     1        ' restraint: ', ' No derivatives found'
            CALL XMOVE(IQ1(1),KF1(1),1)
        ENDIF
                   
        CALL XDOWNF(M22PD,STORE(L22PD),4)
        if(ISTORE(L22PD)>=0) then
          M22PD=M22PD+KINCRF(ISTORE(L22PD))
        else 
          WRITE(CMON,*)'{E No more derivative to find, programmer error'
          CALL XPRVDU(NCVDU, 1,0)
          WRITE(CMON,*)'{E Please seek advice with the authors'
          CALL XPRVDU(NCVDU, 1,0)
          exit
        end if
      end do
    
!3296  FORMAT('  ',A1,(8X,A4,I5,I6,4I3,F12.7,1X),1PE12.3,6X,A)    

      associate(subrestraint => restraints_list(ircpt)%subrestraints(1))

      IF (ISSPRT .EQ. 0) THEN              
        WRITE(NCWU,3296) KF,
     1    subrestraint%atoms(1)%label,subrestraint%atoms(1)%serial,
     2    (ISTORE(M),M=JD,JE), subrestraint%atoms(1)%adps_cart(1,2),
     3    subrestraint%atoms(1)%adps_cart(1,2)-B, 'U[12]'
        WRITE(NCWU,3296) KF, 
     1    subrestraint%atoms(1)%label,subrestraint%atoms(1)%serial,
     2    (ISTORE(M),M=JD,JE), subrestraint%atoms(1)%adps_cart(1,3),
     3    subrestraint%atoms(1)%adps_cart(2,3)-B, 'U[23]'     
      ENDIF      
       
!3297  FORMAT(1X,A1,2X, (2X,A4,I4,1X,E10.3,1X),2X,1PE10.3,8X,A)
      WRITE(CMON, 3297) KF,subrestraint%atoms(1)%label,
     1   subrestraint%atoms(1)%serial,
     2   subrestraint%atoms(1)%adps_cart(1,2),
     3   subrestraint%atoms(1)%adps_cart(1,2)-B, ! B is the target
     4   'U[12]'
      CALL XPRVDU(NCVDU, 1,0)
       
      WRITE(CMON, 3297) KF,subrestraint%atoms(1)%label,
     1   subrestraint%atoms(1)%serial,
     2   subrestraint%atoms(1)%adps_cart(2,3),
     3   subrestraint%atoms(1)%adps_cart(2,3)-B, ! B is the target
     4   'U[23]'
      CALL XPRVDU(NCVDU, 1,0)
       
      Q=subrestraint%atoms(1)%adps_cart(1,2)+
     1  subrestraint%atoms(1)%adps_cart(2,3)
      O=subrestraint%atoms(1)%adps_cart(1,2)-B + 
     1  subrestraint%atoms(1)%adps_cart(2,3)-B
      P=(subrestraint%atoms(1)%adps_cart(1,2)-B)**2 + 
     1  (subrestraint%atoms(1)%adps_cart(2,3)-B)**2
      NCA = 2

      end associate
      GOTO 3600
C         
C--UXXQIV RESTRAINTS PRINT
3264  CONTINUE
      
      A1(3)=A1(2)
      A1(2)=2.*SQRT(STORE(L22PD+3))
      A1(1)=0.5*(A1(2)-A1(3))
      A1(2)=A1(2)-A1(1)-B
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(1),STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=2,3)
      ENDIF
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C )) THEN
c         WRITE(NCAWU,3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
c     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C )) THEN
         WRITE(CMON, 3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
c     print *,
c     print *, 'Cycle 0: ',ISTORE(JA)
      CYCLER = ISTORE(JA)           ! Cycle 1
c     print *, 'Cycle 1: ',ISTORE(CYCLER)
      CYCLER = ISTORE(CYCLER)       ! Cycle 2
c     print *, 'Cycle 2: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 3
C     print *, 'Cycle 3: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 4
C     print *, 'Cycle 4: ',ISTORE(CYCLER)
      JA=ISTORE(CYCLER)             ! Final Cycle
c     print *, 'Cycle 5: ',ISTORE(JA)
c     print *, 'JA: ',JA
c      print *,
      GOTO 3550
C         
C--UXYQIV RESTRAINTS PRINT
3265  CONTINUE
      A1(3)=A1(2)
c     print *, 'L22PD read', L22PD
      A1(2)=2.*SQRT(STORE(L22PD+3))
      A1(1)=0.5*(A1(2)-A1(3))
      A1(2)=A1(2)-A1(1)-B
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(1),STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=2,3)
      ENDIF
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C )) THEN
c         WRITE(NCAWU,3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
c     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C )) THEN
         WRITE(CMON, 3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
c     print *,
c     print *, 'Cycle 0: ',ISTORE(JA)
      CYCLER = ISTORE(JA)           ! Cycle 1
c     print *, 'Cycle 1: ',ISTORE(CYCLER)
      CYCLER = ISTORE(CYCLER)       ! Cycle 2
c     print *, 'Cycle 2: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 3
C     print *, 'Cycle 3: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 4
C     print *, 'Cycle 4: ',ISTORE(CYCLER)
      JA=ISTORE(CYCLER)             ! Final Cycle
c     print *, 'Cycle 5: ',ISTORE(JA)
c     print *, 'JA: ',JA
c      print *,
      JA = -1000000
      GOTO 3550
C         
C--UXZQIV RESTRAINTS PRINT
3266  CONTINUE
      A1(3)=A1(2)
      A1(2)=2.*SQRT(STORE(L22PD+3))
      A1(1)=0.5*(A1(2)-A1(3))
      A1(2)=A1(2)-A1(1)-B
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(1),STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=2,3)
      ENDIF
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C )) THEN
c         WRITE(NCAWU,3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
c     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C )) THEN
         WRITE(CMON, 3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
c     print *,
c     print *, 'Cycle 0: ',ISTORE(JA)
      CYCLER = ISTORE(JA)           ! Cycle 1
c     print *, 'Cycle 1: ',ISTORE(CYCLER)
      CYCLER = ISTORE(CYCLER)       ! Cycle 2
c     print *, 'Cycle 2: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 3
C     print *, 'Cycle 3: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 4
C     print *, 'Cycle 4: ',ISTORE(CYCLER)
      JA=ISTORE(CYCLER)             ! Final Cycle
c     print *, 'Cycle 5: ',ISTORE(JA)
c         print *, 'JA: ',JA
c      print *,
      JA = -1000000
      GOTO 3550
C         
C--UYYQIV RESTRAINTS PRINT
3267  CONTINUE
      A1(3)=A1(2)
      A1(2)=2.*SQRT(STORE(L22PD+3))
      A1(1)=0.5*(A1(2)-A1(3))
      A1(2)=A1(2)-A1(1)-B
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(1),STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=2,3)
      ENDIF
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C )) THEN
c         WRITE(NCAWU,3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
c     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C )) THEN
         WRITE(CMON, 3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
c     print *,
c     print *, 'Cycle 0: ',ISTORE(JA)
      CYCLER = ISTORE(JA)           ! Cycle 1
c     print *, 'Cycle 1: ',ISTORE(CYCLER)
      CYCLER = ISTORE(CYCLER)       ! Cycle 2
c     print *, 'Cycle 2: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 3
C     print *, 'Cycle 3: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 4
C     print *, 'Cycle 4: ',ISTORE(CYCLER)
      JA=ISTORE(CYCLER)             ! Final Cycle
c     print *, 'Cycle 5: ',ISTORE(JA)
c     print *, 'JA: ',JA
c      print *,
      JA = -1000000
      GOTO 3550
C         
C--UYZQIV RESTRAINTS PRINT
3268  CONTINUE
      A1(3)=A1(2)
      A1(2)=2.*SQRT(STORE(L22PD+3))
      A1(1)=0.5*(A1(2)-A1(3))
      A1(2)=A1(2)-A1(1)-B
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(1),STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=2,3)
      ENDIF
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C )) THEN
c         WRITE(NCAWU,3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
c     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C )) THEN
         WRITE(CMON, 3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
c     print *,
c     print *, 'Cycle 0: ',ISTORE(JA)
      CYCLER = ISTORE(JA)           ! Cycle 1
c     print *, 'Cycle 1: ',ISTORE(CYCLER)
      CYCLER = ISTORE(CYCLER)       ! Cycle 2
c     print *, 'Cycle 2: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 3
C     print *, 'Cycle 3: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 4
C     print *, 'Cycle 4: ',ISTORE(CYCLER)
      JA=ISTORE(CYCLER)             ! Final Cycle
c     print *, 'Cycle 5: ',ISTORE(JA)
c      print *, 'JA: ',JA
c      print *,
      JA = -1000000
      GOTO 3550
C         
C--UZZQIV RESTRAINTS PRINT
3269  CONTINUE
      A1(3)=A1(2)
      A1(2)=2.*SQRT(STORE(L22PD+3))
      A1(1)=0.5*(A1(2)-A1(3))
      A1(2)=A1(2)-A1(1)-B
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(1),STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=2,3)
      ENDIF
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C )) THEN
c         WRITE(NCAWU,3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
c     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C )) THEN
         WRITE(CMON, 3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
c     print *,
c     print *, 'Cycle 0: ',ISTORE(JA)
      CYCLER = ISTORE(JA)           ! Cycle 1
c     print *, 'Cycle 1: ',ISTORE(CYCLER)
      CYCLER = ISTORE(CYCLER)       ! Cycle 2
c     print *, 'Cycle 2: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 3
C     print *, 'Cycle 3: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 4
C     print *, 'Cycle 4: ',ISTORE(CYCLER)
      JA=ISTORE(CYCLER)             ! Final Cycle
c     print *, 'Cycle 5: ',ISTORE(JA)
c     print *, 'JA: ',JA      
c     print *,
      JA = -1000000
      GOTO 3550
C         
C
C--U(IJ) RESTRAINT
3300  CONTINUE
      JS=ISTORE(JA+16)
      JT=ISTORE(JB+16)
C--CHECK THAT BOTH ATOMS ARE ANISO
CDJWAPR99 - REMEBER THAT JS+6 IS JUST A FLAG NOW, AND RESULT SHOULD BE
C           BE ZERO
C      IF(ABS(STORE(JS+6))+ABS(STORE(JT+6))-2.*UISO)3350,3500,3500
cdjwjun09 - print out names of iso atoms
      IF(ABS(STORE(JS+6))+ABS(STORE(JT+6)).lt.UISO) then
3350   CONTINUE
c       write(123,'(10f8.5)') (store(idjw),idjw=js+14,js+24,2)
c       write(123,'(10f8.5)') (store(idjw),idjw=jt+14,jt+24,2)
       jdjw = 14
       DO 3450 JJ=8,13
       adjw = store(js+jdjw)
       bdjw = store(jt+jdjw)
C--CHECK IF THIS RESTRAINT IS USEFUL
      CALL XMOVE(IB1(1),KF1(1),1)
      IF(ISTORE(L22PD).eq.4) THEN
         WRITE(CMON,'(A,2x,A,A,A)')'{I ', 
     1   COPERATION(I)(1:NCTRIM(COPERATION(I))),
     1 ' restraint:', ' No derivatives found'
         CALL XPRVDU(NCVDU,1,0)
         IF(ISSPRT.EQ.0)
     1 WRITE(NCWU,'(2x,A,A,A)')COPERATION(I)(1:nctrim(COPERATION(I))),
     1 ' restraint: ', ' No derivatives found'
         CALL XMOVE(IQ1(1),KF1(1),1)
      ENDIF

       A1(3)=STORE(L22PD+2)
       A1(2)=2.*SQRT(STORE(L22PD+3))
       A1(1)=0.5*(A1(2)-A1(3))
       A1(2)=A1(2)-A1(1)-B
c       write(123,'(i6,2f8.5,2x,2f8.5,5x,3f8.5))') 
c     1 jdjw,adjw,bdjw,store(l22pd+2),store(l22pd+3),a1(1),a1(2),a1(3)
c
c Extracting Uij as a1(1) and a1(2) from Store(l22pd+ ) does not 
c recover the original values because L22pd+3 is a squared value, so the
c sign is lost.
c It might be better to use original values at JS and JT.
c
       IF (ISSPRT .EQ. 0) THEN
       WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 adjw,STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),bdjw,A1(3)
     3 ,(ICOORD(idjw,JJ),idjw=1,NWKA)
       ENDIF
c       IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C ))  THEN
c         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C ))THEN
         WRITE(CMON,3251) KF, STORE(JA+2), ISTORE(JA+3), adjw,
     2   STORE(JB+2),ISTORE(JB+3),bdjw,A1(3),
     3   (ICOORD(idjw,JJ),idjw=1,NWKA)
         CALL XPRVDU(NCVDU, 1,0)
c         ENDIF
c       ENDIF
C--ACCUMUALTE THE MEANS ETC.
       O=O+A1(3)
       P=P+A1(3)*A1(3)
       Q=Q+0.5*(A1(1)+A1(2)+B)
C--CHECK IF THIS IS THE LAST U(IJ) FOR THIS ATOM
       IF(JJ-13)3400,3450,3400
3400   CONTINUE
       CALL XDOWNF(M22PD,STORE(L22PD),4)
       M22PD=M22PD+KINCRF(ISTORE(L22PD))
       NCA=NCA+1
       jdjw = jdjw + 2
3450   CONTINUE
      else
       if(issprt.eq.0) WRITE(ncwu,'(2x,A1,2(8X,A4,I5,31x),A)')
     2 KF,STORE(JA+2),ISTORE(JA+3), STORE(JB+2),ISTORE(JB+3),
     3 'Isotropic'
       write(cmon,'(1x,a1,2x,2(2x,a4,i4,10x),a)')
     2 KF,STORE(JA+2),ISTORE(JA+3), STORE(JB+2),ISTORE(JB+3),
     3 'Isotropic'
       call xprvdu(ncvdu, 1,0)
      endif
C--CHANGE ATOMS
3500  CONTINUE
      JA=ISTORE(JB)
      IF(JA)3600,3600,2550
C
C--ACCUMULATE THE MEANS ETC.
3550  CONTINUE
      O=O+A1(2)
      P=P+A1(2)*A1(2)
      Q=Q+A1(1)
      IF(JA)3600,3600,2550
C
C--END OF PRINTING FOR THIS RESTRAINT
3600  CONTINUE
      R=1./FLOAT(NCA)
      Q=Q*R
C--CHECK IF WE SHOULD PRINT THE MEAN DELTA AND R.M.S. DEVIATION
      IF(N-1)3750,3750,3650
3650  CONTINUE
      O=O*R
      P=SQRT(P*R)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,3700)Q,O,P
      WRITE(CMON,3700) Q, O ,P
      CALL XPRVDU(NCVDU, 1,0)
3700  FORMAT('      Mean value =',F9.4,'  Mean delta =',F9.4,
     2 '  r.m.s. delta =',F9.4)
      GOTO 1050
3750  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3700)Q
      ENDIF
      GOTO 1050
C
C--TERMINATION AND APPLICATION OF THE STORED DERIVATIVES
3800  CONTINUE
      IF(L26WRN.GT.0) THEN
            WRITE(CMON,'(A,6x,a/A,I6,A,A/6x,A )') 
     1      '{I ',' Restraint Checking',
     1      '{I ', L26WRN, ' Restraint warnings:',
     2      ' For on-screen information',
     3      '{I  Issue #PRINT 16 and #CHECK HI '
            CALL XPRVDU(NCVDU,3,0) 
      ENDIF
      CALL XOPMSG (IOPCHK, IOPEND, IVERSN)
      CALL XTIME2(2)
      RETURN
C
C--ERRORS
3900  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU,3950)A
3950  FORMAT(/1H ,F4.0,20H   Restraint ignored)
      GOTO 1050
C
C--'PLANAR' reSTRAINT
4000  CONTINUE
      NN=0
      N=2
C--COMPUTE THE PLANE AND DERIVATIVES
      IDWZAP = 0
      IF(KPLANE(IDWZAP))3900,4050,4050
C--PRINT THE HEADER
4050  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU,4100)A,B,(STROM(M),M=1,2),C
4101  FORMAT(/1H ,F4.0,'  Restrain these atoms to be ',F8.3,
     2 2X,' A',' from their mean plane',/' with an E.S.D. of ',F8.3)
4100  FORMAT(/1H ,F4.0,37H   Restrain the following atoms to be,F8.3,
     2 2X,2A4,41H from their mean plane, with an E.S.D. of,F8.3//12X,
     3 4HAtom,7X,15HS(I) L TX TY TZ,5X,5HDelta)
      WRITE(CMON,2460)NINT(A+1), '           Planarity', B,C
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 2500
C
C--PRINT THE INFORMATION FROM A PLANAR RESTRAINT
4150  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4200)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(2)
      ENDIF
4200  FORMAT(2H  ,A1,8X,A4,I5,I6,4I3,F10.3)
      IF ((IMON .GE. 1) .AND. (ABS(A1(2)) .GE. C ) ) THEN
         WRITE(CMON ,4201)KF,STORE(JA+2),ISTORE(JA+3),A1(2)
         CALL XPRVDU(NCVDU, 1,0)
      ENDIF
4201  FORMAT(1X,A1,4X, A4,I4,F7.3)
C--MOVE ONTO THE NEXT ATOM
4250  CONTINUE
      JA=ISTORE(JA)
      GOTO 3550
C
C
C--'SUM' RESTRAINT
4300  CONTINUE
      CALL XSUMCN(1)
      AB=STORE(LCG+2)
      WRITE(CMON,2460)NINT(A+1), '                 Sum', AB,C
      CALL XPRVDU(NCVDU, 1,0)
4310  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU,4350)A,AB,C
4350  FORMAT(1X ,F4.0,' The sum is restrained to be ',
     2 G12.5,'  with an E.S.D. of ',G12.5)
      GOTO 1050
C
C     'ORIGIN' FIXING
5000  CONTINUE
      CALL XSUMCN(2)
      AB=STORE(LCG+2)
      WRITE(CMON,"(I5,1X,A,'. Target ',1PE9.2, ' esd ', 1PE9.2)") 
     1  NINT(A+1), '              Origin', AB,C
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 4310
C
4370  CONTINUE
C----- 'LIMIT' RESTRAINT
      N = 2
      NN = 0
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4380) A,C
      ENDIF
4380  FORMAT ( // , 1X , F4.0 , ' Limit the shifts of the given' ,
     2 ' parameters to 0.0, with an E.S.D. of ',E20.10)
      WRITE(CMON,2460)NINT(A+1), '               Limit', 0.0, C
      CALL XPRVDU(NCVDU, 1,0)
      GO TO 1050
C
C--'AVERAGE' RESTRAINT
4400  CONTINUE
      N=2
      NN=0
C--COMPUTE THE VALUES ETC.
      MM=1
      IF(KAVERG(MM))3900,4450,4450
C--PRINT OUT THE HEADER
4450  CONTINUE
      AB=STORE(LCG+2)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4500)A,AB,C
      ENDIF
4501  FORMAT(/1H ,F4.0,' Restrain these to their common',
     2 ' mean of ',F10.5,'  with an E.S.D. of', F10.5)
4500  FORMAT(/1H ,F4.0,39H   Restrain the following parameters to,
     2 21H their common mean of,F10.5,19H  with an E.S.D. of,
     3 F10.5//12X,4HAtom,7X,15HS(I) L TX TY TZ,5X,9HParameter,8X,
     4 5HValue,5X,5HDelta)
      WRITE(CMON,2460)NINT(A+1), '             Average', AB,C
      CALL XPRVDU(NCVDU, 1,0)
C--RESET THE OBSERVED VALUE
      B=STORE(LCG+4)
      GOTO 2500
C
4540  CONTINUE
C----- DO NOT PRINT THE LIMIT RESTRAINT
      MM = 1
      GOTO 1050
C
C--PRINT FOR THE 'AVERAGE' RESTRAINT
4550  CONTINUE
      MM = 2
C
      JB=ISTORE(JA+6)
      JC=ISTORE(JB+1)
C--CHECK ON THE TYPE OF THE CURRENT PARAMETER
      IF(ISTORE(JA+1)-1)4600,4700,4800
C--THIS IS AN ATOMIC PARAMETER
4600  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4650)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 (ICOORD(idjw,JC),idjw=1,2), (A1(M),M=1,MM)
      ENDIF
4650  FORMAT(2H  ,A1,8X,A4,I5,I6,4I3,6X,2A4,4X,2F10.5)
      IF ((IMON .GE. 1) .AND. (ABS(A1(2)) .GE. C) ) THEN
       WRITE(CMON,4651)KF,STORE(JA+2),ISTORE(JA+3),
     2 (ICOORD(idjw,JC),idjw=1,2), (A1(M),M=1,MM)
       CALL XPRVDU(NCVDU, 1,0)
      ENDIF
4651  FORMAT(1X,A1,4X,A4,I4,2X,2A4,2X,2F10.5)
      GOTO 4250
C--THIS IS A SIMPLE OVERALL PARAMETER
4700  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4750)KF,(KVP(M,JC),M=1,2), (A1(M),M=1,MM)
      ENDIF
4750  FORMAT(2H  ,A1,41X,2A4,4X,2F10.5)
      IF ((IMON .GE. 1) .AND. (ABS(A1(2)) .GE. C) ) THEN
       WRITE(CMON,4751)KF,(KVP(M,JC),M=1,2), (A1(M),M=1,MM)
       CALL XPRVDU(NCVDU, 1,0)
      ENDIF
4751  FORMAT(1X,A1,10X,2A4,2X,2F10.5)
      GOTO 4250
C--THIS IS AN ELEMENT OR LAYER SCALE FACTOR
4800  CONTINUE
      JB=ISTORE(JA+1)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4850) KF,(KSCAL(M,JB),M=1,2), (A1(M),M=1,MM)
      ENDIF
4850  FORMAT(2H  ,A1,38X,2A4,4X,3X,2F10.5)
      IF ((IMON .GE. 1) .AND. (ABS(A1(2)) .GE. C) ) THEN
       WRITE(CMON,4851) KF,(KSCAL(M,JB),M=1,2), (A1(M),M=1,MM)
       CALL XPRVDU(NCVDU, 1,0)
      ENDIF
4851  FORMAT(1X,A1,7X,2A4,4X,1X,2F10.5)
      GOTO 4250
C
9900  CONTINUE
C -- ERRORS
      CALL XOPMSG ( IOPCHK , IOPABN , 0 )
      GO TO 3800
9910  CONTINUE
C -- INPUT ERRORS
      CALL XOPMSG ( IOPCHK , IOPCMI , 0 )
      GO TO 9900
      END
C
CODE FOR XAPP16
      SUBROUTINE XAPP16(calconlyarg)
      use list26_mod
C--APPLY THE RESTRAINTS
C
C  THIS SUBROUTINE READS DOWN THE LIST 26 AND CALCULATES THE
C  REQUIRED RESTRAINTS.
C  THIS SUBROUTINE IS RESPONSIBLE FOR FORMING THE PARTIAL
C  DERIVATIVE QUEUE ON THE DISC AND THEN ADDING IT TO LIST 11
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST23.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'XL26WK.INC'
C
      INCLUDE 'QSTORE.INC'
      
      logical, optional, intent(in) :: calconlyarg
      logical calconly
      integer ISTAT2OLD
      
C
      interface 
          subroutine XCVCV(iaxis,iasym, results)
              use list26_mod
              integer, intent(in) :: iaxis
              integer, intent(in) :: iasym
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
      interface 
          subroutine XCVCV2(iasym, results)
              use list26_mod
              integer, intent(in) :: iasym
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
      interface 
          subroutine XCVCW(iaxis, iasym, results)
              use list26_mod
              integer, intent(in) :: iaxis
              integer, intent(in) :: iasym
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
      interface 
          subroutine XCVCA(iasym, results)
              use list26_mod
              integer, intent(in) :: iasym
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
      interface 
          subroutine XCVCR(iasym, results)
              use list26_mod
              integer, intent(in) :: iasym
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
      interface 
          subroutine XADCPD(calconlyarg)
              logical, optional, intent(in) :: calconlyarg
          end subroutine
      end interface
      
      integer, dimension(8) :: IBUFF
      real, dimension(:), allocatable :: card
      character(len=:), allocatable :: cline
      character(len=24) :: fline
      character eol
      integer list16_index
      
      calconly=.false.
      if(present(calconlyarg)) then
        if(calconlyarg) then
          calconly=.true.
        end if
      end if
C
      DATA IVERSN /403/
C
      if(.not. calconly) then
C--INITIATE THE TIMING
        CALL XTIME1(2)
C--READ THE REMAINING CONTROL CARDS
        I=KRDDPV(ISTORE(NFL),1)
        IF ( I .LT. 0 ) GO TO 9910
      end if
C--CLEAR THE CORE AREA
      CALL XRSL
      CALL XCSAE
C----- FETCH LIST 23 TO SEE IF RESTRAINTS ARE NEEDED
      CALL XFAL23
      IF(ISTORE(L23MN+2) .LT. 0) GOTO 1770
C----- LOAD LIST 3 IF IT EXISTS
      KLST3 = -1
        IF (KEXIST(3) .GT. 0) CALL XFAL03
C--LOAD LIST 5
      CALL XFAL05
C--SET UP THE SYSTEM VARIABLES IN CORE
      CALL XLSV
C--LOAD LIST 12
      CALL XFAL12(-1,1,JR,JN)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--LINK LIST 5 AND LIST 12
      I=KSET52(0,-1)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C
C---- SET TYPE AND INITIALISE THE NO DERIVATIVES FOUND COUNTER
      L26TYP = 1       !APPLY
      L26WRN = 0
C
C--SET UP THE POINTERS FOR THE DERIVATIVE QUEUE ON DISC
      CALL XIPDQF
C--LOAD THE COMPILED LIST FOR PROCESSING
      IULN=26
      CALL XLCLFP(IULN)
      IF ( IERFLG .LT. 0 ) GO TO 9900

      ! loading list 16
      ISTAT = KLSCHK ( 16 , 0 , 0 , ILSAVI , ILSMSG , IADDR , IERERR )
      IF ( ISTAT .LE. 0 ) GO TO 9900
      CALL XRLIND ( 16 , LSN , NEXT , LL , IOW , NOS , ID ) ! next is now the start address of the chain list

      last=0 ! start of the chain      
      if(allocated(restraints_list)) deallocate(restraints_list) ! reset previous list
      if(allocated(subrestraints_parent)) then
        deallocate(subrestraints_parent) ! reset previous list
      end if
      idjwtemp=0
      list16_index=-1 ! user restraints counter
      
C--BRING DOWN THE NEXT BLOCK OF CODE AND RELOCATE IT
1000  CONTINUE
      ISTAT2OLD=ISTAT2
      if(calconly) then
        ISTAT2=0
      end if
      IF(KLOADR(LN))1850,1050,1750
C--JUMP ON THE FUNCTION
1050  CONTINUE
      idjwtemp=idjwtemp+1 ! generated restraint counter. Some user restraints generates several restraints
      current_restraintindex=idjwtemp ! same counter but in list26_mod
      
      ! check storage space for the next restraint  
      if(.not. allocated(restraints_list)) then
        call extend(restraints_list)      
      else if(idjwtemp>size(restraints_list)) then
        call extend(restraints_list)
      end if        

      ! looking for the corresponding user restraint in list16,list17
      restraints_list(idjwtemp)%user_index=ISTORE(LCG+5)
      icpt=0 ! counter used to avoid infinite loop
      do while(list16_index<ISTORE(LCG+5))
        icpt=icpt+1

        i=KLDDRH(LAST,NEXT,IBUFF) ! getting metadata in ibuff and pointing to next record
        if(i<0) then
          ! end of list 16, switching to list 17
          ISTAT = KLSCHK ( 17, 0, 0, ILSAVI, ILSMSG , IADDR , IERERR )
          IF ( ISTAT .LE. 0 ) GO TO 9900
          CALL XRLIND ( 17 , LSN , NEXT , LL , IOW , NOS , ID ) ! next is now the start address of the chain list
          last=0 ! start of the chain      
          i=KLDDRH(LAST,NEXT,IBUFF)
          if(i<0) call abort() ! this is not normal
        end if              

        restraints_list(idjwtemp)%restraint_text=''
        list16_index=list16_index+1
        if(icpt>1000) call abort() ! "infinite" loop
        do ! Now loading the restraint
          IF(IBUFF(7)>0) then
            exit !end of restraint
          end if
          L=IBUFF(4)
          if(allocated(card)) deallocate(card)
          allocate(card(ibuff(5)))
          if(allocated(cline)) deallocate(cline)
          allocate(character(len=ibuff(5)*4) :: cline)
          write(fline, "(A, I0, A)") "(",ibuff(5),"A4)"
          eol=char(10)
          do i=1, IBUFF(6)
            if(i==IBUFF(6)) eol=''
            CALL XDOWNF(L,CARD(1),IBUFF(5)) ! loading data from disc to card
            WRITE(CLINE,fline)  CARD ! transfering fata to text
            restraints_list(idjwtemp)%restraint_text=
     &      trim(restraints_list(idjwtemp)%restraint_text)//
     &      trim(cline)//eol
            L=L+KINCRF(IBUFF(5)) ! calculating next address 
          end do 
       
          ! loading next line
          i=KLDDRH(LAST,NEXT,IBUFF)
        end do
        
        ! Warning the user that a restraint was found but ignored        
        if(list16_index<ISTORE(LCG+5)) then
          associate(r => restraints_list(idjwtemp))
            if(index(r%restraint_text,'REM')==0 .and.
     1         index(r%restraint_text,'COMP')==0 .and.
     1         index(r%restraint_text,'EXEC')==0
     1         ) then
              WRITE(CMON,'("{E",1X, "(",I0,")",1X, A)') list16_index,
     1          trim(r%restraint_text)
              CALL XPRVDU(NCVDU, 1,0)      
              WRITE(CMON,'("{E", 4X, A)') 'Restraint in error'
              CALL XPRVDU(NCVDU, 1,0)      
            end if
          end associate            
        end if             
      end do ! found the user restraint
      
      I=ISTORE(LCG+1)
cdjwsep2011
      if(i .lt. 1) then
       iasym = 1
       i = abs(i)
      else
       iasym = 0
      endif
      GOTO(1150,1200,1250,1300,1350,1400,1450,1500,1550,1600,1650,1700,
     2 1950,2000,2050,2100,2150,2200,2250,2055,1560,1570,1580,1565,1575,
     2 1590,1591,1592,1593,1594,1595,1596,1597,1598,1599,1100) ,I
1100  CONTINUE
      CALL XOPMSG (IOPL16, IOPINT, 0)
      GOTO 9900
C
C--'DEFINE' FUNCTION
1150  CONTINUE
      CALL XCDEF
      GOTO 1000
C
C--'RESTRAIN' FUNCTION
1200  CONTINUE
      CALL XCC
      GOTO 1000
C
C--'SINGLE DISTANCE' RESTRAINTS
1250  CONTINUE
      CALL XCDC(iasym)
      GOTO 1000
C
C--'DISTANCE DIFFERENCE' RESTRAINTS
1300  CONTINUE
      CALL XCDDC(iasym)
      GOTO 1000
C
C--'MEAN DISTANCE' RESTRAINT
1350  CONTINUE
      CALL XCMDC(iasym)
      GOTO 1000
C
C--'SINGLE ANGLE' RESTRAINTS
1400  CONTINUE
      CALL XCAC
      GOTO 1000
C
C--'ANGLE DIFFERENCE' RESTRAINTS
1450  CONTINUE
      CALL XCADC
      GOTO 1000
C
C--'MEAN ANGLE' RESTRAINT
1500  CONTINUE
      CALL XCMAC
      GOTO 1000
C
C--'VIBRATION' RESTRAINT
1550  CONTINUE
      CALL XCVC(iasym)
      GOTO 1000
C
C--'UXZBAR' RESTRAINT
1560  CONTINUE
      CALL XCVCX(1,iasym)
      GOTO 1000
C
C--'UYZBAR' RESTRAINT
1570  CONTINUE
      CALL XCVCX(2,iasym)
      GOTO 1000
C--'UZZBAR' RESTRAINT
1580  CONTINUE
      CALL XCVCX(3,iasym)
      GOTO 1000
C
C--'UPERP' RESTRAINT
1565  CONTINUE
      CALL XCVCV(1,iasym, restraints_list(idjwtemp))
      GOTO 1000
C
C--'UPERP2' RESTRAINT
1575  CONTINUE
      CALL XCVCV2(iasym, restraints_list(idjwtemp))
      GOTO 1000  
C
C--'UALIGN' RESTRAINT
1590  CONTINUE
      CALL XCVCA(iasym, restraints_list(idjwtemp))
      GOTO 1000  
C
C--'RIGU' RESTRAINT
1591  CONTINUE
      CALL XCVCR(iasym, restraints_list(idjwtemp))
      GOTO 1000  

C--'ULIJ' RESTRAINT
1592  CONTINUE
      CALL XCVCL(iasym)
      GOTO 1000  

C--'UPLANE' RESTRAINT
1593  CONTINUE
      CALL XCVCW(0,iasym, restraints_list(idjwtemp))
      GOTO 1000  
C     
C--'UXXQIV' RESTRAINT
1594  CONTINUE
      CALL XCVCY(1,iasym)
      GOTO 1000 
C     
C--'UXYQIV' RESTRAINT
1595  CONTINUE
      CALL XCVCY(2,iasym)
      GOTO 1000 
C     
C--'UXZQIV' RESTRAINT
1596  CONTINUE
      CALL XCVCY(3,iasym)
      GOTO 1000 
C     
C--'UYYQIV' RESTRAINT
1597  CONTINUE
      CALL XCVCY(4,iasym)
      GOTO 1000 
C     
C--'UYZQIV' RESTRAINT
1598  CONTINUE
      CALL XCVCY(5,iasym)
      GOTO 1000 
C     
C--'UZZQIV' RESTRAINT
1599  CONTINUE
      CALL XCVCY(6,iasym)
      GOTO 1000 
C     

C--'EXECUTION LISTING'
1600  CONTINUE
      if(.not. calconly) then
        ISTAT2=1
      end if
      GOTO 1000
C
C--'NO LISTING'
1650  CONTINUE
      ISTAT2=0
      GOTO 1000
C
C-'U(IJ)' RESTRAINT
1700  CONTINUE
      CALL XDUIJ(iasym)
      GOTO 1000
C
C--TERMINATION AND APPLICATION OF THE STORED DERIVATIVES
1750  CONTINUE
      ISTAT2=ISTAT2OLD
      CALL XTPDQF
      CALL XADCPD(calconly)
      IF ( IERFLG .LT. 0 ) GO TO 9900
1770  CONTINUE
      IF(L26WRN.GT.0) THEN
            WRITE(CMON,'(A,6x,a/A,I6,A,A/6x,A )') 
     1      '{I ',' Restraint Application',
     1      '{I ', L26WRN, ' Restraint warnings:',
     2      ' For on-screen information',
     3      '{I  Issue #PRINT 16 and #CHECK HI '
            CALL XPRVDU(NCVDU,3,0) 
      ENDIF
      CALL XOPMSG (IOPCPR, IOPEND, IVERSN)
      CALL XTIME2(2)
      RETURN
C
C--ERRORS
1850  CONTINUE
      J=16
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1900)IULN
1900  FORMAT(
     1' List ',I5,' contains errors.',
     2  ' Check the Restraints lists 16 and 17')
      WRITE ( CMON ,1900)IULN
      CALL XPRVDU(NCVDU, 1,0)
      CALL XERHND ( IERERR )
      GO TO 9900
C
C--'EQUATE' RESTRAINT
1950  CONTINUE
      IF(KEQUAT(I))1850,1000,1000
C
C--'PLANAR' RESTRAINT
2000  CONTINUE
      IDWZAP = 0
      IF(KPLANE(IDWZAP))1850,1000,1000
C
C--'SUM' RESTRAINT
2050  CONTINUE
      CALL XSUMCN(1)
      GOTO 1000
C
C--'ORIGIN' RESTRAINT
2055  CONTINUE
      CALL XSUMCN(2)
      GOTO 1000
C
C
C--'FORM' RESTRAINT
2100  CONTINUE
      IF(KFORM(I))1850,1000,1000
C
C--'AVERAGE' RESTRAINT
2150  CONTINUE
      I = 1
      IF(KAVERG(I))1850,1000,1000
C
C----- 'LIMIT' RESTRAINT
2200  CONTINUE
      I = -1
      IF (KAVERG(I))1850,1000,1000
C
C----- ENERGY RESTRAINT
2250  CONTINUE
      CALL XCEC(iasym)
      GOTO 1000
C
9900  CONTINUE
C -- ERRORS
      CALL XOPMSG ( IOPCPR , IOPABN , 0 )
      GO TO 1770
9910  CONTINUE
C -- INPUT ERRORS
      CALL XOPMSG ( IOPCPR , IOPCMI , 0 )
      GO TO 9900
      END
C
CODE FOR XCC
      SUBROUTINE XCC
C--CALCULATE RESTRAINTS FROM THE GIVEN CODE
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XAPK.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET UP A FEW INITIAL CONSTANTS
      MCA=LCA
      STORE(L22PD+2)=STORE(LCG+4)-XVALUE(LC)
C
C--MAIN LOOP FOR PASSING THROUGH THE COORDS. OF EACH ATOM
1000  CONTINUE
      I=ISTORE(MCA+6)
      K=0
C--CHECK IF THIS IS AN ATOM OR AN OVERALL PARAMETER
      IF(ISTORE(MCA+1))1100,1050,1100
C--THIS IS AN ATOM  -  ALTER THE PARAMETER STEP
1050  CONTINUE
      K=NKA+NKA-2
C--CHECK IF ANY PARAMETERS HAVE BEEN GIVEN
1100  CONTINUE
      IF(I)1650,1650,1150
C--CLEAR THE DERIVATIVE SLOTS FOR THIS ATOM OR PARAMETER
1150  CONTINUE
      L=ISTORE(MCA+16)
      M=L+K
      DO 1200 J=L,M,2
      STORE(J+1)=0.0
1200  CONTINUE
C--CHECK IF THIS IS AN ATOM OR AN OVERALL PARAMETER
      IF(K)1250,1250,1300
C--THIS IS AN OVERALL PARAMETER
1250  CONTINUE
      STORE(L+1)=1.
      GOTO 1600
C--THIS IS AN ATOM  -  CHECK THE PARAMETER TYPE
1300  CONTINUE
      IF(ISTORE(I+1)-5)1350,1450,1400
C--'U[ISO]' OR 'OCC'
1350  CONTINUE
      L=L+ISTORE(I+1)+ISTORE(I+1)
      STORE(L-1)=1.0
      GOTO 1600
C--CHECK FOR AN ANISO TEMPERATURE FACTOR
1400  CONTINUE
      IF(ISTORE(I+1)-7)1450,1450,1500
C--POSITIONAL COORD.
1450  CONTINUE
      M=ISTORE(MCA+4)+ISTORE(I+1)
C--GENERATE DERIVS. FOR SHIFTED ATOM
      STORE(L+9)=STORE(MCA+14)*STORE(M-5)
      STORE(L+11)=STORE(MCA+14)*STORE(M-2)
      STORE(L+13)=STORE(MCA+14)*STORE(M+1)
      GOTO 1600
C--ANISO TEMPERATURE TERMS
1500  CONTINUE
      M=L+15
      N=NFL+18
C--FIND THE ADDRESS OF THE RELEVANT PARAMETER
      L=N+ISTORE(I+1)
C--ZERO THE DERIVATIVE AREA
      CALL XZEROF(STORE(N),6)
      STORE(L-8)=1.0
C--COMPUTE THE DERIVATIVES, ALLOWING FOR SYMMETRY
      CALL XEXANI(N,NFL)
      N=ISTORE(MCA+4)
      CALL XMLTTM(STORE(NFL),STORE(N),STORE(NFL+9),3,3,3)
      CALL XMLTTM(STORE(N),STORE(NFL+9),STORE(NFL),3,3,3)
C--STORE THE SYMMETRY GENERATED DERIVATIVES
      STORE(M)=STORE(NFL)
      STORE(M+2)=STORE(NFL+4)
      STORE(M+4)=STORE(NFL+8)
      STORE(M+6)=STORE(NFL+5)
      STORE(M+8)=STORE(NFL+2)
      STORE(M+10)=STORE(NFL+1)
C--CALCULATE THE PARTIAL DERIVATIVE
1600  CONTINUE
      STORE(I+2)=XDERIV(LC)
      I=ISTORE(I)
      GOTO 1100
1650  CONTINUE
      L=ISTORE(MCA+16)
      M=L+K
      DO 1700 J=L,M,2
      STORE(J+1)=0.0
1700  CONTINUE
      MCA=ISTORE(MCA)
      IF(MCA)1750,1750,1000
1750  CONTINUE
      MCA=LCA
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
      RETURN
      END
C
CODE FOR XDUIJ
      SUBROUTINE XDUIJ(iasym)
C--CALCULATE RESTRAINTS ON THE INDIVIDUAL U(IJ)'S
C
c
C      IASYM = 1 FOR ASYMMETRIC OTHERWISE 0
c
CDJWAPR99
C      The Uij entries for both atoms seem to get swapped, though
c      the sign also seems to get inverted. 'Effect' is in the 1984
c      VAX version.
      INCLUDE 'ISTORE.INC'
C
      DIMENSION A1(6)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (A1(1),O)
C
C--SET UP A FEW CONSTANTS
      DUMP=STORE(LCG+4)
      JA=LCA
      NCA=2
C--SET UP THE ADDRESSES OF THE ATOMS
1000  CONTINUE
      JB=ISTORE(JA)
      JC=JA
      DO 1100 I=1,2
      JD=ISTORE(JC+16)
C--CHECK IF THE ATOM IS ANISO
CDJWAPR99 REMEMBER JD+6 IS JUST A FLAG NOW
c     0=aniso, 1 = iso, 2-4 = shape
c      x to u[12] OK 2012
c      write(123,'(10f8.5)') (store(idjw),idjw=jd+8,jd+24,2)
      IF(ABS(STORE(JD+6))-UISO)1050,1400,1400
C--PASS ONTO THE SECOND OF THE PAIR
1050  CONTINUE
      JC=JB
1100  CONTINUE
      JP=ISTORE(JA+6)
      JV=ISTORE(JB+6)
      JC=ISTORE(JA+16)+14
      JD=ISTORE(JB+16)+14
C--ZERO THE DERIVATIVE AREA
      CALL XZEROF(A1(1),6)
C--CALCULATE THE DERIVATIVES FOR THE U(IJ)
      DO 1350 JY=1,6
c      write(123,'(2(i12,f8.5))') jc,store(jc),jd,store(jd)
      JX=JP
      I=1
      JO=JA
      A=1.
C--STORE THE DERIVATIVES
1150  CONTINUE
      if ((i .eq. 1).AND.(iasym .eq.1)) then
c           dont restrain first atom
            a1(jy) = 0.
      else
            a1(jy)=a
      endif
      CALL XADUIJ
      A1(JY)=0.
C--CHECK IF THIS THE FIRST OR SECOND ATOM
      IF(I)1250,1250,1200
1200  CONTINUE
      JO=JB
      JX=JV
      A=-1.
      I=I-1
      GOTO 1150
C--CALCULATE THE MEAN VALUE AND THE DIFFERENCE
1250  CONTINUE
c      write(123,'(a,3f12.6)') 'U-values', dump, store(jc),store(jd)
cdjwmar2012 - should DUMP be outside the brackets?
c     for the asymmetric restraint, should we NOT compute the mean?
      STORE(LCG+4)=0.5*(DUMP+STORE(JC)+STORE(JD))
      STORE(L22PD+2)=DUMP-STORE(JC)+STORE(JD)
      MCA=JA
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
C--CLEAR THE P.D. SLOSTS FOR THE NEXT COORD.
      JQ=JP
      JW=JV
      DO 1300 JX=1,6
      STORE(JQ+2)=0.
      STORE(JW+2)=0.
      JQ=ISTORE(JQ)
      JW=ISTORE(JW)
1300  CONTINUE
c      write(123,'(2(i12,f8.5))') jc,store(jc),jd,store(jd)
      JC=JC+2
      JD=JD+2
1350  CONTINUE
C--PASS ONTO THE NEXT PAIR OF ATOMS
1400  CONTINUE
      JA=ISTORE(JB)
      IF(JA)1450,1450,1000
1450  CONTINUE
      RETURN
      END
C
CODE FOR XCVC
      SUBROUTINE XCVC(iasym)
C--CALCULATE VIBRATION RESTRAINTS
C
C
C      IASYM = 1 FOR ASYMMETRIC OTHERWISE 0
C
C--THE VARIABLES IN 'XWORK' ARE USED AS FOLLOWS :
C
C  P  DU(B)/DU(22)
C  .
C  .
C  T  DU(B)/DU(12)
C
C--SUBSEQUENTLY O TO T ARE USED FOR THE DIFFERENCES BETWEEN THE
C  THE TWO VALUES OF EACH VIBRATION PARAMETER
C
C--
      INCLUDE 'ISTORE.INC'
C
      DIMENSION A1(12)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (O,A1(1))
C
C--SET UP A FEW CONSTANTS                                               CVC00320
      DUMP=STORE(LCG+4)                                                 CVC00330
      JA=LCA                                                            CVC00340
      NCA=2                                                             CVC00350
C--SET UP THE ADDRESSES OF THE ATOMS                                    CVC00360
1000  CONTINUE                                                          CVC00370
      JB=ISTORE(JA)                                                     CVC00380
      JP=ISTORE(JA+6)                                                   CVC00390
      JV=ISTORE(JB+6)                                                   CVC00400
C--SET UP THE ADDRESSES OF THE U(IJ)'S                                  CVC00410
      DO 1050 I=1,3                                                     CVC00420
      JP=ISTORE(JP)                                                     CVC00430
      JV=ISTORE(JV)                                                     CVC00440
1050  CONTINUE                                                          CVC00450
C--CHECK THAT BOTH ATOMS ARE ANISO AND IF NOT MODIFY ACCORDINGLY        CVC00460
      JX=JP                                                             CVC00470
      JC=JA                                                             CVC00480
      DO 1250 I=1,2                                                     CVC00490
      JD=ISTORE(JC+16)                                                  CVC00500
C--CHECK IF THE ATOM IS ANISO                                           CVC00510
c      IF(ABS(STORE(JD+6))-UISO)1200,1100,1100                           CVC0052
      IF(ABS(STORE(JD+6)) .le. zero) goto 1200
C--'ISO' ATOM  -  MODIFY THE ENTRY IN THE COORDINATE SECTION            CVC00530
1100  CONTINUE                                                          CVC00540
cdjw99 The number of parameters
      ISTORE(JC+5)=4                                                    CVC00550
      ISTORE(JX)=-1000000                                               CVC00560
cdjw99 Where they start (iso is now same as U11)
c      ISTORE(JX+1)=4                                                    CVC0057
      ISTORE(JX+1)=8
C--SET THE ANISO TEMPERATURE FACTORS FOR THE ATOM                       CVC00580
      JE=JD                                                             CVC00590
      JF=L1C+2                                                          CVC00600
      DO 1150 J=L1C,JF                                                  CVC00610
cdjw99 Uiso now in same place as U11
c      STORE(JE+14)=STORE(JD+6)                                          CVC0062
      STORE(JE+14)=STORE(JD+14)
      STORE(JE+20)=STORE(JD+14)*STORE(J)                                 CVC0063
      JE=JE+2                                                           CVC00640
1150  CONTINUE                                                          CVC00650
      STORE(JD+6)=0.                                                    CVC00660
C--PASS ONTO THE SECOND OF THE PAIR                                     CVC00670
1200  CONTINUE                                                          CVC00680
      JX=JV                                                             CVC00690
      JC=JB                                                             CVC00700
1250  CONTINUE                                                          CVC00710
C--CALCULATE THE INTERNUCLEAR DISTANCE                                  CVC00720
      JO=JA                                                             CVC00730
      JS=JB                                                             CVC00740
      CALL XCD2PD                                                       CVC00750
      D=SQRT(0.5*(A*F+B*G+C*H))                                         CVC00760
C--APPLY THE RECIPROCAL CELL PARAMETERS                                 CVC00770
      F=F*STORE(L1P2)                                                   CVC00780
      G=G*STORE(L1P2+1)                                                 CVC00790
      H=H*STORE(L1P2+2)                                                 CVC00800
C--CALCULATE THE COMPONENTS APART FROM A SCALING BY 'D'                 CVC00810
      A1(7)=F*F                                                         CVC00820
      A1(8)=G*G                                                         CVC00830
      A1(9)=H*H                                                         CVC00840
      A1(10)=2.*G*H                                                     CVC00850
      A1(11)=2.*F*H                                                     CVC00860
      A1(12)=2.*F*G                                                     CVC00870
C--CALCULATE THE SCALING CONSTANT FOR THE COMPONENTS SQUARED            CVC00880
      E=1./(4.*D*D)                                                     CVC00890
C--CALCULATE THE DERIVATIVES FOR THE U(IJ)                              CVC00900
      DO 1300 I=1,6                                                     CVC00910
      A1(I)=A1(I+6)*E                                                   CVC00920
1300  CONTINUE                                                          CVC00930
      JO=JA                                                             CVC00940
      JX=JP                                                             CVC00950
      I=1                                                               CVC00960
C--STORE THE DERIVATIVES                                                CVC00970
1350  CONTINUE                                                          CVC00980
C--CHECK IF THIS ATOM IS ISO AND NOT ANISO                              CVC00990
      IF(ISTORE(JO+5)-4)1450,1400,1450                                  CVC01000
C--'ISO' ATOM                                                           CVC01010
1400  CONTINUE                                                          CVC01020
      STORE(JX+2)=STORE(JX+2)+A1(1)+A1(2)+A1(3)+A1(4)*STORE(L1C)+A1(5)
     2 *STORE(L1C+1)+A1(6)*STORE(L1C+2)
      IF(I)1600,1600,1500                                               CVC01050
C--'ANISO' ATOM                                                         CVC01060
1450  CONTINUE                                                          CVC01070
      if ((i .eq. 1).AND. (iasym .eq. 1)) then
c           dont restrain first atom
            do jy = 1,6
              a1(jy) = 0
            enddo
      endif
      CALL XADUIJ                                                       CVC01080
C--CHECK IF THIS THE FIRST OR SECOND ATOM                               CVC01090
      IF(I)1600,1600,1500                                               CVC01100
1500  CONTINUE                                                          CVC01110
      JO=JB                                                             CVC01120
      JX=JV                                                             CVC01130
      DO 1550 J=1,6                                                     CVC01140
c      A1(J)=-A1(J)                                                      CVC01150
      a1(j)=a1(j+6)*e *(-1.)                                                   CVC00920
1550  CONTINUE                                                          CVC01160
      I=I-1                                                             CVC01170
      GOTO 1350                                                         CVC01180
C--CALCULATE THE MEAN VALUE AND THE DIFFERENCE                          CVC01190
1600  CONTINUE                                                          CVC01200
      JC=ISTORE(JA+16)                                                  CVC01210
      JD=ISTORE(JB+16)                                                  CVC01220
      SUM=0.                                                            CVC01230
      D=0.                                                              CVC01240
      DO 1650 I=1,6 
c      write(123,'(a,3f12.6)') 'Mean',  store(jc+14),store(jd+14)
c      for the asymmetric restraint, should we NOT compute the mean?
      SUM=SUM+(STORE(JC+14)+STORE(JD+14))*A1(I+6)                       CVC01260
      A1(I)=STORE(JC+14)-STORE(JD+14)                                   CVC01270
      D=D+A1(I)*A1(I+6)                                                 CVC01280
      JC=JC+2                                                           CVC01290
      JD=JD+2                                                           CVC01300
1650  CONTINUE                                                          CVC01310
      STORE(LCG+4)=0.5*(DUMP+SUM*E)                                     CVC01320
      D=D*E                                                             CVC01330
      STORE(L22PD+2)=DUMP-D                                             CVC01340
C--CALCULATE THE DERIVATIVES FOR THE POSITIONAL COORDS.                 CVC01350
      ESAVE=4.*E                                                            CVC01360
      V=(F*O+G*T+H*S)*STORE(L1P2)                                       CVC01370
      W=(F*T+G*P+H*R)*STORE(L1P2+1)                                     CVC01380
      X=(F*S+G*R+H*Q)*STORE(L1P2+2)                                     CVC01390
      F=STORE(L1M1)*V+STORE(L1M1+3)*W+STORE(L1M1+6)*X-F*D/STORE(L1P2)   CVC01400
      G=STORE(L1M1+1)*V+STORE(L1M1+4)*W+STORE(L1M1+7)                   CVC01410
     2 *X-G*D/STORE(L1P2+1)                                             CVC01420
      H=STORE(L1M1+2)*V+STORE(L1M1+5)*W+STORE(L1M1+8)                   CVC01430
     2 *X-H*D/STORE(L1P2+2)                                             CVC01440
      JO=JA
      IF (IASYM .EQ. 1) THEN
         E = 0.                                                             CVC01450
      ELSE
         E = ESAVE
      ENDIF
      CALL XADXYZ                                                       CVC01460
      JO=JB                                                             CVC01470
      E=-ESAVE                                                              CVC01480
      CALL XADXYZ                                                       CVC01490
      MCA=JA                                                            CVC01500
      STORE(L22PD+1) = STORE(LCG+3)                                     CVC01510
      CALL XFMPDQ                                                       CVC01520
      JA=ISTORE(JB)                                                     CVC01530
      IF(JA)1750,1750,1000                                              CVC01540
1750  CONTINUE                                                          CVC01550
cdjwapr99}
      RETURN
      END
C
CODE FOR XCMDC
      SUBROUTINE XCMDC(IASYM)
C--CALCULATE MEAN DISTANCE RESTRAINTS
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET UP THE POINTERS TO THE TOP OF THE WORK STACK
      DUMP=STORE(LCG+4)
      STORE(LCG+4)=0.
      JJ=0
      JH=ISTORE(LCG+2)+LC
      JI=JH
      JA=LCA
C--CALCULATE THE PARTIAL DIFFERENTIALS INITIALLY
1000  CONTINUE
      E=1.0
      CALL XCDPD(IASYM)
      STORE(LCG+4)=STORE(LCG+4)+D
      JJ=JJ+1
      STORE(JI)=D
      JI=JI+1
      JA=ISTORE(JB)
      IF(JA)1050,1050,1000
C--END OF THE FIRST PASS  -  PASS THROUGH NOW AND ACCUMULATE
1050  CONTINUE
      STORE(LCG+4)=STORE(LCG+4)/FLOAT(JJ)+DUMP
      JI=JH
      JA=LCA
      NCA=2
1100  CONTINUE
      JB=ISTORE(JA)
      MCA=JA
      STORE(L22PD+2)=STORE(LCG+4)-STORE(JI)
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
      JI=JI+1
      JA=ISTORE(JB)
      IF(JA)1150,1150,1100
1150  CONTINUE
      RETURN
      END
C
CODE FOR XCVCL
      SUBROUTINE XCVCL(iasym)
      use xssval_mod, only: issapp, issprt
      implicit none
C--CALCULATE LOCAL UIJ RESTRAINTS
C
C
C      IASYM = 1 FOR ASYMMETRIC OTHERWISE 0
C
C--THE VARIABLES IN 'XWORK' ARE USED AS FOLLOWS :
C
C  P  DU(B)/DU(22)
C  .
C  .
C  T  DU(B)/DU(12)
C
C--SUBSEQUENTLY O TO T ARE USED FOR THE DIFFERENCES BETWEEN THE
C  THE TWO VALUES OF EACH VIBRATION PARAMETER
C
C--
      INCLUDE 'ISTORE.INC'
C
      integer :: iaxis, iasym
      real, dimension(12) :: A1 !< Partial derivatives
      double precision, dimension(3) :: ROT1, ROT2, ROT3 !< Cartesian axes
      double precision, dimension(3) :: ANAXIS, ANORTH, DIFF_VEC !< temp variables to calculates axes
      
      double precision U_L(6) !< adp in linear 6 element form
      integer, dimension(9), parameter :: U_ASSIGN=
     &    (/ 1, 6, 5, 6, 2, 4, 5, 4, 3 /) !< Transform linear 6 elements adp to linear 9 element adps
      double precision, dimension(3,3) :: A_M !< orthogonalisation matrix
            
      type adp_t !< object holding all the infos necessary to construct the restraint
        integer atom !< index in store of the atom of the adp to restraint
        integer, dimension(3) :: basis_atoms !< atoms used to defined the basis
        integer :: U_L !< index of adps from store 
        double precision, dimension(3,3) :: U_M !< adps in 2D matrix form
        double precision, dimension(3,3) :: R_M !< rotation matrix
        double precision, dimension(3,3) :: RAB !< transformation matrix from crystal to user defined basis
        double precision, dimension(3,3) :: RABUBAR !< adp in the user defined basis
        double precision, dimension(9,6) :: dUcart !< dU/dxx matrix where each derivative dxx is a column vector
      end type
      type(adp_t), dimension(2) :: adps

      REAL DIFF_VAL
      REAL MEAN_VAL
      real dump
      
      integer ij, ik
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
      include 'XUNITS.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (O,A1(1))    ! Note well
C
      interface
          subroutine DNCROP3(A,B,C)
              double precision A(3),B(3),C(3)
          end subroutine
      end interface

      interface
          subroutine DNORM3(A)
              double precision A(3)
          end subroutine
      end interface
C--SET UP A FEW CONSTANTS                                        
      DUMP=STORE(LCG+4)   ! The 'observed value' of the restraint
c     print *, 'lca', lca
      JA=LCA              ! Address of first parameter block header                                      
      NCA=2                                                             
C--SET UP THE ADDRESSES OF THE ATOMS                                    

      ! data stored as: atom1 atom2 y1 z1 y2 z2
      adps(1)%atom=JA
      adps(2)%atom=ISTORE(JA)
      adps(1)%U_L=ISTORE(adps(1)%atom+16)+14
      adps(2)%U_L=ISTORE(adps(2)%atom+16)+14

      DO ij=1,2
         JD=ISTORE(adps(ij)%atom+16)   !Address of atom in L5
         JX=ISTORE(adps(ij)%atom+6)
C--CHECK IF THE ATOM IS ANISO                                           
         IF(ABS(STORE(JD+6)) .gt. zero) THEN
C--'ISO' ATOM  -  MODIFY THE ENTRY IN THE COORDINATE SECTION            
            ISTORE(adps(1)%atom+5)=4         ! Reduce the number of restrained parameters to x,y,z,iso
            ISTORE(JX)=-1000000    ! Remove link to next parameter (U22- there isn't one)                                     
            ISTORE(JX+1)=8         ! Where they start 
C--SET THE EQUIVALENT ANISO TEMPERATURE FACTORS FOR THE ATOM
            DO i=0,2                                                  
               STORE(adps(1)%U_L+i*2)=STORE(adps(1)%U_L)
               STORE(adps(1)%U_L+i*2+6)=STORE(adps(1)%U_L)*STORE(L1C+i)                        
            END DO
            STORE(JD+6)=0.
         END IF
      end do
      
      adps(1)%basis_atoms(1)=adps(1)%atom
      adps(1)%basis_atoms(2)=ISTORE(adps(2)%atom)
      adps(1)%basis_atoms(3)=ISTORE(adps(1)%basis_atoms(2))
      adps(2)%basis_atoms(1)=adps(2)%atom
      adps(2)%basis_atoms(2)=ISTORE(adps(1)%basis_atoms(3))
      adps(2)%basis_atoms(3)=ISTORE(adps(2)%basis_atoms(2))

      do ij=1, 2
          do ik=0, 5
              U_L(ik+1)=store(adps(ij)%U_L+ik*2)
          end do
                            
          adps(ij)%U_M=reshape(U_L(U_ASSIGN), (/3,3/))
      end do
      
      if(issprt==0) then
          write(ncwu, *) ''
          write(ncwu, 
     &       '(A,A,"(",I0,") -- ",A,"(",I0,"), args: ",I0,1X,I0)') 
     &       "ULIJ: XCVCL ",
     &       trim(transfer(istore(adps(1)%atom+2), 'aaaa')), 
     &       nint(store(adps(1)%atom+3)), 
     &       trim(transfer(istore(adps(2)%atom+2), 'aaaa')), 
     &       nint(store(adps(2)%atom+3)),
     &       iaxis,iasym
      end if
      
      if(issprt==0) then
          write(ncwu, '(1X, A, A,"(",I0,")", 32X, A, A,"(",I0,")")')
     &        'Adp 1:',
     &        trim(transfer(istore(adps(1)%atom+2), 'aaaa')), 
     &        nint(store(adps(1)%atom+3)),
     &        'Adp 2:', 
     &        trim(transfer(istore(adps(2)%atom+2), 'aaaa')), 
     &        nint(store(adps(2)%atom+3))
          do i=1, 3
              write(ncwu, '(3(E10.3,1X), 10X, 3(E10.3,1X))') 
     &            adps(1)%U_M(i,:), adps(2)%U_M(i,:)
          end do
      end if

            
      ! Orthogonalisation matrix (stored by rows, reshape fill column wise, hence the transpose)
      A_M=transpose(reshape(STORE(L1O1:L1O1+8), (/3,3/))) 
      do ij=1, 2
      
          do ik=0,2
              DIFF_VEC(ik+1)=
     &            store(istore(adps(ij)%basis_atoms(1)+16)+8+ik*2)-
     &            store(istore(adps(ij)%basis_atoms(2)+16)+8+ik*2)     
          end do

          do ik=0,2
              ANAXIS(ik+1)=
     &            store(istore(adps(ij)%basis_atoms(2)+16)+8+ik*2)-
     &            store(istore(adps(ij)%basis_atoms(3)+16)+8+ik*2)     
          end do

          ROT3=matmul(A_M, DIFF_VEC)
          ANORTH=matmul(A_M, ANAXIS)
          CALL DNORM3(ROT3) !Normalise
          CALL DNORM3(ANORTH) !Normalise
           
          CALL DNCROP3(ROT3, ANORTH, ROT2)  !Axis 2 perp to 3 and X-axis
          CALL DNORM3(ROT2) !Normalise
          CALL DNCROP3(ROT2, ROT3, ROT1)   ! Axis 1 perp to 2 an 3.
          CALL DNORM3(ROT1) !Normalise

          ! rotation matrix
          adps(ij)%R_M(1,:)=rot1
          adps(ij)%R_M(2,:)=rot2
          adps(ij)%R_M(3,:)=rot3

C The orthog matrix. It is an upper triangle assuming fortran column ordering. 
C (i.e. offsets +1 +2 +5 are zero).
C Derivatives go here. These values (iaxis*n) are currently just used for testing.


C Here, compute

C IF IAXIS = 1, then UXZBAR, =2 for UYZBAR, IAXIS = 3 for UZZBAR


          call rabubar_derivs(adps(ij)%R_M, adps(ij)%RAB, 
     &       adps(ij)%dUcart) 
      
          adps(ij)%RABUBAR=matmul(matmul(adps(ij)%RAB, adps(ij)%U_M), 
     &        transpose(adps(ij)%rab))
     
      end do
      
      do ij=1, 3 ! 3 restraints, U_c(1,1), U_c(2,2), U_c(3,3)
C-----------------------------------------------
C--First atom
          if(ij==1) then
              ! (1,1) -> 1
              a1(7:12)=adps(1)%dUcart(1,:)
          else if(ij==2) then
              ! (2,2) -> 5
              a1(7:12)=adps(1)%dUcart(5,:)
          else
              ! (3,3) -> 9
              a1(7:12)=adps(1)%dUcart(9,:)
          END IF         
          a1(1:6)=a1(7:12)
C--CHECK IF THE ATOM IS ANISO                                           
          JP=ISTORE(adps(1)%atom+6)
          JD=ISTORE(adps(1)%atom+16)
          JX=JP ! JX used in XADUIJ
          JO=JA ! JO used in XADUIJ
          IF(ABS(STORE(JD+6)) .gt. zero) THEN
C--'ISO' ATOM  -  MODIFY THE ENTRY IN THE COORDINATE SECTION            
             ISTORE(adps(1)%atom+5)=4         ! Reduce the number of restrained parameters to x,y,z,iso
             ISTORE(JP)=-1000000    ! Remove link to next parameter (U22- there isn't one)                                     
             ISTORE(JP+1)=8         ! Where they start 
C--SET THE EQUIVALENT ANISO TEMPERATURE FACTORS FOR THE ATOM
             JE=JD
             JF=L1C+2                                                       
             DO l=L1C,JF                                                  
                STORE(JE+14)=STORE(JD+14)
                STORE(JE+20)=STORE(JD+14)*STORE(l)                        
                JE=JE+2                                                   
             END DO
             STORE(JD+6)=0.
             
             STORE(JP+2)=STORE(JP+2)+A1(1)+A1(2)+A1(3)+A1(4)*STORE(L1C)+
     2          A1(5)*STORE(L1C+1)+A1(6)*STORE(L1C+2)         
          else 
             if (iasym==1) then
c           dont restrain first atom
c            print *, "Asym"
                 a1(1:6) = 0.0
             endif      
             CALL XADUIJ  
          END IF
      
C-----------------------------------------------
C--Second atom
          if(ij==1) then
              ! (1,1) -> 1
              a1(7:12)=adps(2)%dUcart(1,:)
          else if(ij==2) then
              ! (2,2) -> 5
              a1(7:12)=adps(2)%dUcart(5,:)
          else
              ! (3,3) -> 9
              a1(7:12)=adps(2)%dUcart(9,:)
          END IF         
          a1(1:6)=-a1(7:12)
C--CHECK IF THE ATOM IS ANISO                                           
          JP=ISTORE(adps(2)%atom+6)
          JD=ISTORE(adps(2)%atom+16)
          JX=JP ! JX used in XADUIJ
          JO=JA ! JO used in XADUIJ
          IF(ABS(STORE(JD+6)) .gt. zero) THEN
C--'ISO' ATOM  -  MODIFY THE ENTRY IN THE COORDINATE SECTION            
             ISTORE(adps(2)%atom+5)=4         ! Reduce the number of restrained parameters to x,y,z,iso
             ISTORE(JP)=-1000000    ! Remove link to next parameter (U22- there isn't one)                                     
             ISTORE(JP+1)=8         ! Where they start 
C--SET THE EQUIVALENT ANISO TEMPERATURE FACTORS FOR THE ATOM
             JE=JD
             JF=L1C+2                                                       
             DO l=L1C,JF                                                  
                STORE(JE+14)=STORE(JD+14)
                STORE(JE+20)=STORE(JD+14)*STORE(l)                        
                JE=JE+2                                                   
             END DO
             STORE(JD+6)=0.
             
             STORE(JP+2)=STORE(JP+2)+A1(1)+A1(2)+A1(3)+A1(4)*STORE(L1C)+
     2          A1(5)*STORE(L1C+1)+A1(6)*STORE(L1C+2)         
          else 
             CALL XADUIJ  
          END IF
            
   
C--CALCULATE THE MEAN VALUE AND THE DIFFERENCE                          CVC01190      
         IF ( ij==1 ) THEN
             DIFF_VAL = adps(1)%rabubar(1,1) - adps(2)%rabubar(1,1)
             MEAN_VAL = adps(1)%rabubar(1,1) + adps(2)%rabubar(1,1)
         else IF ( ij==2 ) THEN
             DIFF_VAL = adps(1)%rabubar(2,2) - adps(2)%rabubar(2,2)
             MEAN_VAL = adps(1)%rabubar(2,2) + adps(2)%rabubar(2,2)
         else 
             DIFF_VAL = adps(1)%rabubar(3,3) - adps(2)%rabubar(3,3)
             MEAN_VAL = adps(1)%rabubar(3,3) + adps(2)%rabubar(3,3)
         END IF

         if(issprt==0) then
             write(ncwu, '(I1, 1X, A, 6(E10.3, 1X))') 
     &           ij, 'Derivatives A: ', adps(1)%dUcart(ik,:)
             write(ncwu, '(I1, 1X, A, 6(E10.3, 1X))') 
     &           ij, 'Derivatives B: ', adps(2)%dUcart(ik,:)
             write(ncwu, '(I1, 1X, A, E10.3)') ij, 'Delta: ', DIFF_VAL  
             write(ncwu, '(I1, 1X, A, E10.3)')
     &           ij, 'Mean: ', MEAN_VAL / 2.0
         end if

         STORE(LCG+4)=0.5*(DUMP+MEAN_VAL)                                       CVC01320
c        print *, 'L22PD saved', l22pd, ' Dump: ',DUMP
         STORE(L22PD+2)=DUMP-DIFF_VAL ! Difference between restraint target (DUMP) and computed from current parameters (D)
c        print *, 'L22PD+2 ', store(l22pd+2)
         MCA=adps(1)%atom                                                           CVC01500
         STORE(L22PD+1) = STORE(LCG+3)                                     CVC01510
c        print *, 'L22PD+1 ', store(l22pd+1)
         CALL XFMPDQ                                                       CVC01520
      end do
      
c         JA=ISTORE(JB)
c         print *, 'ISTORE: ',ISTORE(JA_at6_1)                                                     CVC01530
         JA=ISTORE(adps(2)%basis_atoms(3))                                               CVC01530

      if(issprt==0) then
          write(ncwu, '(1X, A)') 'R_M rotation matrix'
          do ij=1, 3
              write(ncwu, '(3(E10.3, 1X), 10X, 3(E10.3, 1X))') 
     &            adps(1)%R_M(ij,:), adps(2)%R_M(ij,:)
          end do
          write(ncwu, '(1X, A)') 'RAB rotation matrix'
          do ij=1, 3
              write(ncwu, '(3(E10.3, 1X), 10X, 3(E10.3, 1X))') 
     &            adps(1)%rab(ij,:), adps(2)%rab(ij,:)
          end do
             
          write(ncwu, '(1X, A, 34X, A)') 'RABUBAR 1', 'RABUBAR 2'
          do ij=1, 3
              write(ncwu, '(3(E10.3,1X), 10X, 3(E10.3,1X))') 
     &            adps(1)%RABUBAR(ij,:), adps(2)%RABUBAR(ij,:)
          end do
          write(ncwu, *) ''
      end if

      IF(JA .GT. 0) then
         print *, 'No more atom expected'
         call abort()
      end if

      END
C
CODE FOR XCVCA
      SUBROUTINE XCVCA(iasym, results)
      use xssval_mod, only: issapp, issprt
      use list26_mod
      implicit none
C--CALCULATE principal axes restraints. align 2 adps along an eigenvector
C
C
C      IASYM = 1 FOR ASYMMETRIC OTHERWISE 0
C
C--THE VARIABLES IN 'XWORK' ARE USED AS FOLLOWS :
C
C  P  DU(B)/DU(22)
C  .
C  .
C  T  DU(B)/DU(12)
C
C--SUBSEQUENTLY O TO T ARE USED FOR THE DIFFERENCES BETWEEN THE
C  THE TWO VALUES OF EACH VIBRATION PARAMETER
C
C--
      INCLUDE 'ISTORE.INC'
C
      type(restraints_t), intent(inout), optional :: results
      integer, intent(in) :: iasym

      integer :: iaxis, icpt
      real, dimension(12) :: A1 !< Partial derivatives
      double precision U_L_1(6), U_L_2(6) !< adp in linear 6 element form
      integer, dimension(9), parameter :: U_ASSIGN=
     &    (/ 1, 6, 5, 6, 2, 4, 5, 4, 3 /) !< Transform linear 6 elements adp to linear 9 element adps
      double precision U_M_1(3,3), U_M_2(3,3) !< adp as a 3x3 matrix
      double precision R_M(3,3) !< rotation matrix
      double precision RAB(3,3) !< full transformation matrix
      double precision RABUBAR_1(3,3) !< adp in local cartesian coordinate space
      double precision RABUBAR_2(3,3) !< adp in local cartesian coordinate space
      double precision, dimension(3,3) :: A_M !< orthogonalisation matrix
      double precision dUcart(9,6) !< dU/dxx matrix where each derivative dxx is a column vector
      double precision, dimension(3,3) :: U_C_1, Q_1, U_C_2, Q_2
      double precision, dimension(3,3) :: B_M
      double precision, dimension(3) :: W_1

      real dump
      REAL DIFF_VAL
      REAL MEAN_VAL
      
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
      include 'XUNITS.INC'
      !include 'XSSVAL.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (O,A1(1))    ! Note well
      
C
C--SET UP A FEW CONSTANTS                                        
      DUMP=STORE(LCG+4)   ! The 'observed value' of the restraint
      JA=LCA              ! Address of first parameter block header                                      
      NCA=2
C--SET UP THE ADDRESSES OF THE ATOMS                                    
      JB=ISTORE(JA)             ! Address of next parameter block                                        
      JP=ISTORE(JA+6)           ! Address of first parameter (U11) for atom 1                                        
      JV=ISTORE(JB+6)           ! Address of first parameter (U11) for atom 2                                        

      if(present(results)) then
          call extend(results%subrestraints, 3, .true.)
          do icpt=1, 3
              call extend(results%subrestraints(icpt)%atoms, 2, .true.)
              results%subrestraints(icpt)%atoms(1)%label=
     &            transfer(istore(JA+2), 'aaaa')
              results%subrestraints(icpt)%atoms(1)%serial=
     &            nint(store(JA+3))
              results%subrestraints(icpt)%atoms(2)%label=
     &            transfer(istore(JB+2), 'aaaa')
              results%subrestraints(icpt)%atoms(2)%serial=
     &            nint(store(JB+3))
          end do

          results%subrestraints(1)%description='Uc[12]==0'
          results%subrestraints(2)%description='Uc[13]==0'
          results%subrestraints(3)%description='Uc[23]==0'
      end if      
C--DEFINE U Matrices 

      U_L_1=STORE(ISTORE(JA+16)+14:ISTORE(JA+16)+14+11:2)
      U_L_2=STORE(ISTORE(JB+16)+14:ISTORE(JB+16)+14+11:2)
      
C     U Matrices in 3x3 matrix
      U_M_1=reshape(U_L_1(U_ASSIGN), (/3,3/)) 
      U_M_2=reshape(U_L_2(U_ASSIGN), (/3,3/))

      if(present(results)) then
          do icpt=1,3
              results%subrestraints(icpt)%atoms(1)%adps_crys=U_M_1
              results%subrestraints(icpt)%atoms(2)%adps_crys=U_M_2
          end do
      end if
      
      ! Orthogonalisation matrix (stored by rows, reshape fill column wise, hence the transpose)
      A_M=transpose(reshape(STORE(L1O1:L1O1+8), (/3,3/))) ! Multiply diffvec by orthogonalisation matrix
      
      ! Ucif scaled to U*
      B_M=0.0d0
      B_M(1,1)=STORE(L1P2)
      B_M(2,2)=STORE(L1P2+1)
      B_M(3,3)=STORE(L1P2+2)
      
      R_M=matmul(A_M, B_M) 
      U_C_1=matmul(matmul(R_M, U_M_1), transpose(R_M))
      U_C_2=matmul(matmul(R_M, U_M_2), transpose(R_M))
      call DSYEVJ3(U_C_1, Q_1, W_1)      
      !call DSYEVJ3(U_C_2, Q_2, W_2)   
      U_C_1=matmul(matmul(R_M, U_M_1), transpose(R_M))
      !U_C_2=matmul(matmul(R_M, U_M_2), transpose(R_M))
            
C Here, compute derivatives
      call rabubar_eigenderivs(Q_1, dUcart)
      !dUcart=4.0d0*dUcart
      
C-- RUN RABUBAR MULTIPLICATION

      RABUBAR_1=matmul(transpose(Q_1), matmul(U_C_1, Q_1))
      RABUBAR_2=matmul(transpose(Q_1), matmul(U_C_2, Q_1))

      if(present(results)) then
          do icpt=1, 3
              results%subrestraints(icpt)%atoms(1)%adps_cart=RABUBAR_1
              results%subrestraints(icpt)%atoms(1)%M=Q_1
              results%subrestraints(icpt)%atoms(2)%adps_cart=RABUBAR_2
              results%subrestraints(icpt)%atoms(2)%M=Q_1
          end do
      end if
                     
      do i=1,3
            
          IF ( i==1 ) THEN
              ! XY DERIVS 
              ! (1,2) -> 2
              a1(7:12)=dUcart(2,:)
              DIFF_VAL = (RABUBAR_1(1, 2) - RABUBAR_2(1, 2))
              MEAN_VAL = (RABUBAR_1(1, 2) + RABUBAR_2(1, 2))       
          ELSE IF ( i==2) THEN
              ! XZ DERIVS 
              ! (1,3) -> 3
              a1(7:12)=dUcart(3,:)
              DIFF_VAL = (RABUBAR_1(1, 3) - RABUBAR_2(1, 3))
              MEAN_VAL = (RABUBAR_1(1, 3) + RABUBAR_2(1, 3))       
          ELSE   
              ! YZ DERIVS 
              ! (2,3) -> 5
              a1(7:12)=dUcart(6,:)
              DIFF_VAL = (RABUBAR_1(2, 3) - RABUBAR_2(2, 3))
              MEAN_VAL = (RABUBAR_1(2, 3) + RABUBAR_2(2, 3))       
          END IF

C First atom of the restraint                
C-----------------------------------------------
          a1(1:6)=0.0
C--CHECK IF THE ATOM IS ANISO                                           
          JP=ISTORE(JA+6)
          JD=ISTORE(JA+16)
          JX=JP ! JX used in XADUIJ
          JO=JA ! JO used in XADUIJ
          IF(ABS(STORE(JD+6)) .gt. zero) THEN
C--'ISO' ATOM  -  MODIFY THE ENTRY IN THE COORDINATE SECTION            
              ISTORE(JA+5)=4         ! Reduce the number of restrained parameters to x,y,z,iso
              ISTORE(JP)=-1000000    ! Remove link to next parameter (U22- there isn't one)                                     
              ISTORE(JP+1)=8         ! Where they start 
C--SET THE EQUIVALENT ANISO TEMPERATURE FACTORS FOR THE ATOM
              JE=JD 
              JF=L1C+2                                                       
              DO J=L1C,JF                                                  
                  STORE(JE+14)=STORE(JD+14)
                  STORE(JE+20)=STORE(JD+14)*STORE(J)                        
                  JE=JE+2                                                   
              END DO
              STORE(JD+6)=0.         
              STORE(JP+2)=STORE(JP+2)+A1(1)+A1(2)+A1(3)+
     2            A1(4)*STORE(L1C)+A1(5)*STORE(L1C+1)+A1(6)*STORE(L1C+2)         
          else 
              if (iasym==1) then
c           dont restrain first atom
c            print *, "Asym"
                  a1(1:6) = 0.0
              endif      
              CALL XADUIJ  
          END IF

C Second atom of the restraint                
C-----------------------------------------------
          a1(1:6)=-a1(7:12) 
C--CHECK IF THE ATOM IS ANISO                                           
          JP=ISTORE(JB+6)
          JD=ISTORE(JB+16)
          JX=JP ! JX used in XADUIJ
          JO=JB ! JO used in XADUIJ
          IF(ABS(STORE(JD+6)) .gt. zero) THEN
C--'ISO' ATOM  -  MODIFY THE ENTRY IN THE COORDINATE SECTION            
             ISTORE(JB+5)=4         ! Reduce the number of restrained parameters to x,y,z,iso
             ISTORE(JP)=-1000000    ! Remove link to next parameter (U22- there isn't one)                                     
             ISTORE(JP+1)=8         ! Where they start 
C--SET THE EQUIVALENT ANISO TEMPERATURE FACTORS FOR THE ATOM
             JE=JD
             JF=L1C+2                                                       
             DO J=L1C,JF                                                  
                STORE(JE+14)=STORE(JD+14)
                STORE(JE+20)=STORE(JD+14)*STORE(J)                        
                JE=JE+2                                                   
             END DO
             STORE(JD+6)=0.
             
             STORE(JP+2)=STORE(JP+2)+A1(1)+A1(2)+A1(3)+A1(4)*STORE(L1C)+
     2           A1(5)*STORE(L1C+1)+A1(6)*STORE(L1C+2)         
          else 
             CALL XADUIJ  
          end if                          
                      
C Here, you need to set D to be the computed value of the difference in the covariances
C Note that DUMP is the target difference (and should usually be zero).
C You need to set SUM to be the compute

          STORE(LCG+4)=0.5*(DUMP+MEAN_VAL)                                       CVC01320
          STORE(L22PD+2)=DUMP-DIFF_VAL ! Difference between restraint target (DUMP) and computed from current parameters (D)
          STORE(L22PD+1) = STORE(LCG+3)                                     CVC01510
          MCA=JA                                                            CVC01500
          CALL XFMPDQ                                                       CVC01520
      
      end do
      
      JA=ISTORE(JB)                                                     CVC01530

      if(issprt==0) then
          write(ncwu, '(A)') ''
      END IF

      IF(JA .GT. 0) then
         print *, 'No more atom expected'
         call abort()
      end if

      RETURN
      END
CODE FOR XCVCR
      SUBROUTINE XCVCR(iasym, results)
      use xssval_mod, only: issapp, issprt
      use list26_mod
      implicit none
C--CALCULATE RIGID BODY RESTRAINTS (RIGU resraints)
C
C
C      IASYM = 1 FOR ASYMMETRIC OTHERWISE 0
C
C--THE VARIABLES IN 'XWORK' ARE USED AS FOLLOWS :
C
C  P  DU(B)/DU(22)
C  .
C  .
C  T  DU(B)/DU(12)
C
C--SUBSEQUENTLY O TO T ARE USED FOR THE DIFFERENCES BETWEEN THE
C  THE TWO VALUES OF EACH VIBRATION PARAMETER
C
C--
      INCLUDE 'ISTORE.INC'
C
      type(restraints_t), intent(inout), optional :: results
      integer, intent(in) :: iasym

      integer :: iaxis, icpt
      real, dimension(12) :: A1 !< Partial derivatives
      double precision, dimension(3) :: ROT1, ROT2, ROT3 !< Cartesian axes
      double precision, dimension(3) :: ANAXIS, DIFF_VEC !< temp variables to calculates axes
      
      double precision U_L_1(6), U_L_2(6) !< adp in linear 6 element form
      integer, dimension(9), parameter :: U_ASSIGN=
     &    (/ 1, 6, 5, 6, 2, 4, 5, 4, 3 /) !< Transform linear 6 elements adp to linear 9 element adps
      double precision U_M_1(3,3), U_M_2(3,3) !< adp as a 3x3 matrix
      double precision R_M(3,3) !< rotation matrix
      double precision RAB(3,3) !< full transformation matrix
      double precision RABUBAR_1(3,3) !< adp in local cartesian coordinate space
      double precision RABUBAR_2(3,3) !< adp in local cartesian coordinate space
      double precision, dimension(3,3) :: A_M !< orthogonalisation matrix
      double precision dUcart(9,6) !< dU/dxx matrix where each derivative dxx is a column vector

      real dump
      REAL DIFF_VAL
      REAL MEAN_VAL
      
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
      include 'XUNITS.INC'
      !include 'XSSVAL.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (O,A1(1))    ! Note well
      
C
C--SET UP A FEW CONSTANTS                                        
      DUMP=STORE(LCG+4)   ! The 'observed value' of the restraint
      JA=LCA              ! Address of first parameter block header                                      
      NCA=2
C--SET UP THE ADDRESSES OF THE ATOMS                                    
      JB=ISTORE(JA)             ! Address of next parameter block                                        
      JP=ISTORE(JA+6)           ! Address of first parameter (U11) for atom 1                                        
      JV=ISTORE(JB+6)           ! Address of first parameter (U11) for atom 2                                        

      if(present(results)) then
          call extend(results%subrestraints, 3, .true.)
          do icpt=1, 3
              call extend(results%subrestraints(icpt)%atoms, 2, .true.)
              results%subrestraints(icpt)%atoms(1)%label=
     &            transfer(istore(JA+2), 'aaaa')
              results%subrestraints(icpt)%atoms(1)%serial=
     &            nint(store(JA+3))
              results%subrestraints(icpt)%atoms(2)%label=
     &            transfer(istore(JB+2), 'aaaa')
              results%subrestraints(icpt)%atoms(2)%serial=
     &            nint(store(JB+3))
          end do

          results%subrestraints(1)%description='Uc[13]==0'
          results%subrestraints(2)%description='Uc[23]==0'
          results%subrestraints(3)%description='Uc[33]==0'
      end if      

C--DEFINE U Matrices 

      U_L_1=STORE(ISTORE(JA+16)+14:ISTORE(JA+16)+14+11:2)
      U_L_2=STORE(ISTORE(JB+16)+14:ISTORE(JB+16)+14+11:2)
      
C     U Matrices in 3x3 matrix
      U_M_1=reshape(U_L_1(U_ASSIGN), (/3,3/)) 
      U_M_2=reshape(U_L_2(U_ASSIGN), (/3,3/))

      if(present(results)) then
          do icpt=1,3
              results%subrestraints(icpt)%atoms(1)%adps_crys=U_M_1
              results%subrestraints(icpt)%atoms(2)%adps_crys=U_M_2
          end do
      end if
                  
C-- Set up the new coordinate system for the adp
C-----------------------------------------------

C--CALCULATE THE INTERNUCLEAR DISTANCE                                  
      JO=JA  
      JS=JB  
      JQ=ISTORE(JO+16)
      JU=ISTORE(JS+16)

C Here is the interatomic vector in crystal fractions:    
      DIFF_VEC(1)=STORE(JQ+8)-STORE(JU+8)
      DIFF_VEC(2)=STORE(JQ+10)-STORE(JU+10)
      DIFF_VEC(3)=STORE(JQ+12)-STORE(JU+12)

      ANAXIS = (/1.0d0, 0.0d0, 0.0d0/)
      
c      print *, "Pre-Norm Pre-Orth Bond Vec"
c      print *, A, B, C
c      print *,   
      
      ! Orthogonalisation matrix (stored by rows, reshape fill column wise, hence the transpose)
      A_M=transpose(reshape(STORE(L1O1:L1O1+8), (/3,3/))) ! Multiply diffvec by orthogonalisation matrix
      ROT3=matmul(A_M, DIFF_VEC)
c      print *, "Pre-Norm Orth Bond Vec"
c      print *, (ROT3(I), I=1,3)
c      print *,
      CALL DNORM3(ROT3) !Normalise
      
      
C Take a perpendiculat vector
      ROT2=(/rot3(3), rot3(3), -rot3(1)-rot3(2)/)
      if(all(abs(rot2)<=1d-4)) then
          ROT2=(/-rot3(2)-rot3(3), rot3(1), rot3(1)/)
      end if
      CALL DNORM3(ROT2) !Normalise

      CALL DNCROP3(ROT2, ROT3, ROT1)   ! Axis 1 perp to 2 an 3.
      CALL DNORM3(ROT1) !Normalise
       
      ! rotation matrix from basis vectors
      R_M(1,:)=rot1
      R_M(2,:)=rot2
      R_M(3,:)=rot3

C Here, compute derivatives

      call rabubar_derivs(R_M, RAB, dUcart)
C-- RUN RABUBAR MULTIPLICATION

      RABUBAR_1=matmul(rab, matmul(U_M_1, transpose(rab)))
      RABUBAR_2=matmul(rab, matmul(U_M_2, transpose(rab)))

      if(present(results)) then
          do icpt=1, 3
              results%subrestraints(icpt)%atoms(1)%adps_cart=RABUBAR_1
              results%subrestraints(icpt)%atoms(1)%M=rab
              results%subrestraints(icpt)%atoms(2)%adps_cart=RABUBAR_2
              results%subrestraints(icpt)%atoms(2)%M=rab
          end do
      end if
                     
      do i=1,3
            
          IF ( i==1 ) THEN   !UXZBAR
C      #### XZ DERIVS ####
              ! (1,3) -> 3
              a1(7:12)=dUcart(3,:)
              DIFF_VAL = RABUBAR_1(1, 3) - RABUBAR_2(1, 3)       
              MEAN_VAL = (RABUBAR_1(1, 3) + RABUBAR_2(1, 3))       
          ELSE IF ( i==2) THEN  !UYZBAR
C      #### YZ DERIVS ####
              ! (2,3) -> 8
              a1(7:12)=dUcart(8,:)
              DIFF_VAL = RABUBAR_1(2, 3) - RABUBAR_2(2, 3)       
              MEAN_VAL = (RABUBAR_1(2, 3) + RABUBAR_2(2, 3)) 
          ELSE   !UZZBAR
C      ##### ZZ DERIVS ####
              ! (3,3) -> 9
              a1(7:12)=dUcart(9,:)
              DIFF_VAL = RABUBAR_1(3, 3) - RABUBAR_2(3, 3)       
              MEAN_VAL = (RABUBAR_1(3, 3) + RABUBAR_2(3, 3)) 
          END IF

C First atom of the restraint                
C-----------------------------------------------
          a1(1:6)=a1(7:12) 
C--CHECK IF THE ATOM IS ANISO                                           
          JP=ISTORE(JA+6)
          JD=ISTORE(JA+16)
          JX=JP ! JX used in XADUIJ
          JO=JA ! JO used in XADUIJ
          IF(ABS(STORE(JD+6)) .gt. zero) THEN
C--'ISO' ATOM  -  MODIFY THE ENTRY IN THE COORDINATE SECTION            
              ISTORE(JA+5)=4         ! Reduce the number of restrained parameters to x,y,z,iso
              ISTORE(JP)=-1000000    ! Remove link to next parameter (U22- there isn't one)                                     
              ISTORE(JP+1)=8         ! Where they start 
C--SET THE EQUIVALENT ANISO TEMPERATURE FACTORS FOR THE ATOM
              JE=JD 
              JF=L1C+2                                                       
              DO J=L1C,JF                                                  
                  STORE(JE+14)=STORE(JD+14)
                  STORE(JE+20)=STORE(JD+14)*STORE(J)                        
                  JE=JE+2                                                   
              END DO
              STORE(JD+6)=0.         
              STORE(JP+2)=STORE(JP+2)+A1(1)+A1(2)+A1(3)+
     2            A1(4)*STORE(L1C)+A1(5)*STORE(L1C+1)+A1(6)*STORE(L1C+2)         
          else 
              if (iasym==1) then
c           dont restrain first atom
c            print *, "Asym"
                  a1(1:6) = 0.0
              endif      
              CALL XADUIJ  
          END IF

C Second atom of the restraint                
C-----------------------------------------------
          a1(1:6)=-a1(7:12) 
C--CHECK IF THE ATOM IS ANISO                                           
          JP=ISTORE(JB+6)
          JD=ISTORE(JB+16)
          JX=JP ! JX used in XADUIJ
          JO=JB ! JO used in XADUIJ
          IF(ABS(STORE(JD+6)) .gt. zero) THEN
C--'ISO' ATOM  -  MODIFY THE ENTRY IN THE COORDINATE SECTION            
             ISTORE(JB+5)=4         ! Reduce the number of restrained parameters to x,y,z,iso
             ISTORE(JP)=-1000000    ! Remove link to next parameter (U22- there isn't one)                                     
             ISTORE(JP+1)=8         ! Where they start 
C--SET THE EQUIVALENT ANISO TEMPERATURE FACTORS FOR THE ATOM
             JE=JD
             JF=L1C+2                                                       
             DO J=L1C,JF                                                  
                STORE(JE+14)=STORE(JD+14)
                STORE(JE+20)=STORE(JD+14)*STORE(J)                        
                JE=JE+2                                                   
             END DO
             STORE(JD+6)=0.
             
             STORE(JP+2)=STORE(JP+2)+A1(1)+A1(2)+A1(3)+A1(4)*STORE(L1C)+
     2           A1(5)*STORE(L1C+1)+A1(6)*STORE(L1C+2)         
          else 
             CALL XADUIJ  
          end if                          
                      
C Here, you need to set D to be the computed value of the difference in the covariances
C Note that DUMP is the target difference (and should usually be zero).
C You need to set SUM to be the compute

          STORE(LCG+4)=0.5*(DUMP+MEAN_VAL)                                       CVC01320
          STORE(L22PD+2)=DUMP-DIFF_VAL ! Difference between restraint target (DUMP) and computed from current parameters (D)
          STORE(L22PD+1) = STORE(LCG+3)                                     CVC01510
          MCA=JA                                                            CVC01500
          CALL XFMPDQ                                                       CVC01520
      
      end do
      
      JA=ISTORE(JB)                                                     CVC01530

      IF(JA .GT. 0) then
         print *, 'No more atom expected'
         call abort()
      end if

      RETURN
      END
C
CODE FOR XCVCX
      SUBROUTINE XCVCX(iaxis,iasym)
      use xssval_mod, only: issapp, issprt
      implicit none
C--CALCULATE VIBRATION RESTRAINTS
C
C      IAXIS = 1 FOR XZ COVARIANCE
C      IAXIS = 2 FOR YZ COVARIANCE
C      IAXIS = 3 FOR ZZ VARIANCE
C
C      IASYM = 1 FOR ASYMMETRIC OTHERWISE 0
C
C--THE VARIABLES IN 'XWORK' ARE USED AS FOLLOWS :
C
C  P  DU(B)/DU(22)
C  .
C  .
C  T  DU(B)/DU(12)
C
C--SUBSEQUENTLY O TO T ARE USED FOR THE DIFFERENCES BETWEEN THE
C  THE TWO VALUES OF EACH VIBRATION PARAMETER
C
C--
      INCLUDE 'ISTORE.INC'
C
      integer :: iaxis, iasym
      real, dimension(12) :: A1 !< Partial derivatives
      double precision, dimension(3) :: ROT1, ROT2, ROT3 !< Cartesian axes
      double precision, dimension(3) :: ANAXIS, DIFF_VEC !< temp variables to calculates axes
      
      double precision U_L_1(6), U_L_2(6) !< adp in linear 6 element form
      integer, dimension(9), parameter :: U_ASSIGN=
     &    (/ 1, 6, 5, 6, 2, 4, 5, 4, 3 /) !< Transform linear 6 elements adp to linear 9 element adps
      double precision U_M_1(3,3), U_M_2(3,3) !< adp as a 3x3 matrix
      double precision R_M(3,3) !< rotation matrix
      double precision RAB(3,3) !< full transformation matrix
      double precision RABUBAR_1(3,3) !< adp in local cartesian coordinate space
      double precision RABUBAR_2(3,3) !< adp in local cartesian coordinate space
      double precision, dimension(3,3) :: A_M !< orthogonalisation matrix
      double precision dUcart(9,6) !< dU/dxx matrix where each derivative dxx is a column vector
      double precision vangl

      REAL CHECK_CAL_1
      REAL CHECK_CAL_2
      REAL DIFF_VAL
      REAL MEAN_VAL
      real dump
      
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
      include 'XUNITS.INC'
      !include 'XSSVAL.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (O,A1(1))    ! Note well
      
C
C--SET UP A FEW CONSTANTS                                        
      DUMP=STORE(LCG+4)   ! The 'observed value' of the restraint
      JA=LCA              ! Address of first parameter block header                                      
      NCA=2
C--SET UP THE ADDRESSES OF THE ATOMS                                    
      JB=ISTORE(JA)             ! Address of next parameter block                                        
      JP=ISTORE(JA+6)           ! Address of first parameter (U11) for atom 1                                        
      JV=ISTORE(JB+6)           ! Address of first parameter (U11) for atom 2                                        

      if(issprt==0) then
          write(ncwu, *) ''
          write(ncwu, 
     &       '(A,A,"(",I0,") -- ",A,"(",I0,"), args: ",I0,1X,I0)') 
     &       "U??BAR: XCVCX ",
     &       trim(transfer(istore(JA+2), 'aaaa')), nint(store(JA+3)), 
     &       trim(transfer(istore(JB+2), 'aaaa')), nint(store(JB+3)),
     &       iaxis,iasym
      end if
C--DEFINE U Matrices 

      U_L_1=STORE(ISTORE(JA+16)+14:ISTORE(JA+16)+14+11:2)
      U_L_2=STORE(ISTORE(JB+16)+14:ISTORE(JB+16)+14+11:2)
      
C     U Matrices in 3x3 matrix
      U_M_1=reshape(U_L_1(U_ASSIGN), (/3,3/)) 
      U_M_2=reshape(U_L_2(U_ASSIGN), (/3,3/))
      
      if(issprt==0) then
          write(ncwu, '(1X, A, A,"(",I0,")", 32X, A, A,"(",I0,")")')
     &        'Adp 1:',
     &        trim(transfer(istore(JA+2), 'aaaa')), nint(store(JA+3)),
     &        'Adp 2:', 
     &        trim(transfer(istore(JB+2), 'aaaa')), nint(store(JB+3))
          do i=1, 3
              write(ncwu, '(3(E10.3,1X), 10X, 3(E10.3,1X))') 
     &            U_M_1(i,:), U_M_2(i,:)
          end do
      end if
      
C-- Set up the new coordinate system for the adp
C-----------------------------------------------

C--CALCULATE THE INTERNUCLEAR DISTANCE                                  
      JO=JA  
      JS=JB  
      JQ=ISTORE(JO+16)
      JU=ISTORE(JS+16)

C Here is the interatomic vector in crystal fractions:    
      DIFF_VEC(1)=STORE(JQ+8)-STORE(JU+8)
      DIFF_VEC(2)=STORE(JQ+10)-STORE(JU+10)
      DIFF_VEC(3)=STORE(JQ+12)-STORE(JU+12)

      ANAXIS = (/1.0d0, 0.0d0, 0.0d0/)
      
c      print *, "Pre-Norm Pre-Orth Bond Vec"
c      print *, A, B, C
c      print *,   
      
      ! Orthogonalisation matrix (stored by rows, reshape fill column wise, hence the transpose)
      A_M=transpose(reshape(STORE(L1O1:L1O1+8), (/3,3/))) ! Multiply diffvec by orthogonalisation matrix
      ROT3=matmul(A_M, DIFF_VEC)
c      print *, "Pre-Norm Orth Bond Vec"
c      print *, (ROT3(I), I=1,3)
c      print *,
      CALL DNORM3(ROT3) !Normalise
C Take cross product with x axis (unless angle is too close to zero, in which case, use y.

      VANGL = dot_product(ROT3, ANAXIS)   ! Dot product to get angle
      IF (ABS(VANGL) .GT. 0.95d0) THEN  ! Almost parallel, use y-axis instead.
c         print *, "Bond // to x-axis"
          ANAXIS = (/0.0d0, 1.0d0, 0.0d0/)
      END IF
       
      ! NCROP3 = normalised cross product
      CALL DNCROP3(ROT3, ANAXIS, ROT2)  !Axis 2 perp to 3 and X-axis (or y if too close to x)
      CALL DNORM3(ROT2) !Normalise
      CALL DNCROP3(ROT2, ROT3, ROT1)   ! Axis 1 perp to 2 an 3.
      CALL DNORM3(ROT1) !Normalise
       
      ! rotation matrix from basis vectors
      R_M(1,:)=rot1
      R_M(2,:)=rot2
      R_M(3,:)=rot3

C Here, compute derivatives
C IF IAXIS = 1, then UXZBAR, =2 for UYZBAR, IAXIS = 3 for UZZBAR
C-----------------------------------------------

      call rabubar_derivs(R_M, RAB, dUcart)
            
      IF ( IAXIS .EQ. 1 ) THEN   !UXZBAR
C      #### XZ DERIVS ####
          ! (1,3) -> 3
          a1(7:12)=dUcart(3,:)
          
      ELSE IF ( IAXIS .EQ. 2) THEN  !UYZBAR
C      #### YZ DERIVS ####
          ! (2,3) -> 8
          a1(7:12)=dUcart(8,:)
     
      ELSE   !UZZBAR
C      ##### ZZ DERIVS ####
          ! (3,3) -> 9
          a1(7:12)=dUcart(9,:)
      END IF

C First atom of the restraint                
C-----------------------------------------------
      a1(1:6)=a1(7:12) 
C--CHECK IF THE ATOM IS ANISO                                           
      JP=ISTORE(JA+6)
      JD=ISTORE(JA+16)
      JX=JP ! JX used in XADUIJ
      JO=JA ! JO used in XADUIJ
      IF(ABS(STORE(JD+6)) .gt. zero) THEN
C--'ISO' ATOM  -  MODIFY THE ENTRY IN THE COORDINATE SECTION            
         ISTORE(JA+5)=4         ! Reduce the number of restrained parameters to x,y,z,iso
         ISTORE(JP)=-1000000    ! Remove link to next parameter (U22- there isn't one)                                     
         ISTORE(JP+1)=8         ! Where they start 
C--SET THE EQUIVALENT ANISO TEMPERATURE FACTORS FOR THE ATOM
         JE=JD
         JF=L1C+2                                                       
         DO J=L1C,JF                                                  
            STORE(JE+14)=STORE(JD+14)
            STORE(JE+20)=STORE(JD+14)*STORE(J)                        
            JE=JE+2                                                   
         END DO
         STORE(JD+6)=0.
         
         STORE(JP+2)=STORE(JP+2)+A1(1)+A1(2)+A1(3)+A1(4)*STORE(L1C)+
     2      A1(5)*STORE(L1C+1)+A1(6)*STORE(L1C+2)         
      else 
         if (iasym==1) then
c           dont restrain first atom
c            print *, "Asym"
            a1(1:6) = 0.0
         endif      
         CALL XADUIJ  
      END IF

C Second atom of the restraint                
C-----------------------------------------------
      a1(1:6)=-a1(7:12) 
C--CHECK IF THE ATOM IS ANISO                                           
      JP=ISTORE(JB+6)
      JD=ISTORE(JB+16)
      JX=JP ! JX used in XADUIJ
      JO=JB ! JO used in XADUIJ
      IF(ABS(STORE(JD+6)) .gt. zero) THEN
C--'ISO' ATOM  -  MODIFY THE ENTRY IN THE COORDINATE SECTION            
         ISTORE(JB+5)=4         ! Reduce the number of restrained parameters to x,y,z,iso
         ISTORE(JP)=-1000000    ! Remove link to next parameter (U22- there isn't one)                                     
         ISTORE(JP+1)=8         ! Where they start 
C--SET THE EQUIVALENT ANISO TEMPERATURE FACTORS FOR THE ATOM
         JE=JD
         JF=L1C+2                                                       
         DO J=L1C,JF                                                  
            STORE(JE+14)=STORE(JD+14)
            STORE(JE+20)=STORE(JD+14)*STORE(J)                        
            JE=JE+2                                                   
         END DO
         STORE(JD+6)=0.
         
         STORE(JP+2)=STORE(JP+2)+A1(1)+A1(2)+A1(3)+A1(4)*STORE(L1C)+
     2      A1(5)*STORE(L1C+1)+A1(6)*STORE(L1C+2)         
      else 
         CALL XADUIJ  
      end if                          

C-- RUN RABUBAR MULTIPLICATION

      RABUBAR_1=matmul(rab, matmul(U_M_1, transpose(rab)))
      RABUBAR_2=matmul(rab, matmul(U_M_2, transpose(rab)))
         
C--CALCULATE THE MEAN VALUE AND THE DIFFERENCE                          CVC01190
         
      CHECK_CAL_1 = RABUBAR_1(iaxis, 3)
      CHECK_CAL_2 = RABUBAR_2(iaxis, 3)

      DIFF_VAL = CHECK_CAL_1 - CHECK_CAL_2       
      MEAN_VAL = (CHECK_CAL_1 + CHECK_CAL_2)/2 
             
      if(issprt==0) then
          write(ncwu, '(1X, A)') 'RAB rotation matrix'
          do i=1, 3
              write(ncwu, '(3(E10.3, 1X))') rab(i,:)
          end do
             
          write(ncwu, '(1X, A, 6(E10.3, 1X))') 'Derivatives: ', a1(7:12)

          write(ncwu, '(1X, A, 34X, A)') 'RABUBAR 1', 'RABUBAR 2'
          do i=1, 3
              write(ncwu, '(3(E10.3,1X), 10X, 3(E10.3,1X))') 
     &            RABUBAR_1(i,:), RABUBAR_2(i,:)
          end do
          write(ncwu, '(A, E10.3)') 'Delta: ', DIFF_VAL  
          write(ncwu, '(A, E10.3)') 'Mean: ', MEAN_VAL   
          write(ncwu, *) ''
      end if
         
C Here, you need to set D to be the computed value of the difference in the covariances
C Note that DUMP is the target difference (and should usually be zero).
C You need to set SUM to be the compute

      STORE(LCG+4)=0.5*(DUMP+MEAN_VAL)                                       CVC01320
      STORE(L22PD+2)=DUMP-DIFF_VAL ! Difference between restraint target (DUMP) and computed from current parameters (D)
      STORE(L22PD+1) = STORE(LCG+3)                                     CVC01510
      MCA=JA                                                            CVC01500
      CALL XFMPDQ                                                       CVC01520
      JA=ISTORE(JB)                                                     CVC01530

      IF(JA .GT. 0) then
         print *, 'No more atom expected'
         call abort()
      end if

      RETURN
      END
      

CODE FOR XCVCV
      SUBROUTINE XCVCV(iaxis,iasym, results)
      use list26_mod
C--CALCULATE PERPENDICULAR RESTRAINTS
C
C      IAXIS = Not used
C
C      IASYM = 1 FOR ASYMMETRIC OTHERWISE 0
C
C--THE VARIABLES IN 'XWORK' ARE USED AS FOLLOWS :
C
C  P  DU(B)/DU(22)
C  .
C  .
C  T  DU(B)/DU(12)
C
C--SUBSEQUENTLY O TO T ARE USED FOR THE DIFFERENCES BETWEEN THE
C  THE TWO VALUES OF EACH VIBRATION PARAMETER
C
C--
      INCLUDE 'ISTORE.INC'
C
      type(restraints_t), intent(inout), optional :: results
      integer, intent(in) :: iaxis,iasym
      DIMENSION A1(12)
      double precision ROT3(3)
      double precision ROT2(3)
      double precision ROT1(3)
      double precision ANAXIS(3)
      double precision DIFF_VEC(3)
      
      double precision U_L_1(6)
C      DIMENSION U_L_2(6)
      integer U_ASSIGN (9)
      double precision U_M_1(3,3)
C      DIMENSION U_M_2(3,3)
      double precision A_M(3,3)      
      double precision R_M(3,3)
      double precision RAB(3,3)
C      DIMENSION UBAR_2(3,3)
      double precision RABUBAR_1(3,3)
C      DIMENSION RABUBAR_2(3,3)
      double precision dUcart(9,6) ! dU/dxx matrix where each derivative dxx is a column vector 

C      REAL CHECK_CAL_1
C      REAL CHECK_CAL_2
      REAL DIFF_VAL
      REAL MEAN_VAL
      
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
      include 'XUNITS.INC'
      include 'XSSVAL.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (O,A1(1))    ! Note well
      
      integer icpt
C
C--SET UP A FEW CONSTANTS                                        
      DUMP=STORE(LCG+4)   ! The 'observed value' of the restraint
      JA=LCA              ! Address of first parameter block header                                      
      NCA=2                                                             
C--SET UP THE ADDRESSES OF THE ATOMS                                    
      JB=ISTORE(JA)             ! Address of next parameter block                                        
      JP=ISTORE(JA+6)           ! Address of first parameter (U11) for atom 1                                        
      JV=ISTORE(JB+6)           ! Address of first parameter (U11) for atom 2                                        

      if(present(results)) then
          call extend(results%subrestraints, 2, .true.)
          results%subrestraints(1)%description='Uc[1,3]==0'
          results%subrestraints(2)%description='Uc[2,3]==0'
          do icpt=1, 2
              call extend(results%subrestraints(icpt)%atoms, 2, .true.)
              results%subrestraints(icpt)%atoms(1)%label=
     &            transfer(istore(JA+2), 'aaaa')
              results%subrestraints(icpt)%atoms(1)%serial=
     &            nint(store(JA+3))
              results%subrestraints(icpt)%atoms(2)%label=
     &            transfer(istore(JB+2), 'aaaa')
              results%subrestraints(icpt)%atoms(2)%serial=
     &            nint(store(JB+3))
          end do
      end if
C--DEFINE U Matrices 

      U_L_1=STORE(ISTORE(JA+16)+14:ISTORE(JA+16)+14+11:2)
      
C     U Matrices in 3x3 matrix
      U_ASSIGN = (/ 1, 6, 5, 6, 2, 4, 5, 4, 3 /)
      U_M_1=reshape(U_L_1(U_ASSIGN), (/3,3/)) 
      if(present(results)) then
          results%subrestraints(1)%atoms(1)%adps_crys=U_M_1
      end if
            
C-- Set up the new coordinate system for the adp
C-----------------------------------------------

C--CALCULATE THE INTERNUCLEAR DISTANCE                                  
      JO=JA  
      JS=JB  
      JQ=ISTORE(JO+16)
      JU=ISTORE(JS+16)

C Here is the interatomic vector in crystal fractions:    
      DIFF_VEC(1)=STORE(JQ+8)-STORE(JU+8)
      DIFF_VEC(2)=STORE(JQ+10)-STORE(JU+10)
      DIFF_VEC(3)=STORE(JQ+12)-STORE(JU+12)

      ANAXIS = (/1.0d0, 0.0d0, 0.0d0/)
      
c      print *, "Pre-Norm Pre-Orth Bond Vec"
c      print *, A, B, C
c      print *,   
      
      ! Orthogonalisation matrix (stored by rows, reshape fill column wise, hence the transpose)
      A_M=transpose(reshape(STORE(L1O1:L1O1+8), (/3,3/))) ! Multiply diffvec by orthogonalisation matrix
      ROT3=matmul(A_M, DIFF_VEC)
c      print *, "Pre-Norm Orth Bond Vec"
c      print *, (ROT3(I), I=1,3)
c      print *,
      CALL DNORM3(ROT3) !Normalise
C Take cross product with x axis (unless angle is too close to zero, in which case, use y.

       VANGL = dot_product(ROT3, ANAXIS)      ! Dot product to get angle
       IF (ABS(VANGL) .GT. 0.95) THEN  ! Almost parallel, use y-axis instead.
c         print *, "Bond // to x-axis"
          ANAXIS = (/0.0d0, 1.0d0, 0.0d0/)
       END IF
       
       CALL DNCROP3(ROT3, ANAXIS, ROT2)  !Axis 2 perp to 3 and X-axis (or y if too close to x)
       CALL DNORM3(ROT2) !Normalise
       CALL DNCROP3(ROT2, ROT3, ROT1)   ! Axis 1 perp to 2 an 3.
       CALL DNORM3(ROT1) !Normalise
       
      ! rotation matrix from basis vectors
      R_M(1,:)=rot1
      R_M(2,:)=rot2
      R_M(3,:)=rot3

C Here, compute
C IF IAXIS = 1, then UXZBAR, =2 for UYZBAR, IAXIS = 3 for UZZBAR
          
      call rabubar_derivs(R_M, RAB, dUcart)
      RABUBAR_1=matmul(rab, matmul(U_M_1, transpose(rab)))
      if(present(results)) then
          results%subrestraints(1)%atoms(1)%adps_cart=RABUBAR_1
          results%subrestraints(1)%atoms(1)%M=rab
          results%subrestraints(2)%atoms(1)%adps_cart=RABUBAR_1
          results%subrestraints(2)%atoms(1)%M=rab
      end if
      
      do i=1, 2
      
        IF ( i==1 ) THEN   
C       #### XZ DERIVS ####
          ! (1,3) -> 3
          a1(7:12)=dUcart(3,:)
        ELSE
C      #### YZ DERIVS ####
          ! (2,3) -> 8
          a1(7:12)=dUcart(8,:)
        END IF

        a1(1:6)=a1(7:12)
      
C First atom of the restraint        
C The second atom is just used to define the basis        
C-----------------------------------------------
C--CHECK IF THE ATOM IS ANISO                                           
        JP=ISTORE(JA+6)
        JD=ISTORE(JA+16)
        JX=JP ! JX used in XADUIJ
        JO=JA ! JO used in XADUIJ
        IF(ABS(STORE(JD+6)) .gt. zero) THEN
C--'ISO' ATOM  -  MODIFY THE ENTRY IN THE COORDINATE SECTION            
           ISTORE(JA+5)=4         ! Reduce the number of restrained parameters to x,y,z,iso
           ISTORE(JP)=-1000000    ! Remove link to next parameter (U22- there isn't one)                                     
           ISTORE(JP+1)=8         ! Where they start 
C--SET THE EQUIVALENT ANISO TEMPERATURE FACTORS FOR THE ATOM
           JE=JD
           JF=L1C+2                                                       
           DO J=L1C,JF                                                  
              STORE(JE+14)=STORE(JD+14)
              STORE(JE+20)=STORE(JD+14)*STORE(J)                        
              JE=JE+2                                                   
           END DO
           STORE(JD+6)=0.
         
           STORE(JP+2)=STORE(JP+2)+A1(1)+A1(2)+A1(3)+A1(4)*STORE(L1C)+
     2        A1(5)*STORE(L1C+1)+A1(6)*STORE(L1C+2)         
        else 
           if (iasym==1) then
c             dont restrain first atom
c              print *, "Asym"
              a1(1:6) = 0.0
           endif      
           CALL XADUIJ  
        END IF
         
C--CALCULATE THE MEAN VALUE AND THE DIFFERENCE                          CVC01190
        IF  ( i==1 ) THEN          
           DIFF_VAL = RABUBAR_1(1,3)
           MEAN_VAL = RABUBAR_1(1,3) 
        ELSE
           DIFF_VAL = RABUBAR_1(2,3)
           MEAN_VAL = RABUBAR_1(2,3) 
       END IF
                          
C Here, you need to set D to be the computed value of the difference in the covariances
C Note that DUMP is the target difference (and should usually be zero).
C You need to set SUM to be the compute

         STORE(LCG+4)=0.5*(DUMP+MEAN_VAL)                                       CVC01320
         STORE(L22PD+2)=DUMP-DIFF_VAL ! Difference between restraint target (DUMP) and computed from current parameters (D)
         MCA=JA                                                            CVC01500
         STORE(L22PD+1) = STORE(LCG+3)                                     CVC01510
         CALL XFMPDQ                                                       CVC01520
      end do
      
      JA=ISTORE(JB)                                                     CVC01530

      IF(JA .GT. 0) then
         print *, 'No more atom expected'
         call abort()
      end if

      RETURN
      END
      
CODE FOR XCVCV
      SUBROUTINE XCVCV2(iasym, results)
      use list26_mod
C--CALCULATE PERPENDICULAR RESTRAINTS TO the bissector of 2 vectors
C
C      IAXIS = Not used
C
C      IASYM = 1 FOR ASYMMETRIC OTHERWISE 0
C
C--THE VARIABLES IN 'XWORK' ARE USED AS FOLLOWS :
C
C  P  DU(B)/DU(22)
C  .
C  .
C  T  DU(B)/DU(12)
C
C--SUBSEQUENTLY O TO T ARE USED FOR THE DIFFERENCES BETWEEN THE
C  THE TWO VALUES OF EACH VIBRATION PARAMETER
C
C--
      INCLUDE 'ISTORE.INC'
C
      type(restraints_t), intent(inout), optional :: results
      integer, intent(in) :: iasym
      DIMENSION A1(12)
      double precision ROT3(3)
      double precision ROT2(3)
      double precision ROT1(3)
      double precision ANAXIS(3)
      double precision DIFF_VEC1(3), DIFF_VEC2(3)
      
      double precision U_L_1(6)
C      DIMENSION U_L_2(6)
      integer U_ASSIGN (9)
      double precision U_M_1(3,3)
C      DIMENSION U_M_2(3,3)
      double precision A_M(3,3)      
      double precision R_M(3,3)
      double precision RAB(3,3)
C      DIMENSION UBAR_2(3,3)
      double precision RABUBAR_1(3,3)
C      DIMENSION RABUBAR_2(3,3)
      double precision dUcart(9,6) ! dU/dxx matrix where each derivative dxx is a column vector 

C      REAL CHECK_CAL_1
C      REAL CHECK_CAL_2
      REAL DIFF_VAL
      REAL MEAN_VAL
      
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
      include 'XUNITS.INC'
      include 'XSSVAL.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (O,A1(1))    ! Note well
C
C--SET UP A FEW CONSTANTS                                        
      DUMP=STORE(LCG+4)   ! The 'observed value' of the restraint
      JA=LCA              ! Address of first parameter block header                                      
      NCA=2                                                             
C--SET UP THE ADDRESSES OF THE ATOMS                                    
      JB=ISTORE(JA)             ! Address of next parameter block                                        
      JC=ISTORE(JB)             ! Address of next parameter block                                        
      JP=ISTORE(JA+6)           ! Address of first parameter (U11) for atom 1                                        
      JV=ISTORE(JB+6)           ! Address of first parameter (U11) for atom 2                                        

      if(present(results)) then
          call extend(results%subrestraints, 2, .true.)
          results%subrestraints(1)%description='Uc[1,3]==0'
          results%subrestraints(2)%description='Uc[2,3]==0'
          do icpt=1, 2
              call extend(results%subrestraints(icpt)%atoms, 3, .true.)
              results%subrestraints(icpt)%atoms(1)%label=
     &            transfer(istore(JA+2), 'aaaa')
              results%subrestraints(icpt)%atoms(1)%serial=
     &            nint(store(JA+3))
              results%subrestraints(icpt)%atoms(2)%label=
     &            transfer(istore(JB+2), 'aaaa')
              results%subrestraints(icpt)%atoms(2)%serial=
     &            nint(store(JB+3))
              results%subrestraints(icpt)%atoms(3)%label=
     &            transfer(istore(JC+2), 'aaaa')
              results%subrestraints(icpt)%atoms(3)%serial=
     &            nint(store(JC+3))
          end do
      end if
      
C--DEFINE U Matrices 
      U_L_1=STORE(ISTORE(JA+16)+14:ISTORE(JA+16)+14+11:2)
      
C     U Matrices in 3x3 matrix
      U_ASSIGN = (/ 1, 6, 5, 6, 2, 4, 5, 4, 3 /)
      U_M_1=reshape(U_L_1(U_ASSIGN), (/3,3/)) 
      if(present(results)) then
          results%subrestraints(1)%atoms(1)%adps_crys=U_M_1
      end if
      
C-- Set up the new coordinate system for the adp
C-----------------------------------------------

C--CALCULATE THE INTERNUCLEAR DISTANCE                                  
      JO=JA  
      JS=JB  
      JQ=ISTORE(JO+16)
      JU=ISTORE(JS+16)
      JW=ISTORE(JC+16)

C Here is the interatomic vector in crystal fractions:    
      DIFF_VEC1(1)=STORE(JQ+8)-STORE(JU+8)
      DIFF_VEC1(2)=STORE(JQ+10)-STORE(JU+10)
      DIFF_VEC1(3)=STORE(JQ+12)-STORE(JU+12)

      DIFF_VEC2(1)=STORE(JQ+8)-STORE(JW+8)
      DIFF_VEC2(2)=STORE(JQ+10)-STORE(JW+10)
      DIFF_VEC2(3)=STORE(JQ+12)-STORE(JW+12)
            
      ! Orthogonalisation matrix (stored by rows, reshape fill column wise, hence the transpose)
      A_M=transpose(reshape(STORE(L1O1:L1O1+8), (/3,3/))) ! Multiply diffvec by orthogonalisation matrix
      ROT1=matmul(A_M, DIFF_VEC1)
      ROT2=matmul(A_M, DIFF_VEC2)
      CALL DNORM3(ROT1) !Normalise
      CALL DNORM3(ROT2) !Normalise
      ROT3=ROT1+ROT2
      CALL DNORM3(ROT3) !Normalise

      ANAXIS = (/1.0d0, 0.0d0, 0.0d0/)
       VANGL = dot_product(ROT3, ANAXIS)      ! Dot product to get angle
       IF (ABS(VANGL) .GT. 0.95) THEN  ! Almost parallel, use y-axis instead.
c         print *, "Bond // to x-axis"
          ANAXIS = (/0.0d0, 1.0d0, 0.0d0/)
       END IF
       
       CALL DNCROP3(ROT3, ANAXIS, ROT2)  !Axis 2 perp to 3 and X-axis (or y if too close to x)
       CALL DNORM3(ROT2) !Normalise
       CALL DNCROP3(ROT2, ROT3, ROT1)   ! Axis 1 perp to 2 an 3.
       CALL DNORM3(ROT1) !Normalise
       
      ! rotation matrix from basis vectors
      R_M(1,:)=rot1
      R_M(2,:)=rot2
      R_M(3,:)=rot3

C Here, compute
C IF IAXIS = 1, then UXZBAR, =2 for UYZBAR, IAXIS = 3 for UZZBAR
          
      call rabubar_derivs(R_M, RAB, dUcart)
      RABUBAR_1=matmul(rab, matmul(U_M_1, transpose(rab)))
      if(present(results)) then
          results%subrestraints(1)%atoms(1)%adps_cart=RABUBAR_1
          results%subrestraints(1)%atoms(1)%M=rab
          results%subrestraints(2)%atoms(1)%adps_cart=RABUBAR_1
          results%subrestraints(2)%atoms(1)%M=rab
      end if
      
      do i=1, 2
      
        IF ( i==1 ) THEN   
C       #### XZ DERIVS ####
          ! (1,3) -> 3
          a1(7:12)=dUcart(3,:)
        ELSE
C      #### YZ DERIVS ####
          ! (2,3) -> 8
          a1(7:12)=dUcart(8,:)
        END IF

        a1(1:6)=a1(7:12)
      
C First atom of the restraint        
C The second atom is just used to define the basis        
C-----------------------------------------------
C--CHECK IF THE ATOM IS ANISO                                           
        JP=ISTORE(JA+6)
        JD=ISTORE(JA+16)
        JX=JP ! JX used in XADUIJ
        JO=JA ! JO used in XADUIJ
        IF(ABS(STORE(JD+6)) .gt. zero) THEN
C--'ISO' ATOM  -  MODIFY THE ENTRY IN THE COORDINATE SECTION            
           ISTORE(JA+5)=4         ! Reduce the number of restrained parameters to x,y,z,iso
           ISTORE(JP)=-1000000    ! Remove link to next parameter (U22- there isn't one)                                     
           ISTORE(JP+1)=8         ! Where they start 
C--SET THE EQUIVALENT ANISO TEMPERATURE FACTORS FOR THE ATOM
           JE=JD
           JF=L1C+2                                                       
           DO J=L1C,JF                                                  
              STORE(JE+14)=STORE(JD+14)
              STORE(JE+20)=STORE(JD+14)*STORE(J)                        
              JE=JE+2                                                   
           END DO
           STORE(JD+6)=0.
         
           STORE(JP+2)=STORE(JP+2)+A1(1)+A1(2)+A1(3)+A1(4)*STORE(L1C)+
     2        A1(5)*STORE(L1C+1)+A1(6)*STORE(L1C+2)         
        else 
           if (iasym==1) then
c             dont restrain first atom
c              print *, "Asym"
              a1(1:6) = 0.0
           endif      
           CALL XADUIJ  
        END IF
         
C--CALCULATE THE MEAN VALUE AND THE DIFFERENCE                          CVC01190
        IF  ( i==1 ) THEN          
           DIFF_VAL = RABUBAR_1(1,3)
           MEAN_VAL = RABUBAR_1(1,3) 
        ELSE
           DIFF_VAL = RABUBAR_1(2,3)
           MEAN_VAL = RABUBAR_1(2,3) 
       END IF
             
 !     if(present(results)) then
 !         results%atoms(1)%adps_derivatives=a1(7:12)
 !     end if
             
C Here, you need to set D to be the computed value of the difference in the covariances
C Note that DUMP is the target difference (and should usually be zero).
C You need to set SUM to be the compute

         STORE(LCG+4)=0.5*(DUMP+MEAN_VAL)                                       CVC01320
         STORE(L22PD+2)=DUMP-DIFF_VAL ! Difference between restraint target (DUMP) and computed from current parameters (D)
         MCA=JA                                                            CVC01500
         STORE(L22PD+1) = STORE(LCG+3)                                     CVC01510
         CALL XFMPDQ                                                       CVC01520
      end do
      
      JA=ISTORE(JC)                                                     CVC01530

      IF(JA .GT. 0) then
         print *, 'No more atom expected'
         call abort()
      end if

      RETURN
      END


C
C
CODE FOR XCVCY
      SUBROUTINE XCVCY(iaxis,iasym)
      use xssval_mod, only: issapp, issprt
      implicit none
C--CALCULATE UEQIV RESTRAINTS
C
C      IAXIS = 1 FOR XX ALIGNMENT
C      IAXIS = 2 FOR XY ALIGNMENT
C      IAXIS = 3 FOR XZ ALIGNMENT
C      IAXIS = 4 FOR YY ALIGNMENT
C      IAXIS = 5 FOR YZ ALIGNMENT
C      IAXIS = 6 FOR ZZ ALIGNMENT
C
C      IASYM = 1 FOR ASYMMETRIC OTHERWISE 0
C
C--THE VARIABLES IN 'XWORK' ARE USED AS FOLLOWS :
C
C  P  DU(B)/DU(22)
C  .
C  .
C  T  DU(B)/DU(12)
C
C--SUBSEQUENTLY O TO T ARE USED FOR THE DIFFERENCES BETWEEN THE
C  THE TWO VALUES OF EACH VIBRATION PARAMETER
C
C--
      INCLUDE 'ISTORE.INC'
C
      integer :: iaxis, iasym
      real, dimension(12) :: A1 !< Partial derivatives
      double precision, dimension(3) :: ROT1, ROT2, ROT3 !< Cartesian axes
      double precision, dimension(3) :: ANAXIS, ANORTH, DIFF_VEC !< temp variables to calculates axes
      
      double precision U_L(6) !< adp in linear 6 element form
      integer, dimension(9), parameter :: U_ASSIGN=
     &    (/ 1, 6, 5, 6, 2, 4, 5, 4, 3 /) !< Transform linear 6 elements adp to linear 9 element adps
      double precision, dimension(3,3) :: A_M !< orthogonalisation matrix
            
      type adp_t !< object holding all the infos necessary to construct the restraint
        integer atom !< index in store of the atom of the adp to restraint
        integer, dimension(3) :: basis_atoms !< atoms used to defined the basis
        integer :: U_L !< index of adps from store 
        double precision, dimension(3,3) :: U_M !< adps in 2D matrix form
        double precision, dimension(3,3) :: R_M !< rotation matrix
        double precision, dimension(3,3) :: RAB !< transformation matrix from crystal to user defined basis
        double precision, dimension(3,3) :: RABUBAR !< adp in the user defined basis
        double precision, dimension(9,6) :: dUcart !< dU/dxx matrix where each derivative dxx is a column vector
      end type
      type(adp_t), dimension(2) :: adps

      REAL DIFF_VAL
      REAL MEAN_VAL
      real dump
      
      integer ij, ik
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
      include 'XUNITS.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (O,A1(1))    ! Note well
C
      interface
          subroutine DNCROP3(A,B,C)
              double precision A(3),B(3),C(3)
          end subroutine
      end interface

      interface
          subroutine DNORM3(A)
              double precision A(3)
          end subroutine
      end interface
C--SET UP A FEW CONSTANTS                                        
      DUMP=STORE(LCG+4)   ! The 'observed value' of the restraint
c     print *, 'lca', lca
      JA=LCA              ! Address of first parameter block header                                      
      NCA=2                                                             
C--SET UP THE ADDRESSES OF THE ATOMS                                    

      ! data stored as: atom1 atom2 y1 z1 y2 z2
      adps(1)%atom=JA
      adps(2)%atom=ISTORE(JA)
      adps(1)%U_L=ISTORE(adps(1)%atom+16)+14
      adps(2)%U_L=ISTORE(adps(2)%atom+16)+14

      DO ij=1,2
         JD=ISTORE(adps(ij)%atom+16)   !Address of atom in L5
         JX=ISTORE(adps(ij)%atom+6)
C--CHECK IF THE ATOM IS ANISO                                           
         IF(ABS(STORE(JD+6)) .gt. zero) THEN
C--'ISO' ATOM  -  MODIFY THE ENTRY IN THE COORDINATE SECTION            
            ISTORE(adps(1)%atom+5)=4         ! Reduce the number of restrained parameters to x,y,z,iso
            ISTORE(JX)=-1000000    ! Remove link to next parameter (U22- there isn't one)                                     
            ISTORE(JX+1)=8         ! Where they start 
C--SET THE EQUIVALENT ANISO TEMPERATURE FACTORS FOR THE ATOM
            DO i=0,2                                                  
               STORE(adps(1)%U_L+i*2)=STORE(adps(1)%U_L)
               STORE(adps(1)%U_L+i*2+6)=STORE(adps(1)%U_L)*STORE(L1C+i)                        
            END DO
            STORE(JD+6)=0.
         END IF
      end do
      
      adps(1)%basis_atoms(1)=adps(1)%atom
      adps(1)%basis_atoms(2)=ISTORE(adps(2)%atom)
      adps(1)%basis_atoms(3)=ISTORE(adps(1)%basis_atoms(2))
      adps(2)%basis_atoms(1)=adps(2)%atom
      adps(2)%basis_atoms(2)=ISTORE(adps(1)%basis_atoms(3))
      adps(2)%basis_atoms(3)=ISTORE(adps(2)%basis_atoms(2))

      do ij=1, 2
          do ik=0, 5
              U_L(ik+1)=store(adps(ij)%U_L+ik*2)
          end do
                            
          adps(ij)%U_M=reshape(U_L(U_ASSIGN), (/3,3/))
      end do
      
      if(issprt==0) then
          write(ncwu, *) ''
          write(ncwu, 
     &       '(A,A,"(",I0,") -- ",A,"(",I0,"), args: ",I0,1X,I0)') 
     &       "U??QIV: XCVCY ",
     &       trim(transfer(istore(adps(1)%atom+2), 'aaaa')), 
     &       nint(store(adps(1)%atom+3)), 
     &       trim(transfer(istore(adps(2)%atom+2), 'aaaa')), 
     &       nint(store(adps(2)%atom+3)),
     &       iaxis,iasym
      end if
      
      if(issprt==0) then
          write(ncwu, '(1X, A, A,"(",I0,")", 32X, A, A,"(",I0,")")')
     &        'Adp 1:',
     &        trim(transfer(istore(adps(1)%atom+2), 'aaaa')), 
     &        nint(store(adps(1)%atom+3)),
     &        'Adp 2:', 
     &        trim(transfer(istore(adps(2)%atom+2), 'aaaa')), 
     &        nint(store(adps(2)%atom+3))
          do i=1, 3
              write(ncwu, '(3(E10.3,1X), 10X, 3(E10.3,1X))') 
     &            adps(1)%U_M(i,:), adps(2)%U_M(i,:)
          end do
      end if

            
      ! Orthogonalisation matrix (stored by rows, reshape fill column wise, hence the transpose)
      A_M=transpose(reshape(STORE(L1O1:L1O1+8), (/3,3/))) 
      do ij=1, 2
      
          do ik=0,2
              DIFF_VEC(ik+1)=
     &            store(istore(adps(ij)%basis_atoms(1)+16)+8+ik*2)-
     &            store(istore(adps(ij)%basis_atoms(2)+16)+8+ik*2)     
          end do

          do ik=0,2
              ANAXIS(ik+1)=
     &            store(istore(adps(ij)%basis_atoms(2)+16)+8+ik*2)-
     &            store(istore(adps(ij)%basis_atoms(3)+16)+8+ik*2)     
          end do

          ROT3=matmul(A_M, DIFF_VEC)
          ANORTH=matmul(A_M, ANAXIS)
          CALL DNORM3(ROT3) !Normalise
          CALL DNORM3(ANORTH) !Normalise
           
          CALL DNCROP3(ROT3, ANORTH, ROT2)  !Axis 2 perp to 3 and X-axis
          CALL DNORM3(ROT2) !Normalise
          CALL DNCROP3(ROT2, ROT3, ROT1)   ! Axis 1 perp to 2 an 3.
          CALL DNORM3(ROT1) !Normalise

          ! rotation matrix
          adps(ij)%R_M(1,:)=rot1
          adps(ij)%R_M(2,:)=rot2
          adps(ij)%R_M(3,:)=rot3

C The orthog matrix. It is an upper triangle assuming fortran column ordering. 
C (i.e. offsets +1 +2 +5 are zero).
C Derivatives go here. These values (iaxis*n) are currently just used for testing.


C Here, compute

C IF IAXIS = 1, then UXZBAR, =2 for UYZBAR, IAXIS = 3 for UZZBAR


          call rabubar_derivs(adps(ij)%R_M, adps(ij)%RAB, 
     &       adps(ij)%dUcart) 
      
          adps(ij)%RABUBAR=matmul(matmul(adps(ij)%RAB, adps(ij)%U_M), 
     &        transpose(adps(ij)%rab))
      
          IF ( IAXIS .EQ. 1 ) THEN   !UXXQIV
C      #### XX DERIVS ####
              ! (1,1) -> 1
              a1(7:12)=adps(ij)%dUcart(1,:)
              
          ELSE IF ( IAXIS .EQ. 2) THEN  !UXYQIV
C      #### XY DERIVS ####
              ! (1,2) -> 4
              a1(7:12)=adps(ij)%dUcart(4,:)
         
          ELSE IF ( IAXIS .EQ. 3) THEN  !UXZQIV
C      #### XZ DERIVS ####
              ! (1,3) -> 7
              a1(7:12)=adps(ij)%dUcart(7,:)
         
          ELSE IF ( IAXIS .EQ. 4) THEN  !UYYQIV
C      #### YY DERIVS ####
              ! (2,2) -> 5
              a1(7:12)=adps(ij)%dUcart(5,:)
         
          ELSE IF ( IAXIS .EQ. 5) THEN  !UYZBAR
C      #### YZ DERIVS ####
              ! (2,3) -> 8          
              a1(7:12)=adps(ij)%dUcart(8,:)
         
            ELSE   !UZZQIV
C      ##### ZZ DERIVS ####
              ! (3,3) -> 9
              a1(7:12)=adps(ij)%dUcart(9,:)
          END IF
          
          if(ij==1) then
              a1(1:6)=a1(7:12)
          else
              a1(1:6)=-a1(7:12)
          end if
C-----------------------------------------------
C--CHECK IF THE ATOM IS ANISO                                           
          JP=ISTORE(adps(ij)%atom+6)
          JD=ISTORE(adps(ij)%atom+16)
          JX=JP ! JX used in XADUIJ
          JO=JA ! JO used in XADUIJ
          IF(ABS(STORE(JD+6)) .gt. zero) THEN
C--'ISO' ATOM  -  MODIFY THE ENTRY IN THE COORDINATE SECTION            
             ISTORE(adps(ij)%atom+5)=4         ! Reduce the number of restrained parameters to x,y,z,iso
             ISTORE(JP)=-1000000    ! Remove link to next parameter (U22- there isn't one)                                     
             ISTORE(JP+1)=8         ! Where they start 
C--SET THE EQUIVALENT ANISO TEMPERATURE FACTORS FOR THE ATOM
             JE=JD
             JF=L1C+2                                                       
             DO l=L1C,JF                                                  
                STORE(JE+14)=STORE(JD+14)
                STORE(JE+20)=STORE(JD+14)*STORE(l)                        
                JE=JE+2                                                   
             END DO
             STORE(JD+6)=0.
             
             STORE(JP+2)=STORE(JP+2)+A1(1)+A1(2)+A1(3)+A1(4)*STORE(L1C)+
     2          A1(5)*STORE(L1C+1)+A1(6)*STORE(L1C+2)         
          else 
             if (iasym==1) then
c           dont restrain first atom
c            print *, "Asym"
                 a1(1:6) = 0.0
             endif      
             CALL XADUIJ  
          END IF
      
      end do
   
C--CALCULATE THE MEAN VALUE AND THE DIFFERENCE                          CVC01190      
         IF ( IAXIS .EQ. 1 ) THEN
             DIFF_VAL = adps(1)%rabubar(1,1) - adps(2)%rabubar(1,1)
             MEAN_VAL = adps(1)%rabubar(1,1) + adps(2)%rabubar(1,1)
         ELSE IF ( IAXIS .EQ. 2 ) THEN
             DIFF_VAL = adps(1)%rabubar(1,2) - adps(2)%rabubar(1,2)
             MEAN_VAL = adps(1)%rabubar(1,2) + adps(2)%rabubar(1,2)
         ELSE IF ( IAXIS .EQ. 3 ) THEN
             DIFF_VAL = adps(1)%rabubar(1,3) - adps(2)%rabubar(1,3)
             MEAN_VAL = adps(1)%rabubar(1,3) + adps(2)%rabubar(1,3)
         ELSE IF ( IAXIS .EQ. 4 ) THEN
             DIFF_VAL = adps(1)%rabubar(2,2) - adps(2)%rabubar(2,2)
             MEAN_VAL = adps(1)%rabubar(2,2) + adps(2)%rabubar(2,2)
         ELSE IF ( IAXIS .EQ. 5 ) THEN
             DIFF_VAL = adps(1)%rabubar(2,3) - adps(2)%rabubar(2,3)
             MEAN_VAL = adps(1)%rabubar(2,3) + adps(2)%rabubar(2,3)
         ELSE
             DIFF_VAL = adps(1)%rabubar(3,3) - adps(2)%rabubar(3,3)
             MEAN_VAL = adps(1)%rabubar(3,3) + adps(2)%rabubar(3,3)
         END IF

         STORE(LCG+4)=0.5*(DUMP+MEAN_VAL)                                       CVC01320
c        print *, 'L22PD saved', l22pd, ' Dump: ',DUMP
         STORE(L22PD+2)=DUMP-DIFF_VAL ! Difference between restraint target (DUMP) and computed from current parameters (D)
c        print *, 'L22PD+2 ', store(l22pd+2)
         MCA=adps(1)%atom                                                           CVC01500
         STORE(L22PD+1) = STORE(LCG+3)                                     CVC01510
c        print *, 'L22PD+1 ', store(l22pd+1)
         CALL XFMPDQ                                                       CVC01520
c         JA=ISTORE(JB)
c         print *, 'ISTORE: ',ISTORE(JA_at6_1)                                                     CVC01530
         JA=ISTORE(adps(2)%basis_atoms(3))                                               CVC01530

      if(issprt==0) then
          write(ncwu, '(1X, A)') 'R_M rotation matrix'
          do ij=1, 3
              write(ncwu, '(3(E10.3, 1X), 10X, 3(E10.3, 1X))') 
     &            adps(1)%R_M(ij,:), adps(2)%R_M(ij,:)
          end do
          write(ncwu, '(1X, A)') 'RAB rotation matrix'
          do ij=1, 3
              write(ncwu, '(3(E10.3, 1X), 10X, 3(E10.3, 1X))') 
     &            adps(1)%rab(ij,:), adps(2)%rab(ij,:)
          end do
             
          write(ncwu, '(1X, A, 6(E10.3, 1X))') 'Derivatives1: ', 
     &        adps(1)%dUcart(ik,:)
          write(ncwu, '(1X, A, 6(E10.3, 1X))') 'Derivatives2: ', 
     &        adps(2)%dUcart(ik,:)

          write(ncwu, '(1X, A, 34X, A)') 'RABUBAR 1', 'RABUBAR 2'
          do ij=1, 3
              write(ncwu, '(3(E10.3,1X), 10X, 3(E10.3,1X))') 
     &            adps(1)%RABUBAR(ij,:), adps(2)%RABUBAR(ij,:)
          end do
          write(ncwu, '(A, E10.3)') 'Delta: ', DIFF_VAL  
          write(ncwu, '(A, E10.3)') 'Mean: ', MEAN_VAL / 2.0
          write(ncwu, *) ''
      end if

      IF(JA .GT. 0) then
         print *, 'No more atom expected'
         call abort()
      end if

      END
    
      
C
C
CODE FOR XCVCW
      SUBROUTINE XCVCW(iaxis,iasym, results)
C--CALCULATE PLANAR RESTRAINTS
C
C      IAXIS = Not used
C      IASYM = 1 FOR ASYMMETRIC OTHERWISE 0
C
C--THE VARIABLES IN 'XWORK' ARE USED AS FOLLOWS :
C
C  P  DU(B)/DU(22)
C  .
C  .
C  T  DU(B)/DU(12)
C
C--SUBSEQUENTLY O TO T ARE USED FOR THE DIFFERENCES BETWEEN THE
C  THE TWO VALUES OF EACH VIBRATION PARAMETER
C
C--
C
      use xssval_mod
      use list26_mod
      implicit none

      type(restraints_t), intent(inout), optional :: results
      integer, intent(in) :: iasym
      integer, intent(in) :: iaxis
      real, dimension(12) :: A1 !< Partial derivatives
      double precision, dimension(3) :: ROT1, ROT2, ROT3 !< Cartesian axes
      double precision, dimension(3) :: ANAXIS, ANORTH, DIFF_VEC !< temp variables to calculates axes
      
      double precision U_L_1(6) !< adp in linear 6 element form
      integer, dimension(9), parameter :: U_ASSIGN=
     &    (/ 1, 6, 5, 6, 2, 4, 5, 4, 3 /) !< Transform linear 6 elements adp to linear 9 element adps
      double precision U_M_1(3,3) !< adp as a 3x3 matrix
      double precision R_M(3,3) !< rotation matrix
      double precision RAB(3,3) !< full transformation matrix
      double precision RABUBAR_1(3,3) !< adp in local cartesian coordinate space
      double precision, dimension(3,3) :: A_M !< orthogonalisation matrix
      double precision dUcart(9,6) !< dU/dxx matrix where each derivative dxx is a column vector
      real dump
      REAL DIFF_VAL
      REAL MEAN_VAL
      
      integer JA_ad1, JA_ad2, JA_ad3, JA_ad4    ! Temporary values to extract 3rd atom data
      
      integer icpt
C
      !include 'XSSVAL.INC'
      INCLUDE 'ISTORE.INC'
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
      include 'XUNITS.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (O,A1(1))    ! Note well
C

       JA_ad1 = 0
       JA_ad2 = 0
       JA_ad3 = 0
       JA_ad4 = 0
            

C--SET UP A FEW CONSTANTS                                        
      DUMP=STORE(LCG+4)   ! The 'observed value' of the restraint
c     print *, 'lca', lca
      JA=LCA              ! Address of first parameter block header                                      
      NCA=2                                                             
C--SET UP THE ADDRESSES OF THE ATOMS                                    
1000  CONTINUE  
c      print *, 'ja', ja                                                        
      JB=ISTORE(JA)             ! Address of next parameter block
      JA_ad1=ISTORE(JB)            ! Third atom?      
      JP=ISTORE(JA+6)           ! Address of first parameter (U11) for atom 1                                        
      JV=ISTORE(JB+6)           ! Address of first parameter (U11) for atom 2
      JA_ad2=ISTORE(JA_ad1+6)         ! ^^ for atom 3?    
C--CHECK THAT BOTH ATOMS ARE ANISO AND IF NOT MODIFY ACCORDINGLY        
      JX=JP                                                             
      JC=JA                                                             
      DO I=1,2,3 
         JD=ISTORE(JC+16)   !Address of atom in L5
C--CHECK IF THE ATOM IS ANISO                                           
         IF(ABS(STORE(JD+6)) .gt. zero) THEN
C--'ISO' ATOM  -  MODIFY THE ENTRY IN THE COORDINATE SECTION            
            ISTORE(JC+5)=4         ! Reduce the number of restrained parameters to x,y,z,iso
            ISTORE(JX)=-1000000    ! Remove link to next parameter (U22- there isn't one)                                     
            ISTORE(JX+1)=8         ! Where they start 
C--SET THE EQUIVALENT ANISO TEMPERATURE FACTORS FOR THE ATOM
            JE=JD                                                          
            JF=L1C+2                                                       
            DO J=L1C,JF                                                  
               STORE(JE+14)=STORE(JD+14)
               STORE(JE+20)=STORE(JD+14)*STORE(J)                        
               JE=JE+2                                                   
            END DO
            STORE(JD+6)=0.
         END IF
C--PASS ONTO THE NEXT ATOM
         IF ( I .EQ. 1 ) THEN                                     
            JX=JV                                                          
            JC=JB
         ELSE IF ( I .EQ. 2 ) THEN                                     
            JX=JA_ad1                                                          
            JC=JA_ad2                                                          
         ELSE
         
         END IF
         
      END DO
      
      if(present(results)) then
          call extend(results%subrestraints, 2, .true.)
          results%subrestraints(1)%description='Uc[1,2]==0'
          results%subrestraints(2)%description='Uc[2,3]==0'
          do icpt=1, 2
              call extend(results%subrestraints(icpt)%atoms, 3, .true.)
              results%subrestraints(icpt)%atoms(1)%label=
     &            transfer(istore(JA+2), 'aaaa')
              results%subrestraints(icpt)%atoms(1)%serial=
     &            nint(store(JA+3))
              results%subrestraints(icpt)%atoms(2)%label=
     &            transfer(istore(JB+2), 'aaaa')
              results%subrestraints(icpt)%atoms(2)%serial=
     &            nint(store(JB+3))
              results%subrestraints(icpt)%atoms(3)%label=
     &            transfer(istore(JA_ad1+2), 'aaaa')
              results%subrestraints(icpt)%atoms(3)%serial=
     &            nint(store(JA_ad1+3))
          end do
      end if
            
C--DEFINE U Matrices 

      U_L_1=STORE(ISTORE(JA+16)+14:ISTORE(JA+16)+14+11:2)
      
C     U Matrices in 3x3 matrix
      U_M_1=reshape(U_L_1(U_ASSIGN), (/3,3/)) 

      if(present(results)) then
          results%subrestraints(1)%atoms(1)%adps_crys=U_M_1
          results%subrestraints(2)%atoms(1)%adps_crys=U_M_1
      end if
            
C--CALCULATE THE INTERNUCLEAR DISTANCE                                  
      JO=JA  
      JS=JB
      JA_ad3=JA_ad1   
      JQ=ISTORE(JO+16)
      JU=ISTORE(JS+16)
      JA_ad4=ISTORE(JA_ad3+16)

C Here is the interatomic vector in crystal fractions:    
       DIFF_VEC(1) = STORE(JQ+8)-STORE(JU+8)
       DIFF_VEC(2) = STORE(JQ+10)-STORE(JU+10)
       DIFF_VEC(3) = STORE(JQ+12)-STORE(JU+12)
          
       ANAXIS(1) = STORE(JU+8)-STORE(JA_ad4+8)
       ANAXIS(2) = STORE(JU+10)-STORE(JA_ad4+10)
       ANAXIS(3) = STORE(JU+12)-STORE(JA_ad4+12)
      
c      print *, "Pre-Norm Pre-Orth Bond Vec"
c      print *, A, B, C
c      print *,   
      
      ! Orthogonalisation matrix (stored by rows, reshape fill column wise, hence the transpose)
      A_M=transpose(reshape(STORE(L1O1:L1O1+8), (/3,3/))) 
      ROT3=matmul(A_M, DIFF_VEC) ! Multiply diffvec by orthogonalisation matrix

      ANORTH=matmul(A_M, ANAXIS)
      CALL DNORM3(ROT3) !Normalise
      CALL DNORM3(ANORTH) !Normalise
      
C Take cross product with x axis 
       CALL DNCROP3(ROT3, ANORTH, ROT2)  !Axis 2 perp to 3 and X-axis (or y if too close to x)
       CALL DNORM3(ROT2) !Normalise
       CALL DNCROP3(ROT2, ROT3, ROT1)   ! Axis 1 perp to 2 an 3.
       CALL DNORM3(ROT1) !Normalise

C The orthog matrix. It is an upper triangle assuming fortran column ordering. 
C (i.e. offsets +1 +2 +5 are zero).
C Derivatives go here. These values (iaxis*n) are currently just used for testing.


C Here, compute

      ! rotation matrix
      R_M(1,:)=rot1
      R_M(2,:)=rot2
      R_M(3,:)=rot3

      call rabubar_derivs(R_M, RAB, dUcart)           
                       
      RABUBAR_1=matmul(matmul(RAB, U_M_1), transpose(rab))

      if(present(results)) then
          results%subrestraints(1)%atoms(1)%adps_cart=RABUBAR_1
          results%subrestraints(1)%atoms(1)%M=rab
          results%subrestraints(2)%atoms(1)%adps_cart=RABUBAR_1
          results%subrestraints(2)%atoms(1)%M=rab
      end if

      do i=1, 2
          if(i==1) then
C     #### XY DERIVS ####
              ! (1,2) -> 2
              a1(7:12)=dUcart(2,:)
              a1(1:6)=a1(7:12)
          else
C     #### XZ DERIVS ####
              ! (2,3) -> 6
              a1(7:12)=dUcart(6,:)
              a1(1:6)=a1(7:12)
          end if
C-----------------------------------------------
C--CHECK IF THE ATOM IS ANISO                                           
          JP=ISTORE(JA+6)
          JD=ISTORE(JA+16)
          JX=JP ! JX used in XADUIJ
          JO=JA ! JO used in XADUIJ
          IF(ABS(STORE(JD+6)) .gt. zero) THEN
C--'ISO' ATOM  -  MODIFY THE ENTRY IN THE COORDINATE SECTION            
              ISTORE(JA+5)=4         ! Reduce the number of restrained parameters to x,y,z,iso
              ISTORE(JP)=-1000000    ! Remove link to next parameter (U22- there isn't one)                                     
              ISTORE(JP+1)=8         ! Where they start 
C--SET THE EQUIVALENT ANISO TEMPERATURE FACTORS FOR THE ATOM
              JE=JD
              JF=L1C+2                                                       
              DO l=L1C,JF                                                  
                  STORE(JE+14)=STORE(JD+14)
                   STORE(JE+20)=STORE(JD+14)*STORE(l)                        
                  JE=JE+2                                                   
              END DO
              STORE(JD+6)=0.
             
              STORE(JP+2)=STORE(JP+2)+A1(1)+A1(2)+A1(3)+
     2           A1(4)*STORE(L1C)+A1(5)*STORE(L1C+1)+A1(6)*STORE(L1C+2)         
          else 
              if (iasym==1) then
c           dont restrain first atom
c            print *, "Asym"
                 a1(1:6) = 0.0
             endif      
             CALL XADUIJ  
          END IF
     
C--CALCULATE THE MEAN VALUE AND THE DIFFERENCE                          CVC01190
          
          if(i==1) then           
C             #### XY DERIVS ####
              DIFF_VAL = RABUBAR_1(1,2)
              MEAN_VAL = RABUBAR_1(1,2) 
          else
C             #### XZ DERIVS ####
              DIFF_VAL = RABUBAR_1(2,3)
              MEAN_VAL = RABUBAR_1(2,3) 
          end if
                          
          if(issprt==i) then
              write(ncwu, '(1X,A,I1,1X,6(E10.3, 1X))') 'Derivatives: ', 
     &            i, a1(7:12)

              write(ncwu, '(A, I1, 1X, E10.3)') 'Delta: ', i, DIFF_VAL  
              write(ncwu, '(A, I1, 1X, E10.3)') 'Mean: ', i, MEAN_VAL/2.0   
          end if 
             
C Here, you need to set D to be the computed value of the difference in the covariances
C Note that DUMP is the target difference (and should usually be zero).
C You need to set SUM to be the compute

          STORE(LCG+4)=0.5*(DUMP+MEAN_VAL)                                       CVC01320
          STORE(L22PD+2)=DUMP-DIFF_VAL ! Difference between restraint target (DUMP) and computed from current parameters (D)
          MCA=JA                                                            CVC01500
          STORE(L22PD+1) = STORE(LCG+3)                                     CVC01510
          CALL XFMPDQ                                                       CVC01520
      end do
      if(issprt==0) then
          write(ncwu, *) ''
      end if
      
            
         JA=ISTORE(JA_ad1)                                                     CVC01530
c         ja=jb

      IF(JA .GT. 0) GOTO 1000

      RETURN
      END
      
          
C
CODE FOR XCDDC
      SUBROUTINE XCDDC(iasym)
C--CALCULATE DISTANCE DIFFERENCE RESTRAINTS
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET UP THE POINTERS TO THE TOP OF THE WORK STACK
      DUMP=STORE(LCG+4)
C--FIND THE ADDRESS OF THE DISTANCE STORAGE AREA
      JH=ISTORE(LCG+2)+LC
      JI=JH
      JA=LCA
C--CALCULATE THE PARTIAL DIFFERENTIALS INITIALLY
1000  CONTINUE
      E=-1.0
      CALL XCDPD(IASYM)
C--STORE THE DISTANCE IN THE WORK STACK AREA
      STORE(JI)=D
      JI=JI+1
      JA=ISTORE(JB)
      IF(JA)1050,1050,1000
C--END OF THE FIRST PASS  -  PASS THROUGH NOW AND ACCUMULATE
1050  CONTINUE
      JI=JH
      JA=LCA
      NCA=4
1100  CONTINUE
C--NEXT DISTANCE  -  UPDATE DISTANCE AND ATOM POINTERS
      JJ=JI+1
      JB=ISTORE(JA)
      JD=ISTORE(JB)
C--REVERSE THE SIGNS OF THE DERIVATIVES FOR THE CURRENT
C  COMPARISON DISTANCE
      JP=ISTORE(JA+6)
      JQ=ISTORE(JB+6)
      DO 1150 JS=1,3
      STORE(JP+2)=-STORE(JP+2)
      STORE(JQ+2)=-STORE(JQ+2)
      JP=ISTORE(JP)
      JQ=ISTORE(JQ)
1150  CONTINUE
C--CHECK THAT THERE REMAIN AT LEAST ONE MORE DISTANCE FOR COMPARISON
      IF(JD)1350,1350,1200
C--START THE PASS THROUGH THE REMAINING DISTANCES FOR THIS COMPARISON ON
1200  CONTINUE
      MCA=JA
      JE=JD
1250  CONTINUE
      ISTORE(JB)=JE
      STORE(L22PD+2)=DUMP-STORE(JI)+STORE(JJ)
      STORE(LCG+4)=0.5*(DUMP+STORE(JI)+STORE(JJ))
      JJ=JJ+1
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
      JF=ISTORE(JE)
      JE=ISTORE(JF)
C--CHECK IF THERE ARE MORE DISTANCES FOR THIS DISTANCE
      IF(JE)1300,1300,1250
C--END OF THIS DISTANCE  -  MOVE TO THE NEXT
1300  CONTINUE
      JI=JI+1
      ISTORE(JB)=JD
      JA=JD
      GOTO 1100
1350  CONTINUE
      RETURN
      END
C
CODE FOR XCDC
      SUBROUTINE XCDC(iasym)
C--CALCULATE DISTANCE RESTRAINTS
C
C    IASYM = 0 FOR NORMAL
C            1 FOR ASYMMETRIC
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET UP THE INITIAL CONSTANTS
      JA=LCA
      NCA=2
C--LOOP FOR EACH INDIVIDUAL RESTRAINT
1000  CONTINUE
      E=1.0
      CALL XCDPD(IASYM)
      STORE(L22PD+2)=STORE(LCG+4)-D
      MCA=JA
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
      JA=ISTORE(JB)
      IF(JA)1050,1050,1000
1050  CONTINUE
      RETURN
      END
C
C
CODE FOR XCEC
      SUBROUTINE XCEC(IASYM)
C--CALCULATE ENERGY RESTRAINTS
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET UP THE INITIAL CONSTANTS
      JA=LCA
      NCA=2
C----- GET POWER FACTOR FROM PROCESSED ESD
      POWER = 1. / SQRT( STORE(LCG+3) )
C--LOOP FOR EACH INDIVIDUAL RESTRAINT
1000  CONTINUE
      E=1.0
      CALL XCDPD(IASYM)
      STORE(L22PD+2)=STORE(LCG+4)-D
C----- WEIGHT = 10000. * (D(TARGET)/D(ACTUAL)**(12*POWERFACTOR) )
      STORE(L22PD+1) = 10000 * AMIN1 (10000.,
     1 (STORE(LCG+4) / (AMAX1( D, 1.)) ) ** (12.*POWER) )
      MCA=JA
      CALL XFMPDQ
      JA=ISTORE(JB)
      IF(JA)1050,1050,1000
1050  CONTINUE
      RETURN
      END
C
CODE FOR XCMAC
      SUBROUTINE XCMAC
C--CALCULATE MEAN ANGLE RESTRAINTS
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
c     INCLUDE 'XUNITS.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CONVERT THE ANGLES AND WEIGHTS TO RADIANS
      STORE(LCG+3)=STORE(LCG+3)/(DTR*DTR)
      DUMP=STORE(LCG+4)*DTR
      STORE(LCG+4)=0.
      JJ=0
C--SET UP THE POINTERS TO THE TOP OF THE WORK STACK
      JH=ISTORE(LCG+2)+LC
      JI=JH
      JA=LCA
C--CALCULATE THE PARTIAL DIFFERENTIALS INITIALLY
1000  CONTINUE
      E=1.0
      CALL XCAPD
      STORE(LCG+4)=STORE(LCG+4)+V
      JJ=JJ+1
      STORE(JI)=V
      JI=JI+1
      JA=ISTORE(JC)
      IF(JA)1050,1050,1000
C--END OF THE FIRST PASS  -  PASS THROUGH NOW AND ACCUMULATE
1050  CONTINUE
      STORE(LCG+4)=STORE(LCG+4)/FLOAT(JJ)+DUMP
      JI=JH
      JA=LCA
      NCA=3
1100  CONTINUE
      JB=ISTORE(JA)
      JC=ISTORE(JB)
      MCA=JA
      STORE(L22PD+2)=STORE(LCG+4)-STORE(JI)
      STORE(L22PD+1) = STORE(LCG+3)
c     WRITE(NCWU,*)'Forming PDQ for mean angle restraint'
      CALL XFMPDQ
      JI=JI+1
      JA=ISTORE(JC)
      IF(JA)1150,1150,1100
1150  CONTINUE
      RETURN
      END
C
CODE FOR XCADC
      SUBROUTINE XCADC
C--CALCULATE MULTIPLE ANGLE RESTRAINTS
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
c     INCLUDE 'XUNITS.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CONVERT THE ANGLES AND WEIGHTS TO RADIANS
      STORE(LCG+3)=STORE(LCG+3)/(DTR*DTR)
      DUMP=STORE(LCG+4)*DTR
C--SET UP THE POINTERS TO THE TOP OF THE WORK STACK
      JH=ISTORE(LCG+2)+LC
      JI=JH
      JA=LCA
C--CALCULATE THE PARTIAL DIFFERENTIALS INITIALLY
1000  CONTINUE
      E=-1.0
      CALL XCAPD
      STORE(JI)=V
      JI=JI+1
      JA=ISTORE(JC)
      IF(JA)1050,1050,1000
C--END OF THE FIRST PASS  -  PASS THROUGH NOW AND ACCUMULATE
1050  CONTINUE
      JI=JH
      JA=LCA
      NCA=6
1100  CONTINUE
      JJ=JI+1
      JB=ISTORE(JA)
      JC=ISTORE(JB)
      JD=ISTORE(JC)
C--REVERSE THE SIGNS OF THE CURRENT COMPARISON ANGLE
      JP=ISTORE(JA+6)
      JQ=ISTORE(JB+6)
      JV=ISTORE(JC+6)
      DO 1150 JS=1,3
      STORE(JP+2)=-STORE(JP+2)
      STORE(JQ+2)=-STORE(JQ+2)
      STORE(JV+2)=-STORE(JV+2)
      JP=ISTORE(JP)
      JQ=ISTORE(JQ)
      JV=ISTORE(JV)
1150  CONTINUE
C--CHECK THAT THERE REMAIN AT LEAST ONE MORE DISTANCE FOR COMPARISON
      IF(JD)1350,1350,1200
1200  CONTINUE
      MCA=JA
      JE=JD
1250  CONTINUE
      ISTORE(JC)=JE
      STORE(L22PD+2)=DUMP-STORE(JI)+STORE(JJ)
      STORE(LCG+4)=0.5*(DUMP+STORE(JI)+STORE(JJ))
      JJ=JJ+1
      STORE(L22PD+1) = STORE(LCG+3)
c     WRITE(NCWU,*)'Forming PDQ for multi angle restraint'
      CALL XFMPDQ
      JF=ISTORE(JE)
      JG=ISTORE(JF)
      JE=ISTORE(JG)
      IF(JE)1300,1300,1250
1300  CONTINUE
      JI=JI+1
      ISTORE(JC)=JD
      JA=JD
      GOTO 1100
1350  CONTINUE
      RETURN
      END
C
CODE FOR XCAC
      SUBROUTINE XCAC
C--CALCULATE ANGLE RESTRAINTS
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
c     INCLUDE 'XUNITS.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CONVERT THE ANGLES AND WEIGHTS TO RADIANS
      STORE(LCG+3)=STORE(LCG+3)/(DTR*DTR)
      STORE(LCG+4)=STORE(LCG+4)*DTR
C--SET UP THE INITIAL CONSTANTS
      JA=LCA
      NCA=3
C--LOOP FOR EACH INDIVIDUAL RESTRAINT
1000  CONTINUE
      E=1.0
      CALL XCAPD
      STORE(L22PD+2)=STORE(LCG+4)-V
      MCA=JA
      STORE(L22PD+1) = STORE(LCG+3)
c     WRITE(NCWU,*)'Forming PDQ for normal angle restraint', 
c     2  STORE(L22PD+1), STORE(L22PD+2)
      CALL XFMPDQ
      JA=ISTORE(JC)
      IF(JA)1050,1050,1000
1050  CONTINUE
      RETURN
      END
C
CODE FOR KPLANE
      FUNCTION KPLANE(IN)
C--CALCULATE THE DERIVATIVES FOR A 'PLANAR' RESTRAINT
C
C  IN  A DUMMY ARGUMENT.
C
C--THE RETURN VALUES OF 'KPLANE' ARE :
C
C  -1  AN ERROR HAS BEEN FOUND.
C  >0  THE NUMBER OF ATOMS IN THE PLANE (>2).
C
C--
C
      DIMENSION FF(3)
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (FF(1),F)
      IDWZAP = IN
C--SET UP THE CORE AREAS FOR THE VARIOUS MATRICES
      KPLANE=NCA
      JS=NFL
      JT=4
C--SET UP THE CENTROID AREA FLAG
      JU=NFL+JT*NCA
C--SET UP THE LATENT ROOTS FLAG
      JV=JU+3
C--SET UP THE LATENT VECTORS FLAG  -  STORED BY COLUMNS
      JW=JV+3
C--SET UP THE NORMAL EQUATIONS AREA
      JX=JW+9
C--SET UP THE WORK AREA OF 4 WORDS
      JY=JX+9
      NFL=JY+4
C--CHECK THAT THERE IS ENOUGH ROOM
      IF(NFL-LFL)1200,1000,1000
C--NOT ENOUGH CORE AVAILABLE
1000  CONTINUE
      CALL XERHDR(0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1050)
      WRITE ( CMON ,1050)
      CALL XPRVDU(NCVDU, 1,0)
1050  FORMAT(' Insufficient memory for ''PLANAR'' restraint' )
C--SET THE ERROR RETURN VALUE
1100  CONTINUE
      KPLANE=-1
1150  CONTINUE
      RETURN
C--SET UP THE ATOM COORDINATES IN THE ATOM ARRAY AT 'JS'
1200  CONTINUE
      JA=LCA
      JB=JS
C--CHECK FOR THE END OF THE CHAIN
1250  CONTINUE
      IF(JA)1350,1350,1300
C--FETCH THE COORDINATES FROM THE SPREAD BLOCK  -  SYMMETRY ALREADY ADDE
1300  CONTINUE
      I=ISTORE(JA+16)
      STORE(JB)=STORE(I+8)
      STORE(JB+1)=STORE(I+10)
      STORE(JB+2)=STORE(I+12)
      STORE(JB+3)=1.
      JB=JB+JT
      JA=ISTORE(JA)
      GOTO 1250
C--CALCULATE THE MEAN PLANE
1350  CONTINUE
      IF(KMOLAX(STORE(JS),NCA,JT,STORE(JU),STORE(JV),STORE(JW),
     2 STORE(JX),STORE(JY)))1400,1500,1500
C--NOT ENOUGH ATOMS IN THE GROUP
1400  CONTINUE
      CALL XERHDR(0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1450)
      WRITE ( CMON ,1450)
      CALL XPRVDU(NCVDU, 1,0)
1450  FORMAT(' Insufficient atoms to define a plane')
      GOTO 1100
C--CALCULATE THE EQUATION OF THE PLANE
1500  CONTINUE
      CALL XMOLEQ(STORE(JU),STORE(JW),FF(1),D,STORE(JX))
C--NOW SET UP THE FLAGS TO CALCULATE THE DERIVATIVES
      MCA=LCA
      NCA=1
      JB=JS
      E=1.
C--CHECK FOR THE END OF THE CHAIN
1550  CONTINUE
      IF(MCA)1150,1150,1600
C--CALCULATE THE OBSERVED DEVIATION FROM THE PLANE
1600  CONTINUE
      STORE(JB+3)=F*STORE(JB)+G*STORE(JB+1)+H*STORE(JB+2)-D
C--CALCULATE THE DELTA VALUE
      STORE(L22PD+2)=STORE(LCG+4)-STORE(JB+3)
C--ADD IN THE DERIVATIVES
      JO=MCA
      CALL XADXYZ
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
      JB=JB+JT
      MCA=ISTORE(MCA)
      GOTO 1550
      END
C
CODE FOR XSUMCN
      SUBROUTINE XSUMCN(ITYPE)
C
C----- ITYPE = 1 = UNWEIGHTED
C              2 = Z WEIGHTED
C--reSTRAIN THE SUM OF THE SHIFTS OF THE PARAMETERS TO ZERO
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--INDICATE THAT THE FOUND VALUES ARE NOT TO BE STORED
      JS=-1
C--SCAN OVER THE PARAMETERS THAT ARE  STORED
      CALL XGRPSM(ITYPE)
C--SET THE DELTA TO ZERO
      STORE(L22PD+2)=0.
      STORE(LCG+4)=0.
C--ADD IN THE COMPUTED DERIVATIVES FOR THIS RESTRAINT
      MCA=LCA
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
      RETURN
      END
C
CODE FOR KAVERG
      FUNCTION KAVERG(IN)
C--RESTRAIN A GROUP OF PARAMETERS TO THEIR COMMON MEAN
C------ OR LIMIT THE PARAMETER SHIFTS TO APPROXIMATELY ZERO
C
C     IN   +1 COMPUTE DELTA = MEAN - VALUE
C     IN   -1 SET DELTA = 0, FOR 'LIMIT' RESTRAINT
C
C--THE RETURN VALUES OF 'KAVERG' ARE :
C
C  -1  NOT CORE AVAILABLE
C   0  RESTRAINT PROCESSED OKAY.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET UP THE AREA FOR THE STORED VALUES
      JS=MDCS-NCA
C--CHECK FOR CORE OVERFLOW
      IF(NFL+27-JS)1150,1000,1000
C--NOT ENOUGH CORE AVAILABLE
1000  CONTINUE
      CALL XERHDR(0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1050)
      WRITE ( CMON ,1050)
      CALL XPRVDU(NCVDU, 1,0)
1050  FORMAT(' Insufficient core for ''AVERAGE'' restraint ')
      KAVERG=-1
C--AND NOW RETURN
1100  CONTINUE
      RETURN
C--SCAN THE PROVIDED PARAMETERS
1150  CONTINUE
      KAVERG=0
      JT=1
      CALL XGRPSM(1)
C--COMPUTE THE AVERAGE VALUE
      A=STORE(LCG+2)/FLOAT(NCA)
      STORE(LCG+4)=STORE(LCG+4)+A
      STORE(LCG+2)=A
C--SET UP THE FLAGS TO ADD IN THE DERIVATIVES
      NCA=1
      JA=LCA
      JU=JS
C--CHECK FOR THE END OF THE PARAMETER HEADER CHAIN
1200  CONTINUE
      IF(JA)1100,1100,1250
C--COMPUTE THE DELTA AND ADD IN THE DERIVATIVES
1250  CONTINUE
      IF (IN) 1260,1260,1270
1260  CONTINUE
C----- 'LIMIT' RESTRAINT - SET DELTA = 0
      STORE(LCG+4) = 0.
      STORE(L22PD+2) = 0.
      GOTO 1280
1270  CONTINUE
C
C----- 'AVERAGE' RESTRAINT - COMPUTE DELTA
      STORE(L22PD+2)=STORE(LCG+4)-STORE(JU)
1280  CONTINUE
      JU=JU+JT
      MCA=JA
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
      JA=ISTORE(JA)
      GOTO 1200
      END
C
CODE FOR XGRPSM
      SUBROUTINE XGRPSM(ITYPE)
C
C----- ITYPE = 1 = UNWEIGHTED
C              2 = Z WEIGHTED
C--COMPUTE THE SUM OF A GROUP OF PARAMETERS
C
C--ON ENTRY THE FOLLOWING VARIABLES MUST BE SET :
C
C  LCA     THE ADDRESS OF THE FIRST ATOM HEADER BLOCK
C  JS      THE ADDRESS AT WHICH TO BEGIN STORING THE FOUND PARAMETER VAL
C          (IF SET NEGATIVE, THE VALUES ARE NOT STORED).
C  JT      THE INCREMENT BETWEEN SUCCESSIVE STORAGE LOCATIONS.
C
C--THE FOLLOWING VARIABLES ARE USED :
C
C  JA      THE ADDRESS OF THE CURRENT HEADER.
C  JO      USED BY 'XADXYZ', TOGETHER WITH OTHERS.
C  JU      CURRENT VALUE OF 'JS'.
C
C--THE TOTAL OF THE PARAMETERS IS RETURNED AT STORE(LCG+2)
C  THIS ROUTINE ALSO CLACULATES THE DERIVATIVES FOR EACH PARAMETER
C  AND PUTS THEM IN THE PARAMETER CHAIN.
C  THE PARAMETER OF INTEREST IS ASSUMED TO BE THE FIRST ON THE CHAIN
C  STARTING AT WORD 6 OF EACH HEADER.
C
C--
C
      DIMENSION F1(3),O1(6)
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST03.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (F1(1),F),(O1(1),O)
C
C----- LOAD LIST 3 IF WE NEED IT
      KLST3 = -1
      IF (ITYPE .EQ. 2) THEN
          IF (KHUNTR (3,0, IJNK1,IJNK2,IJNK3, -1) .EQ. 0) KLST3 = 1
      ENDIF
C--SET UP THE INITIAL CONSTANTS
      AA=0.
      E = 1.
      JA=LCA
      JU=JS
C--CHECK FOR THE END OF THE PARAMETER HEADER BLOCK CHAIN
1000  CONTINUE
      IF(JA)1500,1500,1050
C--SET UP THE INITIAL ADDRESS FLAGS FOR THIS HEADER
1050  CONTINUE
      II=0
      IJ=ISTORE(JA+6)
C--CHECK ON THE TYPE OF HEADER BLOCK
      IF(ISTORE(JA+1))1100,1150,1100
C--OVERALL PARAMETER OR SIMPLE ATOMIC PARAMETER
1100  CONTINUE
      STORE(IJ+2)=1.
      GOTO 1350
C--THIS IS AN ATOMIC HEADER BLOCK  -  CHECK THE PARAMETER TYPE
1150  CONTINUE
      II=ISTORE(IJ+1)+ISTORE(IJ+1)-2
      IF(ISTORE(IJ+1)-5)1100,1250,1200
C--NOT A SIMPLE PARAMETER  -  CHECK AGAIN
1200  CONTINUE
      IF(ISTORE(IJ+1)-7)1250,1250,1300
C--THIS IS A POSITIONAL COORDINATE
1250  CONTINUE
      CALL XZEROF(F1(1),3)
C--SET UP THE CORRECT DERIVATIVE
      IK=ISTORE(IJ+1)
      F1(IK-4)=1.
      JO=JA
      IF (ITYPE .EQ. 2) THEN
C-----  SET LIST 3 ADDRESSES
        IF ( KLST3 .EQ. 1) THEN
          KEYO = 1
          MINS = L3
          DO 100 J = 1, N3
C----- GET Z FROM THE FORMFACTOR
            IF ( ISTORE(JO+2) .EQ. ISTORE(MINS)) THEN
              E = STORE(MINS+KEYO) + STORE(MINS+KEYO+2)
     1        + STORE(MINS+KEYO+4) + STORE(MINS+KEYO+6)
     2        + STORE(MINS+KEYO+8) + STORE(MINS+KEYO+10)
              GOTO 110
            END IF
            MINS = MINS + MD3
100       CONTINUE
        END IF
110     CONTINUE
      END IF
C--COMPUTE THE DERIVATIVES, ALLOWING FOR SYMMETRY
      CALL XADXYZ
      GOTO 1350
C--THIS IS A ANISOTROPIC TEMPERATURE FACTOR
1300  CONTINUE
      CALL XZEROF(O1(1),6)
C--SET UP THE CORRECT DERIVATIVE
      IK=ISTORE(IJ+1)
      O1(IK-7)=1.
      JO=JA
      JX=IJ
C--COMPUTE THE DERIVATIVES, ALLOWING FOR SYMMETRY
      CALL XADUIJ
C--ADD IN THIS PARAMETER VALUE
1350  CONTINUE
      II=II+ISTORE(JA+16)
      AA = AA + STORE(II) * E
C--CHECK IF WE SHOULD STORE  THIS VALUE
      IF(JS)1450,1450,1400
C--STORE THE VALUE
1400  CONTINUE
      STORE(JU) =  STORE(II) * E
      JU=JU+JT
C--MOVE ONTO THE NEXT PARAMETER HEADER BLOCK
1450  CONTINUE
      JA=ISTORE(JA)
      GOTO 1000
C--END OF THE CHAIN  -  RETURN
1500  CONTINUE
      STORE(LCG+2)=AA
      RETURN
      END
C
CODE FOR XCDPD
      SUBROUTINE XCDPD(IASYM)
C--CALCULATE DISTANCE PARTIAL DERIVATIVES
C
C IASYM 0 = NORMAL
C       1 = ASYMMETRIC
C
C  JA  ADDRESS OF THE FIRST ATOM
C  E   SET ON ENTRY TO 1.0 OR -1.0 FOR DERIVATIVE MULTIPLIER.
C
C--THE SECOND ATOM IS CHAINED TO THE FIRST, AND ITS ADDRESS IS SET IN 'J
C  ON EXIT.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--FIND THE ADDRESS OF THE SECOND ATOM HEADER
      JB=ISTORE(JA)
C--SET UP THE FLAGS FOR 'XCD2PD'
      JO=JA
      JS=JB
C--COMPUTE THE DERIVATIVES, APART FROM THE MULTIPLIER
      CALL XCD2PD
C--CALCULATE THE DISTANCE
      D=SQRT((A*F+B*G+C*H)*0.5)
C--CALCULATE THE P.D. MULTIPLIER
      ESAVE=E/D*0.5
      IF (IASYM .EQ. 0) THEN
       E = ESAVE
      ELSE
       E = 0.
      ENDIF
C--DERIVATIVES FOR THE FIRST ATOM
      CALL XADXYZ
C--DERIVATIVES FOR THE SECOND ATOM
      E = -ESAVE
      JO=JB
      CALL XADXYZ
      RETURN
      END
C
CODE FOR XCAPD
      SUBROUTINE XCAPD
C--CALCULATE ANGLE PARTIAL DERIVATIVES
C
C  JA  ADDRESS OF ATOM 2
C  JB  ADDRESS OF ATOM 1  -  THE PIVOT ATOM
C  JC  ADDRESS OF ATOM 3
C
C  THE BOND ANGLE IS : JA-JB-JC
C
C--IN THIS LINK THE FOLLOWING VARIABLES ARE USED :
C
C  O  L12*L12
C  P  L23*L23
C  Q  L31*L31
C  R  L12*L12+L31*L31-L23*L23
C  S  L12
C  T  L23
C  U  L31
C  V  THE ANGLE IN RADIANS
C
C--AFTER THE INITIAL CALCULATIONS :
C
C  O  D(L12)/DP
C  P  D(L31)/DP
C  Q  D(L23)/DP
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
c      INCLUDE 'XUNITS.INC'
C
      INCLUDE 'QSTORE.INC'
C
      JB=ISTORE(JA)
      JC=ISTORE(JB)
C--CALCULATE THE CONSTANTS FOR L12
      JO=JB
      JS=JA
      CALL XCD2PD
      O=(A*F+B*G+C*H)*0.5
C--DUMP THE RESULTS
      X=F
      Y=G
      Z=H
C--CALCULATE THE CONSTANTS FOR L23
      JO=JA
      JS=JC
      CALL XCD2PD
      P=(A*F+B*G+C*H)*0.5
C--DUMP THE RESULTS
      U=F
      V=G
      W=H
C--CALCULATE THE CONSTANTS FOR L31
      JO=JC
      JS=JB
      CALL XCD2PD
      Q=(A*F+B*G+C*H)*0.5
      A=U
      B=V
      C=W
      R=O+Q-P
C--CALCULATE THE BOND LENGTHS
      S=SQRT(O+0.000001)
      T=SQRT(P+0.000001)
      U=SQRT(Q+0.000001)
C--CALCULATE THE ANGLE
      V=R/(2.0*S*U)
      IF(ABS(V)-1.0)1050,1050,1000
1000  CONTINUE
      V=SIGN(1.0,V)
1050  CONTINUE
      V=ACOS(V)
      W=1.0/(2.0*O*Q*SIN(V))
C--CALCULATE THE PARTIAL DERIVAITVES FOR THE BOND LENGTHS
      P=(R-Q-Q)*S*W
      O=(R-O-O)*U*W
      Q=2.0*S*T*U*W
      D=0.5*E
C--CALCULATE THE DERIVATIVE BASED ON L31
      E=D*P/U
C--ATOM 3
      JO=JC
c      WRITE(NCWU,*) 'A3 ',E,' ',F,' ',G,' ',H
      CALL XADXYZ
      E=-E
C--ATOM 1
      JO=JB
c      WRITE(NCWU,*) 'A1 ',E,' ',F,' ',G,' ',H
      CALL XADXYZ
C--CALCULATE THE DERIVATIVES BASED ON L23
      F=A
      G=B
      H=C
      E=D*Q/T
C--ATOM 2
      JO=JA
c      WRITE(NCWU,*) 'A2 ',E,' ',F,' ',G,' ',H
      CALL XADXYZ
      E=-E
C--ATOM 3
      JO=JC
c      WRITE(NCWU,*) 'A3a ',E,' ',F,' ',G,' ',H
      CALL XADXYZ
C--CALCULATE THE DERIVATIVES BASED ON L12
      F=X
      G=Y
      H=Z
      E=D*O/S
C--ATOM 1
      JO=JB
c      WRITE(NCWU,*) 'A1a ',E,' ',F,' ',G,' ',H
      CALL XADXYZ
      E=-E
C--ATOM 2
      JO=JA
c      WRITE(NCWU,*) 'A2a ',E,' ',F,' ',G,' ',H
      CALL XADXYZ
      RETURN
      END
C
CODE FOR XCD2PD
      SUBROUTINE XCD2PD
C--CALCULATE THE PARTIAL DERIVATIVES FOR THE DISTANCE  SQUARED
C
C  JO  ADDRESS OF THE HEADER BLOCK FOR THE ATOM FOR WHICH P.D.'S
C        ARE REQUIRED
C  JS  SECOND ATOM
C
C--USES THE COMMON BLOCK /XWORK/ AND RETURNS THE ANSWERS AS FOLLOWS :
C
C  A  X(1)-X(2)
C  B  Y(1)-Y(2)
C  C  Z(1)-Z(2)
C  F  P. D. W. R. T. X APART FROM D(X1-X2)/DX1  (NOT ALWAYS =1)
C  G  P. D. W. R. T. Y . . . .
C  H  P. D. W. R. T. Z
C
C--'F', 'G' AND 'H' ARE DERIVED WITH RESPECT TO THE GENERATED
C  COORDINATES, NOT THOSE IN LIST 5.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XLST01.INC'
C
      INCLUDE 'QSTORE.INC'
C
C
C--FIND THE ADDRESS OF THE SPREAD PARAMETERS
      JQ=ISTORE(JO+16)
      JU=ISTORE(JS+16)
C--CALCULATE THE 'DX', 'DY' AND 'DZ'
      A=STORE(JQ+8)-STORE(JU+8)
      B=STORE(JQ+10)-STORE(JU+10)
      C=STORE(JQ+12)-STORE(JU+12)
C--CALCULATE THE DERIVATIVES, APART FROM THE MULTIPLIER OF '0.5*DIST**-1
      F=2.0*(A*STORE(L1M1)+B*STORE(L1M1+1)+C*STORE(L1M1+2))
      G=2.0*(A*STORE(L1M1+3)+B*STORE(L1M1+4)+C*STORE(L1M1+5))
      H=2.0*(A*STORE(L1M1+6)+B*STORE(L1M1+7)+C*STORE(L1M1+8))
      RETURN
      END
C
CODE FOR XADXYZ
      SUBROUTINE XADXYZ
C--ADD IN THE CONTRIBUTIONS FOR X , Y AND Z
C
C  THE PARTIAL DERIVATIVES ARE ASSUMED TO BE STORED IN THE COMMON
C  BLOCK /XWORK/ :
C
C  F  P. D. W. R. T. X
C  G  P. D. W. R. T. Y
C  H  P. D. W. R. T. Z
C  E  MULTIPLIER FOR THE PARTIAL DERIVATIVES
C
C--'F', 'G' AND 'H' ARE THE DERIVATIVES WITH RESPECT TO THE GENERATED
C  COORDINATES OR STORED PARAMETERS, WHICH ARE DERIVED FROM THOSE IN LIS
C  5 BY SYMMETRY. THIS ROUTINE CALCULATES THE DERIVATIVES WITH RESPECT
C  TO THE COORDINATES IN LIST 5 FROM 'F', 'G' AND 'H'.
C
C--POINTERS IN 'XWORKA' ARE :
C
C  JO  ADDR. OF THE FIRST ATOM
C  JP  ADDR. OF THE CURRENT COORD. FOR THE FIRST ATOM
C  JQ  ADDR. OF THE COORDINATES FOR THE FIRST ATOM
C  JV  ADDR. OF THE GENERATED COORDS. FOR THE FIRST ATOM
C  JS  JO FOR THE SEOND ATOM
C  .
C  .
C
C--THE X, Y AND Z COORDS. ARE ASSUMED TO BE THE FIRST STORED.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
c     INCLUDE 'XUNITS.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--FIND THE ADDRESS OF THE PARAMETER CHAIN
      JP=ISTORE(JO+6)
C--FIND THE ADDRESS OF THE SPREAD PARAMETERS
      JV=ISTORE(JO+16)
C--LOOP OVER EACH COORDINATE
      DO 1000 J=1,3
C--FIND THE SYMMETRY MATRIX
      I=ISTORE(JO+4)+ISTORE(JP+1)
C--CALCULATE THE DERIVATIVES FOR THIS COORD. W.R.T. THE GENERATED X, Y Z
      STORE(JV+9)=STORE(JO+14)*STORE(I-5)
      STORE(JV+11)=STORE(JO+14)*STORE(I-2)
      STORE(JV+13)=STORE(JO+14)*STORE(I+1)
C--CALCULATE THE PARTIAL DERIVATIVE FOR THIS COORD
      STORE(JP+2)=STORE(JP+2)+E*(F*STORE(JV+9)+G*STORE(JV+11)
     2 +H*STORE(JV+13))
c     WRITE(NCWU,*)'ADXYZ ', I, ' ', STORE(JP+2), ' ', JP
      JP=ISTORE(JP)
1000  CONTINUE
      RETURN
      END
C
CODE FOR XADUIJ
      SUBROUTINE XADUIJ
C--ADD THE DERIVATIVES FOR THE UIJ'S INTO THE PARAMETER BLOCKS,
C  ALLOWING FOR SYMMETRY AS IT IS DONE.
C
C--THE FOLLOWING VARIABLES MUST BE SET
C
C  JO  ADDRESS OF THE ATOM HEADER.
C  JX  ADDRESS OF THE FIRST PARAMETER BLOCK TO PROCESS.
C      (THIS VARIABLE IS UPDATED BY THIS ROUTINE).
C
C--THE DERIVATIVES FOR U(11), U(22), ETC. ARE STORED IN O, P, Q, ETC.
C
C--
      INCLUDE 'ISTORE.INC'
C
      DIMENSION A1(12)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (O,A1(1))
C
C--FIND THE ADDRESS OF THE SYMMETRY MATRIX USED
      L=ISTORE(JO+4)
C--ZERO THE U(IJ) DERIVATIVE AREA
      CALL XZEROF(STORE(NFL+18),6)
C--LOOP OVER EACH U(IJ), COMPUTING THE DERIVATIVE, ALLOWING FOR SYMMETRY
      DO 1000 J=1,6
      If(jX+1<0) call abort()
      K=NFL+ISTORE(JX+1)+10
      STORE(K)=1.
C--CALCULATE DU(IJ)'/DU(IJ), WHERE THE ' ALLOWS FOR SYMMETRY
c      write(123,'(6f10.6)') (store(idjw),idjw=nfl+18,nfl+23)
      CALL XEXANI(NFL+18,NFL)
      CALL XMLTTM(STORE(NFL),STORE(L),STORE(NFL+9),3,3,3)
      CALL XMLTTM(STORE(L),STORE(NFL+9),STORE(NFL),3,3,3)
      STORE(K)=0.
C--CALCULATE DV/DU(IJ)
      STORE(JX+2)=STORE(JX+2)+STORE(NFL)*A1(1)+STORE(NFL+4)*A1(2)
     2 +STORE(NFL+8)*A1(3)+STORE(NFL+5)*A1(4)+STORE(NFL+2)*A1(5)
     3 +STORE(NFL+1)*A1(6)
      JX=ISTORE(JX)
1000  CONTINUE
      RETURN
      END
C
CODE FOR XIPDQF
      SUBROUTINE XIPDQF
C--INITIATE PARTIAL DERIVATIVE QUEUE FORMATION
C
C--THIS ROUTINE SETS UP THE P.D. STACK IN CORE, AND FINDS THE DISC ADDR.
C  AT WHICH TO START PUTTING OUT THE INFORMATION.
C
C  L22PD   ADDRESS OF THE PARTIAL DERIVATIVE STACK IN CORE
C  M22PD   CURRENT DISC ADDRESS OF THE PARTIAL DERIVATIVE QUEUE
C  MD22PD  LENGTH OF EACH ENTRY IN THE QUEUE  (=2)
C
C--THE FORMAT OF THE STACK FOR EACH RESTRAINT IS AS FOLLOWS :
C
C  ISTORE(L22PD  )  LENGTH OF THE ENTRY
C   STORE(L22PD+1)  WEIGHT
C   STORE(L22PD+2)  CALC. DELTA
C   STORE(L22PD+3)  OBSERVED VALUE SQUARED
C
C  ISTORE(L22PD+4)  PARAMETER 1
C   STORE(L22PD+5)  P. D. FOR PARAMETER 1
C  .
C  .
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLST12.INC'
      INCLUDE 'XLST22.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET THE LIST TYPE RECORD TYPE FOR THE STACK
      LN=22
      IREC=1001
C--SET THE LENGTH OF EACH ENTRY IN THE STACK
      MD22PD=2
C--SET UP THE STACK
      L22PD=NFL
      M22PD=KCHNFL(4+N12*MD22PD)
C--FIND THE DISC ADDRESS
      M22PD=KNEXTF(L22PD)
      RETURN
      END
C
CODE FOR XTPDQF
      SUBROUTINE XTPDQF
C--TERMINATE PARTIAL DERIVATIVE QUEUE FORMATION
C
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET THE TRANSFER LENGTH
      N22PD=4
C--SET THE TRANSFER DETAILS
      ISTORE(L22PD)=NOWT
      CALL XZEROF(STORE(L22PD+1),N22PD-1)
C--OUTPUT THE DATA TO THE DISC
      CALL XUPF(M22PD, ISTORE(L22PD),N22PD)
      RETURN
      END
C
CODE FOR XFMPDQ
      SUBROUTINE XFMPDQ
      use list26_mod, only: subrestraints_parent, current_restraintindex
      use list26_mod, only: extend
C--FORM THE PARTIAL DERIVATIVE QUEUE
C  THIS SUBROUTINE TAKES THE CALCULATED PARTIAL DERIVATIVES FOR
C  EACH ATOM AND ADDS THEM INTO THE QUEUE.
C
C--THE FOLLOWING ATOMS POINTERS IN 'XCNTRL' MUST BE SET :
C
C  MCA  ADDRESS OF THE HEADER BLOCK FOR THE FIRST ATOM TO BE TREATED
C  NCA  NUMBER OF ATOMS TO TREAT
C
C--THE HEADER BLOCKS ARE ASSUMED TO BE IN STANDARD FORMAT, WITH
C  THE LIST 12 ADDRESSES ALREADY SET.
C  TERMINATION IS REACHED BY A NEGATIVE LINK ADDRESS.
C
C--THE OBSERVED VALUE SQUARED ARE TAKEN FROM THE CONTROL BLOCK AT 'LCG'
C  THE OTHER ENTRIES FOR THE CALCULATED DELTA AND WEIGHT ARE ASSUMED
C  TO BE SET ON ENTRY.
C
C----- ISTORE (LCG+1) OPERATIONS
C      1  DEFINE    2  RESTRAIN  3  DISTANCE 4
C      5            6  ANGLE     7           8
C      9  VIBRATION 10 EXECUTION 11 NOLIST   12 UIJ
C      13 EQUATE    14 PLANAR    15 SUM      16 FORM
C      17 AVERAGE   18 LIMIT     19 ENERGY   20 ORIGIN
C

C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLST12.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XCONST.INC'
C
      INCLUDE 'XL26WK.INC'
C
      INCLUDE 'QSTORE.INC'
C
C
C

      call extend(subrestraints_parent, 1)
        subrestraints_parent(size(subrestraints_parent))=
     1    current_restraintindex

C--SET THE REMAINDER OF THE HEADER BLOCK
      STORE(L22PD+3)=STORE(LCG+4)*STORE(LCG+4)
      J=JR+N12-1
      DO I=JR,J
        STORE(I)=0.
      END DO
      STORE(JN)=0.
      K=MCA
      N=NCA
C--CHECK IF THERE ANY MORE ATOMS TO PROCESS
1050  CONTINUE
      IF(N)1700,1700,1100
C--CHECK IF THIS ATOM HAS AN ACTIVE ENTRY IN LIST 12
1100  CONTINUE
      M12=ISTORE(K+13)
      IF(ISTORE(M12+1))1650,1650,1150
1150  CONTINUE
      M12=ISTORE(M12+1)
      M=ISTORE(K+6)
C--CHECK IF THERE ARE ANY MORE COORDINATES TO BE REFINED
1200  CONTINUE
      L12A=M12
      IF(M)1650,1650,1250
C--FIND THE ADDRESSES OF THIS COORDINATE
1250  CONTINUE
      L=ISTORE(M+1)-1
C--COMPUTE THE ABSOLUTE ADDRESS OF THE INFORMATION FOR THIS COORDINATE
C  IN LIST 12
1300  CONTINUE
      M12A=ISTORE(L12A+2)+ISTORE(L12A+1)*(L-ISTORE(L12A+4))
C--CHECK TO SEE IF THERE IS AN ENTRY FOR THIS COORDINATE
      IF(M12A-ISTORE(L12A+2))1550,1400,1350
1350  CONTINUE
      IF(ISTORE(L12A+3)-M12A)1550,1400,1400
C--FIND THE ADDRESS OF THE PARTIAL DERIVATIVE AND CHECK IF THE 'WEIGHT'
C  IS EQUAL TO 1.0
1400  CONTINUE
      I=ISTORE(M12A)
      IF(ISTORE(L12A+1)-1)1500,1500,1450  
C--NON-UNIT 'WEIGHT'
1450  CONTINUE
c      WRITE(NCWU,*)'Str PDQ1: ',' i:',I,' m:',M,' ',STORE(M+2),' w:',
c     1 STORE(M12A+1),' s(I):',STORE(I),' ++ ',STORE(M+2)*STORE(M12A+1)
      STORE(I)=STORE(I)+STORE(M+2)*STORE(M12A+1)
c      WRITE(NCWU,*)'After:    ',' i:',I,' m:',M,' ',STORE(M+2),' w:',
c     1 STORE(M12A+1),' s(I):',STORE(I),' ++ ',STORE(M+2)*STORE(M12A+1)
      GOTO 1550
C--UNIT 'WEIGHT'
1500  CONTINUE
      STORE(I)=STORE(I)+STORE(M+2)
c      WRITE(NCWU,*)'Str PDQW: ',' ',I,' ',M,' ',STORE(M+2),' ',STORE(I)
C--PICK UP THE NEXT PART FOR THIS ATOM IN LIST 12
1550  CONTINUE
      L12A=ISTORE(L12A)
      IF(L12A)1600,1600,1300
C--PASS ON TO THE NEXT COORDINATE
1600  CONTINUE
      M=ISTORE(M)
      GOTO 1200
C--PASS ON TO THE NEXT ATOM HEADER
1650  CONTINUE
      K=ISTORE(K)
      N=N-1
      GOTO 1050
C
C--COMPRESS THE QUEUE AND OUTPUT IT TO THE DISC
1700  CONTINUE
      N22PD=4
      J=L22PD+N22PD
      K=JR
c      WRITE(NCWU,*) 'PDQAddress: ',J,' ',K 
      DO L=1,N12
c        WRITE(NCWU,*) 'PD: ',L,' ',K,' ',STORE(K),N22PD
C--CHECK IF THE CONTRIBUTION FOR THIS PARAMETER IS ZERO
c        IF(STORE(K))1750,1800,1750
         IF ( ABS(STORE(K))/=0.0 ) THEN
C--ADD IT TO THE QUEUE
            ISTORE(J)=L
            STORE(J+1)=STORE(K)
            J=J+MD22PD
            N22PD=N22PD+MD22PD
         END IF
         K=K+1
      END DO
      ISTORE(L22PD)=N22PD
      K=J-MD22PD
      J=L22PD+4
C--CHECK IF ANY P.D.'S HAVE BEEN FOUND
      IF(J-K)2050,2050,1900
C--NO P.D.'S FOUND
1900  CONTINUE
cdjw2015      IF(ISTAT2)2200,2200,1950
1950  CONTINUE
c     skip shift limiting and origin fixing.
       itemp = istore(lcg+1)
       ioper = iabs(itemp)
      if ((itemp .ne. 18).and.(itemp .ne. 20)) then
        L26WRN=L26WRN+1
        IF(L26TYP .EQ. 1) THEN
         WRITE(CMON,'(A,1x,A,A)') '{I Directive ', 
     1  COPERATION(ioper)(1:nctrim(COPERATION(ioper))),
     1 ': No derivatives found during Evaluation'
C         CALL XPRVDU(NCVDU,1,0)
         IF (ISSPRT .EQ. 0) WRITE(NCWU,'(A,A)')
     1  CMON(1)(3:nctrim(cmon(1)))
         endif
        ENDIF
      GOTO 2200
C--DERIVATIVES FOUND  -  CHECK IF THEY ARE TO BE PRINTED
2050  CONTINUE
      IF(ISTAT2)2200,2200,2100
2100  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2150)ISTORE(L22PD),STORE(L22PD+1),STORE(L22PD+2),
     2 STORE(L22PD+3),(ISTORE(I),STORE(I+1),I=J,K,MD22PD)
      ENDIF
cRIC13:2150  FORMAT(16H Derivative(s) :/I10,/,3(10X,E20.10)/
cRIC13:     2 (4(I10,E20.10)))
2150  FORMAT(16H Derivative(s) :/I10,/,3(10X,E20.4)/
     2 (4(I10,E20.4)))
C--OUTPUT THE QUEUE TO THE DISC
2200  CONTINUE
      CALL XUPF(M22PD, ISTORE(L22PD), N22PD)
      M22PD=M22PD+KINCRF(N22PD)
      RETURN
      END
C
CODE FOR XADCPD
      SUBROUTINE XADCPD(calconlyarg)
      use sfls_punch_mod
      use list26_mod
C--THIS ROUTNE TAKES THE PARTIAL DERIVATIVE QUEUE ON THE DISC
C  AND ADDS IT TO THE NORMAL MATRIX.
C
C--
      INCLUDE 'TYPE11.INC'
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XSTR11.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XLST11.INC'
      INCLUDE 'XLST12.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XLST33.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLSVAL.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QSTR11.INC'
      
      logical, optional, intent(in) :: calconlyarg
      logical calconly, skipderivatives
      
      double precision, dimension(:), allocatable :: globalderivatives !< Line of the unweigthed design matrix including all the blocks
      double precision, dimension(:), allocatable :: derivatives !< line of the unweighted design matrix from a single block
      integer, dimension(:), allocatable :: globalparameters !< Parameters number from globalderivatives
      integer, dimension(:), allocatable :: parameters !< Parameters number from derivatives
      double precision, dimension(:), allocatable :: temp
      integer, dimension(:), allocatable :: itemp
      integer sfls_punch_flag, iblockindex, isubrestraint
      integer ioldrestraint, saveilsmsg, saveilsnms
      
      calconly=.false. ! this flag is set when the subroutine is called outside sfls, ie from check
      skipderivatives=.false. ! if list 11 is absent or nor up to date, the derivatives are not saved in the list26 object (see list26_mod.F90)
      ! when calconly is .false., skipderivatives is always .false.
      if(present(calconlyarg)) then
        if(calconlyarg) then
          calconly=.true.
          sfls_punch_flag=-1
        end if
      end if
C
C--SET THE LENGTH OF EACH ENTRY
      MD16Q=MD22PD
C--CLEAR THE CORE ENTRIES
      CALL XRSL
      CALL XCSAE
C--FIND WHETHER A NEW MATRIX IS BEING COMPUTED
      if(.not. calconly) then
        CALL XFAL33
        IF ( IERFLG .LT. 0 ) GO TO 9900
        JK=ISTORE(M33CD+6)
        sfls_punch_flag=ISTORE(M33CD+5)
      end if
C--RESET THE CORE LIMITS
      CALL XRSL
      CALL XCSAE
C--LOAD LIST 12
      CALL XFAL12(0,0,JR,JN)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--RESET THE CORE LIMITS
      CALL XRSL
      CALL XCSAE
C--INDICATE THE LIST AND RECORD TYPE
      LN=12
      IREC=1001
C--ALLOCATE SAPCE FOR THE BLOCKING DATA
      M12B=L12B
      I=N12B*MD12B
      L12B=KCHLFL(I)
C--MOVE THE BLOCKING DATA ACROSS
      CALL XMOVE(STORE(M12B),STORE(L12B),I)
C--SET THE POINTER TO THE END OF THIS STACK
      M12B=L12B+(N12B-1)*MD12B
C--FIND THE ADDRESS OF THE P.D. QUEUE ON DIC
      MD16=KNEXTF(I)
C--LOAD THE LIST 11
      if(calconly) then
        IF (KEXIST(11)>0) THEN

          ! ilsmsg, ilsnms turn off error printing and reporting to the user
          saveilsmsg=ilsmsg
          saveilsnms=ilsnms
          ilsmsg=-1
          ilsnms=-1
          CALL XSET11(0,1,1)
          ! restore the flags from previous state
          ilsmsg=saveilsmsg
          ilsnms=saveilsnms
          IF ( IERFLG .LT. 0 ) then ! error with list 11, skipping the derivatives part
            skipderivatives=.true.
            IERFLG=1
          end if
        else
          skipderivatives=.true.
        end if
      else
        CALL XSET11(0,1,1)
        IF ( IERFLG .LT. 0 ) GO TO 9900
      end if
      
      if(.not. skipderivatives) then
C--CHECK THAT THE MATRIX IS THE RIGHT TYPE
        IF(ISTORE(L11P+15))1000,1000,1050
C--STORED MATRIX HAS ALREADY BEEN INVERTED
1000  CONTINUE
        JK=0
C--COMPUTE THE WEIGHT MULTIPLIER
1050  CONTINUE
        IF ( (ABS (STORE( L11P + 16 )) .LE. ZERO ) .OR.
     1       (ABS (STORE( L11P + 17 )) .LE. ZERO ) ) THEN
              B = 1.
        ELSE
              B = STORE( L11P + 17 ) / STORE( L11P + 16 )
        ENDIF
        IF ( B .LE. ZERO ) B = 1.
      else
        B=1.0
      endif

      if(.not. calconly) then
C--CLEAR THE TOTAL ACCUMULATION AREAS
        STORE(L11P+27)=0.
        STORE(L11P+28)=0.
        STORE(L11P+29)=0.
      end if
C--SET UP AN AREA TO HOLD THE QUEUE ENTRIES FROM DISC
      L16=NFL
      LN=22
      IREC=1001
      M16=KCHNFL(MD22PD*N12+4)
C--CHECK IF A CORE MAP IS REQUIRED
      IF(ISTAT2)1100,1150,1100
1100  CONTINUE
      CALL XPCM(1)
C--BRING DOWN THE LENGTH OF THE FIRST RECORD
1150  CONTINUE
      CALL XDOWNF(MD16,ISTORE(L16),1)
C--SET THE LENGTH OF THE FIRST ENTRY
      N16=ISTORE(L16)
C--Initialise counter
      ioldrestraint=0 ! counter for restraint in list26
      isubrestraint=1 ! counter for each restraint generated from eah user restraint

C--INCREMENT THE TRANSFER ADDRESS
      MD16=MD16+KINCRF(1)
C--QUEUE PROCESSING LOOP
1200  CONTINUE
        IF(N16)1850,1850,1250
C--PROCESS THE NEXT RESTRAINT
1250    CONTINUE
        ioldrestraint=ioldrestraint+1
        
        ! if 2 consecutive have the same parent, there are generated from the same user restraint
        if(ioldrestraint>1) then
            if(subrestraints_parent(ioldrestraint)==
     1          subrestraints_parent(ioldrestraint-1)) then
                isubrestraint=isubrestraint+1
            else
                isubrestraint=1
            end if
        end if
                
        ! set zero entry for blocks in current restraint
        ! blocks(0) is the line of the design matrix with the block merged together
        if(.not. skipderivatives) then
          if(allocated(
     1      restraints_list(subrestraints_parent(ioldrestraint))%
     1      subrestraints)) then
            call extend(
     1        restraints_list(subrestraints_parent(ioldrestraint))%
     1        subrestraints(isubrestraint)%blocks, 1, .true. )
          end if
        else
          if(allocated(
     1      restraints_list(subrestraints_parent(ioldrestraint))%
     1      subrestraints)) then       
            if(allocated(
     1        restraints_list(subrestraints_parent(ioldrestraint))%
     1        subrestraints(isubrestraint)%blocks)) then
              deallocate(        
     1          restraints_list(subrestraints_parent(ioldrestraint))%
     1          subrestraints(isubrestraint)%blocks )
            end if
          end if
        end if
             
        CALL XDOWNF(MD16,STORE(L16),N16)
C--INCREMENT THE TRANSFER ADDRESS
        MD16=MD16+KINCRF(N16)
C--INDICATE THE NUMBER OF ENTRIES TO PROCESS
        N16=N16-4
C--INDICATE THE CORE ADDRESS OF THE FIRST ENTRY
        M16=L16+3
C--INDICATE THE ADDRESS OF THE LAST ENTRY IN THE QUEUE
        M16Q=M16+N16-MD16Q
C--CHECK IF ANY DERIVATIVES HAVE BEEN FOUND
        IF(N16)1800,1800,1300
C--COMPUTE THE ACTUAL WEIGHT TO USE
1300    CONTINUE
        C=STORE(L16)*B
        D=STORE(L16+1)
cdjwmay2000 - note problems with Rfactor when target is zero!
        if(.not. calconly) then
          STORE(L11P+27)=STORE(L11P+27)+1.
          STORE(L11P+28)=STORE(L11P+28)+D*D*C
          STORE(L11P+29)=STORE(L11P+29)+STORE(L16+2)*C
        end if

        !IF (MATLAB.GT.0) WRITE(NCFPU2,'(G16.8)') D
        if(sfls_punch_flag>0) then
            call sfls_punch_addtowdf(D, sfls_punch_flag)
        end if

c       IF (MATLAB.GT.0) WRITE(NCWU,'(A,G16.8)')'Hello ',store(l11P+27)
        if(allocated(globalderivatives)) deallocate(globalderivatives)
        if(allocated(globalparameters)) deallocate(globalparameters)
        
C--PASS THROUGH THE MATRIX
        M11=L11
        DO I=L12B,M12B,MD12B                 !PROCESS BLOCK BY BLOCK
          M=ISTORE(I)
          N=ISTORE(I+1)
          L=M+N-1           

          ! Get block size and allocate array
          if(L-M+1>0) then
            if(allocated(derivatives)) deallocate(derivatives)
            allocate(derivatives(L-M+1))
            derivatives=0.0d0
            if(allocated(parameters)) deallocate(parameters)
            allocate(parameters(L-M+1))
            parameters=0
            iblockindex=0
            ! extend globalderivatives by the size of the current block
            if(allocated(globalderivatives)) then
              call move_alloc(globalderivatives, temp)
              allocate(globalderivatives(size(temp)+L-M+1))
              globalderivatives(1:size(temp))=temp
              globalderivatives(size(temp)+1:)=0
              deallocate(temp)
              call move_alloc(globalparameters, itemp)
              allocate(globalparameters(size(itemp)+L-M+1))
              globalparameters(1:size(itemp))=itemp
              globalparameters(size(itemp)+1:)=0
              deallocate(itemp)
            else
              allocate(globalderivatives(L-M+1))
              allocate(globalparameters(L-M+1))
            end if
          end if

          DO J=M,L  !PASS THROUGH THE PARAMETERS IN THIS BLOCK
            iblockindex=iblockindex+1
            IF(ISTORE(M16) .NE. J) THEN             !Not this one.
               !IF (MATLAB.GT.0) WRITE(NCFPU1,'(''0.0 ...'')')
            ELSE                                    !Parameter is in queue
              A=STORE(M16+1)*C
              derivatives(iblockindex)=STORE(M16+1)
              parameters(iblockindex)=ISTORE(M16)
              if(.not. calconly) then
C--ADD INTO THE R.H.S.
                M11R=L11R+J-1
                STR11(M11R)=STR11(M11R)+A*D

c                WRITE(CMON,'(A,2G12.5,I12)')
c     1          'Rest: J,A*D,M11R: ',J,A*D,M11R
c                CALL XPRVDU(NCVDU,1,0)

                IF(JK.LT.0) THEN       !The L.H.S is required.
                  DO K=M16,M16Q,MD16Q      !Inner loop through remaining params
                    IF (ISTORE(K).GT.L) EXIT    !Param not in this block
                    M11R=M11+ISTORE(K)-J        !Add contribution
                    STR11(M11R)=STR11(M11R)+A*STORE(K+1)
                  END DO
                END IF
              end if
                 
              N16=N16-MD16Q
              IF(N16.LE.0)THEN                 !No more derivatives.
                if(.not. skipderivatives) then
                  ! append data into globalderivatives
                  globalderivatives(
     1              size(globalderivatives)-size(derivatives)+1:)=
     1              derivatives
                  globalparameters(
     1              size(globalderivatives)-size(parameters)+1:)=
     1              parameters
                     
                  ! append current line of the design matrix in its block
                  if(allocated(
     1              restraints_list(
     1              subrestraints_parent(ioldrestraint))%subrestraints
     1              )) then

                    associate( subrestraint => 
     1                restraints_list(
     1                subrestraints_parent(ioldrestraint))%
     1                subrestraints(isubrestraint) )
     
                      call extend( subrestraint%blocks )
                      associate( newblock => subrestraint%blocks(
     1                  ubound(subrestraint%blocks,1)) )

                       allocate(newblock%derivatives(size(derivatives)))
                        newblock%derivatives=derivatives
                        newblock%weight=sign(SQRT(ABS(C)),C)
                        allocate(newblock%parameters(size(parameters)))
                        newblock%parameters=parameters

                      end associate
                    end associate
                  end if
                end if
                GOTO 1800
              ENDIF
              M16=M16+MD16Q
            END IF
            M11=M11+N
            N=N-1
          END DO ! end of current block

          if(.not. skipderivatives) then
            ! append data into globalderivatives
            globalderivatives(
     1        size(globalderivatives)-size(derivatives)+1:)=derivatives
            globalparameters(
     1        size(globalderivatives)-size(parameters)+1:)=parameters
                      
            ! append current line of the design matrix in its block
            if(allocated(
     1        restraints_list(subrestraints_parent(ioldrestraint))%
     1        subrestraints)) then

              associate( subrestraint => 
     1          restraints_list(subrestraints_parent(ioldrestraint))%
     1          subrestraints(isubrestraint) )
     
                call extend( subrestraint%blocks )
                associate( newblock => subrestraint%blocks(
     1            ubound(subrestraint%blocks,1)) )

                  allocate( newblock%derivatives(size(derivatives)) )     
                  newblock%derivatives=derivatives     
                  newblock%weight=sign(SQRT(ABS(C)),C)
                  allocate( newblock%parameters(size(parameters)) )     
                  newblock%parameters=parameters     
                end associate
              end associate
            end if
          end if 

        END DO ! all blocks processed
           
1800    CONTINUE
        
        ! append global line of the design matrix in block zero
        if(.not. skipderivatives) then
          if(allocated(
     1       restraints_list(subrestraints_parent(ioldrestraint))%
     1       subrestraints) .and. allocated(globalderivatives)) then

             associate( blocks => 
     1         restraints_list(subrestraints_parent(ioldrestraint))%
     1         subrestraints(isubrestraint)%blocks )
     
               allocate( blocks(0)%derivatives(size(globalderivatives)))
               blocks(0)%derivatives=globalderivatives
               blocks(0)%weight=sign(SQRT(ABS(C)),C)
               allocate( blocks(0)%parameters(size(globalparameters)))
               blocks(0)%parameters=globalparameters
             end associate
          end if
        end if
     
        if(sfls_punch_flag>0 .and. allocated(globalderivatives)) then
            call sfls_punch_addtodesign(
     1          reshape(globalderivatives*sign(SQRT(ABS(C)),C), 
     2              (/size(globalderivatives), 1/) ),
     1          reshape( (/0,0,0/), (/3,1/) ), sfls_punch_flag )
            deallocate(globalderivatives)
        end if        
C--FIND THE ADDRESS OF THE LENGTH OF THE NEXT ENTRY
        M16Q=M16Q+MD16Q
C--FIND THE LENGTH OF THE NEXT ENTRY
        N16=ISTORE(M16Q)

      GOTO 1200


C--OUTPUT THE NEW MATRIX
1850  CONTINUE
      if(.not. calconly) then
        STORE(L11P+16)=STORE(L11P+16)+STORE(L11P+27)
        STORE(L11P+17)=STORE(L11P+17)+STORE(L11P+28)
        CALL XCL11(16)
        CALL XMKOWF(11,0)
        CALL XALTES(11,1)
      end if

      if(sfls_punch_flag>0) then
        call sfls_punch_addtodesign(
     1    reshape((/0.0d0/), (/1,1/)), 
     1    reshape( (/0,0,0/), (/3,1/) ), sfls_punch_flag, punch=.true.)
        call sfls_punch_addtowdf(D, sfls_punch_flag, punch=.true.)
      end if       

      RETURN
C
9900  CONTINUE
C -- ERRORS
      RETURN
C
      END

!> \brief derivatives against each adp variable U11, U12,... in oriented cartesian space
!!
!! ## derivatives against each adp variable \f$U_{11}\f$, \f$U_{12}\f$... ##
!! \f$\mathbf{U_\text{cif}}\f$ is what crystals stores for U (same as cif file) \n
!! 1. First \f$\mathbf{U_\text{cif}}\f$ scaled to \f$\mathbf{U^*}\f$ using \f$\mathbf{B}\f$ (See: Acta Cryst. (2011). A67, 383-390, https://doi.org/10.1107/S0108767311018216) \n
!! 2. Changes \f$\mathbf{U^*}\f$ from crystal coordinate to Cartesian coordinates using \f$\mathbf{A}\f$ \n
!! 3. Rotate adp align principal axis with choice of axis using \f$\mathbf{R}\f$ \n
!! \f[ 
!!      \mathbf{U_\text{cart}} = \mathbf{R} \mathbf{A} \mathbf{B} \mathbf{U_\text{cif}} \mathbf{B}^t \mathbf{A}^t \mathbf{R}^t 
!! \f]
!!
!! Derivative is then (with \f$U_{xy}\f$ an element of \f$\mathbf{U}\f$):
!!   \f{align}{
!!        \mathbf{U_{\text{cart}}} &= \mathbf{R} \mathbf{A} \mathbf{B} \mathbf{U_\text{cif}} \mathbf{B}^t \mathbf{A}^t \mathbf{R}^t  \\ 
!!        \frac{\partial (\mathbf{U_{cart}})}{\partial U_\text{xy}} &= \frac{\partial (\mathbf{R} \mathbf{A} \mathbf{B} \mathbf{U_\text{cif}} \mathbf{B}^t \mathbf{A}^t \mathbf{R}^t)}{\partial U_\text{xy}}  \\ 
!!                          &=  \mathbf{R} \mathbf{A} \mathbf{B} \frac{\partial\mathbf{U_\text{cif}}}{\partial U_\text{xy}} \mathbf{B}^t \mathbf{A}^t \mathbf{R}^t  
!!   \f}
!!
!! \f$\sfrac{\partial\mathbf{U_{cif}}}{\partial U_{xy}}\f$ are defined as:
!! \f{align*}{
!!        \sfrac{\partial(\mathbf{U_\text{cif}})}{\partial U_{11}} &= \begin{pmatrix} 1 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 0 \end{pmatrix} \\\\
!!        \sfrac{\partial(\mathbf{U_\text{cif}})}{\partial U_{12}} &= \begin{pmatrix} 0 & 1 & 0 \\ 1 & 0 & 0 \\ 0 & 0 & 0 \end{pmatrix} \\\\
!!        &\vdots \\\\
!!        \sfrac{\partial(\mathbf{U_\text{cif}})}{\partial U_{33}} &= \begin{pmatrix} 0 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 1 \end{pmatrix} 
!! \f}
!!
!! Now let's use fancy math to reduce the use of loops and matrix operations.
!! See Acta Cryst. (2011). A67, 383-390, https://doi.org/10.1107/S0108767311018216 again for vec operator
!!
!! Let \f$\vec{\cdot}\f$ be the \textit{vec} operator, then \f$ \vec{\mathbf{U}} = [ U_{11}, U_{21}, U_{31}, U_{12}, U_{22}, U_{32}, U_{13}, U_{23}, U_{33} ] \f$ (the columns of \f$\mathbf{U}\f$ are stacked in one vector). \n
!! We can rewrite equation 1 to \f$(\mathbf{R} \mathbf{A} \mathbf{B}) \otimes (\mathbf{R} \mathbf{A} \mathbf{B}) \vec{\mathbf{U}}_\text{cif}\f$ with \f$\otimes\f$ the kronecker operator \n
!! similarly for the derivative: 
!! \f[
!!   \frac{\partial (\vec{\mathbf{U}}_\text{cart})}{\partial U_\text{xy}} = (\mathbf{R} \mathbf{A} \mathbf{B}) \otimes (\mathbf{R} \mathbf{A} \mathbf{B}) \frac{\partial\vec{\mathbf{U}}_\text{cif}}{\partial U_\text{xy}} 
!! \f]
!! 
!! All the derivatives vectors are stacked to form a 2D matrix. this enable the calculation of all the derivatives in one call to a matrix multiplication,
!! \f[
!!   \partial\mathbf{U}_{\text{cif:} \vec{11}, \vec{22}, \vec{33}, \vec{23}, \vec{13}, \vec{12}} =  
!!   \begin{matrix}
!!     \frac{\partial (\vec{\mathbf{U}}_\text{cif})}{\partial U_\text{11}} & 
!!     \frac{\partial (\vec{\mathbf{U}}_\text{cif})}{\partial U_\text{22}} & 
!!     \frac{\partial (\vec{\mathbf{U}}_\text{cif})}{\partial U_\text{33}} & 
!!     \frac{\partial (\vec{\mathbf{U}}_\text{cif})}{\partial U_\text{23}} & 
!!     \frac{\partial (\vec{\mathbf{U}}_\text{cif})}{\partial U_\text{13}} & 
!!     \frac{\partial (\vec{\mathbf{U}}_\text{cif})}{\partial U_\text{12}} \\\\
!!
!!     1  &  0  &  0  &  0  &  0  &  0  \\\\
!!     0  &  0  &  0  &  0  &  0  &  1  \\\\
!!     0  &  0  &  0  &  0  &  1  &  0  \\\\
!!     0  &  0  &  0  &  0  &  0  &  1  \\\\
!!     0  &  1  &  0  &  0  &  0  &  0  \\\\
!!     0  &  0  &  0  &  1  &  0  &  0  \\\\
!!     0  &  0  &  0  &  0  &  1  &  0  \\\\
!!     0  &  0  &  0  &  1  &  0  &  0  \\\\
!!     0  &  0  &  1  &  0  &  0  &  0  
!!  \end{matrix}
!! \f]
!!
!! The final derivatives are obtained:
!!
!! \f[
!!   \partial\mathbf{U}_{\text{cart:} \vec{11}, \vec{22}, \vec{33}, \vec{23}, \vec{13}, \vec{12}}  = (\mathbf{R} \mathbf{A} \mathbf{B}) \otimes (\mathbf{R} \mathbf{A} \mathbf{B}) \partial\mathbf{U}_{\text{cif:} \vec{11}, \vec{22}, \vec{33}, \vec{23}, \vec{13}, \vec{12}} 
!! \f]
!!
      subroutine rabubar_derivs(R_M, RAB, dUcart)
      implicit none
      double precision, dimension(3,3), intent(in) :: R_M !< Rotation matrix orienting the principal axes of the adps
      double precision, dimension(9,6), intent(out) :: dUcart !< New derivatives of the adps in the new coordinate system
      double precision, dimension(3,3), intent(out) :: RAB !< transformation matrix
      
      INCLUDE 'XLST01.INC'
      INCLUDE 'STORE.INC'
      double precision, dimension(9,6) :: dUcif
      double precision, dimension(3,3) :: A_M, B_M
      double precision, dimension(9,9) :: kRAB

      ! no idea why it is necessary, maybe because of array shapes
      interface
          subroutine kronecker(k, a, b)
          ! calculate the kronecker product of a and b
          implicit none
          double precision, dimension(:,:), intent(in)  :: a, b
          double precision, dimension(:,:), intent(out) :: k
          end subroutine
      end interface
                    
            dUcif=0.0d0
            dUcif(1,1)=1.0d0 ! dU11
            dUcif(5,2)=1.0d0 ! dU22
            dUcif(9,3)=1.0d0 ! dU33
            dUcif(6,4)=1.0d0 ! dU23
            dUcif(8,4)=1.0d0 ! dU23
            dUcif(3,5)=1.0d0 ! dU13
            dUcif(7,5)=1.0d0 ! dU13
            dUcif(2,6)=1.0d0 ! dU12
            dUcif(4,6)=1.0d0 ! dU12
                    
            ! Ucif scaled to U*
            B_M=0.0d0
            B_M(1,1)=STORE(L1P2)
            B_M(2,2)=STORE(L1P2+1)
            B_M(3,3)=STORE(L1P2+2)
                           
            ! Orthogonalisation matrix (stored by rows, reshape fill column wise, hence the transpose)
            A_M=transpose(reshape(STORE(L1O1:L1O1+8), (/3,3/)))
             
            ! Calculation of all derivatives using the vec operator trick      
            RAB=matmul(matmul(R_M ,A_M), B_M)
            call kronecker(kRAB, RAB, RAB)
                          
            dUcart=matmul(kRAB, dUcif)

      end subroutine


!!
!! \f[
!!   \partial\mathbf{U}_{\text{cart:} \vec{11}, \vec{22}, \vec{33}, \vec{23}, \vec{13}, \vec{12}}  = (\mathbf{R} \mathbf{A} \mathbf{B}) \otimes (\mathbf{R} \mathbf{A} \mathbf{B}) \partial\mathbf{U}_{\text{cif:} \vec{11}, \vec{22}, \vec{33}, \vec{23}, \vec{13}, \vec{12}} 
!! \f]
!!
      subroutine rabubar_eigenderivs(Q_M, dUcart)
      implicit none
      double precision, dimension(3,3), intent(in) :: Q_M !< Eigenvectors
      double precision, dimension(9,6), intent(out) :: dUcart !< New derivatives of the adps in the new coordinate system
      double precision, dimension(3,3) :: left !< transformation matrix
      
      INCLUDE 'XLST01.INC'
      INCLUDE 'STORE.INC'
      double precision, dimension(9,6) :: dUcif
      double precision, dimension(3,3) :: A_M, B_M
      double precision, dimension(9,9) :: kRAB

      ! no idea why it is necessary, maybe because of array shapes
      interface
          subroutine kronecker(k, a, b)
          ! calculate the kronecker product of a and b
          implicit none
          double precision, dimension(:,:), intent(in)  :: a, b
          double precision, dimension(:,:), intent(out) :: k
          end subroutine
      end interface
                    
            dUcif=0.0d0
            dUcif(1,1)=1.0d0 ! dU11
            dUcif(5,2)=1.0d0 ! dU22
            dUcif(9,3)=1.0d0 ! dU33
            dUcif(6,4)=1.0d0 ! dU23
            dUcif(8,4)=1.0d0 ! dU23
            dUcif(3,5)=1.0d0 ! dU13
            dUcif(7,5)=1.0d0 ! dU13
            dUcif(2,6)=1.0d0 ! dU12
            dUcif(4,6)=1.0d0 ! dU12
                    
            ! Ucif scaled to U*
            B_M=0.0d0
            B_M(1,1)=STORE(L1P2)
            B_M(2,2)=STORE(L1P2+1)
            B_M(3,3)=STORE(L1P2+2)
                           
            ! Orthogonalisation matrix (stored by rows, reshape fill column wise, hence the transpose)
            A_M=transpose(reshape(STORE(L1O1:L1O1+8), (/3,3/)))
             
            ! Calculation of all derivatives using the vec operator trick      
            left=matmul(matmul(transpose(Q_M) ,A_M), B_M)
            call kronecker(kRAB, left, left)
                          
            dUcart=matmul(kRAB, dUcif)

      end subroutine
      
* ----------------------------------------------------------------------------
* Numerical diagonalization of 3x3 matrcies
* Copyright (C) 2006  Joachim Kopp
* ----------------------------------------------------------------------------
* This library is free software; you can redistribute it and/or
* modify it under the terms of the GNU Lesser General Public
* License as published by the Free Software Foundation; either
* version 2.1 of the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public
* License along with this library; if not, write to the Free Software
* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
* ----------------------------------------------------------------------------


* ----------------------------------------------------------------------------
      SUBROUTINE DSYEVJ3(A, Q, W)
* ----------------------------------------------------------------------------
* Calculates the eigenvalues and normalized eigenvectors of a symmetric 3x3
* matrix A using the Jacobi algorithm.
* The upper triangular part of A is destroyed during the calculation,
* the diagonal elements are read but not destroyed, and the lower
* triangular elements are not referenced at all.
* ----------------------------------------------------------------------------
* Parameters:
*   A: The symmetric input matrix
*   Q: Storage buffer for eigenvectors
*   W: Storage buffer for eigenvalues
* ----------------------------------------------------------------------------
*     .. Arguments ..
      DOUBLE PRECISION A(3,3)
      DOUBLE PRECISION Q(3,3)
      DOUBLE PRECISION W(3)

*     .. Parameters ..
      INTEGER          N
      PARAMETER        ( N = 3 )
    
*     .. Local Variables ..
      DOUBLE PRECISION SD, SO
      DOUBLE PRECISION S, C, T
      DOUBLE PRECISION G, H, Z, THETA
      DOUBLE PRECISION THRESH
      INTEGER          I, X, Y, R

*     Initialize Q to the identitity matrix
*     --- This loop can be omitted if only the eigenvalues are desired ---
      DO 10 X = 1, N
        Q(X,X) = 1.0D0
        DO 11, Y = 1, X-1
          Q(X, Y) = 0.0D0
          Q(Y, X) = 0.0D0
   11   CONTINUE
   10 CONTINUE

*     Initialize W to diag(A)
      DO 20 X = 1, N
        W(X) = A(X, X)
   20 CONTINUE

*     Calculate SQR(tr(A))  
      SD = 0.0D0
      DO 30 X = 1, N
        SD = SD + ABS(W(X))
   30 CONTINUE
      SD = SD**2
 
*     Main iteration loop
      DO 40 I = 1, 50
*       Test for convergence
        SO = 0.0D0
        DO 50 X = 1, N
          DO 51 Y = X+1, N
            SO = SO + ABS(A(X, Y))
   51     CONTINUE
   50   CONTINUE
        IF (SO .EQ. 0.0D0) THEN
          RETURN
        END IF

        IF (I .LT. 4) THEN
          THRESH = 0.2D0 * SO / N**2
        ELSE
          THRESH = 0.0D0
        END IF

*       Do sweep
        DO 60 X = 1, N
          DO 61 Y = X+1, N
            G = 100.0D0 * ( ABS(A(X, Y)) )
            IF ( I .GT. 4 .AND. ABS(W(X)) + G .EQ. ABS(W(X))
     $                    .AND. ABS(W(Y)) + G .EQ. ABS(W(Y)) ) THEN
              A(X, Y) = 0.0D0
            ELSE IF (ABS(A(X, Y)) .GT. THRESH) THEN
*             Calculate Jacobi transformation
              H = W(Y) - W(X)
              IF ( ABS(H) + G .EQ. ABS(H) ) THEN
                T = A(X, Y) / H
              ELSE
                THETA = 0.5D0 * H / A(X, Y)
                IF (THETA .LT. 0.0D0) THEN
                  T = -1.0D0 / (SQRT(1.0D0 + THETA**2) - THETA)
                ELSE
                  T = 1.0D0 / (SQRT(1.0D0 + THETA**2) + THETA)
                END IF
              END IF

              C = 1.0D0 / SQRT( 1.0D0 + T**2 )
              S = T * C
              Z = T * A(X, Y)
              
*             Apply Jacobi transformation
              A(X, Y) = 0.0D0
              W(X)    = W(X) - Z
              W(Y)    = W(Y) + Z
              DO 70 R = 1, X-1
                T       = A(R, X)
                A(R, X) = C * T - S * A(R, Y)
                A(R, Y) = S * T + C * A(R, Y)
   70         CONTINUE
              DO 80, R = X+1, Y-1
                T       = A(X, R)
                A(X, R) = C * T - S * A(R, Y)
                A(R, Y) = S * T + C * A(R, Y)
   80         CONTINUE
              DO 90, R = Y+1, N
                T       = A(X, R)
                A(X, R) = C * T - S * A(Y, R)
                A(Y, R) = S * T + C * A(Y, R)
   90         CONTINUE

*             Update eigenvectors
*             --- This loop can be omitted if only the eigenvalues are desired ---
              DO 100, R = 1, N
                T       = Q(R, X)
                Q(R, X) = C * T - S * Q(R, Y)
                Q(R, Y) = S * T + C * Q(R, Y)
  100         CONTINUE
            END IF
   61     CONTINUE
   60   CONTINUE
   40 CONTINUE

      PRINT *, "DSYEVJ3: No convergence."
            
      END SUBROUTINE
* End of subroutine DSYEVJ3

