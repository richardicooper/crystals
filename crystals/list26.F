C $Log: list26.F,v $
C Revision 1.27  2013/12/11 16:54:14  rich
C Some mismatched subroutine argument lengths following previous update.f
C
C Revision 1.26  2013/12/08 20:32:26  rich
C Ensure IASYM is passed throughout required routines. Thanks Pascal.
C
C Revision 1.25  2013/11/06 13:52:52  rich
C Fix use of uninit variable
C
C Revision 1.24  2013/09/19 21:35:39  rich
C Change precision of listing output where not important to reduce differences across platforms.
C Important changes - SFLS now uses builtin cos() and sin() functions rather than Chebyshev
C approximations.
C
C Revision 1.23  2012/11/09 15:05:00  rich
C *** empty log message ***
C
C Revision 1.22  2012/08/29 09:53:57  djw
C New format for listing Derivatives
C Values of Uij taken directly from input rather than be computed from derived parameters
C
C Revision 1.21  2012/07/11 14:07:01  djw
C remove debugging prints
C
C Revision 1.20  2011/10/14 13:48:09  djw
C Fix interaction between A-DIST and MEAN and DiIFF restraints
C
C Revision 1.19  2011/10/13 14:41:31  djw
C Add asymmetric distacne restraint
C
C Revision 1.18  2011/09/30 11:20:39  djw
C Add asymmetric vib and Uij restraints
C
C Revision 1.17  2011/05/04 11:28:51  rich
C TODO note.
C
C Revision 1.16  2011/03/21 13:57:21  rich
C Update files to work with gfortran compiler.
C
C Revision 1.15  2010/10/26 09:51:24  djw
C Sort out more writes to NCAWU, provide more output from EXEC directive
C
C Revision 1.14  2009/06/17 13:41:49  djw
C Fix #CHECK HI crash.  Actual error was in wrong values for idjw1 & idjw2 for DELU
C  restraint in LIST 16.  Several messages cleaned up, more diagnostics for error conditions.
C
C Revision 1.13  2005/01/23 08:29:11  rich
C Reinstated CVS change history for all FPP files.
C History for very recent (January) changes may be lost.
C
C Revision 1.2  2004/12/13 16:16:08  rich
C Changed GIL to _GIL_ etc.
C
C Revision 1.1.1.1  2004/12/13 11:16:09  rich
C New CRYSTALS repository
C
C Revision 1.12  2004/03/25 10:16:56  rich
C Fix bug in FORMAT statement when #CHECKing an 'AVERAGE' restraint on
C layer scale factors. Obscure.
C
C Revision 1.11  2003/03/20 16:11:28  rich
C Fix. I accidentally removed a GOTO when clearing out NCAWU writes the other
C week... with disasterous consquences for anyone typing #CHECK.
C
C Revision 1.10  2003/02/26 12:13:27  rich
C Removed some writes to the monitor file, as part of an
C ongoing (quite boring) project.
C
C Revision 1.9  2002/12/05 11:51:51  rich
C Things look better without the debugging messages.
C
C Revision 1.8  2002/12/04 14:31:11  rich
C Reformat output during refinement.
C
C Allow punching to MATLAB files, including restraints.
C
C Tidy some routines.
C
C Revision 1.7  2002/12/02 15:48:54  rich
C XADCPD was looking at PUNCH YES/NO, should have been looking at MATRIX OLD/NEW
C in LIST 33.
C
C Revision 1.6  2001/02/26 10:28:01  richard
C RIC: Added changelog to top of file
C
C
CODE FOR XCHK16
      SUBROUTINE XCHK16
C--CHECK THE VALUES OF THE APPLIED RESTRAINTS
C
C  THIS SUBROUTINE READS DOWN THE LIST 26 AND CALCULATES THE
C  REQUIRED RESTRAINTS.
C
C--THE COMMON BLOCK 'XCNTRL' CONTROLS THE FORMAT OF THE
C  INFORMATION OUTPUT TO THE DISC. WHILE THE LIST IS STILL IN
C  CORE, THE VARIABLES HAVE THE FOLLOWING SIGNIFICANCE :
C
C  LC      BASE ADDRESS OF THE WORK STACK, WHICH HOLDS CONSTANTS
C          AND VARIABLES GENERATED BY THE CODE.
C          THIS VARIABLE SET UP DYNAMICALLY BOTH DURING SYNTAX
C          ANALYSIS AND DURING EXECUTION, AND IS THUS NOT OUTPUT TO
C          DISC.
C  ISTAT2  THIS IS A PRINT CONTROL FLAG :
C
C          -1  PRINT THE CARD IMAGES AS THEY ARE PROCESSED.
C           0  NO PRINTING.
C          +1  PRINT THE CARD IMAGES AND THE GENERATED CODE.
C
C
C      IASYM ASYMMETRIC RESTRAINT
C           1 ASYMMETRYIC
C           0 NORMAL
C
C--THE REMAINING 12 WORDS OF THIS COMMON BLOCK ARE OUTPUT TO THE
C  DISC AND DEFINE THE LOCATIONS AND LENGTH OF THE REMAINING BLOCKS
C  ASSOCIATED WITH THIS INSTRUCTION. IN CORE THE FORMAT OF THIS CONTROL
C  BLOCK IS :
C
C  LCG   ADDRESS IN CORE OF THE HEADER BLOCK FOR THE GENERAL CHAIN.
C        FOR OUTPUT PRODUCED BY THE PARSE ROUTINES, THIS CHAIN CONTAINS
C        ONLY INSTRUCTIONS OR CODE. IN OTHER CASES THE CONTENTS
C        OF THE CHAIN ARE DEFINED BY THE FUNCTION OF THE ROUTINE
C        THAT SET IT UP.
C        (ON THE DISC, THIS VARIABLE IS STORED RELATIVE TO 'LCG',
C        THAT IS AS ZERO).
C  MCG   CURRENT ADDRESS IN CORE OF THE NEXT FREE WORD FOR THE GENERAL,
C        PARAMETER HEADER AND CONSTANT CHAINS. THESE CHAINS MOVE UP THE
C        STORE AND MUST UPDATE 'MCG' AS THEY DO SO.
C  MDCG  CURRENT ADDRESS IN CORE OF THE LAST GENERAL (OR INSTRUCTION)
C        BLOCK INSERTED.
C  NCG   NOT DEFINED.
C        (ON THE DISC, THIS VARIABLE IS SET TO THE TOTAL LENGTH
C        OF ALL THE CHAINS FORMED AT THE BOTTOM OF CORE  -  THE
C        GENERAL, PARAMETER AND CONSTANT CHAINS).
C
C  LCA   ADDRESS IN CORE OF THE FIRST BLOCK ON THE PARAMETER HEADER
C        BLOCK CHAIN.
C        (ON THE DISC, THIS VARIABLE IS STORED WITH ITS ADDRESS
C        SET RELATIVE TO 'LCG').
C  MCA   USED TO PROCESS THE PARAMETER HEADER BLOCK CHAIN.
C  MDCA  USED TO PROCESS THE PARAMETER HEADER BLOCK CHAIN.
C  NCA   NUMBER OF PARAMETER HEADER BLOCKS ON THE CHAIN.
C
C  LCS   ADDRESS IN CORE OF THE CONSTANT AND WORK STACK HEADER BLOCK.
C        (ON THE DISC, THIS VARIABLE IS STORED WITH ITS ADDRESS
C        SET RELATIVE TO 'LCG').
C  MCS   CURRENT ADDRESS OF THE LAST BLOCK INSERTED ON THE CONSTANT
C        CHAIN. THIS MUST BE UPDATED WHEN A NEW BLOCK IS ADDED.
C  MDCS  NEXT FREE ADDRESS IN THE WORK STACK. THIS STACK STARTS AT
C        'LC' AND COMES DOWN THE STORE.
C        (THIS PARAMETER SHOULD BE UPDATED WHENEVER SPACE IS
C        ALLOCATED IN THE WORK STACK).
C
C--DURING ALL OPERATIONS EXCEPT PARSING BY 'KPARSE', THE NEXT FREE
C  LOCATION IS STORED IN 'MCG' AND THE LAST FREE LOCATION IS HELD IN 'LF
C
C--FORMAT OF THE GENERAL CHAIN HEADER BLOCK IS :
C
C  0  ADDRESS OF THE FIRST BLOCK ON THE CHAIN REL. TO 'LCG' OR 'NOWT'.
C  1  TYPE OF OPERATION DESCRIBED BY THIS HEADER BLOCK AND ALL THE
C     OTHER HEADER BLOCKS DEFINED BY THE CONTROL BLOCK.
C  2  NOT DEFINED  -  FOR RESTRAINTS MAY BE A WORK STACK ADDRESS REL.
C                     TO 'LC'..
C  3  NOT DEFINED  -  FOR RESTRAINTS THE WEIGHT.
C  4  NOT DEFINED  -  FOR RESTRAINTS THE INPUT OR OBSERVED VALUE.
C
C--THE FORMAT OF THE INSTRUCTION BLOCKS ON THE CHAIN IS :
C
C  0  ADDRESS OF THE NEXT BLOCK RELATIVE TO 'LCG' OR 'NOWT'.
C  1  FUNCTION OF THIS BLOCK.
C  2  ADDRESS IN THE WORK STACK RELATIVE TO 'LC'  -  OPERAND 1.
C  3  ADDRESS IN THE WORK STACK RELATIVE TO 'LC'  -  OPERAND 2.
C  4  ADDRESS IN THE WORK STACK RELATIVE TO 'LC'  -  THE RESULT.
C
C--THE TERMS IN WORDS 2, 3 AND 4 ARE THOSE SET UP BY THE PARSE ROUTINES,
C  AND THE ADDRESSES ARE CONVERTED TO ABSOLUTE VALUES BY 'KLOADR' WHEN
C  THE INFORMATION IS READ BACK FROM THE DISC.
C  THE FORMAT OF THE BLOCK BEYOND WORD 4 IS NOT DEFINED, AND THESE
C  LOCATIONS MAY BE USED AS REQUIRED.
C
C--THE PARAMETER HEADER BLOCKS ARE DIVIDED INTO THOSE FOR ATOMS
C  AND THOSE FOR OVERALL PARAMETERS. THE FORMAT OF THE FORMER IS
C  AS FOLLOWS :
C
C  0   ADDR. OF NEXT HEADER BLOCK REL. TO LCG OR 'NOWT'
C  1   TYPE OF HEADER BLOCK :
C         0  HEADER BLOCK FOR ONE ATOM
C      1024  HEADER BLOCK FOR THE FIRST ATOM OF AN 'UNTIL' SEQUENCE
C  2   ATOM TYPE
C  3   ATOM SERIAL
C  4   NOT USED
C  5   NUMBER OF PARAMETERS
C  6   ADDR. OF FIRST PARAMETER ENTRY REL. TO 'LCG'
C  7   S
C  8   L
C  9   T(X)
C  10  T(Y)
C  11  T(Z)
C  12  ADDR. OF THIS ATOM IN LIST 5 (NOT SET HERE)
C  13  ADDR. OF THIS ATOM IN LIST 12 (NOT SET HERE)
C  14  NOT USED
C  15  ADDR. OF GENERATED PARAMETERS IN WORK STACK REL. TO 'LC'
C  16  ADDR. OF PARAMETERS TO BE USED IN WORK STACK REL. TO 'LC'
C
C--FOR EACH PARAMETER :
C
C  0   LINK TO NEXT PARAMETER REL. TO 'LCG' OR 'NOWT'.
C  1   REL. ADDR. IN LIST 5 (X=5, FOR EXAMPLE).
C  2   PARTIAL DERIVATIVE WHEN CALCULATED.
C  .
C
C--THE INFORMATION FOR EACH OVERALL PARAMETER ALSO CONSISTS OF A HEADER
C  WITH THE SPECIFIED PARAMETER GIVEN AS THE COORDINATE ON THE CHAIN AT
C  WORD 6.
C
C  0   ADDR. OF NEXT HEADER BLOCK REL. TO 'LCG' OR 'NOWT'.
C  1   TYPE :
C      1  OVERALL PARAMETER
C      2  LAYER SCALE
C      3  ELEMENT SCALE
C  2   THE POSITION OF THE PARAMETER IN ITS GROUP
C  3   0.0
C  4   NOT USED
C  5   THE NUMBER OF PARAMETERS ON THE CHAIN GIVEN AT WORD 6.
C  6   ADDRESS OF THE PARAMETER CHAIN REL. TO 'LCG' (STARTS AT WORD 7).
C  7   'NOWT'  LINK TO THE NEXT PARAMETER ON THE CHAIN
C  8   THE POSITION OF THE PARAMETER IN ITS GROUP (STARTING FROM 1).
C  9   NOT USED
C  10  'NOWT'
C  11  'NOWT'
C  12  ADDR. OF THE GROUP CONTAINING THIS PARAMETER IN LIST 5 ('NOWT')
C  13  ADDR. OF THE GROUP CONTAINING THIS PARAMETER IN LIST 12 ('NOWT'
C  14  NOT USED
C  15  ADDR. OF THE PARAMETER IN THE WORK STACK REL. TO 'LC'
C  16  ADDR. OF THE SPACE TO BE USED IN THE WORK STACK REL. TO 'LC'
C
C--THE FORMAT OF THE CONSTANT AND WORK STACK HEADER IS :
C
C  0  ADDRESS OF THE NEXT CONSTANT OR WORK STACK HEADER RELATIVE
C     TO 'LCG' OR 'NOWT'.
C  1  LENGTH OF THIS BLOCK (=6)
C  2  ADDRESS AT WHICH THE WORK STACK BEGINS REL. TO 'LC' OR 'NOWT'
C  3  NUMBER OF WORDS REQUIRED FOR THE WORK STACK.
C  4  ADDRESS OF THE FIRST CONSTANT BLOCK ON THE CONSTANT CHAIN REL. TO
C     'LCG' OR 'NOWT'.
C  5  NUMBER OF CONSTANTS ON THE CONSTANT CHAIN.
C
C--THE FORMAT OF THE CONSTANT CHAIN IS :
C
C  0  ADDRESS OF THE NEXT CONSTANT BLOCK RELATIVE TO 'LCG' OR 'NOWT'
C  1  ADDRESS OF THIS CONSTANT IN THE WORK STACK RELATIVE TO 'LC'.
C  2  THE VALUE TO BE PLACED IN THE WORK STACK.
C
C--THE COMPUTED DERIVATIVES ARE OUTPUT IN A CHAINED LIST TO
C  THE DISC, UNDER THE CONTROL OF THE 'L22PD' VARIABLES. THE VARIABLES
C  ARE USED AS FOLLOWS :
C
C  L22PD   THE ADDRESS OF THE STACK OF OUTPUT PARTIAL DERIVATIVES.
C  M22PD   THE CURRENT OUTPUT DISC ADDRESS.
C  MD22PD  THE NUMBER OF WORDS PER P.D. (=2).
C  N22PD   THE LENGTH OF THE CURRENT P.D. STACK ON DISC.
C
C--THE FORMAT OF THE STACK IS :
C
C  ISTORE(L22PD  )  LENGTH OF THE ENTRY
C   STORE(L22PD+1)  WEIGHT
C   STORE(L22PD+2)  CALC. DELTA
C   STORE(L22PD+3)  OBSERVED VALUE SQUARED
C
C  ISTORE(L22PD+4)  PARAMETER 1
C   STORE(L22PD+5)  P. D. FOR PARAMETER 1
C  .
C  .
C
C----- COMMAND FILE SWITCHES
C
C   1.DEFINE         2.RESTRAIN       3.DISTANCES      4.ANGLES
C   5.VIBRATIONS     6.COMPILER       7.EXECUTION      8.NO
C   9.FUNCTION      10.U(IJ)'S       11.TERM          12.EQUATE
C  13.PLANAR        14.SUM           15.FORM          16.AVERAGE
C  17.LIMIT         18.ENERGY        19.ORIGIN
C
C----- ISTORE (LCG + 1) OPERATIONS
C      1  DEFINE    2  RESTRAIN  3  DISTANCE 4
C      5            6  ANGLE     7           8
C      9  VIBRATION 10 EXECUTION 11 NOLIST   12 UIJ
C      13 EQUATE    14 PLANAR    15 SUM      16 FORM
C      17 AVERAGE   18 LIMIT     19 ENERGY   20 ORIGIN
C
C      21 UXZBAR    22 UYZBAR    23 UZZBAR
C--
C
      CHARACTER *24 CTEXT
      DIMENSION A1(3)
      INTEGER DIST, ANGLE, STROM, DEG
      DIMENSION DIST(3),ANGLE(3),MSD(3),STROM(2),DEG(2)
      INTEGER UIJ, CONT
      DIMENSION UIJ(3), CONT(3)
      DIMENSION KF1(1),IQ1(1),IB1(1)
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XLST02.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST12.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XAPK.INC'
      INCLUDE 'XOPK.INC'
      INCLUDE 'XSCALE.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (KF,KF1(1)),(IQ,IQ1(1)),(IB,IB1(1))
C
      DATA IVERSN /404/
C
#if defined(_HOL_) 
      DATA DIST(1)/4Hdist/,DIST(2)/4Hance/,DIST(3)/4Hs   /
      DATA ANGLE(1)/4H ang/,ANGLE(2)/4Hles /,ANGLE(3)/4H    /
      DATA MSD(1)/4H M.S/,MSD(2)/4H.D.'/,MSD(3)/4Hs   /
      DATA STROM(1)/4HAngs/,STROM(2)/4Htrom/
      DATA DEG(1)/4Hdegr/,DEG(2)/4Hees /
      DATA UIJ(1)/4H  U(/,UIJ(2)/4HIJ)'/,UIJ(3)/4Hs   /
      DATA CONT(1)/4Hcont/,CONT(2)/4Hacts/,CONT(3)/4H    /
C
#else
      DATA DIST(1)/'dist'/,DIST(2)/'ance'/,DIST(3)/'s   '/
      DATA ANGLE(1)/' ang'/,ANGLE(2)/'les '/,ANGLE(3)/'    '/
      DATA MSD(1)/' M.S'/,MSD(2)/'.D.'''/,MSD(3)/'s   '/
      DATA STROM(1)/'Angs'/,STROM(2)/'trom'/
      DATA DEG(1)/'degr'/,DEG(2)/'ees '/
      DATA UIJ(1)/'  U('/,UIJ(2)/'IJ)'''/,UIJ(3)/'s   '/
      DATA CONT(1)/'cont'/,CONT(2)/'acts'/,CONT(3)/'    '/
#endif
C
C--INITIATE THE TIMING
      CALL XTIME1(2)
C--READ THE REMAINING CONTROL CARDS
      I=KRDDPV(ISTORE(NFL),1)
      IF ( I .LT. 0 ) GO TO 9910
C----- SET MONITOR LEVEL
      IMON = ISTORE(NFL)
C--WRITE OUT A COUPLE OF CAPTIONS
      CALL XPRTCN
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1000)
1000  FORMAT(26H  Restraints checking  -  ,/,
     2 42H  restraints that produce no contributions,
     3 22H are marked with a '?')
C--CLEAR THE CORE AREA
      CALL XRSL
      CALL XCSAE
C----- LOAD LIST 3 IF IT EXISTS
      KLST3 = -1
        IF (KEXIST(3) .GT. 0) CALL XFAL03
C--LOAD LIST 5
      CALL XFAL05
C--SET UP THE SYSTEM VARIABLES IN CORE
      CALL XLSV
C--LOAD LIST 12
      CALL XFAL12(-1,1,JR,JN)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--LINK LIST 5 AND LIST 12
      I=KSET52(0,-1)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--SET UP THE POINTERS FOR THE DERIVATIVE QUEUE ON DISC
      CALL XIPDQF
C--LOAD THE COMPILED LIST FOR PROCESSING
      IULN=26
      CALL XLCLFP(IULN)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--SET THE CARD NUMBER FLAG
      A=-1.
C--BRING DOWN THE NEXT BLOCK OF CODE AND RELOCATE IT
1050  CONTINUE
      A=A+1.
      NN=1
C--LOAD THE NEXT CARD FOR PROCESSING
      IF(KLOADR(LN))3900,1100,3800
C--JUMP ON THE FUNCTION
1100  CONTINUE
      I=ISTORE(LCG+1)
cdjwsep2011
      if(i .lt. 1) then
       iasym = 1
       i = abs(i)
      else
       iasym = 0
      endif
      M22PD=KNEXTF(L22PD)
C--FETCH THE OBSERVED VALUE AND CALCULATE THE E.S.D.
      B=STORE(LCG+4)
C--CHECK IF WE CAN COMPUTE THE WEIGHT IN THIS CASE
      IF(I-16)1150,1200,1150
C--COMPUTE THE SQUARE ROOT OF THE WEIGHT
1150  CONTINUE
      C=1./SQRT(STORE(LCG+3))
C--SET THE CONVERSION FACTOR
1200  CONTINUE
      CONV=1.
      GOTO(1300,1350,1550,1750,1850,1950,2100,2150,2200,2350,2400,2450,
     2 1050,4000,4300,1050,4400,4370,1710, 5000,5010,5020,5030,1250) ,I
1250  CONTINUE
      CALL XOPMSG (IOPL16, IOPINT, 0)
      GOTO 9900
C
C--'DEFINE' FUNCTION
1300  CONTINUE
      CALL XCDEF
      GOTO 1050
C
C--'RESTRAIN' FUNCTION
1350  CONTINUE
      CALL XCC
      CALL XMOVE(IB1(1),KF1(1),1)
C--CHECK IF ANY DERIVATIVES HAVE BEEN PRODUCED
      IF(ISTORE(L22PD)-4)1450,1400,1450
C--NO DERIVATIVES
1400  CONTINUE
      CALL XMOVE(IQ1(1),KF1(1),1)
C--CALCULATE THE COMPUTED VALUE AND PRINT THE RESULTS
1450  CONTINUE
      D=B-STORE(L22PD+2)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1500)A,B,C,KF,D,STORE(L22PD+2)
1500  FORMAT(//1H ,F4.0,26H  General restraint to be ,E20.10,
     2 19H  with an E.S.D. of,E20.10//2X,A1,2X,18H  Calculated value,
     3 8X,E20.10,19H  giving a delta of,E20.10)
      GOTO 1050
C
C--'SINGLE DISTANCE' RESTRAINTS
1550  CONTINUE
      CALL XCDC(iasym)
      N=2
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1600)A,(DIST(M),M=1,3),B,(STROM(M),M=1,2),C
      ENDIF
1600  FORMAT(/1X,F4.0,' Restrain these ',2A4,A1,' to be',
     2 F9.3,1X,2A4,',',/15X,' with an E.S.D. of',F8.3)
      WRITE(CMON,1610)NINT(A+1), '      given distance', B,C
      CALL XPRVDU(NCVDU, 1,0)
1610  FORMAT(I5, 1X, A, '. ', 'Target ',F7.3, ' esd ', F7.3)
C
C
1650  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1700)(NUMB(M),M=2,3),(DIST(M),M=1,3),(IB,M=1,N)
      ENDIF
1700  FORMAT(/5X,2(7X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ),3X,2A4,A1,
     2 2A1,2X,5HDelta)
      GOTO 2500
C
C
C--'ENERGY ' RESTRAINTS
1710  CONTINUE
      CALL XCEC(iasym)
      N=2
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1720)A,(CONT(M),M=1,3),B,(STROM(M),M=1,2),C
      ENDIF
1720  FORMAT(//1H ,F4.0,16H Restrain these ,2A4,A1,6H to be,
     2 F9.3,1X,2A4,22H, with Power Factor of,F4.1)
      WRITE(CMON,1610)NINT(A+1), ' non-bonded distance', B,C
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 1650
C
C--'DISTANCE DIFFERENCE' RESTRAINTS
1750  CONTINUE
      CALL XCDDC(iasym)
      N=1
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1800)A,(DIST(M),M=1,3),B,(STROM(M),M=1,2),C
      ENDIF
1800  FORMAT(/1X ,F4.0,
     2 '   Restrain the differences between the following ',2A4,A1,
     3 ' to be' /,F9.3,2X,2A4,',',' with an E.S.D. of ',F8.3)
      WRITE(CMON,1610)NINT(A+1), ' distance difference', B,C
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 1650
C
C--'MEAN DISTANCE' RESTRAINT
1850  CONTINUE
      CALL XCMDC(iasym)
      N=2
      B=STORE(LCG+4)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1900)A,(DIST(M),M=1,3),B,(STROM(M),M=1,2),C
      ENDIF
1900  FORMAT(/1H ,F4.0,'   Restrain the following ',2A4,A1,
     2 ' to their common mean of '/,F9.3,
     3 2X,2A4,15X,'with an E.S.D. of', F8.3)
      WRITE(CMON,1610)NINT(A+1), '       mean distance', B,C
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 1650
C
C--'SINGLE ANGLE' RESTRAINTS
1950  CONTINUE
      CALL XCAC
      N=2
      CONV=RTD
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1600)A,(ANGLE(M),M=1,3),B,(DEG(M),M=1,2),C
      ENDIF
      WRITE(CMON,1960)NINT(A+1), '         given angle', B,C
      CALL XPRVDU(NCVDU, 1,0)
1960  FORMAT(I5, 1X, A, '. ', 'Target ',F7.2, ' esd ', F7.2)
C
C
2000  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2050)(NUMB(M),M=2,4),(ANGLE(M),M=1,2),(IB,M=1,N)
      ENDIF
2050  FORMAT(/5X,3(7X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ),3X,A4,A3,2A1,
     2 5HDelta)
      GOTO 2500
C
C--'ANGLE DIFFERENCE' RESTRAINTS
2100  CONTINUE
      CALL XCADC
      N=1
      CONV=RTD
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1800)A,(ANGLE(M),M=1,3),B,(DEG(M),M=1,2),C
      ENDIF
      WRITE(CMON,1960)NINT(A+1), '    angle difference', B,C
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 2000
C
C--'MEAN ANGLE' RESTRAINT
2150  CONTINUE
      CALL XCMAC
      N=2
      B=STORE(LCG+4)
      CONV=RTD
      B=B*CONV
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1900)A,(ANGLE(M),M=1,3),B,(DEG(M),M=1,2),C
      ENDIF
      WRITE(CMON,1960)NINT(A+1), '          mean angle', B,C
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 2000
C
C--'VIBRATION' RESTRAINT
2200  CONTINUE
      CALL XCVC(IASYM)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2250)A,(MSD(M),M=1,3),B,C
      ENDIF
2250  FORMAT(/1X,F4.0,'DELU - Restrain the difference in the',2A4,A1,
     2 ' along a bond to be',/6x,F9.5,
     3 '  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,2260)NINT(A+1), 'Vibration difference', B,C
      CALL XPRVDU(NCVDU, 1,0)
2260  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)

      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2300)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
2300  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500
C
C--'UXZBAR' RESTRAINT
5010  CONTINUE
C To be replaced with JA routine:
      CALL XCVCX(1,IASYM)
      WRITE(*,*)'Hello UXZBar'
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,5011)A,B,C
      ENDIF
5011  FORMAT(/1X,F4.0,
     1 'UXZBAR - Restrain the covariance perp. to X and bond to be '
     2 /6x,F9.5,'  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,5012)NINT(A+1), 'Covariance difference XZ ', B,C
      CALL XPRVDU(NCVDU, 1,0)
5012  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)
      IF (ISSPRT .EQ. 0) THEN
         WRITE(NCWU,5013)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
5013  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500
C
C--'UYZBAR' RESTRAINT
5020  CONTINUE
C To be replaced with JA routine:
      CALL XCVCX(2,IASYM)
      WRITE(*,*)'Hello UYZBar'
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,5021)A,B,C
      ENDIF
5021  FORMAT(/1X,F4.0,
     1'UYZBAR - Restrain the covariance perp to UXZBAR and bond to be '
     2 /6x,F9.5,'  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,5022)NINT(A+1), 'Covariance difference YZ', B,C
      CALL XPRVDU(NCVDU, 1,0)
5022  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)

      IF (ISSPRT .EQ. 0) THEN
         WRITE(NCWU,5023)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
5023  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500

C--'UZZBAR' RESTRAINT
5030  CONTINUE
C To be replaced with JA routine:
      CALL XCVCX(3,IASYM)
      WRITE(*,*)'Hello UZZBar'
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,5031)A,B,C
      ENDIF
5031  FORMAT(/1X,F4.0,
     1 'UZZBAR - Restrain the covariance perp. to X and bond to be '
     2 /6x,F9.5,'  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,5032)NINT(A+1), 'Variance difference ZZ ', B,C
      CALL XPRVDU(NCVDU, 1,0)
5032  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)
      IF (ISSPRT .EQ. 0) THEN
         WRITE(NCWU,5033)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
5033  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500
C
C
C--'EXECUTION LISTING'
2350  CONTINUE
      ISTAT2=1
      GOTO 1050
C
C--'NO LISTING'
2400  CONTINUE
      ISTAT2=0
      GOTO 1050
C
C--'U(IJ)' RESTRAINT
2450  CONTINUE
      CALL XDUIJ(iasym)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2251)A,(UIJ(M),M=1,3),B,C
2251  FORMAT(/4X ,F4.0,'SIMU - Restrain the difference',
     1 ' in the components of',  2A4,A1,
     2 ' to be',/6x,F9.5,
     3 '  angstrom squared, with an E.S.D. of',F9.5)
      ENDIF
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2300)(NUMB(N),(UIJ(M),M=1,3),N=2,3),IB
      ENDIF
      WRITE(CMON,2460)NINT(A+1), '      Uij difference', B,C
      CALL XPRVDU(NCVDU, 1,0)
2460  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)
      N=2
      GOTO 2500
C
C--GENERAL PRINT ROUTINES
2500  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,2900)
      ENDIF
      M22PD=KNEXTF(L22PD)
      JA=LCA
      O=0.
      P=0.
      Q=0.
      NCA=0
      JI=JH
      ITEMPA=M22PD
C--LOOP FOR PRINTING EACH INDIVIDUAL RESTRAINT
2550  CONTINUE
      CALL XDOWNF(M22PD,STORE(L22PD),4)
      M22PD=M22PD+KINCRF(ISTORE(L22PD))
C--CHECK IF THIS RESTRAINT IS USEFUL
      CALL XMOVE(IB1(1),KF1(1),1)
      IF(ISTORE(L22PD)-4)2650,2600,2650
2600  CONTINUE
      CALL XMOVE(IQ1(1),KF1(1),1)
2650  CONTINUE
C--SET UP A FEW CONSTANTS
      JD=JA+7
      JE=JA+11
      JB=ISTORE(JA)
      JF=JB+7
      JG=JB+11
      NCA=NCA+1
      ISTORE(JA+3)=NINT(STORE(JA+3))
C--CHECK IF THERE IS MORE THAN ONE ATOM IN THIS RESTRAINT
      IF(NN)2750,2750,2700
2700  CONTINUE
      ISTORE(JB+3)=NINT(STORE(JB+3))
C--CALCULATE THE 'DELTA' AND 'CALCULATED' VALUES
2750  CONTINUE
      A1(2)=STORE(L22PD+2)*CONV
      A1(1)=B-A1(2)
C--BRANCH ON THE TYPE OF RESTRAINTS
      GOTO(1050,1050,2850,3000,2850,3050,3150,3050,3200,1050,1050,3300,
     2 1050,4150,1050,1050,4550,4540,2850,1050,3280,3290, 3270,2800) ,I
2800  CONTINUE
      CALL XOPMSG (IOPL16, IOPINT, 0)
      GOTO 9900
C
C--PRINT A DISTANCE RESTRAINT
2850  CONTINUE
C----- GET THE EQUIVALENT SIGMA FOR A 'ENERGY' CARD
      ESIGMA = AMIN1( 1./(SQRT( STORE(L22PD + 1) ) ), 10.)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2900)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=1,N)
      ENDIF
2900  FORMAT(2H  ,A1,2X,2(6X,A4,I5,I6,4I3),F11.3,F10.3)
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(2)) .GE. ESIGMA) ) THEN
c         WRITE(NCAWU,2901)KF,STORE(JA+2),ISTORE(JA+3),STORE(JB+2),
c     2   ISTORE(JB+3),A1(1),A1(2), ESIGMA
         IF ((IMON .GE. 1) .AND. (ABS(A1(2)) .GE. ESIGMA) ) THEN
         WRITE(CMON ,2901)KF,STORE(JA+2),ISTORE(JA+3),STORE(JB+2),
     2   ISTORE(JB+3),A1(1),A1(2)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
2901  FORMAT(1X,A1, 12X, 2(2X,A4,I4),F11.3,F10.3,F12.7)
C--RESET FOR THE NEXT RESTRAINT
2950  CONTINUE
      JA=ISTORE(JB)
      GOTO 3550
C--RESET FOR DISTANCES WHEN DIFFERENCES HAVE BEEN COMPUTED
3000  CONTINUE
      M22PD=ITEMPA
      A1(1)=STORE(JI)
      JI=JI+1
      GOTO 2850
C
C--ANGLES RESTRAINT PRINT
3050  CONTINUE
      JC=ISTORE(JB)
      ISTORE(JC+3)=NINT(STORE(JC+3))
      JL=JC+7
      JM=JC+11
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3100)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),STORE(JC+2),
     3 ISTORE(JC+3),(ISTORE(M),M=JL,JM),(A1(M),M=1,N)
      ENDIF
3100  FORMAT(2H  ,A1,2X,3(6X,A4,I5,I6,4I3),F10.2,F7.2)
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(2)) .GE. C) ) THEN
c         WRITE(NCAWU,3101)KF,STORE(JA+2),ISTORE(JA+3),STORE(JB+2),
c     2   ISTORE(JB+3),STORE(JC+2),ISTORE(JC+3),A1(1),A1(2)
         IF ((IMON .GE. 1) .AND. (ABS(A1(2)) .GE. C) ) THEN
         WRITE(CMON,3101)KF,STORE(JA+2),ISTORE(JA+3),STORE(JB+2),
     2   ISTORE(JB+3),STORE(JC+2),ISTORE(JC+3),A1(1),A1(2)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
3101  FORMAT(1X,A1, 2X, 3(2X,A4,I4),F7.2,F7.2)
      JA=ISTORE(JC)
      GOTO 3550
C--ANGLE RESTRAINT PRINT FOR DIFFERENCES
3150  CONTINUE
      M22PD=ITEMPA
      A1(1)=STORE(JI)*CONV
      JI=JI+1
      GOTO 3050
C
C--VIBRATION RESTRAINTS PRINT
3200  CONTINUE
      A1(3)=A1(2)
      A1(2)=2.*SQRT(STORE(L22PD+3))
      A1(1)=0.5*(A1(2)-A1(3))
      A1(2)=A1(2)-A1(1)-B
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(1),STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=2,3)
      ENDIF
3250  FORMAT(2H  ,A1,2(8X,A4,I5,I6,4I3,F12.5,1X),F9.5,5X,5A4)
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C )) THEN
c         WRITE(NCAWU,3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
c     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C )) THEN
         WRITE(CMON, 3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
3251  FORMAT(1X,A1,2X,2(2X,A4,I4,F9.5,1X),F9.5,2X,5A4)
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
      GOTO 2950

C--UXZBAR RESTRAINTS PRINT
3280  CONTINUE
      A1(3)=A1(2)
      A1(2)=2.*SQRT(STORE(L22PD+3))
      A1(1)=0.5*(A1(2)-A1(3))
      A1(2)=A1(2)-A1(1)-B
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(1),STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=2,3)
      ENDIF
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C )) THEN
c         WRITE(NCAWU,3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
c     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C )) THEN
         WRITE(CMON, 3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
      GOTO 2950
CC--UYZBAR RESTRAINTS PRINT
3290  CONTINUE
      A1(3)=A1(2)
      A1(2)=2.*SQRT(STORE(L22PD+3))
      A1(1)=0.5*(A1(2)-A1(3))
      A1(2)=A1(2)-A1(1)-B
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(1),STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=2,3)
      ENDIF
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C )) THEN
c         WRITE(NCAWU,3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
c     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C )) THEN
         WRITE(CMON, 3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
      GOTO 2950
C--UZZBAR RESTRAINTS PRINT
3270  CONTINUE
      A1(3)=A1(2)
      A1(2)=2.*SQRT(STORE(L22PD+3))
      A1(1)=0.5*(A1(2)-A1(3))
      A1(2)=A1(2)-A1(1)-B
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(1),STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=2,3)
      ENDIF
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C )) THEN
c         WRITE(NCAWU,3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
c     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C )) THEN
         WRITE(CMON, 3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
      GOTO 2950
C	  
C
C--U(IJ) RESTRAINT
3300  CONTINUE
      JS=ISTORE(JA+16)
      JT=ISTORE(JB+16)
C--CHECK THAT BOTH ATOMS ARE ANISO
CDJWAPR99 - REMEBER THAT JS+6 IS JUST A FLAG NOW, AND RESULT SHOULD BE
C           BE ZERO
C      IF(ABS(STORE(JS+6))+ABS(STORE(JT+6))-2.*UISO)3350,3500,3500
cdjwjun09 - print out names of iso atoms
      IF(ABS(STORE(JS+6))+ABS(STORE(JT+6)).lt.UISO) then
3350   CONTINUE
c       write(123,'(10f8.5)') (store(idjw),idjw=js+14,js+24,2)
c       write(123,'(10f8.5)') (store(idjw),idjw=jt+14,jt+24,2)
       jdjw = 14
       DO 3450 JJ=8,13
       adjw = store(js+jdjw)
       bdjw = store(jt+jdjw)
       A1(3)=STORE(L22PD+2)
       A1(2)=2.*SQRT(STORE(L22PD+3))
       A1(1)=0.5*(A1(2)-A1(3))
       A1(2)=A1(2)-A1(1)-B
c       write(123,'(i6,2f8.5,2x,2f8.5,5x,3f8.5))') 
c     1 jdjw,adjw,bdjw,store(l22pd+2),store(l22pd+3),a1(1),a1(2),a1(3)
c
c Extracting Uij as a1(1) and a1(2) from Store(l22pd+ ) does not 
c recover the original values because L22pd+3 is a squared value, so the
c sign is lost.
c It might be better to use original values at JS and JT.
c
       IF (ISSPRT .EQ. 0) THEN
       WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 adjw,STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),bdjw,A1(3)
     3 ,(ICOORD(idjw,JJ),idjw=1,NWKA)
       ENDIF
       IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C ))  THEN
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C ))THEN
         WRITE(CMON,3251) KF, STORE(JA+2), ISTORE(JA+3), adjw,
     2   STORE(JB+2),ISTORE(JB+3),bdjw,A1(3),
     3   (ICOORD(idjw,JJ),idjw=1,NWKA)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
       ENDIF
C--ACCUMUALTE THE MEANS ETC.
       O=O+A1(3)
       P=P+A1(3)*A1(3)
       Q=Q+0.5*(A1(1)+A1(2)+B)
C--CHECK IF THIS IS THE LAST U(IJ) FOR THIS ATOM
       IF(JJ-13)3400,3450,3400
3400   CONTINUE
       CALL XDOWNF(M22PD,STORE(L22PD),4)
       M22PD=M22PD+KINCRF(ISTORE(L22PD))
       NCA=NCA+1
       jdjw = jdjw + 2
3450   CONTINUE
      else
       if(issprt.eq.0) WRITE(ncwu,'(2x,A1,2(8X,A4,I5,31x),A)')
     2 KF,STORE(JA+2),ISTORE(JA+3), STORE(JB+2),ISTORE(JB+3),
     3 'Isotropic'
       write(cmon,'(1x,a1,2x,2(2x,a4,i4,10x),a)')
     2 KF,STORE(JA+2),ISTORE(JA+3), STORE(JB+2),ISTORE(JB+3),
     3 'Isotropic'
       call xprvdu(ncvdu, 1,0)
      endif
C--CHANGE ATOMS
3500  CONTINUE
      JA=ISTORE(JB)
      IF(JA)3600,3600,2550
C
C--ACCUMULATE THE MEANS ETC.
3550  CONTINUE
      O=O+A1(2)
      P=P+A1(2)*A1(2)
      Q=Q+A1(1)
      IF(JA)3600,3600,2550
C
C--END OF PRINTING FOR THIS RESTRAINT
3600  CONTINUE
      R=1./FLOAT(NCA)
      Q=Q*R
C--CHECK IF WE SHOULD PRINT THE MEAN DELTA AND R.M.S. DEVIATION
      IF(N-1)3750,3750,3650
3650  CONTINUE
      O=O*R
      P=SQRT(P*R)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,3700)Q,O,P
      WRITE(CMON,3700) Q, O ,P
      CALL XPRVDU(NCVDU, 1,0)
3700  FORMAT('      Mean value =',F9.4,'  Mean delta =',F9.4,
     2 '  r.m.s. delta =',F9.4)
      GOTO 1050
3750  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3700)Q
      ENDIF
      GOTO 1050
C
C--TERMINATION AND APPLICATION OF THE STORED DERIVATIVES
3800  CONTINUE
      CALL XOPMSG (IOPCHK, IOPEND, IVERSN)
      CALL XTIME2(2)
      RETURN
C
C--ERRORS
3900  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU,3950)A
3950  FORMAT(/1H ,F4.0,20H   Restraint ignored)
      GOTO 1050
C
C--'PLANAR' reSTRAINT
4000  CONTINUE
      NN=0
      N=2
C--COMPUTE THE PLANE AND DERIVATIVES
      IDWZAP = 0
      IF(KPLANE(IDWZAP))3900,4050,4050
C--PRINT THE HEADER
4050  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU,4100)A,B,(STROM(M),M=1,2),C
4101  FORMAT(//1H ,F4.0,'  Restrain these atoms to be ',F8.3,
     2 2X,' A',' from their mean plane',/' with an E.S.D. of ',F8.3)
4100  FORMAT(//1H ,F4.0,37H   Restrain the following atoms to be,F8.3,
     2 2X,2A4,41H from their mean plane, with an E.S.D. of,F8.3//12X,
     3 4HAtom,7X,15HS(I) L TX TY TZ,5X,5HDelta)
      WRITE(CMON,2460)NINT(A+1), '           Planarity', B,C
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 2500
C
C--PRINT THE INFORMATION FROM A PLANAR RESTRAINT
4150  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4200)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(2)
      ENDIF
4200  FORMAT(2H  ,A1,8X,A4,I5,I6,4I3,F10.3)
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(2)) .GE. C ) ) THEN
c        WRITE(NCAWU,4201)KF,STORE(JA+2),ISTORE(JA+3),A1(2)
         IF ((IMON .GE. 1) .AND. (ABS(A1(2)) .GE. C ) ) THEN
         WRITE(CMON ,4201)KF,STORE(JA+2),ISTORE(JA+3),A1(2)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
4201  FORMAT(1X,A1,4X, A4,I4,F7.3)
C--MOVE ONTO THE NEXT ATOM
4250  CONTINUE
      JA=ISTORE(JA)
      GOTO 3550
C
C
C--'SUM' RESTRAINT
4300  CONTINUE
      CALL XSUMCN(1)
      AB=STORE(LCG+2)
      WRITE(CMON,2460)NINT(A+1), '                 Sum', AB,C
      CALL XPRVDU(NCVDU, 1,0)
4310  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU,4350)A,AB,C
c      WRITE(NCAWU,4350)A,AB,C
4350  FORMAT(1X ,F4.0,' The sum is restrained to be ',
     2 G12.5,'  with an E.S.D. of ',G12.5)
      GOTO 1050
C
C     'ORIGIN' FIXING
5000  CONTINUE
      CALL XSUMCN(2)
      AB=STORE(LCG+2)
      WRITE(CMON,2460)NINT(A+1), '              Origin', AB,C
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 4310
C
4370  CONTINUE
C----- 'LIMIT' RESTRAINT
      N = 2
      NN = 0
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4380) A,C
      ENDIF
c      WRITE(NCAWU,4380) A,C
4380  FORMAT ( // , 1X , F4.0 , ' Limit the shifts of the given' ,
     2 ' parameters to 0.0, with an E.S.D. of ',E20.10)
      WRITE(CMON,2460)NINT(A+1), '               Limit', 0.0, C
      CALL XPRVDU(NCVDU, 1,0)
      GO TO 1050
C
C--'AVERAGE' RESTRAINT
4400  CONTINUE
      N=2
      NN=0
C--COMPUTE THE VALUES ETC.
      MM=1
      IF(KAVERG(MM))3900,4450,4450
C--PRINT OUT THE HEADER
4450  CONTINUE
      AB=STORE(LCG+2)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4500)A,AB,C
      ENDIF
c      WRITE(NCAWU,4501)A,AB,C
4501  FORMAT(//1H ,F4.0,' Restrain these to their common',
     2 ' mean of ',F10.5,'  with an E.S.D. of', F10.5)
4500  FORMAT(//1H ,F4.0,39H   Restrain the following parameters to,
     2 21H their common mean of,F10.5,19H  with an E.S.D. of,
     3 F10.5//12X,4HAtom,7X,15HS(I) L TX TY TZ,5X,9HParameter,8X,
     4 5HValue,5X,5HDelta)
      WRITE(CMON,2460)NINT(A+1), '             Average', AB,C
      CALL XPRVDU(NCVDU, 1,0)
C--RESET THE OBSERVED VALUE
      B=STORE(LCG+4)
      GOTO 2500
C
4540  CONTINUE
C----- DO NOT PRINT THE LIMIT RESTRAINT
      MM = 1
      GOTO 1050
C
C--PRINT FOR THE 'AVERAGE' RESTRAINT
4550  CONTINUE
      MM = 2
C
      JB=ISTORE(JA+6)
      JC=ISTORE(JB+1)
C--CHECK ON THE TYPE OF THE CURRENT PARAMETER
      IF(ISTORE(JA+1)-1)4600,4700,4800
C--THIS IS AN ATOMIC PARAMETER
4600  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4650)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 (ICOORD(idjw,JC),idjw=1,2), (A1(M),M=1,MM)
      ENDIF
4650  FORMAT(2H  ,A1,8X,A4,I5,I6,4I3,6X,2A4,4X,2F10.5)
c      WRITE(NCAWU,4651)KF,STORE(JA+2),ISTORE(JA+3),
c     2 (ICOORD(M,JC),M=1,2), (A1(M),M=1,MM)
      IF ((IMON .GE. 1) .AND. (ABS(A1(2)) .GE. C) ) THEN
       WRITE(CMON,4651)KF,STORE(JA+2),ISTORE(JA+3),
     2 (ICOORD(idjw,JC),idjw=1,2), (A1(M),M=1,MM)
       CALL XPRVDU(NCVDU, 1,0)
      ENDIF
4651  FORMAT(1X,A1,4X,A4,I4,2X,2A4,2X,2F10.5)
      GOTO 4250
C--THIS IS A SIMPLE OVERALL PARAMETER
4700  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4750)KF,(KVP(M,JC),M=1,2), (A1(M),M=1,MM)
      ENDIF
4750  FORMAT(2H  ,A1,41X,2A4,4X,2F10.5)
c      WRITE(NCAWU,4751)KF,(KVP(M,JC),M=1,2), (A1(M),M=1,MM)
      IF ((IMON .GE. 1) .AND. (ABS(A1(2)) .GE. C) ) THEN
       WRITE(CMON,4751)KF,(KVP(M,JC),M=1,2), (A1(M),M=1,MM)
       CALL XPRVDU(NCVDU, 1,0)
      ENDIF
4751  FORMAT(1X,A1,10X,2A4,2X,2F10.5)
      GOTO 4250
C--THIS IS AN ELEMENT OR LAYER SCALE FACTOR
4800  CONTINUE
      JB=ISTORE(JA+1)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4850) KF,(KSCAL(M,JB),M=1,2), (A1(M),M=1,MM)
      ENDIF
4850  FORMAT(2H  ,A1,38X,2A4,4X,3X,2F10.5)
c      WRITE(NCAWU,4851) KF,(KSCAL(M,JB),M=1,2), (A1(M),M=1,MM)
      IF ((IMON .GE. 1) .AND. (ABS(A1(2)) .GE. C) ) THEN
       WRITE(CMON,4851) KF,(KSCAL(M,JB),M=1,2), (A1(M),M=1,MM)
       CALL XPRVDU(NCVDU, 1,0)
      ENDIF
4851  FORMAT(1X,A1,7X,2A4,4X,1X,2F10.5)
      GOTO 4250
C
9900  CONTINUE
C -- ERRORS
      CALL XOPMSG ( IOPCHK , IOPABN , 0 )
      GO TO 3800
9910  CONTINUE
C -- INPUT ERRORS
      CALL XOPMSG ( IOPCHK , IOPCMI , 0 )
      GO TO 9900
      END
C
CODE FOR XAPP16
      SUBROUTINE XAPP16
C--APPLY THE RESTRAINTS
C
C  THIS SUBROUTINE READS DOWN THE LIST 26 AND CALCULATES THE
C  REQUIRED RESTRAINTS.
C  THIS SUBROUTINE IS RESPONSIBLE FOR FORMING THE PARTIAL
C  DERIVATIVE QUEUE ON THE DISC AND THEN ADDING IT TO LIST 11
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST23.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
C
C
      DATA IVERSN /403/
C
C--INITIATE THE TIMING
      CALL XTIME1(2)
C--READ THE REMAINING CONTROL CARDS
      I=KRDDPV(ISTORE(NFL),1)
      IF ( I .LT. 0 ) GO TO 9910
C--CLEAR THE CORE AREA
      CALL XRSL
      CALL XCSAE
C----- FETCH LIST 23 TO SEE IF RESTRAINTS ARE NEEDED
      CALL XFAL23
      IF(ISTORE(L23MN+2) .LT. 0) GOTO 1770
C----- LOAD LIST 3 IF IT EXISTS
      KLST3 = -1
        IF (KEXIST(3) .GT. 0) CALL XFAL03
C--LOAD LIST 5
      CALL XFAL05
C--SET UP THE SYSTEM VARIABLES IN CORE
      CALL XLSV
C--LOAD LIST 12
      CALL XFAL12(-1,1,JR,JN)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--LINK LIST 5 AND LIST 12
      I=KSET52(0,-1)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--SET UP THE POINTERS FOR THE DERIVATIVE QUEUE ON DISC
      CALL XIPDQF
C--LOAD THE COMPILED LIST FOR PROCESSING
      IULN=26
      CALL XLCLFP(IULN)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--BRING DOWN THE NEXT BLOCK OF CODE AND RELOCATE IT
1000  CONTINUE
      IF(KLOADR(LN))1850,1050,1750
C--JUMP ON THE FUNCTION
1050  CONTINUE
      I=ISTORE(LCG+1)
cdjwsep2011
      if(i .lt. 1) then
       iasym = 1
       i = abs(i)
      else
       iasym = 0
      endif
      GOTO(1150,1200,1250,1300,1350,1400,1450,1500,1550,1600,1650,1700,
     2 1950,2000,2050,2100,2150,2200,2250,2055,1560,1570,1580,1100) ,I
1100  CONTINUE
      CALL XOPMSG (IOPL16, IOPINT, 0)
      GOTO 9900
C
C--'DEFINE' FUNCTION
1150  CONTINUE
      CALL XCDEF
      GOTO 1000
C
C--'RESTRAIN' FUNCTION
1200  CONTINUE
      CALL XCC
      GOTO 1000
C
C--'SINGLE DISTANCE' RESTRAINTS
1250  CONTINUE
      CALL XCDC(iasym)
      GOTO 1000
C
C--'DISTANCE DIFFERENCE' RESTRAINTS
1300  CONTINUE
      CALL XCDDC(iasym)
      GOTO 1000
C
C--'MEAN DISTANCE' RESTRAINT
1350  CONTINUE
      CALL XCMDC(iasym)
      GOTO 1000
C
C--'SINGLE ANGLE' RESTRAINTS
1400  CONTINUE
      CALL XCAC
      GOTO 1000
C
C--'ANGLE DIFFERENCE' RESTRAINTS
1450  CONTINUE
      CALL XCADC
      GOTO 1000
C
C--'MEAN ANGLE' RESTRAINT
1500  CONTINUE
      CALL XCMAC
      GOTO 1000
C
C--'VIBRATION' RESTRAINT
1550  CONTINUE
      CALL XCVC(iasym)
      GOTO 1000
C
C--'UXZBAR' RESTRAINT
1560  CONTINUE
      CALL XCVCX(1,iasym)
      GOTO 1000
C
C--'UYZBAR' RESTRAINT
1570  CONTINUE
      CALL XCVCX(2,iasym)
      GOTO 1000
C--'UZZBAR' RESTRAINT
1580  CONTINUE
      CALL XCVCX(3,iasym)
      GOTO 1000
C
C--'EXECUTION LISTING'
1600  CONTINUE
      ISTAT2=1
      GOTO 1000
C
C--'NO LISTING'
1650  CONTINUE
      ISTAT2=0
      GOTO 1000
C
C-'U(IJ)' RESTRAINT
1700  CONTINUE
      CALL XDUIJ(iasym)
      GOTO 1000
C
C--TERMINATION AND APPLICATION OF THE STORED DERIVATIVES
1750  CONTINUE
      CALL XTPDQF
      CALL XADCPD
      IF ( IERFLG .LT. 0 ) GO TO 9900
1770  CONTINUE
      CALL XOPMSG (IOPCPR, IOPEND, IVERSN)
      CALL XTIME2(2)
      RETURN
C
C--ERRORS
1850  CONTINUE
      J=16
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1900)IULN
c      WRITE(NCAWU,1900)IULN
1900  FORMAT(
     1' List ',I5,' contains errors.',
     2  ' Check the Restraints lists 16 and 17')
      WRITE ( CMON ,1900)IULN
      CALL XPRVDU(NCVDU, 1,0)
      CALL XERHND ( IERERR )
      GO TO 9900
C
C--'EQUATE' RESTRAINT
1950  CONTINUE
      IF(KEQUAT(I))1850,1000,1000
C
C--'PLANAR' RESTRAINT
2000  CONTINUE
      IDWZAP = 0
      IF(KPLANE(IDWZAP))1850,1000,1000
C
C--'SUM' RESTRAINT
2050  CONTINUE
      CALL XSUMCN(1)
      GOTO 1000
C
C--'ORIGIN' RESTRAINT
2055  CONTINUE
      CALL XSUMCN(2)
      GOTO 1000
C
C
C--'FORM' RESTRAINT
2100  CONTINUE
      IF(KFORM(I))1850,1000,1000
C
C--'AVERAGE' RESTRAINT
2150  CONTINUE
      I = 1
      IF(KAVERG(I))1850,1000,1000
C
C----- 'LIMIT' RESTRAINT
2200  CONTINUE
      I = -1
      IF (KAVERG(I))1850,1000,1000
C
C----- ENERGY RESTRAINT
2250  CONTINUE
      CALL XCEC(iasym)
      GOTO 1000
C
9900  CONTINUE
C -- ERRORS
      CALL XOPMSG ( IOPCPR , IOPABN , 0 )
      GO TO 1770
9910  CONTINUE
C -- INPUT ERRORS
      CALL XOPMSG ( IOPCPR , IOPCMI , 0 )
      GO TO 9900
      END
C
CODE FOR XCC
      SUBROUTINE XCC
C--CALCULATE RESTRAINTS FROM THE GIVEN CODE
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XAPK.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET UP A FEW INITIAL CONSTANTS
      MCA=LCA
      STORE(L22PD+2)=STORE(LCG+4)-XVALUE(LC)
C
C--MAIN LOOP FOR PASSING THROUGH THE COORDS. OF EACH ATOM
1000  CONTINUE
      I=ISTORE(MCA+6)
      K=0
C--CHECK IF THIS IS AN ATOM OR AN OVERALL PARAMETER
      IF(ISTORE(MCA+1))1100,1050,1100
C--THIS IS AN ATOM  -  ALTER THE PARAMETER STEP
1050  CONTINUE
      K=NKA+NKA-2
C--CHECK IF ANY PARAMETERS HAVE BEEN GIVEN
1100  CONTINUE
      IF(I)1650,1650,1150
C--CLEAR THE DERIVATIVE SLOTS FOR THIS ATOM OR PARAMETER
1150  CONTINUE
      L=ISTORE(MCA+16)
      M=L+K
      DO 1200 J=L,M,2
      STORE(J+1)=0.0
1200  CONTINUE
C--CHECK IF THIS IS AN ATOM OR AN OVERALL PARAMETER
      IF(K)1250,1250,1300
C--THIS IS AN OVERALL PARAMETER
1250  CONTINUE
      STORE(L+1)=1.
      GOTO 1600
C--THIS IS AN ATOM  -  CHECK THE PARAMETER TYPE
1300  CONTINUE
      IF(ISTORE(I+1)-5)1350,1450,1400
C--'U[ISO]' OR 'OCC'
1350  CONTINUE
      L=L+ISTORE(I+1)+ISTORE(I+1)
      STORE(L-1)=1.0
      GOTO 1600
C--CHECK FOR AN ANISO TEMPERATURE FACTOR
1400  CONTINUE
      IF(ISTORE(I+1)-7)1450,1450,1500
C--POSITIONAL COORD.
1450  CONTINUE
      M=ISTORE(MCA+4)+ISTORE(I+1)
C--GENERATE DERIVS. FOR SHIFTED ATOM
      STORE(L+9)=STORE(MCA+14)*STORE(M-5)
      STORE(L+11)=STORE(MCA+14)*STORE(M-2)
      STORE(L+13)=STORE(MCA+14)*STORE(M+1)
      GOTO 1600
C--ANISO TEMPERATURE TERMS
1500  CONTINUE
      M=L+15
      N=NFL+18
C--FIND THE ADDRESS OF THE RELEVANT PARAMETER
      L=N+ISTORE(I+1)
C--ZERO THE DERIVATIVE AREA
      CALL XZEROF(STORE(N),6)
      STORE(L-8)=1.0
C--COMPUTE THE DERIVATIVES, ALLOWING FOR SYMMETRY
      CALL XEXANI(N,NFL)
      N=ISTORE(MCA+4)
      CALL XMLTTM(STORE(NFL),STORE(N),STORE(NFL+9),3,3,3)
      CALL XMLTTM(STORE(N),STORE(NFL+9),STORE(NFL),3,3,3)
C--STORE THE SYMMETRY GENERATED DERIVATIVES
      STORE(M)=STORE(NFL)
      STORE(M+2)=STORE(NFL+4)
      STORE(M+4)=STORE(NFL+8)
      STORE(M+6)=STORE(NFL+5)
      STORE(M+8)=STORE(NFL+2)
      STORE(M+10)=STORE(NFL+1)
C--CALCULATE THE PARTIAL DERIVATIVE
1600  CONTINUE
      STORE(I+2)=XDERIV(LC)
      I=ISTORE(I)
      GOTO 1100
1650  CONTINUE
      L=ISTORE(MCA+16)
      M=L+K
      DO 1700 J=L,M,2
      STORE(J+1)=0.0
1700  CONTINUE
      MCA=ISTORE(MCA)
      IF(MCA)1750,1750,1000
1750  CONTINUE
      MCA=LCA
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
      RETURN
      END
C
CODE FOR XDUIJ
      SUBROUTINE XDUIJ(iasym)
C--CALCULATE RESTRAINTS ON THE INDIVIDUAL U(IJ)'S
C
c
C      IASYM = 1 FOR ASYMMETRIC OTHERWISE 0
c
CDJWAPR99
C      The Uij entries for both atoms seem to get swapped, though
c      the sign also seems to get inverted. 'Effect' is in the 1984
c      VAX version.
      INCLUDE 'ISTORE.INC'
C
      DIMENSION A1(6)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (A1(1),O)
C
C--SET UP A FEW CONSTANTS
      DUMP=STORE(LCG+4)
      JA=LCA
      NCA=2
C--SET UP THE ADDRESSES OF THE ATOMS
1000  CONTINUE
      JB=ISTORE(JA)
      JC=JA
      DO 1100 I=1,2
      JD=ISTORE(JC+16)
C--CHECK IF THE ATOM IS ANISO
CDJWAPR99 REMEMBER JD+6 IS JUST A FLAG NOW
c     0=aniso, 1 = iso, 2-4 = shape
c      x to u[12] OK 2012
c      write(123,'(10f8.5)') (store(idjw),idjw=jd+8,jd+24,2)
      IF(ABS(STORE(JD+6))-UISO)1050,1400,1400
C--PASS ONTO THE SECOND OF THE PAIR
1050  CONTINUE
      JC=JB
1100  CONTINUE
      JP=ISTORE(JA+6)
      JV=ISTORE(JB+6)
      JC=ISTORE(JA+16)+14
      JD=ISTORE(JB+16)+14
C--ZERO THE DERIVATIVE AREA
      CALL XZEROF(A1(1),6)
C--CALCULATE THE DERIVATIVES FOR THE U(IJ)
      DO 1350 JY=1,6
c      write(123,'(2(i12,f8.5))') jc,store(jc),jd,store(jd)
      JX=JP
      I=1
      JO=JA
      A=1.
C--STORE THE DERIVATIVES
1150  CONTINUE
      if ((i .eq. 1).AND.(iasym .eq.1)) then
c           dont restrain first atom
            a1(jy) = 0.
      else
            a1(jy)=a
      endif
      CALL XADUIJ
      A1(JY)=0.
C--CHECK IF THIS THE FIRST OR SECOND ATOM
      IF(I)1250,1250,1200
1200  CONTINUE
      JO=JB
      JX=JV
      A=-1.
      I=I-1
      GOTO 1150
C--CALCULATE THE MEAN VALUE AND THE DIFFERENCE
1250  CONTINUE
c      write(123,'(a,3f12.6)') 'U-values', dump, store(jc),store(jd)
cdjwmar2012 - should DUMP be outside the brackets?
c     for the asymmetric restraint, should we NOT compute the mean?
      STORE(LCG+4)=0.5*(DUMP+STORE(JC)+STORE(JD))
      STORE(L22PD+2)=DUMP-STORE(JC)+STORE(JD)
      MCA=JA
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
C--CLEAR THE P.D. SLOSTS FOR THE NEXT COORD.
      JQ=JP
      JW=JV
      DO 1300 JX=1,6
      STORE(JQ+2)=0.
      STORE(JW+2)=0.
      JQ=ISTORE(JQ)
      JW=ISTORE(JW)
1300  CONTINUE
c      write(123,'(2(i12,f8.5))') jc,store(jc),jd,store(jd)
      JC=JC+2
      JD=JD+2
1350  CONTINUE
C--PASS ONTO THE NEXT PAIR OF ATOMS
1400  CONTINUE
      JA=ISTORE(JB)
      IF(JA)1450,1450,1000
1450  CONTINUE
      RETURN
      END
C
CODE FOR XCVC
      SUBROUTINE XCVC(iasym)
C--CALCULATE VIBRATION RESTRAINTS
C
C
C      IASYM = 1 FOR ASYMMETRIC OTHERWISE 0
C
C--THE VARIABLES IN 'XWORK' ARE USED AS FOLLOWS :
C
C  P  DU(B)/DU(22)
C  .
C  .
C  T  DU(B)/DU(12)
C
C--SUBSEQUENTLY O TO T ARE USED FOR THE DIFFERENCES BETWEEN THE
C  THE TWO VALUES OF EACH VIBRATION PARAMETER
C
C--
      INCLUDE 'ISTORE.INC'
C
      DIMENSION A1(12)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (O,A1(1))
C
C--SET UP A FEW CONSTANTS                                               CVC00320
      DUMP=STORE(LCG+4)                                                 CVC00330
      JA=LCA                                                            CVC00340
      NCA=2                                                             CVC00350
C--SET UP THE ADDRESSES OF THE ATOMS                                    CVC00360
1000  CONTINUE                                                          CVC00370
      JB=ISTORE(JA)                                                     CVC00380
      JP=ISTORE(JA+6)                                                   CVC00390
      JV=ISTORE(JB+6)                                                   CVC00400
C--SET UP THE ADDRESSES OF THE U(IJ)'S                                  CVC00410
      DO 1050 I=1,3                                                     CVC00420
      JP=ISTORE(JP)                                                     CVC00430
      JV=ISTORE(JV)                                                     CVC00440
1050  CONTINUE                                                          CVC00450
C--CHECK THAT BOTH ATOMS ARE ANISO AND IF NOT MODIFY ACCORDINGLY        CVC00460
      JX=JP                                                             CVC00470
      JC=JA                                                             CVC00480
      DO 1250 I=1,2                                                     CVC00490
      JD=ISTORE(JC+16)                                                  CVC00500
C--CHECK IF THE ATOM IS ANISO                                           CVC00510
c      IF(ABS(STORE(JD+6))-UISO)1200,1100,1100                           CVC0052
      IF(ABS(STORE(JD+6)) .le. zero) goto 1200
C--'ISO' ATOM  -  MODIFY THE ENTRY IN THE COORDINATE SECTION            CVC00530
1100  CONTINUE                                                          CVC00540
cdjw99 The number of parameters
      ISTORE(JC+5)=4                                                    CVC00550
      ISTORE(JX)=-1000000                                               CVC00560
cdjw99 Where they start (iso is now same as U11)
c      ISTORE(JX+1)=4                                                    CVC0057
      ISTORE(JX+1)=8
C--SET THE ANISO TEMPERATURE FACTORS FOR THE ATOM                       CVC00580
      JE=JD                                                             CVC00590
      JF=L1C+2                                                          CVC00600
      DO 1150 J=L1C,JF                                                  CVC00610
cdjw99 Uiso now in same place as U11
c      STORE(JE+14)=STORE(JD+6)                                          CVC0062
      STORE(JE+14)=STORE(JD+14)
      STORE(JE+20)=STORE(JD+14)*STORE(J)                                 CVC0063
      JE=JE+2                                                           CVC00640
1150  CONTINUE                                                          CVC00650
      STORE(JD+6)=0.                                                    CVC00660
C--PASS ONTO THE SECOND OF THE PAIR                                     CVC00670
1200  CONTINUE                                                          CVC00680
      JX=JV                                                             CVC00690
      JC=JB                                                             CVC00700
1250  CONTINUE                                                          CVC00710
C--CALCULATE THE INTERNUCLEAR DISTANCE                                  CVC00720
      JO=JA                                                             CVC00730
      JS=JB                                                             CVC00740
      CALL XCD2PD                                                       CVC00750
      D=SQRT(0.5*(A*F+B*G+C*H))                                         CVC00760
C--APPLY THE RECIPROCAL CELL PARAMETERS                                 CVC00770
      F=F*STORE(L1P2)                                                   CVC00780
      G=G*STORE(L1P2+1)                                                 CVC00790
      H=H*STORE(L1P2+2)                                                 CVC00800
C--CALCULATE THE COMPONENTS APART FROM A SCALING BY 'D'                 CVC00810
      A1(7)=F*F                                                         CVC00820
      A1(8)=G*G                                                         CVC00830
      A1(9)=H*H                                                         CVC00840
      A1(10)=2.*G*H                                                     CVC00850
      A1(11)=2.*F*H                                                     CVC00860
      A1(12)=2.*F*G                                                     CVC00870
C--CALCULATE THE SCALING CONSTANT FOR THE COMPONENTS SQUARED            CVC00880
      E=1./(4.*D*D)                                                     CVC00890
C--CALCULATE THE DERIVATIVES FOR THE U(IJ)                              CVC00900
      DO 1300 I=1,6                                                     CVC00910
      A1(I)=A1(I+6)*E                                                   CVC00920
1300  CONTINUE                                                          CVC00930
      JO=JA                                                             CVC00940
      JX=JP                                                             CVC00950
      I=1                                                               CVC00960
C--STORE THE DERIVATIVES                                                CVC00970
1350  CONTINUE                                                          CVC00980
C--CHECK IF THIS ATOM IS ISO AND NOT ANISO                              CVC00990
      IF(ISTORE(JO+5)-4)1450,1400,1450                                  CVC01000
C--'ISO' ATOM                                                           CVC01010
1400  CONTINUE                                                          CVC01020
      STORE(JX+2)=STORE(JX+2)+A1(1)+A1(2)+A1(3)+A1(4)*STORE(L1C)+A1(5)
     2 *STORE(L1C+1)+A1(6)*STORE(L1C+2)
      IF(I)1600,1600,1500                                               CVC01050
C--'ANISO' ATOM                                                         CVC01060
1450  CONTINUE                                                          CVC01070
      if ((i .eq. 1).AND. (iasym .eq. 1)) then
c           dont restrain first atom
            do jy = 1,6
              a1(jy) = 0
            enddo
      endif
      CALL XADUIJ                                                       CVC01080
C--CHECK IF THIS THE FIRST OR SECOND ATOM                               CVC01090
      IF(I)1600,1600,1500                                               CVC01100
1500  CONTINUE                                                          CVC01110
      JO=JB                                                             CVC01120
      JX=JV                                                             CVC01130
      DO 1550 J=1,6                                                     CVC01140
c      A1(J)=-A1(J)                                                      CVC01150
      a1(j)=-a1(j+6)*e                                                    CVC00920
       print *, "Vib-derivs", a1(j)
1550  CONTINUE                                                          CVC01160
      I=I-1                                                             CVC01170
      GOTO 1350                                                         CVC01180
C--CALCULATE THE MEAN VALUE AND THE DIFFERENCE                          CVC01190
1600  CONTINUE                                                          CVC01200
      JC=ISTORE(JA+16)                                                  CVC01210
      JD=ISTORE(JB+16)                                                  CVC01220
      SUM=0.                                                            CVC01230
      D=0.                                                              CVC01240
      DO 1650 I=1,6 
c      write(123,'(a,3f12.6)') 'Mean',  store(jc+14),store(jd+14)
c      for the asymmetric restraint, should we NOT compute the mean?
      SUM=SUM+(STORE(JC+14)+STORE(JD+14))*A1(I+6)                       CVC01260
      A1(I)=STORE(JC+14)-STORE(JD+14)                                   CVC01270
      D=D+A1(I)*A1(I+6)                                                 CVC01280
      JC=JC+2                                                           CVC01290
      JD=JD+2                                                           CVC01300
1650  CONTINUE                                                          CVC01310
      STORE(LCG+4)=0.5*(DUMP+SUM*E)                                     CVC01320
      D=D*E                                                             CVC01330
      STORE(L22PD+2)=DUMP-D                                             CVC01340
C--CALCULATE THE DERIVATIVES FOR THE POSITIONAL COORDS.                 CVC01350
      ESAVE=4.*E                                                            CVC01360
      V=(F*O+G*T+H*S)*STORE(L1P2)                                       CVC01370
      W=(F*T+G*P+H*R)*STORE(L1P2+1)                                     CVC01380
      X=(F*S+G*R+H*Q)*STORE(L1P2+2)                                     CVC01390
      F=STORE(L1M1)*V+STORE(L1M1+3)*W+STORE(L1M1+6)*X-F*D/STORE(L1P2)   CVC01400
      G=STORE(L1M1+1)*V+STORE(L1M1+4)*W+STORE(L1M1+7)                   CVC01410
     2 *X-G*D/STORE(L1P2+1)                                             CVC01420
      H=STORE(L1M1+2)*V+STORE(L1M1+5)*W+STORE(L1M1+8)                   CVC01430
     2 *X-H*D/STORE(L1P2+2)                                             CVC01440
      JO=JA
      IF (IASYM .EQ. 1) THEN
         E = 0.                                                             CVC01450
      ELSE
         E = ESAVE
      ENDIF
      CALL XADXYZ                                                       CVC01460
      JO=JB                                                             CVC01470
      E=-ESAVE                                                              CVC01480
      CALL XADXYZ                                                       CVC01490
      MCA=JA                                                            CVC01500
      STORE(L22PD+1) = STORE(LCG+3)                                     CVC01510
      CALL XFMPDQ                                                       CVC01520
      JA=ISTORE(JB)                                                     CVC01530
      IF(JA)1750,1750,1000                                              CVC01540
1750  CONTINUE                                                          CVC01550
cdjwapr99}
      RETURN
      END
C
CODE FOR XCVCX
      SUBROUTINE XCVCX(iaxis,iasym)
C--CALCULATE VIBRATION RESTRAINTS
C
C      IAXIS = 1 FOR XZ COVARIANCE
C      IAXIS = 2 FOR YZ COVARIANCE
C      IAXIS = 3 FOR ZZ VARIANCE
C
C      IASYM = 1 FOR ASYMMETRIC OTHERWISE 0
C
C--THE VARIABLES IN 'XWORK' ARE USED AS FOLLOWS :
C
C  P  DU(B)/DU(22)
C  .
C  .
C  T  DU(B)/DU(12)
C
C--SUBSEQUENTLY O TO T ARE USED FOR THE DIFFERENCES BETWEEN THE
C  THE TWO VALUES OF EACH VIBRATION PARAMETER
C
C--
      INCLUDE 'ISTORE.INC'
C
      DIMENSION A1(12)
      DIMENSION ROT3(3)
      DIMENSION ROT2(3)
      DIMENSION ROT1(3)
      DIMENSION ANAXIS(3)
      DIMENSION DIFF_VEC(3)
	  
      DIMENSION U_L_1(6)
      DIMENSION U_L_2(6)
      DIMENSION U_ASSIGN (9)
      DIMENSION U_M_1(3,3)
      DIMENSION U_M_2(3,3)
      DIMENSION B_M(3,3)
      DIMENSION A_M(3,3)	  
      DIMENSION R_M(3,3)
      DIMENSION RA(3,3)
      DIMENSION RAB(3,3)
      DIMENSION UBAR_1(3,3)
      DIMENSION UBAR_2(3,3)
      DIMENSION RABUBAR_1(3,3)
      DIMENSION RABUBAR_2(3,3)

      INTEGER M_COUNT	  

      REAL CHECK_CAL_1
      REAL CHECK_CAL_2
      REAL DIFF_VAL
      REAL MEAN_VAL
	  
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (O,A1(1))    ! Note well
C
C--SET UP A FEW CONSTANTS                                        
      DUMP=STORE(LCG+4)   ! The 'observed value' of the restraint
      JA=LCA              ! Address of first parameter block header                                      
      NCA=2                                                             
C--SET UP THE ADDRESSES OF THE ATOMS                                    
1000  CONTINUE                                                          
      JB=ISTORE(JA)             ! Address of next parameter block                                        
      JP=ISTORE(JA+6)           ! Address of first parameter (U11) for atom 1                                        
      JV=ISTORE(JB+6)           ! Address of first parameter (U11) for atom 2                                        
C--CHECK THAT BOTH ATOMS ARE ANISO AND IF NOT MODIFY ACCORDINGLY        
      JX=JP                                                             
      JC=JA                                                             
      DO I=1,2 
         JD=ISTORE(JC+16)   !Address of atom in L5
C--CHECK IF THE ATOM IS ANISO                                           
         IF(ABS(STORE(JD+6)) .gt. zero) THEN
C--'ISO' ATOM  -  MODIFY THE ENTRY IN THE COORDINATE SECTION            
            ISTORE(JC+5)=4         ! Reduce the number of restrained parameters to x,y,z,iso
            ISTORE(JX)=-1000000    ! Remove link to next parameter (U22- there isn't one)                                     
            ISTORE(JX+1)=8         ! Where they start 
C--SET THE EQUIVALENT ANISO TEMPERATURE FACTORS FOR THE ATOM
            JE=JD                                                          
            JF=L1C+2                                                       
            DO J=L1C,JF                                                  
               STORE(JE+14)=STORE(JD+14)
               STORE(JE+20)=STORE(JD+14)*STORE(J)                        
               JE=JE+2                                                   
            END DO
            STORE(JD+6)=0.
         END IF
C--PASS ONTO THE SECOND OF THE PAIR                                     
         JX=JV                                                          
         JC=JB                                                          
      END DO

C--CALCULATE THE INTERNUCLEAR DISTANCE                                  
      JO=JA  
      JS=JB  
      JQ=ISTORE(JO+16)
      JU=ISTORE(JS+16)

C Here is the interatomic vector in crystal fractions:	  
      A=STORE(JQ+8)-STORE(JU+8)
      B=STORE(JQ+10)-STORE(JU+10)
      C=STORE(JQ+12)-STORE(JU+12)

	     DIFF_VEC(1) = A
	     DIFF_VEC(2) = B
	     DIFF_VEC(3) = C
	  
	     ANAXIS(1) = 1.0
	     ANAXIS(2) = 0.0
	     ANAXIS(3) = 0.0
      
      print *, "Pre-Norm Pre-Orth Bond Vec"
      print *, A, B, C
      print *,	  
	  
      CALL XMLTTM(STORE(L1O1),DIFF_VEC,ROT3(1),3,3,1)  ! Multiply diffvec by orthogonalisation matrix
      print *, "Pre-Norm Orth Bond Vec"
      print *, (ROT3(I), I=1,3)
      print *,
      CALL NORM3(ROT3) !Normalise
C Take cross product with x axis (unless angle is too close to zero, in which case, use y.

       VANGL = FDPROD(ROT3, ANAXIS)	  ! Dot product to get angle
       IF (ABS(VANGL) .GT. 0.95) THEN  ! Almost parallel, use y-axis instead.
	      print *, "Bond // to x-axis"
	      ANAXIS(1) = 0.0
	 	  ANAXIS(2) = 1.0
       END IF
	   
	   CALL NCROP3(ROT3, ANAXIS, ROT2)  !Axis 2 perp to 3 and X-axis (or y if too close to x)
	   CALL NCROP3(ROT2, ROT3, ROT1)   ! Axis 1 perp to 2 an 3.


       AST = STORE(L1P2)
       BST = STORE(L1P2+1)
       CST = STORE(L1P2+2)
	   
C The orthog matrix. It is an upper triangle assuming fortran column ordering. 
C (i.e. offsets +1 +2 +5 are zero).
C Derivatives go here. These values (iaxis*n) are currently just used for testing.


C Here, compute

C IF IAXIS = 1, then UXZBAR, =2 for UYZBAR, IAXIS = 3 for UZZBAR
          
	  
      IF ( IAXIS .EQ. 1 ) THEN   !UXZBAR

C      #### XZ DERIVS ####

C      dX/dU11
         A1(7)= (AST*ROT1(1)*STORE(L1O1+0) + AST*ROT1(2)*STORE(L1O1+3) 
     1         + AST*ROT1(3)*STORE(L1O1+6))*(AST*ROT3(1)*STORE(L1O1+0) 
     1         + AST*ROT3(2)*STORE(L1O1+3) + AST*ROT3(3)*STORE(L1O1+6))
C      dX/dU22
         A1(8)= (BST*ROT1(1)*STORE(L1O1+1) + BST*ROT1(2)*STORE(L1O1+4) 
     1         + BST*ROT1(3)*STORE(L1O1+7))*(BST*ROT3(1)*STORE(L1O1+1) 
     1         + BST*ROT3(2)*STORE(L1O1+4) + BST*ROT3(3)*STORE(L1O1+7))
C      dX/dU33
         A1(9)= (CST*ROT1(1)*STORE(L1O1+2) + CST*ROT1(2)*STORE(L1O1+5) 
     1         + CST*ROT1(3)*STORE(L1O1+8))*(CST*ROT3(1)*STORE(L1O1+2) 
     1         + CST*ROT3(2)*STORE(L1O1+5) + CST*ROT3(3)*STORE(L1O1+8))
C      dX/dU23
         A1(10)= (BST*ROT1(1)*STORE(L1O1+1) + BST*ROT1(2)*STORE(L1O1+4) 
     1         + BST*ROT1(3)*STORE(L1O1+7))*(CST*ROT3(1)*STORE(L1O1+2) 
     1         + CST*ROT3(2)*STORE(L1O1+5) + CST*ROT3(3)*STORE(L1O1+8)) 
     1         + (BST*ROT3(1)*STORE(L1O1+1) + BST*ROT3(2)*STORE(L1O1+4) 
     1         + BST*ROT3(3)*STORE(L1O1+7))*(CST*ROT1(1)*STORE(L1O1+2) 
     1         + CST*ROT1(2)*STORE(L1O1+5) + CST*ROT1(3)*STORE(L1O1+8))
C      dX/dU13
         A1(11)= (AST*ROT1(1)*STORE(L1O1+0) + AST*ROT1(2)*STORE(L1O1+3) 
     1         + AST*ROT1(3)*STORE(L1O1+6))*(CST*ROT3(1)*STORE(L1O1+2) 
     1         + CST*ROT3(2)*STORE(L1O1+5) + CST*ROT3(3)*STORE(L1O1+8)) 
     1         + (AST*ROT3(1)*STORE(L1O1+0) + AST*ROT3(2)*STORE(L1O1+3) 
     1         + AST*ROT3(3)*STORE(L1O1+6))*(CST*ROT1(1)*STORE(L1O1+2) 
     1         + CST*ROT1(2)*STORE(L1O1+5) + CST*ROT1(3)*STORE(L1O1+8))
C      dX/dU12
         A1(12)= (AST*ROT1(1)*STORE(L1O1+0) + AST*ROT1(2)*STORE(L1O1+3) 
     1         + AST*ROT1(3)*STORE(L1O1+6))*(BST*ROT3(1)*STORE(L1O1+1) 
     1         + BST*ROT3(2)*STORE(L1O1+4) + BST*ROT3(3)*STORE(L1O1+7)) 
     1         + (AST*ROT3(1)*STORE(L1O1+0) + AST*ROT3(2)*STORE(L1O1+3) 
     1         + AST*ROT3(3)*STORE(L1O1+6))*(BST*ROT1(1)*STORE(L1O1+1) 
     1         + BST*ROT1(2)*STORE(L1O1+4) + BST*ROT1(3)*STORE(L1O1+7))
	 
	     PRINT *,"Derivatives XZ", (A1(I), I=7,12)
		
        ELSE IF ( IAXIS .EQ. 2) THEN  !UYZBAR

C      #### YZ DERIVS ####

C      dX/dU11
         A1(7)= (AST*ROT2(1)*STORE(L1O1+0) + AST*ROT2(2)*STORE(L1O1+3) 
     1         + AST*ROT2(3)*STORE(L1O1+6))*(AST*ROT3(1)*STORE(L1O1+0) 
     1         + AST*ROT3(2)*STORE(L1O1+3) + AST*ROT3(3)*STORE(L1O1+6))
C      dX/dU22
         A1(8)= (BST*ROT2(1)*STORE(L1O1+1) + BST*ROT2(2)*STORE(L1O1+4) 
     1         + BST*ROT2(3)*STORE(L1O1+7))*(BST*ROT3(1)*STORE(L1O1+1) 
     1         + BST*ROT3(2)*STORE(L1O1+4) + BST*ROT3(3)*STORE(L1O1+7))
C      dX/dU33
         A1(9)= (CST*ROT2(1)*STORE(L1O1+2) + CST*ROT2(2)*STORE(L1O1+5) 
     1         + CST*ROT2(3)*STORE(L1O1+8))*(CST*ROT3(1)*STORE(L1O1+2) 
     1         + CST*ROT3(2)*STORE(L1O1+5) + CST*ROT3(3)*STORE(L1O1+8))
C      dX/dU23
         A1(10)= (BST*ROT2(1)*STORE(L1O1+1) + BST*ROT2(2)*STORE(L1O1+4) 
     1         + BST*ROT2(3)*STORE(L1O1+7))*(CST*ROT3(1)*STORE(L1O1+2) 
     1         + CST*ROT3(2)*STORE(L1O1+5) + CST*ROT3(3)*STORE(L1O1+8)) 
     1         + (BST*ROT3(1)*STORE(L1O1+1) + BST*ROT3(2)*STORE(L1O1+4) 
     1         + BST*ROT3(3)*STORE(L1O1+7))*(CST*ROT2(1)*STORE(L1O1+2) 
     1         + CST*ROT2(2)*STORE(L1O1+5) + CST*ROT2(3)*STORE(L1O1+8))
C      dX/dU13
         A1(11)= (AST*ROT2(1)*STORE(L1O1+0) + AST*ROT2(2)*STORE(L1O1+3) 
     1         + AST*ROT2(3)*STORE(L1O1+6))*(CST*ROT3(1)*STORE(L1O1+2) 
     1         + CST*ROT3(2)*STORE(L1O1+5) + CST*ROT3(3)*STORE(L1O1+8)) 
     1         + (AST*ROT3(1)*STORE(L1O1+0) + AST*ROT3(2)*STORE(L1O1+3) 
     1         + AST*ROT3(3)*STORE(L1O1+6))*(CST*ROT2(1)*STORE(L1O1+2) 
     1         + CST*ROT2(2)*STORE(L1O1+5) + CST*ROT2(3)*STORE(L1O1+8))
C      dX/dU12
         A1(12)= (AST*ROT2(1)*STORE(L1O1+0) + AST*ROT2(2)*STORE(L1O1+3) 
     1         + AST*ROT2(3)*STORE(L1O1+6))*(BST*ROT3(1)*STORE(L1O1+1) 
     1         + BST*ROT3(2)*STORE(L1O1+4) + BST*ROT3(3)*STORE(L1O1+7)) 
     1         + (AST*ROT3(1)*STORE(L1O1+0) + AST*ROT3(2)*STORE(L1O1+3) 
     1         + AST*ROT3(3)*STORE(L1O1+6))*(BST*ROT2(1)*STORE(L1O1+1) 
     1         + BST*ROT2(2)*STORE(L1O1+4) + BST*ROT2(3)*STORE(L1O1+7))
	 
	     PRINT *,"Derivatives YZ", (A1(I), I=7,12)
		 
		
        ELSE   !UZZBAR

C      ##### ZZ DERIVS ####

C      dX/dU11
        A1(7)= (AST*ROT3(1)*STORE(L1O1+0) + AST*ROT3(2)*STORE(L1O1+3) 
     1       + AST*ROT3(3)*STORE(L1O1+6))**2
C      dX/dU22
        A1(8)= (BST*ROT3(1)*STORE(L1O1+1) + BST*ROT3(2)*STORE(L1O1+4) 
     1       + BST*ROT3(3)*STORE(L1O1+7))**2
C      dX/dU33
        A1(9)= (CST*ROT3(1)*STORE(L1O1+2) + CST*ROT3(2)*STORE(L1O1+5) 
     1       + CST*ROT3(3)*STORE(L1O1+8))**2
C      dX/dU23
        A1(10)= 2*(BST*ROT3(1)*STORE(L1O1+1) + BST*ROT3(2)*STORE(L1O1+4) 
     1       + BST*ROT3(3)*STORE(L1O1+7))*(CST*ROT3(1)*STORE(L1O1+2) 
     1       + CST*ROT3(2)*STORE(L1O1+5) + CST*ROT3(3)*STORE(L1O1+8))
C      dX/dU13
        A1(11)= 2*(AST*ROT3(1)*STORE(L1O1+0) + AST*ROT3(2)*STORE(L1O1+3) 
     1       + AST*ROT3(3)*STORE(L1O1+6))*(CST*ROT3(1)*STORE(L1O1+2) 
     1       + CST*ROT3(2)*STORE(L1O1+5) + CST*ROT3(3)*STORE(L1O1+8))
C      dX/dU12
        A1(12)= 2*(AST*ROT3(1)*STORE(L1O1+0) + AST*ROT3(2)*STORE(L1O1+3) 
     1       + AST*ROT3(3)*STORE(L1O1+6))*(BST*ROT3(1)*STORE(L1O1+1) 
     1       + BST*ROT3(2)*STORE(L1O1+4) + BST*ROT3(3)*STORE(L1O1+7))
	 	    
            PRINT *,			
            PRINT *,"Derivatives ZZ:"
            PRINT *,A1(7)
            PRINT *,A1(8)
            PRINT *,A1(9)
            PRINT *,A1(10)
            PRINT *,A1(11)
            PRINT *,A1(12)
		    PRINT *,
            PRINT *,"R Matrix:"
            PRINT *,(ROT1(I), I=1,3)
            PRINT *,(ROT2(I), I=1,3)
            PRINT *,(ROT3(I), I=1,3)
            PRINT *,
            PRINT *,"A Matrix:"
		    PRINT *,(STORE(L1O1+I), I=0,8)
            PRINT *, SHAPE(STORE(L1O1))            
            PRINT *,
            PRINT *,"B Matrix Values:"
            PRINT *,AST,BST,CST
            PRINT *,			
			
			
			
			
			
			
		END IF

      DO  J=1,6                                                     
         a1(j)=a1(j+6) 
      END DO

      JO=JA   
      JX=JP   
      I=1     

	  
1300  CONTINUE                                                          CVC00930
      JO=JA                                                             CVC00940
      JX=JP                                                             CVC00950
      I=1                                                               CVC00960
C--STORE THE DERIVATIVES                                                CVC00970
1350  CONTINUE                                                          CVC00980
C--CHECK IF THIS ATOM IS ISO AND NOT ANISO                              CVC00990
      IF(ISTORE(JO+5)-4)1450,1400,1450                                  CVC01000
C--'ISO' ATOM                                                           CVC01010
1400  CONTINUE                                                          CVC01020
      STORE(JX+2)=STORE(JX+2)+A1(1)+A1(2)+A1(3)+A1(4)*STORE(L1C)+A1(5)
     2 *STORE(L1C+1)+A1(6)*STORE(L1C+2)
	 
	 
      IF(I)1600,1600,1500 !Goto 1500 first time, 1600 second time
	  
C--'ANISO' ATOM                                                         CVC01060
1450  CONTINUE                                                          CVC01070
      if ((i .eq. 1).AND. (iasym .eq. 1)) then
c           dont restrain first atom
            print *, "Asym"
            do jy = 1,6
              a1(jy) = 0
            enddo
      endif
      CALL XADUIJ                                                       CVC01080
C--CHECK IF THIS THE FIRST OR SECOND ATOM                               CVC01090
     
	 IF(I)1600,1600,1500 !Goto 1500 first time, 1600 second time

1500  CONTINUE                                                          CVC01110
      JO=JB                                                             CVC01120
      JX=JV                                                             CVC01130
      DO 1550 J=1,6                                                     CVC01140
c      A1(J)=-A1(J)                                                      CVC01150
      a1(j)=-a1(j+6)                                                    CVC00920
       print *, "Vib-derivs", a1(j)
1550  CONTINUE                                                          CVC01160
      I=I-1                                                             CVC01170
      GOTO 1350                                                         CVC01180
C--CALCULATE THE MEAN VALUE AND THE DIFFERENCE                          CVC01190
	  
1600  CONTINUE
	  
	  
C--DEFINE U, B, A & R Matrices

      JC=ISTORE(JA+16)                                                  CVC01210	 
      JD=ISTORE(JB+16)                                                  CVC01220
      DO I=1,6
         U_L_1(I) = (STORE(JC+14))	  
         U_L_2(I) = (STORE(JD+14))	  
         JC=JC+2                                                           CVC01290
         JD=JD+2                                                           CVC01300
      END DO
	  	   			 		
      
C     U Matrices
      M_COUNT = 1      
      U_ASSIGN = (/ 1, 6, 5, 6, 2, 4, 5, 4, 3 /)
      DO I=1,3
	     DO J=1,3
             U_M_1(J,I) = U_L_1(U_ASSIGN(M_COUNT))
             U_M_2(J,I) = U_L_2(U_ASSIGN(M_COUNT))
	         M_COUNT = M_COUNT+1
	     END DO
      END DO	

C     B Matrix
      M_COUNT = 1	  
      DO I=1,3
	     DO J=1,3
		     IF (I .EQ. J) THEN
			     IF (I .EQ. 1) THEN
				     B_M(J,I) = AST
			     ELSE IF (I .EQ. 2) THEN
				     B_M(J,I) = BST
			     ELSE
				     B_M(J,I) = CST
			     END IF
             ELSE			 
                 B_M(I,J) = 0
	         END IF
	     END DO
      END DO			  
				
C     A Matrix
      M_COUNT = 0		
      DO I=1,3
	     DO J=1,3
             A_M(I,J) = STORE(L1O1+M_COUNT)
	         M_COUNT = M_COUNT+1
	     END DO
      END DO		

C     R Matrix		
      DO I=1,3
	     DO J=1,3
		     IF (J .EQ. 1) THEN
                 R_M(J,I) = ROT1(I)
             ELSE IF (J .EQ. 2) THEN
                 R_M(J,I) = ROT2(I)
             ELSE
                 R_M(J,I) = ROT3(I)
             END IF				 
	     END DO
      END DO	  
	  
            PRINT *,
            PRINT *,"Check U"
            PRINT *,
            PRINT *,"1: ",U_L_1			
            PRINT *,"2: ",U_L_2
            PRINT *,
            PRINT *,"Matrix Tests"
            PRINT *,
            PRINT *, "U1"
            DO I=1,3
			     PRINT *, U_M_1(I,1), U_M_1(I,2), U_M_1(I,3)
		    END DO
            PRINT *, "U2"
            DO I=1,3         
		         PRINT *, U_M_2(I,1), U_M_2(I,2), U_M_2(I,3)
		    END DO
            PRINT *, "B"
            DO I=1,3
                 PRINT *, B_M(I,1), B_M(I,2), B_M(I,3)
		    END DO
		    PRINT *, "A"
            DO I=1,3
                 PRINT *, A_M(I,1), A_M(I,2), A_M(I,3)
		    END DO
            PRINT *,  "R"
            DO I=1,3
                 PRINT *, R_M(I,1), R_M(I,2), R_M(I,3)
		    END DO
            PRINT *,
	 

C-- RUN RABUBAR MULTIPLICATION

         CALL XMLTMM(R_M, A_M, RA, 3, 3, 3)
	     CALL XMLTMT(RA, B_M, RAB, 3, 3, 3)
	     CALL XMLTMT(U_M_1, RAB, UBAR_1, 3, 3, 3)		 
         CALL XMLTMM(RAB, UBAR_1, RABUBAR_1, 3, 3, 3)
	     CALL XMLTMT(U_M_2, RAB, UBAR_2, 3, 3, 3)		 
         CALL XMLTMM(RAB, UBAR_2, RABUBAR_2, 3, 3, 3)

		 
C--CALCULATE THE MEAN VALUE AND THE DIFFERENCE                          CVC01190
         
	     IF ( IAXIS .EQ. 1 ) THEN
             CHECK_CAL_1 = RABUBAR_1(3,1)		 
             CHECK_CAL_2 = RABUBAR_2(3,1)
	     ELSE IF ( IAXIS .EQ. 2 ) THEN
             CHECK_CAL_1 = RABUBAR_1(3,2)		 
             CHECK_CAL_2 = RABUBAR_2(3,2)		 	 
	     ELSE
             CHECK_CAL_1 = RABUBAR_1(3,3)		 
             CHECK_CAL_2 = RABUBAR_2(3,3)			 
         END IF

         DIFF_VAL = CHECK_CAL_1 - CHECK_CAL_2		 
	     MEAN_VAL = (CHECK_CAL_1 + CHECK_CAL_2)/2 
			 
		    PRINT *,
            PRINT *, "RA"
            DO I=1,3
			     PRINT *, RA(I,1), RA(I,2), RA(I,3)			
            END DO		    
		    PRINT *, "RAB"
            DO I=1,3
			     PRINT *, RAB(I,1), RAB(I,2), RAB(I,3)			
            END DO
	    	PRINT *, "RABUBAR_1"
            DO I=1,3
			     PRINT *, RABUBAR_1(I,1), RABUBAR_1(I,2), RABUBAR_1(I,3)
		    END DO
            PRINT *, "RABUBAR_2"
            DO I=1,3         
		         PRINT *, RABUBAR_2(I,1), RABUBAR_2(I,2), RABUBAR_2(I,3)
		    END DO	 
            PRINT *, 
		    PRINT *, 'Delta: ', DIFF_VAL	 
		    PRINT *, 'Mean: ', MEAN_VAL	 
			 
C Here, you need to set D to be the computed value of the difference in the covariances
C Note that DUMP is the target difference (and should usually be zero).
C You need to set SUM to be the compute

         STORE(LCG+4)=0.5*(DUMP+DIFF_VAL)                                       CVC01320
         STORE(L22PD+2)=DUMP-DIFF_VAL ! Difference between restraint target (DUMP) and computed from current parameters (D)
         MCA=JA                                                            CVC01500
         STORE(L22PD+1) = STORE(LCG+3)                                     CVC01510
         CALL XFMPDQ                                                       CVC01520
         JA=ISTORE(JB)                                                     CVC01530

      IF(JA .GT. 0)GOTO 1000

      RETURN
      END
	  
	  
C
CODE FOR XCMDC
      SUBROUTINE XCMDC(IASYM)
C--CALCULATE MEAN DISTANCE RESTRAINTS
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET UP THE POINTERS TO THE TOP OF THE WORK STACK
      DUMP=STORE(LCG+4)
      STORE(LCG+4)=0.
      JJ=0
      JH=ISTORE(LCG+2)+LC
      JI=JH
      JA=LCA
C--CALCULATE THE PARTIAL DIFFERENTIALS INITIALLY
1000  CONTINUE
      E=1.0
      CALL XCDPD(IASYM)
      STORE(LCG+4)=STORE(LCG+4)+D
      JJ=JJ+1
      STORE(JI)=D
      JI=JI+1
      JA=ISTORE(JB)
      IF(JA)1050,1050,1000
C--END OF THE FIRST PASS  -  PASS THROUGH NOW AND ACCUMULATE
1050  CONTINUE
      STORE(LCG+4)=STORE(LCG+4)/FLOAT(JJ)+DUMP
      JI=JH
      JA=LCA
      NCA=2
1100  CONTINUE
      JB=ISTORE(JA)
      MCA=JA
      STORE(L22PD+2)=STORE(LCG+4)-STORE(JI)
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
      JI=JI+1
      JA=ISTORE(JB)
      IF(JA)1150,1150,1100
1150  CONTINUE
      RETURN
      END
C
CODE FOR XCDDC
      SUBROUTINE XCDDC(iasym)
C--CALCULATE DISTANCE DIFFERENCE RESTRAINTS
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET UP THE POINTERS TO THE TOP OF THE WORK STACK
      DUMP=STORE(LCG+4)
C--FIND THE ADDRESS OF THE DISTANCE STORAGE AREA
      JH=ISTORE(LCG+2)+LC
      JI=JH
      JA=LCA
C--CALCULATE THE PARTIAL DIFFERENTIALS INITIALLY
1000  CONTINUE
      E=-1.0
      CALL XCDPD(IASYM)
C--STORE THE DISTANCE IN THE WORK STACK AREA
      STORE(JI)=D
      JI=JI+1
      JA=ISTORE(JB)
      IF(JA)1050,1050,1000
C--END OF THE FIRST PASS  -  PASS THROUGH NOW AND ACCUMULATE
1050  CONTINUE
      JI=JH
      JA=LCA
      NCA=4
1100  CONTINUE
C--NEXT DISTANCE  -  UPDATE DISTANCE AND ATOM POINTERS
      JJ=JI+1
      JB=ISTORE(JA)
      JD=ISTORE(JB)
C--REVERSE THE SIGNS OF THE DERIVATIVES FOR THE CURRENT
C  COMPARISON DISTANCE
      JP=ISTORE(JA+6)
      JQ=ISTORE(JB+6)
      DO 1150 JS=1,3
      STORE(JP+2)=-STORE(JP+2)
      STORE(JQ+2)=-STORE(JQ+2)
      JP=ISTORE(JP)
      JQ=ISTORE(JQ)
1150  CONTINUE
C--CHECK THAT THERE REMAIN AT LEAST ONE MORE DISTANCE FOR COMPARISON
      IF(JD)1350,1350,1200
C--START THE PASS THROUGH THE REMAINING DISTANCES FOR THIS COMPARISON ON
1200  CONTINUE
      MCA=JA
      JE=JD
1250  CONTINUE
      ISTORE(JB)=JE
      STORE(L22PD+2)=DUMP-STORE(JI)+STORE(JJ)
      STORE(LCG+4)=0.5*(DUMP+STORE(JI)+STORE(JJ))
      JJ=JJ+1
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
      JF=ISTORE(JE)
      JE=ISTORE(JF)
C--CHECK IF THERE ARE MORE DISTANCES FOR THIS DISTANCE
      IF(JE)1300,1300,1250
C--END OF THIS DISTANCE  -  MOVE TO THE NEXT
1300  CONTINUE
      JI=JI+1
      ISTORE(JB)=JD
      JA=JD
      GOTO 1100
1350  CONTINUE
      RETURN
      END
C
CODE FOR XCDC
      SUBROUTINE XCDC(iasym)
C--CALCULATE DISTANCE RESTRAINTS
C
C    IASYM = 0 FOR NORMAL
C            1 FOR ASYMMETRIC
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET UP THE INITIAL CONSTANTS
      JA=LCA
      NCA=2
C--LOOP FOR EACH INDIVIDUAL RESTRAINT
1000  CONTINUE
      E=1.0
      CALL XCDPD(IASYM)
      STORE(L22PD+2)=STORE(LCG+4)-D
      MCA=JA
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
      JA=ISTORE(JB)
      IF(JA)1050,1050,1000
1050  CONTINUE
      RETURN
      END
C
C
CODE FOR XCEC
      SUBROUTINE XCEC(IASYM)
C--CALCULATE ENERGY RESTRAINTS
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET UP THE INITIAL CONSTANTS
      JA=LCA
      NCA=2
C----- GET POWER FACTOR FROM PROCESSED ESD
      POWER = 1. / SQRT( STORE(LCG+3) )
C--LOOP FOR EACH INDIVIDUAL RESTRAINT
1000  CONTINUE
      E=1.0
      CALL XCDPD(IASYM)
      STORE(L22PD+2)=STORE(LCG+4)-D
C----- WEIGHT = 10000. * (D(TARGET)/D(ACTUAL)**(12*POWERFACTOR) )
      STORE(L22PD+1) = 10000 * AMIN1 (10000.,
     1 (STORE(LCG+4) / (AMAX1( D, 1.)) ) ** (12.*POWER) )
      MCA=JA
      CALL XFMPDQ
      JA=ISTORE(JB)
      IF(JA)1050,1050,1000
1050  CONTINUE
      RETURN
      END
C
CODE FOR XCMAC
      SUBROUTINE XCMAC
C--CALCULATE MEAN ANGLE RESTRAINTS
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
c	  INCLUDE 'XUNITS.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CONVERT THE ANGLES AND WEIGHTS TO RADIANS
      STORE(LCG+3)=STORE(LCG+3)/(DTR*DTR)
      DUMP=STORE(LCG+4)*DTR
      STORE(LCG+4)=0.
      JJ=0
C--SET UP THE POINTERS TO THE TOP OF THE WORK STACK
      JH=ISTORE(LCG+2)+LC
      JI=JH
      JA=LCA
C--CALCULATE THE PARTIAL DIFFERENTIALS INITIALLY
1000  CONTINUE
      E=1.0
      CALL XCAPD
      STORE(LCG+4)=STORE(LCG+4)+V
      JJ=JJ+1
      STORE(JI)=V
      JI=JI+1
      JA=ISTORE(JC)
      IF(JA)1050,1050,1000
C--END OF THE FIRST PASS  -  PASS THROUGH NOW AND ACCUMULATE
1050  CONTINUE
      STORE(LCG+4)=STORE(LCG+4)/FLOAT(JJ)+DUMP
      JI=JH
      JA=LCA
      NCA=3
1100  CONTINUE
      JB=ISTORE(JA)
      JC=ISTORE(JB)
      MCA=JA
      STORE(L22PD+2)=STORE(LCG+4)-STORE(JI)
      STORE(L22PD+1) = STORE(LCG+3)
c	  WRITE(NCWU,*)'Forming PDQ for mean angle restraint'
      CALL XFMPDQ
      JI=JI+1
      JA=ISTORE(JC)
      IF(JA)1150,1150,1100
1150  CONTINUE
      RETURN
      END
C
CODE FOR XCADC
      SUBROUTINE XCADC
C--CALCULATE MULTIPLE ANGLE RESTRAINTS
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
c	  INCLUDE 'XUNITS.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CONVERT THE ANGLES AND WEIGHTS TO RADIANS
      STORE(LCG+3)=STORE(LCG+3)/(DTR*DTR)
      DUMP=STORE(LCG+4)*DTR
C--SET UP THE POINTERS TO THE TOP OF THE WORK STACK
      JH=ISTORE(LCG+2)+LC
      JI=JH
      JA=LCA
C--CALCULATE THE PARTIAL DIFFERENTIALS INITIALLY
1000  CONTINUE
      E=-1.0
      CALL XCAPD
      STORE(JI)=V
      JI=JI+1
      JA=ISTORE(JC)
      IF(JA)1050,1050,1000
C--END OF THE FIRST PASS  -  PASS THROUGH NOW AND ACCUMULATE
1050  CONTINUE
      JI=JH
      JA=LCA
      NCA=6
1100  CONTINUE
      JJ=JI+1
      JB=ISTORE(JA)
      JC=ISTORE(JB)
      JD=ISTORE(JC)
C--REVERSE THE SIGNS OF THE CURRENT COMPARISON ANGLE
      JP=ISTORE(JA+6)
      JQ=ISTORE(JB+6)
      JV=ISTORE(JC+6)
      DO 1150 JS=1,3
      STORE(JP+2)=-STORE(JP+2)
      STORE(JQ+2)=-STORE(JQ+2)
      STORE(JV+2)=-STORE(JV+2)
      JP=ISTORE(JP)
      JQ=ISTORE(JQ)
      JV=ISTORE(JV)
1150  CONTINUE
C--CHECK THAT THERE REMAIN AT LEAST ONE MORE DISTANCE FOR COMPARISON
      IF(JD)1350,1350,1200
1200  CONTINUE
      MCA=JA
      JE=JD
1250  CONTINUE
      ISTORE(JC)=JE
      STORE(L22PD+2)=DUMP-STORE(JI)+STORE(JJ)
      STORE(LCG+4)=0.5*(DUMP+STORE(JI)+STORE(JJ))
      JJ=JJ+1
      STORE(L22PD+1) = STORE(LCG+3)
c 	  WRITE(NCWU,*)'Forming PDQ for multi angle restraint'
      CALL XFMPDQ
      JF=ISTORE(JE)
      JG=ISTORE(JF)
      JE=ISTORE(JG)
      IF(JE)1300,1300,1250
1300  CONTINUE
      JI=JI+1
      ISTORE(JC)=JD
      JA=JD
      GOTO 1100
1350  CONTINUE
      RETURN
      END
C
CODE FOR XCAC
      SUBROUTINE XCAC
C--CALCULATE ANGLE RESTRAINTS
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
c	  INCLUDE 'XUNITS.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CONVERT THE ANGLES AND WEIGHTS TO RADIANS
      STORE(LCG+3)=STORE(LCG+3)/(DTR*DTR)
      STORE(LCG+4)=STORE(LCG+4)*DTR
C--SET UP THE INITIAL CONSTANTS
      JA=LCA
      NCA=3
C--LOOP FOR EACH INDIVIDUAL RESTRAINT
1000  CONTINUE
      E=1.0
      CALL XCAPD
      STORE(L22PD+2)=STORE(LCG+4)-V
      MCA=JA
      STORE(L22PD+1) = STORE(LCG+3)
c 	  WRITE(NCWU,*)'Forming PDQ for normal angle restraint', 
c     2  STORE(L22PD+1), STORE(L22PD+2)
      CALL XFMPDQ
      JA=ISTORE(JC)
      IF(JA)1050,1050,1000
1050  CONTINUE
      RETURN
      END
C
CODE FOR KPLANE
      FUNCTION KPLANE(IN)
C--CALCULATE THE DERIVATIVES FOR A 'PLANAR' RESTRAINT
C
C  IN  A DUMMY ARGUMENT.
C
C--THE RETURN VALUES OF 'KPLANE' ARE :
C
C  -1  AN ERROR HAS BEEN FOUND.
C  >0  THE NUMBER OF ATOMS IN THE PLANE (>2).
C
C--
C
      DIMENSION FF(3)
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (FF(1),F)
      IDWZAP = IN
C--SET UP THE CORE AREAS FOR THE VARIOUS MATRICES
      KPLANE=NCA
      JS=NFL
      JT=4
C--SET UP THE CENTROID AREA FLAG
      JU=NFL+JT*NCA
C--SET UP THE LATENT ROOTS FLAG
      JV=JU+3
C--SET UP THE LATENT VECTORS FLAG  -  STORED BY COLUMNS
      JW=JV+3
C--SET UP THE NORMAL EQUATIONS AREA
      JX=JW+9
C--SET UP THE WORK AREA OF 4 WORDS
      JY=JX+9
      NFL=JY+4
C--CHECK THAT THERE IS ENOUGH ROOM
      IF(NFL-LFL)1200,1000,1000
C--NOT ENOUGH CORE AVAILABLE
1000  CONTINUE
      CALL XERHDR(0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1050)
c      WRITE(NCAWU,1050)
      WRITE ( CMON ,1050)
      CALL XPRVDU(NCVDU, 1,0)
1050  FORMAT(' Insufficient memory for ''PLANAR'' restraint' )
C--SET THE ERROR RETURN VALUE
1100  CONTINUE
      KPLANE=-1
1150  CONTINUE
      RETURN
C--SET UP THE ATOM COORDINATES IN THE ATOM ARRAY AT 'JS'
1200  CONTINUE
      JA=LCA
      JB=JS
C--CHECK FOR THE END OF THE CHAIN
1250  CONTINUE
      IF(JA)1350,1350,1300
C--FETCH THE COORDINATES FROM THE SPREAD BLOCK  -  SYMMETRY ALREADY ADDE
1300  CONTINUE
      I=ISTORE(JA+16)
      STORE(JB)=STORE(I+8)
      STORE(JB+1)=STORE(I+10)
      STORE(JB+2)=STORE(I+12)
      STORE(JB+3)=1.
      JB=JB+JT
      JA=ISTORE(JA)
      GOTO 1250
C--CALCULATE THE MEAN PLANE
1350  CONTINUE
      IF(KMOLAX(STORE(JS),NCA,JT,STORE(JU),STORE(JV),STORE(JW),
     2 STORE(JX),STORE(JY)))1400,1500,1500
C--NOT ENOUGH ATOMS IN THE GROUP
1400  CONTINUE
      CALL XERHDR(0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1450)
c      WRITE(NCAWU,1450)
      WRITE ( CMON ,1450)
      CALL XPRVDU(NCVDU, 1,0)
1450  FORMAT(' Insufficient atoms to define a plane')
      GOTO 1100
C--CALCULATE THE EQUATION OF THE PLANE
1500  CONTINUE
      CALL XMOLEQ(STORE(JU),STORE(JW),FF(1),D,STORE(JX))
C--NOW SET UP THE FLAGS TO CALCULATE THE DERIVATIVES
      MCA=LCA
      NCA=1
      JB=JS
      E=1.
C--CHECK FOR THE END OF THE CHAIN
1550  CONTINUE
      IF(MCA)1150,1150,1600
C--CALCULATE THE OBSERVED DEVIATION FROM THE PLANE
1600  CONTINUE
      STORE(JB+3)=F*STORE(JB)+G*STORE(JB+1)+H*STORE(JB+2)-D
C--CALCULATE THE DELTA VALUE
      STORE(L22PD+2)=STORE(LCG+4)-STORE(JB+3)
C--ADD IN THE DERIVATIVES
      JO=MCA
      CALL XADXYZ
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
      JB=JB+JT
      MCA=ISTORE(MCA)
      GOTO 1550
      END
C
CODE FOR XSUMCN
      SUBROUTINE XSUMCN(ITYPE)
C
C----- ITYPE = 1 = UNWEIGHTED
C              2 = Z WEIGHTED
C--reSTRAIN THE SUM OF THE SHIFTS OF THE PARAMETERS TO ZERO
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--INDICATE THAT THE FOUND VALUES ARE NOT TO BE STORED
      JS=-1
C--SCAN OVER THE PARAMETERS THAT ARE  STORED
      CALL XGRPSM(ITYPE)
C--SET THE DELTA TO ZERO
      STORE(L22PD+2)=0.
      STORE(LCG+4)=0.
C--ADD IN THE COMPUTED DERIVATIVES FOR THIS RESTRAINT
      MCA=LCA
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
      RETURN
      END
C
CODE FOR KAVERG
      FUNCTION KAVERG(IN)
C--RESTRAIN A GROUP OF PARAMETERS TO THEIR COMMON MEAN
C------ OR LIMIT THE PARAMETER SHIFTS TO APPROXIMATELY ZERO
C
C     IN   +1 COMPUTE DELTA = MEAN - VALUE
C     IN   -1 SET DELTA = 0, FOR 'LIMIT' RESTRAINT
C
C--THE RETURN VALUES OF 'KAVERG' ARE :
C
C  -1  NOT CORE AVAILABLE
C   0  RESTRAINT PROCESSED OKAY.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET UP THE AREA FOR THE STORED VALUES
      JS=MDCS-NCA
C--CHECK FOR CORE OVERFLOW
      IF(NFL+27-JS)1150,1000,1000
C--NOT ENOUGH CORE AVAILABLE
1000  CONTINUE
      CALL XERHDR(0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1050)
c      WRITE(NCAWU,1050)
      WRITE ( CMON ,1050)
      CALL XPRVDU(NCVDU, 1,0)
1050  FORMAT(' Insufficient core for ''AVERAGE'' restraint ')
      KAVERG=-1
C--AND NOW RETURN
1100  CONTINUE
      RETURN
C--SCAN THE PROVIDED PARAMETERS
1150  CONTINUE
      KAVERG=0
      JT=1
      CALL XGRPSM(1)
C--COMPUTE THE AVERAGE VALUE
      A=STORE(LCG+2)/FLOAT(NCA)
      STORE(LCG+4)=STORE(LCG+4)+A
      STORE(LCG+2)=A
C--SET UP THE FLAGS TO ADD IN THE DERIVATIVES
      NCA=1
      JA=LCA
      JU=JS
C--CHECK FOR THE END OF THE PARAMETER HEADER CHAIN
1200  CONTINUE
      IF(JA)1100,1100,1250
C--COMPUTE THE DELTA AND ADD IN THE DERIVATIVES
1250  CONTINUE
      IF (IN) 1260,1260,1270
1260  CONTINUE
C----- 'LIMIT' RESTRAINT - SET DELTA = 0
      STORE(LCG+4) = 0.
      STORE(L22PD+2) = 0.
      GOTO 1280
1270  CONTINUE
C
C----- 'AVERAGE' RESTRAINT - COMPUTE DELTA
      STORE(L22PD+2)=STORE(LCG+4)-STORE(JU)
1280  CONTINUE
      JU=JU+JT
      MCA=JA
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
      JA=ISTORE(JA)
      GOTO 1200
      END
C
CODE FOR XGRPSM
      SUBROUTINE XGRPSM(ITYPE)
C
C----- ITYPE = 1 = UNWEIGHTED
C              2 = Z WEIGHTED
C--COMPUTE THE SUM OF A GROUP OF PARAMETERS
C
C--ON ENTRY THE FOLLOWING VARIABLES MUST BE SET :
C
C  LCA     THE ADDRESS OF THE FIRST ATOM HEADER BLOCK
C  JS      THE ADDRESS AT WHICH TO BEGIN STORING THE FOUND PARAMETER VAL
C          (IF SET NEGATIVE, THE VALUES ARE NOT STORED).
C  JT      THE INCREMENT BETWEEN SUCCESSIVE STORAGE LOCATIONS.
C
C--THE FOLLOWING VARIABLES ARE USED :
C
C  JA      THE ADDRESS OF THE CURRENT HEADER.
C  JO      USED BY 'XADXYZ', TOGETHER WITH OTHERS.
C  JU      CURRENT VALUE OF 'JS'.
C
C--THE TOTAL OF THE PARAMETERS IS RETURNED AT STORE(LCG+2)
C  THIS ROUTINE ALSO CLACULATES THE DERIVATIVES FOR EACH PARAMETER
C  AND PUTS THEM IN THE PARAMETER CHAIN.
C  THE PARAMETER OF INTEREST IS ASSUMED TO BE THE FIRST ON THE CHAIN
C  STARTING AT WORD 6 OF EACH HEADER.
C
C--
C
      DIMENSION F1(3),O1(6)
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST03.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (F1(1),F),(O1(1),O)
C
C----- LOAD LIST 3 IF WE NEED IT
      KLST3 = -1
      IF (ITYPE .EQ. 2) THEN
          IF (KHUNTR (3,0, IJNK1,IJNK2,IJNK3, -1) .EQ. 0) KLST3 = 1
      ENDIF
C--SET UP THE INITIAL CONSTANTS
      AA=0.
      E = 1.
      JA=LCA
      JU=JS
C--CHECK FOR THE END OF THE PARAMETER HEADER BLOCK CHAIN
1000  CONTINUE
      IF(JA)1500,1500,1050
C--SET UP THE INITIAL ADDRESS FLAGS FOR THIS HEADER
1050  CONTINUE
      II=0
      IJ=ISTORE(JA+6)
C--CHECK ON THE TYPE OF HEADER BLOCK
      IF(ISTORE(JA+1))1100,1150,1100
C--OVERALL PARAMETER OR SIMPLE ATOMIC PARAMETER
1100  CONTINUE
      STORE(IJ+2)=1.
      GOTO 1350
C--THIS IS AN ATOMIC HEADER BLOCK  -  CHECK THE PARAMETER TYPE
1150  CONTINUE
      II=ISTORE(IJ+1)+ISTORE(IJ+1)-2
      IF(ISTORE(IJ+1)-5)1100,1250,1200
C--NOT A SIMPLE PARAMETER  -  CHECK AGAIN
1200  CONTINUE
      IF(ISTORE(IJ+1)-7)1250,1250,1300
C--THIS IS A POSITIONAL COORDINATE
1250  CONTINUE
      CALL XZEROF(F1(1),3)
C--SET UP THE CORRECT DERIVATIVE
      IK=ISTORE(IJ+1)
      F1(IK-4)=1.
      JO=JA
      IF (ITYPE .EQ. 2) THEN
C-----  SET LIST 3 ADDRESSES
        IF ( KLST3 .EQ. 1) THEN
          KEYO = 1
          MINS = L3
          DO 100 J = 1, N3
C----- GET Z FROM THE FORMFACTOR
            IF ( ISTORE(JO+2) .EQ. ISTORE(MINS)) THEN
              E = STORE(MINS+KEYO) + STORE(MINS+KEYO+2)
     1        + STORE(MINS+KEYO+4) + STORE(MINS+KEYO+6)
     2        + STORE(MINS+KEYO+8) + STORE(MINS+KEYO+10)
              GOTO 110
            END IF
            MINS = MINS + MD3
100       CONTINUE
        END IF
110     CONTINUE
      END IF
C--COMPUTE THE DERIVATIVES, ALLOWING FOR SYMMETRY
      CALL XADXYZ
      GOTO 1350
C--THIS IS A ANISOTROPIC TEMPERATURE FACTOR
1300  CONTINUE
      CALL XZEROF(O1(1),6)
C--SET UP THE CORRECT DERIVATIVE
      IK=ISTORE(IJ+1)
      O1(IK-7)=1.
      JO=JA
      JX=IJ
C--COMPUTE THE DERIVATIVES, ALLOWING FOR SYMMETRY
      CALL XADUIJ
C--ADD IN THIS PARAMETER VALUE
1350  CONTINUE
      II=II+ISTORE(JA+16)
      AA = AA + STORE(II) * E
C--CHECK IF WE SHOULD STORE  THIS VALUE
      IF(JS)1450,1450,1400
C--STORE THE VALUE
1400  CONTINUE
      STORE(JU) =  STORE(II) * E
      JU=JU+JT
C--MOVE ONTO THE NEXT PARAMETER HEADER BLOCK
1450  CONTINUE
      JA=ISTORE(JA)
      GOTO 1000
C--END OF THE CHAIN  -  RETURN
1500  CONTINUE
      STORE(LCG+2)=AA
      RETURN
      END
C
CODE FOR XCDPD
      SUBROUTINE XCDPD(IASYM)
C--CALCULATE DISTANCE PARTIAL DERIVATIVES
C
C IASYM 0 = NORMAL
C       1 = ASYMMETRIC
C
C  JA  ADDRESS OF THE FIRST ATOM
C  E   SET ON ENTRY TO 1.0 OR -1.0 FOR DERIVATIVE MULTIPLIER.
C
C--THE SECOND ATOM IS CHAINED TO THE FIRST, AND ITS ADDRESS IS SET IN 'J
C  ON EXIT.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--FIND THE ADDRESS OF THE SECOND ATOM HEADER
      JB=ISTORE(JA)
C--SET UP THE FLAGS FOR 'XCD2PD'
      JO=JA
      JS=JB
C--COMPUTE THE DERIVATIVES, APART FROM THE MULTIPLIER
      CALL XCD2PD
C--CALCULATE THE DISTANCE
      D=SQRT((A*F+B*G+C*H)*0.5)
C--CALCULATE THE P.D. MULTIPLIER
      ESAVE=E/D*0.5
      IF (IASYM .EQ. 0) THEN
       E = ESAVE
      ELSE
       E = 0.
      ENDIF
C--DERIVATIVES FOR THE FIRST ATOM
      CALL XADXYZ
C--DERIVATIVES FOR THE SECOND ATOM
      E = -ESAVE
      JO=JB
      CALL XADXYZ
      RETURN
      END
C
CODE FOR XCAPD
      SUBROUTINE XCAPD
C--CALCULATE ANGLE PARTIAL DERIVATIVES
C
C  JA  ADDRESS OF ATOM 2
C  JB  ADDRESS OF ATOM 1  -  THE PIVOT ATOM
C  JC  ADDRESS OF ATOM 3
C
C  THE BOND ANGLE IS : JA-JB-JC
C
C--IN THIS LINK THE FOLLOWING VARIABLES ARE USED :
C
C  O  L12*L12
C  P  L23*L23
C  Q  L31*L31
C  R  L12*L12+L31*L31-L23*L23
C  S  L12
C  T  L23
C  U  L31
C  V  THE ANGLE IN RADIANS
C
C--AFTER THE INITIAL CALCULATIONS :
C
C  O  D(L12)/DP
C  P  D(L31)/DP
C  Q  D(L23)/DP
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
c      INCLUDE 'XUNITS.INC'
C
      INCLUDE 'QSTORE.INC'
C
      JB=ISTORE(JA)
      JC=ISTORE(JB)
C--CALCULATE THE CONSTANTS FOR L12
      JO=JB
      JS=JA
      CALL XCD2PD
      O=(A*F+B*G+C*H)*0.5
C--DUMP THE RESULTS
      X=F
      Y=G
      Z=H
C--CALCULATE THE CONSTANTS FOR L23
      JO=JA
      JS=JC
      CALL XCD2PD
      P=(A*F+B*G+C*H)*0.5
C--DUMP THE RESULTS
      U=F
      V=G
      W=H
C--CALCULATE THE CONSTANTS FOR L31
      JO=JC
      JS=JB
      CALL XCD2PD
      Q=(A*F+B*G+C*H)*0.5
      A=U
      B=V
      C=W
      R=O+Q-P
C--CALCULATE THE BOND LENGTHS
      S=SQRT(O+0.000001)
      T=SQRT(P+0.000001)
      U=SQRT(Q+0.000001)
C--CALCULATE THE ANGLE
      V=R/(2.0*S*U)
      IF(ABS(V)-1.0)1050,1050,1000
1000  CONTINUE
      V=SIGN(1.0,V)
1050  CONTINUE
      V=ACOS(V)
      W=1.0/(2.0*O*Q*SIN(V))
C--CALCULATE THE PARTIAL DERIVAITVES FOR THE BOND LENGTHS
      P=(R-Q-Q)*S*W
      O=(R-O-O)*U*W
      Q=2.0*S*T*U*W
      D=0.5*E
C--CALCULATE THE DERIVATIVE BASED ON L31
      E=D*P/U
C--ATOM 3
      JO=JC
c      WRITE(NCWU,*) 'A3 ',E,' ',F,' ',G,' ',H
      CALL XADXYZ
      E=-E
C--ATOM 1
      JO=JB
c      WRITE(NCWU,*) 'A1 ',E,' ',F,' ',G,' ',H
      CALL XADXYZ
C--CALCULATE THE DERIVATIVES BASED ON L23
      F=A
      G=B
      H=C
      E=D*Q/T
C--ATOM 2
      JO=JA
c      WRITE(NCWU,*) 'A2 ',E,' ',F,' ',G,' ',H
      CALL XADXYZ
      E=-E
C--ATOM 3
      JO=JC
c      WRITE(NCWU,*) 'A3a ',E,' ',F,' ',G,' ',H
      CALL XADXYZ
C--CALCULATE THE DERIVATIVES BASED ON L12
      F=X
      G=Y
      H=Z
      E=D*O/S
C--ATOM 1
      JO=JB
c      WRITE(NCWU,*) 'A1a ',E,' ',F,' ',G,' ',H
      CALL XADXYZ
      E=-E
C--ATOM 2
      JO=JA
c      WRITE(NCWU,*) 'A2a ',E,' ',F,' ',G,' ',H
      CALL XADXYZ
      RETURN
      END
C
CODE FOR XCD2PD
      SUBROUTINE XCD2PD
C--CALCULATE THE PARTIAL DERIVATIVES FOR THE DISTANCE  SQUARED
C
C  JO  ADDRESS OF THE HEADER BLOCK FOR THE ATOM FOR WHICH P.D.'S
C        ARE REQUIRED
C  JS  SECOND ATOM
C
C--USES THE COMMON BLOCK /XWORK/ AND RETURNS THE ANSWERS AS FOLLOWS :
C
C  A  X(1)-X(2)
C  B  Y(1)-Y(2)
C  C  Z(1)-Z(2)
C  F  P. D. W. R. T. X APART FROM D(X1-X2)/DX1  (NOT ALWAYS =1)
C  G  P. D. W. R. T. Y . . . .
C  H  P. D. W. R. T. Z
C
C--'F', 'G' AND 'H' ARE DERIVED WITH RESPECT TO THE GENERATED
C  COORDINATES, NOT THOSE IN LIST 5.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XLST01.INC'
C
      INCLUDE 'QSTORE.INC'
C
C
C--FIND THE ADDRESS OF THE SPREAD PARAMETERS
      JQ=ISTORE(JO+16)
      JU=ISTORE(JS+16)
C--CALCULATE THE 'DX', 'DY' AND 'DZ'
      A=STORE(JQ+8)-STORE(JU+8)
      B=STORE(JQ+10)-STORE(JU+10)
      C=STORE(JQ+12)-STORE(JU+12)
C--CALCULATE THE DERIVATIVES, APART FROM THE MULTIPLIER OF '0.5*DIST**-1
      F=2.0*(A*STORE(L1M1)+B*STORE(L1M1+1)+C*STORE(L1M1+2))
      G=2.0*(A*STORE(L1M1+3)+B*STORE(L1M1+4)+C*STORE(L1M1+5))
      H=2.0*(A*STORE(L1M1+6)+B*STORE(L1M1+7)+C*STORE(L1M1+8))
      RETURN
      END
C
CODE FOR XADXYZ
      SUBROUTINE XADXYZ
C--ADD IN THE CONTRIBUTIONS FOR X , Y AND Z
C
C  THE PARTIAL DERIVATIVES ARE ASSUMED TO BE STORED IN THE COMMON
C  BLOCK /XWORK/ :
C
C  F  P. D. W. R. T. X
C  G  P. D. W. R. T. Y
C  H  P. D. W. R. T. Z
C  E  MULTIPLIER FOR THE PARTIAL DERIVATIVES
C
C--'F', 'G' AND 'H' ARE THE DERIVATIVES WITH RESPECT TO THE GENERATED
C  COORDINATES OR STORED PARAMETERS, WHICH ARE DERIVED FROM THOSE IN LIS
C  5 BY SYMMETRY. THIS ROUTINE CALCULATES THE DERIVATIVES WITH RESPECT
C  TO THE COORDINATES IN LIST 5 FROM 'F', 'G' AND 'H'.
C
C--POINTERS IN 'XWORKA' ARE :
C
C  JO  ADDR. OF THE FIRST ATOM
C  JP  ADDR. OF THE CURRENT COORD. FOR THE FIRST ATOM
C  JQ  ADDR. OF THE COORDINATES FOR THE FIRST ATOM
C  JV  ADDR. OF THE GENERATED COORDS. FOR THE FIRST ATOM
C  JS  JO FOR THE SEOND ATOM
C  .
C  .
C
C--THE X, Y AND Z COORDS. ARE ASSUMED TO BE THE FIRST STORED.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
c	  INCLUDE 'XUNITS.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--FIND THE ADDRESS OF THE PARAMETER CHAIN
      JP=ISTORE(JO+6)
C--FIND THE ADDRESS OF THE SPREAD PARAMETERS
      JV=ISTORE(JO+16)
C--LOOP OVER EACH COORDINATE
      DO 1000 J=1,3
C--FIND THE SYMMETRY MATRIX
      I=ISTORE(JO+4)+ISTORE(JP+1)
C--CALCULATE THE DERIVATIVES FOR THIS COORD. W.R.T. THE GENERATED X, Y Z
      STORE(JV+9)=STORE(JO+14)*STORE(I-5)
      STORE(JV+11)=STORE(JO+14)*STORE(I-2)
      STORE(JV+13)=STORE(JO+14)*STORE(I+1)
C--CALCULATE THE PARTIAL DERIVATIVE FOR THIS COORD
      STORE(JP+2)=STORE(JP+2)+E*(F*STORE(JV+9)+G*STORE(JV+11)
     2 +H*STORE(JV+13))
c	  WRITE(NCWU,*)'ADXYZ ', I, ' ', STORE(JP+2), ' ', JP
      JP=ISTORE(JP)
1000  CONTINUE
      RETURN
      END
C
CODE FOR XADUIJ
      SUBROUTINE XADUIJ
C--ADD THE DERIVATIVES FOR THE UIJ'S INTO THE PARAMETER BLOCKS,
C  ALLOWING FOR SYMMETRY AS IT IS DONE.
C
C--THE FOLLOWING VARIABLES MUST BE SET
C
C  JO  ADDRESS OF THE ATOM HEADER.
C  JX  ADDRESS OF THE FIRST PARAMETER BLOCK TO PROCESS.
C      (THIS VARIABLE IS UPDATED BY THIS ROUTINE).
C
C--THE DERIVATIVES FOR U(11), U(22), ETC. ARE STORED IN O, P, Q, ETC.
C
C--
      INCLUDE 'ISTORE.INC'
C
      DIMENSION A1(12)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (O,A1(1))
C
C--FIND THE ADDRESS OF THE SYMMETRY MATRIX USED
      L=ISTORE(JO+4)
C--ZERO THE U(IJ) DERIVATIVE AREA
      CALL XZEROF(STORE(NFL+18),6)
C--LOOP OVER EACH U(IJ), COMPUTING THE DERIVATIVE, ALLOWING FOR SYMMETRY
      DO 1000 J=1,6
      K=NFL+ISTORE(JX+1)+10
      STORE(K)=1.
C--CALCULATE DU(IJ)'/DU(IJ), WHERE THE ' ALLOWS FOR SYMMETRY
c      write(123,'(6f10.6)') (store(idjw),idjw=nfl+18,nfl+23)
      CALL XEXANI(NFL+18,NFL)
      CALL XMLTTM(STORE(NFL),STORE(L),STORE(NFL+9),3,3,3)
      CALL XMLTTM(STORE(L),STORE(NFL+9),STORE(NFL),3,3,3)
      STORE(K)=0.
C--CALCULATE DV/DU(IJ)
      STORE(JX+2)=STORE(JX+2)+STORE(NFL)*A1(1)+STORE(NFL+4)*A1(2)
     2 +STORE(NFL+8)*A1(3)+STORE(NFL+5)*A1(4)+STORE(NFL+2)*A1(5)
     3 +STORE(NFL+1)*A1(6)
      JX=ISTORE(JX)
1000  CONTINUE
      RETURN
      END
C
CODE FOR XIPDQF
      SUBROUTINE XIPDQF
C--INITIATE PARTIAL DERIVATIVE QUEUE FORMATION
C
C--THIS ROUTINE SETS UP THE P.D. STACK IN CORE, AND FINDS THE DISC ADDR.
C  AT WHICH TO START PUTTING OUT THE INFORMATION.
C
C  L22PD   ADDRESS OF THE PARTIAL DERIVATIVE STACK IN CORE
C  M22PD   CURRENT DISC ADDRESS OF THE PARTIAL DERIVATIVE QUEUE
C  MD22PD  LENGTH OF EACH ENTRY IN THE QUEUE  (=2)
C
C--THE FORMAT OF THE STACK FOR EACH RESTRAINT IS AS FOLLOWS :
C
C  ISTORE(L22PD  )  LENGTH OF THE ENTRY
C   STORE(L22PD+1)  WEIGHT
C   STORE(L22PD+2)  CALC. DELTA
C   STORE(L22PD+3)  OBSERVED VALUE SQUARED
C
C  ISTORE(L22PD+4)  PARAMETER 1
C   STORE(L22PD+5)  P. D. FOR PARAMETER 1
C  .
C  .
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLST12.INC'
      INCLUDE 'XLST22.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET THE LIST TYPE RECORD TYPE FOR THE STACK
      LN=22
      IREC=1001
C--SET THE LENGTH OF EACH ENTRY IN THE STACK
      MD22PD=2
C--SET UP THE STACK
      L22PD=NFL
      M22PD=KCHNFL(4+N12*MD22PD)
C--FIND THE DISC ADDRESS
      M22PD=KNEXTF(L22PD)
      RETURN
      END
C
CODE FOR XTPDQF
      SUBROUTINE XTPDQF
C--TERMINATE PARTIAL DERIVATIVE QUEUE FORMATION
C
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET THE TRANSFER LENGTH
      N22PD=4
C--SET THE TRANSFER DETAILS
      ISTORE(L22PD)=NOWT
      CALL XZEROF(STORE(L22PD+1),N22PD-1)
C--OUTPUT THE DATA TO THE DISC
      CALL XUPF(M22PD, ISTORE(L22PD),N22PD)
      RETURN
      END
C
CODE FOR XFMPDQ
      SUBROUTINE XFMPDQ
C--FORM THE PARTIAL DERIVATIVE QUEUE
C  THIS SUBROUTINE TAKES THE CALCULATED PARTIAL DERIVATIVES FOR
C  EACH ATOM AND ADDS THEM INTO THE QUEUE.
C
C--THE FOLLOWING ATOMS POINTERS IN 'XCNTRL' MUST BE SET :
C
C  MCA  ADDRESS OF THE HEADER BLOCK FOR THE FIRST ATOM TO BE TREATED
C  NCA  NUMBER OF ATOMS TO TREAT
C
C--THE HEADER BLOCKS ARE ASSUMED TO BE IN STANDARD FORMAT, WITH
C  THE LIST 12 ADDRESSES ALREADY SET.
C  TERMINATION IS REACHED BY A NEGATIVE LINK ADDRESS.
C
C--THE OBSERVED VALUE SQUARED ARE TAKEN FROM THE CONTROL BLOCK AT 'LCG'
C  THE OTHER ENTRIES FOR THE CALCULATED DELTA AND WEIGHT ARE ASSUMED
C  TO BE SET ON ENTRY.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLST12.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XIOBUF.INC'
	  INCLUDE 'XCONST.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET THE REMAINDER OF THE HEADER BLOCK
      STORE(L22PD+3)=STORE(LCG+4)*STORE(LCG+4)
      J=JR+N12-1
      DO I=JR,J
        STORE(I)=0.
	  END DO
      STORE(JN)=0.
      K=MCA
      N=NCA
C--CHECK IF THERE ANY MORE ATOMS TO PROCESS
1050  CONTINUE
      IF(N)1700,1700,1100
C--CHECK IF THIS ATOM HAS AN ACTIVE ENTRY IN LIST 12
1100  CONTINUE
      M12=ISTORE(K+13)
      IF(ISTORE(M12+1))1650,1650,1150
1150  CONTINUE
      M12=ISTORE(M12+1)
      M=ISTORE(K+6)
C--CHECK IF THERE ARE ANY MORE COORDINATES TO BE REFINED
1200  CONTINUE
      L12A=M12
      IF(M)1650,1650,1250
C--FIND THE ADDRESSES OF THIS COORDINATE
1250  CONTINUE
      L=ISTORE(M+1)-1
C--COMPUTE THE ABSOLUTE ADDRESS OF THE INFORMATION FOR THIS COORDINATE
C  IN LIST 12
1300  CONTINUE
      M12A=ISTORE(L12A+2)+ISTORE(L12A+1)*(L-ISTORE(L12A+4))
C--CHECK TO SEE IF THERE IS AN ENTRY FOR THIS COORDINATE
      IF(M12A-ISTORE(L12A+2))1550,1400,1350
1350  CONTINUE
      IF(ISTORE(L12A+3)-M12A)1550,1400,1400
C--FIND THE ADDRESS OF THE PARTIAL DERIVATIVE AND CHECK IF THE 'WEIGHT'
C  IS EQUAL TO 1.0
1400  CONTINUE
      I=ISTORE(M12A)
      IF(ISTORE(L12A+1)-1)1500,1500,1450  
C--NON-UNIT 'WEIGHT'
1450  CONTINUE
c      WRITE(NCWU,*)'Str PDQ1: ',' i:',I,' m:',M,' ',STORE(M+2),' w:',
c     1 STORE(M12A+1),' s(I):',STORE(I),' ++ ',STORE(M+2)*STORE(M12A+1)
      STORE(I)=STORE(I)+STORE(M+2)*STORE(M12A+1)
c      WRITE(NCWU,*)'After:    ',' i:',I,' m:',M,' ',STORE(M+2),' w:',
c     1 STORE(M12A+1),' s(I):',STORE(I),' ++ ',STORE(M+2)*STORE(M12A+1)
      GOTO 1550
C--UNIT 'WEIGHT'
1500  CONTINUE
      STORE(I)=STORE(I)+STORE(M+2)
c      WRITE(NCWU,*)'Str PDQW: ',' ',I,' ',M,' ',STORE(M+2),' ',STORE(I)
C--PICK UP THE NEXT PART FOR THIS ATOM IN LIST 12
1550  CONTINUE
      L12A=ISTORE(L12A)
      IF(L12A)1600,1600,1300
C--PASS ON TO THE NEXT COORDINATE
1600  CONTINUE
      M=ISTORE(M)
      GOTO 1200
C--PASS ON TO THE NEXT ATOM HEADER
1650  CONTINUE
      K=ISTORE(K)
      N=N-1
      GOTO 1050
C
C--COMPRESS THE QUEUE AND OUTPUT IT TO THE DISC
1700  CONTINUE
      N22PD=4
      J=L22PD+N22PD
      K=JR
c      WRITE(NCWU,*) 'PDQAddress: ',J,' ',K 
      DO L=1,N12
c	     WRITE(NCWU,*) 'PD: ',L,' ',K,' ',STORE(K),N22PD
C--CHECK IF THE CONTRIBUTION FOR THIS PARAMETER IS ZERO
c        IF(STORE(K))1750,1800,1750
         IF ( ABS(STORE(K)) .GT. VALUSQ ) THEN
C--ADD IT TO THE QUEUE
            ISTORE(J)=L
            STORE(J+1)=STORE(K)
            J=J+MD22PD
            N22PD=N22PD+MD22PD
	     END IF
         K=K+1
	  END DO
      ISTORE(L22PD)=N22PD
      K=J-MD22PD
      J=L22PD+4
C--CHECK IF ANY P.D.'S HAVE BEEN FOUND
      IF(J-K)2050,2050,1900
C--NO P.D.'S FOUND
1900  CONTINUE
      IF(ISTAT2)2200,2200,1950
1950  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2000)
      ENDIF
c      WRITE(NCAWU,2000)
2000  FORMAT(21H No derivatives found)
      GOTO 2200
C--DERIVATIVES FOUND  -  CHECK IF THEY ARE TO BE PRINTED
2050  CONTINUE
      IF(ISTAT2)2200,2200,2100
2100  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2150)ISTORE(L22PD),STORE(L22PD+1),STORE(L22PD+2),
     2 STORE(L22PD+3),(ISTORE(I),STORE(I+1),I=J,K,MD22PD)
      ENDIF
cRIC13:2150  FORMAT(16H Derivative(s) :/I10,/,3(10X,E20.10)/
cRIC13:     2 (4(I10,E20.10)))
2150  FORMAT(16H Derivative(s) :/I10,/,3(10X,E20.4)/
     2 (4(I10,E20.4)))
C--OUTPUT THE QUEUE TO THE DISC
2200  CONTINUE
      CALL XUPF(M22PD, ISTORE(L22PD), N22PD)
      M22PD=M22PD+KINCRF(N22PD)
      RETURN
      END
C
CODE FOR XADCPD
      SUBROUTINE XADCPD
C--THIS ROUTNE TAKES THE PARTIAL DERIVATIVE QUEUE ON THE DISC
C  AND ADDS IT TO THE NORMAL MATRIX.
C
C--
      INCLUDE 'TYPE11.INC'
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XSTR11.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XLST11.INC'
      INCLUDE 'XLST12.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XLST33.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XMTLAB.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QSTR11.INC'
C
C--SET THE LENGTH OF EACH ENTRY
      MD16Q=MD22PD
C--CLEAR THE CORE ENTRIES
      CALL XRSL
      CALL XCSAE
C--FIND WHETHER A NEW MATRIX IS BEING COMPUTED
      CALL XFAL33
      IF ( IERFLG .LT. 0 ) GO TO 9900
      JK=ISTORE(M33CD+6)
C--RESET THE CORE LIMITS
      CALL XRSL
      CALL XCSAE
C--LOAD LIST 12
      CALL XFAL12(0,0,JR,JN)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--RESET THE CORE LIMITS
      CALL XRSL
      CALL XCSAE
C--INDICATE THE LIST AND RECORD TYPE
      LN=12
      IREC=1001
C--ALLOCATE SAPCE FOR THE BLOCKING DATA
      M12B=L12B
      I=N12B*MD12B
      L12B=KCHLFL(I)
C--MOVE THE BLOCKING DATA ACROSS
      CALL XMOVE(STORE(M12B),STORE(L12B),I)
C--SET THE POINTER TO THE END OF THIS STACK
      M12B=L12B+(N12B-1)*MD12B
C--FIND THE ADDRESS OF THE P.D. QUEUE ON DIC
      MD16=KNEXTF(I)
C--LOAD THE LIST 11
      CALL XSET11(0,1,1)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--CHECK THAT THE MATRIX IS THE RIGHT TYPE
      IF(ISTORE(L11P+15))1000,1000,1050
C--STORED MATRIX HAS ALREADY BEEN INVERTED
1000  CONTINUE
      JK=0
C--COMPUTE THE WEIGHT MULTIPLIER
1050  CONTINUE
      IF ( (ABS (STORE( L11P + 16 )) .LE. ZERO ) .OR.
     1     (ABS (STORE( L11P + 17 )) .LE. ZERO ) ) THEN
            B = 1.
      ELSE
            B = STORE( L11P + 17 ) / STORE( L11P + 16 )
      ENDIF
      IF ( B .LE. ZERO ) B = 1.
C--CLEAR THE TOTAL ACCUMULATION AREAS
      STORE(L11P+27)=0.
      STORE(L11P+28)=0.
      STORE(L11P+29)=0.
C--SET UP AN AREA TO HOLD THE QUEUE ENTRIES FROM DISC
      L16=NFL
      LN=22
      IREC=1001
      M16=KCHNFL(MD22PD*N12+4)
C--CHECK IF A CORE MAP IS REQUIRED
      IF(ISTAT2)1100,1150,1100
1100  CONTINUE
      CALL XPCM(1)
C--BRING DOWN THE LENGTH OF THE FIRST RECORD
1150  CONTINUE
      CALL XDOWNF(MD16,ISTORE(L16),1)
C--SET THE LENGTH OF THE FIRST ENTRY
      N16=ISTORE(L16)

C--INCREMENT THE TRANSFER ADDRESS
      MD16=MD16+KINCRF(1)
C--QUEUE PROCESSING LOOP
1200  CONTINUE
        IF(N16)1850,1850,1250
C--PROCESS THE NEXT RESTRAINT
1250    CONTINUE
        CALL XDOWNF(MD16,STORE(L16),N16)
C--INCREMENT THE TRANSFER ADDRESS
        MD16=MD16+KINCRF(N16)
C--INDICATE THE NUMBER OF ENTRIES TO PROCESS
        N16=N16-4
C--INDICATE THE CORE ADDRESS OF THE FIRST ENTRY
        M16=L16+3
C--INDICATE THE ADDRESS OF THE LAST ENTRY IN THE QUEUE
        M16Q=M16+N16-MD16Q
C--CHECK IF ANY DERIVATIVES HAVE BEEN FOUND
        IF(N16)1800,1800,1300
C--COMPUTE THE ACTUAL WEIGHT TO USE
1300    CONTINUE
        C=STORE(L16)*B
        D=STORE(L16+1)
cdjwmay2000 - note problems with Rfactor when target is zero!
c      write(ncawu,'(a,3g15.3)')'c&d ', c,d, store(l16+2)
c      write(ncwu,'(a,3g15.3)')'c&d ', c,d, store(l16+2)
        STORE(L11P+27)=STORE(L11P+27)+1.
        STORE(L11P+28)=STORE(L11P+28)+D*D*C
        STORE(L11P+29)=STORE(L11P+29)+STORE(L16+2)*C

        IF (MATLAB.GT.0) WRITE(NCFPU2,'(G16.8)') D
        print *, 'Rest(Target) - Rest(Calc) = ', D
c		IF (MATLAB.GT.0) WRITE(NCWU,'(A,G16.8)')'Hello ',store(l11P+27)
        IM11C = 0
C--PASS THROUGH THE MATRIX
        M11=L11
        DO I=L12B,M12B,MD12B                 !PROCESS BLOCK BY BLOCK
           M=ISTORE(I)
           N=ISTORE(I+1)
           L=M+N-1

           DO J=M,L  !PASS THROUGH THE PARAMETERS IN THIS BLOCK
              IM11C = IM11C+1

              IF(ISTORE(M16) .NE. J) THEN             !Not this one.
				 print *, IM11C, ': 0.0 '
                 IF (MATLAB.GT.0) WRITE(NCFPU1,'(''0.0 ...'')')
              ELSE                                    !Parameter is in queue
                 A=STORE(M16+1)*C
				 print *, IM11C, ': ', STORE(M16+1), SQRT(ABS(C))*STORE(M16+1)
                 IF (MATLAB.GT.0) WRITE(NCFPU1,'(G16.8,'' ...'')')
     1                SQRT(ABS(C))*STORE(M16+1)
C--ADD INTO THE R.H.S.
                 M11R=L11R+J-1
                 STR11(M11R)=STR11(M11R)+A*D

c                 WRITE(CMON,'(A,2G12.5,I12)')
c     1           'Rest: J,A*D,M11R: ',J,A*D,M11R
c                 CALL XPRVDU(NCVDU,1,0)

                 IF(JK.LT.0) THEN       !The L.H.S is required.
                    DO K=M16,M16Q,MD16Q      !Inner loop through remaining params
                       IF (ISTORE(K).GT.L) EXIT    !Param not in this block
                       M11R=M11+ISTORE(K)-J        !Add contribution
                       STR11(M11R)=STR11(M11R)+A*STORE(K+1)
                    END DO
                 END IF

                 N16=N16-MD16Q
                 IF(N16.LE.0)THEN                 !No more derivatives.
                    IF ( MATLAB .GT. 0 ) THEN         !Finish this line.
                        DO JJ = J+1,L
                           WRITE(NCFPU1,'(''0.0 ...'')')
                        END DO
                     END IF
                     DO JJ = J+1,L
					     IM11C = IM11C + 1
          				 print *, IM11C, ': 0.0'
                     END DO
                    GOTO 1800
                 ENDIF
                 M16=M16+MD16Q
              END IF
              M11=M11+N
              N=N-1
           END DO
        END DO

1800    CONTINUE
C--FIND THE ADDRESS OF THE LENGTH OF THE NEXT ENTRY
        M16Q=M16Q+MD16Q
C--FIND THE LENGTH OF THE NEXT ENTRY
        N16=ISTORE(M16Q)
        print *, '=============='
        IF (MATLAB.GT.0) THEN
          WRITE(NCFPU1,'('' '')')
        END IF

      GOTO 1200



C--OUTPUT THE NEW MATRIX
1850  CONTINUE
      STORE(L11P+16)=STORE(L11P+16)+STORE(L11P+27)
      STORE(L11P+17)=STORE(L11P+17)+STORE(L11P+28)
      CALL XCL11(16)
      CALL XMKOWF(11,0)
      CALL XALTES(11,1)

      IF (MATLAB.GT.0) THEN
        WRITE (NCFPU1, '(''];'')')
        I = KFLCLS(NCFPU1)
        WRITE (NCFPU2, '(''];'')')
        I = KFLCLS(NCFPU2)
        MATLAB = 0
      END IF

      RETURN
C
9900  CONTINUE
C -- ERRORS
      RETURN
C
      END

