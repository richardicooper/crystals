C $Log: list26.F,v $
C Revision 1.27  2013/12/11 16:54:14  rich
C Some mismatched subroutine argument lengths following previous update.f
C
C Revision 1.26  2013/12/08 20:32:26  rich
C Ensure IASYM is passed throughout required routines. Thanks Pascal.
C
C Revision 1.25  2013/11/06 13:52:52  rich
C Fix use of uninit variable
C
C Revision 1.24  2013/09/19 21:35:39  rich
C Change precision of listing output where not important to reduce differences across platforms.
C Important changes - SFLS now uses builtin cos() and sin() functions rather than Chebyshev
C approximations.
C
C Revision 1.23  2012/11/09 15:05:00  rich
C *** empty log message ***
C
C Revision 1.22  2012/08/29 09:53:57  djw
C New format for listing Derivatives
C Values of Uij taken directly from input rather than be computed from derived parameters
C
C Revision 1.21  2012/07/11 14:07:01  djw
C remove debugging prints
C
C Revision 1.20  2011/10/14 13:48:09  djw
C Fix interaction between A-DIST and MEAN and DiIFF restraints
C
C Revision 1.19  2011/10/13 14:41:31  djw
C Add asymmetric distacne restraint
C
C Revision 1.18  2011/09/30 11:20:39  djw
C Add asymmetric vib and Uij restraints
C
C Revision 1.17  2011/05/04 11:28:51  rich
C TODO note.
C
C Revision 1.16  2011/03/21 13:57:21  rich
C Update files to work with gfortran compiler.
C
C Revision 1.15  2010/10/26 09:51:24  djw
C Sort out more writes to NCAWU, provide more output from EXEC directive
C
C Revision 1.14  2009/06/17 13:41:49  djw
C Fix #CHECK HI crash.  Actual error was in wrong values for idjw1 & idjw2 for DELU
C  restraint in LIST 16.  Several messages cleaned up, more diagnostics for error conditions.
C
C Revision 1.13  2005/01/23 08:29:11  rich
C Reinstated CVS change history for all FPP files.
C History for very recent (January) changes may be lost.
C
C Revision 1.2  2004/12/13 16:16:08  rich
C Changed GIL to _GIL_ etc.
C
C Revision 1.1.1.1  2004/12/13 11:16:09  rich
C New CRYSTALS repository
C
C Revision 1.12  2004/03/25 10:16:56  rich
C Fix bug in FORMAT statement when #CHECKing an 'AVERAGE' restraint on
C layer scale factors. Obscure.
C
C Revision 1.11  2003/03/20 16:11:28  rich
C Fix. I accidentally removed a GOTO when clearing out NCAWU writes the other
C week... with disasterous consquences for anyone typing #CHECK.
C
C Revision 1.10  2003/02/26 12:13:27  rich
C Removed some writes to the monitor file, as part of an
C ongoing (quite boring) project.
C
C Revision 1.9  2002/12/05 11:51:51  rich
C Things look better without the debugging messages.
C
C Revision 1.8  2002/12/04 14:31:11  rich
C Reformat output during refinement.
C
C Allow punching to MATLAB files, including restraints.
C
C Tidy some routines.
C
C Revision 1.7  2002/12/02 15:48:54  rich
C XADCPD was looking at PUNCH YES/NO, should have been looking at MATRIX OLD/NEW
C in LIST 33.
C
C Revision 1.6  2001/02/26 10:28:01  richard
C RIC: Added changelog to top of file
C
C
CODE FOR XCHK16
      SUBROUTINE XCHK16
C--CHECK THE VALUES OF THE APPLIED RESTRAINTS
C
C  THIS SUBROUTINE READS DOWN THE LIST 26 AND CALCULATES THE
C  REQUIRED RESTRAINTS.
C
C--THE COMMON BLOCK 'XCNTRL' CONTROLS THE FORMAT OF THE
C  INFORMATION OUTPUT TO THE DISC. WHILE THE LIST IS STILL IN
C  CORE, THE VARIABLES HAVE THE FOLLOWING SIGNIFICANCE :
C
C  LC      BASE ADDRESS OF THE WORK STACK, WHICH HOLDS CONSTANTS
C          AND VARIABLES GENERATED BY THE CODE.
C          THIS VARIABLE SET UP DYNAMICALLY BOTH DURING SYNTAX
C          ANALYSIS AND DURING EXECUTION, AND IS THUS NOT OUTPUT TO
C          DISC.
C  ISTAT2  THIS IS A PRINT CONTROL FLAG :
C
C          -1  PRINT THE CARD IMAGES AS THEY ARE PROCESSED.
C           0  NO PRINTING.
C          +1  PRINT THE CARD IMAGES AND THE GENERATED CODE.
C
C
C      IASYM ASYMMETRIC RESTRAINT
C           1 ASYMMETRYIC
C           0 NORMAL
C
C--THE REMAINING 12 WORDS OF THIS COMMON BLOCK ARE OUTPUT TO THE
C  DISC AND DEFINE THE LOCATIONS AND LENGTH OF THE REMAINING BLOCKS
C  ASSOCIATED WITH THIS INSTRUCTION. IN CORE THE FORMAT OF THIS CONTROL
C  BLOCK IS :
C
C  LCG   ADDRESS IN CORE OF THE HEADER BLOCK FOR THE GENERAL CHAIN.
C        FOR OUTPUT PRODUCED BY THE PARSE ROUTINES, THIS CHAIN CONTAINS
C        ONLY INSTRUCTIONS OR CODE. IN OTHER CASES THE CONTENTS
C        OF THE CHAIN ARE DEFINED BY THE FUNCTION OF THE ROUTINE
C        THAT SET IT UP.
C        (ON THE DISC, THIS VARIABLE IS STORED RELATIVE TO 'LCG',
C        THAT IS AS ZERO).
C  MCG   CURRENT ADDRESS IN CORE OF THE NEXT FREE WORD FOR THE GENERAL,
C        PARAMETER HEADER AND CONSTANT CHAINS. THESE CHAINS MOVE UP THE
C        STORE AND MUST UPDATE 'MCG' AS THEY DO SO.
C  MDCG  CURRENT ADDRESS IN CORE OF THE LAST GENERAL (OR INSTRUCTION)
C        BLOCK INSERTED.
C  NCG   NOT DEFINED.
C        (ON THE DISC, THIS VARIABLE IS SET TO THE TOTAL LENGTH
C        OF ALL THE CHAINS FORMED AT THE BOTTOM OF CORE  -  THE
C        GENERAL, PARAMETER AND CONSTANT CHAINS).
C
C  LCA   ADDRESS IN CORE OF THE FIRST BLOCK ON THE PARAMETER HEADER
C        BLOCK CHAIN.
C        (ON THE DISC, THIS VARIABLE IS STORED WITH ITS ADDRESS
C        SET RELATIVE TO 'LCG').
C  MCA   USED TO PROCESS THE PARAMETER HEADER BLOCK CHAIN.
C  MDCA  USED TO PROCESS THE PARAMETER HEADER BLOCK CHAIN.
C  NCA   NUMBER OF PARAMETER HEADER BLOCKS ON THE CHAIN.
C
C  LCS   ADDRESS IN CORE OF THE CONSTANT AND WORK STACK HEADER BLOCK.
C        (ON THE DISC, THIS VARIABLE IS STORED WITH ITS ADDRESS
C        SET RELATIVE TO 'LCG').
C  MCS   CURRENT ADDRESS OF THE LAST BLOCK INSERTED ON THE CONSTANT
C        CHAIN. THIS MUST BE UPDATED WHEN A NEW BLOCK IS ADDED.
C  MDCS  NEXT FREE ADDRESS IN THE WORK STACK. THIS STACK STARTS AT
C        'LC' AND COMES DOWN THE STORE.
C        (THIS PARAMETER SHOULD BE UPDATED WHENEVER SPACE IS
C        ALLOCATED IN THE WORK STACK).
C
C--DURING ALL OPERATIONS EXCEPT PARSING BY 'KPARSE', THE NEXT FREE
C  LOCATION IS STORED IN 'MCG' AND THE LAST FREE LOCATION IS HELD IN 'LF
C
C--FORMAT OF THE GENERAL CHAIN HEADER BLOCK IS :
C
C  0  ADDRESS OF THE FIRST BLOCK ON THE CHAIN REL. TO 'LCG' OR 'NOWT'.
C  1  TYPE OF OPERATION DESCRIBED BY THIS HEADER BLOCK AND ALL THE
C     OTHER HEADER BLOCKS DEFINED BY THE CONTROL BLOCK.
C  2  NOT DEFINED  -  FOR RESTRAINTS MAY BE A WORK STACK ADDRESS REL.
C                     TO 'LC'..
C  3  NOT DEFINED  -  FOR RESTRAINTS THE WEIGHT.
C  4  NOT DEFINED  -  FOR RESTRAINTS THE INPUT OR OBSERVED VALUE.
C  5  The index of the restraint in the user list `list 16` starting from zero
C
C--THE FORMAT OF THE INSTRUCTION BLOCKS ON THE CHAIN IS :
C
C  0  ADDRESS OF THE NEXT BLOCK RELATIVE TO 'LCG' OR 'NOWT'.
C  1  FUNCTION OF THIS BLOCK.
C  2  ADDRESS IN THE WORK STACK RELATIVE TO 'LC'  -  OPERAND 1.
C  3  ADDRESS IN THE WORK STACK RELATIVE TO 'LC'  -  OPERAND 2.
C  4  ADDRESS IN THE WORK STACK RELATIVE TO 'LC'  -  THE RESULT.
C
C--THE TERMS IN WORDS 2, 3 AND 4 ARE THOSE SET UP BY THE PARSE ROUTINES,
C  AND THE ADDRESSES ARE CONVERTED TO ABSOLUTE VALUES BY 'KLOADR' WHEN
C  THE INFORMATION IS READ BACK FROM THE DISC.
C  THE FORMAT OF THE BLOCK BEYOND WORD 4 IS NOT DEFINED, AND THESE
C  LOCATIONS MAY BE USED AS REQUIRED.
C
C--THE PARAMETER HEADER BLOCKS ARE DIVIDED INTO THOSE FOR ATOMS
C  AND THOSE FOR OVERALL PARAMETERS. THE FORMAT OF THE FORMER IS
C  AS FOLLOWS :
C
C  0   ADDR. OF NEXT HEADER BLOCK REL. TO LCG OR 'NOWT'
C  1   TYPE OF HEADER BLOCK :
C         0  HEADER BLOCK FOR ONE ATOM
C      1024  HEADER BLOCK FOR THE FIRST ATOM OF AN 'UNTIL' SEQUENCE
C  2   ATOM TYPE
C  3   ATOM SERIAL
C  4   NOT USED
C  5   NUMBER OF PARAMETERS
C  6   ADDR. OF FIRST PARAMETER ENTRY REL. TO 'LCG'
C  7   S
C  8   L
C  9   T(X)
C  10  T(Y)
C  11  T(Z)
C  12  ADDR. OF THIS ATOM IN LIST 5 (NOT SET HERE)
C  13  ADDR. OF THIS ATOM IN LIST 12 (NOT SET HERE)
C  14  NOT USED
C  15  ADDR. OF GENERATED PARAMETERS IN WORK STACK REL. TO 'LC'
C  16  ADDR. OF PARAMETERS TO BE USED IN WORK STACK REL. TO 'LC'
C
C--FOR EACH PARAMETER :
C
C  0   LINK TO NEXT PARAMETER REL. TO 'LCG' OR 'NOWT'.
C  1   REL. ADDR. IN LIST 5 (X=5, FOR EXAMPLE).
C  2   PARTIAL DERIVATIVE WHEN CALCULATED.
C  .
C
C--THE INFORMATION FOR EACH OVERALL PARAMETER ALSO CONSISTS OF A HEADER
C  WITH THE SPECIFIED PARAMETER GIVEN AS THE COORDINATE ON THE CHAIN AT
C  WORD 6.
C
C  0   ADDR. OF NEXT HEADER BLOCK REL. TO 'LCG' OR 'NOWT'.
C  1   TYPE :
C      1  OVERALL PARAMETER
C      2  LAYER SCALE
C      3  ELEMENT SCALE
C  2   THE POSITION OF THE PARAMETER IN ITS GROUP
C  3   0.0
C  4   NOT USED
C  5   THE NUMBER OF PARAMETERS ON THE CHAIN GIVEN AT WORD 6.
C  6   ADDRESS OF THE PARAMETER CHAIN REL. TO 'LCG' (STARTS AT WORD 7).
C  7   'NOWT'  LINK TO THE NEXT PARAMETER ON THE CHAIN
C  8   THE POSITION OF THE PARAMETER IN ITS GROUP (STARTING FROM 1).
C  9   NOT USED
C  10  'NOWT'
C  11  'NOWT'
C  12  ADDR. OF THE GROUP CONTAINING THIS PARAMETER IN LIST 5 ('NOWT')
C  13  ADDR. OF THE GROUP CONTAINING THIS PARAMETER IN LIST 12 ('NOWT'
C  14  NOT USED
C  15  ADDR. OF THE PARAMETER IN THE WORK STACK REL. TO 'LC'
C  16  ADDR. OF THE SPACE TO BE USED IN THE WORK STACK REL. TO 'LC'
C
C--THE FORMAT OF THE CONSTANT AND WORK STACK HEADER IS :
C
C  0  ADDRESS OF THE NEXT CONSTANT OR WORK STACK HEADER RELATIVE
C     TO 'LCG' OR 'NOWT'.
C  1  LENGTH OF THIS BLOCK (=6)
C  2  ADDRESS AT WHICH THE WORK STACK BEGINS REL. TO 'LC' OR 'NOWT'
C  3  NUMBER OF WORDS REQUIRED FOR THE WORK STACK.
C  4  ADDRESS OF THE FIRST CONSTANT BLOCK ON THE CONSTANT CHAIN REL. TO
C     'LCG' OR 'NOWT'.
C  5  NUMBER OF CONSTANTS ON THE CONSTANT CHAIN.
C
C--THE FORMAT OF THE CONSTANT CHAIN IS :
C
C  0  ADDRESS OF THE NEXT CONSTANT BLOCK RELATIVE TO 'LCG' OR 'NOWT'
C  1  ADDRESS OF THIS CONSTANT IN THE WORK STACK RELATIVE TO 'LC'.
C  2  THE VALUE TO BE PLACED IN THE WORK STACK.
C
C--THE COMPUTED DERIVATIVES ARE OUTPUT IN A CHAINED LIST TO
C  THE DISC, UNDER THE CONTROL OF THE 'L22PD' VARIABLES. THE VARIABLES
C  ARE USED AS FOLLOWS :
C
C  L22PD   THE ADDRESS OF THE STACK OF OUTPUT PARTIAL DERIVATIVES.
C  M22PD   THE CURRENT OUTPUT DISC ADDRESS.
C  MD22PD  THE NUMBER OF WORDS PER P.D. (=2).
C  N22PD   THE LENGTH OF THE CURRENT P.D. STACK ON DISC.
C
C--THE FORMAT OF THE STACK IS :
C
C  ISTORE(L22PD  )  LENGTH OF THE ENTRY
C   STORE(L22PD+1)  WEIGHT
C   STORE(L22PD+2)  CALC. DELTA
C   STORE(L22PD+3)  OBSERVED VALUE SQUARED
C
C  ISTORE(L22PD+4)  PARAMETER 1
C   STORE(L22PD+5)  P. D. FOR PARAMETER 1
C  .
C  .
C
C----- COMMAND FILE SWITCHES
C
C   1.DEFINE         2.RESTRAIN       3.DISTANCES      4.ANGLES
C   5.VIBRATIONS     6.COMPILER       7.EXECUTION      8.NO
C   9.FUNCTION      10.U(IJ)'S       11.TERM          12.EQUATE
C  13.PLANAR        14.SUM           15.FORM          16.AVERAGE
C  17.LIMIT         18.ENERGY        19.ORIGIN
C
C----- ISTORE (LCG+1) OPERATIONS
C      1  DEFINE    2  RESTRAIN  3  DISTANCE 4
C      5            6  ANGLE     7           8
C      9  VIBRATION 10 EXECUTION 11 NOLIST   12 UIJ
C      13 EQUATE    14 PLANAR    15 SUM      16 FORM
C      17 AVERAGE   18 LIMIT     19 ENERGY   20 ORIGIN
C
C      21 UXZBAR    22 UYZBAR    23 UZZBAR   24 UPERP
C      25 unused    26 UALIGN    27 URIGU    28 ULIJ     
C      29 UPLANE    30 UXXQIV    31 UXYQIV   32 UXZQIV   
C      33 UYYQIV    34 UYZQIV    35 UZZQIV   36 UEIG
C      37 UQISO     38 UVOL      39 UEQIV    40 UTLS
C
C Don't forget to chage coperation in preset.F !!
C--
C
      use, intrinsic :: IEEE_ARITHMETIC
      use list26_mod
      use list12_mod, only: load_lsq_params
      use lists2_mod, only: xldlst
C
      interface 
          subroutine XAPP16(savederivatives)
              logical, optional, intent(in) :: savederivatives
          end subroutine
      end interface
      interface 
          subroutine XCDEF(results)
              use list26_mod
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
      interface 
          function KPLANE(in, results)
              use list26_mod
              integer in
              type(restraints_t), intent(inout), optional :: results
          end function
      end interface
      interface 
          subroutine XCDC(iasym, results)
              use list26_mod
              integer iasym
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
      
      
      character(len=1024) :: formatstr
      DIMENSION A1(3)
      INTEGER DIST, ANGLE, STROM, DEG
      DIMENSION DIST(3),ANGLE(3),MSD(3),STROM(2),DEG(2)
      INTEGER UIJ, CONT
      INTEGER CYCLER
      DIMENSION UIJ(3), CONT(3)
      DIMENSION KF1(1),IQ1(1),IB1(1)
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XLST02.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST11.INC'
      INCLUDE 'XSTR11.INC'
      INCLUDE 'XLST12.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XAPK.INC'
      INCLUDE 'XOPK.INC'
      INCLUDE 'XSCALE.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'XL26WK.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'ICOM12.INC'
      INCLUDE 'ICOM11.INC'
      
      real, dimension(:), allocatable :: leverages
      
C
      EQUIVALENCE (KF,KF1(1)),(IQ,IQ1(1)),(IB,IB1(1))
      
C
      DATA IVERSN /404/
C
#ifdef _HOL_ 
      DATA DIST(1)/4Hdist/,DIST(2)/4Hance/,DIST(3)/4Hs   /
      DATA ANGLE(1)/4H ang/,ANGLE(2)/4Hles /,ANGLE(3)/4H    /
      DATA MSD(1)/4H M.S/,MSD(2)/4H.D.'/,MSD(3)/4Hs   /
      DATA STROM(1)/4HAngs/,STROM(2)/4Htrom/
      DATA DEG(1)/4Hdegr/,DEG(2)/4Hees /
      DATA UIJ(1)/4H  U(/,UIJ(2)/4HIJ)'/,UIJ(3)/4Hs   /
      DATA CONT(1)/4Hcont/,CONT(2)/4Hacts/,CONT(3)/4H    /
C
#else
      DATA DIST(1)/'dist'/,DIST(2)/'ance'/,DIST(3)/'s   '/
      DATA ANGLE(1)/' ang'/,ANGLE(2)/'les '/,ANGLE(3)/'    '/
      DATA MSD(1)/' M.S'/,MSD(2)/'.D.'''/,MSD(3)/'s   '/
      DATA STROM(1)/'Angs'/,STROM(2)/'trom'/
      DATA DEG(1)/'degr'/,DEG(2)/'ees '/
      DATA UIJ(1)/'  U('/,UIJ(2)/'IJ)'''/,UIJ(3)/'s   '/
      DATA CONT(1)/'cont'/,CONT(2)/'acts'/,CONT(3)/'    '/
#endif
C
      ircpt=0 ! counter for the restraints as in list 16
C--INITIATE THE TIMING
      CALL XTIME1(2)
C--READ THE REMAINING CONTROL CARDS
      I=KRDDPV(ISTORE(NFL),1)
      IF ( I .LT. 0 ) GO TO 9910
C----- SET MONITOR LEVEL
      IMON = ISTORE(NFL)
C--WRITE OUT A COUPLE OF CAPTIONS
      CALL XPRTCN
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1000)
1000  FORMAT(26H  Restraints checking  -  ,/,
     2 42H  restraints that produce no contributions,
     3 22H are marked with a '?')
C
C---- SET TYPE AND INITIALISE THE NO DERIVATIVES FOUND COUNTER
      L26TYP = 0       ! 0 = CHECK 
      L26WRN = 0
      
      ! Hijacking sfls subroutine to setup the object from list26_mod.F90
      call XAPP16(savederivatives=.false.)
      
      ! Load the list of parameter names
            
C--LOAD LIST 5 and 12 FROM THE DISC
C this is before the clear of core and loading of everything needed for the restraints
C to avoid problems down the line
      CALL XFAL05
      IF ( IERFLG .LT. 0 ) GO TO 9900
      JQ=2
      JS=1
      CALL XFAL12(JS,JQ,JR,JN)

      call load_lsq_params(parameters_list)
#if defined(CRY_OSLINUX)
      print *, 'new size of parameters_list: ', 
     1  sizeof(parameters_list)/1024.0, 'kB'
#endif        
C
C--CLEAR THE CORE AREA
      CALL XRSL
      CALL XCSAE
C----- LOAD LIST 3 IF IT EXISTS
      KLST3 = -1
        IF (KEXIST(3) .GT. 0) CALL XFAL03
C--LOAD LIST 5
      CALL XFAL05
C--SET UP THE SYSTEM VARIABLES IN CORE
      CALL XLSV
C--LOAD LIST 12
      CALL XFAL12(-1,1,JR,JN)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--LINK LIST 5 AND LIST 12
      I=KSET52(0,-1)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--SET UP THE POINTERS FOR THE DERIVATIVE QUEUE ON DISC
      CALL XIPDQF
C--LOAD THE COMPILED LIST FOR PROCESSING
      IULN=26
      CALL XLCLFP(IULN)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--SET THE CARD NUMBER FLAG
      A=-1.
      
      nostop=1
      call XLDLST(-11,ICOM11,size(icom11),0,nostop)
      if(nostop==-1) then ! list26 out of sync with derivatives
        if(allocated(invertm)) deallocate(invertm)
        if(allocated(restraints_derivatives)) then
          deallocate(restraints_derivatives)
        end if
        if(allocated(parameters_list)) deallocate(parameters_list)
      end if
      
      WRITE(CMON,'("{3,15", A)') repeat('-',80)
      CALL XPRVDU(NCVDU, 1,0)      
      WRITE(CMON,'("{3,15", 1X, A)') 'Checking restraints'
      CALL XPRVDU(NCVDU, 1,0)      
      WRITE(CMON,'("{3,15", A)') repeat('-',80)
      CALL XPRVDU(NCVDU, 1,0)      
                  
C--BRING DOWN THE NEXT BLOCK OF CODE AND RELOCATE IT
1050  CONTINUE
      A=A+1.
      NN=1
C--LOAD THE NEXT CARD FOR PROCESSING
      IF(KLOADR(LN))3900,1100,3800
C--JUMP ON THE FUNCTION
1100  CONTINUE
      I=ISTORE(LCG+1)
cdjwsep2011
      if(i .lt. 1) then
       iasym = 1
       i = abs(i)
      else
       iasym = 0
      endif
      M22PD=KNEXTF(L22PD)
C--FETCH THE OBSERVED VALUE AND CALCULATE THE E.S.D.
      B=STORE(LCG+4)
C--CHECK IF WE CAN COMPUTE THE WEIGHT IN THIS CASE
      IF(I-16)1150,1200,1150
C--COMPUTE THE SQUARE ROOT OF THE WEIGHT
1150  CONTINUE
      C=1./SQRT(STORE(LCG+3))
C--SET THE CONVERSION FACTOR
1200  CONTINUE
      CONV=1.
C 1300 DEFINE
C 1350 RESTRAIN
C 1550 SINGLE DISTANCE
C 1750 DIFFERENCE DISTANCE
C 1850 MEAN DISTANCE
C 1950 SINGLE ANGLE
C 2100 DIFFERENCE ANGLE
C 2150 MEAN ANGLE
C 2200 VIBRATION
C 2350 EXECUTION
C 2400 NO(THING)
C 2450 U(IJ)
C 1050 equate
C 4000 PLANAR
C 4300 SUM
C 1050 form
C 4400 AVERAGE
C 4370 LIMIT
C 1710 ENERGY 
C 5000 ORIGIN
C 5010 UXZBAR
C 5020 UYZBAR
C 5030 UZZBAR
C 5040 UPERP
C 5050 unused
C 5060 UALIGN
C 5070 URIGU
C 5080 ULIJ
C 5090 UPLANE
C 5500 UXXQIV
C 5510 UXYQIV
C 5520 UXZQIV
C 5530 UYYQIV
C 5540 UYZQIV
C 5550 UZZQIV
C 5560 UEIG
C 5570 UQISO
C 5580 UVOL
C 5590 UEQIV
C 5600 UTLS
C 1250
c
      write(cmon,'(a)') ''
      call xprvdu(ncvdu,1,0)
      ircpt=ircpt+1
      
      if(.not. allocated(restraints_list)) then
        write(cmon,'(A,A)') "{E Error: Run a refinement cycle ",
     1    "before issuing \check"
        call xprvdu(ncvdu,1,0)
        return
      end if
      
      ! Write user restraint, first element is index in list 16 from zero
      if(i/=10) then ! skip exec
        if(ircpt<1 .or. ircpt>size(restraints_list)) then
          IF (ISSPRT .EQ. 0) then
            WRITE(NCWU,'(A)') '___________'
            WRITE(NCWU,'(1X, "(",I0,")",1X, A)') 
     1        sign(ircpt,-1), 'Unknown restraint'
          end if

          WRITE(CMON,'(1X, "(",I0,")",1X, A)') 
     1      sign(ircpt,-1), 'Unknown restraint'
          CALL XPRVDU(NCVDU, 1,0)      
        else
          IF (ISSPRT .EQ. 0) then
            WRITE(NCWU,'(A)') '___________'
            WRITE(NCWU,'(1X, "(",I0,")",1X, A)') 
     1        restraints_list(ircpt)%user_index,
     2        trim(restraints_list(ircpt)%restraint_text)
          end if

          icptn=index(restraints_list(ircpt)%restraint_text, char(10))
          if(icptn>0) then
            WRITE(CMON,'("{I",1X, "(",I4,")",1X, A)') 
     1        restraints_list(ircpt)%user_index, 
     2        trim(restraints_list(ircpt)%restraint_text(1:icptn-1))          
            CALL XPRVDU(NCVDU, 1,0)      
            
            icptn=icptn+1
            do ii=icptn, len_trim(restraints_list(ircpt)%restraint_text)
              if(restraints_list(ircpt)%restraint_text(ii:ii)==char(10))
     1          then
                WRITE(CMON,'("{I",1X, 6X,1X, A)') 
     1           trim(restraints_list(ircpt)%restraint_text(icptn:ii-1))          
                CALL XPRVDU(NCVDU, 1,0)      
                icptn=ii+1
              end if
            end do
            WRITE(CMON,'("{I",1X, 6X,1X, A)') 
     1        trim(restraints_list(ircpt)%restraint_text(icptn:))          
            CALL XPRVDU(NCVDU, 1,0)      
          else
            WRITE(CMON,'("{I",1X, "(",I4,")",1X, A)') 
     1        restraints_list(ircpt)%user_index, 
     2        trim(restraints_list(ircpt)%restraint_text)          
            CALL XPRVDU(NCVDU, 1,0)                
          end if
          
          ! writing short description of restraint
          if(trim(restraints_list(ircpt)%short_desc)/='') then
            IF (ISSPRT .EQ. 0) THEN       
              write(ncwu, '(A,A)') ' -- ', 
     1          trim(restraints_list(ircpt)%short_desc)
              write(ncwu, '(A)') ''
            end if
            write(cmon, '(A,A)') ' -- ', 
     1        trim(restraints_list(ircpt)%short_desc)
            CALL XPRVDU(NCVDU, 1,0)
            write(cmon, '(A)') ''
            CALL XPRVDU(NCVDU, 1,0)
          end if
        end if
      end if
      
      GOTO(1300,1350,1550,1750,1850,1950,2100,2150,2200,2350,
     1     2400,2450,1050,4000,4300,1050,4400,4370,1710,5000,
     2     5010,5020,5030,5040,5050,5060,5070,5080,5090,5500,
     3     5510,5520,5530,5540,5550,5560,5570,5580,5590,5600,1250) ,I
1250  CONTINUE
      CALL XOPMSG (IOPL16, IOPINT, 0)
      GOTO 9900
C
C--'DEFINE' FUNCTION
1300  CONTINUE
      CALL XCDEF()
      
      if(allocated(restraints_list(ircpt)%subrestraints)) then
      if(size(restraints_list(ircpt)%subrestraints)>0) then
        associate(subrestraints => restraints_list(ircpt)%subrestraints)
          ! lis file output
          IF (ISSPRT .EQ. 0) THEN
            WRITE(NCWU,'(a,a,"=",F0.3)') 'Define ', 'unknown ', 
     1        subrestraints(1)%rvalue
          ENDIF
      
          ! screen output
          WRITE(CMON,'(a,a,"=",F0.3)') 'Define ', 'unknown ', 
     1        subrestraints(1)%rvalue
          CALL XPRVDU(NCVDU, 1,0)      
        end associate
      else      
        IF (ISSPRT .EQ. 0) THEN
          WRITE(NCWU,'(/1X,A)') 'Restraint not applied'
        end if        
        write(cmon, '(A)') 'Restraint not applied'
        CALL XPRVDU(NCVDU, 1,0)            
      end if
      else      
        IF (ISSPRT .EQ. 0) THEN
          WRITE(NCWU,'(/1X,A)') 'Restraint not applied'
        end if        
        write(cmon, '(A)') 'Restraint not applied'
        CALL XPRVDU(NCVDU, 1,0)            
      end if
      
      GOTO 1050
C
C--'RESTRAIN' FUNCTION
1350  CONTINUE
      CALL XCC
      CALL XMOVE(IB1(1),KF1(1),1)
C--CHECK IF ANY DERIVATIVES HAVE BEEN PRODUCED
      IF(ISTORE(L22PD)-4)1450,1400,1450
C--NO DERIVATIVES
1400  CONTINUE
      CALL XMOVE(IQ1(1),KF1(1),1)
       WRITE(CMON,'(A)')'{I  General Restraint: No derivatives found'
       CALL XPRVDU(NCVDU,1,0)
       IF(ISSPRT.EQ.0)
     1 WRITE(NCWU,'(A)')'   General Restraint: No derivatives found'
1450  CONTINUE
C--CALCULATE THE COMPUTED VALUE AND PRINT THE RESULTS
      D=B-STORE(L22PD+2)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1500)A,B,C,KF,D,STORE(L22PD+2)
1500  FORMAT(//1H ,F4.0,26H  General restraint to be ,E20.10,
     2 19H  with an E.S.D. of,E20.10/3X,A1,1X,18H  Calculated value,
     3 8X,E20.10,19H  giving a delta of,E20.10)
      WRITE(CMON,1610)NINT(A), '   General restraint', B,C
      CALL XPRVDU(NCVDU, 1,0)
      
      ! leverages
      call showleverage(ircpt, -1)

      GOTO 1050
C
C--'SINGLE DISTANCE' RESTRAINTS
1550  CONTINUE
      CALL XCDC(iasym)
      N=2
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1600)A,(DIST(M),M=1,3),B,(STROM(M),M=1,2),C
      ENDIF
1600  FORMAT(/1X,F4.0,' Restrain these ',2A4,A1,' to be',
     2 F9.3,1X,2A4,',',/15X,' with an E.S.D. of',F8.3)
      WRITE(CMON,1610)NINT(A), '      Given distance', B,C
      CALL XPRVDU(NCVDU, 1,0)
1610  FORMAT(I5, 1X, A, '. ', 'Target ',F7.3, ' esd ', F7.3)
C
1650  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1700)(NUMB(M),M=2,3),(DIST(M),M=1,3),(IB,M=1,N)
      ENDIF
1700  FORMAT(/5X,2(7X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ),3X,2A4,A1,
     2 2A1,2X,5HDelta)
      GOTO 2500
C
C
C--'ENERGY ' RESTRAINTS
1710  CONTINUE
      CALL XCEC(iasym)
      N=2
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1720)A,(CONT(M),M=1,3),B,(STROM(M),M=1,2),C
      ENDIF
1720  FORMAT(/1H ,F4.0,16H Restrain these ,2A4,A1,6H to be,
     2 F9.3,1X,2A4,22H, with Power Factor of,F4.1)
      WRITE(CMON,1610)NINT(A), ' non-bonded distance', B,C
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 1650
C
C--'DISTANCE DIFFERENCE' RESTRAINTS
1750  CONTINUE
      CALL XCDDC(iasym)
      N=1
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1800)A,(DIST(M),M=1,3),B,(STROM(M),M=1,2),C
      ENDIF
1800  FORMAT(/1X ,F4.0,
     2 '   Restrain the differences between the following ',2A4,A1,
     3 ' to be' /,F9.3,2X,2A4,',',' with an E.S.D. of ',F8.3)
      WRITE(CMON,1610)NINT(A), ' distance difference', B,C
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 1650
C
C--'MEAN DISTANCE' RESTRAINT
1850  CONTINUE
      CALL XCMDC(iasym)
      N=2
      B=STORE(LCG+4)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1900)A,(DIST(M),M=1,3),B,(STROM(M),M=1,2),C
      ENDIF
1900  FORMAT(/1H ,F4.0,'   Restrain the following ',2A4,A1,
     2 ' to their common mean of ',F9.3,1X,2A4,/
     3 49X,'with an E.S.D. of', F8.3)
      WRITE(CMON,1610)NINT(A), '       Mean distance', B,C
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 1650
C
C--'SINGLE ANGLE' RESTRAINTS
1950  CONTINUE
      CALL XCAC
      N=2
      CONV=RTD
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1600)A,(ANGLE(M),M=1,3),B,(DEG(M),M=1,2),C
      ENDIF
      WRITE(CMON,1960)NINT(A), '         Given angle', B,C
      CALL XPRVDU(NCVDU, 1,0)
1960  FORMAT(I5, 1X, A, '. ', 'Target ',F7.2, ' esd ', F7.2)
C
C
2000  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2050)(NUMB(M),M=2,4),(ANGLE(M),M=1,2),(IB,M=1,N)
      ENDIF
2050  FORMAT(/5X,3(7X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ),3X,A4,A3,2A1,
     2 5HDelta)
      GOTO 2500
C
C--'ANGLE DIFFERENCE' RESTRAINTS
2100  CONTINUE
      CALL XCADC
      N=1
      CONV=RTD
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1800)A,(ANGLE(M),M=1,3),B,(DEG(M),M=1,2),C
      ENDIF
      WRITE(CMON,1960)NINT(A), '    angle difference', B,C
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 2000
C
C--'MEAN ANGLE' RESTRAINT
2150  CONTINUE
      CALL XCMAC
      N=2
      B=STORE(LCG+4)
      CONV=RTD
      B=B*CONV
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1900)A,(ANGLE(M),M=1,3),B,(DEG(M),M=1,2),C
      ENDIF
      WRITE(CMON,1960)NINT(A), '          Mean angle', B,C
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 2000
C
C--'VIBRATION' RESTRAINT
2200  CONTINUE
      CALL XCVC(IASYM)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2250)A,(MSD(M),M=1,3),B,C
      ENDIF
2250  FORMAT(/1X,F4.0,'DELU - Restrain the difference in the',2A4,A1,
     2 ' along a bond to be',/6x,F9.5,
     3 '  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,2260)NINT(A), 'Vibration difference', B,C
      CALL XPRVDU(NCVDU, 1,0)
2260  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)

      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2300)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
2300  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500
C
C--'UXZBAR' RESTRAINT
5010  CONTINUE
C To be replaced with JA routine:
      CALL XCVCX(1,IASYM)
c      WRITE(*,*)'Hello UXZBar'
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,5011)A,B,C
      ENDIF
5011  FORMAT(/1X,F4.0,
     1 'UXZBAR - Restrain the covariance perp. to X and bond to be '
     2 /6x,F9.5,'  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,5012)NINT(A+1), 'Covariance difference XZ ', B,C
      CALL XPRVDU(NCVDU, 1,0)
5012  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)
      IF (ISSPRT .EQ. 0) THEN
         WRITE(NCWU,5013)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
5013  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500
C
C--'UYZBAR' RESTRAINT
5020  CONTINUE
C To be replaced with JA routine:
      CALL XCVCX(2,IASYM)
c      WRITE(*,*)'Hello UYZBar'
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,5021)A,B,C
      ENDIF
5021  FORMAT(/1X,F4.0,
     1'UYZBAR - Restrain the covariance perp to UXZBAR and bond to be '
     2 /6x,F9.5,'  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,5022)NINT(A+1), 'Covariance difference YZ', B,C
      CALL XPRVDU(NCVDU, 1,0)
5022  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)

      IF (ISSPRT .EQ. 0) THEN
         WRITE(NCWU,5023)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
5023  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500

C--'UZZBAR' RESTRAINT
5030  CONTINUE
C To be replaced with JA routine:
      CALL XCVCX(3,IASYM)
c      WRITE(*,*)'Hello UZZBar'
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,5031)A,B,C
      ENDIF
5031  FORMAT(/1X,F4.0,
     1 'UZZBAR - Restrain the covariance perp. to X and bond to be '
     2 /6x,F9.5,'  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,5032)NINT(A+1), 'Variance difference ZZ ', B,C
      CALL XPRVDU(NCVDU, 1,0)
5032  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)
      IF (ISSPRT .EQ. 0) THEN
         WRITE(NCWU,5033)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
5033  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500
      
C--'UPERP' RESTRAINT
5040  CONTINUE
      NN=0
      GOTO 2500
      
C--'UPERP2' RESTRAINT
5050  CONTINUE
      ! unused
      GOTO 2500
C
C--'UALIGN' RESTRAINT
5060  CONTINUE
      NN=0
      GOTO 2500
C
C--'URIGU' RESTRAINT
5070  CONTINUE
      NN=0
      GOTO 2500
C
C--'ULIJ' RESTRAINT
5080  CONTINUE
      NN=0
      GOTO 2500

C--'UPLANE' RESTRAINT
5090  CONTINUE
      NN=0
      GOTO 2500
C
C--'UXXQIV' RESTRAINT
5500  CONTINUE
C To be replaced with JAA routine:
      CALL XCVCY(1,IASYM)
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,5501)A,B,C
      ENDIF
5501  FORMAT(/1X,F4.0,
     1 'UXXQIV - Restrain the covariance perp. to X and bond to be '
     2 /6x,F9.5,'  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,5502)NINT(A+1), 'Difference XX ', B,C
      CALL XPRVDU(NCVDU, 1,0)
5502  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)
      IF (ISSPRT .EQ. 0) THEN
         WRITE(NCWU,5503)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
5503  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500
C
C--'UXYQIV' RESTRAINT
5510  CONTINUE
C To be replaced with JAA routine:
      CALL XCVCY(2,IASYM)
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,5511)A,B,C
      ENDIF
5511  FORMAT(/1X,F4.0,
     1 'UXYQIV - Restrain the covariance perp. to X and bond to be '
     2 /6x,F9.5,'  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,5512)NINT(A+1), 'Difference XY ', B,C
      CALL XPRVDU(NCVDU, 1,0)
5512  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)
      IF (ISSPRT .EQ. 0) THEN
         WRITE(NCWU,5513)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
5513  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500
C
C--'UXZQIV' RESTRAINT
5520  CONTINUE
C To be replaced with JAA routine:
      CALL XCVCY(3,IASYM)
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,5521)A,B,C
      ENDIF
5521  FORMAT(/1X,F4.0,
     1 'UXZQIV - Restrain the covariance perp. to X and bond to be '
     2 /6x,F9.5,'  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,5522)NINT(A+1), 'Difference XZ ', B,C
      CALL XPRVDU(NCVDU, 1,0)
5522  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)
      IF (ISSPRT .EQ. 0) THEN
         WRITE(NCWU,5533)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
5523  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500
C
C--'UYYQIV' RESTRAINT
5530  CONTINUE
C To be replaced with JAA routine:
      CALL XCVCY(4,IASYM)
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,5531)A,B,C
      ENDIF
5531  FORMAT(/1X,F4.0,
     1 'UYYQIV - Restrain the covariance perp. to X and bond to be '
     2 /6x,F9.5,'  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,5532)NINT(A+1), 'Difference YY ', B,C
      CALL XPRVDU(NCVDU, 1,0)
5532  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)
      IF (ISSPRT .EQ. 0) THEN
         WRITE(NCWU,5533)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
5533  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500
C
C--'UYZQIV' RESTRAINT
5540  CONTINUE
C To be replaced with JAA routine:
      CALL XCVCY(5,IASYM)
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,5541)A,B,C
      ENDIF
5541  FORMAT(/1X,F4.0,
     1 'UYZQIV - Restrain the covariance perp. to X and bond to be '
     2 /6x,F9.5,'  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,5542)NINT(A+1), 'Difference YZ ', B,C
      CALL XPRVDU(NCVDU, 1,0)
5542  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)
      IF (ISSPRT .EQ. 0) THEN
         WRITE(NCWU,5543)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
5543  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500
C
C--'UZZQIV' RESTRAINT
5550  CONTINUE
C To be replaced with JAA routine:
      CALL XCVCY(6,IASYM)
      IF (ISSPRT .EQ. 0) THEN
        WRITE(NCWU,5551)A,B,C
      ENDIF
5551  FORMAT(/1X,F4.0,
     1 'UZZQIV - Restrain the covariance perp. to X and bond to be '
     2 /6x,F9.5,'  angstrom squared, with an E.S.D. of',F9.5)
      WRITE(CMON,5552)NINT(A+1), 'Difference ZZ ', B,C
      CALL XPRVDU(NCVDU, 1,0)
5552  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)
      IF (ISSPRT .EQ. 0) THEN
         WRITE(NCWU,5553)(NUMB(N),(MSD(M),M=1,3),N=2,3)
      ENDIF
5553  FORMAT(/2X,2(10X,4HAtom,2X,A1,4X,15HS(I) L TX TY TZ,3X,2A4,A1),
     2 4X,5HDelta,A1,4X,8HCoord.'S)
      N=2
      GOTO 2500
      
C--'eigen value restraint UEIG' RESTRAINT
5560  CONTINUE
      NN=0
      GOTO 2500

C--'UQISO' RESTRAINT. near isotropic restraint
5570  CONTINUE
      NN=0
      GOTO 2500

C--'UVOL' RESTRAINT. restrain the volume to be equal
5580  CONTINUE
      NN=0
      GOTO 2500

C--'UEQIV' RESTRAINT. restrain the volume to be equal
5590  CONTINUE
      NN=0
      GOTO 2500

C--'UTLS' RESTRAINT
5600  CONTINUE
      NN=0
      GOTO 2500
      
C
C
C--'EXECUTION LISTING'
2350  CONTINUE
      ISTAT2=1
      GOTO 1050
C
C--'NO LISTING'
2400  CONTINUE
      WRITE(CMON,'(6X,A)') 'No output'
      CALL XPRVDU(NCVDU, 1,0)
      ISTAT2=0
      GOTO 1050
C
C--'U(IJ)' RESTRAINT
2450  CONTINUE
      CALL XDUIJ(iasym)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2251)A,(UIJ(M),M=1,3),B,C
2251  FORMAT(/4X ,F4.0,'SIMU - Restrain the difference',
     1 ' in the components of',  2A4,A1,
     2 ' to be',/6x,F9.5,
     3 '  angstrom squared, with an E.S.D. of',F9.5)
      ENDIF
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2300)(NUMB(N),(UIJ(M),M=1,3),N=2,3),IB
      ENDIF
      WRITE(CMON,2460)NINT(A), '      Uij difference', B,C
      CALL XPRVDU(NCVDU, 1,0)
2460  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F7.4)
      N=2
      GOTO 2500
C
C--GENERAL PRINT ROUTINES
2500  CONTINUE
      M22PD=KNEXTF(L22PD)
      JA=LCA
      O=0.
      P=0.
      Q=0.
      NCA=0
      JI=JH
      ITEMPA=M22PD
C--LOOP FOR PRINTING EACH INDIVIDUAL RESTRAINT
2550  CONTINUE
      CALL XDOWNF(M22PD,STORE(L22PD),4)
      M22PD=M22PD+KINCRF(ISTORE(L22PD))
C--CHECK IF THIS RESTRAINT IS USEFUL
C Watch out for Uij - this can have up to 6 individual restraints 
c per atom - dealt with under Uij
      if(i.ne.12) then
        CALL XMOVE(IB1(1),KF1(1),1)
        IF(ISTORE(L22PD).eq.4) THEN
         WRITE(CMON,'(A,2x,A,A,A)')'{I ', 
     1   COPERATION(I)(1:NCTRIM(COPERATION(I))),
     1 ' restraint:', ' No derivatives found'
         CALL XPRVDU(NCVDU,1,0)
         IF(ISSPRT.EQ.0)
     1 WRITE(NCWU,'(2x,A,A,A)')COPERATION(I)(1:nctrim(COPERATION(I))),
     1 ' restraint: ', ' No derivatives found'
         CALL XMOVE(IQ1(1),KF1(1),1)
        ENDIF
      endif
2650  CONTINUE
C--SET UP A FEW CONSTANTS
      JD=JA+7
      JE=JA+11
      JB=ISTORE(JA)
      JF=JB+7
      JG=JB+11
      NCA=NCA+1
      ISTORE(JA+3)=NINT(STORE(JA+3))
C--CHECK IF THERE IS MORE THAN ONE ATOM IN THIS RESTRAINT
      IF(NN)2750,2750,2700
2700  CONTINUE
      ISTORE(JB+3)=NINT(STORE(JB+3))
C--CALCULATE THE 'DELTA' AND 'CALCULATED' VALUES
2750  CONTINUE
      A1(2)=STORE(L22PD+2)*CONV
      A1(1)=B-A1(2)
C--BRANCH ON THE TYPE OF RESTRAINTS
      GOTO(1050,1050,2850,3000,2850,3050,3150,3050,3200,1050,1050,3300,
     2 1050,4150,1050,1050,4550,4540,2850,1050,3280,3290,3270,3285,3295,
     2 3260,3261,3262,3263,3264,3265,3266,3267,3268,3269,3271,
     2 3272,3273,3274,3275,2800),I
2800  CONTINUE
      CALL XOPMSG (IOPL16, IOPINT, 0)
      GOTO 9900
C
C--PRINT A DISTANCE RESTRAINT
2850  CONTINUE
C----- GET THE EQUIVALENT SIGMA FOR A 'ENERGY' CARD
      ESIGMA = AMIN1( 1./(SQRT( STORE(L22PD + 1) ) ), 10.)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2900)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=1,N)
      ENDIF
2900  FORMAT(2H  ,A1,2X,2(6X,A4,I5,I6,4I3),F11.3,F10.3)
      IF ((IMON .GE. 1) .AND. (ABS(A1(2)) .GE. ESIGMA) ) THEN
         WRITE(CMON ,2901)KF,STORE(JA+2),ISTORE(JA+3),STORE(JB+2),
     2   ISTORE(JB+3),A1(1),A1(2)
         CALL XPRVDU(NCVDU, 1,0)
      ENDIF
2901  FORMAT(1X,A1, 12X, 2(2X,A4,I4),F11.3,F10.3,F12.7)
C--RESET FOR THE NEXT RESTRAINT
2950  CONTINUE
      JA=ISTORE(JB)
      GOTO 3550
C--RESET FOR DISTANCES WHEN DIFFERENCES HAVE BEEN COMPUTED
3000  CONTINUE
      M22PD=ITEMPA
      A1(1)=STORE(JI)
      JI=JI+1
      GOTO 2850
C
C--ANGLES RESTRAINT PRINT
3050  CONTINUE
      JC=ISTORE(JB)
      ISTORE(JC+3)=NINT(STORE(JC+3))
      JL=JC+7
      JM=JC+11
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3100)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),STORE(JC+2),
     3 ISTORE(JC+3),(ISTORE(M),M=JL,JM),(A1(M),M=1,N)
      ENDIF
3100  FORMAT(2H  ,A1,2X,3(6X,A4,I5,I6,4I3),F10.2,F7.2)
      IF ((IMON .GE. 1) .AND. (ABS(A1(2)) .GE. C) ) THEN
         WRITE(CMON,3101)KF,STORE(JA+2),ISTORE(JA+3),STORE(JB+2),
     2   ISTORE(JB+3),STORE(JC+2),ISTORE(JC+3),A1(1),A1(2)
         CALL XPRVDU(NCVDU, 1,0)
      ENDIF
3101  FORMAT(1X,A1, 2X, 3(2X,A4,I4),F7.2,F7.2)
      JA=ISTORE(JC)
      GOTO 3550
C--ANGLE RESTRAINT PRINT FOR DIFFERENCES
3150  CONTINUE
      M22PD=ITEMPA
      A1(1)=STORE(JI)*CONV
      JI=JI+1
      GOTO 3050
C
C--VIBRATION RESTRAINTS PRINT
3200  CONTINUE
      A1(3)=A1(2)
      A1(2)=2.*SQRT(STORE(L22PD+3))
      A1(1)=0.5*(A1(2)-A1(3))
      A1(2)=A1(2)-A1(1)-B
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(1),STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=2,3)
      ENDIF
3250  FORMAT(2H  ,A1,2(8X,A4,I5,I6,4I3,F12.5,1X),F9.5,5X,5A4)
      IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C )) THEN
         WRITE(CMON, 3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         CALL XPRVDU(NCVDU, 1,0)
      ENDIF
3251  FORMAT(1X,A1,2X,2(2X,A4,I4,F9.5,1X),F9.5,2X,5A4)
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
      
      GOTO 2950
C--UXZBAR RESTRAINTS PRINT
3280  CONTINUE
      A1(3)=A1(2)
       A1(2)=2.*SQRT(STORE(L22PD+3))
       A1(1)=0.5*(A1(2)-A1(3))
       A1(2)=A1(2)-A1(1)-B
c       write(123,'(i6,2f8.5,2x,2f8.5,5x,3f8.5))') 
c     1 jdjw,adjw,bdjw,store(l22pd+2),store(l22pd+3),a1(1),a1(2),a1(3)
c
c Extracting Uij as a1(1) and a1(2) from Store(l22pd+ ) does not 
c recover the original values because L22pd+3 is a squared value, so the
c sign is lost.
c It might be better to use original values at JS and JT.
c
       IF (ISSPRT .EQ. 0) THEN
       WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 adjw,STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),bdjw,A1(3)
     3 ,(ICOORD(idjw,JJ),idjw=1,NWKA)
       ENDIF
       IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C ))  THEN
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C ))THEN
         WRITE(CMON,3251) KF, STORE(JA+2), ISTORE(JA+3), adjw,
     2   STORE(JB+2),ISTORE(JB+3),bdjw,A1(3),
     3   (ICOORD(idjw,JJ),idjw=1,NWKA)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
       ENDIF
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
      GOTO 2950
CC--UYZBAR RESTRAINTS PRINT
3290  CONTINUE
      A1(3)=A1(2)
      A1(2)=2.*SQRT(STORE(L22PD+3))
      A1(1)=0.5*(A1(2)-A1(3))
      A1(2)=A1(2)-A1(1)-B
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(1),STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=2,3)
      ENDIF
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C )) THEN
c         WRITE(NCAWU,3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
c     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C )) THEN
         WRITE(CMON, 3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
      CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
      GOTO 2950
C--UZZBAR RESTRAINTS PRINT
3270  CONTINUE
      A1(3)=A1(2)
      A1(2)=2.*SQRT(STORE(L22PD+3))
      A1(1)=0.5*(A1(2)-A1(3))
      A1(2)=A1(2)-A1(1)-B
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(1),STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=2,3)
      ENDIF
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C )) THEN
c         WRITE(NCAWU,3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
c     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C )) THEN
         WRITE(CMON, 3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
      GOTO 2950
C
      
3295  CONTINUE
      ! unused
      goto 3600
      
C
C--UPERP RESTRAINTS PRINT
3285  CONTINUE
C--UALIGN RESTRAINTS PRINT
3260  CONTINUE
C--URIGU RESTRAINTS PRINT
3261  CONTINUE
C--UPLANE RESTRAINTS PRINT
3263  CONTINUE
C--UEIG RESTRAINTS PRINT
3271  CONTINUE
C--UQISO RESTRAINTS PRINT
3272  CONTINUE
C--UVOL RESTRAINTS PRINT
3273  CONTINUE
C--UEQIV RESTRAINTS PRINT
3274  CONTINUE
C--ULIJ RESTRAINTS PRINT
3262  CONTINUE
C--UTLS RESTRAINTS PRINT
3275  CONTINUE
      NN=0

      if(allocated(restraints_list(ircpt)%subrestraints)) then
      
        call calcleverages(ircpt, leverages, infolev)
        if(infolev<0) then
          write(cmon, '(4X, A)') 
     1      '{6,0 Do a cycle of refinement to get leverages'
          CALL XPRVDU(NCVDU, 1,0)
          write(cmon, '(A)') ''
          CALL XPRVDU(NCVDU, 1,0)
        end if

        IF (ISSPRT .EQ. 0) THEN 
          if(allocated(restraints_list(ircpt)%description)) then
            do icpt=1, size(restraints_list(ircpt)%description)
              write(ncwu, '(a)') 
     1          trim(restraints_list(ircpt)%description(icpt))
            end do
            write(ncwu, *) ''
          end if
C         Derivatives output only if Execution listing requested        
          if (istat2.eq.1) call printderivatives(ircpt)        
        end if

        numrestraints=size(restraints_list(ircpt)%subrestraints)/
     1   max(1, restraints_list(ircpt)%groups)

        if(istat2.eq.1) then ! Matrices output only if Execution listing requested  
        ! print out transformartion matrices
        write(ncwu, '(4X, A)') 'Transformation matrices:'
        do icpt=1, size(restraints_list(ircpt)%subrestraints), 
     1    2*numrestraints
          jcpt=icpt+numrestraints
          ! print 2 matrices per line
          if(jcpt<=size(restraints_list(ircpt)%subrestraints)) then
            associate(ra => restraints_list(ircpt)%subrestraints(icpt),
     1        rb => restraints_list(ircpt)%subrestraints(jcpt) )
     
              do kcpt=1, max(size(ra%atoms), size(rb%atoms))
                if(kcpt<=size(ra%atoms) .and. 
     1            kcpt<=size(rb%atoms)) then
                  write(ncwu, '(10X, A,"(",I0,")",43X,A,"(",I0,")")') 
     1              trim(ra%atoms(kcpt)%label), 
     2              ra%atoms(kcpt)%serial, 
     1              trim(rb%atoms(kcpt)%label), 
     2              rb%atoms(kcpt)%serial
     
                  do lcpt=1, 3
                    write(ncwu, '(6X, 1P, 3(E10.2,1X),10X,3(E10.2,1X))') 
     1                (/ (ra%atoms(kcpt)%M(lcpt,mcpt), mcpt=1, 
     1                      ubound(ra%atoms(kcpt)%M, 2)) /), 
     2                (/ (rb%atoms(kcpt)%M(lcpt,mcpt), mcpt=1, 
     2                      ubound(rb%atoms(kcpt)%M, 2)) /)
                  end do
                else if(kcpt>size(ra%atoms)) then
                  write(ncwu, '(10X, A,"(",I0,")")') 
     1              trim(rb%atoms(kcpt)%label), 
     2              rb%atoms(kcpt)%serial
     
                  do lcpt=1, 3
                    write(ncwu, '(6X, 1P, 3(E10.2,1X))') 
     2                rb%atoms(kcpt)%M(lcpt,:)
                  end do
                else
                  write(ncwu, '(10X, A,"(",I0,")")') 
     1              trim(ra%atoms(kcpt)%label), 
     2              ra%atoms(kcpt)%serial
     
                  do lcpt=1, 3
                    write(ncwu, '(6X, 1P, 3(E10.2,1X))') 
     2                ra%atoms(kcpt)%M(lcpt,:)
                  end do
                end if            
              end do
              write(ncwu, '(a)') ''
            end associate
          else
            associate(ra => restraints_list(ircpt)%subrestraints(icpt) )
              do kcpt=1, size(ra%atoms)
                write(ncwu, '(10X, A,"(",I0,")")') 
     1            trim(ra%atoms(kcpt)%label), 
     2            ra%atoms(kcpt)%serial 
     
                do lcpt=1, 3
                  write(ncwu, '(6X, 1P, 3(E10.2,1X))') 
     1              (/ (ra%atoms(kcpt)%M(lcpt,mcpt), mcpt=1, 
     1                  ubound(ra%atoms(kcpt)%M, 2)) /)
                end do
              end do
              write(ncwu, '(a)') ''
            end associate        
          end if
        end do
        endif

        do icpt=1, size(restraints_list(ircpt)%subrestraints)
          associate(subrestraint => 
     1      restraints_list(ircpt)%subrestraints(icpt))

          ! print table header
          if(mod(icpt-1,numrestraints)==0) then
            IF (ISSPRT .EQ. 0) THEN       
              if(size(subrestraint%atoms)>1) then
                write(formatstr,'(I0,A)') size(subrestraint%atoms), 
     1           '(A,"(",I0,")",:,",")'
                formatstr='('//'4X,A,A,"(",I0,")",A,'//
     1            trim(formatstr)//')'
                write(ncwu, formatstr) 'Atom ',
     2            trim(subrestraint%atoms(1)%label),
     3            subrestraint%atoms(1)%serial,
     4            ', basis: ',
     5            ( trim(subrestraint%atoms(m)%label), 
     6              subrestraint%atoms(m)%serial, 
     7              m=1, size(subrestraint%atoms) )
              else
                write(ncwu, '(4X,A, A,"(",I0,")")') 'Atom ',
     2            trim(subrestraint%atoms(1)%label),
     3            subrestraint%atoms(1)%serial
              end if
              write(ncwu, '(4X,A18, 3(A12,1X),A8,4X,A)') 
     1          'S(I) L TX TY TZ', 'Value', 'target', 
     2          'Difference', 'Leverage', 'Description'
            end if

            if(size(subrestraint%atoms)>1) then
              write(formatstr,'(I0,A)') size(subrestraint%atoms), 
     1          '(A,"(",I0,")",:,",")'
             formatstr='('//'4X,A,A,"(",I0,")",A,'//trim(formatstr)//')'
              write(cmon, formatstr) 'Atom ',
     2          trim(subrestraint%atoms(1)%label),
     3          subrestraint%atoms(1)%serial,
     4          ', basis: ',
     5          ( trim(subrestraint%atoms(m)%label), 
     6            subrestraint%atoms(m)%serial, 
     7            m=1, size(subrestraint%atoms) )
              CALL XPRVDU(NCVDU, 1,0)
            else
              write(cmon, '(4X,A, A,"(",I0,")")') 'Atom ',
     2          trim(subrestraint%atoms(1)%label),
     3         subrestraint%atoms(1)%serial
              CALL XPRVDU(NCVDU, 1,0)
            end if
          
            write(cmon, '(4X,3(A12,1X),A8,4X,A)') 'Value', 'target', 
     1        'Difference', 'Leverage', 'Description'
            CALL XPRVDU(NCVDU, 1,0)
          end if
          ! end of header

          if(infolev>=0) then
            if(leverages(icpt)>=0.9) then ! color code extreme values <=0.1 and >=0.9
              icolorindex=3
            else if(leverages(icpt)<=0.1) then
              icolorindex=2
            else
              icolorindex=1
            end if

            IF (ISSPRT .EQ. 0) THEN       
              WRITE(NCWU,'(4X,I6,4I3,3(1PE12.2,1X),0PF8.3,4X, A)')
     2          (ISTORE(M),M=JD,JE),
     3          subrestraint%rvalue,
     3          subrestraint%rtarget,
     3          subrestraint%rvalue-subrestraint%rtarget,
     4          leverages(icpt),
     5          trim(subrestraint%description)
            ENDIF      
            
            WRITE(CMON, 
     1      '(4X,1P,3(E12.2,1X),"{",I0,",",I0,1X,0P, F7.3,"{1,0",4X,A)') 
     2        subrestraint%rvalue,
     3        subrestraint%rtarget,
     4        subrestraint%rvalue-subrestraint%rtarget,
     5        icolorindex, 0, 
     6        leverages(icpt),
     7        trim(subrestraint%description)
            CALL XPRVDU(NCVDU, 1,0)
          else
            icolorindex=1
            IF (ISSPRT .EQ. 0) THEN       
              WRITE(NCWU,'(4X,I6,4I3,3(1PE12.2,1X),8X,4X, A)')
     2          (ISTORE(M),M=JD,JE),
     3          subrestraint%rvalue,
     3          subrestraint%rtarget,
     3          subrestraint%rvalue-subrestraint%rtarget,
     5          trim(subrestraint%description)
            ENDIF      
            
            WRITE(CMON, 
     1      '(4X,1P,3(E12.2,1X),"{",I0,",",I0,1X,7X,"{1,0",4X,A)') 
     2        subrestraint%rvalue,
     3        subrestraint%rtarget,
     4        subrestraint%rvalue-subrestraint%rtarget,
     5        icolorindex, 0, 
     7        trim(subrestraint%description)
            CALL XPRVDU(NCVDU, 1,0)
          end if
          Q=Q+subrestraint%rvalue
          O=O+subrestraint%rvalue
          P=P+subrestraint%rvalue**2
     
          end associate
        end do
        NCA=size(restraints_list(ircpt)%subrestraints)/
     1    max(1, restraints_list(ircpt)%groups)
        WRITE(CMON, '(A)') ''
        CALL XPRVDU(NCVDU, 1,0)
      else      
        IF (ISSPRT .EQ. 0) THEN
          WRITE(NCWU,'(/1X,A)') 'Restraint not applied'
        end if        
        write(cmon, '(A)') 'Restraint not applied'
        CALL XPRVDU(NCVDU, 1,0)            
      end if
      N=0 ! do not print mean deviation
      GOTO 1050
C         
C--UXXQIV RESTRAINTS PRINT
3264  CONTINUE
      
      A1(3)=A1(2)
      A1(2)=2.*SQRT(STORE(L22PD+3))
      A1(1)=0.5*(A1(2)-A1(3))
      A1(2)=A1(2)-A1(1)-B
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(1),STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=2,3)
      ENDIF
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C )) THEN
c         WRITE(NCAWU,3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
c     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C )) THEN
         WRITE(CMON, 3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
c     print *,
c     print *, 'Cycle 0: ',ISTORE(JA)
      CYCLER = ISTORE(JA)           ! Cycle 1
c     print *, 'Cycle 1: ',ISTORE(CYCLER)
      CYCLER = ISTORE(CYCLER)       ! Cycle 2
c     print *, 'Cycle 2: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 3
C     print *, 'Cycle 3: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 4
C     print *, 'Cycle 4: ',ISTORE(CYCLER)
      JA=ISTORE(CYCLER)             ! Final Cycle
c     print *, 'Cycle 5: ',ISTORE(JA)
c     print *, 'JA: ',JA
c      print *,
      GOTO 3550
C         
C--UXYQIV RESTRAINTS PRINT
3265  CONTINUE
      A1(3)=A1(2)
c     print *, 'L22PD read', L22PD
      A1(2)=2.*SQRT(STORE(L22PD+3))
      A1(1)=0.5*(A1(2)-A1(3))
      A1(2)=A1(2)-A1(1)-B
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(1),STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=2,3)
      ENDIF
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C )) THEN
c         WRITE(NCAWU,3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
c     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C )) THEN
         WRITE(CMON, 3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
c     print *,
c     print *, 'Cycle 0: ',ISTORE(JA)
      CYCLER = ISTORE(JA)           ! Cycle 1
c     print *, 'Cycle 1: ',ISTORE(CYCLER)
      CYCLER = ISTORE(CYCLER)       ! Cycle 2
c     print *, 'Cycle 2: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 3
C     print *, 'Cycle 3: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 4
C     print *, 'Cycle 4: ',ISTORE(CYCLER)
      JA=ISTORE(CYCLER)             ! Final Cycle
c     print *, 'Cycle 5: ',ISTORE(JA)
c     print *, 'JA: ',JA
c      print *,
      JA = -1000000
      GOTO 3550
C         
C--UXZQIV RESTRAINTS PRINT
3266  CONTINUE
      A1(3)=A1(2)
      A1(2)=2.*SQRT(STORE(L22PD+3))
      A1(1)=0.5*(A1(2)-A1(3))
      A1(2)=A1(2)-A1(1)-B
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(1),STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=2,3)
      ENDIF
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C )) THEN
c         WRITE(NCAWU,3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
c     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C )) THEN
         WRITE(CMON, 3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
c     print *,
c     print *, 'Cycle 0: ',ISTORE(JA)
      CYCLER = ISTORE(JA)           ! Cycle 1
c     print *, 'Cycle 1: ',ISTORE(CYCLER)
      CYCLER = ISTORE(CYCLER)       ! Cycle 2
c     print *, 'Cycle 2: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 3
C     print *, 'Cycle 3: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 4
C     print *, 'Cycle 4: ',ISTORE(CYCLER)
      JA=ISTORE(CYCLER)             ! Final Cycle
c     print *, 'Cycle 5: ',ISTORE(JA)
c         print *, 'JA: ',JA
c      print *,
      JA = -1000000
      GOTO 3550
C         
C--UYYQIV RESTRAINTS PRINT
3267  CONTINUE
      A1(3)=A1(2)
      A1(2)=2.*SQRT(STORE(L22PD+3))
      A1(1)=0.5*(A1(2)-A1(3))
      A1(2)=A1(2)-A1(1)-B
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(1),STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=2,3)
      ENDIF
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C )) THEN
c         WRITE(NCAWU,3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
c     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C )) THEN
         WRITE(CMON, 3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
c     print *,
c     print *, 'Cycle 0: ',ISTORE(JA)
      CYCLER = ISTORE(JA)           ! Cycle 1
c     print *, 'Cycle 1: ',ISTORE(CYCLER)
      CYCLER = ISTORE(CYCLER)       ! Cycle 2
c     print *, 'Cycle 2: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 3
C     print *, 'Cycle 3: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 4
C     print *, 'Cycle 4: ',ISTORE(CYCLER)
      JA=ISTORE(CYCLER)             ! Final Cycle
c     print *, 'Cycle 5: ',ISTORE(JA)
c     print *, 'JA: ',JA
c      print *,
      JA = -1000000
      GOTO 3550
C         
C--UYZQIV RESTRAINTS PRINT
3268  CONTINUE
      A1(3)=A1(2)
      A1(2)=2.*SQRT(STORE(L22PD+3))
      A1(1)=0.5*(A1(2)-A1(3))
      A1(2)=A1(2)-A1(1)-B
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(1),STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=2,3)
      ENDIF
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C )) THEN
c         WRITE(NCAWU,3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
c     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C )) THEN
         WRITE(CMON, 3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
c     print *,
c     print *, 'Cycle 0: ',ISTORE(JA)
      CYCLER = ISTORE(JA)           ! Cycle 1
c     print *, 'Cycle 1: ',ISTORE(CYCLER)
      CYCLER = ISTORE(CYCLER)       ! Cycle 2
c     print *, 'Cycle 2: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 3
C     print *, 'Cycle 3: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 4
C     print *, 'Cycle 4: ',ISTORE(CYCLER)
      JA=ISTORE(CYCLER)             ! Final Cycle
c     print *, 'Cycle 5: ',ISTORE(JA)
c      print *, 'JA: ',JA
c      print *,
      JA = -1000000
      GOTO 3550
C         
C--UZZQIV RESTRAINTS PRINT
3269  CONTINUE
      A1(3)=A1(2)
      A1(2)=2.*SQRT(STORE(L22PD+3))
      A1(1)=0.5*(A1(2)-A1(3))
      A1(2)=A1(2)-A1(1)-B
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(1),STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),(A1(M),M=2,3)
      ENDIF
      IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C )) THEN
c         WRITE(NCAWU,3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
c     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C )) THEN
         WRITE(CMON, 3251)KF,STORE(JA+2),ISTORE(JA+3),A1(1),
     2   STORE(JB+2),ISTORE(JB+3),A1(2),A1(3)
         CALL XPRVDU(NCVDU, 1,0)
         ENDIF
      ENDIF
C--CALCULATE THE MEAN
      A1(1)=0.5*(A1(1)+A1(2)+B)
      A1(2)=A1(3)
c     print *,
c     print *, 'Cycle 0: ',ISTORE(JA)
      CYCLER = ISTORE(JA)           ! Cycle 1
c     print *, 'Cycle 1: ',ISTORE(CYCLER)
      CYCLER = ISTORE(CYCLER)       ! Cycle 2
c     print *, 'Cycle 2: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 3
C     print *, 'Cycle 3: ',ISTORE(CYCLER)
C      CYCLER = ISTORE(CYCLER)       ! Cycle 4
C     print *, 'Cycle 4: ',ISTORE(CYCLER)
      JA=ISTORE(CYCLER)             ! Final Cycle
c     print *, 'Cycle 5: ',ISTORE(JA)
c     print *, 'JA: ',JA      
c     print *,
      JA = -1000000
      GOTO 3550
            
C         
C
C--U(IJ) RESTRAINT
3300  CONTINUE
      JS=ISTORE(JA+16)
      JT=ISTORE(JB+16)
C--CHECK THAT BOTH ATOMS ARE ANISO
CDJWAPR99 - REMEBER THAT JS+6 IS JUST A FLAG NOW, AND RESULT SHOULD BE
C           BE ZERO
C      IF(ABS(STORE(JS+6))+ABS(STORE(JT+6))-2.*UISO)3350,3500,3500
cdjwjun09 - print out names of iso atoms
      IF(ABS(STORE(JS+6))+ABS(STORE(JT+6)).lt.UISO) then
3350   CONTINUE
c       write(123,'(10f8.5)') (store(idjw),idjw=js+14,js+24,2)
c       write(123,'(10f8.5)') (store(idjw),idjw=jt+14,jt+24,2)
       jdjw = 14
       DO 3450 JJ=8,13
       adjw = store(js+jdjw)
       bdjw = store(jt+jdjw)
C--CHECK IF THIS RESTRAINT IS USEFUL
      CALL XMOVE(IB1(1),KF1(1),1)
      IF(ISTORE(L22PD).eq.4) THEN
         WRITE(CMON,'(A,2x,A,A,A)')'{I ', 
     1   COPERATION(I)(1:NCTRIM(COPERATION(I))),
     1 ' restraint:', ' No derivatives found'
         CALL XPRVDU(NCVDU,1,0)
         IF(ISSPRT.EQ.0)
     1 WRITE(NCWU,'(2x,A,A,A)')COPERATION(I)(1:nctrim(COPERATION(I))),
     1 ' restraint: ', ' No derivatives found'
         CALL XMOVE(IQ1(1),KF1(1),1)
      ENDIF

       A1(3)=STORE(L22PD+2)
       A1(2)=2.*SQRT(STORE(L22PD+3))
       A1(1)=0.5*(A1(2)-A1(3))
       A1(2)=A1(2)-A1(1)-B
c       write(123,'(i6,2f8.5,2x,2f8.5,5x,3f8.5))') 
c     1 jdjw,adjw,bdjw,store(l22pd+2),store(l22pd+3),a1(1),a1(2),a1(3)
c
c Extracting Uij as a1(1) and a1(2) from Store(l22pd+ ) does not 
c recover the original values because L22pd+3 is a squared value, so the
c sign is lost.
c It might be better to use original values at JS and JT.
c
       IF (ISSPRT .EQ. 0) THEN
       WRITE(NCWU,3250)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 adjw,STORE(JB+2),ISTORE(JB+3),(ISTORE(M),M=JF,JG),bdjw,A1(3)
     3 ,(ICOORD(idjw,JJ),idjw=1,NWKA)
       ENDIF
c       IF ( (IMON .GT. 0 ) .OR. (ABS(A1(3)) .GE. C ))  THEN
c         IF ((IMON .GE. 1) .AND. (ABS(A1(3)) .GE. C ))THEN
         WRITE(CMON,3251) KF, STORE(JA+2), ISTORE(JA+3), adjw,
     2   STORE(JB+2),ISTORE(JB+3),bdjw,A1(3),
     3   (ICOORD(idjw,JJ),idjw=1,NWKA)
         CALL XPRVDU(NCVDU, 1,0)
c         ENDIF
c       ENDIF
C--ACCUMUALTE THE MEANS ETC.
       O=O+A1(3)
       P=P+A1(3)*A1(3)
       Q=Q+0.5*(A1(1)+A1(2)+B)
C--CHECK IF THIS IS THE LAST U(IJ) FOR THIS ATOM
       IF(JJ-13)3400,3450,3400
3400   CONTINUE
       CALL XDOWNF(M22PD,STORE(L22PD),4)
       M22PD=M22PD+KINCRF(ISTORE(L22PD))
       NCA=NCA+1
       jdjw = jdjw + 2
3450   CONTINUE
      else
       if(issprt.eq.0) WRITE(ncwu,'(2x,A1,2(8X,A4,I5,31x),A)')
     2 KF,STORE(JA+2),ISTORE(JA+3), STORE(JB+2),ISTORE(JB+3),
     3 'Isotropic'
       write(cmon,'(1x,a1,2x,2(2x,a4,i4,10x),a)')
     2 KF,STORE(JA+2),ISTORE(JA+3), STORE(JB+2),ISTORE(JB+3),
     3 'Isotropic'
       call xprvdu(ncvdu, 1,0)
      endif
C--CHANGE ATOMS
3500  CONTINUE
      JA=ISTORE(JB)
      IF(JA)3600,3600,2550
C
C--ACCUMULATE THE MEANS ETC.
3550  CONTINUE
      O=O+A1(2)
      P=P+A1(2)*A1(2)
      Q=Q+A1(1)
      IF(JA)3600,3600,2550
C
C--END OF PRINTING FOR THIS RESTRAINT
3600  CONTINUE

      ! leverages
      call showleverage(ircpt, -1)

      R=1./FLOAT(NCA)
      Q=Q*R
C--CHECK IF WE SHOULD PRINT THE MEAN DELTA AND R.M.S. DEVIATION
      IF(N-1)3750,3750,3650
3650  CONTINUE
      O=O*R
      P=SQRT(P*R)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,3700)Q,O,P
      WRITE(CMON,3700) Q, O ,P
      CALL XPRVDU(NCVDU, 1,0)
3700  FORMAT('      Mean value =',F9.4,'  Mean delta =',F9.4,
     2 '  r.m.s. delta =',F9.4)

      GOTO 1050
3750  CONTINUE

      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3700)Q
      ENDIF

      GOTO 1050
C
C--TERMINATION AND APPLICATION OF THE STORED DERIVATIVES
3800  CONTINUE
      IF(L26WRN.GT.0) THEN
            WRITE(CMON,'(A,6x,a/A,I6,A,A/6x,A )') 
     1      '{I ',' Restraint Checking',
     1      '{I ', L26WRN, ' Restraint warnings:',
     2      ' For on-screen information',
     3      '{I  Issue #PRINT 16 and #CHECK HI '
            CALL XPRVDU(NCVDU,3,0) 
      ENDIF
      CALL XOPMSG (IOPCHK, IOPEND, IVERSN)
      CALL XTIME2(2)
      RETURN
C
C--ERRORS
3900  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU,3950)A
3950  FORMAT(/1H ,F4.0,20H   Restraint ignored)
      GOTO 1050
C
C--'PLANAR' reSTRAINT
4000  CONTINUE
      NN=0
      N=2
C--COMPUTE THE PLANE AND DERIVATIVES
      IDWZAP = 0
      IF(KPLANE(IDWZAP))3900,4050,4050
C--PRINT THE HEADER
4050  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU,4100)A,B,(STROM(M),M=1,2),C
4101  FORMAT(/1H ,F4.0,'  Restrain these atoms to be ',F8.3,
     2 2X,' A',' from their mean plane',/' with an E.S.D. of ',F8.3)
4100  FORMAT(/1H ,F4.0,37H   Restrain the following atoms to be,F8.3,
     2 2X,2A4,41H from their mean plane, with an E.S.D. of,F8.3//12X,
     3 4HAtom,7X,15HS(I) L TX TY TZ,5X,5HDelta)
      WRITE(CMON,2460)NINT(A+1), '           Planarity', B,C
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 2500
C
C--PRINT THE INFORMATION FROM A PLANAR RESTRAINT
4150  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4200)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 A1(2)
      ENDIF
4200  FORMAT(2H  ,A1,8X,A4,I5,I6,4I3,F10.3)
      IF ((IMON .GE. 1) .AND. (ABS(A1(2)) .GE. C ) ) THEN
         WRITE(CMON ,4201)KF,STORE(JA+2),ISTORE(JA+3),A1(2)
         CALL XPRVDU(NCVDU, 1,0)
      ENDIF
4201  FORMAT(1X,A1,4X, A4,I4,F7.3)
C--MOVE ONTO THE NEXT ATOM
4250  CONTINUE
      JA=ISTORE(JA)
      GOTO 3550
C
C
C--'SUM' RESTRAINT
4300  CONTINUE
      CALL XSUMCN(1)
      AB=STORE(LCG+2)
      WRITE(CMON,2460)NINT(A+1), '                 Sum', AB,C
      CALL XPRVDU(NCVDU, 1,0)
4310  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU,4350)A,AB,C
4350  FORMAT(1X ,F4.0,' The sum is restrained to be ',
     2 G12.5,'  with an E.S.D. of ',G12.5)

      ! leverages
      call showleverage(ircpt,-1)

      GOTO 1050
C
C     'ORIGIN' FIXING
5000  CONTINUE
      CALL XSUMCN(2)
      AB=STORE(LCG+2)
      WRITE(CMON,"(I5,1X,A,'. Target ',1PE9.2, ' esd ', 1PE9.2)") 
     1  NINT(A+1), '              Origin', AB,C
      CALL XPRVDU(NCVDU, 1,0)

      GOTO 4310
C
4370  CONTINUE
C----- 'LIMIT' RESTRAINT
      N = 2
      NN = 0
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4380) A,C
      ENDIF
4380  FORMAT ( // , 1X , F4.0 , ' Limit the shifts of the given' ,
     2 ' parameters to 0.0, with an E.S.D. of ',E20.10)
4381  FORMAT(I5, 1X, A, '. ', 'Target ',F7.4, ' esd ', F8.4)
      WRITE(CMON,4381) NINT(A+1), '               Limit', 0.0, C
      CALL XPRVDU(NCVDU, 1,0)

      ! leverages
      call showleverage(ircpt, -1)

      GO TO 1050
C
C--'AVERAGE' RESTRAINT
4400  CONTINUE
      N=2
      NN=0
C--COMPUTE THE VALUES ETC.
      MM=1
      IF(KAVERG(MM))3900,4450,4450
C--PRINT OUT THE HEADER
4450  CONTINUE
      AB=STORE(LCG+2)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4500)A,AB,C
      ENDIF
4501  FORMAT(/1H ,F4.0,' Restrain these to their common',
     2 ' mean of ',F10.5,'  with an E.S.D. of', F10.5)
4500  FORMAT(/1H ,F4.0,39H   Restrain the following parameters to,
     2 21H their common mean of,F10.5,19H  with an E.S.D. of,
     3 F10.5//12X,4HAtom,7X,15HS(I) L TX TY TZ,5X,9HParameter,8X,
     4 5HValue,5X,5HDelta)
      WRITE(CMON,2460)NINT(A+1), '             Average', AB,C
      CALL XPRVDU(NCVDU, 1,0)
C--RESET THE OBSERVED VALUE
      B=STORE(LCG+4)
      GOTO 2500
C
4540  CONTINUE
C----- DO NOT PRINT THE LIMIT RESTRAINT
      MM = 1
      GOTO 1050
C
C--PRINT FOR THE 'AVERAGE' RESTRAINT
4550  CONTINUE
      MM = 2
C
      JB=ISTORE(JA+6)
      JC=ISTORE(JB+1)
C--CHECK ON THE TYPE OF THE CURRENT PARAMETER
      IF(ISTORE(JA+1)-1)4600,4700,4800
C--THIS IS AN ATOMIC PARAMETER
4600  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4650)KF,STORE(JA+2),ISTORE(JA+3),(ISTORE(M),M=JD,JE),
     2 (ICOORD(idjw,JC),idjw=1,2), (A1(M),M=1,MM)
      ENDIF
4650  FORMAT(2H  ,A1,8X,A4,I5,I6,4I3,6X,2A4,4X,2F10.5)
      IF ((IMON .GE. 1) .AND. (ABS(A1(2)) .GE. C) ) THEN
       WRITE(CMON,4651)KF,STORE(JA+2),ISTORE(JA+3),
     2 (ICOORD(idjw,JC),idjw=1,2), (A1(M),M=1,MM)
       CALL XPRVDU(NCVDU, 1,0)
      ENDIF
4651  FORMAT(1X,A1,4X,A4,I4,2X,2A4,2X,2F10.5)
      GOTO 4250
C--THIS IS A SIMPLE OVERALL PARAMETER
4700  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4750)KF,(KVP(M,JC),M=1,2), (A1(M),M=1,MM)
      ENDIF
4750  FORMAT(2H  ,A1,41X,2A4,4X,2F10.5)
      IF ((IMON .GE. 1) .AND. (ABS(A1(2)) .GE. C) ) THEN
       WRITE(CMON,4751)KF,(KVP(M,JC),M=1,2), (A1(M),M=1,MM)
       CALL XPRVDU(NCVDU, 1,0)
      ENDIF
4751  FORMAT(1X,A1,10X,2A4,2X,2F10.5)
      GOTO 4250
C--THIS IS AN ELEMENT OR LAYER SCALE FACTOR
4800  CONTINUE
      JB=ISTORE(JA+1)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4850) KF,(KSCAL(M,JB),M=1,2), (A1(M),M=1,MM)
      ENDIF
4850  FORMAT(2H  ,A1,38X,2A4,4X,3X,2F10.5)
      IF ((IMON .GE. 1) .AND. (ABS(A1(2)) .GE. C) ) THEN
       WRITE(CMON,4851) KF,(KSCAL(M,JB),M=1,2), (A1(M),M=1,MM)
       CALL XPRVDU(NCVDU, 1,0)
      ENDIF
4851  FORMAT(1X,A1,7X,2A4,4X,1X,2F10.5)
      GOTO 4250
C
9900  CONTINUE
C -- ERRORS
      CALL XOPMSG ( IOPCHK , IOPABN , 0 )
      GO TO 3800
9910  CONTINUE
C -- INPUT ERRORS
      CALL XOPMSG ( IOPCHK , IOPCMI , 0 )
      GO TO 9900
      END
C
CODE FOR XAPP16
      SUBROUTINE XAPP16(savederivativesarg)
      use lists1_mod, only: xrlind, klschk
      use list26_mod
C--APPLY THE RESTRAINTS
C
C  THIS SUBROUTINE READS DOWN THE LIST 26 AND CALCULATES THE
C  REQUIRED RESTRAINTS.
C  THIS SUBROUTINE IS RESPONSIBLE FOR FORMING THE PARTIAL
C  DERIVATIVE QUEUE ON THE DISC AND THEN ADDING IT TO LIST 11
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLSVAL.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST23.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'XL26WK.INC'
C
      INCLUDE 'QSTORE.INC'
      
      logical, optional, intent(in) :: savederivativesarg
      logical savederivatives
      integer ISTAT2OLD
      dimension ID(2) 
      integer restraints_block_size
C
      interface 
          subroutine XCVCV(results)
              use list26_mod
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
      interface 
          subroutine XCVUPLANE(iaxis, iasym, results)
              use list26_mod
              integer, intent(in) :: iaxis
              integer, intent(in) :: iasym
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
      interface 
          subroutine XCVCUALIGN(results)
              use list26_mod
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
      interface 
          subroutine XCVCURIGU(iasym, results)
              use list26_mod
              integer, intent(in) :: iasym
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
      interface 
          subroutine XCVCULIJ(results)
              use list26_mod
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
      interface 
          subroutine XCVCUEIG(results)
              use list26_mod
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
      interface 
          subroutine XCVCUQISO(results)
              use list26_mod
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
      interface 
          subroutine XCVCUVOL(results)
              use list26_mod
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
      interface 
          subroutine XCVCUEQIV(results)
              use list26_mod
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
      interface 
          subroutine XCVCTLS(results)
              use list26_mod
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
      interface 
          function KPLANE(in, results)
              use list26_mod
              integer in
              type(restraints_t), intent(inout), optional :: results
          end function
      end interface
      interface 
          subroutine XCDC(iasym, results)
              use list26_mod
              integer iasym
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
       interface 
          subroutine XCDEF(results)
              use list26_mod
              type(restraints_t), intent(inout), optional :: results
          end subroutine
      end interface
     
      integer, dimension(8) :: IBUFF
      real, dimension(:), allocatable :: card
      character(len=:), allocatable :: cline
      character(len=24) :: fline
      character eol
      integer list16_index
      
      savederivatives=.true.
      if(present(savederivativesarg)) then
        savederivatives=savederivativesarg
      end if
C
      DATA IVERSN /403/
      restraints_block_size=128
C
      if(savederivatives) then
C--INITIATE THE TIMING
        CALL XTIME1(2)
C--READ THE REMAINING CONTROL CARDS
        I=KRDDPV(ISTORE(NFL),1)
        IF ( I .LT. 0 ) GO TO 9910
      end if
C--CLEAR THE CORE AREA
      CALL XRSL
      CALL XCSAE
C----- FETCH LIST 23 TO SEE IF RESTRAINTS ARE NEEDED
      CALL XFAL23
      IF(ISTORE(L23MN+2) .LT. 0) GOTO 1770
C----- LOAD LIST 3 IF IT EXISTS
      KLST3 = -1
        IF (KEXIST(3) .GT. 0) CALL XFAL03
C--LOAD LIST 5
      CALL XFAL05
C--SET UP THE SYSTEM VARIABLES IN CORE
      CALL XLSV
C--LOAD LIST 12
      CALL XFAL12(-1,1,JR,JN)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--LINK LIST 5 AND LIST 12
      I=KSET52(0,-1)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C
C---- SET TYPE AND INITIALISE THE NO DERIVATIVES FOUND COUNTER
      L26TYP = 1       !APPLY
      L26WRN = 0
C
C--SET UP THE POINTERS FOR THE DERIVATIVE QUEUE ON DISC
      CALL XIPDQF
C--LOAD THE COMPILED LIST FOR PROCESSING
      IULN=26
      CALL XLCLFP(IULN)
      IF ( IERFLG .LT. 0 ) GO TO 9900

      ! loading list 16
      ISTAT = KLSCHK ( 16 , 0 , 0 , ILSAVI , ILSMSG , IADDR , IERERR )
      IF ( ISTAT .LE. 0 ) GO TO 9900
      CALL XRLIND ( 16 , LSN , NEXT , LL , IOW , NOS , ID ) ! next is now the start address of the chain list

      last=0 ! start of the chain     
      if(allocated(restraints_list)) deallocate(restraints_list)
      if(allocated(subrestraints_parent)) then
        deallocate(subrestraints_parent)
      end if
      current_restraintindex=0
      idjwtemp=0
      list16_index=-1 ! user restraints counter
      
C--BRING DOWN THE NEXT BLOCK OF CODE AND RELOCATE IT
1000  CONTINUE
      ISTAT2OLD=ISTAT2
      if(.not. savederivatives) then
        ISTAT2=0
      end if
      IF(KLOADR(LN))1850,1050,1750
C--JUMP ON THE FUNCTION
1050  CONTINUE
      idjwtemp=idjwtemp+1 ! generated restraint counter. Some user restraints generates several restraints
      current_restraintindex=idjwtemp ! same counter but in list26_mod
      
      ! check storage space for the next restraint  
      if(.not. allocated(restraints_list)) then
        call extend(restraints_list,restraints_block_size)      
      else if(idjwtemp>size(restraints_list)) then
        restraints_block_size=restraints_block_size*2
        call extend(restraints_list, restraints_block_size)
#if defined(CRY_OSLINUX)
        print *, 'new size of restraints_list: ', 
     1      sizeof(restraints_list)/1024.0, 'kB'
#endif        
      end if        

      ! looking for the corresponding user restraint in list16,list17
      restraints_list(idjwtemp)%user_index=ISTORE(LCG+5)
      icpt=0 ! counter used to avoid infinite loop
      do while(list16_index<ISTORE(LCG+5))
        icpt=icpt+1

        i=KLDDRH(LAST,NEXT,IBUFF) ! getting metadata in ibuff and pointing to next record
        if(i<0) then
          ! end of list 16, switching to list 17
          ISTAT = KLSCHK ( 17, 0, 0, ILSAVI, ILSMSG , IADDR , IERERR )
          IF ( ISTAT .LE. 0 ) GO TO 9900
          CALL XRLIND ( 17 , LSN , NEXT , LL , IOW , NOS , ID ) ! next is now the start address of the chain list
          last=0 ! start of the chain      
          i=KLDDRH(LAST,NEXT,IBUFF)
          if(i<0) call abort() ! this is not normal
        end if              

        restraints_list(idjwtemp)%restraint_text=''
        list16_index=list16_index+1
        if(icpt>1000) call abort() ! "infinite" loop
        do ! Now loading the restraint
          IF(IBUFF(7)>0) then
            exit !end of restraint
          end if
          L=IBUFF(4)
          if(allocated(card)) deallocate(card)
          allocate(card(ibuff(5)))
          if(allocated(cline)) deallocate(cline)
          allocate(character(len=ibuff(5)*4) :: cline)
          write(fline, "(A, I0, A)") "(",ibuff(5),"A4)"
          eol=char(10)
          do i=1, IBUFF(6)
            if(i==IBUFF(6)) eol=''
            CALL XDOWNF(L,CARD(1),IBUFF(5)) ! loading data from disc to card
            WRITE(CLINE,fline)  CARD ! transfering fata to text
            restraints_list(idjwtemp)%restraint_text=
     &      trim(restraints_list(idjwtemp)%restraint_text)//
     &      trim(cline)//eol
            L=L+KINCRF(IBUFF(5)) ! calculating next address 
          end do 
       
          ! loading next line
          i=KLDDRH(LAST,NEXT,IBUFF)
        end do
        
        ! Warning the user that a restraint was found but ignored        
        if(list16_index<ISTORE(LCG+5)) then
          associate(r => restraints_list(idjwtemp))
            if(index(r%restraint_text,'REM')==0 .and.
     1         index(r%restraint_text,'COMP')==0 .and.
     1         index(r%restraint_text,'EXEC')==0
     1         ) then
     
              icptn=index(r%restraint_text, char(10)) ! Checking for end of line in restraints
              if(icptn>0) then
                ! Printing one line at a time
                WRITE(CMON,'("{E",1X, "(",I0,")",1X, A)') list16_index,
     1            r%restraint_text(1:icptn-1)
                CALL XPRVDU(NCVDU, 1,0)      
            
                icptn=icptn+1
                do ii=icptn, len_trim(r%restraint_text)
                  if(r%restraint_text(ii:ii)==char(10)) then
                    WRITE(CMON,'("{E",1X, 6X,1X, A)') 
     1                trim(r%restraint_text(icptn:ii-1))          
                    CALL XPRVDU(NCVDU, 1,0)      
                    icptn=ii+1
                   end if
                end do
                WRITE(CMON,'("{E",1X, 6X,1X, A)') 
     1            trim(r%restraint_text(icptn:))          
                CALL XPRVDU(NCVDU, 1,0)      
              else
                WRITE(CMON,'("{E",1X, "(",I0,")",1X, A)') list16_index,
     1            trim(r%restraint_text)
                CALL XPRVDU(NCVDU, 1,0)      
              end if

              WRITE(CMON,'("{E", 4X, A)') 'Restraint in error'
              CALL XPRVDU(NCVDU, 1,0)      

            end if
          end associate            
        end if         
      end do ! found the user restraint

      I=ISTORE(LCG+1)
cdjwsep2011
      if(i .lt. 1) then
       iasym = 1
       i = abs(i)
      else
       iasym = 0
      endif
      GOTO(1150,1200,1250,1300,1350,1400,1450,1500,1550,1600, !1
     1     1650,1700,1950,2000,2050,2100,2150,2200,2250,2055, !11
     1     1560,1570,1580,1565,1575,1590,1591,1592,1593,1594, !21
     1     1595,1596,1597,1598,1599,1601,1602,1603,1604,1605,1100) ,I   !31
1100  CONTINUE
      CALL XOPMSG (IOPL16, IOPINT, 0)
      GOTO 9900
C
C--'DEFINE' FUNCTION
1150  CONTINUE
      CALL XCDEF(restraints_list(idjwtemp))
      GOTO 1000
C
C--'RESTRAIN' FUNCTION
1200  CONTINUE
      CALL XCC
      GOTO 1000
C
C--'SINGLE DISTANCE' RESTRAINTS
1250  CONTINUE
      CALL XCDC(iasym, restraints_list(idjwtemp))
      GOTO 1000
C
C--'DISTANCE DIFFERENCE' RESTRAINTS
1300  CONTINUE
      CALL XCDDC(iasym)
      GOTO 1000
C
C--'MEAN DISTANCE' RESTRAINT
1350  CONTINUE
      CALL XCMDC(iasym)
      GOTO 1000
C
C--'SINGLE ANGLE' RESTRAINTS
1400  CONTINUE
      CALL XCAC
      GOTO 1000
C
C--'ANGLE DIFFERENCE' RESTRAINTS
1450  CONTINUE
      CALL XCADC
      GOTO 1000
C
C--'MEAN ANGLE' RESTRAINT
1500  CONTINUE
      CALL XCMAC
      GOTO 1000
C
C--'VIBRATION' RESTRAINT
1550  CONTINUE
      CALL XCVC(iasym)
      GOTO 1000
C
C--'UXZBAR' RESTRAINT
1560  CONTINUE
      CALL XCVCX(1,iasym)
      GOTO 1000
C
C--'UYZBAR' RESTRAINT
1570  CONTINUE
      CALL XCVCX(2,iasym)
      GOTO 1000
C--'UZZBAR' RESTRAINT
1580  CONTINUE
      CALL XCVCX(3,iasym)
      GOTO 1000
C
C--'UPERP' RESTRAINT
1565  CONTINUE
      CALL XCVCV(restraints_list(idjwtemp))
      GOTO 1000
C
C--'unused' RESTRAINT
1575  CONTINUE
      GOTO 1000  
C
C--'UALIGN' RESTRAINT
1590  CONTINUE
      CALL XCVCUALIGN(restraints_list(idjwtemp))
      GOTO 1000  
C
C--'URIGU' RESTRAINT
1591  CONTINUE
      CALL XCVCURIGU(iasym, restraints_list(idjwtemp))
      GOTO 1000  

C--'ULIJ' RESTRAINT
1592  CONTINUE
      CALL XCVCULIJ(restraints_list(idjwtemp))
      GOTO 1000  

C--'UPLANE' RESTRAINT
1593  CONTINUE
      CALL XCVUPLANE(0,iasym, restraints_list(idjwtemp))
      GOTO 1000  
C     
C--'UXXQIV' RESTRAINT
1594  CONTINUE
      CALL XCVCY(1,iasym)
      GOTO 1000 
C     
C--'UXYQIV' RESTRAINT
1595  CONTINUE
      CALL XCVCY(2,iasym)
      GOTO 1000 
C     
C--'UXZQIV' RESTRAINT
1596  CONTINUE
      CALL XCVCY(3,iasym)
      GOTO 1000 
C     
C--'UYYQIV' RESTRAINT
1597  CONTINUE
      CALL XCVCY(4,iasym)
      GOTO 1000 
C     
C--'UYZQIV' RESTRAINT
1598  CONTINUE
      CALL XCVCY(5,iasym)
      GOTO 1000 
C     
C--'UZZQIV' RESTRAINT
1599  CONTINUE
      CALL XCVCY(6,iasym)
      GOTO 1000 
C     
C--'UEIG' RESTRAINT
1601  CONTINUE
      CALL XCVCUEIG(restraints_list(idjwtemp))
      GOTO 1000  

C--'UQISO' RESTRAINT
1602  CONTINUE
      CALL XCVCUQISO(restraints_list(idjwtemp))
      GOTO 1000  

C--'UVOL' RESTRAINT
1603  CONTINUE
      CALL XCVCUVOL(restraints_list(idjwtemp))
      GOTO 1000  

C--'UEQIV' RESTRAINT
1604  CONTINUE
      CALL XCVCUEQIV(restraints_list(idjwtemp))
      GOTO 1000  

C--'UTLS' RESTRAINT
1605  CONTINUE
      CALL XCVCTLS(restraints_list(idjwtemp))
      GOTO 1000  

C--'EXECUTION LISTING'
1600  CONTINUE
      if(.not. savederivatives) then
        ISTAT2=1
      end if
      GOTO 1000
C
C--'NO LISTING'
1650  CONTINUE
      ISTAT2=0
      GOTO 1000
C
C-'U(IJ)' RESTRAINT
1700  CONTINUE
      CALL XDUIJ(iasym)
      GOTO 1000
C
C--TERMINATION AND APPLICATION OF THE STORED DERIVATIVES
1750  CONTINUE
      ISTAT2=ISTAT2OLD
      CALL XTPDQF
      if(savederivatives) then
        CALL XADCPD
      end if
      IF ( IERFLG .LT. 0 ) GO TO 9900
1770  CONTINUE
      IF(L26WRN.GT.0) THEN
            WRITE(CMON,'(A,6x,a/A,I6,A,A/6x,A )') 
     1      '{I ',' Restraint Application',
     1      '{I ', L26WRN, ' Restraint warnings:',
     2      ' For on-screen information',
     3      '{I  Issue #PRINT 16 and #CHECK HI '
            CALL XPRVDU(NCVDU,3,0) 
      ENDIF
      CALL XOPMSG (IOPCPR, IOPEND, IVERSN)
      CALL XTIME2(2)
      RETURN
C
C--ERRORS
1850  CONTINUE
      J=16
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1900)IULN
1900  FORMAT(
     1' List ',I5,' contains errors.',
     2  ' Check the Restraints lists 16 and 17')
      WRITE ( CMON ,1900)IULN
      CALL XPRVDU(NCVDU, 1,0)
      CALL XERHND ( IERERR )
      GO TO 9900
C
C--'EQUATE' RESTRAINT
1950  CONTINUE
      IF(KEQUAT(I))1850,1000,1000
C
C--'PLANAR' RESTRAINT
2000  CONTINUE
      IDWZAP = 0
      IF(KPLANE(IDWZAP, restraints_list(idjwtemp)))1850,1000,1000
C
C--'SUM' RESTRAINT
2050  CONTINUE
      CALL XSUMCN(1)
      GOTO 1000
C
C--'ORIGIN' RESTRAINT
2055  CONTINUE
      CALL XSUMCN(2)
      GOTO 1000
C
C
C--'FORM' RESTRAINT
2100  CONTINUE
      IF(KFORM(I))1850,1000,1000
C
C--'AVERAGE' RESTRAINT
2150  CONTINUE
      I = 1
      IF(KAVERG(I))1850,1000,1000
C
C----- 'LIMIT' RESTRAINT
2200  CONTINUE
      I = -1
      IF (KAVERG(I))1850,1000,1000
C
C----- ENERGY RESTRAINT
2250  CONTINUE
      CALL XCEC(iasym)
      GOTO 1000
C
9900  CONTINUE
C -- ERRORS
      CALL XOPMSG ( IOPCPR , IOPABN , 0 )
      GO TO 1770
9910  CONTINUE
C -- INPUT ERRORS
      CALL XOPMSG ( IOPCPR , IOPCMI , 0 )
      GO TO 9900
      END
C
CODE FOR XCC
      SUBROUTINE XCC
C--CALCULATE RESTRAINTS FROM THE GIVEN CODE
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XAPK.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET UP A FEW INITIAL CONSTANTS
      MCA=LCA
      STORE(L22PD+2)=STORE(LCG+4)-XVALUE(LC)
C
C--MAIN LOOP FOR PASSING THROUGH THE COORDS. OF EACH ATOM
1000  CONTINUE
      I=ISTORE(MCA+6)
      K=0
C--CHECK IF THIS IS AN ATOM OR AN OVERALL PARAMETER
      IF(ISTORE(MCA+1))1100,1050,1100
C--THIS IS AN ATOM  -  ALTER THE PARAMETER STEP
1050  CONTINUE
      K=NKA+NKA-2
C--CHECK IF ANY PARAMETERS HAVE BEEN GIVEN
1100  CONTINUE
      IF(I)1650,1650,1150
C--CLEAR THE DERIVATIVE SLOTS FOR THIS ATOM OR PARAMETER
1150  CONTINUE
      L=ISTORE(MCA+16)
      M=L+K
      DO 1200 J=L,M,2
      STORE(J+1)=0.0
1200  CONTINUE
C--CHECK IF THIS IS AN ATOM OR AN OVERALL PARAMETER
      IF(K)1250,1250,1300
C--THIS IS AN OVERALL PARAMETER
1250  CONTINUE
      STORE(L+1)=1.
      GOTO 1600
C--THIS IS AN ATOM  -  CHECK THE PARAMETER TYPE
1300  CONTINUE
      IF(ISTORE(I+1)-5)1350,1450,1400
C--'U[ISO]' OR 'OCC'
1350  CONTINUE
      L=L+ISTORE(I+1)+ISTORE(I+1)
      STORE(L-1)=1.0
      GOTO 1600
C--CHECK FOR AN ANISO TEMPERATURE FACTOR
1400  CONTINUE
      IF(ISTORE(I+1)-7)1450,1450,1500
C--POSITIONAL COORD.
1450  CONTINUE
      M=ISTORE(MCA+4)+ISTORE(I+1)
C--GENERATE DERIVS. FOR SHIFTED ATOM
      STORE(L+9)=STORE(MCA+14)*STORE(M-5)
      STORE(L+11)=STORE(MCA+14)*STORE(M-2)
      STORE(L+13)=STORE(MCA+14)*STORE(M+1)
      GOTO 1600
C--ANISO TEMPERATURE TERMS
1500  CONTINUE
      M=L+15
      N=NFL+18
C--FIND THE ADDRESS OF THE RELEVANT PARAMETER
      L=N+ISTORE(I+1)
C--ZERO THE DERIVATIVE AREA
      CALL XZEROF(STORE(N),6)
      STORE(L-8)=1.0
C--COMPUTE THE DERIVATIVES, ALLOWING FOR SYMMETRY
      CALL XEXANI(N,NFL)
      N=ISTORE(MCA+4)
      CALL XMLTTM(STORE(NFL),STORE(N),STORE(NFL+9),3,3,3)
      CALL XMLTTM(STORE(N),STORE(NFL+9),STORE(NFL),3,3,3)
C--STORE THE SYMMETRY GENERATED DERIVATIVES
      STORE(M)=STORE(NFL)
      STORE(M+2)=STORE(NFL+4)
      STORE(M+4)=STORE(NFL+8)
      STORE(M+6)=STORE(NFL+5)
      STORE(M+8)=STORE(NFL+2)
      STORE(M+10)=STORE(NFL+1)
C--CALCULATE THE PARTIAL DERIVATIVE
1600  CONTINUE
      STORE(I+2)=XDERIV(LC)
      I=ISTORE(I)
      GOTO 1100
1650  CONTINUE
      L=ISTORE(MCA+16)
      M=L+K
      DO 1700 J=L,M,2
      STORE(J+1)=0.0
1700  CONTINUE
      MCA=ISTORE(MCA)
      IF(MCA)1750,1750,1000
1750  CONTINUE
      MCA=LCA
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
      RETURN
      END
C
CODE FOR XDUIJ
      SUBROUTINE XDUIJ(iasym)
C--CALCULATE RESTRAINTS ON THE INDIVIDUAL U(IJ)'S
C
c
C      IASYM = 1 FOR ASYMMETRIC OTHERWISE 0
c
CDJWAPR99
C      The Uij entries for both atoms seem to get swapped, though
c      the sign also seems to get inverted. 'Effect' is in the 1984
c      VAX version.
      INCLUDE 'ISTORE.INC'
C
      DIMENSION A1(6)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (A1(1),O)
C
C--SET UP A FEW CONSTANTS
      DUMP=STORE(LCG+4)
      JA=LCA
      NCA=2
C--SET UP THE ADDRESSES OF THE ATOMS
1000  CONTINUE
      JB=ISTORE(JA)
      JC=JA
      DO 1100 I=1,2
      JD=ISTORE(JC+16)
C--CHECK IF THE ATOM IS ANISO
CDJWAPR99 REMEMBER JD+6 IS JUST A FLAG NOW
c     0=aniso, 1 = iso, 2-4 = shape
c      x to u[12] OK 2012
c      write(123,'(10f8.5)') (store(idjw),idjw=jd+8,jd+24,2)
      IF(ABS(STORE(JD+6))-UISO)1050,1400,1400
C--PASS ONTO THE SECOND OF THE PAIR
1050  CONTINUE
      JC=JB
1100  CONTINUE
      JP=ISTORE(JA+6)
      JV=ISTORE(JB+6)
      JC=ISTORE(JA+16)+14
      JD=ISTORE(JB+16)+14
C--ZERO THE DERIVATIVE AREA
      CALL XZEROF(A1(1),6)
C--CALCULATE THE DERIVATIVES FOR THE U(IJ)
      DO 1350 JY=1,6
c      write(123,'(2(i12,f8.5))') jc,store(jc),jd,store(jd)
      JX=JP
      I=1
      JO=JA
      A=1.
C--STORE THE DERIVATIVES
1150  CONTINUE
      if ((i .eq. 1).AND.(iasym .eq.1)) then
c           dont restrain first atom
            a1(jy) = 0.
      else
            a1(jy)=a
      endif
      CALL XADUIJ
      A1(JY)=0.
C--CHECK IF THIS THE FIRST OR SECOND ATOM
      IF(I)1250,1250,1200
1200  CONTINUE
      JO=JB
      JX=JV
      A=-1.
      I=I-1
      GOTO 1150
C--CALCULATE THE MEAN VALUE AND THE DIFFERENCE
1250  CONTINUE
c      write(123,'(a,3f12.6)') 'U-values', dump, store(jc),store(jd)
cdjwmar2012 - should DUMP be outside the brackets?
c     for the asymmetric restraint, should we NOT compute the mean?
      STORE(LCG+4)=0.5*(DUMP+STORE(JC)+STORE(JD))
      STORE(L22PD+2)=DUMP-STORE(JC)+STORE(JD)
      MCA=JA
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
C--CLEAR THE P.D. SLOSTS FOR THE NEXT COORD.
      JQ=JP
      JW=JV
      DO 1300 JX=1,6
      STORE(JQ+2)=0.
      STORE(JW+2)=0.
      JQ=ISTORE(JQ)
      JW=ISTORE(JW)
1300  CONTINUE
c      write(123,'(2(i12,f8.5))') jc,store(jc),jd,store(jd)
      JC=JC+2
      JD=JD+2
1350  CONTINUE
C--PASS ONTO THE NEXT PAIR OF ATOMS
1400  CONTINUE
      JA=ISTORE(JB)
      IF(JA)1450,1450,1000
1450  CONTINUE
      RETURN
      END
C
CODE FOR XCVC
      SUBROUTINE XCVC(iasym)
C--CALCULATE VIBRATION RESTRAINTS
C
C
C      IASYM = 1 FOR ASYMMETRIC OTHERWISE 0
C
C--THE VARIABLES IN 'XWORK' ARE USED AS FOLLOWS :
C
C  P  DU(B)/DU(22)
C  .
C  .
C  T  DU(B)/DU(12)
C
C--SUBSEQUENTLY O TO T ARE USED FOR THE DIFFERENCES BETWEEN THE
C  THE TWO VALUES OF EACH VIBRATION PARAMETER
C
C--
      INCLUDE 'ISTORE.INC'
C
      DIMENSION A1(12)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (O,A1(1))
C
C--SET UP A FEW CONSTANTS                                               CVC00320
      DUMP=STORE(LCG+4)                                                 CVC00330
      JA=LCA                                                            CVC00340
      NCA=2                                                             CVC00350
C--SET UP THE ADDRESSES OF THE ATOMS                                    CVC00360
1000  CONTINUE                                                          CVC00370
      JB=ISTORE(JA)                                                     CVC00380
      JP=ISTORE(JA+6)                                                   CVC00390
      JV=ISTORE(JB+6)                                                   CVC00400
C--SET UP THE ADDRESSES OF THE U(IJ)'S                                  CVC00410
      DO 1050 I=1,3                                                     CVC00420
      JP=ISTORE(JP)                                                     CVC00430
      JV=ISTORE(JV)                                                     CVC00440
1050  CONTINUE                                                          CVC00450
C--CHECK THAT BOTH ATOMS ARE ANISO AND IF NOT MODIFY ACCORDINGLY        CVC00460
      JX=JP                                                             CVC00470
      JC=JA                                                             CVC00480
      DO 1250 I=1,2                                                     CVC00490
      JD=ISTORE(JC+16)                                                  CVC00500
C--CHECK IF THE ATOM IS ANISO                                           CVC00510
c      IF(ABS(STORE(JD+6))-UISO)1200,1100,1100                           CVC0052
      IF(ABS(STORE(JD+6)) .le. zero) goto 1200
C--'ISO' ATOM  -  MODIFY THE ENTRY IN THE COORDINATE SECTION            CVC00530
1100  CONTINUE                                                          CVC00540
cdjw99 The number of parameters
      ISTORE(JC+5)=4                                                    CVC00550
      ISTORE(JX)=-1000000                                               CVC00560
cdjw99 Where they start (iso is now same as U11)
c      ISTORE(JX+1)=4                                                    CVC0057
      ISTORE(JX+1)=8
C--SET THE ANISO TEMPERATURE FACTORS FOR THE ATOM                       CVC00580
      JE=JD                                                             CVC00590
      JF=L1C+2                                                          CVC00600
      DO 1150 J=L1C,JF                                                  CVC00610
cdjw99 Uiso now in same place as U11
c      STORE(JE+14)=STORE(JD+6)                                          CVC0062
      STORE(JE+14)=STORE(JD+14)
      STORE(JE+20)=STORE(JD+14)*STORE(J)                                 CVC0063
      JE=JE+2                                                           CVC00640
1150  CONTINUE                                                          CVC00650
      STORE(JD+6)=0.                                                    CVC00660
C--PASS ONTO THE SECOND OF THE PAIR                                     CVC00670
1200  CONTINUE                                                          CVC00680
      JX=JV                                                             CVC00690
      JC=JB                                                             CVC00700
1250  CONTINUE                                                          CVC00710
C--CALCULATE THE INTERNUCLEAR DISTANCE                                  CVC00720
      JO=JA                                                             CVC00730
      JS=JB                                                             CVC00740
      CALL XCD2PD                                                       CVC00750
      D=SQRT(0.5*(A*F+B*G+C*H))                                         CVC00760
C--APPLY THE RECIPROCAL CELL PARAMETERS                                 CVC00770
      F=F*STORE(L1P2)                                                   CVC00780
      G=G*STORE(L1P2+1)                                                 CVC00790
      H=H*STORE(L1P2+2)                                                 CVC00800
C--CALCULATE THE COMPONENTS APART FROM A SCALING BY 'D'                 CVC00810
      A1(7)=F*F                                                         CVC00820
      A1(8)=G*G                                                         CVC00830
      A1(9)=H*H                                                         CVC00840
      A1(10)=2.*G*H                                                     CVC00850
      A1(11)=2.*F*H                                                     CVC00860
      A1(12)=2.*F*G                                                     CVC00870
C--CALCULATE THE SCALING CONSTANT FOR THE COMPONENTS SQUARED            CVC00880
      E=1./(4.*D*D)                                                     CVC00890
C--CALCULATE THE DERIVATIVES FOR THE U(IJ)                              CVC00900
      DO 1300 I=1,6                                                     CVC00910
      A1(I)=A1(I+6)*E                                                   CVC00920
1300  CONTINUE                                                          CVC00930
      JO=JA                                                             CVC00940
      JX=JP                                                             CVC00950
      I=1                                                               CVC00960
C--STORE THE DERIVATIVES                                                CVC00970
1350  CONTINUE                                                          CVC00980
C--CHECK IF THIS ATOM IS ISO AND NOT ANISO                              CVC00990
      IF(ISTORE(JO+5)-4)1450,1400,1450                                  CVC01000
C--'ISO' ATOM                                                           CVC01010
1400  CONTINUE                                                          CVC01020
      STORE(JX+2)=STORE(JX+2)+A1(1)+A1(2)+A1(3)+A1(4)*STORE(L1C)+A1(5)
     2 *STORE(L1C+1)+A1(6)*STORE(L1C+2)
      IF(I)1600,1600,1500                                               CVC01050
C--'ANISO' ATOM                                                         CVC01060
1450  CONTINUE                                                          CVC01070
      if ((i .eq. 1).AND. (iasym .eq. 1)) then
c           dont restrain first atom
            do jy = 1,6
              a1(jy) = 0
            enddo
      endif
      CALL XADUIJ                                                       CVC01080
C--CHECK IF THIS THE FIRST OR SECOND ATOM                               CVC01090
      IF(I)1600,1600,1500                                               CVC01100
1500  CONTINUE                                                          CVC01110
      JO=JB                                                             CVC01120
      JX=JV                                                             CVC01130
      DO 1550 J=1,6                                                     CVC01140
c      A1(J)=-A1(J)                                                      CVC01150
      a1(j)=a1(j+6)*e *(-1.)                                                   CVC00920
1550  CONTINUE                                                          CVC01160
      I=I-1                                                             CVC01170
      GOTO 1350                                                         CVC01180
C--CALCULATE THE MEAN VALUE AND THE DIFFERENCE                          CVC01190
1600  CONTINUE                                                          CVC01200
      JC=ISTORE(JA+16)                                                  CVC01210
      JD=ISTORE(JB+16)                                                  CVC01220
      SUM=0.                                                            CVC01230
      D=0.                                                              CVC01240
      DO 1650 I=1,6 
c      write(123,'(a,3f12.6)') 'Mean',  store(jc+14),store(jd+14)
c      for the asymmetric restraint, should we NOT compute the mean?
      SUM=SUM+(STORE(JC+14)+STORE(JD+14))*A1(I+6)                       CVC01260
      A1(I)=STORE(JC+14)-STORE(JD+14)                                   CVC01270
      D=D+A1(I)*A1(I+6)                                                 CVC01280
      JC=JC+2                                                           CVC01290
      JD=JD+2                                                           CVC01300
1650  CONTINUE                                                          CVC01310
      STORE(LCG+4)=0.5*(DUMP+SUM*E)                                     CVC01320
      D=D*E                                                             CVC01330
      STORE(L22PD+2)=DUMP-D                                             CVC01340
C--CALCULATE THE DERIVATIVES FOR THE POSITIONAL COORDS.                 CVC01350
      ESAVE=4.*E                                                            CVC01360
      V=(F*O+G*T+H*S)*STORE(L1P2)                                       CVC01370
      W=(F*T+G*P+H*R)*STORE(L1P2+1)                                     CVC01380
      X=(F*S+G*R+H*Q)*STORE(L1P2+2)                                     CVC01390
      F=STORE(L1M1)*V+STORE(L1M1+3)*W+STORE(L1M1+6)*X-F*D/STORE(L1P2)   CVC01400
      G=STORE(L1M1+1)*V+STORE(L1M1+4)*W+STORE(L1M1+7)                   CVC01410
     2 *X-G*D/STORE(L1P2+1)                                             CVC01420
      H=STORE(L1M1+2)*V+STORE(L1M1+5)*W+STORE(L1M1+8)                   CVC01430
     2 *X-H*D/STORE(L1P2+2)                                             CVC01440
      JO=JA
      IF (IASYM .EQ. 1) THEN
         E = 0.                                                             CVC01450
      ELSE
         E = ESAVE
      ENDIF
      CALL XADXYZ                                                       CVC01460
      JO=JB                                                             CVC01470
      E=-ESAVE                                                              CVC01480
      CALL XADXYZ                                                       CVC01490
      MCA=JA                                                            CVC01500
      STORE(L22PD+1) = STORE(LCG+3)                                     CVC01510
      CALL XFMPDQ                                                       CVC01520
      JA=ISTORE(JB)                                                     CVC01530
      IF(JA)1750,1750,1000                                              CVC01540
1750  CONTINUE                                                          CVC01550
cdjwapr99}
      RETURN
      END
C
CODE FOR XCMDC
      SUBROUTINE XCMDC(IASYM)
C--CALCULATE MEAN DISTANCE RESTRAINTS
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET UP THE POINTERS TO THE TOP OF THE WORK STACK
      DUMP=STORE(LCG+4)
      STORE(LCG+4)=0.
      JJ=0
      JH=ISTORE(LCG+2)+LC
      JI=JH
      JA=LCA
C--CALCULATE THE PARTIAL DIFFERENTIALS INITIALLY
1000  CONTINUE
      E=1.0
      CALL XCDPD(IASYM)
      STORE(LCG+4)=STORE(LCG+4)+D
      JJ=JJ+1
      STORE(JI)=D
      JI=JI+1
      JA=ISTORE(JB)
      IF(JA)1050,1050,1000
C--END OF THE FIRST PASS  -  PASS THROUGH NOW AND ACCUMULATE
1050  CONTINUE
      STORE(LCG+4)=STORE(LCG+4)/FLOAT(JJ)+DUMP
      JI=JH
      JA=LCA
      NCA=2
1100  CONTINUE
      JB=ISTORE(JA)
      MCA=JA
      STORE(L22PD+2)=STORE(LCG+4)-STORE(JI)
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
      JI=JI+1
      JA=ISTORE(JB)
      IF(JA)1150,1150,1100
1150  CONTINUE
      RETURN
      END
C
!> Calculate ULIJ restraints. Each local Uij is restrained to the mean <Uij> of all atoms.
!! The first atom of the group is the atom to be restrainted, the 2 other atoms are used to form the local basis      
      SUBROUTINE XCVCULIJ(results)
      use xssval_mod, only: issapp, issprt
      use list26_mod
      use xiobuf_mod, only:CMON
      use math_mod, only: DSYEVJ3
      use store_mod, only: store, istore=>i_store, c_store
      implicit none
C
      type(restraints_t), intent(inout), optional :: results

      integer :: icpt, jcpt,  ij, ik, info
      real, dimension(12) :: A1 !< Partial derivatives      
      integer, dimension(9), parameter :: U_ASSIGN=
     &    (/ 1, 6, 5, 6, 2, 4, 5, 4, 3 /) !< Transform linear 6 elements adp to linear 9 element adps
      double precision, dimension(3,3) :: A_M !< orthogonalisation matrix
      !double precision, dimension(3,3) :: B_M !< scaling to dimensionless adp

      double precision, dimension(3) :: ROT1, ROT2, ROT3 !< Cartesian axes
      double precision, dimension(3) :: ANAXIS, ANORTH, DIFF_VEC !< temp variables to calculates axes
     
      type Udata_t
          double precision, dimension(6) :: U_L !< adp in linear 6 element form
          double precision, dimension(3,3) :: U_M !< adp as a 3x3 matrix
          double precision, dimension(3,3) :: L_M !< rotation matrix for local basis
          double precision, dimension(3,3) :: RAB !< rotation matrix with A_M, B_M and L_M
          double precision, dimension(3,3) :: RABUBAR !< adp in local cartesian coordinate space
          double precision, dimension(9,6) :: dUcart !< dU/dxx matrix where each derivative dxx is a column vector
          double precision, dimension(3,3) :: Q !< eigenvectors
          double precision, dimension(3) :: W !< eigen values
          logical :: tobeused !< flag for unusable atoms
      end type
      type(Udata_t), dimension(:), allocatable :: Udata
      double precision, dimension(3,3) :: temp_M !< temp 3x3 matrix
      
      double precision, dimension(3,3) :: U_avg !< average of alls adps
      character(len=2), dimension(6),parameter :: Uindices=
     &  (/'11','22','33','12','23','13'/)
      
      real dump
      REAL DIFF_VAL
      REAL MEAN_VAL
      
C
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
      include 'XUNITS.INC'
      !include 'XSSVAL.INC'
C
      EQUIVALENCE (O,A1(1))    ! Note well
      
C
C--SET UP A FEW CONSTANTS                                        
      DUMP=STORE(LCG+4)   ! The 'observed value' of the restraint
      MCA=LCA ! address of fisrt atom
      
      if(nca<3) then
        WRITE(CMON,'("{E", A)') 
     1    'ULIJ: At least a list of 6 atoms is needed'
        CALL XPRVDU(NCVDU, 1,0)      
        return
      end if
      
      if(present(results)) then
          results%short_desc=
     1      'Restrain Uij to be equals in their local basis'
          results%groups=NCA/3
          call extend(results%subrestraints, NCA/3*6, .true.)
      end if  

      ! Orthogonalisation matrix (stored by rows, reshape fill column wise, hence the transpose)
      A_M=transpose(reshape(STORE(L1O1:L1O1+8), (/3,3/))) ! Multiply diffvec by orthogonalisation matrix
      
      ! Ucif scaled to U*
      !B_M=0.0d0
      !B_M(1,1)=STORE(L1P2)
      !B_M(2,2)=STORE(L1P2+1)
      !B_M(3,3)=STORE(L1P2+2)
      !R_M=matmul(A_M, B_M) 
      
      allocate(Udata(nca))
      JA=LCA
      U_avg=0.0d0
      do icpt=1, nca,3 ! loop over each atom
        JB=ISTORE(JA)
        JC=ISTORE(JB)

        if(present(results)) then
          do jcpt=0,5
            call extend(
     &        results%subrestraints((icpt-1)/3*6+1+jcpt)%atoms,
     &        3, .true.)
            results%subrestraints((icpt-1)/3*6+1+jcpt)%atoms(1)%label=
     &        c_store(JA+2)
            results%subrestraints((icpt-1)/3*6+1+jcpt)%atoms(1)%serial=
     &        nint(store(JA+3))
            results%subrestraints((icpt-1)/3*6+1+jcpt)%description=
     &        'U'//Uindices(jcpt+1)//'_local - <U'//
     &        Uindices(jcpt+1)//'_local> == 0'
            results%subrestraints((icpt-1)/3*6+1+jcpt)%atoms(2)%label=
     &        c_store(JB+2)
            results%subrestraints((icpt-1)/3*6+1+jcpt)%atoms(2)%serial=
     &        nint(store(JB+3))
            results%subrestraints((icpt-1)/3*6+1+jcpt)%atoms(3)%label=
     &        c_store(JC+2)
            results%subrestraints((icpt-1)/3*6+1+jcpt)%atoms(3)%serial=
     &        nint(store(JC+3))
          end do          
        end if

        Udata(icpt)%tobeused=.true.
        Udata(icpt+1)%tobeused=.false.
        Udata(icpt+2)%tobeused=.false.

        IF(ABS(STORE(ISTORE(JA+16)+6))/=0.0 ) THEN ! check if atom is isotropic
          if(present(results)) then
            WRITE(CMON,'("{E",1X, "(",I0,")",1X, A)')
     1         results%user_index, trim(results%restraint_text)
            CALL XPRVDU(NCVDU, 1,0)      
              WRITE(CMON,'("{E", 4X, A)') 
     1          'Error: not implemented on isotropic atom'
            CALL XPRVDU(NCVDU, 1,0)      
          end if
          Udata(icpt)%tobeused=.false.
        end if
      
C--DEFINE U Matrices 
        Udata(icpt)%U_L=STORE(ISTORE(JA+16)+14:ISTORE(JA+16)+14+11:2)

C     U Matrices in 3x3 matrix
        Udata(icpt)%U_M=reshape(Udata(icpt)%U_L(U_ASSIGN), (/3,3/)) 

        if(present(results)) then
          do jt=0,5
            results%subrestraints((icpt-1)/3*6+1+jt)%atoms(1)%adps_crys=
     &        Udata(icpt)%U_M
          end do
        end if
        
        do ik=0,2
          DIFF_VEC(ik+1)=
     &      store(istore(JA+16)+8+ik*2)-
     &      store(istore(JB+16)+8+ik*2)     
        end do

        do ik=0,2
          ANAXIS(ik+1)=
     &      store(istore(JB+16)+8+ik*2)-
     &      store(istore(JC+16)+8+ik*2)     
        end do

        ROT3=matmul(A_M, DIFF_VEC)
        ANORTH=matmul(A_M, ANAXIS)
        CALL DNORM3(ROT3) !Normalise
        CALL DNORM3(ANORTH) !Normalise
         
        CALL DNCROP3(ROT3, ANORTH, ROT2)  !Axis 2 perp to 3 and X-axis
        CALL DNORM3(ROT2) !Normalise
        CALL DNCROP3(ROT2, ROT3, ROT1)   ! Axis 1 perp to 2 an 3.
        CALL DNORM3(ROT1) !Normalise

        ! rotation matrix
        Udata(icpt)%L_M(1,:)=rot1
        Udata(icpt)%L_M(2,:)=rot2
        Udata(icpt)%L_M(3,:)=rot3
        
        call rabubar_derivs(Udata(icpt)%L_M, Udata(icpt)%RAB, 
     &    Udata(icpt)%dUcart)       
        Udata(icpt)%RABUBAR=matmul(matmul(Udata(icpt)%RAB, 
     &    Udata(icpt)%U_M), transpose(Udata(icpt)%RAB))
        
        ! eigen decomposition (used to filter out npd adp when avereging)
        temp_M=Udata(icpt)%RABUBAR
        call DSYEVJ3(temp_M, Udata(icpt)%Q, Udata(icpt)%W, info)   
        if(info<0) then
          WRITE(CMON,'("{I", A)') 
     1      'ULIJ: DSYEVJ3 failed to converged'
          CALL XPRVDU(NCVDU, 1,0)   
          Udata(icpt)%W=-1.0d0   
        end if              
      
        if(any(Udata(icpt)%W<0.0d0)) then
          Udata(icpt)%tobeused=.false.
        end if
              
        if(present(results)) then
          do jcpt=0,5
            associate(r => 
     &        results%subrestraints((icpt-1)/3*6+1+jcpt)%atoms(1))
              r%adps_cart=Udata(icpt)%RABUBAR
              r%M=Udata(icpt)%RAB
            end associate
          end do
        end if
        
        if(Udata(icpt)%tobeused) then
          U_avg=U_avg+Udata(icpt)%RABUBAR
        end if
        
        ja=istore(jC)
      end do

      if(count(Udata(:)%tobeused)==0) then
        WRITE(CMON,'("{E", A)') 
     1    'ULIJ: All atoms are non positive definite'
        CALL XPRVDU(NCVDU, 1,0)      
        results%groups=0
        deallocate(results%subrestraints)
        return
      end if
      
      U_avg=U_avg/real(count(Udata(:)%tobeused))
      
      JA=LCA
      do icpt=1, nca, 3 ! loop over each atom to setup restraints
        JB=ISTORE(JA)
        JC=ISTORE(JB)
        if(present(results)) then
          do jcpt=0,5
            results%subrestraints((icpt-1)/3*6+1+jcpt)%
     &        atoms(1)%adps_target=U_avg

            if(jcpt==0) then
              results%subrestraints((icpt-1)/3*6+1+jcpt)%
     &        rvalue=Udata(icpt)%rabubar(1,1)
              results%subrestraints((icpt-1)/3*6+1+jcpt)%
     &        rtarget=U_avg(1,1)
            else if(jcpt==1) then
              results%subrestraints((icpt-1)/3*6+1+jcpt)%
     &        rvalue=Udata(icpt)%rabubar(2,2)
              results%subrestraints((icpt-1)/3*6+1+jcpt)%
     &        rtarget=U_avg(2,2)
            else if(jcpt==2) then
              results%subrestraints((icpt-1)/3*6+1+jcpt)%
     &        rvalue=Udata(icpt)%rabubar(3,3)
              results%subrestraints((icpt-1)/3*6+1+jcpt)%
     &        rtarget=U_avg(3,3)
            else if(jcpt==3) then
              results%subrestraints((icpt-1)/3*6+1+jcpt)%
     &        rvalue=Udata(icpt)%rabubar(1,2)
              results%subrestraints((icpt-1)/3*6+1+jcpt)%
     &        rtarget=U_avg(1,2)
            else if(jcpt==4) then
              results%subrestraints((icpt-1)/3*6+1+jcpt)%
     &        rvalue=Udata(icpt)%rabubar(2,3)
              results%subrestraints((icpt-1)/3*6+1+jcpt)%
     &        rtarget=U_avg(2,3)
            else
              results%subrestraints((icpt-1)/3*6+1+jcpt)%
     &        rvalue=Udata(icpt)%rabubar(1,3)
              results%subrestraints((icpt-1)/3*6+1+jcpt)%
     &        rtarget=U_avg(1,3)
            END IF         

          end do
        end if
        
!        if(any(Udata(icpt)%W<0.0)) then
!          if(present(results)) then
!            WRITE(CMON,'("{I", 4X, A, A, A, "(",I0,")")') 
!     1        'UVOL: ',
!     4        ' Non positive definite adp, restraint not applied to ',
!     2        trim(results%subrestraints(icpt)%atoms(1)%label),
!     3        results%subrestraints(icpt)%atoms(1)%serial
!            CALL XPRVDU(NCVDU, 1,0)      
!          end if
!          cycle
!        end if
      
        do ij=1, 6
          if(ij==1) then
              ! (1,1) -> 1
              a1(7:12)=Udata(icpt)%dUcart(1,:)
          else if(ij==2) then
              ! (2,2) -> 5
              a1(7:12)=Udata(icpt)%dUcart(5,:)
          else if(ij==3) then
              ! (3,3) -> 9
              a1(7:12)=Udata(icpt)%dUcart(9,:)
          else if(ij==4) then
              ! (1,2) -> 2
              a1(7:12)=Udata(icpt)%dUcart(2,:)
          else if(ij==5) then
              ! (2,3) -> 8
              a1(7:12)=Udata(icpt)%dUcart(8,:)
          else
              ! (1,3) -> 7
              a1(7:12)=Udata(icpt)%dUcart(7,:)
          END IF         
          a1(1:6)=a1(7:12)
          JP=ISTORE(JA+6)
          JD=ISTORE(JA+16)
          JX=JP ! JX used in XADUIJ
          JO=JA ! JO used in XADUIJ
          CALL XADUIJ  

C--CALCULATE THE MEAN VALUE AND THE DIFFERENCE                          CVC01190      
          IF ( ij==1 ) THEN
             DIFF_VAL = Udata(icpt)%rabubar(1,1) - U_avg(1,1)
             MEAN_VAL = Udata(icpt)%rabubar(1,1) + U_avg(1,1)
          else IF ( ij==2 ) THEN
             DIFF_VAL = Udata(icpt)%rabubar(2,2) - U_avg(2,2)
             MEAN_VAL = Udata(icpt)%rabubar(2,2) + U_avg(2,2)
          else IF ( ij==3 ) THEN
             DIFF_VAL = Udata(icpt)%rabubar(3,3) - U_avg(3,3)
             MEAN_VAL = Udata(icpt)%rabubar(3,3) + U_avg(3,3)
          else if(ij==4) then
             DIFF_VAL = Udata(icpt)%rabubar(1,2) - U_avg(1,2)
             MEAN_VAL = Udata(icpt)%rabubar(1,2) + U_avg(1,2)
          else if(ij==5) then
             DIFF_VAL = Udata(icpt)%rabubar(2,3) - U_avg(2,3)
             MEAN_VAL = Udata(icpt)%rabubar(2,3) + U_avg(2,3)
          else
             DIFF_VAL = Udata(icpt)%rabubar(1,3) - U_avg(1,3)
             MEAN_VAL = Udata(icpt)%rabubar(1,3) + U_avg(1,3)
          END IF

          STORE(LCG+4)=0.5*(MEAN_VAL)                                       CVC01320
c         print *, 'L22PD saved', l22pd, ' Dump: ',DUMP
          STORE(L22PD+2)=0.0-DIFF_VAL ! Difference between restraint target (DUMP) and computed from current parameters (D)
c         print *, 'L22PD+2 ', store(l22pd+2)
          STORE(L22PD+1) = STORE(LCG+3)                                     CVC01510
c         print *, 'L22PD+1 ', store(l22pd+1)
          CALL XFMPDQ        
         
C--CLEAR THE P.D. SLOSTS FOR THE NEXT COORD.         
          JQ=ISTORE(JA+6)
          DO JX=1,6
            STORE(JQ+2)=0.
            JQ=ISTORE(JQ)
          end do
         
        end do

        JA=ISTORE(JC)
      end do
      END
 
!> This subroutine calculate the restraints that align the principal axes of n atoms
!! to a common average direction
      SUBROUTINE XCVCUALIGN(results)
      use xssval_mod, only: issapp, issprt
      use list26_mod
      use xiobuf_mod, only:CMON
      use math_mod, only: DSYEVJ3, outer_product, matrixtoquaternions
      use math_mod, only: quaternionstomatrix, m33det
      use store_mod, only: store, istore=>i_store, c_store
      implicit none
C
      type(restraints_t), intent(inout), optional :: results

      integer :: icpt, jcpt, info
      real, dimension(12) :: A1 !< Partial derivatives      
      integer, dimension(9), parameter :: U_ASSIGN=
     &    (/ 1, 6, 5, 6, 2, 4, 5, 4, 3 /) !< Transform linear 6 elements adp to linear 9 element adps
      double precision, dimension(3,3) :: A_M !< orthogonalisation matrix
      double precision, dimension(3,3) :: B_M !< scaling to dimensionless adp
      double precision, dimension(3,3) :: R_M !< rotation matrix with A_M and B_M
      double precision, dimension(3,3) :: Q_avg !< Average rotation matrix from eigenvectors
     
      type Udata_t
          double precision, dimension(6) :: U_L !< adp in linear 6 element form
          double precision, dimension(3,3) :: U_M !< adp as a 3x3 matrix
          double precision, dimension(3,3) :: RABUBAR !< adp in local cartesian coordinate space
          double precision, dimension(9,6) :: dUcart !< dU/dxx matrix where each derivative dxx is a column vector
          double precision, dimension(3,3) :: U_C !< adp in cartesian space
          double precision, dimension(3,3) :: Q !< eigenvectors
          double precision, dimension(3) :: W !< eigen values
          logical :: tobeused !< flag for unusable atoms
      end type
      type(Udata_t), dimension(:), allocatable :: Udata
      
      double precision, dimension(4) :: qi, qi_avg !< quaternion
      
      REAL DIFF_VAL
      REAL MEAN_VAL
      
C
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
      include 'XUNITS.INC'
      !include 'XSSVAL.INC'
C
      EQUIVALENCE (O,A1(1))    ! Note well
      
C
C--SET UP A FEW CONSTANTS                                        
      MCA=LCA ! address of fisrt atom

      if(present(results)) then
          results%short_desc='Restrain all ADPs to be aligned'
          results%groups=NCA
          call extend(results%subrestraints, NCA*3, .true.)
      end if  

      ! Orthogonalisation matrix (stored by rows, reshape fill column wise, hence the transpose)
      A_M=transpose(reshape(STORE(L1O1:L1O1+8), (/3,3/))) ! Multiply diffvec by orthogonalisation matrix
      
      ! Ucif scaled to U*
      B_M=0.0d0
      B_M(1,1)=STORE(L1P2)
      B_M(2,2)=STORE(L1P2+1)
      B_M(3,3)=STORE(L1P2+2)
      R_M=matmul(A_M, B_M) 
      
      allocate(Udata(nca))
      JA=LCA
      Q_avg=0.0d0
      qi_avg=0.0d0
      do icpt=1, nca ! loop over each atom

        if(present(results)) then
          do jcpt=1, 3
            call extend(results%subrestraints((icpt-1)*3+jcpt)%atoms, 1,
     &         .true.)
            results%subrestraints((icpt-1)*3+jcpt)%atoms(1)%label=
     &        c_store(JA+2)
            results%subrestraints((icpt-1)*3+jcpt)%atoms(1)%serial=
     &        nint(store(JA+3))
          end do
          results%subrestraints((icpt-1)*3+1)%description=
     &      'Ul_12 = 0.0'
          results%subrestraints((icpt-1)*3+2)%description=
     &      'Ul_23 = 0.0'
          results%subrestraints((icpt-1)*3+3)%description=
     &      'Ul_13 = 0.0'
        end if

        Udata(icpt)%tobeused=.true.

        IF(ABS(STORE(ISTORE(JA+16)+6))/=0.0 ) THEN ! check if atom is isotropic
          if(present(results)) then
            WRITE(CMON,'("{E",1X, "(",I0,")",1X, A)')
     1         results%user_index, trim(results%restraint_text)
            CALL XPRVDU(NCVDU, 1,0)      
              WRITE(CMON,'("{E", 4X, A)') 
     1          'Error: not implemented on isotropic atom'
            CALL XPRVDU(NCVDU, 1,0)      
          end if
          Udata(icpt)%tobeused=.false.
        end if
      
C--DEFINE U Matrices 
        Udata(icpt)%U_L=STORE(ISTORE(JA+16)+14:ISTORE(JA+16)+14+11:2)

C     U Matrices in 3x3 matrix
        Udata(icpt)%U_M=reshape(Udata(icpt)%U_L(U_ASSIGN), (/3,3/)) 

        if(present(results)) then
          do jcpt=1, 3
            results%subrestraints((icpt-1)*3+jcpt)%
     &        atoms(1)%adps_crys=Udata(icpt)%U_M
          end do
        end if
      
        ! Adp in cartesian space
        Udata(icpt)%U_C=
     1    matmul(matmul(R_M, Udata(icpt)%U_M), transpose(R_M))
        ! eigen decomposition
        call DSYEVJ3(Udata(icpt)%U_C, Udata(icpt)%Q, Udata(icpt)%W,info)      
        if(info<0) then
          WRITE(CMON,'("{I", A)') 
     1      'UALIGN: DSYEVJ3 failed to converged'
          CALL XPRVDU(NCVDU, 1,0)   
          Udata(icpt)%W=-1.0d0   
        end if              
        
        Udata(icpt)%U_C=
     1    matmul(matmul(R_M, Udata(icpt)%U_M), transpose(R_M))
      
        if(any(Udata(icpt)%W<0.0d0) .or. 
     1    maxval(Udata(icpt)%W)-minval(Udata(icpt)%W)<1d-6) then
          Udata(icpt)%tobeused=.false.
          qi=0.0d0
        else
          qi=matrixtoquaternions(Udata(icpt)%Q)
          if(sum(abs(qi_avg-qi))>sum(abs(qi_avg+qi))) then
            qi=-qi
          end if            
          qi_avg=qi_avg+qi
        end if
        
        ja=istore(ja)
        !write(*,'(A,I0,1X,1P, 9(E10.3,1X))') 'Q ', icpt, Udata(icpt)%Q
        !write(*,'(A,I0,1X,1P, 4(E10.3,1X))') 'Qi ', icpt, qi
      end do
      
      if(count(Udata(:)%tobeused)==0) then
        WRITE(CMON,'("{I", A, A)') 
     1      'UALIGN: All atoms are non positive definite ',
     2      'or nearly isotropic'
        CALL XPRVDU(NCVDU, 1,0)   
        deallocate(results%subrestraints)
        return
      end if

      ! Calculating the average quaternions
      ! The mean is a very crude approximation that works only for small differences
      ! however as the refinement progress those differences will reach small values
      !
      ! I (pp) tried this method before with less success: 
      ! Markley, F. L., Cheng, Y., Crassidis, J. L. and Oshman, Y.
      ! Averaging Quaternions
      ! Journal of Guidance, Control, and Dynamics, American Institute of Aeronautics and Astronautics, 2007, Vol. 30(4), pp. 1193-1197
      ! doi: https://doi.org/10.2514/1.28949

      qi=qi_avg/real(count(Udata(:)%tobeused), kind(1.0d0))
      qi=qi/sqrt(sum(qi**2))
      Q_avg=quaternionstomatrix(qi)
      !write(*,'(A,1P, 4(E10.3,1X))') 'Qi_avg ', qi
      !write(*,'(A,1P, 9(E10.3,1X))') 'Q_avg ', Q_avg
                        
      JA=LCA
      do icpt=1, nca ! loop over each atom
C Here, compute derivatives
        call rabubar_eigenderivs(Q_avg, Udata(icpt)%dUcart)
      
C-- RUN RABUBAR MULTIPLICATION (no need to calculate)
        Udata(icpt)%RABUBAR=matmul(matmul(transpose(Q_avg), 
     &    Udata(icpt)%U_C), Q_avg)
     
        if(present(results)) then
          do jcpt=1, 3
            associate(r => 
     &        results%subrestraints((icpt-1)*3+jcpt)%atoms(1))
              r%M=matmul(transpose(Q_avg), R_M)              
              r%adps_cart=Udata(icpt)%RABUBAR
            end associate
          end do
        end if
        
        ja=istore(ja)
      end do
      
      JA=LCA
      do icpt=1, nca ! loop over each atom to setup restraints
        do jcpt=1, 3
          if(present(results)) then
            associate(r => 
     &        results%subrestraints((icpt-1)*3+jcpt))
              r%rtarget=0.0
              if(jcpt==1) then
                r%rvalue=r%atoms(1)%adps_cart(1,2)
              else if(jcpt==2) then
                r%rvalue=r%atoms(1)%adps_cart(2,3)
              else
                r%rvalue=r%atoms(1)%adps_cart(1,3)
              end if
             end associate
          end if
        
          if(jcpt==1) then
            DIFF_VAL=Udata(icpt)%RABUBAR(1,2)
            MEAN_VAL=Udata(icpt)%RABUBAR(1,2)
            a1(7:12)=Udata(icpt)%dUcart(2,:)
          else if(jcpt==2) then
            DIFF_VAL=Udata(icpt)%RABUBAR(2,3)
            MEAN_VAL=Udata(icpt)%RABUBAR(2,3)
            a1(7:12)=Udata(icpt)%dUcart(6,:)
          else 
            DIFF_VAL=Udata(icpt)%RABUBAR(1,3)
            MEAN_VAL=Udata(icpt)%RABUBAR(1,3)
            a1(7:12)=Udata(icpt)%dUcart(3,:)
          end if
          a1(1:6)=a1(7:12)

          JP=ISTORE(JA+6)
          JD=ISTORE(JA+16)
          JX=JP ! JX used in XADUIJ
          JO=JA ! JO used in XADUIJ
          CALL XADUIJ  

          STORE(LCG+4)=0.5*MEAN_VAL
          STORE(L22PD+2)=0.0-DIFF_VAL ! Difference between restraint target (DUMP) and computed from current parameters (D)
          STORE(L22PD+1) = STORE(LCG+3)
          CALL XFMPDQ

C--CLEAR THE P.D. SLOSTS FOR THE NEXT COORD.         
          JQ=ISTORE(JA+6)
          DO JX=1,6
            STORE(JQ+2)=0.
            JQ=ISTORE(JQ)
          end do
          
        end do
        JA=ISTORE(JA)

      end do

      RETURN

      END
      
CODE FOR XCVCURIGU
!> RIGU shelxl type of restraint
      SUBROUTINE XCVCURIGU(iasym, results)
      use xssval_mod, only: issapp, issprt
      use list26_mod
      use xiobuf_mod, only: cmon
      use math_mod, only: DSYEVJ3
      use store_mod, only: store, istore=>i_store, c_store

      implicit none
C--CALCULATE RIGID BODY RESTRAINTS (URIGU resraints)
C
C
C      IASYM = 1 FOR ASYMMETRIC OTHERWISE 0
C
C--
      type(restraints_t), intent(inout), optional :: results
      integer, intent(in) :: iasym

      integer :: icpt, jcpt
      real, dimension(12) :: A1 !< Partial derivatives
      double precision, dimension(3) :: ROT1, ROT2, ROT3 !< Cartesian axes
      double precision, dimension(3) :: ANAXIS, DIFF_VEC !< temp variables to calculates axes
      
      double precision U_L_1(6), U_L_2(6) !< adp in linear 6 element form
      integer, dimension(9), parameter :: U_ASSIGN=
     &    (/ 1, 6, 5, 6, 2, 4, 5, 4, 3 /) !< Transform linear 6 elements adp to linear 9 element adps
      double precision U_M_1(3,3), U_M_2(3,3) !< adp as a 3x3 matrix
      double precision R_M(3,3) !< rotation matrix
      double precision RAB(3,3) !< full transformation matrix
      double precision RABUBAR_1(3,3) !< adp in local cartesian coordinate space
      double precision RABUBAR_2(3,3) !< adp in local cartesian coordinate space
      double precision, dimension(3,3) :: A_M !< orthogonalisation matrix
      double precision dUcart(9,6) !< dU/dxx matrix where each derivative dxx is a column vector

      REAL DIFF_VAL
      REAL MEAN_VAL
      
C
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
      include 'XUNITS.INC'
      !include 'XSSVAL.INC'
C
      EQUIVALENCE (O,A1(1))    ! Note well

C--SET UP A FEW CONSTANTS                                        
      JA=LCA              ! Address of first parameter block header                                      
      MCA=JA ! address of fisrt atom
      
      if(present(results)) then
          results%short_desc='Enhanced rigid body restraints'
          results%groups=NCA/2
          call extend(results%subrestraints, NCA/2*3, .true.)
      end if  
      
      ! Orthogonalisation matrix (stored by rows, reshape fill column wise, hence the transpose)
      A_M=transpose(reshape(STORE(L1O1:L1O1+8), (/3,3/))) ! Multiply diffvec by orthogonalisation matrix
      
      JA=LCA
      do icpt=1, nca/2 ! loop over each atom
        JB=istore(ja)

        if(present(results)) then
          do jcpt=1, 3
            call extend(results%subrestraints((icpt-1)*3+jcpt)%atoms, 
     &        2, .true.)
            results%subrestraints((icpt-1)*3+jcpt)%atoms(1)%label=
     &        c_store(JA+2)
            results%subrestraints((icpt-1)*3+jcpt)%atoms(1)%serial=
     &        nint(store(JA+3))
            results%subrestraints((icpt-1)*3+jcpt)%atoms(2)%label=
     &        c_store(JB+2)
            results%subrestraints((icpt-1)*3+jcpt)%atoms(2)%serial=
     &        nint(store(JB+3))
          end do
        end if
      
        U_L_1=STORE(ISTORE(JA+16)+14:ISTORE(JA+16)+14+11:2)
        U_L_2=STORE(ISTORE(JB+16)+14:ISTORE(JB+16)+14+11:2)
      
C       U Matrices in 3x3 matrix
        U_M_1=reshape(U_L_1(U_ASSIGN), (/3,3/)) 
        U_M_2=reshape(U_L_2(U_ASSIGN), (/3,3/)) 
        if(present(results)) then
          do jcpt=1, 3
            results%subrestraints((icpt-1)*3+jcpt)%
     &        atoms(1)%adps_crys=U_M_1
            results%subrestraints((icpt-1)*3+jcpt)%
     &        atoms(2)%adps_crys=U_M_2
          end do
        end if
            
C-- Set up the new coordinate system for the adp
C-----------------------------------------------

C--CALCULATE THE INTERNUCLEAR DISTANCE                                  
        JO=JA  
        JS=JB  
        JQ=ISTORE(JO+16)
        JU=ISTORE(JS+16)

C Here is the interatomic vector in crystal fractions:    
        DIFF_VEC(1)=STORE(JQ+8)-STORE(JU+8)
        DIFF_VEC(2)=STORE(JQ+10)-STORE(JU+10)
        DIFF_VEC(3)=STORE(JQ+12)-STORE(JU+12)

        ANAXIS = (/1.0d0, 0.0d0, 0.0d0/)
      
        ROT3=matmul(A_M, DIFF_VEC)
        CALL DNORM3(ROT3) !Normalise
      
      
C Take a perpendiculat vector
        ROT2=(/rot3(3), rot3(3), -rot3(1)-rot3(2)/)
        if(all(abs(rot2)<=1d-4)) then
          ROT2=(/-rot3(2)-rot3(3), rot3(1), rot3(1)/)
        end if
        CALL DNORM3(ROT2) !Normalise

        CALL DNCROP3(ROT2, ROT3, ROT1)   ! Axis 1 perp to 2 an 3.
        CALL DNORM3(ROT1) !Normalise
                 
        ! rotation matrix from basis vectors
        R_M(1,:)=rot1
        R_M(2,:)=rot2
        R_M(3,:)=rot3
          
        call rabubar_derivs(R_M, RAB, dUcart)
        RABUBAR_1=matmul(rab, matmul(U_M_1, transpose(rab)))
        RABUBAR_2=matmul(rab, matmul(U_M_2, transpose(rab)))
        if(present(results)) then
          do jcpt=1, 3
            results%subrestraints((icpt-1)*3+jcpt)%
     &        atoms(1)%adps_cart=RABUBAR_1
            results%subrestraints((icpt-1)*3+jcpt)%atoms(1)%M=rab
            results%subrestraints((icpt-1)*3+jcpt)%
     &        atoms(2)%adps_cart=RABUBAR_2
            results%subrestraints((icpt-1)*3+jcpt)%atoms(2)%M=rab
          end do
          associate(r => results%subrestraints)
            r((icpt-1)*3+1)%description='Uc1[1,3]-Uc2[1,3]=0'
            r((icpt-1)*3+1)%rvalue=RABUBAR_1(1,3)-RABUBAR_2(1,3)
            r((icpt-1)*3+1)%rtarget=0.0
            r((icpt-1)*3+2)%description='Uc1[2,3]-Uc2[2,3]=0'
            r((icpt-1)*3+2)%rvalue=RABUBAR_1(2,3)-RABUBAR_2(2,3)
            r((icpt-1)*3+2)%rtarget=0.0
            r((icpt-1)*3+3)%description='Uc1[3,3]-Uc2[3,3]=0'
            r((icpt-1)*3+3)%rvalue=RABUBAR_1(3,3)-RABUBAR_2(3,3)
            r((icpt-1)*3+3)%rtarget=0.0
          end associate
        end if
      
        do i=1, 3
      
          IF ( i==1 ) THEN   !UXZBAR
C      #### XZ DERIVS ####
              ! (1,3) -> 3
              a1(7:12)=dUcart(3,:)
              DIFF_VAL = RABUBAR_1(1, 3) - RABUBAR_2(1, 3)       
              MEAN_VAL = (RABUBAR_1(1, 3) + RABUBAR_2(1, 3))       
          ELSE IF ( i==2) THEN  !UYZBAR
C      #### YZ DERIVS ####
              ! (2,3) -> 8
              a1(7:12)=dUcart(8,:)
              DIFF_VAL = RABUBAR_1(2, 3) - RABUBAR_2(2, 3)       
              MEAN_VAL = (RABUBAR_1(2, 3) + RABUBAR_2(2, 3)) 
          ELSE   !UZZBAR
C      ##### ZZ DERIVS ####
              ! (3,3) -> 9
              a1(7:12)=dUcart(9,:)
              DIFF_VAL = RABUBAR_1(3, 3) - RABUBAR_2(3, 3)       
              MEAN_VAL = (RABUBAR_1(3, 3) + RABUBAR_2(3, 3)) 
          END IF

C First atom of the restraint                
C-----------------------------------------------
          a1(1:6)=a1(7:12) 
          JP=ISTORE(JA+6)
          JD=ISTORE(JA+16)
          JX=JP ! JX used in XADUIJ
          JO=JA ! JO used in XADUIJ
          if (iasym==1) then
c           dont restrain first atom
c            print *, "Asym"
              a1(1:6) = 0.0
          endif      
          CALL XADUIJ  

C Second atom of the restraint                
C-----------------------------------------------
          a1(1:6)=-a1(7:12) 
          JP=ISTORE(JB+6)
          JD=ISTORE(JB+16)
          JX=JP ! JX used in XADUIJ
          JO=JB ! JO used in XADUIJ
          CALL XADUIJ  
                      
C Here, you need to set D to be the computed value of the difference in the covariances
C Note that DUMP is the target difference (and should usually be zero).
C You need to set SUM to be the compute

          STORE(LCG+4)=0.5*MEAN_VAL
          STORE(L22PD+2)=0.0-DIFF_VAL ! Difference between restraint target 0.0 and computed from current parameters (D)
          STORE(L22PD+1) = STORE(LCG+3)
          CALL XFMPDQ                  

C--CLEAR THE P.D. SLOSTS FOR THE NEXT COORD.         
          JQ=ISTORE(JA+6)
          JW=ISTORE(JB+6)
          DO JX=1,6
              STORE(JQ+2)=0.
              STORE(JW+2)=0.
              JQ=ISTORE(JQ)
              JW=ISTORE(JW)
          end do

        end do

        JA=ISTORE(JB)
      end do

      END
C
CODE FOR XCVCUEIG
C--CALCULATE UEIG restraints. The 2 smalles eigen values are made equal
C
C--
!> Restrain the 2 smallest eigenvalue of a restraint to be equal
      SUBROUTINE XCVCUEIG(results)
      use xssval_mod, only: issapp, issprt
      use list26_mod
      use xiobuf_mod, only:CMON
      use math_mod, only: DSYEVJ3
      use store_mod, only:c_store, store, istore=>i_store
      implicit none

      type(restraints_t), intent(inout), optional :: results

      integer :: icpt, info, jcpt
      real, dimension(12) :: A1 !< Partial derivatives
      double precision U_L_1(6) !< adp in linear 6 element form
      integer, dimension(9), parameter :: U_ASSIGN=
     &    (/ 1, 6, 5, 6, 2, 4, 5, 4, 3 /) !< Transform linear 6 elements adp to linear 9 element adps
      double precision U_M_1(3,3) !< adp as a 3x3 matrix
      double precision R_M(3,3) !< rotation matrix
      double precision RABUBAR_1(3,3) !< adp in local cartesian coordinate space
      double precision, dimension(3,3) :: A_M !< orthogonalisation matrix
      double precision dUcart(9,6) !< dU/dxx matrix where each derivative dxx is a column vector
      double precision, dimension(3,3) :: U_C_1 !< adp in cartesian space
      double precision, dimension(3,3) :: Q_1 !< eigenvectors
      double precision, dimension(3,3) :: B_M
      double precision, dimension(3) :: W_1 !< eigen values
      double precision meaneig
      double precision, dimension(3) :: l3
      double precision l1
      logical lexit
      
      real dump
      REAL DIFF_VAL
      REAL MEAN_VAL
      
C
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
      include 'XUNITS.INC'
      !include 'XSSVAL.INC'
C
      EQUIVALENCE (O,A1(1))    ! Note well
      
C
C--SET UP A FEW CONSTANTS                                        
      DUMP=STORE(LCG+4)   ! The 'observed value' of the restraint
      JA=LCA              ! Address of first parameter block header                                      
      MCA=JA ! address of first atom
C--SET UP THE ADDRESSES OF THE ATOMS                                    

      ! Orthogonalisation matrix (stored by rows, reshape fill column wise, hence the transpose)
      A_M=transpose(reshape(STORE(L1O1:L1O1+8), (/3,3/))) ! Multiply diffvec by orthogonalisation matrix
      
      ! Ucif scaled to U*
      B_M=0.0d0
      B_M(1,1)=STORE(L1P2)
      B_M(2,2)=STORE(L1P2+1)
      B_M(3,3)=STORE(L1P2+2)
      
      R_M=matmul(A_M, B_M) 
      
      if(present(results)) then
          results%short_desc='Restrain an ADP to a spheroid'
          results%groups=NCA
          call extend(results%subrestraints, NCA*3, .true.)

          allocate(results%description(5))
          results%description(1)=
     &      'The 2 smallest eigen values are restrained to their mean.'
          results%description(2)=
     &      'the eigenvalues, Q a matrix of eigen vectors, '
          results%description(3)=
     &      'R a tansformation matrix of adp to cartesian space and '//
     &      'U a adp matrix. '
          results%description(4)=
     &      'Then R U R^t = Q L Q^t => L = Q^t R U R^t Q. '
          results%description(5)=
     &      'Finally dL/dU_ij = Q^t R dU/DU_ij R^t Q'
      end if
      
      do icpt=1, nca ! loop over each atom individually to set up restraints

        IF(ABS(STORE(ISTORE(JA+16)+6))/=0.0 ) THEN ! check if atom is isotropic
          if(present(results)) then
            WRITE(CMON,'("{I",1X, "(",I0,")",1X,A)') results%user_index,
     1        trim(results%restraint_text)
            CALL XPRVDU(NCVDU, 1,0)      
              WRITE(CMON,'("{I", 4X, A, A, "(",I0,")", A)') 
     1          'Error: atom ',trim(c_store(JA+2)),
     2          nint(store(JA+3)), 'is isotropic'
            CALL XPRVDU(NCVDU, 1,0)      
          end if
          cycle
        end if

        if(present(results)) then
          do jcpt=1, 3
            call extend(results%subrestraints((icpt-1)*3+jcpt)%atoms, 
     &        1, .true.)
            results%subrestraints((icpt-1)*3+jcpt)%atoms(1)%label=
     &        c_store(JA+2)
            results%subrestraints((icpt-1)*3+jcpt)%atoms(1)%serial=
     &        nint(store(JA+3))
          end do
          associate(r => results%subrestraints)
          r((icpt-1)*3+1)%description='L_11-<L_11,L_22>=0'
          r((icpt-1)*3+2)%description='L_22-<L_11,L_22>=0'
          r((icpt-1)*3+3)%description='L_12=0'
          end associate
        end if
          
C--DEFINE U Matrices 
        U_L_1=STORE(ISTORE(JA+16)+14:ISTORE(JA+16)+14+11:2)
C       U Matrices in 3x3 matrix
        U_M_1=reshape(U_L_1(U_ASSIGN), (/3,3/)) 

        if(present(results)) then
          do jcpt=1, 3
            results%subrestraints((icpt-1)*3+jcpt)%atoms(1)%
     1        adps_crys=U_M_1
          end do
        end if
      
        U_C_1=matmul(matmul(R_M, U_M_1), transpose(R_M))
        ! eigen decomposition
        call DSYEVJ3(U_C_1, Q_1, W_1, info)      
        if(info<0) then
          WRITE(CMON,'("{I", A)') 
     1      'UEIG: DSYEVJ3 failed to converged'
          CALL XPRVDU(NCVDU, 1,0)   
          cycle
        end if              
      
        U_C_1=matmul(matmul(R_M, U_M_1), transpose(R_M))                

        ! sort eigenvalues in ascending order with their corresponding eigenvector
        lexit=.true.
        do
          do i=1, 2
            if(w_1(i)>w_1(i+1)) then
              ! permute eigen values and corresponding eigen vectors
              l1=w_1(i)
              w_1(i)=w_1(i+1)
              w_1(i+1)=l1
              l3=Q_1(:,i)
              Q_1(:,i)=Q_1(:,i+1)
              Q_1(:,i+1)=l3
              lexit=.false.
              exit
            end if
          end do
          if(lexit) exit ! no change done, already sorted
          lexit=.true.
        end do
      
        meaneig=(w_1(1)+w_1(2))/2.0d0 ! average of eigenvalues
C-- RUN RABUBAR MULTIPLICATION (no need to calculate)
        RABUBAR_1=0.0d0
        RABUBAR_1(1,1)=w_1(1)
        RABUBAR_1(2,2)=w_1(2)
        RABUBAR_1(3,3)=w_1(3)

C Here, compute derivatives
        call rabubar_eigenderivs(Q_1, dUcart)
                  
        if(present(results)) then
          do jcpt=1,3
              results%subrestraints((icpt-1)*3+jcpt)%atoms(1)%
     1          adps_cart=RABUBAR_1
              results%subrestraints((icpt-1)*3+jcpt)%atoms(1)%M=Q_1
          end do
          results%subrestraints((icpt-1)*3+1)%rvalue=w_1(1)
          results%subrestraints((icpt-1)*3+2)%rvalue=w_1(2)
          results%subrestraints((icpt-1)*3+3)%rvalue=0.0
        end if
      
        do jcpt=1, 3 ! loop over the 3 U[ij]
      
          if(jcpt==1) then
              DIFF_VAL = RABUBAR_1(1,1)-meaneig
              MEAN_VAL = RABUBAR_1(1,1)+meaneig
          else if(jcpt==2) then
              DIFF_VAL = RABUBAR_1(2,2)-meaneig
              MEAN_VAL = RABUBAR_1(2,2)+meaneig
          else if(jcpt==3) then
              DIFF_VAL = RABUBAR_1(1,2)
              MEAN_VAL = RABUBAR_1(1,2)
          end if

          if(jcpt==1) then
              a1(7:12)=dUcart(1, :)-meaneig
          else if(jcpt==2) then
              a1(7:12)=dUcart(5, :)-meaneig
          else if(jcpt==2) then
            a1(7:12)=dUcart(2, :)
          end if
          
          a1(1:6)=a1(7:12)
          JP=ISTORE(JA+6)
          JD=ISTORE(JA+16)
          JX=JP ! JX used in XADUIJ
          JO=JA ! JO used in XADUIJ
          CALL XADUIJ  
                         
          STORE(LCG+4)=0.5*MEAN_VAL
          STORE(L22PD+2)=0.0-DIFF_VAL ! Difference between 0.0 and computed from current parameters (D)
          STORE(L22PD+1) = STORE(LCG+3)
          CALL XFMPDQ

C--CLEAR THE P.D. SLOSTS FOR THE NEXT COORD.         
          JQ=ISTORE(JA+6)
          DO JX=1,6
              STORE(JQ+2)=0.
              JQ=ISTORE(JQ)
          end do
      
        end do
      
        JA=ISTORE(JA)              
      end do

      RETURN
      END

C
CODE FOR XCVCUQISO
!> Restrain the adp to isotropic or nearly if low weight is used
      SUBROUTINE XCVCUQISO(results)
      use xssval_mod, only: issapp, issprt
      use list26_mod
      use xiobuf_mod, only:CMON
      use math_mod, only: DSYEVJ3
      use store_mod, only: store, istore=>i_store, c_store
      implicit none
C--CALCULATE UQISO restraints. The 3 eigen values are made equal
C
C--
      type(restraints_t), intent(inout), optional :: results

      integer :: icpt, info, jcpt
      real, dimension(12) :: A1 !< Partial derivatives
      double precision U_L_1(6) !< adp in linear 6 element form
      integer, dimension(9), parameter :: U_ASSIGN=
     &    (/ 1, 6, 5, 6, 2, 4, 5, 4, 3 /) !< Transform linear 6 elements adp to linear 9 element adps
      double precision U_M_1(3,3) !< adp as a 3x3 matrix
      double precision R_M(3,3) !< rotation matrix
      double precision RABUBAR_1(3,3) !< adp in local cartesian coordinate space
      double precision, dimension(3,3) :: A_M !< orthogonalisation matrix
      double precision dUcart(9,6) !< dU/dxx matrix where each derivative dxx is a column vector
      double precision, dimension(3,3) :: U_C_1 !< adp in cartesian space
      double precision, dimension(3,3) :: Q_1 !< eigenvectors
      double precision, dimension(3,3) :: B_M
      double precision, dimension(3) :: W_1 !< eigen values
      double precision meaneig

      real dump
      REAL DIFF_VAL
      REAL MEAN_VAL
      
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
      include 'XUNITS.INC'
      !include 'XSSVAL.INC'
C
      EQUIVALENCE (O,A1(1))    ! Note well
      
C
C--SET UP A FEW CONSTANTS                                        
      DUMP=STORE(LCG+4)   ! The 'observed value' of the restraint
      JA=LCA              ! Address of first parameter block header                                      
      MCA=JA ! address of first atom

      ! Orthogonalisation matrix (stored by rows, reshape fill column wise, hence the transpose)
      A_M=transpose(reshape(STORE(L1O1:L1O1+8), (/3,3/))) ! Multiply diffvec by orthogonalisation matrix
      
      ! Ucif scaled to U*
      B_M=0.0d0
      B_M(1,1)=STORE(L1P2)
      B_M(2,2)=STORE(L1P2+1)
      B_M(3,3)=STORE(L1P2+2)
      
      R_M=matmul(A_M, B_M) 

      if(present(results)) then
          results%short_desc='Restraint an ADP to be isotropic'
          results%groups=NCA
          call extend(results%subrestraints, NCA*6, .true.)

            allocate(results%description(5))
            results%description(1)=
     &        'The eigen values are restrained to their mean.'
            results%description(2)=
     &        'Let''s define L a diagonal matrix of '//
     &        'the eigenvalues, Q a matrix of eigen vectors, '
            results%description(3)=
     &        'R a tansformation matrix of adp to'//
     &        ' cartesian space and U a adp matrix. '
            results%description(4)=
     &        'Then R U R^t = Q L Q^t => L = Q^t R U R^t Q. '
            results%description(5)=
     &        'Finally dL/dU_ij = Q^t R dU/DU_ij R^t Q'
      end if      
      
      do icpt=1, NCA ! loop over each atom, restraints will be set individually

        IF(ABS(STORE(ISTORE(JA+16)+6))/=0.0 ) THEN ! check if atom is isotropic
          if(present(results)) then
            WRITE(CMON,'("{I",1X, "(",I0,")",1X,A)') results%user_index,
     1        trim(results%restraint_text)
            CALL XPRVDU(NCVDU, 1,0)      
              WRITE(CMON,'("{I", 4X, A, A, "(",I0,")", A)') 
     1          'Error: atom ',trim(c_store(JA+2)),
     2          nint(store(JA+3)), 'already isotropic'
            CALL XPRVDU(NCVDU, 1,0)      
          end if
          cycle
        end if

        if(present(results)) then
          do jcpt=1,6
            call extend(results%subrestraints((icpt-1)*6+jcpt)%atoms,
     &        1,.true.)
            results%subrestraints((icpt-1)*6+jcpt)%atoms(1)%label=
     &        c_store(JA+2)
            results%subrestraints((icpt-1)*6+jcpt)%atoms(1)%serial=
     &        nint(store(JA+3))
          end do
          associate(r => results%subrestraints)
            r((icpt-1)*6+1)%description='L(1,1)-<eig>=0'
            r((icpt-1)*6+2)%description='L(2,2)-<eig>=0'
            r((icpt-1)*6+3)%description='L(3,3)-<eig>=0'
            r((icpt-1)*6+4)%description='L(2,3)=0'
            r((icpt-1)*6+5)%description='L(1,3)=0'
            r((icpt-1)*6+6)%description='L(1,2)=0'
          end associate          
        end if  
          
C--DEFINE U Matrices 
        U_L_1=STORE(ISTORE(JA+16)+14:ISTORE(JA+16)+14+11:2)
C     U Matrices in 3x3 matrix
        U_M_1=reshape(U_L_1(U_ASSIGN), (/3,3/)) 

        if(present(results)) then
          do jcpt=1,6
            results%subrestraints((icpt-1)*6+jcpt)%atoms(1)%
     &        adps_crys=U_M_1
          end do
        end if
      
        ! Adp in cartesian space
        U_C_1=matmul(matmul(R_M, U_M_1), transpose(R_M))
        ! eigen decomposition
        call DSYEVJ3(U_C_1, Q_1, W_1, info)
        if(info<0) then
          WRITE(CMON,'("{E", A)') 
     1      'UQISO: DSYEVJ3 failed to converged'
          CALL XPRVDU(NCVDU, 1,0)   
          cycle
        end if              

        U_C_1=matmul(matmul(R_M, U_M_1), transpose(R_M))                
      
        meaneig=sum(w_1)/3.0d0 ! average of eigenvalues
C-- RUN RABUBAR MULTIPLICATION (no need to calculate)
        RABUBAR_1=0.0d0
        RABUBAR_1(1,1)=w_1(1)
        RABUBAR_1(2,2)=w_1(2)
        RABUBAR_1(3,3)=w_1(3)

C Here, compute derivatives
        call rabubar_eigenderivs(Q_1, dUcart)
                  
        if(present(results)) then
          do jcpt=1,6
            results%subrestraints((icpt-1)*6+jcpt)%atoms(1)%
     &        adps_cart=RABUBAR_1
            results%subrestraints((icpt-1)*6+jcpt)%atoms(1)%M=Q_1
          end do
          do jcpt=1,3
            results%subrestraints((icpt-1)*6+jcpt)%rvalue=w_1(jcpt)
            results%subrestraints((icpt-1)*6+jcpt)%rtarget=meaneig
          end do
          do jcpt=1,3
            results%subrestraints((icpt-1)*6+3+jcpt)%rvalue=0.0
            results%subrestraints((icpt-1)*6+3+jcpt)%rtarget=0.0
          end do
        end if
      
        do jcpt=1, 6 ! loop over the 6 U[ij]
      
            if(jcpt==1) then
              DIFF_VAL = RABUBAR_1(1,1)-meaneig
              MEAN_VAL = RABUBAR_1(1,1)+meaneig
            else if(jcpt==2) then
              DIFF_VAL = RABUBAR_1(2,2)-meaneig
              MEAN_VAL = RABUBAR_1(2,2)+meaneig
            else if(jcpt==3) then
              DIFF_VAL = RABUBAR_1(3,3)-meaneig
              MEAN_VAL = RABUBAR_1(3,3)+meaneig
            else if(jcpt==4) then
              DIFF_VAL = RABUBAR_1(2,3)
              MEAN_VAL = RABUBAR_1(2,3)
            else if(jcpt==5) then
              DIFF_VAL = RABUBAR_1(1,3)
              MEAN_VAL = RABUBAR_1(1,3)
            else if(jcpt==6) then
              DIFF_VAL = RABUBAR_1(1,2)
              MEAN_VAL = RABUBAR_1(1,2)
            end if

            if(jcpt==1) then
              a1(7:12)=dUcart(1, :)-meaneig
            else if(jcpt==2) then
              a1(7:12)=dUcart(5, :)-meaneig
            else if(jcpt==3) then
              a1(7:12)=dUcart(9, :)-meaneig
            else if(jcpt==4) then
              a1(7:12)=dUcart(6, :)
            else if(jcpt==5) then
              a1(7:12)=dUcart(3, :)
            else if(jcpt==6) then
              a1(7:12)=dUcart(2, :)
            end if
          
            a1(1:6)=a1(7:12)
            JP=ISTORE(JA+6)
            JD=ISTORE(JA+16)
            JX=JP ! JX used in XADUIJ
            JO=JA ! JO used in XADUIJ
            CALL XADUIJ  
                         
            STORE(LCG+4)=0.5*(MEAN_VAL)                                       CVC01320
            STORE(L22PD+2)=0.0-DIFF_VAL ! Difference between restraint target (0.0) and computed from current parameters (D)
            STORE(L22PD+1) = STORE(LCG+3)
            CALL XFMPDQ                                                       CVC01520

C--CLEAR THE P.D. SLOSTS FOR THE NEXT COORD.         
            JQ=ISTORE(JA+6)
            DO JX=1,6
              STORE(JQ+2)=0.
              JQ=ISTORE(JQ)
            end do
      
        end do
      
        JA=ISTORE(JA)                             
      end do

      RETURN
      END
C
CODE FOR XCVCUVOL
!> \brief Restrain the geometric mean of the principal axes of 2 adps to be equal
!!
!! geometric mean: <U> = (a b c)**(1/3)
!! with a, b, c length of the principal axes (eigen values)
!!
!! The restraint is: <U_1> - <U_2> = 0
!! => (a_1 b_1 c_1)**(1/3) - (a_2 b_2 c_2)**(1/3) = 0
!! 
!! d(a_1 b_1 c_1) = [ d(a_1)(b_1 c_1) + d(b_1)(a_1 c_1) + d(c_1)(a_1 b_1) ] / [3*(a_1 b_1 c_1)**(2.0/3.0)]
      SUBROUTINE XCVCUVOL(results)
      use xssval_mod, only: issapp, issprt
      use list26_mod
      use xiobuf_mod, only:CMON
      use math_mod, only: DSYEVJ3
      use store_mod, only: store, c_store, istore=>i_store
      implicit none

      type(restraints_t), intent(inout), optional :: results

      integer :: icpt, jcpt, info
      real, dimension(12) :: A1 !< Partial derivatives      
      integer, dimension(9), parameter :: U_ASSIGN=
     &    (/ 1, 6, 5, 6, 2, 4, 5, 4, 3 /) !< Transform linear 6 elements adp to linear 9 element adps
      double precision, dimension(3,3) :: A_M !< orthogonalisation matrix
      double precision, dimension(3,3) :: B_M !< scaling to dimensionless adp
      double precision, dimension(3,3) :: R_M !< rotation matrix with A_M and B_M
     
      type Udata_t
          double precision, dimension(6) :: U_L !< adp in linear 6 element form
          double precision, dimension(3,3) :: U_M !< adp as a 3x3 matrix
          double precision, dimension(3,3) :: RABUBAR !< adp in local cartesian coordinate space
          double precision, dimension(9,6) :: dUcart !< dU/dxx matrix where each derivative dxx is a column vector
          double precision, dimension(3,3) :: U_C !< adp in cartesian space
          double precision, dimension(3,3) :: Q !< eigenvectors
          double precision, dimension(3) :: W !< eigen values
          logical :: tobeused !< flag for unusable atoms
      end type
      type(Udata_t), dimension(:), allocatable :: Udata
      
      real :: Um_avg !< average of alls the Ugeom
      double precision rtemp

      real dump
      REAL DIFF_VAL
      REAL MEAN_VAL
      
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
      include 'XUNITS.INC'
      !include 'XSSVAL.INC'
C
      EQUIVALENCE (O,A1(1))    ! Note well
      
C
C--SET UP A FEW CONSTANTS                                        
      DUMP=STORE(LCG+4)   ! The 'observed value' of the restraint
      MCA=LCA ! address of fisrt atom

      ! Orthogonalisation matrix (stored by rows, reshape fill column wise, hence the transpose)
      A_M=transpose(reshape(STORE(L1O1:L1O1+8), (/3,3/))) ! Multiply diffvec by orthogonalisation matrix
      
      ! Ucif scaled to U*
      B_M=0.0d0
      B_M(1,1)=STORE(L1P2)
      B_M(2,2)=STORE(L1P2+1)
      B_M(3,3)=STORE(L1P2+2)
      R_M=matmul(A_M, B_M) 
      
      allocate(Udata(nca))
      JA=LCA
      Um_avg=0.0
      do icpt=1, nca ! loop over each atom

        Udata(icpt)%tobeused=.true.

        IF(ABS(STORE(ISTORE(JA+16)+6))/=0.0 ) THEN ! check if atom is isotropic
          if(present(results)) then
            WRITE(CMON,'("{E",1X, "(",I0,")",1X, A)')
     1         results%user_index, trim(results%restraint_text)
            CALL XPRVDU(NCVDU, 1,0)      
              WRITE(CMON,'("{E", 4X, A)') 
     1          'Error: not implemented on isotropic atom'
            CALL XPRVDU(NCVDU, 1,0)      
          end if
          Udata(icpt)%tobeused=.false.
        end if
      
C--DEFINE U Matrices 
        Udata(icpt)%U_L=STORE(ISTORE(JA+16)+14:ISTORE(JA+16)+14+11:2)

C     U Matrices in 3x3 matrix
        Udata(icpt)%U_M=reshape(Udata(icpt)%U_L(U_ASSIGN), (/3,3/)) 

        ! Adp in cartesian space
        Udata(icpt)%U_C=
     1    matmul(matmul(R_M, Udata(icpt)%U_M), transpose(R_M))
        ! eigen decomposition
        call DSYEVJ3(Udata(icpt)%U_C, Udata(icpt)%Q, Udata(icpt)%W,info)      
        if(info<0) then
          WRITE(CMON,'("{I", A)') 
     1      'UVOL: DSYEVJ3 failed to converged'
          CALL XPRVDU(NCVDU, 1,0)   
          Udata(icpt)%W=-1.0d0   
        end if              
        
        Udata(icpt)%U_C=
     1    matmul(matmul(R_M, Udata(icpt)%U_M), transpose(R_M))
      
        if(any(Udata(icpt)%W<0.0d0)) then
          Udata(icpt)%tobeused=.false.
        end if
                  
C Here, compute derivatives
        call rabubar_eigenderivs(Udata(icpt)%Q, Udata(icpt)%dUcart)
      
C-- RUN RABUBAR MULTIPLICATION (no need to calculate)
        Udata(icpt)%RABUBAR=0.0d0
        Udata(icpt)%RABUBAR(1,1)=Udata(icpt)%w(1)
        Udata(icpt)%RABUBAR(2,2)=Udata(icpt)%w(2)
        Udata(icpt)%RABUBAR(3,3)=Udata(icpt)%w(3)

        if(Udata(icpt)%tobeused) then
          Um_avg=Um_avg+product(Udata(icpt)%W)**(1.0d0/3.0d0)
        end if
        
        ja=istore(ja)
      end do

      Um_avg=Um_avg/real(count(Udata(:)%tobeused))
      
      ! fill in data storage
      if(count(Udata(:)%tobeused)>0) then
        if(present(results)) then
          results%short_desc=
     1      'Restraint geometric mean of all ADPs to be equal'
          results%groups=count(Udata(:)%tobeused)
          call extend(results%subrestraints, 
     1      count(Udata(:)%tobeused), .true.)

          JA=LCA
          jcpt=0
          do icpt=1, nca
            if(Udata(icpt)%tobeused) then
              jcpt=jcpt+1
              call extend(results%subrestraints(jcpt)%atoms, 1, .true.)
              results%subrestraints(jcpt)%atoms(1)%label=
     &          c_store(JA+2)
              results%subrestraints(jcpt)%atoms(1)%serial=
     &          nint(store(JA+3))
              results%subrestraints(jcpt)%description=
     &          'U_geom = <U>_geom'

              associate(r => results%subrestraints(jcpt))
                r%atoms(1)%adps_crys=Udata(icpt)%U_M
                r%atoms(1)%adps_cart=Udata(icpt)%RABUBAR
                r%atoms(1)%M=matmul(R_M,Udata(icpt)%Q)        
                r%rvalue=product(Udata(icpt)%W)**(1.0d0/3.0d0)
                r%rtarget=Um_avg
              end associate
            end if
            ja=istore(ja)
          end do      
        end if
      else 
        if(present(results)) then
          results%short_desc=
     1      'Restraint geometric mean of all ADPs to be equal'
        end if
        return
      end if
      
      JA=LCA
      do icpt=1, nca ! loop over each atom to setup restraints        
        if(.not. Udata(icpt)%tobeused) then
          if(present(results)) then
            WRITE(CMON,'("{I", 4X, A, A, A, "(",I0,")")') 
     1        'UVOL: ',
     4        ' Non positive definite adp, restraint not applied to ',
     2        trim(c_store(JA+2)),
     3        nint(store(JA+3))
            CALL XPRVDU(NCVDU, 1,0)      
          end if
          cycle
        end if

        rtemp=product(Udata(icpt)%W)**(1.0d0/3.0d0)
        DIFF_VAL=rtemp-Um_avg
        MEAN_VAL=rtemp+Um_avg
                     
        a1(7:12)=(
     1    Udata(icpt)%dUcart(1,:)*Udata(icpt)%w(2)*Udata(icpt)%w(3)+ 
     1    Udata(icpt)%dUcart(5,:)*Udata(icpt)%w(1)*Udata(icpt)%w(3)+
     1    Udata(icpt)%dUcart(9,:)*Udata(icpt)%w(1)*Udata(icpt)%w(2))/ 
     1    (3.0d0*rtemp**2)
        a1(1:6)=a1(7:12)

        JP=ISTORE(JA+6)
        JD=ISTORE(JA+16)
        JX=JP ! JX used in XADUIJ
        JO=JA ! JO used in XADUIJ
        CALL XADUIJ  

        STORE(LCG+4)=0.5*MEAN_VAL
        STORE(L22PD+2)=0.0-DIFF_VAL ! Difference between restraint target (DUMP) and computed from current parameters (D)
        STORE(L22PD+1) = STORE(LCG+3)
        CALL XFMPDQ

C--CLEAR THE P.D. SLOSTS FOR THE NEXT COORD.         
        JQ=ISTORE(JA+6)
        DO JX=1,6
          STORE(JQ+2)=0.
          JQ=ISTORE(JQ)
        end do
              
        JA=ISTORE(JA)

      end do

      RETURN
      END


CODE FOR XCVCUEQIV
!> Restrain the Ueq of 2 adps to be equal
!>
!> Ueq: <U> = 1/3 (a + b + c)
!> with a, b, c length of the principal axes (eigen values)
!>
!> The restraint is: <U_1> - <U_2> = 0
!> => (a_1 + b_1 + c_1) - (a_2 + b_2 + c_2) = 0
!> 
!> d(a_1 + b_1 + c_1) = d(a_1) + d(b_1) + d(c_1)
      SUBROUTINE XCVCUEQIV(results)
      use xssval_mod, only: issapp, issprt
      use list26_mod
      use xiobuf_mod, only:CMON
      use math_mod, only: DSYEVJ3
      use store_mod, only: store, c_store, istore=>i_store
      implicit none

      type(restraints_t), intent(inout), optional :: results

      integer :: icpt, info
      real, dimension(12) :: A1 !< Partial derivatives      
      integer, dimension(9), parameter :: U_ASSIGN=
     &    (/ 1, 6, 5, 6, 2, 4, 5, 4, 3 /) !< Transform linear 6 elements adp to linear 9 element adps
      double precision, dimension(3,3) :: A_M !< orthogonalisation matrix
      double precision, dimension(3,3) :: B_M !< scaling to dimensionless adp
      double precision, dimension(3,3) :: R_M !< rotation matrix with A_M and B_M
     
      type Udata_t
          double precision, dimension(6) :: U_L !< adp in linear 6 element form
          double precision, dimension(3,3) :: U_M !< adp as a 3x3 matrix
          double precision, dimension(3,3) :: RABUBAR !< adp in local cartesian coordinate space
          double precision, dimension(9,6) :: dUcart !< dU/dxx matrix where each derivative dxx is a column vector
          double precision, dimension(3,3) :: U_C !< adp in cartesian space
          double precision, dimension(3,3) :: Q !< eigenvectors
          double precision, dimension(3) :: W !< eigen values
          logical :: tobeused !< flag for unusable atoms
      end type
      type(Udata_t), dimension(:), allocatable :: Udata
      
      real :: Um_avg !< average of alls the Ugeom
      double precision rtemp

      real dump
      REAL DIFF_VAL
      REAL MEAN_VAL
      
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
      include 'XUNITS.INC'
      !include 'XSSVAL.INC'
C
      EQUIVALENCE (O,A1(1))    ! Note well
      
C
C--SET UP A FEW CONSTANTS                                        
      DUMP=STORE(LCG+4)   ! The 'observed value' of the restraint
      MCA=LCA ! address of fisrt atom

      if(present(results)) then
          results%short_desc=
     1      'Restraint all Ueq to be equal'
          results%groups=NCA
          call extend(results%subrestraints, NCA, .true.)
      end if  

      ! Orthogonalisation matrix (stored by rows, reshape fill column wise, hence the transpose)
      A_M=transpose(reshape(STORE(L1O1:L1O1+8), (/3,3/))) ! Multiply diffvec by orthogonalisation matrix
      
      ! Ucif scaled to U*
      B_M=0.0d0
      B_M(1,1)=STORE(L1P2)
      B_M(2,2)=STORE(L1P2+1)
      B_M(3,3)=STORE(L1P2+2)
      R_M=matmul(A_M, B_M) 
      
      allocate(Udata(nca))
      JA=LCA
      Um_avg=0.0
      do icpt=1, nca ! loop over each atom

        if(present(results)) then
          call extend(results%subrestraints(icpt)%atoms, 1, .true.)
          results%subrestraints(icpt)%atoms(1)%label=
     &      c_store(JA+2)
          results%subrestraints(icpt)%atoms(1)%serial=
     &      nint(store(JA+3))
          results%subrestraints(icpt)%description=
     &      'U_eq = <U>_eq'
        end if

        Udata(icpt)%tobeused=.true.

        IF(ABS(STORE(ISTORE(JA+16)+6))/=0.0 ) THEN ! check if atom is isotropic
          if(present(results)) then
            WRITE(CMON,'("{E",1X, "(",I0,")",1X, A)')
     1         results%user_index, trim(results%restraint_text)
            CALL XPRVDU(NCVDU, 1,0)      
              WRITE(CMON,'("{E", 4X, A)') 
     1          'Error: not implemented on isotropic atom'
            CALL XPRVDU(NCVDU, 1,0)      
          end if
          Udata(icpt)%tobeused=.false.
        end if
      
C--DEFINE U Matrices 
        Udata(icpt)%U_L=STORE(ISTORE(JA+16)+14:ISTORE(JA+16)+14+11:2)

C     U Matrices in 3x3 matrix
        Udata(icpt)%U_M=reshape(Udata(icpt)%U_L(U_ASSIGN), (/3,3/)) 

        if(present(results)) then
          results%subrestraints(icpt)%atoms(1)%adps_crys=Udata(icpt)%U_M
        end if
      
        ! Adp in cartesian space
        Udata(icpt)%U_C=
     1    matmul(matmul(R_M, Udata(icpt)%U_M), transpose(R_M))
        ! eigen decomposition
        call DSYEVJ3(Udata(icpt)%U_C, Udata(icpt)%Q, Udata(icpt)%W,info)      
        if(info<0) then
          WRITE(CMON,'("{I", A)') 
     1      'UEQIV: DSYEVJ3 failed to converged'
          CALL XPRVDU(NCVDU, 1,0)   
          Udata(icpt)%W=-1.0d0   
        end if              
        
        Udata(icpt)%U_C=
     1    matmul(matmul(R_M, Udata(icpt)%U_M), transpose(R_M))
      
        if(any(Udata(icpt)%W<0.0d0)) then
          Udata(icpt)%tobeused=.false.
        end if
                  
C Here, compute derivatives
        call rabubar_eigenderivs(Udata(icpt)%Q, Udata(icpt)%dUcart)
      
C-- RUN RABUBAR MULTIPLICATION (no need to calculate)
        Udata(icpt)%RABUBAR=0.0d0
        Udata(icpt)%RABUBAR(1,1)=Udata(icpt)%w(1)
        Udata(icpt)%RABUBAR(2,2)=Udata(icpt)%w(2)
        Udata(icpt)%RABUBAR(3,3)=Udata(icpt)%w(3)

        if(present(results)) then
          associate(r => results%subrestraints(icpt)%atoms(1))
            r%adps_cart=Udata(icpt)%RABUBAR
            r%M=matmul(R_M,Udata(icpt)%Q)
          end associate
        end if
        
        if(Udata(icpt)%tobeused) then
          Um_avg=Um_avg+sum(Udata(icpt)%W)/3.0d0
        end if
        
        ja=istore(ja)
      end do
      
      if(count(Udata(:)%tobeused)>0) then
        Um_avg=Um_avg/real(count(Udata(:)%tobeused))
      else
        WRITE(CMON,'("{I", A)') 
     1    'UEQIV: All atoms are non positive definite'
        CALL XPRVDU(NCVDU, 1,0)   
        deallocate(results%subrestraints)
        return
      end if
            
      JA=LCA
      do icpt=1, nca ! loop over each atom to setup restraints
        if(present(results)) then
          results%subrestraints(icpt)%rvalue=sum(Udata(icpt)%W)/3.0d0
          results%subrestraints(icpt)%rtarget=Um_avg
        end if
        
!        if(any(Udata(icpt)%W<0.0)) then
!          if(present(results)) then
!            WRITE(CMON,'("{I", 4X, A, A, A, "(",I0,")")') 
!     1        'UVOL: ',
!     4        ' Non positive definite adp, restraint not applied to ',
!     2        trim(results%subrestraints(icpt)%atoms(1)%label),
!     3        results%subrestraints(icpt)%atoms(1)%serial
!            CALL XPRVDU(NCVDU, 1,0)      
!          end if
!          cycle
!        end if
      
        rtemp=sum(Udata(icpt)%W)/3.0d0
        DIFF_VAL=rtemp-Um_avg
        MEAN_VAL=rtemp+Um_avg
                     
        a1(7:12)=Udata(icpt)%dUcart(1,:) + 
     1    Udata(icpt)%dUcart(5,:) + Udata(icpt)%dUcart(9,:)
        a1(7:12)=1.0/3.0*a1(7:12)
        a1(1:6)=a1(7:12)

        JP=ISTORE(JA+6)
        JD=ISTORE(JA+16)
        JX=JP ! JX used in XADUIJ
        JO=JA ! JO used in XADUIJ
        CALL XADUIJ  

        STORE(LCG+4)=0.5*MEAN_VAL
        STORE(L22PD+2)=0.0-DIFF_VAL ! Difference between restraint target (DUMP) and computed from current parameters (D)
        STORE(L22PD+1) = STORE(LCG+3)
        CALL XFMPDQ

C--CLEAR THE P.D. SLOSTS FOR THE NEXT COORD.         
        JQ=ISTORE(JA+6)
        DO JX=1,6
          STORE(JQ+2)=0.
          JQ=ISTORE(JQ)
        end do
              
        JA=ISTORE(JA)

      end do

      RETURN

      END

C
CODE FOR XCVCX
      SUBROUTINE XCVCX(iaxis,iasym)
      use xssval_mod, only: issapp, issprt
      use store_mod, only: c_store
      implicit none
C--CALCULATE VIBRATION RESTRAINTS
C
C      IAXIS = 1 FOR XZ COVARIANCE
C      IAXIS = 2 FOR YZ COVARIANCE
C      IAXIS = 3 FOR ZZ VARIANCE
C
C      IASYM = 1 FOR ASYMMETRIC OTHERWISE 0
C
C--THE VARIABLES IN 'XWORK' ARE USED AS FOLLOWS :
C
C  P  DU(B)/DU(22)
C  .
C  .
C  T  DU(B)/DU(12)
C
C--SUBSEQUENTLY O TO T ARE USED FOR THE DIFFERENCES BETWEEN THE
C  THE TWO VALUES OF EACH VIBRATION PARAMETER
C
C--
      INCLUDE 'ISTORE.INC'
C
      integer :: iaxis, iasym
      real, dimension(12) :: A1 !< Partial derivatives
      double precision, dimension(3) :: ROT1, ROT2, ROT3 !< Cartesian axes
      double precision, dimension(3) :: ANAXIS, DIFF_VEC !< temp variables to calculates axes
      
      double precision U_L_1(6), U_L_2(6) !< adp in linear 6 element form
      integer, dimension(9), parameter :: U_ASSIGN=
     &    (/ 1, 6, 5, 6, 2, 4, 5, 4, 3 /) !< Transform linear 6 elements adp to linear 9 element adps
      double precision U_M_1(3,3), U_M_2(3,3) !< adp as a 3x3 matrix
      double precision R_M(3,3) !< rotation matrix
      double precision RAB(3,3) !< full transformation matrix
      double precision RABUBAR_1(3,3) !< adp in local cartesian coordinate space
      double precision RABUBAR_2(3,3) !< adp in local cartesian coordinate space
      double precision, dimension(3,3) :: A_M !< orthogonalisation matrix
      double precision dUcart(9,6) !< dU/dxx matrix where each derivative dxx is a column vector
      double precision vangl

      REAL CHECK_CAL_1
      REAL CHECK_CAL_2
      REAL DIFF_VAL
      REAL MEAN_VAL
      real dump
      
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
      include 'XUNITS.INC'
      !include 'XSSVAL.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (O,A1(1))    ! Note well
      
C
C--SET UP A FEW CONSTANTS                                        
      DUMP=STORE(LCG+4)   ! The 'observed value' of the restraint
      JA=LCA              ! Address of first parameter block header                                      
      NCA=2 ! number of atom to treat
      MCA=JA ! address of first atom
C--SET UP THE ADDRESSES OF THE ATOMS                                    
      JB=ISTORE(JA)             ! Address of next parameter block                                        
      JP=ISTORE(JA+6)           ! Address of first parameter (U11) for atom 1                                        
      JV=ISTORE(JB+6)           ! Address of first parameter (U11) for atom 2                                        

      if(issprt==0) then
          write(ncwu, *) ''
          write(ncwu, 
     &       '(A,A,"(",I0,") -- ",A,"(",I0,"), args: ",I0,1X,I0)') 
     &       "U??BAR: XCVCX ",
     &       trim(c_store(JA+2)), nint(store(JA+3)), 
     &       trim(c_store(JB+2)), nint(store(JB+3)),
     &       iaxis,iasym
      end if
C--DEFINE U Matrices 

      U_L_1=STORE(ISTORE(JA+16)+14:ISTORE(JA+16)+14+11:2)
      U_L_2=STORE(ISTORE(JB+16)+14:ISTORE(JB+16)+14+11:2)
      
C     U Matrices in 3x3 matrix
      U_M_1=reshape(U_L_1(U_ASSIGN), (/3,3/)) 
      U_M_2=reshape(U_L_2(U_ASSIGN), (/3,3/))
      
      if(issprt==0) then
          write(ncwu, '(1X, A, A,"(",I0,")", 32X, A, A,"(",I0,")")')
     &        'Adp 1:',
     &        trim(c_store(JA+2)), nint(store(JA+3)),
     &        'Adp 2:', 
     &        trim(c_store(JB+2)), nint(store(JB+3))
          do i=1, 3
              write(ncwu, '(3(E10.3,1X), 10X, 3(E10.3,1X))') 
     &            U_M_1(i,:), U_M_2(i,:)
          end do
      end if
      
C-- Set up the new coordinate system for the adp
C-----------------------------------------------

C--CALCULATE THE INTERNUCLEAR DISTANCE                                  
      JO=JA  
      JS=JB  
      JQ=ISTORE(JO+16)
      JU=ISTORE(JS+16)

C Here is the interatomic vector in crystal fractions:    
      DIFF_VEC(1)=STORE(JQ+8)-STORE(JU+8)
      DIFF_VEC(2)=STORE(JQ+10)-STORE(JU+10)
      DIFF_VEC(3)=STORE(JQ+12)-STORE(JU+12)

      ANAXIS = (/1.0d0, 0.0d0, 0.0d0/)
      
c      print *, "Pre-Norm Pre-Orth Bond Vec"
c      print *, A, B, C
c      print *,   
      
      ! Orthogonalisation matrix (stored by rows, reshape fill column wise, hence the transpose)
      A_M=transpose(reshape(STORE(L1O1:L1O1+8), (/3,3/))) ! Multiply diffvec by orthogonalisation matrix
      ROT3=matmul(A_M, DIFF_VEC)
c      print *, "Pre-Norm Orth Bond Vec"
c      print *, (ROT3(I), I=1,3)
c      print *,
      CALL DNORM3(ROT3) !Normalise
C Take cross product with x axis (unless angle is too close to zero, in which case, use y.

      VANGL = dot_product(ROT3, ANAXIS)   ! Dot product to get angle
      IF (ABS(VANGL) .GT. 0.95d0) THEN  ! Almost parallel, use y-axis instead.
c         print *, "Bond // to x-axis"
          ANAXIS = (/0.0d0, 1.0d0, 0.0d0/)
      END IF
       
      ! NCROP3 = normalised cross product
      CALL DNCROP3(ROT3, ANAXIS, ROT2)  !Axis 2 perp to 3 and X-axis (or y if too close to x)
      CALL DNORM3(ROT2) !Normalise
      CALL DNCROP3(ROT2, ROT3, ROT1)   ! Axis 1 perp to 2 an 3.
      CALL DNORM3(ROT1) !Normalise
       
      ! rotation matrix from basis vectors
      R_M(1,:)=rot1
      R_M(2,:)=rot2
      R_M(3,:)=rot3

C Here, compute derivatives
C IF IAXIS = 1, then UXZBAR, =2 for UYZBAR, IAXIS = 3 for UZZBAR
C-----------------------------------------------

      call rabubar_derivs(R_M, RAB, dUcart)
            
      IF ( IAXIS .EQ. 1 ) THEN   !UXZBAR
C      #### XZ DERIVS ####
          ! (1,3) -> 3
          a1(7:12)=dUcart(3,:)
          
      ELSE IF ( IAXIS .EQ. 2) THEN  !UYZBAR
C      #### YZ DERIVS ####
          ! (2,3) -> 8
          a1(7:12)=dUcart(8,:)
     
      ELSE   !UZZBAR
C      ##### ZZ DERIVS ####
          ! (3,3) -> 9
          a1(7:12)=dUcart(9,:)
      END IF

C First atom of the restraint                
C-----------------------------------------------
      a1(1:6)=a1(7:12) 
C--CHECK IF THE ATOM IS ANISO                                           
      JP=ISTORE(JA+6)
      JD=ISTORE(JA+16)
      JX=JP ! JX used in XADUIJ
      JO=JA ! JO used in XADUIJ
      IF(ABS(STORE(JD+6)) .gt. zero) THEN
C--'ISO' ATOM  -  MODIFY THE ENTRY IN THE COORDINATE SECTION            
         ISTORE(JA+5)=4         ! Reduce the number of restrained parameters to x,y,z,iso
         ISTORE(JP)=-1000000    ! Remove link to next parameter (U22- there isn't one)                                     
         ISTORE(JP+1)=8         ! Where they start 
C--SET THE EQUIVALENT ANISO TEMPERATURE FACTORS FOR THE ATOM
         JE=JD
         JF=L1C+2                                                       
         DO J=L1C,JF                                                  
            STORE(JE+14)=STORE(JD+14)
            STORE(JE+20)=STORE(JD+14)*STORE(J)                        
            JE=JE+2                                                   
         END DO
         STORE(JD+6)=0.
         
         STORE(JP+2)=STORE(JP+2)+A1(1)+A1(2)+A1(3)+A1(4)*STORE(L1C)+
     2      A1(5)*STORE(L1C+1)+A1(6)*STORE(L1C+2)         
      else 
         if (iasym==1) then
c           dont restrain first atom
c            print *, "Asym"
            a1(1:6) = 0.0
         endif      
         CALL XADUIJ  
      END IF

C Second atom of the restraint                
C-----------------------------------------------
      a1(1:6)=-a1(7:12) 
C--CHECK IF THE ATOM IS ANISO                                           
      JP=ISTORE(JB+6)
      JD=ISTORE(JB+16)
      JX=JP ! JX used in XADUIJ
      JO=JB ! JO used in XADUIJ
      IF(ABS(STORE(JD+6)) .gt. zero) THEN
C--'ISO' ATOM  -  MODIFY THE ENTRY IN THE COORDINATE SECTION            
         ISTORE(JB+5)=4         ! Reduce the number of restrained parameters to x,y,z,iso
         ISTORE(JP)=-1000000    ! Remove link to next parameter (U22- there isn't one)                                     
         ISTORE(JP+1)=8         ! Where they start 
C--SET THE EQUIVALENT ANISO TEMPERATURE FACTORS FOR THE ATOM
         JE=JD
         JF=L1C+2                                                       
         DO J=L1C,JF                                                  
            STORE(JE+14)=STORE(JD+14)
            STORE(JE+20)=STORE(JD+14)*STORE(J)                        
            JE=JE+2                                                   
         END DO
         STORE(JD+6)=0.
         
         STORE(JP+2)=STORE(JP+2)+A1(1)+A1(2)+A1(3)+A1(4)*STORE(L1C)+
     2      A1(5)*STORE(L1C+1)+A1(6)*STORE(L1C+2)         
      else 
         CALL XADUIJ  
      end if                          

C-- RUN RABUBAR MULTIPLICATION

      RABUBAR_1=matmul(rab, matmul(U_M_1, transpose(rab)))
      RABUBAR_2=matmul(rab, matmul(U_M_2, transpose(rab)))
         
C--CALCULATE THE MEAN VALUE AND THE DIFFERENCE                          CVC01190
         
      CHECK_CAL_1 = RABUBAR_1(iaxis, 3)
      CHECK_CAL_2 = RABUBAR_2(iaxis, 3)

      DIFF_VAL = CHECK_CAL_1 - CHECK_CAL_2       
      MEAN_VAL = (CHECK_CAL_1 + CHECK_CAL_2)/2 
             
      if(issprt==0) then
          write(ncwu, '(1X, A)') 'RAB rotation matrix'
          do i=1, 3
              write(ncwu, '(3(E10.3, 1X))') rab(i,:)
          end do
             
          write(ncwu, '(1X, A, 6(E10.3, 1X))') 'Derivatives: ', a1(7:12)

          write(ncwu, '(1X, A, 34X, A)') 'RABUBAR 1', 'RABUBAR 2'
          do i=1, 3
              write(ncwu, '(3(E10.3,1X), 10X, 3(E10.3,1X))') 
     &            RABUBAR_1(i,:), RABUBAR_2(i,:)
          end do
          write(ncwu, '(A, E10.3)') 'Delta: ', DIFF_VAL  
          write(ncwu, '(A, E10.3)') 'Mean: ', MEAN_VAL   
          write(ncwu, *) ''
      end if
         
C Here, you need to set D to be the computed value of the difference in the covariances
C Note that DUMP is the target difference (and should usually be zero).
C You need to set SUM to be the compute

      STORE(LCG+4)=0.5*(DUMP+MEAN_VAL)                                       CVC01320
      STORE(L22PD+2)=DUMP-DIFF_VAL ! Difference between restraint target (DUMP) and computed from current parameters (D)
      STORE(L22PD+1) = STORE(LCG+3)                                     CVC01510
      CALL XFMPDQ                                                       CVC01520
      JA=ISTORE(JB)                                                     CVC01530

      IF(JA .GT. 0) then
c         print *, 'No more atom expected'
         call abort()
      end if

      RETURN
      END
      

CODE FOR XCVCV
!> Restrain ADP perpendicular to a bond or a plane
      SUBROUTINE XCVCV(results)
      use list26_mod
      use xiobuf_mod, only:cmon
      use store_mod, only: store, istore=>i_store, c_store
C--CALCULATE PERPENDICULAR RESTRAINTS
C
C--THE VARIABLES IN 'XWORK' ARE USED AS FOLLOWS :
C
C  P  DU(B)/DU(22)
C  .
C  .
C  T  DU(B)/DU(12)
C
C--SUBSEQUENTLY O TO T ARE USED FOR THE DIFFERENCES BETWEEN THE
C  THE TWO VALUES OF EACH VIBRATION PARAMETER
C
C--
C
      type(restraints_t), intent(inout), optional :: results
      DIMENSION A1(12)
      double precision ROT3(3)
      double precision ROT2(3)
      double precision ROT1(3)
      double precision ANAXIS(3)
      double precision DIFF_VEC(3)
      double precision DIFF_VEC1(3), DIFF_VEC2(3)
      
      double precision U_L_1(6)
C      DIMENSION U_L_2(6)
      integer U_ASSIGN (9)
      double precision U_M_1(3,3)
C      DIMENSION U_M_2(3,3)
      double precision A_M(3,3)      
      double precision R_M(3,3)
      double precision RAB(3,3)
C      DIMENSION UBAR_2(3,3)
      double precision RABUBAR_1(3,3)
C      DIMENSION RABUBAR_2(3,3)
      double precision dUcart(9,6) ! dU/dxx matrix where each derivative dxx is a column vector 

C      REAL CHECK_CAL_1
C      REAL CHECK_CAL_2
      REAL DIFF_VAL
      REAL MEAN_VAL
      
C
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
      include 'XUNITS.INC'
      include 'XSSVAL.INC'
C
      EQUIVALENCE (O,A1(1))    ! Note well
      
      integer icpt, uperptype
C
C--SET UP A FEW CONSTANTS                                        
      uperptype=ISTORE(LCG+4)   ! Type of restraint, perp to a bond (2) or perp to a plane (3)
      JA=LCA              ! Address of first parameter block header                                      
      MCA=JA ! address of fisrt atom
      
      if(uperptype<2 .or. uperptype>3) then
         WRITE (CMON,'(a,I0)') '{E Corrupted uperp restraint ',uperptype
         CALL XPRVDU (NCVDU,1,0)
         return
      end if
      
      if(present(results)) then
          if(uperptype==2) then
            results%short_desc='Restrain an ADP perpendicular to a bond'
          else
            results%short_desc='Restrain an ADP perpendicular to'//
     1        ' the bissector of two bonds'
          end if
          results%groups=NCA/uperptype
          call extend(results%subrestraints, NCA/uperptype*2, .true.)
      end if  
      
      ! Orthogonalisation matrix (stored by rows, reshape fill column wise, hence the transpose)
      A_M=transpose(reshape(STORE(L1O1:L1O1+8), (/3,3/))) ! Multiply diffvec by orthogonalisation matrix
      
      JA=LCA
      do icpt=1, nca/uperptype ! loop over each atom
        JB=istore(ja)
        if(uperptype==3) then
          jc=istore(jb)
        else 
          jc=-1
        end if

        if(present(results)) then
          do jcpt=1, 2
            call extend(results%subrestraints((icpt-1)*2+jcpt)%atoms, 
     &        uperptype, .true.)
            results%subrestraints((icpt-1)*2+jcpt)%atoms(1)%label=
     &        c_store(JA+2)
            results%subrestraints((icpt-1)*2+jcpt)%atoms(1)%serial=
     &        nint(store(JA+3))
            results%subrestraints((icpt-1)*2+jcpt)%atoms(2)%label=
     &        c_store(JB+2)
            results%subrestraints((icpt-1)*2+jcpt)%atoms(2)%serial=
     &        nint(store(JB+3))
            if(uperptype==3) then
              results%subrestraints((icpt-1)*2+jcpt)%atoms(3)%label=
     &          c_store(JC+2)
              results%subrestraints((icpt-1)*2+jcpt)%atoms(3)%serial=
     &          nint(store(JC+3))
            end if
          end do
        end if
      
        U_L_1=STORE(ISTORE(JA+16)+14:ISTORE(JA+16)+14+11:2)
      
C       U Matrices in 3x3 matrix
        U_ASSIGN = (/ 1, 6, 5, 6, 2, 4, 5, 4, 3 /)
        U_M_1=reshape(U_L_1(U_ASSIGN), (/3,3/)) 
        if(present(results)) then
          do jcpt=1, 2
            results%subrestraints((icpt-1)*2+jcpt)%
     &        atoms(1)%adps_crys=U_M_1
          end do
        end if
            
C-- Set up the new coordinate system for the adp
C-----------------------------------------------

        if(uperptype==2) then
C--CALCULATE THE INTERNUCLEAR DISTANCE                                  
          JO=JA  
          JS=JB  
          JQ=ISTORE(JO+16)
          JU=ISTORE(JS+16)

C Here is the interatomic vector in crystal fractions:    
          DIFF_VEC(1)=STORE(JQ+8)-STORE(JU+8)
          DIFF_VEC(2)=STORE(JQ+10)-STORE(JU+10)
          DIFF_VEC(3)=STORE(JQ+12)-STORE(JU+12)

          ANAXIS = (/1.0d0, 0.0d0, 0.0d0/)
      
          ROT3=matmul(A_M, DIFF_VEC)
          CALL DNORM3(ROT3) !Normalise
C Take cross product with x axis (unless angle is too close to zero, in which case, use y.

          VANGL = dot_product(ROT3, ANAXIS)      ! Dot product to get angle
           IF (ABS(VANGL) .GT. 0.95) THEN  ! Almost parallel, use y-axis instead.
c           print *, "Bond // to x-axis"
            ANAXIS = (/0.0d0, 1.0d0, 0.0d0/)
          END IF
       
          CALL DNCROP3(ROT3, ANAXIS, ROT2)  !Axis 2 perp to 3 and X-axis (or y if too close to x)
          CALL DNORM3(ROT2) !Normalise
          CALL DNCROP3(ROT2, ROT3, ROT1)   ! Axis 1 perp to 2 an 3.
          CALL DNORM3(ROT1) !Normalise
          
        else
C--CALCULATE THE INTERNUCLEAR DISTANCE                                  
          JO=JA  
          JS=JB  
          JQ=ISTORE(JO+16)
          JU=ISTORE(JS+16)
          JW=ISTORE(JC+16)

C Here is the interatomic vector in crystal fractions:    
          DIFF_VEC1(1)=STORE(JQ+8)-STORE(JU+8)
          DIFF_VEC1(2)=STORE(JQ+10)-STORE(JU+10)
          DIFF_VEC1(3)=STORE(JQ+12)-STORE(JU+12)

          DIFF_VEC2(1)=STORE(JQ+8)-STORE(JW+8)
          DIFF_VEC2(2)=STORE(JQ+10)-STORE(JW+10)
          DIFF_VEC2(3)=STORE(JQ+12)-STORE(JW+12)
            
          ROT1=matmul(A_M, DIFF_VEC1)
          ROT2=matmul(A_M, DIFF_VEC2)
          CALL DNORM3(ROT1) !Normalise
          CALL DNORM3(ROT2) !Normalise
          ROT3=ROT1+ROT2
          CALL DNORM3(ROT3) !Normalise

          ANAXIS = (/1.0d0, 0.0d0, 0.0d0/)
          VANGL = dot_product(ROT3, ANAXIS)      ! Dot product to get angle
          IF (ABS(VANGL) .GT. 0.95) THEN  ! Almost parallel, use y-axis instead.
c         print *, "Bond // to x-axis"
            ANAXIS = (/0.0d0, 1.0d0, 0.0d0/)
          END IF
       
          CALL DNCROP3(ROT3, ANAXIS, ROT2)  !Axis 2 perp to 3 and X-axis (or y if too close to x)
          CALL DNORM3(ROT2) !Normalise
          CALL DNCROP3(ROT2, ROT3, ROT1)   ! Axis 1 perp to 2 an 3.
          CALL DNORM3(ROT1) !Normalise
        end if
       
        ! rotation matrix from basis vectors
        R_M(1,:)=rot1
        R_M(2,:)=rot2
        R_M(3,:)=rot3
          
        call rabubar_derivs(R_M, RAB, dUcart)
        RABUBAR_1=matmul(rab, matmul(U_M_1, transpose(rab)))
        if(present(results)) then
          do jcpt=1, 2
            results%subrestraints((icpt-1)*2+jcpt)%
     &        atoms(1)%adps_cart=RABUBAR_1
            results%subrestraints((icpt-1)*2+jcpt)%atoms(1)%M=rab
          end do
          results%subrestraints((icpt-1)*2+1)%description='Uc[1,3]==0'
          results%subrestraints((icpt-1)*2+1)%rvalue=RABUBAR_1(1,3)
          results%subrestraints((icpt-1)*2+1)%rtarget=0.0
          results%subrestraints((icpt-1)*2+2)%description='Uc[2,3]==0'
          results%subrestraints((icpt-1)*2+2)%rvalue=RABUBAR_1(2,3)
          results%subrestraints((icpt-1)*2+2)%rtarget=0.0
        end if
      
        do i=1, 2
      
          IF ( i==1 ) THEN   
C       #### XZ DERIVS ####
            ! (1,3) -> 3
            a1(7:12)=dUcart(3,:)
          ELSE
C      #### YZ DERIVS ####
            ! (2,3) -> 8
            a1(7:12)=dUcart(8,:)
          END IF

          a1(1:6)=a1(7:12)
      
C First atom of the restraint        
C The second atom is just used to define the basis        
C-----------------------------------------------
          JP=ISTORE(JA+6)
          JD=ISTORE(JA+16)
          JX=JP ! JX used in XADUIJ
          JO=JA ! JO used in XADUIJ
          CALL XADUIJ  

C--CALCULATE THE MEAN VALUE AND THE DIFFERENCE                          CVC01190
          IF  ( i==1 ) THEN          
             DIFF_VAL = RABUBAR_1(1,3)
             MEAN_VAL = RABUBAR_1(1,3) 
          ELSE
             DIFF_VAL = RABUBAR_1(2,3)
             MEAN_VAL = RABUBAR_1(2,3) 
          END IF
                          
C Here, you need to set D to be the computed value of the difference in the covariances
C Note that DUMP is the target difference (and should usually be zero).
C You need to set SUM to be the compute

          DUMP = 0.0  ! All Uperp restraints have zero as a target for each component.
          STORE(LCG+4)=0.5*(DUMP+MEAN_VAL)                                       CVC01320
          STORE(L22PD+2)=DUMP-DIFF_VAL ! Difference between restraint target (DUMP) and computed from current parameters (D)
          STORE(L22PD+1) = STORE(LCG+3)                                     CVC01510
          CALL XFMPDQ                                                       CVC01520

C--CLEAR THE P.D. SLOSTS FOR THE NEXT COORD.         
          JQ=ISTORE(JA+6)
          DO JX=1,6
            STORE(JQ+2)=0.
            JQ=ISTORE(JQ)
          end do

        end do
      
        if(uperptype==3) then 
          JA=ISTORE(JC)
        else
          JA=ISTORE(JB)
        end if
      end do

      END
      
C
C
CODE FOR XCVCY
      SUBROUTINE XCVCY(iaxis,iasym)
      use xssval_mod, only: issapp, issprt
      use store_mod, only: store, istore=>i_store, c_store, i_store_set
      implicit none
C--CALCULATE UEQIV RESTRAINTS
C
C      IAXIS = 1 FOR XX ALIGNMENT
C      IAXIS = 2 FOR XY ALIGNMENT
C      IAXIS = 3 FOR XZ ALIGNMENT
C      IAXIS = 4 FOR YY ALIGNMENT
C      IAXIS = 5 FOR YZ ALIGNMENT
C      IAXIS = 6 FOR ZZ ALIGNMENT
C
C      IASYM = 1 FOR ASYMMETRIC OTHERWISE 0
C
C--THE VARIABLES IN 'XWORK' ARE USED AS FOLLOWS :
C
C  P  DU(B)/DU(22)
C  .
C  .
C  T  DU(B)/DU(12)
C
C--SUBSEQUENTLY O TO T ARE USED FOR THE DIFFERENCES BETWEEN THE
C  THE TWO VALUES OF EACH VIBRATION PARAMETER
C
C--
      integer :: iaxis, iasym
      real, dimension(12) :: A1 !< Partial derivatives
      double precision, dimension(3) :: ROT1, ROT2, ROT3 !< Cartesian axes
      double precision, dimension(3) :: ANAXIS, ANORTH, DIFF_VEC !< temp variables to calculates axes
      
      double precision U_L(6) !< adp in linear 6 element form
      integer, dimension(9), parameter :: U_ASSIGN=
     &    (/ 1, 6, 5, 6, 2, 4, 5, 4, 3 /) !< Transform linear 6 elements adp to linear 9 element adps
      double precision, dimension(3,3) :: A_M !< orthogonalisation matrix
            
      type adp_t !< object holding all the infos necessary to construct the restraint
        integer atom !< index in store of the atom of the adp to restraint
        integer, dimension(3) :: basis_atoms !< atoms used to defined the basis
        integer :: U_L !< index of adps from store 
        double precision, dimension(3,3) :: U_M !< adps in 2D matrix form
        double precision, dimension(3,3) :: R_M !< rotation matrix
        double precision, dimension(3,3) :: RAB !< transformation matrix from crystal to user defined basis
        double precision, dimension(3,3) :: RABUBAR !< adp in the user defined basis
        double precision, dimension(9,6) :: dUcart !< dU/dxx matrix where each derivative dxx is a column vector
      end type
      type(adp_t), dimension(2) :: adps

      REAL DIFF_VAL
      REAL MEAN_VAL
      real dump
      
      integer ij, ik
C
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
      include 'XUNITS.INC'
C
      EQUIVALENCE (O,A1(1))    ! Note well
C
      interface
          subroutine DNCROP3(A,B,C)
              double precision A(3),B(3),C(3)
          end subroutine
      end interface

      interface
          subroutine DNORM3(A)
              double precision A(3)
          end subroutine
      end interface
C--SET UP A FEW CONSTANTS                                        
      DUMP=STORE(LCG+4)   ! The 'observed value' of the restraint
c     print *, 'lca', lca
      JA=LCA              ! Address of first parameter block header                                      
      NCA=2                                                             
      MCA=JA ! address of the first atom
C--SET UP THE ADDRESSES OF THE ATOMS                                    

      ! data stored as: atom1 atom2 y1 z1 y2 z2
      adps(1)%atom=JA
      adps(2)%atom=ISTORE(JA)
      adps(1)%U_L=ISTORE(adps(1)%atom+16)+14
      adps(2)%U_L=ISTORE(adps(2)%atom+16)+14

      DO ij=1,2
         JD=ISTORE(adps(ij)%atom+16)   !Address of atom in L5
         JX=ISTORE(adps(ij)%atom+6)
C--CHECK IF THE ATOM IS ANISO                                           
         IF(ABS(STORE(JD+6)) .gt. zero) THEN
C--'ISO' ATOM  -  MODIFY THE ENTRY IN THE COORDINATE SECTION            
            call i_store_set(adps(1)%atom+5, 4)         ! Reduce the number of restrained parameters to x,y,z,iso
            call i_store_set(JX, -1000000)    ! Remove link to next parameter (U22- there isn't one)                                     
            call i_store_set(JX+1, 8)         ! Where they start 
C--SET THE EQUIVALENT ANISO TEMPERATURE FACTORS FOR THE ATOM
            DO i=0,2                                                  
               STORE(adps(1)%U_L+i*2)=STORE(adps(1)%U_L)
               STORE(adps(1)%U_L+i*2+6)=STORE(adps(1)%U_L)*STORE(L1C+i)                        
            END DO
            STORE(JD+6)=0.
         END IF
      end do
      
      adps(1)%basis_atoms(1)=adps(1)%atom
      adps(1)%basis_atoms(2)=ISTORE(adps(2)%atom)
      adps(1)%basis_atoms(3)=ISTORE(adps(1)%basis_atoms(2))
      adps(2)%basis_atoms(1)=adps(2)%atom
      adps(2)%basis_atoms(2)=ISTORE(adps(1)%basis_atoms(3))
      adps(2)%basis_atoms(3)=ISTORE(adps(2)%basis_atoms(2))

      do ij=1, 2
          do ik=0, 5
              U_L(ik+1)=store(adps(ij)%U_L+ik*2)
          end do
                            
          adps(ij)%U_M=reshape(U_L(U_ASSIGN), (/3,3/))
      end do
      
      if(issprt==0) then
          write(ncwu, *) ''
          write(ncwu, 
     &       '(A,A,"(",I0,") -- ",A,"(",I0,"), args: ",I0,1X,I0)') 
     &       "U??QIV: XCVCY ",
     &       trim(c_store(adps(1)%atom+2)), 
     &       nint(store(adps(1)%atom+3)), 
     &       trim(c_store(adps(2)%atom+2)), 
     &       nint(store(adps(2)%atom+3)),
     &       iaxis,iasym
      end if
      
      if(issprt==0) then
          write(ncwu, '(1X, A, A,"(",I0,")", 32X, A, A,"(",I0,")")')
     &        'Adp 1:',
     &        trim(c_store(adps(1)%atom+2)), 
     &        nint(store(adps(1)%atom+3)),
     &        'Adp 2:', 
     &        trim(c_store(adps(2)%atom+2)), 
     &        nint(store(adps(2)%atom+3))
          do i=1, 3
              write(ncwu, '(3(E10.3,1X), 10X, 3(E10.3,1X))') 
     &            adps(1)%U_M(i,:), adps(2)%U_M(i,:)
          end do
      end if

            
      ! Orthogonalisation matrix (stored by rows, reshape fill column wise, hence the transpose)
      A_M=transpose(reshape(STORE(L1O1:L1O1+8), (/3,3/))) 
      do ij=1, 2
      
          do ik=0,2
              DIFF_VEC(ik+1)=
     &            store(istore(adps(ij)%basis_atoms(1)+16)+8+ik*2)-
     &            store(istore(adps(ij)%basis_atoms(2)+16)+8+ik*2)     
          end do

          do ik=0,2
              ANAXIS(ik+1)=
     &            store(istore(adps(ij)%basis_atoms(2)+16)+8+ik*2)-
     &            store(istore(adps(ij)%basis_atoms(3)+16)+8+ik*2)     
          end do

          ROT3=matmul(A_M, DIFF_VEC)
          ANORTH=matmul(A_M, ANAXIS)
          CALL DNORM3(ROT3) !Normalise
          CALL DNORM3(ANORTH) !Normalise
           
          CALL DNCROP3(ROT3, ANORTH, ROT2)  !Axis 2 perp to 3 and X-axis
          CALL DNORM3(ROT2) !Normalise
          CALL DNCROP3(ROT2, ROT3, ROT1)   ! Axis 1 perp to 2 an 3.
          CALL DNORM3(ROT1) !Normalise

          ! rotation matrix
          adps(ij)%R_M(1,:)=rot1
          adps(ij)%R_M(2,:)=rot2
          adps(ij)%R_M(3,:)=rot3

C The orthog matrix. It is an upper triangle assuming fortran column ordering. 
C (i.e. offsets +1 +2 +5 are zero).
C Derivatives go here. These values (iaxis*n) are currently just used for testing.


C Here, compute

C IF IAXIS = 1, then UXZBAR, =2 for UYZBAR, IAXIS = 3 for UZZBAR


          call rabubar_derivs(adps(ij)%R_M, adps(ij)%RAB, 
     &       adps(ij)%dUcart) 
      
          adps(ij)%RABUBAR=matmul(matmul(adps(ij)%RAB, adps(ij)%U_M), 
     &        transpose(adps(ij)%rab))
      
          IF ( IAXIS .EQ. 1 ) THEN   !UXXQIV
C      #### XX DERIVS ####
              ! (1,1) -> 1
              a1(7:12)=adps(ij)%dUcart(1,:)
              
          ELSE IF ( IAXIS .EQ. 2) THEN  !UXYQIV
C      #### XY DERIVS ####
              ! (1,2) -> 4
              a1(7:12)=adps(ij)%dUcart(4,:)
         
          ELSE IF ( IAXIS .EQ. 3) THEN  !UXZQIV
C      #### XZ DERIVS ####
              ! (1,3) -> 7
              a1(7:12)=adps(ij)%dUcart(7,:)
         
          ELSE IF ( IAXIS .EQ. 4) THEN  !UYYQIV
C      #### YY DERIVS ####
              ! (2,2) -> 5
              a1(7:12)=adps(ij)%dUcart(5,:)
         
          ELSE IF ( IAXIS .EQ. 5) THEN  !UYZBAR
C      #### YZ DERIVS ####
              ! (2,3) -> 8          
              a1(7:12)=adps(ij)%dUcart(8,:)
         
            ELSE   !UZZQIV
C      ##### ZZ DERIVS ####
              ! (3,3) -> 9
              a1(7:12)=adps(ij)%dUcart(9,:)
          END IF
          
          if(ij==1) then
              a1(1:6)=a1(7:12)
          else
              a1(1:6)=-a1(7:12)
          end if
C-----------------------------------------------
C--CHECK IF THE ATOM IS ANISO                                           
          JP=ISTORE(adps(ij)%atom+6)
          JD=ISTORE(adps(ij)%atom+16)
          JX=JP ! JX used in XADUIJ
          JO=JA ! JO used in XADUIJ
          IF(ABS(STORE(JD+6)) .gt. zero) THEN
C--'ISO' ATOM  -  MODIFY THE ENTRY IN THE COORDINATE SECTION            
             call i_store_set(adps(ij)%atom+5, 4)         ! Reduce the number of restrained parameters to x,y,z,iso
             call i_store_set(JP, -1000000)    ! Remove link to next parameter (U22- there isn't one)                                     
             call i_store_set(JP+1, 8)         ! Where they start 
C--SET THE EQUIVALENT ANISO TEMPERATURE FACTORS FOR THE ATOM
             JE=JD
             JF=L1C+2                                                       
             DO l=L1C,JF                                                  
                STORE(JE+14)=STORE(JD+14)
                STORE(JE+20)=STORE(JD+14)*STORE(l)                        
                JE=JE+2                                                   
             END DO
             STORE(JD+6)=0.
             
             STORE(JP+2)=STORE(JP+2)+A1(1)+A1(2)+A1(3)+A1(4)*STORE(L1C)+
     2          A1(5)*STORE(L1C+1)+A1(6)*STORE(L1C+2)         
          else 
             if (iasym==1) then
c           dont restrain first atom
c            print *, "Asym"
                 a1(1:6) = 0.0
             endif      
             CALL XADUIJ  
          END IF
      
      end do
   
C--CALCULATE THE MEAN VALUE AND THE DIFFERENCE                          CVC01190      
         IF ( IAXIS .EQ. 1 ) THEN
             DIFF_VAL = adps(1)%rabubar(1,1) - adps(2)%rabubar(1,1)
             MEAN_VAL = adps(1)%rabubar(1,1) + adps(2)%rabubar(1,1)
         ELSE IF ( IAXIS .EQ. 2 ) THEN
             DIFF_VAL = adps(1)%rabubar(1,2) - adps(2)%rabubar(1,2)
             MEAN_VAL = adps(1)%rabubar(1,2) + adps(2)%rabubar(1,2)
         ELSE IF ( IAXIS .EQ. 3 ) THEN
             DIFF_VAL = adps(1)%rabubar(1,3) - adps(2)%rabubar(1,3)
             MEAN_VAL = adps(1)%rabubar(1,3) + adps(2)%rabubar(1,3)
         ELSE IF ( IAXIS .EQ. 4 ) THEN
             DIFF_VAL = adps(1)%rabubar(2,2) - adps(2)%rabubar(2,2)
             MEAN_VAL = adps(1)%rabubar(2,2) + adps(2)%rabubar(2,2)
         ELSE IF ( IAXIS .EQ. 5 ) THEN
             DIFF_VAL = adps(1)%rabubar(2,3) - adps(2)%rabubar(2,3)
             MEAN_VAL = adps(1)%rabubar(2,3) + adps(2)%rabubar(2,3)
         ELSE
             DIFF_VAL = adps(1)%rabubar(3,3) - adps(2)%rabubar(3,3)
             MEAN_VAL = adps(1)%rabubar(3,3) + adps(2)%rabubar(3,3)
         END IF

         STORE(LCG+4)=0.5*(DUMP+MEAN_VAL)                                       CVC01320
c        print *, 'L22PD saved', l22pd, ' Dump: ',DUMP
         STORE(L22PD+2)=DUMP-DIFF_VAL ! Difference between restraint target (DUMP) and computed from current parameters (D)
c        print *, 'L22PD+2 ', store(l22pd+2)
         STORE(L22PD+1) = STORE(LCG+3)                                     CVC01510
c        print *, 'L22PD+1 ', store(l22pd+1)
         CALL XFMPDQ                                                       CVC01520
c         JA=ISTORE(JB)
c         print *, 'ISTORE: ',ISTORE(JA_at6_1)                                                     CVC01530
         JA=ISTORE(adps(2)%basis_atoms(3))                                               CVC01530

      if(issprt==0) then
          write(ncwu, '(1X, A)') 'R_M rotation matrix'
          do ij=1, 3
              write(ncwu, '(3(E10.3, 1X), 10X, 3(E10.3, 1X))') 
     &            adps(1)%R_M(ij,:), adps(2)%R_M(ij,:)
          end do
          write(ncwu, '(1X, A)') 'RAB rotation matrix'
          do ij=1, 3
              write(ncwu, '(3(E10.3, 1X), 10X, 3(E10.3, 1X))') 
     &            adps(1)%rab(ij,:), adps(2)%rab(ij,:)
          end do
             
          write(ncwu, '(1X, A, 6(E10.3, 1X))') 'Derivatives1: ', 
     &        adps(1)%dUcart(ik,:)
          write(ncwu, '(1X, A, 6(E10.3, 1X))') 'Derivatives2: ', 
     &        adps(2)%dUcart(ik,:)

          write(ncwu, '(1X, A, 34X, A)') 'RABUBAR 1', 'RABUBAR 2'
          do ij=1, 3
              write(ncwu, '(3(E10.3,1X), 10X, 3(E10.3,1X))') 
     &            adps(1)%RABUBAR(ij,:), adps(2)%RABUBAR(ij,:)
          end do
          write(ncwu, '(A, E10.3)') 'Delta: ', DIFF_VAL  
          write(ncwu, '(A, E10.3)') 'Mean: ', MEAN_VAL / 2.0
          write(ncwu, *) ''
      end if

      IF(JA .GT. 0) then
c         print *, 'No more atom expected'
         call abort()
      end if

      END
    
      
C
C
CODE FOR XCVUPLANE
!> Restrain ADP to be in a plane defined by 3 atoms
      SUBROUTINE XCVUPLANE(iaxis,iasym, results)
C--CALCULATE PLANAR RESTRAINTS
C
C      IAXIS = Not used
C      IASYM = 1 FOR ASYMMETRIC OTHERWISE 0
C
C--THE VARIABLES IN 'XWORK' ARE USED AS FOLLOWS :
C
C  P  DU(B)/DU(22)
C  .
C  .
C  T  DU(B)/DU(12)
C
C--SUBSEQUENTLY O TO T ARE USED FOR THE DIFFERENCES BETWEEN THE
C  THE TWO VALUES OF EACH VIBRATION PARAMETER
C
C--
C
      use xssval_mod
      use list26_mod
      use store_mod, only: store, istore=>i_store, c_store
      implicit none

      type(restraints_t), intent(inout), optional :: results
      integer, intent(in) :: iasym
      integer, intent(in) :: iaxis
      real, dimension(12) :: A1 !< Partial derivatives
      double precision, dimension(3) :: ROT1, ROT2, ROT3 !< Cartesian axes
      double precision, dimension(3) :: ANAXIS, ANORTH, DIFF_VEC !< temp variables to calculates axes
      
      double precision U_L_1(6) !< adp in linear 6 element form
      integer, dimension(9), parameter :: U_ASSIGN=
     &    (/ 1, 6, 5, 6, 2, 4, 5, 4, 3 /) !< Transform linear 6 elements adp to linear 9 element adps
      double precision U_M_1(3,3) !< adp as a 3x3 matrix
      double precision R_M(3,3) !< rotation matrix
      double precision RAB(3,3) !< full transformation matrix
      double precision RABUBAR_1(3,3) !< adp in local cartesian coordinate space
      double precision, dimension(3,3) :: A_M !< orthogonalisation matrix
      double precision dUcart(9,6) !< dU/dxx matrix where each derivative dxx is a column vector
      REAL DIFF_VAL
      REAL MEAN_VAL
            
      integer icpt, jcpt
C
      !include 'XSSVAL.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
      include 'XUNITS.INC'
C
      EQUIVALENCE (O,A1(1))    ! Note well
C

      JA=LCA              ! Address of first parameter block header                                      
      MCA=JA ! address of fisrt atom
      
      if(present(results)) then
        results%groups=NCA/3
        results%short_desc='Restrain an ADP to be normal to a plane'
        call extend(results%subrestraints, NCA/3*2, .true.)
      end if  
      
      ! Orthogonalisation matrix (stored by rows, reshape fill column wise, hence the transpose)
      A_M=transpose(reshape(STORE(L1O1:L1O1+8), (/3,3/))) ! Multiply diffvec by orthogonalisation matrix
      
      JA=LCA
      do icpt=1, nca/3 ! loop over each atom
        JB=istore(ja)
        jc=istore(jb)

        if(present(results)) then
          do jcpt=1, 2
            call extend(results%subrestraints((icpt-1)*2+jcpt)%atoms, 
     &        3, .true.)
            results%subrestraints((icpt-1)*2+jcpt)%atoms(1)%label=
     &        c_store(JA+2)
            results%subrestraints((icpt-1)*2+jcpt)%atoms(1)%serial=
     &        nint(store(JA+3))
            results%subrestraints((icpt-1)*2+jcpt)%atoms(2)%label=
     &        c_store(JB+2)
            results%subrestraints((icpt-1)*2+jcpt)%atoms(2)%serial=
     &        nint(store(JB+3))
            results%subrestraints((icpt-1)*2+jcpt)%atoms(3)%label=
     &        c_store(JC+2)
            results%subrestraints((icpt-1)*2+jcpt)%atoms(3)%serial=
     &        nint(store(JC+3))
          end do
        end if
      
        U_L_1=STORE(ISTORE(JA+16)+14:ISTORE(JA+16)+14+11:2)
      
C       U Matrices in 3x3 matrix
        U_M_1=reshape(U_L_1(U_ASSIGN), (/3,3/)) 
        if(present(results)) then
          do jcpt=1, 2
            results%subrestraints((icpt-1)*2+jcpt)%
     &        atoms(1)%adps_crys=U_M_1
          end do
        end if
            
C-- Set up the new coordinate system for the adp
C-----------------------------------------------

C--CALCULATE THE INTERNUCLEAR DISTANCE                                  
        JQ=ISTORE(JA+16)
        JU=ISTORE(JB+16)
        JV=ISTORE(JC+16)

C Here is the interatomic vector in crystal fractions:    
         DIFF_VEC(1) = STORE(JQ+8)-STORE(JU+8)
         DIFF_VEC(2) = STORE(JQ+10)-STORE(JU+10)
         DIFF_VEC(3) = STORE(JQ+12)-STORE(JU+12)
          
         ANAXIS(1) = STORE(JU+8)-STORE(JV+8)
         ANAXIS(2) = STORE(JU+10)-STORE(JV+10)
         ANAXIS(3) = STORE(JU+12)-STORE(JV+12)
      
         ROT3=matmul(A_M, DIFF_VEC) ! Multiply diffvec by orthogonalisation matrix

        ANORTH=matmul(A_M, ANAXIS)
        CALL DNORM3(ROT3) !Normalise
        CALL DNORM3(ANORTH) !Normalise
      
C Take cross product with x axis 
         CALL DNCROP3(ROT3, ANORTH, ROT2)  !Axis 2 perp to 3 and X-axis (or y if too close to x)
         CALL DNORM3(ROT2) !Normalise
         CALL DNCROP3(ROT2, ROT3, ROT1)   ! Axis 1 perp to 2 an 3.
         CALL DNORM3(ROT1) !Normalise
                 
        ! rotation matrix from basis vectors
        R_M(1,:)=rot1
        R_M(2,:)=rot2
        R_M(3,:)=rot3
          
        call rabubar_derivs(R_M, RAB, dUcart)
        RABUBAR_1=matmul(rab, matmul(U_M_1, transpose(rab)))
        if(present(results)) then
          do jcpt=1, 2
            results%subrestraints((icpt-1)*2+jcpt)%
     &        atoms(1)%adps_cart=RABUBAR_1
            results%subrestraints((icpt-1)*2+jcpt)%atoms(1)%M=rab
          end do
          results%subrestraints((icpt-1)*2+1)%description='Uc[1,2]=0'
          results%subrestraints((icpt-1)*2+1)%rvalue=RABUBAR_1(1,2)
          results%subrestraints((icpt-1)*2+1)%rtarget=0.0
          results%subrestraints((icpt-1)*2+2)%description='Uc[2,3]=0'
          results%subrestraints((icpt-1)*2+2)%rvalue=RABUBAR_1(2,3)
          results%subrestraints((icpt-1)*2+2)%rtarget=0.0
        end if
      
        do i=1, 2
      
          IF ( i==1 ) THEN   
C       #### XZ DERIVS ####
            ! (1,2) -> 2
            a1(7:12)=dUcart(2,:)
          ELSE
C      #### YZ DERIVS ####
            ! (2,3) -> 6
            a1(7:12)=dUcart(6,:)
          END IF

          a1(1:6)=a1(7:12)
      
C First atom of the restraint        
C The second atom is just used to define the basis        
C-----------------------------------------------
          JP=ISTORE(JA+6)
          JD=ISTORE(JA+16)
          JX=JP ! JX used in XADUIJ
          JO=JA ! JO used in XADUIJ
          CALL XADUIJ  

C--CALCULATE THE MEAN VALUE AND THE DIFFERENCE                          CVC01190
          IF  ( i==1 ) THEN          
             DIFF_VAL = RABUBAR_1(1,2)
             MEAN_VAL = RABUBAR_1(1,2) 
          ELSE
             DIFF_VAL = RABUBAR_1(2,3)
             MEAN_VAL = RABUBAR_1(2,3) 
          END IF
                          
C Here, you need to set D to be the computed value of the difference in the covariances
C Note that DUMP is the target difference (and should usually be zero).
C You need to set SUM to be the compute

          STORE(LCG+4)=0.5*MEAN_VAL
          STORE(L22PD+2)=0.0-DIFF_VAL ! Difference between restraint target 0.0 and computed from current parameters (D)
          STORE(L22PD+1) = STORE(LCG+3)
          CALL XFMPDQ

C--CLEAR THE P.D. SLOSTS FOR THE NEXT COORD.         
          JQ=ISTORE(JA+6)
          DO JX=1,6
            STORE(JQ+2)=0.
            JQ=ISTORE(JQ)
          end do

        end do
      
        JA=ISTORE(JC)
      end do

      END
      
          
C
CODE FOR XCDDC
      SUBROUTINE XCDDC(iasym)
C--CALCULATE DISTANCE DIFFERENCE RESTRAINTS
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET UP THE POINTERS TO THE TOP OF THE WORK STACK
      DUMP=STORE(LCG+4)
C--FIND THE ADDRESS OF THE DISTANCE STORAGE AREA
      JH=ISTORE(LCG+2)+LC
      JI=JH
      JA=LCA
C--CALCULATE THE PARTIAL DIFFERENTIALS INITIALLY
1000  CONTINUE
      E=-1.0
      CALL XCDPD(IASYM)
C--STORE THE DISTANCE IN THE WORK STACK AREA
      STORE(JI)=D
      JI=JI+1
      JA=ISTORE(JB)
      IF(JA)1050,1050,1000
C--END OF THE FIRST PASS  -  PASS THROUGH NOW AND ACCUMULATE
1050  CONTINUE
      JI=JH
      JA=LCA
      NCA=4
1100  CONTINUE
C--NEXT DISTANCE  -  UPDATE DISTANCE AND ATOM POINTERS
      JJ=JI+1
      JB=ISTORE(JA)
      JD=ISTORE(JB)
C--REVERSE THE SIGNS OF THE DERIVATIVES FOR THE CURRENT
C  COMPARISON DISTANCE
      JP=ISTORE(JA+6)
      JQ=ISTORE(JB+6)
      DO 1150 JS=1,3
      STORE(JP+2)=-STORE(JP+2)
      STORE(JQ+2)=-STORE(JQ+2)
      JP=ISTORE(JP)
      JQ=ISTORE(JQ)
1150  CONTINUE
C--CHECK THAT THERE REMAIN AT LEAST ONE MORE DISTANCE FOR COMPARISON
      IF(JD)1350,1350,1200
C--START THE PASS THROUGH THE REMAINING DISTANCES FOR THIS COMPARISON ON
1200  CONTINUE
      MCA=JA
      JE=JD
1250  CONTINUE
      ISTORE(JB)=JE
      STORE(L22PD+2)=DUMP-STORE(JI)+STORE(JJ)
      STORE(LCG+4)=0.5*(DUMP+STORE(JI)+STORE(JJ))
      JJ=JJ+1
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
      JF=ISTORE(JE)
      JE=ISTORE(JF)
C--CHECK IF THERE ARE MORE DISTANCES FOR THIS DISTANCE
      IF(JE)1300,1300,1250
C--END OF THIS DISTANCE  -  MOVE TO THE NEXT
1300  CONTINUE
      JI=JI+1
      ISTORE(JB)=JD
      JA=JD
      GOTO 1100
1350  CONTINUE
      RETURN
      END
C
CODE FOR XCDC
      SUBROUTINE XCDC(iasym, results)
      use list26_mod
      use store_mod, only: store, istore=>i_store, c_store
C--CALCULATE DISTANCE RESTRAINTS
C
C    IASYM = 0 FOR NORMAL
C            1 FOR ASYMMETRIC
C--

      type(restraints_t), intent(inout), optional :: results
      
C
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
C

      if(present(results)) then
          call extend(results%subrestraints, nca/2, .true.)
          JA=LCA
          do icpt=1, size(results%subrestraints)
             write(results%subrestraints(icpt)%description, '(A)') 
     &        'Single distance'
              call extend(results%subrestraints(icpt)%atoms, 2, .true.)
              results%subrestraints(icpt)%atoms(1)%label=
     &            c_store(JA+2)
              results%subrestraints(icpt)%atoms(1)%serial=
     &            nint(store(JA+3))
              JA=ISTORE(JA)
              results%subrestraints(icpt)%atoms(2)%label=
     &            c_store(JA+2)
              results%subrestraints(icpt)%atoms(2)%serial=
     &            nint(store(JA+3))
              JA=ISTORE(JA)
          end do
      end if
      
C--SET UP THE INITIAL CONSTANTS
      JA=LCA
      NCA=2
C--LOOP FOR EACH INDIVIDUAL RESTRAINT
1000  CONTINUE
      E=1.0
      CALL XCDPD(IASYM)
      STORE(L22PD+2)=STORE(LCG+4)-D
      MCA=JA
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
      JA=ISTORE(JB)
      IF(JA)1050,1050,1000
1050  CONTINUE
      RETURN
      END
C
C
CODE FOR XCEC
      SUBROUTINE XCEC(IASYM)
C--CALCULATE ENERGY RESTRAINTS
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET UP THE INITIAL CONSTANTS
      JA=LCA
      NCA=2
C----- GET POWER FACTOR FROM PROCESSED ESD
      POWER = 1. / SQRT( STORE(LCG+3) )
C--LOOP FOR EACH INDIVIDUAL RESTRAINT
1000  CONTINUE
      E=1.0
      CALL XCDPD(IASYM)
      STORE(L22PD+2)=STORE(LCG+4)-D
C----- WEIGHT = 10000. * (D(TARGET)/D(ACTUAL)**(12*POWERFACTOR) )
      STORE(L22PD+1) = 10000 * AMIN1 (10000.,
     1 (STORE(LCG+4) / (AMAX1( D, 1.)) ) ** (12.*POWER) )
      MCA=JA
      CALL XFMPDQ
      JA=ISTORE(JB)
      IF(JA)1050,1050,1000
1050  CONTINUE
      RETURN
      END
C
CODE FOR XCMAC
      SUBROUTINE XCMAC
C--CALCULATE MEAN ANGLE RESTRAINTS
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
c     INCLUDE 'XUNITS.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CONVERT THE ANGLES AND WEIGHTS TO RADIANS
      STORE(LCG+3)=STORE(LCG+3)/(DTR*DTR)
      DUMP=STORE(LCG+4)*DTR
      STORE(LCG+4)=0.
      JJ=0
C--SET UP THE POINTERS TO THE TOP OF THE WORK STACK
      JH=ISTORE(LCG+2)+LC
      JI=JH
      JA=LCA
C--CALCULATE THE PARTIAL DIFFERENTIALS INITIALLY
1000  CONTINUE
      E=1.0
      CALL XCAPD
      STORE(LCG+4)=STORE(LCG+4)+V
      JJ=JJ+1
      STORE(JI)=V
      JI=JI+1
      JA=ISTORE(JC)
      IF(JA)1050,1050,1000
C--END OF THE FIRST PASS  -  PASS THROUGH NOW AND ACCUMULATE
1050  CONTINUE
      STORE(LCG+4)=STORE(LCG+4)/FLOAT(JJ)+DUMP
      JI=JH
      JA=LCA
      NCA=3
1100  CONTINUE
      JB=ISTORE(JA)
      JC=ISTORE(JB)
      MCA=JA
      STORE(L22PD+2)=STORE(LCG+4)-STORE(JI)
      STORE(L22PD+1) = STORE(LCG+3)
c     WRITE(NCWU,*)'Forming PDQ for mean angle restraint'
      CALL XFMPDQ
      JI=JI+1
      JA=ISTORE(JC)
      IF(JA)1150,1150,1100
1150  CONTINUE
      RETURN
      END
C
CODE FOR XCADC
      SUBROUTINE XCADC
C--CALCULATE MULTIPLE ANGLE RESTRAINTS
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
c     INCLUDE 'XUNITS.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CONVERT THE ANGLES AND WEIGHTS TO RADIANS
      STORE(LCG+3)=STORE(LCG+3)/(DTR*DTR)
      DUMP=STORE(LCG+4)*DTR
C--SET UP THE POINTERS TO THE TOP OF THE WORK STACK
      JH=ISTORE(LCG+2)+LC
      JI=JH
      JA=LCA
C--CALCULATE THE PARTIAL DIFFERENTIALS INITIALLY
1000  CONTINUE
      E=-1.0
      CALL XCAPD
      STORE(JI)=V
      JI=JI+1
      JA=ISTORE(JC)
      IF(JA)1050,1050,1000
C--END OF THE FIRST PASS  -  PASS THROUGH NOW AND ACCUMULATE
1050  CONTINUE
      JI=JH
      JA=LCA
      NCA=6
1100  CONTINUE
      JJ=JI+1
      JB=ISTORE(JA)
      JC=ISTORE(JB)
      JD=ISTORE(JC)
C--REVERSE THE SIGNS OF THE CURRENT COMPARISON ANGLE
      JP=ISTORE(JA+6)
      JQ=ISTORE(JB+6)
      JV=ISTORE(JC+6)
      DO 1150 JS=1,3
      STORE(JP+2)=-STORE(JP+2)
      STORE(JQ+2)=-STORE(JQ+2)
      STORE(JV+2)=-STORE(JV+2)
      JP=ISTORE(JP)
      JQ=ISTORE(JQ)
      JV=ISTORE(JV)
1150  CONTINUE
C--CHECK THAT THERE REMAIN AT LEAST ONE MORE DISTANCE FOR COMPARISON
      IF(JD)1350,1350,1200
1200  CONTINUE
      MCA=JA
      JE=JD
1250  CONTINUE
      ISTORE(JC)=JE
      STORE(L22PD+2)=DUMP-STORE(JI)+STORE(JJ)
      STORE(LCG+4)=0.5*(DUMP+STORE(JI)+STORE(JJ))
      JJ=JJ+1
      STORE(L22PD+1) = STORE(LCG+3)
c     WRITE(NCWU,*)'Forming PDQ for multi angle restraint'
      CALL XFMPDQ
      JF=ISTORE(JE)
      JG=ISTORE(JF)
      JE=ISTORE(JG)
      IF(JE)1300,1300,1250
1300  CONTINUE
      JI=JI+1
      ISTORE(JC)=JD
      JA=JD
      GOTO 1100
1350  CONTINUE
      RETURN
      END
C
CODE FOR XCAC
      SUBROUTINE XCAC
C--CALCULATE ANGLE RESTRAINTS
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
c     INCLUDE 'XUNITS.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CONVERT THE ANGLES AND WEIGHTS TO RADIANS
      STORE(LCG+3)=STORE(LCG+3)/(DTR*DTR)
      STORE(LCG+4)=STORE(LCG+4)*DTR
C--SET UP THE INITIAL CONSTANTS
      JA=LCA
      NCA=3
C--LOOP FOR EACH INDIVIDUAL RESTRAINT
1000  CONTINUE
      E=1.0
      CALL XCAPD
      STORE(L22PD+2)=STORE(LCG+4)-V
      MCA=JA
      STORE(L22PD+1) = STORE(LCG+3)
c     WRITE(NCWU,*)'Forming PDQ for normal angle restraint', 
c     2  STORE(L22PD+1), STORE(L22PD+2)
      CALL XFMPDQ
      JA=ISTORE(JC)
      IF(JA)1050,1050,1000
1050  CONTINUE
      RETURN
      END
C
CODE FOR KPLANE
      FUNCTION KPLANE(IN, results)
      use list26_mod
      use store_mod, only: lfl, nfl, store, c_store, istore=>i_store
C--CALCULATE THE DERIVATIVES FOR A 'PLANAR' RESTRAINT
C
C  IN  A DUMMY ARGUMENT.
C
C--THE RETURN VALUES OF 'KPLANE' ARE :
C
C  -1  AN ERROR HAS BEEN FOUND.
C  >0  THE NUMBER OF ATOMS IN THE PLANE (>2).
C
C--
C
      type(restraints_t), intent(inout), optional :: results
      DIMENSION FF(3)
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XIOBUF.INC'
C
      EQUIVALENCE (FF(1),F)
      IDWZAP = IN
C--SET UP THE CORE AREAS FOR THE VARIOUS MATRICES
      KPLANE=NCA
      JS=NFL
      JT=4
C--SET UP THE CENTROID AREA FLAG
      JU=NFL+JT*NCA
C--SET UP THE LATENT ROOTS FLAG
      JV=JU+3
C--SET UP THE LATENT VECTORS FLAG  -  STORED BY COLUMNS
      JW=JV+3
C--SET UP THE NORMAL EQUATIONS AREA
      JX=JW+9
C--SET UP THE WORK AREA OF 4 WORDS
      JY=JX+9
      NFL=JY+4
C--CHECK THAT THERE IS ENOUGH ROOM
      IF(NFL-LFL)1200,1000,1000
C--NOT ENOUGH CORE AVAILABLE
1000  CONTINUE
      CALL XERHDR(0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1050)
      WRITE ( CMON ,1050)
      CALL XPRVDU(NCVDU, 1,0)
1050  FORMAT(' Insufficient memory for ''PLANAR'' restraint' )
C--SET THE ERROR RETURN VALUE
1100  CONTINUE
      KPLANE=-1
1150  CONTINUE
      RETURN
C--SET UP THE ATOM COORDINATES IN THE ATOM ARRAY AT 'JS'
1200  CONTINUE

      if(present(results)) then
        results%short_desc=
     &    'Restrain the distance to a mean plane to zero'
        results%groups=NCA
        call extend(results%subrestraints, NCA, .true.)
        JA=LCA
        do icpt=1, size(results%subrestraints)
           write(results%subrestraints(icpt)%description, '(A)') 
     &      'Distance to mean plane'
            call extend(results%subrestraints(icpt)%atoms, 1, .true.)
            results%subrestraints(icpt)%atoms(1)%label=
     &        c_store(JA+2)
            results%subrestraints(icpt)%atoms(1)%serial=
     &        nint(store(JA+3))     
           JA=ISTORE(JA)
        end do
      end if
      
      JA=LCA
      JB=JS
C--CHECK FOR THE END OF THE CHAIN
1250  CONTINUE
      IF(JA)1350,1350,1300
C--FETCH THE COORDINATES FROM THE SPREAD BLOCK  -  SYMMETRY ALREADY ADDE
1300  CONTINUE
      I=ISTORE(JA+16)
      STORE(JB)=STORE(I+8)
      STORE(JB+1)=STORE(I+10)
      STORE(JB+2)=STORE(I+12)
      STORE(JB+3)=1.
      JB=JB+JT
      JA=ISTORE(JA)
      GOTO 1250
C--CALCULATE THE MEAN PLANE
1350  CONTINUE
      IF(KMOLAX(STORE(JS),NCA,JT,STORE(JU),STORE(JV),STORE(JW),
     2 STORE(JX),STORE(JY)))1400,1500,1500
C--NOT ENOUGH ATOMS IN THE GROUP
1400  CONTINUE
      CALL XERHDR(0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1450)
      WRITE ( CMON ,1450)
      CALL XPRVDU(NCVDU, 1,0)
1450  FORMAT(' Insufficient atoms to define a plane')
      GOTO 1100
C--CALCULATE THE EQUATION OF THE PLANE
1500  CONTINUE
      CALL XMOLEQ(STORE(JU),STORE(JW),FF(1),D,STORE(JX))
C--NOW SET UP THE FLAGS TO CALCULATE THE DERIVATIVES
      MCA=LCA
      NCA=1
      JB=JS
      E=1.
C--CHECK FOR THE END OF THE CHAIN
      icpt=0
1550  CONTINUE
      IF(MCA)1150,1150,1600
C--CALCULATE THE OBSERVED DEVIATION FROM THE PLANE
1600  CONTINUE
      icpt=icpt+1
      STORE(JB+3)=F*STORE(JB)+G*STORE(JB+1)+H*STORE(JB+2)-D

      if(present(results)) then
        results%subrestraints(icpt)%rvalue=STORE(JB+3)
        results%subrestraints(icpt)%rtarget=0.0
      end if

C--CALCULATE THE DELTA VALUE
      STORE(L22PD+2)=STORE(LCG+4)-STORE(JB+3)
C--ADD IN THE DERIVATIVES
      JO=MCA
      CALL XADXYZ
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
      JB=JB+JT
      MCA=ISTORE(MCA)
      GOTO 1550
      END
C
CODE FOR XSUMCN
      SUBROUTINE XSUMCN(ITYPE)
C
C----- ITYPE = 1 = UNWEIGHTED
C              2 = Z WEIGHTED
C--reSTRAIN THE SUM OF THE SHIFTS OF THE PARAMETERS TO ZERO
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--INDICATE THAT THE FOUND VALUES ARE NOT TO BE STORED
      JS=-1
C--SCAN OVER THE PARAMETERS THAT ARE  STORED
      CALL XGRPSM(ITYPE)
C--SET THE DELTA TO ZERO
      STORE(L22PD+2)=0.
      STORE(LCG+4)=0.
C--ADD IN THE COMPUTED DERIVATIVES FOR THIS RESTRAINT
      MCA=LCA
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
      RETURN
      END
C
CODE FOR KAVERG
      FUNCTION KAVERG(IN)
C--RESTRAIN A GROUP OF PARAMETERS TO THEIR COMMON MEAN
C------ OR LIMIT THE PARAMETER SHIFTS TO APPROXIMATELY ZERO
C
C     IN   +1 COMPUTE DELTA = MEAN - VALUE
C     IN   -1 SET DELTA = 0, FOR 'LIMIT' RESTRAINT
C
C--THE RETURN VALUES OF 'KAVERG' ARE :
C
C  -1  NOT CORE AVAILABLE
C   0  RESTRAINT PROCESSED OKAY.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET UP THE AREA FOR THE STORED VALUES
      JS=MDCS-NCA
C--CHECK FOR CORE OVERFLOW
      IF(NFL+27-JS)1150,1000,1000
C--NOT ENOUGH CORE AVAILABLE
1000  CONTINUE
      CALL XERHDR(0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1050)
      WRITE ( CMON ,1050)
      CALL XPRVDU(NCVDU, 1,0)
1050  FORMAT(' Insufficient core for ''AVERAGE'' restraint ')
      KAVERG=-1
C--AND NOW RETURN
1100  CONTINUE
      RETURN
C--SCAN THE PROVIDED PARAMETERS
1150  CONTINUE
      KAVERG=0
      JT=1
      CALL XGRPSM(1)
C--COMPUTE THE AVERAGE VALUE
      A=STORE(LCG+2)/FLOAT(NCA)
      STORE(LCG+4)=STORE(LCG+4)+A
      STORE(LCG+2)=A
C--SET UP THE FLAGS TO ADD IN THE DERIVATIVES
      NCA=1
      JA=LCA
      JU=JS
C--CHECK FOR THE END OF THE PARAMETER HEADER CHAIN
1200  CONTINUE
      IF(JA)1100,1100,1250
C--COMPUTE THE DELTA AND ADD IN THE DERIVATIVES
1250  CONTINUE
      IF (IN) 1260,1260,1270
1260  CONTINUE
C----- 'LIMIT' RESTRAINT - SET DELTA = 0
      STORE(LCG+4) = 0.
      STORE(L22PD+2) = 0.
      GOTO 1280
1270  CONTINUE
C
C----- 'AVERAGE' RESTRAINT - COMPUTE DELTA
      STORE(L22PD+2)=STORE(LCG+4)-STORE(JU)
1280  CONTINUE
      JU=JU+JT
      MCA=JA
      STORE(L22PD+1) = STORE(LCG+3)
      CALL XFMPDQ
      JA=ISTORE(JA)
      GOTO 1200
      END
C
CODE FOR XGRPSM
      SUBROUTINE XGRPSM(ITYPE)
C
C----- ITYPE = 1 = UNWEIGHTED
C              2 = Z WEIGHTED
C--COMPUTE THE SUM OF A GROUP OF PARAMETERS
C
C--ON ENTRY THE FOLLOWING VARIABLES MUST BE SET :
C
C  LCA     THE ADDRESS OF THE FIRST ATOM HEADER BLOCK
C  JS      THE ADDRESS AT WHICH TO BEGIN STORING THE FOUND PARAMETER VAL
C          (IF SET NEGATIVE, THE VALUES ARE NOT STORED).
C  JT      THE INCREMENT BETWEEN SUCCESSIVE STORAGE LOCATIONS.
C
C--THE FOLLOWING VARIABLES ARE USED :
C
C  JA      THE ADDRESS OF THE CURRENT HEADER.
C  JO      USED BY 'XADXYZ', TOGETHER WITH OTHERS.
C  JU      CURRENT VALUE OF 'JS'.
C
C--THE TOTAL OF THE PARAMETERS IS RETURNED AT STORE(LCG+2)
C  THIS ROUTINE ALSO CLACULATES THE DERIVATIVES FOR EACH PARAMETER
C  AND PUTS THEM IN THE PARAMETER CHAIN.
C  THE PARAMETER OF INTEREST IS ASSUMED TO BE THE FIRST ON THE CHAIN
C  STARTING AT WORD 6 OF EACH HEADER.
C
C--
C
      DIMENSION F1(3),O1(6)
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST03.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (F1(1),F),(O1(1),O)
C
C----- LOAD LIST 3 IF WE NEED IT
      KLST3 = -1
      IF (ITYPE .EQ. 2) THEN
          IF (KHUNTR (3,0, IJNK1,IJNK2,IJNK3, -1) .EQ. 0) KLST3 = 1
      ENDIF
C--SET UP THE INITIAL CONSTANTS
      AA=0.
      E = 1.
      JA=LCA
      JU=JS
C--CHECK FOR THE END OF THE PARAMETER HEADER BLOCK CHAIN
1000  CONTINUE
      IF(JA)1500,1500,1050
C--SET UP THE INITIAL ADDRESS FLAGS FOR THIS HEADER
1050  CONTINUE
      II=0
      IJ=ISTORE(JA+6)
C--CHECK ON THE TYPE OF HEADER BLOCK
      IF(ISTORE(JA+1))1100,1150,1100
C--OVERALL PARAMETER OR SIMPLE ATOMIC PARAMETER
1100  CONTINUE
      STORE(IJ+2)=1.
      GOTO 1350
C--THIS IS AN ATOMIC HEADER BLOCK  -  CHECK THE PARAMETER TYPE
1150  CONTINUE
      II=ISTORE(IJ+1)+ISTORE(IJ+1)-2
      IF(ISTORE(IJ+1)-5)1100,1250,1200
C--NOT A SIMPLE PARAMETER  -  CHECK AGAIN
1200  CONTINUE
      IF(ISTORE(IJ+1)-7)1250,1250,1300
C--THIS IS A POSITIONAL COORDINATE
1250  CONTINUE
      CALL XZEROF(F1(1),3)
C--SET UP THE CORRECT DERIVATIVE
      IK=ISTORE(IJ+1)
      F1(IK-4)=1.
      JO=JA
      IF (ITYPE .EQ. 2) THEN
C-----  SET LIST 3 ADDRESSES
        IF ( KLST3 .EQ. 1) THEN
          KEYO = 1
          MINS = L3
          DO 100 J = 1, N3
C----- GET Z FROM THE FORMFACTOR
            IF ( ISTORE(JO+2) .EQ. ISTORE(MINS)) THEN
              E = STORE(MINS+KEYO) + STORE(MINS+KEYO+2)
     1        + STORE(MINS+KEYO+4) + STORE(MINS+KEYO+6)
     2        + STORE(MINS+KEYO+8) + STORE(MINS+KEYO+10)
              GOTO 110
            END IF
            MINS = MINS + MD3
100       CONTINUE
        END IF
110     CONTINUE
      END IF
C--COMPUTE THE DERIVATIVES, ALLOWING FOR SYMMETRY
      CALL XADXYZ
      GOTO 1350
C--THIS IS A ANISOTROPIC TEMPERATURE FACTOR
1300  CONTINUE
      CALL XZEROF(O1(1),6)
C--SET UP THE CORRECT DERIVATIVE
      IK=ISTORE(IJ+1)
      O1(IK-7)=1.
      JO=JA
      JX=IJ
C--COMPUTE THE DERIVATIVES, ALLOWING FOR SYMMETRY
      CALL XADUIJ
C--ADD IN THIS PARAMETER VALUE
1350  CONTINUE
      II=II+ISTORE(JA+16)
      AA = AA + STORE(II) * E
C--CHECK IF WE SHOULD STORE  THIS VALUE
      IF(JS)1450,1450,1400
C--STORE THE VALUE
1400  CONTINUE
      STORE(JU) =  STORE(II) * E
      JU=JU+JT
C--MOVE ONTO THE NEXT PARAMETER HEADER BLOCK
1450  CONTINUE
      JA=ISTORE(JA)
      GOTO 1000
C--END OF THE CHAIN  -  RETURN
1500  CONTINUE
      STORE(LCG+2)=AA
      RETURN
      END
C
CODE FOR XCDPD
      SUBROUTINE XCDPD(IASYM)
C--CALCULATE DISTANCE PARTIAL DERIVATIVES
C
C IASYM 0 = NORMAL
C       1 = ASYMMETRIC
C
C  JA  ADDRESS OF THE FIRST ATOM
C  E   SET ON ENTRY TO 1.0 OR -1.0 FOR DERIVATIVE MULTIPLIER.
C
C--THE SECOND ATOM IS CHAINED TO THE FIRST, AND ITS ADDRESS IS SET IN 'J
C  ON EXIT.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--FIND THE ADDRESS OF THE SECOND ATOM HEADER
      JB=ISTORE(JA)
C--SET UP THE FLAGS FOR 'XCD2PD'
      JO=JA
      JS=JB
C--COMPUTE THE DERIVATIVES, APART FROM THE MULTIPLIER
      CALL XCD2PD
C--CALCULATE THE DISTANCE
      D=SQRT((A*F+B*G+C*H)*0.5)
C--CALCULATE THE P.D. MULTIPLIER
      ESAVE=E/D*0.5
      IF (IASYM .EQ. 0) THEN
       E = ESAVE
      ELSE
       E = 0.
      ENDIF
C--DERIVATIVES FOR THE FIRST ATOM
      CALL XADXYZ
C--DERIVATIVES FOR THE SECOND ATOM
      E = -ESAVE
      JO=JB
      CALL XADXYZ
      RETURN
      END
C
CODE FOR XCAPD
      SUBROUTINE XCAPD
C--CALCULATE ANGLE PARTIAL DERIVATIVES
C
C  JA  ADDRESS OF ATOM 2
C  JB  ADDRESS OF ATOM 1  -  THE PIVOT ATOM
C  JC  ADDRESS OF ATOM 3
C
C  THE BOND ANGLE IS : JA-JB-JC
C
C--IN THIS LINK THE FOLLOWING VARIABLES ARE USED :
C
C  O  L12*L12
C  P  L23*L23
C  Q  L31*L31
C  R  L12*L12+L31*L31-L23*L23
C  S  L12
C  T  L23
C  U  L31
C  V  THE ANGLE IN RADIANS
C
C--AFTER THE INITIAL CALCULATIONS :
C
C  O  D(L12)/DP
C  P  D(L31)/DP
C  Q  D(L23)/DP
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
c      INCLUDE 'XUNITS.INC'
C
      INCLUDE 'QSTORE.INC'
C
      JB=ISTORE(JA)
      JC=ISTORE(JB)
C--CALCULATE THE CONSTANTS FOR L12
      JO=JB
      JS=JA
      CALL XCD2PD
      O=(A*F+B*G+C*H)*0.5
C--DUMP THE RESULTS
      X=F
      Y=G
      Z=H
C--CALCULATE THE CONSTANTS FOR L23
      JO=JA
      JS=JC
      CALL XCD2PD
      P=(A*F+B*G+C*H)*0.5
C--DUMP THE RESULTS
      U=F
      V=G
      W=H
C--CALCULATE THE CONSTANTS FOR L31
      JO=JC
      JS=JB
      CALL XCD2PD
      Q=(A*F+B*G+C*H)*0.5
      A=U
      B=V
      C=W
      R=O+Q-P
C--CALCULATE THE BOND LENGTHS
      S=SQRT(O+0.000001)
      T=SQRT(P+0.000001)
      U=SQRT(Q+0.000001)
C--CALCULATE THE ANGLE
      V=R/(2.0*S*U)
      IF(ABS(V)-1.0)1050,1050,1000
1000  CONTINUE
      V=SIGN(1.0,V)
1050  CONTINUE
      V=ACOS(V)
      W=1.0/(2.0*O*Q*SIN(V))
C--CALCULATE THE PARTIAL DERIVAITVES FOR THE BOND LENGTHS
      P=(R-Q-Q)*S*W
      O=(R-O-O)*U*W
      Q=2.0*S*T*U*W
      D=0.5*E
C--CALCULATE THE DERIVATIVE BASED ON L31
      E=D*P/U
C--ATOM 3
      JO=JC
c      WRITE(NCWU,*) 'A3 ',E,' ',F,' ',G,' ',H
      CALL XADXYZ
      E=-E
C--ATOM 1
      JO=JB
c      WRITE(NCWU,*) 'A1 ',E,' ',F,' ',G,' ',H
      CALL XADXYZ
C--CALCULATE THE DERIVATIVES BASED ON L23
      F=A
      G=B
      H=C
      E=D*Q/T
C--ATOM 2
      JO=JA
c      WRITE(NCWU,*) 'A2 ',E,' ',F,' ',G,' ',H
      CALL XADXYZ
      E=-E
C--ATOM 3
      JO=JC
c      WRITE(NCWU,*) 'A3a ',E,' ',F,' ',G,' ',H
      CALL XADXYZ
C--CALCULATE THE DERIVATIVES BASED ON L12
      F=X
      G=Y
      H=Z
      E=D*O/S
C--ATOM 1
      JO=JB
c      WRITE(NCWU,*) 'A1a ',E,' ',F,' ',G,' ',H
      CALL XADXYZ
      E=-E
C--ATOM 2
      JO=JA
c      WRITE(NCWU,*) 'A2a ',E,' ',F,' ',G,' ',H
      CALL XADXYZ
      RETURN
      END
C
CODE FOR XCD2PD
      SUBROUTINE XCD2PD
C--CALCULATE THE PARTIAL DERIVATIVES FOR THE DISTANCE  SQUARED
C
C  JO  ADDRESS OF THE HEADER BLOCK FOR THE ATOM FOR WHICH P.D.'S
C        ARE REQUIRED
C  JS  SECOND ATOM
C
C--USES THE COMMON BLOCK /XWORK/ AND RETURNS THE ANSWERS AS FOLLOWS :
C
C  A  X(1)-X(2)
C  B  Y(1)-Y(2)
C  C  Z(1)-Z(2)
C  F  P. D. W. R. T. X APART FROM D(X1-X2)/DX1  (NOT ALWAYS =1)
C  G  P. D. W. R. T. Y . . . .
C  H  P. D. W. R. T. Z
C
C--'F', 'G' AND 'H' ARE DERIVED WITH RESPECT TO THE GENERATED
C  COORDINATES, NOT THOSE IN LIST 5.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XLST01.INC'
C
      INCLUDE 'QSTORE.INC'
C
C
C--FIND THE ADDRESS OF THE SPREAD PARAMETERS
      JQ=ISTORE(JO+16)
      JU=ISTORE(JS+16)
C--CALCULATE THE 'DX', 'DY' AND 'DZ'
      A=STORE(JQ+8)-STORE(JU+8)
      B=STORE(JQ+10)-STORE(JU+10)
      C=STORE(JQ+12)-STORE(JU+12)
C--CALCULATE THE DERIVATIVES, APART FROM THE MULTIPLIER OF '0.5*DIST**-1
      F=2.0*(A*STORE(L1M1)+B*STORE(L1M1+1)+C*STORE(L1M1+2))
      G=2.0*(A*STORE(L1M1+3)+B*STORE(L1M1+4)+C*STORE(L1M1+5))
      H=2.0*(A*STORE(L1M1+6)+B*STORE(L1M1+7)+C*STORE(L1M1+8))
      RETURN
      END
C
CODE FOR XADXYZ
      SUBROUTINE XADXYZ
C--ADD IN THE CONTRIBUTIONS FOR X , Y AND Z
C
C  THE PARTIAL DERIVATIVES ARE ASSUMED TO BE STORED IN THE COMMON
C  BLOCK /XWORK/ :
C
C  F  P. D. W. R. T. X
C  G  P. D. W. R. T. Y
C  H  P. D. W. R. T. Z
C  E  MULTIPLIER FOR THE PARTIAL DERIVATIVES
C
C--'F', 'G' AND 'H' ARE THE DERIVATIVES WITH RESPECT TO THE GENERATED
C  COORDINATES OR STORED PARAMETERS, WHICH ARE DERIVED FROM THOSE IN LIS
C  5 BY SYMMETRY. THIS ROUTINE CALCULATES THE DERIVATIVES WITH RESPECT
C  TO THE COORDINATES IN LIST 5 FROM 'F', 'G' AND 'H'.
C
C--POINTERS IN 'XWORKA' ARE :
C
C  JO  ADDR. OF THE FIRST ATOM
C  JP  ADDR. OF THE CURRENT COORD. FOR THE FIRST ATOM
C  JQ  ADDR. OF THE COORDINATES FOR THE FIRST ATOM
C  JV  ADDR. OF THE GENERATED COORDS. FOR THE FIRST ATOM
C  JS  JO FOR THE SEOND ATOM
C  .
C  .
C
C--THE X, Y AND Z COORDS. ARE ASSUMED TO BE THE FIRST STORED.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
c     INCLUDE 'XUNITS.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--FIND THE ADDRESS OF THE PARAMETER CHAIN
      JP=ISTORE(JO+6)
C--FIND THE ADDRESS OF THE SPREAD PARAMETERS
      JV=ISTORE(JO+16)
C--LOOP OVER EACH COORDINATE
      DO 1000 J=1,3
C--FIND THE SYMMETRY MATRIX
      I=ISTORE(JO+4)+ISTORE(JP+1)
C--CALCULATE THE DERIVATIVES FOR THIS COORD. W.R.T. THE GENERATED X, Y Z
      STORE(JV+9)=STORE(JO+14)*STORE(I-5)
      STORE(JV+11)=STORE(JO+14)*STORE(I-2)
      STORE(JV+13)=STORE(JO+14)*STORE(I+1)
C--CALCULATE THE PARTIAL DERIVATIVE FOR THIS COORD
      STORE(JP+2)=STORE(JP+2)+E*(F*STORE(JV+9)+G*STORE(JV+11)
     2 +H*STORE(JV+13))
c     WRITE(NCWU,*)'ADXYZ ', I, ' ', STORE(JP+2), ' ', JP
      JP=ISTORE(JP)
1000  CONTINUE
      RETURN
      END
C
CODE FOR XADUIJ
      SUBROUTINE XADUIJ
C--ADD THE DERIVATIVES FOR THE UIJ'S INTO THE PARAMETER BLOCKS,
C  ALLOWING FOR SYMMETRY AS IT IS DONE.
C
C--THE FOLLOWING VARIABLES MUST BE SET
C
C  JO  ADDRESS OF THE ATOM HEADER.
C  JX  ADDRESS OF THE FIRST PARAMETER BLOCK TO PROCESS.
C      (THIS VARIABLE IS UPDATED BY THIS ROUTINE).
C
C--THE DERIVATIVES FOR U(11), U(22), ETC. ARE STORED IN O, P, Q, ETC.
C
C--
      INCLUDE 'ISTORE.INC'
C
      DIMENSION A1(12)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (O,A1(1))
C
C--FIND THE ADDRESS OF THE SYMMETRY MATRIX USED
      L=ISTORE(JO+4)
C--ZERO THE U(IJ) DERIVATIVE AREA
      CALL XZEROF(STORE(NFL+18),6)
C--LOOP OVER EACH U(IJ), COMPUTING THE DERIVATIVE, ALLOWING FOR SYMMETRY
      DO 1000 J=1,6
      If(jX+1<0) call abort()
      K=NFL+ISTORE(JX+1)+10
      STORE(K)=1.
C--CALCULATE DU(IJ)'/DU(IJ), WHERE THE ' ALLOWS FOR SYMMETRY
c      write(123,'(6f10.6)') (store(idjw),idjw=nfl+18,nfl+23)
      CALL XEXANI(NFL+18,NFL)
      CALL XMLTTM(STORE(NFL),STORE(L),STORE(NFL+9),3,3,3)
      CALL XMLTTM(STORE(L),STORE(NFL+9),STORE(NFL),3,3,3)
      STORE(K)=0.
C--CALCULATE DV/DU(IJ)
      STORE(JX+2)=STORE(JX+2)+STORE(NFL)*A1(1)+STORE(NFL+4)*A1(2)
     2 +STORE(NFL+8)*A1(3)+STORE(NFL+5)*A1(4)+STORE(NFL+2)*A1(5)
     3 +STORE(NFL+1)*A1(6)
c      print *, 'jx, dv/du ', JX+2, STORE(JX+2)
      JX=ISTORE(JX)
1000  CONTINUE
      RETURN
      END
C
CODE FOR XIPDQF
      SUBROUTINE XIPDQF
C--INITIATE PARTIAL DERIVATIVE QUEUE FORMATION
C
C--THIS ROUTINE SETS UP THE P.D. STACK IN CORE, AND FINDS THE DISC ADDR.
C  AT WHICH TO START PUTTING OUT THE INFORMATION.
C
C  L22PD   ADDRESS OF THE PARTIAL DERIVATIVE STACK IN CORE
C  M22PD   CURRENT DISC ADDRESS OF THE PARTIAL DERIVATIVE QUEUE
C  MD22PD  LENGTH OF EACH ENTRY IN THE QUEUE  (=2)
C
C--THE FORMAT OF THE STACK FOR EACH RESTRAINT IS AS FOLLOWS :
C
C  ISTORE(L22PD  )  LENGTH OF THE ENTRY
C   STORE(L22PD+1)  WEIGHT
C   STORE(L22PD+2)  CALC. DELTA
C   STORE(L22PD+3)  OBSERVED VALUE SQUARED
C
C  ISTORE(L22PD+4)  PARAMETER 1
C   STORE(L22PD+5)  P. D. FOR PARAMETER 1
C  .
C  .
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLST12.INC'
      INCLUDE 'XLST22.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET THE LIST TYPE RECORD TYPE FOR THE STACK
      LN=22
      IREC=1001
C--SET THE LENGTH OF EACH ENTRY IN THE STACK
      MD22PD=2
C--SET UP THE STACK
      L22PD=NFL
      M22PD=KCHNFL(4+N12*MD22PD)
C--FIND THE DISC ADDRESS
      M22PD=KNEXTF(L22PD)
      RETURN
      END
C
CODE FOR XTPDQF
      SUBROUTINE XTPDQF
C--TERMINATE PARTIAL DERIVATIVE QUEUE FORMATION
C
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET THE TRANSFER LENGTH
      N22PD=4
C--SET THE TRANSFER DETAILS
      ISTORE(L22PD)=NOWT
      CALL XZEROF(STORE(L22PD+1),N22PD-1)
C--OUTPUT THE DATA TO THE DISC
      CALL XUPF(M22PD, ISTORE(L22PD),N22PD)
      RETURN
      END
C
CODE FOR XFMPDQ
      SUBROUTINE XFMPDQ
      use list26_mod, only: subrestraints_parent, current_restraintindex
      use list26_mod, only: extend
C--FORM THE PARTIAL DERIVATIVE QUEUE
C  THIS SUBROUTINE TAKES THE CALCULATED PARTIAL DERIVATIVES FOR
C  EACH ATOM AND ADDS THEM INTO THE QUEUE.
C
C--THE FOLLOWING ATOMS POINTERS IN 'XCNTRL' MUST BE SET :
C
C  MCA  ADDRESS OF THE HEADER BLOCK FOR THE FIRST ATOM TO BE TREATED
C  NCA  NUMBER OF ATOMS TO TREAT
C
C--THE HEADER BLOCKS ARE ASSUMED TO BE IN STANDARD FORMAT, WITH
C  THE LIST 12 ADDRESSES ALREADY SET.
C  TERMINATION IS REACHED BY A NEGATIVE LINK ADDRESS.
C
C--THE OBSERVED VALUE SQUARED ARE TAKEN FROM THE CONTROL BLOCK AT 'LCG'
C  THE OTHER ENTRIES FOR THE CALCULATED DELTA AND WEIGHT ARE ASSUMED
C  TO BE SET ON ENTRY.
C
C----- ISTORE (LCG+1) OPERATIONS
C      1  DEFINE    2  RESTRAIN  3  DISTANCE 4
C      5            6  ANGLE     7           8
C      9  VIBRATION 10 EXECUTION 11 NOLIST   12 UIJ
C      13 EQUATE    14 PLANAR    15 SUM      16 FORM
C      17 AVERAGE   18 LIMIT     19 ENERGY   20 ORIGIN
C

C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLST12.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XCONST.INC'
C
      INCLUDE 'XL26WK.INC'
C
      INCLUDE 'QSTORE.INC'
C
C
C
      if(mca<0) then
         ! serious programming error, mca should be set
         write(ncwu, *) 'Serious programing error, MCA in XFMPDQ ',
     1     'should be set. Aborting...'
#ifdef CRY_OSLINUX
         write(*, *) 'Serious programing error, MCA in XFMPDQ ',
     1     'should be set. Aborting...'
#endif
         call abort() 
      end if
      
      call extend(subrestraints_parent, 1)
      subrestraints_parent(size(subrestraints_parent))=
     1    current_restraintindex

C--SET THE REMAINDER OF THE HEADER BLOCK
      STORE(L22PD+3)=STORE(LCG+4)*STORE(LCG+4)
      J=JR+N12-1
      DO I=JR,J
        STORE(I)=0.
      END DO
      STORE(JN)=0.
      K=MCA
      N=NCA
C--CHECK IF THERE ANY MORE ATOMS TO PROCESS
1050  CONTINUE
      IF(N)1700,1700,1100
C--CHECK IF THIS ATOM HAS AN ACTIVE ENTRY IN LIST 12
1100  CONTINUE
      M12=ISTORE(K+13)
      IF(ISTORE(M12+1))1650,1650,1150
1150  CONTINUE
      M12=ISTORE(M12+1)
      M=ISTORE(K+6)
C--CHECK IF THERE ARE ANY MORE COORDINATES TO BE REFINED
1200  CONTINUE
      L12A=M12
      IF(M)1650,1650,1250
C--FIND THE ADDRESSES OF THIS COORDINATE
1250  CONTINUE
      L=ISTORE(M+1)-1
C--COMPUTE THE ABSOLUTE ADDRESS OF THE INFORMATION FOR THIS COORDINATE
C  IN LIST 12
1300  CONTINUE
      M12A=ISTORE(L12A+2)+ISTORE(L12A+1)*(L-ISTORE(L12A+4))
C--CHECK TO SEE IF THERE IS AN ENTRY FOR THIS COORDINATE
      IF(M12A-ISTORE(L12A+2))1550,1400,1350
1350  CONTINUE
      IF(ISTORE(L12A+3)-M12A)1550,1400,1400
C--FIND THE ADDRESS OF THE PARTIAL DERIVATIVE AND CHECK IF THE 'WEIGHT'
C  IS EQUAL TO 1.0
1400  CONTINUE
      I=ISTORE(M12A)
      IF(ISTORE(L12A+1)-1)1500,1500,1450  
C--NON-UNIT 'WEIGHT'
1450  CONTINUE
c      WRITE(*,*)'Str PDQ1: ',' i:',I,' m:',M,' ',STORE(M+2),' w:',
c     1 STORE(M12A+1),' s(I):',STORE(I),' ++ ',STORE(M+2)*STORE(M12A+1)
      STORE(I)=STORE(I)+STORE(M+2)*STORE(M12A+1)
c      WRITE(*,*)'After:    ',' i:',I,' m:',M,' ',STORE(M+2),' w:',
c     1 STORE(M12A+1),' s(I):',STORE(I),' ++ ',STORE(M+2)*STORE(M12A+1)
      GOTO 1550
C--UNIT 'WEIGHT'
1500  CONTINUE
      STORE(I)=STORE(I)+STORE(M+2)
c      WRITE(*,*)'Str PDQW: ',' ',I,' ',M,' ',STORE(M+2),' ',STORE(I)
C--PICK UP THE NEXT PART FOR THIS ATOM IN LIST 12
1550  CONTINUE
      L12A=ISTORE(L12A)
      IF(L12A)1600,1600,1300
C--PASS ON TO THE NEXT COORDINATE
1600  CONTINUE
      M=ISTORE(M)
      GOTO 1200
C--PASS ON TO THE NEXT ATOM HEADER
1650  CONTINUE
      K=ISTORE(K)
      N=N-1
      GOTO 1050
C
C--COMPRESS THE QUEUE AND OUTPUT IT TO THE DISC
1700  CONTINUE
      N22PD=4
      J=L22PD+N22PD
      K=JR
c      WRITE(NCWU,*) 'PDQAddress: ',J,' ',K 
      DO L=1,N12
c        WRITE(NCWU,*) 'PD: ',L,' ',K,' ',STORE(K),N22PD
C--CHECK IF THE CONTRIBUTION FOR THIS PARAMETER IS ZERO
c        IF(STORE(K))1750,1800,1750
         IF ( ABS(STORE(K))/=0.0 ) THEN
C--ADD IT TO THE QUEUE
            ISTORE(J)=L
            STORE(J+1)=STORE(K)
            J=J+MD22PD
            N22PD=N22PD+MD22PD
         END IF
         K=K+1
      END DO
      ISTORE(L22PD)=N22PD
      K=J-MD22PD
      J=L22PD+4
C--CHECK IF ANY P.D.'S HAVE BEEN FOUND
      IF(J-K)2050,2050,1900
C--NO P.D.'S FOUND
1900  CONTINUE
cdjw2015      IF(ISTAT2)2200,2200,1950
1950  CONTINUE
c     skip shift limiting and origin fixing.
       itemp = istore(lcg+1)
       ioper = iabs(itemp)
      if ((itemp .ne. 18).and.(itemp .ne. 20)) then
        L26WRN=L26WRN+1
        IF(L26TYP .EQ. 1) THEN
         WRITE(CMON,'(A,1x,A,A)') '{I Directive ', 
     1  COPERATION(ioper)(1:nctrim(COPERATION(ioper))),
     1 ': No derivatives found during Evaluation'
C         CALL XPRVDU(NCVDU,1,0)
         IF (ISSPRT .EQ. 0) WRITE(NCWU,'(A,A)')
     1  CMON(1)(3:nctrim(cmon(1)))
         endif
        ENDIF
      GOTO 2200
C--DERIVATIVES FOUND  -  CHECK IF THEY ARE TO BE PRINTED
2050  CONTINUE
      IF(ISTAT2)2200,2200,2100
2100  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2150)ISTORE(L22PD),STORE(L22PD+1),STORE(L22PD+2),
     2 STORE(L22PD+3),(ISTORE(I),STORE(I+1),I=J,K,MD22PD)
      ENDIF
cRIC13:2150  FORMAT(16H Derivative(s) :/I10,/,3(10X,E20.10)/
cRIC13:     2 (4(I10,E20.10)))
2150  FORMAT(16H Derivative(s) :/I10,/,3(10X,E20.4)/
     2 (4(I10,E20.4)))
C--OUTPUT THE QUEUE TO THE DISC
2200  CONTINUE
      CALL XUPF(M22PD, ISTORE(L22PD), N22PD)
      M22PD=M22PD+KINCRF(N22PD)
      RETURN
      END
C
CODE FOR XADCPD
      SUBROUTINE XADCPD
      use sfls_punch_mod
      use list26_mod, only: restraints_derivatives, subrestraints_parent
      use list26_mod, only: extend
C--THIS ROUTNE TAKES THE PARTIAL DERIVATIVE QUEUE ON THE DISC
C  AND ADDS IT TO THE NORMAL MATRIX.
C
C--
      INCLUDE 'TYPE11.INC'
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XSTR11.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XLST11.INC'
      INCLUDE 'XLST12.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XLST33.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLSVAL.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QSTR11.INC'
            
      double precision, dimension(:), allocatable :: globalderivatives !< Line of the unweigthed design matrix including all the blocks
      double precision, dimension(:), allocatable :: derivatives !< line of the unweighted design matrix from a single block
      integer, dimension(:), allocatable :: globalparameters !< Parameters number from globalderivatives
      integer, dimension(:), allocatable :: parameters !< Parameters number from derivatives
      integer :: num_global_parameters !< number of parameters accross all blocks
      integer :: sfls_sp_normalm !< flag for single precision calculation
      double precision, dimension(:), allocatable :: temp
      integer, dimension(:), allocatable :: itemp
      integer sfls_punch_flag, sfls_calcul_flag
      integer iblockindex, isubrestraint
      integer ioldrestraint, restraints_derivatives_idx
      integer derivatives_block_size
      
      if(allocated(restraints_derivatives)) then
        deallocate(restraints_derivatives)
      end if
      iblockindex=0
      restraints_derivatives_idx=0
      derivatives_block_size=128
      num_global_parameters=-1
      
C
C--SET THE LENGTH OF EACH ENTRY
      MD16Q=MD22PD
C--CLEAR THE CORE ENTRIES
      CALL XRSL
      CALL XCSAE
C--FIND WHETHER A NEW MATRIX IS BEING COMPUTED
      CALL XFAL33
      IF ( IERFLG .LT. 0 ) GO TO 9900
      JK=ISTORE(M33CD+6)
      sfls_punch_flag=ISTORE(M33CD+5)
      sfls_calcul_flag=ISTORE(M33CD+1)
      if(sfls_calcul_flag>0 .and. sfls_punch_flag<=0) then
        sfls_punch_flag=3 ! numpy is default
      end if
      sfls_sp_normalm=ISTORE(M33CD)
C--RESET THE CORE LIMITS
      CALL XRSL
      CALL XCSAE
C--LOAD LIST 12
      CALL XFAL12(0,0,JR,JN)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--RESET THE CORE LIMITS
      CALL XRSL
      CALL XCSAE
C--INDICATE THE LIST AND RECORD TYPE
      LN=12
      IREC=1001
C--ALLOCATE SAPCE FOR THE BLOCKING DATA
      M12B=L12B
      I=N12B*MD12B
      L12B=KCHLFL(I)
C--MOVE THE BLOCKING DATA ACROSS
      CALL XMOVE(STORE(M12B),STORE(L12B),I)
C--SET THE POINTER TO THE END OF THIS STACK
      M12B=L12B+(N12B-1)*MD12B
C--FIND THE ADDRESS OF THE P.D. QUEUE ON DIC
      MD16=KNEXTF(I)
C--LOAD THE LIST 11
      CALL XSET11(0,1,1)
      IF ( IERFLG .LT. 0 ) GO TO 9900
      
C--CHECK THAT THE MATRIX IS THE RIGHT TYPE
      IF(ISTORE(L11P+15))1000,1000,1050
C--STORED MATRIX HAS ALREADY BEEN INVERTED
1000  CONTINUE
      JK=0
C--COMPUTE THE WEIGHT MULTIPLIER
1050  CONTINUE
      IF ( (ABS (STORE( L11P + 16 )) .LE. ZERO ) .OR.
     1       (ABS (STORE( L11P + 17 )) .LE. ZERO ) ) THEN
            B = 1.
      ELSE
            B = STORE( L11P + 17 ) / STORE( L11P + 16 )
      ENDIF
      IF ( B .LE. ZERO ) B = 1.

C--CLEAR THE TOTAL ACCUMULATION AREAS
      STORE(L11P+27)=0.
      STORE(L11P+28)=0.
      STORE(L11P+29)=0.
C--SET UP AN AREA TO HOLD THE QUEUE ENTRIES FROM DISC
      L16=NFL
      LN=22
      IREC=1001
      M16=KCHNFL(MD22PD*N12+4)
C--CHECK IF A CORE MAP IS REQUIRED
      IF(ISTAT2)1100,1150,1100
1100  CONTINUE
      CALL XPCM(1)
C--BRING DOWN THE LENGTH OF THE FIRST RECORD
1150  CONTINUE
      CALL XDOWNF(MD16,ISTORE(L16),1)
C--SET THE LENGTH OF THE FIRST ENTRY
      N16=ISTORE(L16)
C--Initialise counter
      ioldrestraint=0 ! counter for restraint in list26
      isubrestraint=1 ! counter for each restraint generated from eah user restraint

C--INCREMENT THE TRANSFER ADDRESS
      MD16=MD16+KINCRF(1)
C--QUEUE PROCESSING LOOP
1200  CONTINUE
        IF(N16)1850,1850,1250
C--PROCESS THE NEXT RESTRAINT
1250    CONTINUE
        ioldrestraint=ioldrestraint+1
        
        ! if 2 consecutive have the same parent, there are generated from the same user restraint
        if(ioldrestraint>1) then
            if(subrestraints_parent(ioldrestraint)==
     1          subrestraints_parent(ioldrestraint-1)) then
                isubrestraint=isubrestraint+1
            else
                isubrestraint=1
            end if
        end if
                             
        CALL XDOWNF(MD16,STORE(L16),N16)
C--INCREMENT THE TRANSFER ADDRESS
        MD16=MD16+KINCRF(N16)
C--INDICATE THE NUMBER OF ENTRIES TO PROCESS
        N16=N16-4
C--INDICATE THE CORE ADDRESS OF THE FIRST ENTRY
        M16=L16+3
C--INDICATE THE ADDRESS OF THE LAST ENTRY IN THE QUEUE
        M16Q=M16+N16-MD16Q
C--CHECK IF ANY DERIVATIVES HAVE BEEN FOUND
        IF(N16)1800,1800,1300
C--COMPUTE THE ACTUAL WEIGHT TO USE
1300    CONTINUE
        C=STORE(L16)*B
        D=STORE(L16+1)
cdjwmay2000 - note problems with Rfactor when target is zero!
        STORE(L11P+27)=STORE(L11P+27)+1.
        STORE(L11P+28)=STORE(L11P+28)+D*D*C
        STORE(L11P+29)=STORE(L11P+29)+STORE(L16+2)*C

        !IF (MATLAB.GT.0) WRITE(NCFPU2,'(G16.8)') D
        if(sfls_punch_flag>0) then
            call sfls_punch_addtowdf(D, sfls_punch_flag)
        end if

c       IF (MATLAB.GT.0) WRITE(NCWU,'(A,G16.8)')'Hello ',store(l11P+27)
        if(allocated(globalderivatives)) deallocate(globalderivatives)
        if(allocated(globalparameters)) deallocate(globalparameters)
        
C--PASS THROUGH THE MATRIX
        M11=L11
        DO I=L12B,M12B,MD12B                 !PROCESS BLOCK BY BLOCK
          M=ISTORE(I)
          N=ISTORE(I+1)
          L=M+N-1           

          ! Get block size and allocate array
          if(L-M+1>0) then
            if(allocated(derivatives)) deallocate(derivatives)
            allocate(derivatives(L-M+1))
            derivatives=0.0d0
            if(allocated(parameters)) deallocate(parameters)
            allocate(parameters(L-M+1))
            parameters=0
            iblockindex=0
            ! extend globalderivatives by the size of the current block
            if(allocated(globalderivatives)) then
              call move_alloc(globalderivatives, temp)
              allocate(globalderivatives(size(temp)+L-M+1))
              globalderivatives(1:size(temp))=temp
              globalderivatives(size(temp)+1:)=0
              deallocate(temp)
              call move_alloc(globalparameters, itemp)
              allocate(globalparameters(size(itemp)+L-M+1))
              globalparameters(1:size(itemp))=itemp
              globalparameters(size(itemp)+1:)=0
              deallocate(itemp)
            else
              allocate(globalderivatives(L-M+1))
              allocate(globalparameters(L-M+1))
            end if
          end if

          DO J=M,L  !PASS THROUGH THE PARAMETERS IN THIS BLOCK
            iblockindex=iblockindex+1
            IF(ISTORE(M16) .NE. J) THEN             !Not this one.
               !IF (MATLAB.GT.0) WRITE(NCFPU1,'(''0.0 ...'')')
            ELSE                                    !Parameter is in queue
              A=STORE(M16+1)*C
              derivatives(iblockindex)=STORE(M16+1)
              parameters(iblockindex)=ISTORE(M16)
C--ADD INTO THE R.H.S.
              M11R=L11R+J-1
              STR11(M11R)=STR11(M11R)+A*D

c                WRITE(CMON,'(A,2G12.5,I12)')
c     1          'Rest: J,A*D,M11R: ',J,A*D,M11R
c                CALL XPRVDU(NCVDU,1,0)

              IF(JK.LT.0) THEN       !The L.H.S is required.
                DO K=M16,M16Q,MD16Q      !Inner loop through remaining params
                  IF (ISTORE(K).GT.L) EXIT    !Param not in this block
                  M11R=M11+ISTORE(K)-J        !Add contribution
                  STR11(M11R)=STR11(M11R)+A*STORE(K+1)
                END DO
              END IF
                 
              N16=N16-MD16Q
              IF(N16.LE.0)THEN                 !No more derivatives.
                ! append data into globalderivatives
                globalderivatives(
     1            size(globalderivatives)-size(derivatives)+1:)=
     1            derivatives
                globalparameters(
     1            size(globalderivatives)-size(parameters)+1:)=
     1            parameters
                     
                GOTO 1800
              ENDIF
              M16=M16+MD16Q
            END IF
            M11=M11+N
            N=N-1
          END DO ! end of current block

          ! append data into globalderivatives
          globalderivatives(
     1      size(globalderivatives)-size(derivatives)+1:)=derivatives
          globalparameters(
     1      size(globalderivatives)-size(parameters)+1:)=parameters
                      

        END DO ! all blocks processed
           
1800    CONTINUE

        ! Saving derivatives
        restraints_derivatives_idx=restraints_derivatives_idx+1
        if(.not. allocated(restraints_derivatives)) then
          call extend(restraints_derivatives, derivatives_block_size)
        else
          if(restraints_derivatives_idx>size(restraints_derivatives)) 
     1      then
            derivatives_block_size=derivatives_block_size*2
            call extend(restraints_derivatives, derivatives_block_size)
#if defined(CRY_OSLINUX)
            print *, 'new size of derivatives: ', 
     1          sizeof(restraints_derivatives)/1024.0, 'kB'
#endif
          end if
        end if
        associate(r => 
     1   restraints_derivatives(restraints_derivatives_idx))
          r%ioldrestraint=ioldrestraint
          r%irestraint=subrestraints_parent(ioldrestraint)
          r%isubrestraint=isubrestraint
          if(allocated(globalderivatives)) then
            allocate(r%derivatives(size(globalderivatives)))
            r%derivatives=globalderivatives
          end if
          if(allocated(globalparameters)) then
            allocate(r%parameters(size(globalparameters)))
            r%parameters=globalparameters
          end if
          r%weight=sign(SQRT(ABS(C)),C)
        end associate
             
        if(sfls_punch_flag>0 .and. allocated(globalderivatives)) then
            if(num_global_parameters==-1) then
                num_global_parameters=size(globalderivatives)
            else if(num_global_parameters/=size(globalderivatives)) then
#if defined(CRY_OSLINUX)
                print *, 'Inconsistent size of the design matrix'
                print *, 'Got ', size(globalderivatives), 
     1              ' expected ', num_global_parameters
#endif
                call abort()
            end if
            if(sfls_sp_normalm<0) then
              call sfls_punch_addtodesign(
     1          reshape(globalderivatives*sign(SQRT(ABS(C)),C), 
     2            (/size(globalderivatives), 1/) ),
     2          reshape( (/1000+restraints_derivatives_idx,0,0/), 
     3            (/3,1/) ), sfls_punch_flag )
            else
              call sfls_punch_addtodesign(
     1          reshape(real(
     2            globalderivatives*sign(SQRT(ABS(C)),C),kind(1.0)), 
     3            (/size(globalderivatives), 1/) ),
     4          reshape( (/1000+restraints_derivatives_idx,0,0/), 
     5            (/3,1/) ), sfls_punch_flag )
              end if
            deallocate(globalderivatives)
        end if
C--FIND THE ADDRESS OF THE LENGTH OF THE NEXT ENTRY
        M16Q=M16Q+MD16Q
C--FIND THE LENGTH OF THE NEXT ENTRY
        N16=ISTORE(M16Q)

      GOTO 1200


C--OUTPUT THE NEW MATRIX
1850  CONTINUE
      STORE(L11P+16)=STORE(L11P+16)+STORE(L11P+27)
      STORE(L11P+17)=STORE(L11P+17)+STORE(L11P+28)
      CALL XCL11(16)
      CALL XMKOWF(11,0)
      CALL XALTES(11,1)

      if(sfls_punch_flag>0) then
        ! it is important to pass a design matrix with the correct shape even though no data is written
        ! it is how the subroutine will work out the size of the design matrix
        allocate(globalderivatives(num_global_parameters))
        if(sfls_sp_normalm<0) then
          call sfls_punch_addtodesign(
     1      reshape(globalderivatives, 
     2        (/size(globalderivatives), 1/) ), 
     3      reshape( (/0,0,0/), (/3,1/) ),sfls_punch_flag, punch=.true.)
        else
          call sfls_punch_addtodesign(
     1      reshape(real(globalderivatives, kind(1.0)), 
     2        (/size(globalderivatives), 1/) ), 
     3      reshape( (/0,0,0/), (/3,1/) ),sfls_punch_flag, punch=.true.)
        end if
        deallocate(globalderivatives)
        call sfls_punch_addtowdf(D, sfls_punch_flag, punch=.true.)
      end if       

      RETURN
C
9900  CONTINUE
C -- ERRORS
      RETURN
C
      END

!> \brief derivatives against each adp variable U11, U12,... in oriented cartesian space
!!
!! ## derivatives against each adp variable \f$U_{11}\f$, \f$U_{12}\f$... ##
!! \f$\mathbf{U_\text{cif}}\f$ is what crystals stores for U (same as cif file) \n
!! 1. First \f$\mathbf{U_\text{cif}}\f$ scaled to \f$\mathbf{U^*}\f$ using \f$\mathbf{B}\f$ (See: Acta Cryst. (2011). A67, 383-390, https://doi.org/10.1107/S0108767311018216) \n
!! 2. Changes \f$\mathbf{U^*}\f$ from crystal coordinate to Cartesian coordinates using \f$\mathbf{A}\f$ \n
!! 3. Rotate adp align principal axis with choice of axis using \f$\mathbf{R}\f$ \n
!! \f[ 
!!      \mathbf{U_\text{cart}} = \mathbf{R} \mathbf{A} \mathbf{B} \mathbf{U_\text{cif}} \mathbf{B}^t \mathbf{A}^t \mathbf{R}^t 
!! \f]
!!
!! Derivative is then (with \f$U_{xy}\f$ an element of \f$\mathbf{U}\f$):
!!   \f{align}{
!!        \mathbf{U_{\text{cart}}} &= \mathbf{R} \mathbf{A} \mathbf{B} \mathbf{U_\text{cif}} \mathbf{B}^t \mathbf{A}^t \mathbf{R}^t  \\ 
!!        \frac{\partial (\mathbf{U_{cart}})}{\partial U_\text{xy}} &= \frac{\partial (\mathbf{R} \mathbf{A} \mathbf{B} \mathbf{U_\text{cif}} \mathbf{B}^t \mathbf{A}^t \mathbf{R}^t)}{\partial U_\text{xy}}  \\ 
!!                          &=  \mathbf{R} \mathbf{A} \mathbf{B} \frac{\partial\mathbf{U_\text{cif}}}{\partial U_\text{xy}} \mathbf{B}^t \mathbf{A}^t \mathbf{R}^t  
!!   \f}
!!
!! \f$\sfrac{\partial\mathbf{U_{cif}}}{\partial U_{xy}}\f$ are defined as:
!! \f{align*}{
!!        \sfrac{\partial(\mathbf{U_\text{cif}})}{\partial U_{11}} &= \begin{pmatrix} 1 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 0 \end{pmatrix} \\\\
!!        \sfrac{\partial(\mathbf{U_\text{cif}})}{\partial U_{12}} &= \begin{pmatrix} 0 & 1 & 0 \\ 1 & 0 & 0 \\ 0 & 0 & 0 \end{pmatrix} \\\\
!!        &\vdots \\\\
!!        \sfrac{\partial(\mathbf{U_\text{cif}})}{\partial U_{33}} &= \begin{pmatrix} 0 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & 1 \end{pmatrix} 
!! \f}
!!
!! Now let's use fancy math to reduce the use of loops and matrix operations.
!! See Acta Cryst. (2011). A67, 383-390, https://doi.org/10.1107/S0108767311018216 again for vec operator
!!
!! Let \f$\vec{\cdot}\f$ be the \textit{vec} operator, then \f$ \vec{\mathbf{U}} = [ U_{11}, U_{21}, U_{31}, U_{12}, U_{22}, U_{32}, U_{13}, U_{23}, U_{33} ] \f$ (the columns of \f$\mathbf{U}\f$ are stacked in one vector). \n
!! We can rewrite equation 1 to \f$(\mathbf{R} \mathbf{A} \mathbf{B}) \otimes (\mathbf{R} \mathbf{A} \mathbf{B}) \vec{\mathbf{U}}_\text{cif}\f$ with \f$\otimes\f$ the kronecker operator \n
!! similarly for the derivative: 
!! \f[
!!   \frac{\partial (\vec{\mathbf{U}}_\text{cart})}{\partial U_\text{xy}} = (\mathbf{R} \mathbf{A} \mathbf{B}) \otimes (\mathbf{R} \mathbf{A} \mathbf{B}) \frac{\partial\vec{\mathbf{U}}_\text{cif}}{\partial U_\text{xy}} 
!! \f]
!! 
!! All the derivatives vectors are stacked to form a 2D matrix. this enable the calculation of all the derivatives in one call to a matrix multiplication,
!! \f[
!!   \partial\mathbf{U}_{\text{cif:} \vec{11}, \vec{22}, \vec{33}, \vec{23}, \vec{13}, \vec{12}} =  
!!   \begin{matrix}
!!     \frac{\partial (\vec{\mathbf{U}}_\text{cif})}{\partial U_\text{11}} & 
!!     \frac{\partial (\vec{\mathbf{U}}_\text{cif})}{\partial U_\text{22}} & 
!!     \frac{\partial (\vec{\mathbf{U}}_\text{cif})}{\partial U_\text{33}} & 
!!     \frac{\partial (\vec{\mathbf{U}}_\text{cif})}{\partial U_\text{23}} & 
!!     \frac{\partial (\vec{\mathbf{U}}_\text{cif})}{\partial U_\text{13}} & 
!!     \frac{\partial (\vec{\mathbf{U}}_\text{cif})}{\partial U_\text{12}} \\\\
!!
!!     1  &  0  &  0  &  0  &  0  &  0  \\\\
!!     0  &  0  &  0  &  0  &  0  &  1  \\\\
!!     0  &  0  &  0  &  0  &  1  &  0  \\\\
!!     0  &  0  &  0  &  0  &  0  &  1  \\\\
!!     0  &  1  &  0  &  0  &  0  &  0  \\\\
!!     0  &  0  &  0  &  1  &  0  &  0  \\\\
!!     0  &  0  &  0  &  0  &  1  &  0  \\\\
!!     0  &  0  &  0  &  1  &  0  &  0  \\\\
!!     0  &  0  &  1  &  0  &  0  &  0  
!!  \end{matrix}
!! \f]
!!
!! The final derivatives are obtained:
!!
!! \f[
!!   \partial\mathbf{U}_{\text{cart:} \vec{11}, \vec{22}, \vec{33}, \vec{23}, \vec{13}, \vec{12}}  = (\mathbf{R} \mathbf{A} \mathbf{B}) \otimes (\mathbf{R} \mathbf{A} \mathbf{B}) \partial\mathbf{U}_{\text{cif:} \vec{11}, \vec{22}, \vec{33}, \vec{23}, \vec{13}, \vec{12}} 
!! \f]
!!
      subroutine rabubar_derivs(R_M, RAB, dUcart)
      implicit none
      double precision, dimension(3,3), intent(in) :: R_M !< Rotation matrix orienting the principal axes of the adps
      double precision, dimension(9,6), intent(out) :: dUcart !< New derivatives of the adps in the new coordinate system
      double precision, dimension(3,3), intent(out) :: RAB !< transformation matrix
      
      INCLUDE 'XLST01.INC'
      INCLUDE 'STORE.INC'
      double precision, dimension(9,6) :: dUcif
      double precision, dimension(3,3) :: A_M, B_M
      double precision, dimension(9,9) :: kRAB

      ! no idea why it is necessary, maybe because of array shapes
      interface
          subroutine kronecker(k, a, b)
          ! calculate the kronecker product of a and b
          implicit none
          double precision, dimension(:,:), intent(in)  :: a, b
          double precision, dimension(:,:), intent(out) :: k
          end subroutine
      end interface
                    
            dUcif=0.0d0
            dUcif(1,1)=1.0d0 ! dU11
            dUcif(5,2)=1.0d0 ! dU22
            dUcif(9,3)=1.0d0 ! dU33
            dUcif(6,4)=1.0d0 ! dU23
            dUcif(8,4)=1.0d0 ! dU23
            dUcif(3,5)=1.0d0 ! dU13
            dUcif(7,5)=1.0d0 ! dU13
            dUcif(2,6)=1.0d0 ! dU12
            dUcif(4,6)=1.0d0 ! dU12
                    
            ! Ucif scaled to U*
            B_M=0.0d0
            B_M(1,1)=STORE(L1P2)
            B_M(2,2)=STORE(L1P2+1)
            B_M(3,3)=STORE(L1P2+2)
                           
            ! Orthogonalisation matrix (stored by rows, reshape fill column wise, hence the transpose)
            A_M=transpose(reshape(STORE(L1O1:L1O1+8), (/3,3/)))
             
            ! Calculation of all derivatives using the vec operator trick      
            RAB=matmul(matmul(R_M ,A_M), B_M)
            call kronecker(kRAB, RAB, RAB)
                          
            dUcart=matmul(kRAB, dUcif)

      end subroutine


!> \brief calculate derivatives given a rotation matrix R in cartesian space
!! 
!! \f[
!!   \partial\mathbf{U}_{\text{cart:} \vec{11}, \vec{22}, \vec{33}, \vec{23}, \vec{13}, \vec{12}}  = (\mathbf{R} \mathbf{A} \mathbf{B}) \otimes (\mathbf{R} \mathbf{A} \mathbf{B}) \partial\mathbf{U}_{\text{cif:} \vec{11}, \vec{22}, \vec{33}, \vec{23}, \vec{13}, \vec{12}} 
!! \f]
!!
      subroutine rabubar_eigenderivs(Q_M, dUcart)
      implicit none
      double precision, dimension(3,3), intent(in) :: Q_M !< Eigenvectors
      double precision, dimension(9,6), intent(out) :: dUcart !< New derivatives of the adps in the new coordinate system
      double precision, dimension(3,3) :: left !< transformation matrix
      
      INCLUDE 'XLST01.INC'
      INCLUDE 'STORE.INC'
      double precision, dimension(9,6) :: dUcif
      double precision, dimension(3,3) :: A_M, B_M
      double precision, dimension(9,9) :: kRAB

      ! no idea why it is necessary, maybe because of array shapes
      interface
          subroutine kronecker(k, a, b)
          ! calculate the kronecker product of a and b
          implicit none
          double precision, dimension(:,:), intent(in)  :: a, b
          double precision, dimension(:,:), intent(out) :: k
          end subroutine
      end interface
                    
            dUcif=0.0d0
            dUcif(1,1)=1.0d0 ! dU11
            dUcif(5,2)=1.0d0 ! dU22
            dUcif(9,3)=1.0d0 ! dU33
            dUcif(6,4)=1.0d0 ! dU23
            dUcif(8,4)=1.0d0 ! dU23
            dUcif(3,5)=1.0d0 ! dU13
            dUcif(7,5)=1.0d0 ! dU13
            dUcif(2,6)=1.0d0 ! dU12
            dUcif(4,6)=1.0d0 ! dU12
                    
            ! Ucif scaled to U*
            B_M=0.0d0
            B_M(1,1)=STORE(L1P2)
            B_M(2,2)=STORE(L1P2+1)
            B_M(3,3)=STORE(L1P2+2)
                           
            ! Orthogonalisation matrix (stored by rows, reshape fill column wise, hence the transpose)
            A_M=transpose(reshape(STORE(L1O1:L1O1+8), (/3,3/)))
             
            ! Calculation of all derivatives using the vec operator trick      
            left=matmul(matmul(transpose(Q_M) ,A_M), B_M)
            call kronecker(kRAB, left, left)
                          
            dUcart=matmul(kRAB, dUcif)

      end subroutine


CODE FOR XCVCTLS
!> \brief Restraints based on a tls model
!!
!! A TLS is calculated using all the atoms, then calculated ADPS are computed,
!! first m atoms are then restrain to the target Uij
      SUBROUTINE XCVCTLS(results)
      use, intrinsic :: iso_fortran_env, only : stdout=>output_unit
      use list26_mod
      use xssval_mod
      use store_mod, only: store, c_store, istore=>i_store
      implicit none

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
C--
      type(restraints_t), intent(inout), optional :: results
      real, dimension(12) :: A1

      REAL DIFF_VAL
      REAL MEAN_VAL
      
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST22.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XAPK.INC'
      include 'XUNITS.INC'
C
      EQUIVALENCE (O,A1(1))    ! Note well
      
      integer icpt, jcpt, kcpt, ncpt
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

C
      INCLUDE 'XRTLSC.INC'
      INCLUDE 'XIOBUF.INC'
      
      
      double precision, dimension(3) :: xyz
      double precision, dimension(6) :: adps
      double precision, dimension(:,:), allocatable :: occordinates !< coordinates in orthogonal space
      double precision, dimension(3) :: cog !< centre of gravity (crystal space)
      double precision, dimension(3) :: cogo !< centre of gravity (orthogonal space)
      double precision, dimension(3,3) :: OCM !< orthogonalisation coordinates matrix
      double precision, dimension(3,3) :: OUM !< orthogonalisation U's matrix
      integer napplied !< number of atoms on which the restraint is applied

      double precision DAA(20,20) !< normal matrix
      double precision DAR(21),DAI(20,20),DAII(6,20),DAS(20), ABdp(20)
      double precision aaa, bbb, ccc, ddd
      double precision anumb, del, dels, delu, rmsu, sfac
      double precision sum, sums, sumu
      double precision ufac
      integer info, jff, natom, natom2
      double precision WAdp(3,3),WBdp(3,3),WCdp(6), WDdp(3)
C
      character(len=17), dimension(6), parameter :: rdescription=(/
     &  'U11 - Utls11 == 0', 'U22 - Utls22 == 0', 'U33 - Utls33 == 0', 
     &  'U12 - Utls12 == 0', 'U23 - Utls23 == 0', 'U13 - Utls13 == 0' /) 
      
      logical flag
      
      integer, external :: kinv2, kinv2dp
      
      interface
        subroutine rsub08pp (xyz, co, dv)
          double precision, dimension(3), intent(in) :: xyz !< coordinates in orthogonal coordinates
          double precision, dimension(3), intent(in) :: co !< centre of libration in orthogonal coordinates
          double precision, dimension(6, 20), intent(out) :: dv !< calculated derivatives
        end subroutine
      end interface

      
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!      
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!      
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!      
C
C--SET UP A FEW CONSTANTS                                        
      napplied=nint(STORE(LCG+4))   ! The 'observed value' of the restraint
      if(napplied<=0) then
        napplied=nca
      else if(napplied>nca) then
        napplied=nca
      end if
       
      JA=LCA              ! Address of first parameter block header                                      
      !print *, 'nca ', NCA
      MCA=JA ! address of fisrt atom
C--SET UP THE ADDRESSES OF THE ATOMS    
                                
      JB=ISTORE(JA)             ! Address of next parameter block                                        
      JP=ISTORE(JA+6)           ! Address of first parameter (U11) for atom 1                                        
      JV=ISTORE(JB+6)           ! Address of first parameter (U11) for atom 2                                        

      JA=LCA
      flag=.false.
      do icpt=1, NCA
        IF(ABS(STORE(ISTORE(JA+16)+6))/=0.0) THEN ! check if atom is isotropic
          flag=.true.
          if(present(results)) then
            WRITE(CMON,'("{E",1X, "(",I0,")",1X, A)') 
     1        results%user_index, trim(results%restraint_text)
            CALL XPRVDU(NCVDU, 1,0)      
              WRITE(CMON,'("{E", 4X, A)') 'Error: atom is isotropic'
            CALL XPRVDU(NCVDU, 1,0)      
          end if
        end if
        ja=istore(ja)
      end do
      
      if(flag) return

      if(present(results)) then
          results%short_desc='Restraint Uij to a TLS model'
          results%groups=napplied
          call extend(results%subrestraints, napplied*6, .true.)
          JA=LCA
          do icpt=1, size(results%subrestraints)
             write(results%subrestraints(icpt)%description, '(A)') 
     &        rdescription(mod(icpt-1,6)+1)
              call extend(results%subrestraints(icpt)%atoms, 1, .true.)
              results%subrestraints(icpt)%atoms(1)%label=
     &            c_store(JA+2)
              results%subrestraints(icpt)%atoms(1)%serial=
     &            nint(store(JA+3))
     
             if(mod(icpt,6)==0) then
               JA=ISTORE(JA)
             end if
          end do
      end if

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!      
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!      
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!      
                
C---SET UP MATRIX TO ORTHOGONALISE COORDINATES
      kcpt=L1O1
      DO Icpt=1,3
         DO Jcpt=1,3
           OCM(Icpt,Jcpt)=STORE(kcpt)
           kcpt=kcpt+1
         end do
      end do
      OUM=0.
C---SET UP MATRIX TO ORTHOGONALISE U'S
      AAA=COS(real(STORE(L1P1+3), kind(1.0d0)))
      BBB=COS(real(STORE(L1P1+4), kind(1.0d0)))
      CCC=COS(real(STORE(L1P1+5), kind(1.0d0)))
      DDD=1.0d0+2.0d0*AAA*BBB*CCC-AAA**2-BBB**2-CCC**2
      DDD=SQRT(DDD)
      OUM(1,1)=SIN(real(STORE(L1P1+3), kind(1.0d0)))/(ddD*STORE(L1P1))
      OUM(2,2)=SIN(real(STORE(L1P1+4), kind(1.0d0)))/(ddD*STORE(L1P1+1))
      OUM(3,3)=SIN(real(STORE(L1P1+5), kind(1.0d0)))/(ddD*STORE(L1P1+2))
      OUM=matmul(OCM, OUM)
C---ZERO DERIVATIVES AND MATRICES
      Daa=0.0d0
      ABdp=0.0d0
C---CALCULATE LOCATION OF FIRST ATOM;  SET LOCATION OF
C   ORTHOGONAL COORDINATES
      cog=0.0d0
C---- CYCLE THROUGH ATOM LIST TO GET C.OF.G
      jb=LCA
      NATOM=0
      DO while(jb>0)
C----- INCLUDE ISOTROPIC ATOMS AT THIS STAGE
         NATOM=NATOM+1
         cog(1)=cog(1)+store(ISTORE(JB+16)+8)
         cog(2)=cog(2)+store(ISTORE(JB+16)+10)
         cog(3)=cog(3)+store(ISTORE(JB+16)+12)
         jb=istore(jb)
      end do
      cog(1)=cog(1)/real(NATOM, kind(1.0d0))
      cog(2)=cog(2)/real(NATOM, kind(1.0d0))
      cog(3)=cog(3)/real(NATOM, kind(1.0d0))

C------ ORTHOGONALISE CENTRE OF LIBRATION
      cogo=matmul(OCM, cog) ! CALL XMLTMM (OCM,cog,cogo,3,3,1)
      
C---CYCLE THROUGH ATOM LIST
      NATOM2=0
      JB=LCA
      allocate(occordinates(3,natom))
      DO JA=1,NATOM
C----- ORTHOGONAL COORDINATES AT JB
         xyz=store(ISTORE(JB+16)+8:ISTORE(JB+16)+12:2)
         occordinates(:,JA)=matmul(OCM,xyz)
         NATOM2=NATOM2+1
C---ORTHOGONALIZE U'S, STORING AS WC
         adps=store(ISTORE(JB+16)+14:ISTORE(JB+16)+14+11:2)
         CALL RSUB10DP (WBdp,adps) ! copy 6x1 adps to 3x3 WB  
         if(present(results) .and. JA<=napplied) then       
           results%subrestraints((JA-1)*6+1)%atoms(1)%adps_crys=WBdp
         end if
         WAdp=matmul(OUM, WBdp) ! CALL XMLTMM (OUM,WB,WA,3,3,3)         
         WBdp=matmul(WAdp, transpose(OUM)) ! CALL XMLTMT (WA,OUM,WB,3,3,3)
         CALL RSUB09DP (WBdp,WCdp)
C---SET UP DERIVATIVES FOR THIS ATOM
         daii=0.0d0
         CALL RSUB08PP (occordinates(:,JA), cogo, DAII)
C---ACCUMULATE L.H.S. AS AA, R.H.S. AS AB
         DO Ncpt=1,6
            DO Icpt=1,20
              DO Jcpt=Icpt,20
                DAA(Icpt,Jcpt)=DAA(Icpt,Jcpt)+
     1             DAII(Ncpt,Icpt)*DAII(Ncpt,Jcpt)
              end do
              ABdp(Icpt)=ABdp(Icpt)+DAII(Ncpt,Icpt)*WCdp(Ncpt)
            end do
          end do
C---RESET COUNTERS
         JB=istore(JB)
      end do
      IF (NATOM2.LT.4) THEN
         WRITE (CMON,950) NATOM2
         CALL XPRVDU (NCVDU,1,0)
950      FORMAT (' Insufficient anisotropic atoms for tls -',I5)
         if(present(results)) then
           deallocate(results%subrestraints)
           results%groups=0
         end if
         return
      END IF


C----- SCALE THE NORMAL MATRIX TO GIVE DIAGONAL ELEMENTS OF 1.
C     FIND THE SCALE FACTORS , MAXIMUM=100
      DO Icpt=1,20
         DAS(Icpt)=1.0D0/max(sqrt(DAA(Icpt,Icpt)),.01D0)
      end do
C---FILL OUT AA
      DO Icpt=1,20
C---- RHS
         ABdp(Icpt)=ABdp(Icpt)*DAS(Icpt)
         DO Jcpt=1,Icpt
             DAA(Jcpt,Icpt)=DAA(Jcpt,Icpt)*DAS(Icpt)*DAS(Jcpt)
             DAA(Icpt,Jcpt)=DAA(Jcpt,Icpt)
         end do
      end do
C---SOLVE NORMAL EQUATIONS, STORING INVERSE MATRIX AS AI AND RESULTS AS
      CALL RLTNT(abdp, DAA, DAR, DAI, info)
      if(info/=0) then
        if(present(results)) then
          write(cmon, '("{I", 1X, A)') 'The TLS restraint is aborted'
          CALL XPRVDU(NCVDU, 1,0)      
          deallocate(results%subrestraints)
        end if
        return
      end if
      
C----- RESCALE THE RESULTS
       DAR(1:20)=DAR(1:20)*SNGL(DAS(1:20))
       
       allocate(results%description(4))
       write(results%description(1),'(a)') 'L tensor:'
       write(results%description(2), '(1P,6(E10.2,1X))') Dar(1:6)
       write(results%description(3),'(a)') 'T tensor:'
       write(results%description(4), '(1P,6(E10.2,1X))') Dar(7:12)

C---INVERT OUM TO GET MATRIX FOR CONVERSION OF U'S BACK TO CRYSTAL AXES
      I=KINV2dp(3,OUM,WAdp,9,0,WCdp,WDdp,3)
      OUM=WAdp
C---CALCULATE AND OUTPUT OBSERVED AND CALCULATED TEMPERATURE FACTORS

C--SET UP THE ACCUMULATION CONSTANTS FOR THE SCAN THROUGH THE ATOMS
      DELU=0.
      SUMU=0.
      DELS=0.
      SUMS=0.
      ANUMB=0.
C--LOOP OVER EACH ATOM IN TURN
      JB=LCA
      DO 2500 JA=1,napplied
         !IF (ABS(STORE(ISTORE(JA+16)+6))-UISO<0) then
         !   print *, 'Ooops'
         !   cycle
         !end if
C--CHECK IF THE ATOM IS ISOTROPIC
         adps=store(ISTORE(JB+16)+14:ISTORE(JB+16)+14+11:2)
         CALL RSUB08PP(occordinates(:,ja), cogo, DAII)
         WCdp=matmul(DAII, DAR(1:20)) ! CALL XMLTMM (DV,AR,WC,6,20,1)
         CALL RSUB10DP (WAdp,WCdp) ! 6x1 (WC)  to 3x3 (WA)
         WBdp=matmul(OUM, WAdp) !CALL XMLTMM (OUM,WA,WB,3,3,3)
         WAdp=matmul(WBdp, transpose(OUM)) ! CALL XMLTMT (WB,OUM,WA,3,3,3)
         CALL RSUB09DP (WAdp,WCdp) ! 3x3 to 6x1

         if(present(results)) then      
           do jcpt=1, 6 
             results%subrestraints((JA-1)*6+jcpt)%
     1         atoms(1)%adps_target=WAdp
             results%subrestraints((JA-1)*6+jcpt)%rvalue=adps(jcpt)
             results%subrestraints((JA-1)*6+jcpt)%rtarget=wcdp(jcpt)
           end do
         end if


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        do jcpt=1, 6
          a1=0.0
          a1(jcpt)=1.0
          a1(7:12)=a1(1:6)
            
          JP=ISTORE(JB+6)
          JD=ISTORE(JB+16)
          JX=JP ! JX used in XADUIJ
          JO=JB ! JO used in XADUIJ
          !print *, 'jb, res ', jb, jcpt
          CALL XADUIJ  

C--CALCULATE THE MEAN VALUE AND THE DIFFERENCE                       
           DIFF_VAL = adps(jcpt)-wcdp(jcpt)
           MEAN_VAL = adps(jcpt)+wcdp(jcpt)
                          
          STORE(LCG+4)=0.5*(MEAN_VAL)                                  
          STORE(L22PD+2)=-DIFF_VAL ! Difference between restraint target (DUMP) and computed from current parameters (D)
          STORE(L22PD+1) = STORE(LCG+3)                                     
          CALL XFMPDQ                                                      

C--CLEAR THE P.D. SLOSTS FOR THE NEXT COORD.         
          JQ=ISTORE(JB+6)
          DO JX=1,6
              STORE(JQ+2)=0.
              JQ=ISTORE(JQ)
          end do
        end do
                          
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

C--ACCUMULATE THE TOTALS FOR THIS ATOM
         DO 2400 Kcpt=1,6
            DEL=ABS(adps(Kcpt)-WCdp(Kcpt))
            SUM=ABS(adps(Kcpt))
            DELS=DELS+DEL*DEL
            SUMS=SUMS+SUM*SUM
            DELU=DELU+DEL
            SUMU=SUMU+SUM
            ANUMB=ANUMB+1.
2400     CONTINUE
         JB=istore(JB)
2500  CONTINUE
C--COMPUTE AND PRINT THE TOTALS FOR ALL THE ATOMS
      UFAC=DELU/SUMU*100.0d0
      SFAC=SQRT(DELS/SUMS)*100.0d0
      RMSU=SQRT(DELS/ANUMB)
!      IF (ISSPRT.EQ.0) WRITE (NCWU,2550) UFAC,SFAC,RMSU
!      WRITE (CMON,2550) UFAC,SFAC,RMSU
!      CALL XPRVDU (NCVDU,4,0)
!2550  FORMAT (/6X,
!     1'          R1-Factor for U''S = ',F7.2,/6X,
!     2'         R^2-Factor for U''S = ',F7.2,/6X,
!     3' R.M.S. discrepancy for U''S = ',2F7.4)
C


      RETURN
      END


CODE FOR RSUB08
!> Calculate derivatives in orthogonal coordinates given the centre of libration
      SUBROUTINE RSUB08PP (xyz, co, dv)
C---CALCULATE DERIVATIVES FOR ATOM WHOSE ORTHOGONAL COORDINATES
C
C--
      implicit none
      INCLUDE 'STORE.INC'
      !INCLUDE 'XRTLSC.INC'
      double precision, dimension(3), intent(in) :: xyz !< coordinates in orthogonal coordinates
      double precision, dimension(3), intent(in) :: co !< centre of libration in orthogonal coordinates
      double precision, dimension(6, 20), intent(out) :: dv !< calculated derivatives
      
      double precision x, y, z, a, b, c, d, e, f
      integer i
      
      dv=0.0d0
C
      X=xyz(1)-CO(1)
      Y=xyz(2)-CO(2)
      Z=xyz(3)-CO(3)
      A=X*X
      B=Y*Y
      C=Z*Z
      D=Y*Z
      E=X*Z
      F=X*Y
C---DERIVATIVES W.R.T. T'S
      DO I=1,6
        DV(I,I)=1.0d0
      end do
C---DERIVATIVES W.R.T. L'S
      DV(1,8)=C
      DV(1,9)=B
      DV(1,10)=-2.0d0*D
      DV(2,7)=C
      DV(2,9)=A
      DV(2,11)=-2.0d0*E
      DV(3,7)=B
      DV(3,8)=A
      DV(3,12)=-2.0d0*F
      DV(4,7)=-D
      DV(4,10)=-A
      DV(4,11)=F
      DV(4,12)=E
      DV(5,8)=-E
      DV(5,10)=F
      DV(5,11)=-B
      DV(5,12)=D
      DV(6,9)=-F
      DV(6,10)=E
      DV(6,11)=D
      DV(6,12)=-C
C---DERIVATIVES W.R.T. S'S
      DV(1,16)=2.0d0*Z
      DV(1,19)=-2.0d0*Y
      DV(2,14)=-2.0d0*Z
      DV(2,20)=2.0d0*X
      DV(3,15)=2.0d0*Y
      DV(3,18)=-2.0d0*X
      DV(4,13)=-X
      DV(4,14)=Y
      DV(4,15)=-Z
      DV(4,17)=-2.0d0*X
      DV(5,13)=2.0d0*Y
      DV(5,16)=-X
      DV(5,17)=Y
      DV(5,18)=Z
      DV(6,13)=-Z
      DV(6,17)=Z
      DV(6,19)=X
      DV(6,20)=-Y
      RETURN
      END
