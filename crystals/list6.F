C$Rev::                                      $:  Revision of last commit
C$Author::                                   $:  Author of last commit
C$Date::                                     $:  Date of last commit
C $Log: list6.F,v $
C Revision 1.24  2013/12/06 12:51:31  djw
C Oops.
C
C Revision 1.23  2013/12/06 12:44:52  djw
C Problem spooed by Arie.  RATIO was rouinded to 1 sig fig during packing with JCODE, so that filtering
C by LIST 28 was not compatible with JANA (or any code using more precision).  Also noted that no special
C care was taken if sigmas not input (see SLANT.OUT) In the absence of sigma, RATIO is set to 3.01, ie
C all reflections accepted at 3 sigma level
C
C Revision 1.22  2011/08/31 15:43:24  rich
C Remove uninitialised variable from KALLOW
C
C Revision 1.21  2011/05/13 16:03:34  djw
C Fix the calls to kallow and their effect on the fcf listing
C
C Revision 1.20  2011/05/13 11:16:51  djw
C Calls to Kallow now return a key to the test which failed and a value to indicate if it was Max or Min. The argument of KALLOW must be a variable
C
C Revision 1.19  2010/07/21 15:57:32  djw
C Include list type in PUNCH 6 C
C
C Revision 1.18  2009/07/31 12:40:25  djw
C Remove the patch that sorted out -ve JCODES - it was fouling up the packing/unpacking of Ratio/JCODE.  Patch left in place for future reference.
C In the future, we should look at computing RATIO on the fly from I and sigma
C
C Revision 1.17  2009/07/21 13:41:35  djw
C test
C
C Revision 1.16  2009/07/20 10:57:22  djw
C Retro-fix for unpacking Ratio/JCODE. If Fo was -ve, JCODE also becomes -ve.  Fix (for
C  cases seen anyway) by adding +10
C
C Revision 1.15  2005/02/25 17:25:20  stefan
C 1. Added some preprocessor if defined lines for the mac version.
C
C Revision 1.14  2005/01/23 08:29:11  rich
C Reinstated CVS change history for all FPP files.
C History for very recent (January) changes may be lost.
C
C Revision 1.2  2004/12/13 16:16:08  rich
C Changed GIL to _GIL_ etc.
C
C Revision 1.1.1.1  2004/12/13 11:16:09  rich
C New CRYSTALS repository
C
C Revision 1.13  2003/09/12 15:13:24  rich
C Don't output thermometer in GIL version.
C
C Revision 1.12  2003/08/05 11:11:12  rich
C Commented out unused routines - saves 50Kb off the executable.
C
C Revision 1.11  2003/05/07 12:18:54  rich
C
C RIC: Make a new platform target "WXS" for building CRYSTALS under Windows
C using only free compilers and libraries. Hurrah, but it isn't very stable
C yet (CRYSTALS, not the compilers...)
C
C Revision 1.10  2003/02/14 17:09:02  djw
C Extend codes to work wih list 6 and list 7.  Note that sfls, calc and
C recine have the parameter ityp06, which corresponds to the types
C pickedip for lists 6 and 7  from the command file
C
C Revision 1.9  2003/01/15 15:26:38  rich
C Removal of NCAWU calls throught the standard SFLS refinement instruction. If
C anywhere will benefit from less IO, it's here.
C
C Revision 1.8  2002/11/29 15:29:30  rich
C Don't print 0 Processing 100% message in GID version.
C
C Revision 1.7  2002/03/29 00:10:38  richard
C Reduce number of steps in progress bar output (from 50 to 20).
C
C Revision 1.6  2001/05/31 16:39:48  richard
C RIC: New processing of SLICES and CONDITIONS in KALLOW.
C
C Revision 1.5  2001/02/26 10:28:02  richard
C RIC: Added changelog to top of file
C
C     H              K              L              /FO/           SQRTW
C     /FC/           PHASE          A-PART         B-PART         TBAR
C     /FOT/          ELEMENTS       SIGMA(/FO/)    BATCH          INDICES
C     BATCH/PHASE    SINTH/L**2     FO/FC          JCODE          SERIAL
C     RATIO          THETA          OMEGA          CHI            PHI
C     KAPPA          PSI            CORRECTIONS    FACTOR1        FACTOR2
C     FACTOR3        RATIO/JCODE    NOTHING
C
C
CODE FOR XPRT6C
      SUBROUTINE XPRT6C(lstno, M1)
C--PRINT LIST 6 IN COMPRESSED FORMAT
C
C  M1  IF ZERO OR LESS THAN ZERO STRUCTURE FACTORS ARE PRINTED ON
C      ON THE SCALE OF /FO/, ELSE ON THE SCALE OF /FC/
C
C--
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
C
cdjwjul2010 - add lstno
      CALL XPRT6Q(lstno,M1,IPAGE(4)-9,3)
      RETURN
      END
C
CODE FOR XPRT6Q
      SUBROUTINE XPRT6Q(IULN,M1,NL,ICOL3)
C--PRINT LIST 6 IN COMPRESSED FORMAT
C
C  IULN    THE LIST TYPE TO BE PRINTED.
C  M1      IF ZERO OR LESS THAN ZERO STRUCTURE FACTORS ARE PRINTED ON
C          ON THE SCALE OF /FO/, ELSE ON THE SCALE OF /FC/
C  NL      THE NUMBER OF LINES PER PAGE
C  ICOL3   THE NUMBER OF COLUMNS PER PAGE (THIS IS CONSTRAINED
C          IN THE RANGE 1 TO 3).
C
C--
      INCLUDE 'ICOM06.INC'
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST06.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLST50.INC'
      INCLUDE 'XCARDS.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QLST06.INC'
C
C--ENSURE THAT THE NUMBER OF COLUMNS/PAGE DOES NOT EXCEED 3
      ICOL=MIN0(ICOL3,3)
C--CHECK THAT THERE ARE SOME COLUMNS ON THE PAGE
      IF(ICOL)1000,1000,1050
C--INSERT THE DEFAULT NUMBER OF COLUMNS  -  3
1000  CONTINUE
      ICOL=3
C--CHECK IF LIST 6 IS AVAILABLE FOR PRINTING
1050  CONTINUE
      IF(KPRTLN(IULN,I))3400,1100,1100
C--ALL OKAY  -  LOAD LIST 50 AND THE RECORD FOR THE REQUIRED LIST TYPE
1100  CONTINUE
      CALL XFAL50
      CALL XLL50R(IULN+LSTOFF)
      INCLUDE 'IDIM06.INC'
C--SET THE POINTERS TO THE SECOND RECORD  -  CONTAINS THE KEYWORDS
      LN=IULN
      IREC=0
      CALL XDIRFL(4,ICOM06,IDIM06)
C--CLEAR THE CORE AGAIN
      CALL XRSL
      CALL XCSAE
C--FIND THE NUMBER AND ADDRESS OF THE KEYWORDS
      KC=ISTORE(LR62D+1)+LR62
      KD=ISTORE(LR62D+3)
C--ALLOCATE SPACE TO HOLD THE KEYWORDS
      KA=NFL
      KB=3
      I=KCHNFL(KB*KD)
C--FORM A4 CHARACTER STRINGS FROM THE KEYWORDS
      J=KA
      DO 1150 I=1,KD
      CALL XFA4CS(STORE(KC+1),STORE(J),KB*NWCHAR)
      KC=KC+ISTORE(LR62D+2)
      J=J+KB
1150  CONTINUE
C--SET UP THE SCALING POINTERS INITIALLY
      I=0
      A=1.
      C=1.
C--CHECK IF THIS IS A LIST 6
Cdjwjan03 - LOAD A LIST 5 ANYWAY IF IT EXISTS
C      IF(IULN-6)1400,1250,1400
C--CHECK IF THERE IS A LIST 5 STORED
1250  CONTINUE
      CALL XRLIND(5,I,J,K,L,M,STORE(NFL))
C--CHECK THE DISC ADDRESS
      IF(J)1400,1400,1300
C--THERE IS A LIST 5 STORED  -  LOAD IT INTO CORE
1300  CONTINUE
      CALL XFAL05
      IF ( IERFLG .LT. 0 ) GO TO 9900
      A=1.
      C=STORE(L5O)
C--CHECK THE OUTPUT SCALE REQUIRED
      IF(M1)1400,1400,1350
C--OUTPUT IS ON THE SCALE OF /FO/, NOT THE SCALE OF /FC/
1350  CONTINUE
      C=1.
      A=1./STORE(L5O)
C--SET UP THE PROCESSING OF LIST 6
1400  CONTINUE
      CALL XFLT06(IULN,0)
      CALL XFAL28
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--CHECK IF THERE IS A LIST ONE STORED
      IF(KEXIST(1))1500,1500,1450
C--LOAD LIST 1
1450  CONTINUE
      CALL XFAL01
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--PRINT THE DETAILS RECORD
1500  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1550)
      ENDIF
1550  FORMAT(' Quantity',12X,'Minimum',8X,'Maximum',7X,'Mean value',
     2 4X,'R.M.S. value',/)
C--LOOP OVER EACH DETAIL STORED
      M6DTL=L6DTL
      DO 1850 I=2,N6DTL
      KC=KA+KB-1
C--CHECK IF THIS DETAIL IS SET
      IF(STORE(M6DTL+3)-ZERO)1600,1700,1700
C--NOT SET  -  PRINT THE CAPTION AND IGNORE IT
1600  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1650)(ISTORE(J),J=KA,KC)
      ENDIF
1650  FORMAT(2X,3A4,4X,'No details available')
      GOTO 1800
C--PRINT THE DETAILS
1700  CONTINUE
      K=M6DTL+MD6DTL-1
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1750)(ISTORE(J),J=KA,KC),(STORE(J),J=M6DTL,K)
      ENDIF
1750  FORMAT(2X,3A4,2X,6E15.6)
C--UPDATE FOR THE NEXT PARAMETER
1800  CONTINUE
      M6DTL=M6DTL+MD6DTL
      KA=KA+KB
1850  CONTINUE
C--CHECK IF THIS LIST TYPE 6
      IF(IULN-6)2000,1900,2000
C--PRINT THE R VALUE ETC.
1900  CONTINUE
      J=NINT(STORE(L6P))
      M6P=L6P+2
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1950)J,(STORE(I+1),I=L6P,M6P)
      ENDIF
1950  FORMAT(/,' After ',I5,
     2 '  Structure factor/refinement calculation(s)',//,' R = ',F6.2,
     3 5X,'Weighted R = ',F6.2,5X,'Minimisation function = ',E15.6)
C--ASSIGN THE NUMBER OF COEFFICIENTS TO BE PRINTED PER REFLECTION
2000  CONTINUE
      NW=6
      N=NW+NW+NW
      ASSIGN 2050 TO NRET
C--SET UP A PRINT BUFFER IN CORE
      JA=NFL
      LN=IULN
      IREC=1001
      M=KCHNFL(NW*NL*ICOL)
C--RESET THE CONSTANTS FOR THE BEGINNING OF A PAGE
2050  CONTINUE
      K=NL
      J=K+NL
      I=J+NL
      L=JA
      M=JA
C--FETCH THE NEXT REFLECTION
2100  CONTINUE
      IF(KFNR(0))2600,2150,2150
C--MOVE THE REFLECTION FROM THE INPUT BUFFER
2150  CONTINUE
      ISTORE(L)=NINT(STORE(M6))
      ISTORE(L+1)=NINT(STORE(M6+1))
      ISTORE(L+2)=NINT(STORE(M6+2))
      STORE(L+3)=STORE(M6+3)*A
      STORE(L+4)=STORE(M6+5)*C
      STORE(L+5)=STORE(M6+6)*RTD
      L=L+N
      I=I-1
      J=J-1
      K=K-1
C--CHECK IF THE COLUMN IS FULL
      IF(K)2300,2200,2100
C--END OF THE FIRST COLUMN  -  CHECK IF WE SHOULD ONLY PRINT ONE COLUMN
2200  CONTINUE
      IF(ICOL-1)2250,3150,2250
C--MORE THAN ONE COLUMN  -  RETURN FOR MORE REFLECTIONS
2250  CONTINUE
      M=M+NW
      L=M
      GOTO 2100
C--END OF THE SECOND OR THIRD COLUMNS  -  FIND WHICH
2300  CONTINUE
      IF(J)2400,2350,2100
C--END OF THE SECOND COLUMN  -  CHECK IF WE ARE ONLY PRINTING 2
2350  CONTINUE
      IF(ICOL-2)2250,2950,2250
C--MORE THAN TWO COLUMNS  -  CHECK FOR THE END OF A PAGE
2400  CONTINUE
      IF(I)2450,2450,2100
C--END OF A PAGE WITH THREE COLUMNS ON IT  -  PRINT THEM
2450  CONTINUE
      L=L-N
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2500)
2500  FORMAT('1',/,
     2 3(7X,'H',3X,'K',3X,'L',4X,'/FO/',4X,'/FC/',3X,'Phase'),/)
      WRITE(NCWU,2550)(ISTORE(NX),ISTORE(NX+1),ISTORE(NX+2),
     2 STORE(NX+3),STORE(NX+4),STORE(NX+5),NX=JA,L,NW)
      ENDIF
2550  FORMAT((3(4X,3I4,3F8.1)))
      GOTONRET,(2050,2700,3400,3050)
C
C--LAST REFLECTION MARKER FOUND
2600  CONTINUE
      M=NL-I
C--CHECK IF THERE ANY ROWS WITH THREE COLUMNS TO PRINT
      IF(M)2900,2900,2650
C--PRINT ROWS WITH THREE COLUMNS
2650  CONTINUE
      ASSIGN 2700 TO NRET
      GOTO 2450
C--RETURN AFTER PRINTING 3 COLUMNS  -  RESET TO PRINT 2
2700  CONTINUE
      ASSIGN 3400 TO NRET
      L=L+NW
C--CHECK IF THERE ARE ANY ROWS WITH TWO COLUMNS TO PRINT
2750  CONTINUE
      IF(I)2800,2800,2850
C--END OF 2 COLUMN PRINT - EXIT FOR 2 AND 3 COLUMNS, PRINT 1 FOR 1 AND 2
2800  CONTINUE
      GOTONRET,(2050,2700,3400,3050)
C--PRINT THE NEXT LINE OF TWO COLUMNS
2850  CONTINUE
      M=L+NW
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2550)(ISTORE(NX),ISTORE(NX+1),ISTORE(NX+2),
     2 STORE(NX+3),STORE(NX+4),STORE(NX+5),NX=L,M,NW)
      ENDIF
      I=I-1
      L=L+N
      GOTO 2750
C
C--NO ROWS WITH THREE COLUMNS
2900  CONTINUE
      ASSIGN 3050 TO NRET
C--COMPUTE THE NUMBER OF ROWS WITH TWO COLUMNS TO PRINT
2950  CONTINUE
      I=NL-J
C--CHECK IF THERE ANY ROWS WITH ONLY TWO COLUMNS
      IF(I)3100,3100,3000
C--NEW PAGE CAPTION REQUIRED BEFORE WE START
3000  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2500)
      ENDIF
      L=JA
      GOTO 2750
C--ASSIGN THE EXIT VARIABLE AFTER PRINTING THE 2 COLUMN ROWS
3050  CONTINUE
      ASSIGN 3400 TO NRET
      GOTO 3250
C
C--ONLY ROWS WITH ONE COLUMN TO PRINT
3100  CONTINUE
      ASSIGN 3400 TO NRET
C--COMPUTE THE NUMBER OF 1 COLUMN ROWS TO BE PRINTED
3150  CONTINUE
      J=NL-K
      IF(J)3400,3400,3200
C--CAPTION FOR THE NEW PAGE WITH ONLY ONE COLUMN ON IT
3200  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2500)
      ENDIF
      L=JA
C--CHECK FOR THE END OF THE PAGE
3250  CONTINUE
      IF(J)3300,3300,3350
C--END OF THE PAGE  -  EXIT NOW
3300  CONTINUE
      GOTONRET,(2050,2700,3400,3050)
C--PRINT THE NEXT LINE WITH ONE COLUMN ON IT
3350  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2550)ISTORE(L),ISTORE(L+1),ISTORE(L+2),STORE(L+3),
     2 STORE(L+4),STORE(L+5)
      ENDIF
      L=L+N
      J=J-1
      GOTO 3250
C--A FEW SPARE LINES AT THE END
3400  CONTINUE
      CALL XLINES
      RETURN
C
9900  CONTINUE
C -- ERRORS
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 9905 )
      WRITE ( CMON, 9905 )
      CALL XPRVDU(NCVDU, 1,0)
9905  FORMAT ( 1X , 'Printing of list 6 abandoned' )
      RETURN
      END
C
C----- L6W = -1 FOR M/T; +1 FOR DISK
CODE FOR XSWP06
      SUBROUTINE XSWP06(IULN,MEDIUM)
C--CHECK IF THE CURRENT OUTPUT MEDIUM IS WHAT IS REQUIRED FOR LIST 6
C
C  IULN    THE LIST TYPE BEING PROCESSED.
C  MEDIUM  THE NEW MEDIUM FLAG :
C
C          -1  M/T
C           0  AS BEFORE.
C          +1  DISC.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLST06.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CHECK WHAT IS REQUIRED NOW
      IF(MEDIUM)1000,1300,1050
C--M/T REQUIRED  -  CHECK WHERE WE ARE
1000  CONTINUE
      IF(L6W)1300,1100,1100
C--DISC REQUIRED  -  CHECK WHERE WE ARE NOW
1050  CONTINUE
      IF(L6W)1100,1300,1300
C--OUTPUT THE DATA TO THE NEW MEDIUM
1100  CONTINUE
      CALL XRSL
      CALL XCSAE
C--LOAD THE OLD LIST FOR READING
      CALL XFLT06(IULN,0)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--SET UP THE NEW LIST FOR OUTPUT
      CALL XSTR06(IULN,MEDIUM,0,1,0)
C--LOAD THE NEXT REFLECTION
1150  CONTINUE
      IF(KLDRNR(I))1250,1200,1200
C--STORE THE NEXT REFLECTION
1200  CONTINUE
      CALL XSLR(1)
      GOTO 1150
C--TERMINATE THE TRANSFER
1250  CONTINUE
      CALL XERT(IULN)
C--AND NOW RETURN
1300  CONTINUE
C -- NORMAL AND ERROR RETURN
9900  CONTINUE
      RETURN
      END
C
CODE FOR XFAL06
      SUBROUTINE XFAL06(IULN, IOWF)
C--SET UP LIST 6 FOR READING FROM THE DISC, AND POSSIBLY FOR REWRITING
C
C  IOWF  THE WRITE/OVERWRITE FLAG :
C
C        -1  ATTEMPT AN OVERWRITE.
C         0  READ ONLY.
C        +1  CAREFUL UPDATE ONLY.
C
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
C--
C
C--CALL THE MAIN LOADING ROUTINE
      CALL XFLT06(IULN,IOWF)
      IF ( IERFLG .LT. 0 ) RETURN
C
C--INITIALISE LIST 28 IF POSSIBLE
      CALL XFAL28
      RETURN
      END
C
cCODE FOR XLDR06
c      SUBROUTINE XLDR06(IULN, IOWF)
cC--SET UP LIST 6 FOR READING FROM THE DISC, AND POSSIBLY FOR REWRITING.
cC  THIS ROUTINE DOES NOT INITIALISE LIST 28, AND SO SUCH CHECKING
cC  WILL BE PERFORMED.
cC
cC  IOWF  THE WRITE/OVERWRITE FLAG :
cC
cC        -1  ATTEMPT AN OVERWRITE.
cC         0  READ ONLY.
cC        +1  CAREFUL UPDATE ONLY.
cC
cC--
cC
cC--CALL THE MAIN LOADING ROUTINE
c      CALL XFLT06(IULN,IOWF)
c      RETURN
c      END

CODE FOR XFLT06
      SUBROUTINE XFLT06(IULN,IOWF)
C--SET UP A LIST FOR PROCESSING AS A LIST 6.
C
C  IULN  THE LIST TYPE TO BE SET UP FOR PROCESSING.
C  IOWF  THE WRITE/OVERWRITE FLAG :
C
C        -1  ATTEMPT AN OVERWRITE.
C         0  READ ONLY.
C        +1  CAREFUL UPDATE ONLY.
C
C--
      INCLUDE 'ISTORE.INC'
      INCLUDE 'ICOM06.INC'
      INCLUDE 'ICOM28.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST06.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLST28.INC'
      INCLUDE 'XPCK06.INC'
      INCLUDE 'XUSLST.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XTAPES.INC'
      INCLUDE 'XTAPED.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QLST06.INC'
      INCLUDE 'QLST28.INC'
C
      INCLUDE 'IDIM28.INC'
C--ZERO THE COMMON BLOCK FOR LIST 28
      CALL XZEROF(ICOM28(1),IDIM28)
      INCLUDE 'IDIM06.INC'
      LN6=IULN
C--LOAD THE DATA FROM THE DISC
      CALL XLDLST(IULN,ICOM06,IDIM06,IOWF)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--SET UP THE PACK COEFFICIENTS FOR THE INDICES
      IPACKR=KCOMP(1,I14,STORE(L6DMP),MD6DMP,N6DMP)
      IPACKW=IPACKR
C--SET UP THE PHASE/BATCH PACK COEFFICIENTS
      IPHSER=KCOMP(1,I15,STORE(L6DMP),MD6DMP,N6DMP)
      IPHSEW=IPHSER
C -- FIND IF THE RATIO AND JCODE HAVE BEEN PACKED
      JCDRAR = KCOMP ( 1 , I31 , STORE(L6DMP) , MD6DMP , N6DMP )
      JCDRAW = JCDRAR
C--SET THE POINTER TO THE CORE BUFFER
      M6=L6
C--CHECK IF THE INPUT IS FROM M/T
      IF(L6D)1000,1000,1050
C--INPUT IS FROM M/T  -  SET UP A BUFFER
1000  CONTINUE
      CALL XIMTR(MD6D)
C--REWIND THE INPUT TAPE
      REWINDMTA
C--SET THE POINTERS TO THE DISC INPUT BUFFER
1050  CONTINUE
      M6R=L6R
      L6R=L6D
      N6R=N6D
C--CONVERT THE DISC POINTERS TO ABSOLUTE VALUES
      CALL XABP06(1)
C--CHECK IF THIS OPERATION ALSO INVOLVES A WRITE TO THE DISC
      IF(IOWF)1100,1150,1100
C--OUTPUT IS TO BE GENERATED
1100  CONTINUE
      CALL XSTR06(IULN,0,IOWF,-1,0)
C--AND NOW RETURN
1150  CONTINUE
      CALL XZEROF(STORE(M6),MD6)
C -- NORMAL AND ERROR EXIT
9900  CONTINUE
      RETURN
      END
C
cCODE FOR XEND06
c      SUBROUTINE XEND06
cC--TERMINATE THE TRANSFER OF LIST 6 REFLECTION DATA TO DISC
cC
cC--
cC
cC--CALL THE TERMINATION ROUTINE
c      CALL XERT(6)
c      RETURN
c      END

CODE FOR XERT
      SUBROUTINE XERT(IULN)
C--TERMINATE THE OUTPUT OF LIST TYPE 6 TO THE DISC
C
C  IULN    THE TYPE OF LIST BEING OUTPUT AS A LIST 6.
C
C--
C
C
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLST06.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XTAPES.INC'
      INCLUDE 'XTAPED.INC'
      INCLUDE 'XIOBUF.INC'
C
C
C
C
C--SET THE LIST TYPE
      LN=IULN
      IREC=0
C--SET THE OUTPUT FLAG
      JTYPE=1
C--CHECK FOR OUTPUT TO M/T
      IF(L6W)1000,1000,1050
C--OUTPUT TO M/T  -  FINISH IT OFF
1000  CONTINUE
      CALL XTMTW(MTB)
      CALL XTMTR(MTA)
C--SWITCH UNITS
      I=MTA
      MTA=MTB
      MTB=I
      JTYPE=2
C--REWRITE THE LIST DETAILS TO DISC
1050  CONTINUE
      KA=L6W
      KB=N6W
      L6W=M6W
      N6W=1
C--MARK THE CURRENT LIST AS BEING UPDATED NOW
      CALL XMKOWF(IULN,1)
C--REWRITE THE DETAILS TO DISC
      CALL XSTR06(IULN,0,-1,-1,-1)
C--RESET THE POINTERS
      L6W=KA
      N6W=KB
C--ALTER THE WRITE/OVERWRITE FLAG
      CALL XMKOWF(IULN,0)
C--ALTER THE ERROR STATUS
      CALL XALTES(IULN,1)
C--CHECK FOR M/T OUTPUT
      IF(L6W .LE. 0 ) THEN
C--PRINT THE FILE NAME NOW CURRENT
1100    CONTINUE
        IF (ISSPRT .EQ. 0) WRITE(NCWU,1200)MTA
1200    FORMAT (' The updated reflections are now on UNIT ', I2 )
C--AND NOW RETURN
      ENDIF
1250  CONTINUE
      RETURN
      END
C
CODE FOR XSTR06
      SUBROUTINE XSTR06(IULN,MTFLAG,IOWF,INEW,IMTBUF)
C--INITIATE OUTPUT FOR A LIST 6
C
C  IULN    THE TYPE OF LIST TO OUTPUT.
C  MTFLAG  M/T OUTPUT FLAG :
C
C          -1  OUTPUT IS TO M/T
C           0  OUTPUT IS AS DEFINED BY 'L6D'  -  I.E. SAME AS BEFORE.
C          +1  OUTPUT IS TO DISC.
C
C  IOWF    THE WRITE/OVERWRITE FLAG :
C
C          -1  OVERWRITE IF POSSIBLE.
C           0  OUTPUT A COMPLETELY NEW LIST.
C          +1  CAREFUL UPDATE.
C
C  INEW    THE NEW LIST FLAG :
C
C          -1  THIS IS NOT A NEW VERSION OF THIS LIST.
C           0  THIS IS A NEW LIST, WITH LINKS TO OTHER EXISTING LISTS.
C          +1  THIS IS A NEW LIST, WITH NO LINKS TO OTHER EXISTING
C              LISTS. THIS IS NORMALLY THE CASE WHEN THE LIST HAS JUST B
C              INPUT.
C
C  IMTBUF  THIS POINTER DETERMINES WHETHER AN M/T BUFFER IS SET IF REQUI
C
C          -1  DO NOT SET UP A BUFFER.
C           0  SET UP A BUFFER IF REQUIRED.
C
C
C--TO ALTER THE OUTPUT MEDIUM FROM THAT USED FOR INPUT, 'XFAL06' OR
C  'XFLT06' SHOULD BE CALLED WITH NO OUTPUT REQUESTED ('IOWF' SET TO 0),
C  AND THEN 'XSTR06' SHOULD BE CALLED TO NOMINATE THE OUTPUT MEDIUM.
C
C--
      INCLUDE 'HEADES.INC'
      INCLUDE 'ISTORE.INC'
      INCLUDE 'ICOM06.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST06.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUSLST.INC'
      INCLUDE 'XTAPES.INC'
      INCLUDE 'XTAPED.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QLST06.INC'
C
      LN6=IULN
C--ADJUST THE READ POINTERS DURING THIS OPERATION
      KA=L6R
      KB=M6R
      KC=N6R
C--INDICATE ONLY ONE READ RECORD
      L6R=M6R
      N6R=1
C--CHECK THE OUTPUT TYPE REQUIRED
      MTFLG=MTFLAG
      IF(MTFLG)1000,1050,1100
C--OUTPUT TO M/T
1000  CONTINUE
      KD=N6D
      N6D=0
      MTFLG=-1
      GOTO 1100
C--SAME AS BEFORE  -  CHECK THE PREVIOUS TYPE
1050  CONTINUE
      IF(L6D)1000,1000,1100
C--CONVERT ALL ADDRESSES IN THE MOVE BLOCK TO RELATIVE
1100  CONTINUE
      CALL XABP06(-1)
      INCLUDE 'IDIM06.INC'
C--INITIATE OUTPUT OF THE LIST
      CALL XWLSTD(IULN,ICOM06,IDIM06,IOWF,INEW)
C--RESET THE READ POINTERS
      L6R=KA
      M6R=KB
      N6R=KC
C--CHECK FOR OUTPUT TO M/T
      IF(MTFLG)1150,1250,1250
C--M/T OUTPUT  -  UPDATE THE CONTROL RECORD
1150  CONTINUE
      N6D=KD
      L6D=-1
C--FIND THE BLOCK ON DISC
      I=KFNDRI(IULN,-104,IADDR,IBUFF)
C--UPDATE THE NUMBER, LENGTH AND ADDRESS
      IBUFF(6)=N6D
      IBUFF(3)=MD0+IBUFF(5)*IBUFF(6)
      IBUFF(4)=-1
C--REWITE THE BLOCK
      CALL XUPF(IADDR,IBUFF(1),MD0)
C--UPDATE THE CORE POINTERS
      CALL XUDRH(IULN,-104,0,N6D)
C--CHECK IF THE OUTPUT AREA SHOULD BE CREATED
      IF(IMTBUF)1250,1200,1200
C--CREATE AN OUTPUT AREA
1200  CONTINUE
      CALL XIMTW(MD6D)
      REWINDMTB
C--SET THE POINTERS
1250  CONTINUE
      M6W=L6W
      L6W=L6D
      N6W=0
C--CONVERT THE POINTERS BACK TO ABSOLUTE
      CALL XABP06(1)
C--SET THE BUFFER TO ZERO INITIALLY
      CALL XZEROF(STORE(M6),MD6)
      RETURN
      END
C
CODE FOR KFNR
      integer function KFNR(state)
C--FETCH THE NEXT REFLECTION, CHECKING WITH LIST 28 THAT IT IS ALLOWED.
C
C----- state   0 FOR READ-ONLY
C              1 FOR READ-WRITE
C
C--RETURN VALUES OF 'KFNR' ARE :
C
C  -1  END OF THE REFLCTIONS.
C   0  REFLCTION READ TO BE USED, STORED AT 'M6'.
C
C--
      implicit none
      integer, intent(in) :: state
      integer :: iallow
      integer, external :: KLDRNR, kallow
      
C
C--FETCH THE NEXT REFLECTION
1000  CONTINUE
      IF(KLDRNR(state))1100,1050,1050
C--CHECK IF THE REFLECTION IS ALLOWED
1050  CONTINUE
      KFNR=0
      IF(KALLOW(IALLOW)) 1060,1150,1150
1060  CONTINUE
      IF(state) 1000,1000,1070
1070   CONTINUE
      CALL XSLR(state)
      GO TO 1000
C--END OF THE REFLECTIONS FOUND
1100  CONTINUE
      KFNR=-1
C--AND NOW RETURN
1150  CONTINUE
      RETURN
      END
C
CODE FOR KFNR
      integer function KFNRnew(state, L6W, N6W, reflectiondata) 
     1     result(kfnr)
C--FETCH THE NEXT REFLECTION, CHECKING WITH LIST 28 THAT IT IS ALLOWED.
C
C----- state   0 FOR READ-ONLY
C              1 FOR READ-WRITE
C
C--RETURN VALUES OF 'KFNR' ARE :
C
C  -1  END OF THE REFLCTIONS.
C   0  REFLCTION READ TO BE USED, STORED AT 'M6'.
C
C--
      use xlst06_mod, only: md6w, m6, md6
      use store_mod, only: store
      implicit none
      integer, intent(in) :: state
      integer, intent(inout) :: l6w, n6w
      integer :: iallow
      real, dimension(:), intent(out) :: reflectiondata
      
      interface
        integer function KLDRNRnew(state, reflectiondata) result(KLDRNR)
          implicit none
          integer, intent(in) :: state
          real, dimension(:) :: reflectiondata
          end function
      end interface

      interface
       integer function kallownew(iallow, reflectiondata) result(kallow)
          implicit none
          real, dimension(:), intent(inout) :: reflectiondata
          integer iallow
          end function
      end interface
          
      
C
C--FETCH THE NEXT REFLECTION
1000  CONTINUE
      L6W=L6W+MD6W
      N6W=N6W+1
      IF(KLDRNRnew(state, reflectiondata))1100,1050,1050
C--CHECK IF THE REFLECTION IS ALLOWED
1050  CONTINUE
      KFNR=0
      IF(KALLOWnew(IALLOW, reflectiondata)) 1060,1150,1150
1060  CONTINUE
      IF(state) 1000,1000,1070
1070   CONTINUE
      !CALL XSLR(state)
      GO TO 1000
C--END OF THE REFLECTIONS FOUND
1100  CONTINUE
      KFNR=-1
C--AND NOW RETURN
1150  CONTINUE
      RETURN
      END
C
CODE FOR XSLR
      SUBROUTINE XSLR(IN)
C--STORE THE LAST REFLECTION
C
C  IN  A DUMMY ARGUMENT, IN PLACE FOR COMPATIBILITY.
C
      PARAMETER (SDJW=10.)
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST06.INC'
      INCLUDE 'XPCK06.INC'
      INCLUDE 'XTAPES.INC'
      INCLUDE 'XTAPED.INC'
      INCLUDE 'XCONST.INC'
C
      INCLUDE 'QSTORE.INC'
C
      IDWZAP = IN
C--CHECK IF THE INDICES SHOULD BE PACKED UP
      IF(IPACKW)1050,1000,1000
C--PACK THE INDICES
1000  CONTINUE
      STORE(M6+14)=STORE(M6)+STORE(M6+1)*256.+STORE(M6+2)*65536.
C--CHECK IF THE PHASE AND BATCH NUMBER NEED PACKING UP
1050  CONTINUE
      IF(IPHSEW)1150,1100,1100
C--PACK THE PHASE AND BATCH NUMBER
1100  CONTINUE
      STORE(M6+15)=STORE(M6+13)*20.+AMOD(STORE(M6+6),TWOPI)+10.
C -- CHECK IF WE MUST PACK UP THE RATIO AND JCODE
1150  CONTINUE
      IF ( JCDRAW .GE. 0 ) THEN
c this algorithm is better for -ve values, and is  
c backwards compatible with old dsc files
c changing the scale, sdjw, to 100 would be better still, but is
c not backwards compatible
        adjw=sign(1.,store(m6+20))
        bdjw=min(1000000.,abs(store(m6+20)))  ! limit maximum I/sigma
        cdjw = adjw*((anint(STORE(M6+18)) + 10.*nint(sdjw*bdjw)))
        STORE(M6+31) = cdjw
c
c        STORE(M6+31) = STORE(M6+18) + 10.* ANINT ( 10. * STORE(M6+20) )
      ENDIF
C--MOVE THE DATA TO THE OUTPUT BUFFER
      J=M6W
C--CHECK FOR OUTPUT TO M/T
      IF(L6W)1300,1300,1350
C--OUTPUT TO M/T
1300  CONTINUE
      J=MMTW
C--TRANSFER THE DATA TO THE OUTPUT BUFFER
1350  CONTINUE
      DO 1400 I=L6DMP,M6DMP
      K=ISTORE(I)
      STORE(J)=STORE(K)
      J=J+1
1400  CONTINUE
C--CHECK FOR M/T OUTPUT
      IF(L6W)1450,1450,1500
C--M/T OUTPUT  -  UPDATE THE POINTERS
1450  CONTINUE
      CALL XIMTWA(MTB)
      GOTO 1550
C--OUTPUT THE DATA TO THE DISC
1500  CONTINUE
      CALL XUPF(L6W, ISTORE(M6W), MD6W)
C--UPDATE THE POINTERS
      L6W=L6W+KINCRF(MD6W)
C--UPDATE THE NUMBER OF REFLECTIONS OUTPUT
1550  CONTINUE
      N6W=N6W+1
      RETURN
      END
C
CODE FOR XSLR
      SUBROUTINE XSLRnew(reflectiondata, store, l6w, n6w)
      use xlst06_mod, only: md6w, L6DMP, m6dmp, m6w, m6
      implicit none
C--STORE THE LAST REFLECTION
C
C  IN  A DUMMY ARGUMENT, IN PLACE FOR COMPATIBILITY.
C
      real, PARAMETER :: SDJW=10.
C--
C      INCLUDE 'ISTORE.INC'
C
C      INCLUDE 'STORE.INC'
      !INCLUDE 'XLST06.INC'
      INCLUDE 'XPCK06.INC'
      INCLUDE 'XTAPES.INC'
      INCLUDE 'XTAPED.INC'
      INCLUDE 'XCONST.INC'
C
C      INCLUDE 'QSTORE.INC'
      
      real, dimension(:), intent(inout) :: store, reflectiondata
      integer, intent(in) :: l6w, n6w
      real adjw, bdjw, cdjw
      integer i, idwzap, j, k   
      
      integer, external :: kincrf
C
C--CHECK IF THE INDICES SHOULD BE PACKED UP
      IF(IPACKW)1050,1000,1000
C--PACK THE INDICES
1000  CONTINUE
      reflectiondata(1+14)=reflectiondata(1)+ 
     1    reflectiondata(1+1)*256.+reflectiondata(1+2)*65536.
C--CHECK IF THE PHASE AND BATCH NUMBER NEED PACKING UP
1050  CONTINUE
      IF(IPHSEW)1150,1100,1100
C--PACK THE PHASE AND BATCH NUMBER
1100  CONTINUE
      reflectiondata(1+15)=reflectiondata(1+13)*20.+ 
     1    AMOD(reflectiondata(1+6),TWOPI)+10.
C -- CHECK IF WE MUST PACK UP THE RATIO AND JCODE
1150  CONTINUE
      IF ( JCDRAW .GE. 0 ) THEN
c this algorithm is better for -ve values, and is  
c backwards compatible with old dsc files
c changing the scale, sdjw, to 100 would be better still, but is
c not backwards compatible
        adjw=sign(1.,reflectiondata(1+20))
        bdjw=min(1000000.,abs(reflectiondata(1+20)))  ! limit maximum I/sigma
        cdjw= adjw*((anint(reflectiondata(1+18)) + 10.*nint(sdjw*bdjw)))
        reflectiondata(1+31) = cdjw
c
c        STORE(M6+31) = STORE(M6+18) + 10.* ANINT ( 10. * STORE(M6+20) )
      ENDIF
C--MOVE THE DATA TO THE OUTPUT BUFFER
      J=M6W
C--CHECK FOR OUTPUT TO M/T
      IF(L6W)1300,1300,1350
C--OUTPUT TO M/T
1300  CONTINUE
      J=MMTW
C--TRANSFER THE DATA TO THE OUTPUT BUFFER
1350  CONTINUE
      DO 1400 I=L6DMP,M6DMP
      K=transfer(STORE(I), K)-m6+1 ! relative addres!!!
      STORE(J)=reflectiondata(K)
      J=J+1
1400  CONTINUE
C--CHECK FOR M/T OUTPUT
      IF(L6W)1450,1450,1500
C--M/T OUTPUT  -  UPDATE THE POINTERS
1450  CONTINUE
      CALL XIMTWA(MTB)
      GOTO 1550
C--OUTPUT THE DATA TO THE DISC
1500  CONTINUE
      CALL XUPF(L6W, transfer(STORE(M6W:M6W+MD6W-1), 1, MD6W), MD6W)
C--UPDATE THE POINTERS
      !L6W=L6W+KINCRF(MD6W)
C--UPDATE THE NUMBER OF REFLECTIONS OUTPUT
1550  CONTINUE
      !N6W=N6W+1
      RETURN
      END
C
CODE FOR XABP06
      SUBROUTINE XABP06(IN)
C--ALTER THE DISC BUFFER POINTERS BY 'IN'*M6.
C
C  IN  INDICATES WHETHER TO SUBTRACT OR ADD 'M6' FROM THE STORED VALUES
C
C      -1  SUBTRACT 'M6'.
C      +1  ADD 'M6'.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST06.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET THE INCREMENT/DECREMENT
      J=IN*M6
C--LOOP OVER THE AVAILABLE VALUES
      M6DMP=L6DMP+MD6DMP-1
      DO 1000 I=L6DMP,M6DMP
      ISTORE(I)=ISTORE(I)+J
1000  CONTINUE
      RETURN
      END
C
CODE FOR XFAL28
      SUBROUTINE XFAL28
C--SUBROUTINE TO LOAD LIST 28 FROM DISC, IF IT EXISTS
C
C--
      INCLUDE 'ICOM28.INC'
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XLST06.INC'
      INCLUDE 'XLST28.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QLST28.INC'
C
      INCLUDE 'IDIM28.INC'
C--ZERO THE LIST 28 COMMON BLOCK
      CALL XZEROF(ICOM28(1),IDIM28)
C--READ THE DETAILS FOR LIST 28
      CALL XRLIND(28,I,J,K,L,M,STORE(NFL))
C--CHECK IF SUCH A LIST EXISTS
      IF(J)1250,1250,1000
C--THERE IS A LIST 28  -  LOAD IT FROM DISC
1000  CONTINUE
      CALL XLDLST(28,ICOM28,IDIM28,0)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--FIND THE NUMBER OF ENTRIES IN LIST 28
      N=IDIM28/4
C--SET THE 'M' VARIABLES TO THE LAST ENTRY FOR EACH RECORD
      DO 1050 I=1,N
      J=(I-1)*4
      ICOM28(J+2)=ICOM28(J+1)+(ICOM28(J+4)-1)*ICOM28(J+3)
1050  CONTINUE
C--SET THE 'USE' POINTERS INTO LIST 6
      DO 1200 I=1,3,2
      K=(I-1)*4
C--CHECK IF THERE IS AN ENTRY FOR THIS RECORD
      IF(ICOM28(K+4))1200,1200,1100
C--COMPUTE THE ADDRESS POINTERS
1100  CONTINUE
      L=ICOM28(K+2)
      M=ICOM28(K+3)
      KK=ICOM28(K+1)
C--LOOP OVER EACH ENTRY
      DO 1150 J=KK,L,M
      ISTORE(J)=ISTORE(J)+M6
1150  CONTINUE
1200  CONTINUE
C----- FIX STEP AND STORE IT IN MD28SK
      MD28SK = MAX(1, NINT(STORE(L28SK)) )
C--CHECK IF LIST 1 IS IN CORE
1250  CONTINUE
      IF(KHUNTR(1,0,I,J,K,-1))1300,1350,1350
C--LIST 1 IS NOT IN CORE  -  FLAG ITS CONTROL VARIABLE
1300  CONTINUE
      L1S=NOWT
C--AND NOW RETURN
1350  CONTINUE
C -- NORMAL AND ERROR EXIT
9900  CONTINUE
      RETURN
      END
C
CODE FOR KALLOW
      FUNCTION KALLOW(IALLOW)
C--THIS FUNCTION DETERMINES WHETHER A REFLECTION IS ACCEPTABLE TO LIST 2
c
cdjwapr2011. Return info about which test failed
C
C--THE RETURN VALUES OF 'KALLOW' ARE :
C   0  THE REFLECTION IS OKAY.
C  -N  NOT ACCEPTABLE TO TEST 'N'
C -100 GENERAL REJECTION
C
C  IALLOW  -1 MIN FLAG
C           0 UNDEFINED
C           1 MAX FLAG
C
C--THE REFLECTION IS TAKEN FROM THE CORE BUFFER AT 'M6', AND
C  SIN(THETA)/LAMBDA SQUARED AND FO/FC ARE COMPUTED BY THIS ROUTINE.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST06.INC'
      INCLUDE 'XLST28.INC'
      INCLUDE 'XUNITS.INC'
C
      INCLUDE 'QSTORE.INC'
C
C----- DISALLOW THIS REFLECTION INITIALLY
      IK = -100
      IALLOW = 0
C----- SHOULD WE SKIP IT (STEP STORED IN MD28SK IN XFAL28)
      IF (MOD (N6R, MAX(1, MD28SK) ) .NE. 0) GOTO 1650
C--COMPUTE THE SIN(THETA)/LAMBDA SQUARED
      STORE(M6+16)=SNTHL2(IN)
C--CHECK IF /FC/ IS ZERO
      IF(ABS(STORE(M6+5))-ZERO)1000,1050,1050
C--/FC/ IS ZERO  -  FO/FC DEFAULTS TO ZERO AS WELL
1000  CONTINUE
      STORE(M6+17)=ZERO
      GOTO 1100
C--COMPUTE FO/FC
1050  CONTINUE
      STORE(M6+17)=STORE(M6+3)/STORE(M6+5)
1100  CONTINUE
C--CHECK IF THERE ARE ANY MINIMA CONDITIONS
      IF(N28MN)1250,1250,1150
C--RUN THROUGH THE MINIMA CONDITIONS
1150  CONTINUE
      DO 1200 I=L28MN,M28MN,MD28MN
      J=ISTORE(I)
      IF(STORE(J) .LT. STORE(I+1)) THEN
            IALLOW = -1
            IK = m6-j-1
            GOTO 1650
      ENDIF
c      K = K - 1  ! RC 310811 - removed this line - variable K does not exist
1200  CONTINUE
C--CHECK IF THERE ARE ANY MAXIMA CONDITIONS
1250  CONTINUE
      IF(N28MX)1400,1400,1300
C--RUN THROUGH THE MAXIMA CONDITIONS
1300  CONTINUE
      DO 1350 I=L28MX,M28MX,MD28MX
      J=ISTORE(I)
      IF(STORE(J).GT.STORE(I+1)) THEN
            IALLOW = 1
            IK = m6-j-1
            GOTO 1650
      ENDIF
c      K = K - 1 ! RC 310811 - removed this line - variable K does not exist
1350  CONTINUE
C--CHECK IF THERE ARE ANY SLICE CONDITIONS
1400  CONTINUE
      IF(N28RC)1600,1600,1450
C--PASS THROUGH THE SLICE CONDITIONS
1450  CONTINUE
      DO 1550 I=L28RC,M28RC,MD28RC
        A=STORE(M6)  *STORE(I  )
     1   +STORE(M6+1)*STORE(I+1)
     2   +STORE(M6+2)*STORE(I+2)
C--CHECK THE MINIMUM AND MAXIMUM
        IF( (A .GE. STORE(I+3)).AND.(A .LE. STORE(I+4)) ) THEN
C We have a match. If reject, then disallow this reflection.
C If accept, stop processing slice directives.
C----- REJECT OR ACCEPT?
          IF (ISTORE(I+5) .EQ. 0) THEN
            GOTO 1650 !Reject this reflection outright
          ELSE
            GOTO 1600 !Accept as far as SLICE is concerned.
          ENDIF
        ENDIF
1550  CONTINUE
1600  CONTINUE
      IF(N28CD)1800, 1800, 1700
C--PASS THROUGH THE REFLECTION CONDITIONS
1700  CONTINUE
      DO 1750 I = L28CD, M28CD, MD28CD
        A = STORE(M6  )*STORE(I  )
     1    + STORE(M6+1)*STORE(I+1)
     2    + STORE(M6+2)*STORE(I+2) + STORE(I+3)
        IF (MOD (ABS(A), STORE(I+4) ) .LE. ZERO) THEN
C We have a match. If reject, then disallow this reflection.
C If accept, stop processing condition directives.
C-- REJECT OR ACCEPT?
          IF (ISTORE(I+5) .EQ. 0) THEN
            GOTO 1650    !Reject this reflection outright.
          ELSE
            GOTO 1800    !Accept as far as CONDITIONS are concerned.
          ENDIF
        ENDIF
1750  CONTINUE
1800  CONTINUE
C
C -- CHECK FOR SPECIFIC OMISSIONS
      IF ( N28OM .LE. 0 ) GO TO 1640
      DO 1620 I = L28OM , M28OM , MD28OM
      A = 0.
      DO 1610 J = 1 , 3
      IND6 = M6 + J - 1
      IND28 = I + J - 1
      A = A + ABS ( STORE(IND6) - STORE(IND28) )
1610  CONTINUE
      IF ( A .LE.  ( 3 * ZERO )  ) GO TO 1650
1620  CONTINUE
C
1640  CONTINUE
C -- REFLECTION HAS PASSED ALL TESTS
      IK = 0
C--AND NOW RETURN
1650  CONTINUE
      KALLOW = IK
      RETURN
      END
C

CODE FOR KALLOW
      FUNCTION KALLOWnew(IALLOW, reflectiondata) result(kallow)
C--THIS FUNCTION DETERMINES WHETHER A REFLECTION IS ACCEPTABLE TO LIST 2
c
cdjwapr2011. Return info about which test failed
C
C--THE RETURN VALUES OF 'KALLOW' ARE :
C   0  THE REFLECTION IS OKAY.
C  -N  NOT ACCEPTABLE TO TEST 'N'
C -100 GENERAL REJECTION
C
C  IALLOW  -1 MIN FLAG
C           0 UNDEFINED
C           1 MAX FLAG
C
C--THE REFLECTION IS TAKEN FROM THE CORE BUFFER AT 'M6', AND
C  SIN(THETA)/LAMBDA SQUARED AND FO/FC ARE COMPUTED BY THIS ROUTINE.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLST06.INC'
      INCLUDE 'XLST28.INC'
      INCLUDE 'XUNITS.INC'
C
      INCLUDE 'QSTORE.INC'
      
      real, dimension(:), intent(inout) :: reflectiondata
C
C----- DISALLOW THIS REFLECTION INITIALLY
      IK = -100
      IALLOW = 0
C----- SHOULD WE SKIP IT (STEP STORED IN MD28SK IN XFAL28)
      IF (MOD (N6R, MAX(1, MD28SK) ) .NE. 0) GOTO 1650
C--COMPUTE THE SIN(THETA)/LAMBDA SQUARED
      reflectiondata(1+16)=SNTHL2new(IN, reflectiondata)
C--CHECK IF /FC/ IS ZERO
      IF(ABS(reflectiondata(1+5))-ZERO)1000,1050,1050
C--/FC/ IS ZERO  -  FO/FC DEFAULTS TO ZERO AS WELL
1000  CONTINUE
      reflectiondata(1+17)=ZERO
      GOTO 1100
C--COMPUTE FO/FC
1050  CONTINUE
      reflectiondata(1+17)=reflectiondata(1+3)/reflectiondata(1+5)
1100  CONTINUE
C--CHECK IF THERE ARE ANY MINIMA CONDITIONS
      IF(N28MN)1250,1250,1150
C--RUN THROUGH THE MINIMA CONDITIONS
1150  CONTINUE
      DO 1200 I=L28MN,M28MN,MD28MN
      J=ISTORE(I) ! using relative address in reflectiondata instead
      IF(reflectiondata(J-m6+1) .LT. STORE(I+1)) THEN
            IALLOW = -1
            IK = m6-j-1
            GOTO 1650
      ENDIF
c      K = K - 1  ! RC 310811 - removed this line - variable K does not exist
1200  CONTINUE
C--CHECK IF THERE ARE ANY MAXIMA CONDITIONS
1250  CONTINUE
      IF(N28MX)1400,1400,1300
C--RUN THROUGH THE MAXIMA CONDITIONS
1300  CONTINUE
      DO 1350 I=L28MX,M28MX,MD28MX
      J=ISTORE(I)
      IF(reflectiondata(J-m6+1).GT.STORE(I+1)) THEN
            IALLOW = 1
            IK = m6-j-1
            GOTO 1650
      ENDIF
c      K = K - 1 ! RC 310811 - removed this line - variable K does not exist
1350  CONTINUE
C--CHECK IF THERE ARE ANY SLICE CONDITIONS
1400  CONTINUE
      IF(N28RC)1600,1600,1450
C--PASS THROUGH THE SLICE CONDITIONS
1450  CONTINUE
      DO 1550 I=L28RC,M28RC,MD28RC
        A=reflectiondata(1)  *STORE(I  )
     1   +reflectiondata(1+1)*STORE(I+1)
     2   +reflectiondata(1+2)*STORE(I+2)
C--CHECK THE MINIMUM AND MAXIMUM
        IF( (A .GE. STORE(I+3)).AND.(A .LE. STORE(I+4)) ) THEN
C We have a match. If reject, then disallow this reflection.
C If accept, stop processing slice directives.
C----- REJECT OR ACCEPT?
          IF (ISTORE(I+5) .EQ. 0) THEN
            GOTO 1650 !Reject this reflection outright
          ELSE
            GOTO 1600 !Accept as far as SLICE is concerned.
          ENDIF
        ENDIF
1550  CONTINUE
1600  CONTINUE
      IF(N28CD)1800, 1800, 1700
C--PASS THROUGH THE REFLECTION CONDITIONS
1700  CONTINUE
      DO 1750 I = L28CD, M28CD, MD28CD
        A = reflectiondata(1  )*STORE(I  )
     1    + reflectiondata(1+1)*STORE(I+1)
     2    + reflectiondata(1+2)*STORE(I+2) + STORE(I+3)
        IF (MOD (ABS(A), STORE(I+4) ) .LE. ZERO) THEN
C We have a match. If reject, then disallow this reflection.
C If accept, stop processing condition directives.
C-- REJECT OR ACCEPT?
          IF (ISTORE(I+5) .EQ. 0) THEN
            GOTO 1650    !Reject this reflection outright.
          ELSE
            GOTO 1800    !Accept as far as CONDITIONS are concerned.
          ENDIF
        ENDIF
1750  CONTINUE
1800  CONTINUE
C
C -- CHECK FOR SPECIFIC OMISSIONS
      IF ( N28OM .LE. 0 ) GO TO 1640
      DO 1620 I = L28OM , M28OM , MD28OM
      A = 0.
      DO 1610 J = 1 , 3
      IND6 = M6 + J - 1 - m6 + 1 ! using relative address in reflectiondata instead
      IND28 = I + J - 1
      A = A + ABS ( reflectiondata(IND6) - STORE(IND28) )
1610  CONTINUE
      IF ( A .LE.  ( 3 * ZERO )  ) GO TO 1650
1620  CONTINUE
C
1640  CONTINUE
C -- REFLECTION HAS PASSED ALL TESTS
      IK = 0
C--AND NOW RETURN
1650  CONTINUE
      KALLOW = IK
      RETURN
      END
C

CODE FOR SNTHL2
      FUNCTION SNTHL2(IN)
C--CALCULATE (SIN(THETA)/LAMBDA)**2
C
C  M6   LOCATION OF THE REFLECTION.
C  L1S  LOCATION OF THE R(IJ) TERMS.
C
C--
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XLST06.INC'
C
      IDWZAP = IN
C--CHECK IF LIST 1 IS AVAILABLE
      SNTHL2=0.
      IF(L1S)1050,1050,1000
C--CALCULATE (SIN(THETA)/LAMBDA)**2
1000  CONTINUE
      SNTHL2=STORE(M6)*STORE(M6)*STORE(L1S)+STORE(M6+1)*STORE(M6+1)
     2 *STORE(L1S+1)+STORE(M6+2)*STORE(M6+2)*STORE(L1S+2)+STORE(M6+1)
     3 *STORE(M6+2)*STORE(L1S+3)+STORE(M6)*STORE(M6+2)*STORE(L1S+4)
     4 +STORE(M6)*STORE(M6+1)*STORE(L1S+5)
C--AND NOW RETURN
1050  CONTINUE
      RETURN
      END
C
CODE FOR SNTHL2
      FUNCTION SNTHL2new(dummy, reflectiondata) result(SNTHL2)
C--CALCULATE (SIN(THETA)/LAMBDA)**2
C
C  M6   LOCATION OF THE REFLECTION.
C  L1S  LOCATION OF THE R(IJ) TERMS.
C
C--
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XLST06.INC'
      
      real, dimension(md6), intent(in) :: reflectiondata
      integer dummy
C
      IDWZAP = dummy
C--CHECK IF LIST 1 IS AVAILABLE
      SNTHL2=0.
      IF(L1S)1050,1050,1000
C--CALCULATE (SIN(THETA)/LAMBDA)**2
1000  CONTINUE
      SNTHL2=reflectiondata(1)**2*STORE(L1S)
     1 +reflectiondata(1+1)**2*STORE(L1S+1)+reflectiondata(1+2)**2
     2 *STORE(L1S+2)+reflectiondata(1+1)
     3 *reflectiondata(1+2)*STORE(L1S+3)+reflectiondata(1)
     4 *reflectiondata(1+2)*STORE(L1S+4)
     5 +reflectiondata(1)*reflectiondata(1+1)*STORE(L1S+5)
C--AND NOW RETURN
1050  CONTINUE
      RETURN
      END
C
CODE FOR KTYP06
      FUNCTION KTYP06(ITYP06)
C--SET THE TYPE OF LIST 6 TO BE USED.
C
C  ITYP06    THE TYPE OF THE LIST 6, IN THE RANGE 1 TO N. 
C            THIS IS SET IN THE COMMAND FILE 
C            THE FOLLOWING TYPES ARE KNOWN AT PRESENT :
C
C          1  TYPE IS 6
C          2  TYPE IS 7
C
C--NO OTHER TYPES ARE SUPPORTED AND AN ERROR IS REPORTED FOR ANY OTHERS.
C
C--RETURN VALUES OF 'KTYP06' ARE :
C
C  >0  THE LIST TYPE TO BE USED.
C
C--
C
      DIMENSION ITYPE(2)
C
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
C
      DATA ITYPE/6,7/
C
C--CHECK THE INPUT VALUE
      IF(ITYP06)1000,1000,1100
C--TYPE IS ILLEGAL
1000  CONTINUE
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1050)ITYP06
      WRITE ( CMON, 1050) ITYP06
      CALL XPRVDU(NCVDU, 1,0)
1050  FORMAT(' Illegal list 6 type selector ',I5)
      CALL XERHND ( IERPRG )
C--CHECK THE MAXIMUM
1100  CONTINUE
      IF(ITYP06-2)1150,1150,1000
C--FIND THE TYPE
1150  CONTINUE
      KTYP06=ITYPE(ITYP06)
      RETURN
      END
CODE FOR XIRTAC
      SUBROUTINE XIRTAC(IPOSN)
C--INITIATE THE ACCUMULATION OF DETAILS FOR THE REFLECTIONS. THIS
C  ROUTINE SETS UP ONE SLOT IN THE RECORD STARTING AT 'STORE(L6DTL)'.
C
C  IPOSN   THE NUMBER OF THE SLOT TO INITIATE, IN THE RANGE 1 TO MD6.
C
C--
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST06.INC'
C
C--COMPUTE THE ADDRESS IN THE DETAILS RECORD.
      I=L6DTL+(IPOSN-1)*MD6DTL
C--SET THE MAXIMUM AND MINIMUM FLAGS
      STORE(I)=1E20
      STORE(I+1)=-1E20
C--SET THE SLOTS FOR THE MEAN AND R.M.S.
      STORE(I+2)=0.
      STORE(I+3)=0.
      RETURN
      END
C
CODE FOR XACRT
      SUBROUTINE XACRT(IPOSN, minimum, maximum, summation, summationsq, 
     1    reflectiondata)
C--ADD IN THE TOTAL FOR A REFLECTION TO A GIVEN SLOT IN THE DETAILS
C  RECORD.
C
C  IPOSN   THE POSITION IN THE DETAILS RECORD TO BE UPDATED, IN THE RANG
C          1 TO MD6.
C
C--
      !INCLUDE 'STORE.INC'
      use store_mod, only: storelength
      !INCLUDE 'XLST06.INC'
      use xlst06_mod, only: l6dtl, md6dtl
      
      implicit none
      integer i, j
      integer, intent(in) :: iposn
      real, dimension(:), intent(inout):: minimum, maximum
      real, dimension(:), intent(inout):: summation, summationsq
      real, dimension(:), intent(in) :: reflectiondata
      
      ! check if allocated space is enough and crashing the program if not enough space
      if(iposn>ubound(minimum,1) .or. iposn<1 ) then
          print *, 'not enough space allocated (xacrt)!! '
          print *, iposn, ubound(minimum,1)
      !    stop
      end if
      if(iposn>ubound(maximum,1) .or. iposn<1) then
          print *, 'not enough space allocated (xacrt)!! '
          print *, iposn, ubound(minimum,1)
      !    stop
      end if
      if(iposn>ubound(summation,1) .or. iposn<1) then
          print *, 'not enough space allocated (xacrt)!! '
          print *, iposn, ubound(minimum,1)
      !    stop
      end if
      if(iposn>ubound(summationsq,1) .or. iposn<1) then
          print *, 'not enough space allocated (xacrt)!! '
          print *, iposn, ubound(minimum,1)
      !    stop
      end if
            
C--FIND THE POSITION IN THE DETAILS AND CORE BUFFER
      I=IPOSN-1
      J=L6DTL+I*MD6DTL
      I=1+I
C--FIND THE NEW MAXIMUM AND MINIMUM
      !STORE(J)=MIN(STORE(J),STORE(I))
      minimum(IPOSN)=min(minimum(IPOSN), reflectiondata(I))
      !STORE(J+1)=MAX(STORE(J+1),STORE(I))
      maximum(IPOSN)=max(maximum(IPOSN), reflectiondata(I))
C--ADD IN FOR THE MEAN AND R.M.S.
      !STORE(J+2)=STORE(J+2)+STORE(I)
      summation(IPOSN)=summation(IPOSN)+reflectiondata(i)
      !STORE(J+3)=STORE(J+3)+STORE(I)*STORE(I)
      summationsq(IPOSN)=summationsq(IPOSN)+reflectiondata(i)**2
      RETURN
      END
C
CODE FOR XCRD
      SUBROUTINE XCRD(IPOSN)
C--COMPUTE THE REFLECTIONS DETAILS AT THE POSITION INDICATED.
C
C  IPOSN   THE POSITION IN THE DETAILS RECORD TO BE COMPUTED, IN THE
C          RANGE 1 TO MD6.
C
C--
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST06.INC'
C
C--CHECK IF ANY REFLECTIONS HAVE BEEN OUTPUT
      A=0.
      IF(N6W)1050,1050,1000
C--COMPUTE THE RECIPROCAL OF THE NUMBER OF REFLECTIONS OUTPUT
1000  CONTINUE
      A=1./FLOAT(N6W)
C--COMPUTE THE POSITION IN THE DETAILS RECORD
1050  CONTINUE
      I=L6DTL+(IPOSN-1)*MD6DTL
C--COMPUTE THE MEAN
      STORE(I+2)=STORE(I+2)*A
C--COMPUTE THE R.M.S. VALUE
      STORE(I+3)=SQRT(STORE(I+3)*A)
      RETURN
      END
C
cCODE FOR XWRDTD
c      SUBROUTINE XWRDTD(IULN)
cC--WRITE THE REFLECTION DETAILS RECORD TO DISC
cC
cC  IULN    THE LIST THAT IS BEING OUTPUT AS A LIST TYPE 6.
cC
cC--
c\HEADES
cC
c\ISTORE
c\STORE
c\XLST06
c\XLISTI
c\QSTORE
cC
cC--SET THE LIST TYPE
c      LN=IULN
cC--FIND THE RECORD ON DISC
c      I=KFNDRI(IULN,107,J,IBUFF)
cC--WRITE THE NEW DETAILS TO DISC
c      CALL XUPF(IBUFF(4), ISTORE(L6DTL), IBUFF(3)-MD0)
cC--FIND THE RECORD ON DISC
c      I=KFNDRI(IULN,106,J,IBUFF)
cC--WRITE THE NEW DETAILS TO DISC
c      CALL XUPF(IBUFF(4),STORE(L6P),IBUFF(3)-MD0)
c      RETURN
c      END
CODE FOR KLDRNR
      integer function KLDRNR(state)
C--LOAD THE NEXT REFLECTION FROM THE DISC
C
C  state  A DUMMY ARGUMENT.
C
C--RETURN VALUES ARE :
C
C  -1  END OF DATA  -  ALL SUBSEQUENT ACCESSES WILL RETURN THIS VALUE
C   0  REFLECTION TRANSFERRED TO THE CORE BUFFER.
C
C      IDISPL      FLAG CONTROLLING LIST 6 DISPLAY
C                    -1      NO DISPLAY
C                    +1      DISPLAY
C
      implicit none

      logical, save :: DISPL6
      integer, PARAMETER :: NINTER = 20
      integer, intent(in) :: state
      real a
      integer i, j, k, ipercn, newlvl, nprev
      real bdjw, cdjw, ddjw
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'XDRIVE.INC'
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST06.INC'
      INCLUDE 'XPCK06.INC'
      INCLUDE 'XTAPES.INC'
      INCLUDE 'XTAPED.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XCONST.INC'
C
      integer, save :: idispl=1
      integer, save :: NXTLVL=0 , NSTAR
      integer, external :: KINCRF
C
      INCLUDE 'QSTORE.INC'
      
C
C
C
C--CHECK FOR END OF FILE
      KLDRNR=-1
      IF(N6R>0) then !1550,1550,1000
C--READ DOWN THE NEXT REFLECTION
          !1000  CONTINUE
          KLDRNR=0
          !CALL XZEROF(STORE(M6),MD6)
          STORE(M6:M6+MD6-1)=0.0
C--CHECK FOR INPUT FROM M/T
          IF(L6R<=0) then !1050,1050,1100
C--INPUT FROM TAPE  -  FETCH THE NEXT REFLECTION
              !1050  CONTINUE
              CALL XIMTRA(MTA)
              M6R=MMTR
              !GOTO 1150
          else !1100  CONTINUE
C--INPUT FROM DISC
              CALL XDOWNF(L6R,STORE(M6R),MD6R)
C--UPDATE THE POINTERS FOR THE DISC
              L6R=L6R+KINCRF(MD6R)
C--UPDATE THE NUMBER OF REFLECTIONS LEFT TO READ
          end if ! 1150      CONTINUE
          N6R=N6R-1
C--TRANSFER THE DATA TO THE CORE BUFFER
          J=M6R
          DO I=L6DMP,M6DMP ! 1200 
              K=ISTORE(I)
              STORE(K)=STORE(J)
              J=J+1
          end do !1200  CONTINUE
C--CHECK IF THE INDICES SHOULD BE UNPACKED
          IF(IPACKR>=0) then !1300,1250,1250
C--UNPACK THE REFLECTIONS
              !1250  CONTINUE
              A=FLOAT(NINT(STORE(M6+14)/256.))
              STORE(M6)=STORE(M6+14)-A*256.
              !print *, 'KLDRNR', m6, STORE(M6)
              STORE(M6+2)=FLOAT(NINT(A/256.))
              STORE(M6+1)=A-STORE(M6+2)*256.
C--CHECK IF THE PHASE AND BATCH NUMBER SHOULD BE UNPACKED
          end if !1300  CONTINUE
          IF(IPHSER>=0) then !1400,1350,1350
C--UNPACK THE PHASE AND BATCH NUMBER
              !1350  CONTINUE
              STORE(M6+13)=AINT(STORE(M6+15)*0.05)
              STORE(M6+6)=STORE(M6+15)-STORE(M6+13)*20.-10.
C -- CHECK IF THE RATIO AND JCODE SHOULD BE UNPACKED
          end if !1400  CONTINUE
          IF ( JCDRAR .GE. 0 ) THEN
c this algorithm is better for -ve values, and is  
c backwards compatible with old dsc files
c changing the scale, sdjw, to 0.01 would be better still, but is
c not backwards compatible
 
c              adjw = sign(1.,store(m6+31))
              bdjw = abs(store(m6+31))
              cdjw = int(0.1*bdjw)
              ddjw = bdjw-10.*cdjw
c             edjw = adjw*sdjw*cdjw

              store(m6+18) = ddjw
c             store(m6+20) = edjw
c
c        STORE(M6+20) = AINT(STORE(M6+31)*0.1+0.005) * 0.1
c        STORE(M6+18) = ANINT(STORE(M6+31) - (100.*STORE(M6+20)))
c
c        recompute RATIO because value is only stored to 2sig fig
c        esd was set to ZERO elsewhere if none was input. 
c        Assume users wants all reflections, so set default RATIO to > 3
              if (store(m6+12).le. zero) then
                  store(m6+20) = 3.001
              else
                  store(m6+20)=min(128., store(m6+3)/(store(m6+12)*2.) )
              endif
          ENDIF
          STORE(M6+13) = MAX ( STORE(M6+13) , 1.0 )
C
C -- MAKE SURE 'SIGMA' AND 'CORRECTIONS' HAVE REASONABLE VALUES
          IF ( STORE(M6+12) .LT. ZERO ) STORE(M6+12) = ZERO
          IF ( STORE(M6+27) .LT. ZERO ) STORE(M6+27) = 1.0
C
C -- PRODUCE DISPLAY IF REQUIRED
          DISPL6 = ( IDISPL .GT. 0 ) .AND. ( IQUN .EQ. JQUN ) .AND.
     2        ( ISSSPD .GT. 1 ) .AND. ( N6D .GT. 0 )
C
          IF ( DISPL6 ) THEN
              IF ( N6R .GE. (N6D-1) ) THEN
#if !defined(_GID_) && !defined(_GIL_) && !defined(_WXS_)  && !defined(_MAC_)&& !defined(_INW_)
                  WRITE ( CMON,1505)
                  CALL XPRVDU(NCVDU, 1, 0)
                  WRITE(NCVDU,1505)
#endif
1505              FORMAT ( 15X ,  12X, 'Processing reflections ')
C                 CALL VGACOL ( 'BOL', 'YEL', 'BLA' )
                  CALL OUTCOL(6)
#if !defined(_GID_) && !defined(_GIL_) && !defined(_WXS_)  && !defined(_MAC_)&& !defined(_INW_)
                  WRITE(NCVDU,'(15X,''^'',$)')
#endif
                  NSTAR = 1
                  NXTLVL = ( NSTAR * N6D ) / NINTER
              ELSE IF ( (N6D-N6R) .GE. NXTLVL ) THEN
                  IPERCN = MIN ( 100 , ( 100 * NSTAR ) / NINTER )
                  CALL SLIDER (NSTAR, NINTER)
C
C -- CALCULATE WHERE NEXT PRINT IS DUE
C
                  NPREV = NXTLVL + 1
            
                  do while( (NXTLVL<=NPREV) .and. (NSTAR<=NINTER+1) ) !1520      CONTINUE
                      NSTAR = NSTAR + 1
                      NXTLVL = ( NSTAR * N6D ) / NINTER
                      !GO TO 1520
                  end do
C
                  NEWLVL=NXTLVL-1
                  do while( (NEWLVL<=NXTLVL) .AND. (NSTAR<=NINTER+1) ) ! 1530      CONTINUE
                      NSTAR = NSTAR + 1
                      NEWLVL = ( NSTAR * N6D ) / NINTER
                  end do !GO TO 1530
C
                  NSTAR = MIN ( NSTAR - 1 , NINTER )
                  
C
              ENDIF
          ENDIF
          RETURN
C
      end if !1550  CONTINUE
C      CALL VGACOL ( 'BOL', 'WHI', 'BLU' )
      CALL OUTCOL(1)
C------ SWITCH ON LINE FEEDS FOR DOS
          JNL77 = 1
C      WRITE(CMON,1560)
C      CALL XPRVDU(NCVDU, 2,0)
1560  FORMAT(' ')
      RETURN
      END
C
      integer function KLDRNRnew(state, reflectiondata) result(KLDRNR)
C--LOAD THE NEXT REFLECTION FROM THE DISC
C
C  state  A DUMMY ARGUMENT.
C
C--RETURN VALUES ARE :
C
C  -1  END OF DATA  -  ALL SUBSEQUENT ACCESSES WILL RETURN THIS VALUE
C   0  REFLECTION TRANSFERRED TO THE CORE BUFFER.
C
C      IDISPL      FLAG CONTROLLING LIST 6 DISPLAY
C                    -1      NO DISPLAY
C                    +1      DISPLAY
C
      implicit none

      logical, save :: DISPL6
      integer, PARAMETER :: NINTER = 20
      integer, intent(in) :: state
      real a
      integer i, j, k, ipercn, newlvl, nprev
      real bdjw, cdjw, ddjw
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'XDRIVE.INC'
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST06.INC'
      INCLUDE 'XPCK06.INC'
      INCLUDE 'XTAPES.INC'
      INCLUDE 'XTAPED.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XCONST.INC'
C
      integer, save :: idispl=1
      integer, save :: NXTLVL=0 , NSTAR
      integer, external :: KINCRF
C
      INCLUDE 'QSTORE.INC'
      real, dimension(md6r) :: packedbuffer
      !> dedicated storage for list 6. size is md6
      !! Used to be in store at address m6 
      real, dimension(:) :: reflectiondata
      
C
C
C
C--CHECK FOR END OF FILE
      KLDRNR=-1
      IF(N6R>0) then !1550,1550,1000
C--READ DOWN THE NEXT REFLECTION
          !1000  CONTINUE
          KLDRNR=0
          !CALL XZEROF(STORE(M6),MD6)
          reflectiondata=0.0
C--CHECK FOR INPUT FROM M/T
          IF(L6R<=0) then !1050,1050,1100
C--INPUT FROM TAPE  -  FETCH THE NEXT REFLECTION
              !1050  CONTINUE
              CALL XIMTRA(MTA)
              M6R=MMTR
              !GOTO 1150
          else !1100  CONTINUE
C--INPUT FROM DISC
              !CALL XDOWNF(L6R,STORE(M6R),MD6R)
              call XDOWNnew2(L6R,packedbuffer,MD6R, ierflg)
C--UPDATE THE POINTERS FOR THE DISC
              L6R=L6R+KINCRF(MD6R)
C--UPDATE THE NUMBER OF REFLECTIONS LEFT TO READ
          end if ! 1150      CONTINUE
          N6R=N6R-1
C--TRANSFER THE DATA TO THE CORE BUFFER
          J=1
          DO I=L6DMP,M6DMP ! 1200 
              K=ISTORE(I)-M6+1 ! istore is an absolute, using a relative address to m6 now
              reflectiondata(K)=packedbuffer(J)
              J=J+1
          end do !1200  CONTINUE
C--CHECK IF THE INDICES SHOULD BE UNPACKED
          IF(IPACKR>=0) then !1300,1250,1250
C--UNPACK THE REFLECTIONS
              !1250  CONTINUE
              A=FLOAT(NINT(reflectiondata(1+14)/256.))
              reflectiondata(1)=reflectiondata(1+14)-A*256.
              !print *, 'KLDRNR', m6, STORE(M6)
              reflectiondata(1+2)=FLOAT(NINT(A/256.))
              reflectiondata(1+1)=A-reflectiondata(1+2)*256.
C--CHECK IF THE PHASE AND BATCH NUMBER SHOULD BE UNPACKED
          end if !1300  CONTINUE
          IF(IPHSER>=0) then !1400,1350,1350
C--UNPACK THE PHASE AND BATCH NUMBER
              !1350  CONTINUE
              reflectiondata(1+13)=AINT(reflectiondata(1+15)*0.05)
              reflectiondata(1+6)=reflectiondata(1+15)-
     1            reflectiondata(1+13)*20.-10.
C -- CHECK IF THE RATIO AND JCODE SHOULD BE UNPACKED
          end if !1400  CONTINUE
          IF ( JCDRAR .GE. 0 ) THEN
c this algorithm is better for -ve values, and is  
c backwards compatible with old dsc files
c changing the scale, sdjw, to 0.01 would be better still, but is
c not backwards compatible
 
c              adjw = sign(1.,store(m6+31))
              bdjw = abs(reflectiondata(1+31))
              cdjw = int(0.1*bdjw)
              ddjw = bdjw-10.*cdjw
c             edjw = adjw*sdjw*cdjw

              reflectiondata(1+18) = ddjw
c             store(m6+20) = edjw
c
c        STORE(M6+20) = AINT(STORE(M6+31)*0.1+0.005) * 0.1
c        STORE(M6+18) = ANINT(STORE(M6+31) - (100.*STORE(M6+20)))
c
c        recompute RATIO because value is only stored to 2sig fig
c        esd was set to ZERO elsewhere if none was input. 
c        Assume users wants all reflections, so set default RATIO to > 3
              if (reflectiondata(1+12).le. zero) then
                  reflectiondata(1+20) = 3.001
              else
                  reflectiondata(1+20)=min(128., 
     1                reflectiondata(1+3)/(reflectiondata(1+12)*2.) )
              endif
          ENDIF
          reflectiondata(1+13) = MAX ( reflectiondata(1+13) , 1.0 )
C
C -- MAKE SURE 'SIGMA' AND 'CORRECTIONS' HAVE REASONABLE VALUES
          IF (reflectiondata(1+12).LT.ZERO) reflectiondata(1+12)= ZERO
          IF (reflectiondata(1+27).LT.ZERO) reflectiondata(1+27)= 1.0
C
C -- PRODUCE DISPLAY IF REQUIRED
          DISPL6 = ( IDISPL .GT. 0 ) .AND. ( IQUN .EQ. JQUN ) .AND.
     2        ( ISSSPD .GT. 1 ) .AND. ( N6D .GT. 0 )
C
          IF ( DISPL6 ) THEN
              IF ( N6R .GE. (N6D-1) ) THEN
#if !defined(_GID_) && !defined(_GIL_) && !defined(_WXS_)  && !defined(_MAC_)&& !defined(_INW_)
                  WRITE ( CMON,1505)
                  CALL XPRVDU(NCVDU, 1, 0)
                  WRITE(NCVDU,1505)
#endif
1505              FORMAT ( 15X ,  12X, 'Processing reflections ')
C                 CALL VGACOL ( 'BOL', 'YEL', 'BLA' )
                  CALL OUTCOL(6)
#if !defined(_GID_) && !defined(_GIL_) && !defined(_WXS_)  && !defined(_MAC_)&& !defined(_INW_)
                  WRITE(NCVDU,'(15X,''^'',$)')
#endif
                  NSTAR = 1
                  NXTLVL = ( NSTAR * N6D ) / NINTER
              ELSE IF ( (N6D-N6R) .GE. NXTLVL ) THEN
                  IPERCN = MIN ( 100 , ( 100 * NSTAR ) / NINTER )
                  CALL SLIDER (NSTAR, NINTER)
C
C -- CALCULATE WHERE NEXT PRINT IS DUE
C
                  NPREV = NXTLVL + 1
            
                  do while( (NXTLVL<=NPREV) .and. (NSTAR<=NINTER+1) ) !1520      CONTINUE
                      NSTAR = NSTAR + 1
                      NXTLVL = ( NSTAR * N6D ) / NINTER
                      !GO TO 1520
                  end do
C
                  NEWLVL=NXTLVL-1
                  do while( (NEWLVL<=NXTLVL) .AND. (NSTAR<=NINTER+1) ) ! 1530      CONTINUE
                      NSTAR = NSTAR + 1
                      NEWLVL = ( NSTAR * N6D ) / NINTER
                  end do !GO TO 1530
C
                  NSTAR = MIN ( NSTAR - 1 , NINTER )
                  
C
              ENDIF
          ENDIF
          RETURN
C
      end if !1550  CONTINUE
C      CALL VGACOL ( 'BOL', 'WHI', 'BLU' )
      CALL OUTCOL(1)
C------ SWITCH ON LINE FEEDS FOR DOS
          JNL77 = 1
C      WRITE(CMON,1560)
C      CALL XPRVDU(NCVDU, 2,0)
1560  FORMAT(' ')
      RETURN
      END
C
