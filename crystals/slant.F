C $Log: not supported by cvs2svn $
C Revision 1.25  2012/07/12 08:42:23  rich
C Allow FoSq-FcSq-Patterson maps.
C
C Revision 1.24  2011/03/21 13:57:22  rich
C Update files to work with gfortran compiler.
C
C Revision 1.23  2009/09/18 16:24:34  djw
C Silly scaling error if 2Fo-Fc map
C
C Revision 1.22  2009/07/31 12:42:05  djw
C Remove de-bugging out put from the monitor
C
C Revision 1.21  2008/01/03 13:10:46  djw
C Add 2Fo-Fc map type
C
C Revision 1.20  2005/01/23 08:29:12  rich
C Reinstated CVS change history for all FPP files.
C History for very recent (January) changes may be lost.
C
C Revision 1.1.1.1  2004/12/13 11:16:07  rich
C New CRYSTALS repository
C
C Revision 1.19  2004/10/22 10:45:13  rich
C NCAWU removed.
C
C Revision 1.18  2003/12/02 11:55:38  rich
C Code changes to \SLANT to output MapView data file.
C
C Revision 1.17  2003/02/14 17:09:02  djw
C Extend codes to work wih list 6 and list 7.  Note that sfls, calc and
C recine have the parameter ityp06, which corresponds to the types
C pickedip for lists 6 and 7  from the command file
C
C Revision 1.16  2002/12/16 18:24:21  rich
C Change calls to KDIST1
C
C Revision 1.15  2002/10/02 13:39:51  rich
C KDIST1 call requires extra param.
C
C Revision 1.14  2002/03/13 12:35:22  richard
C Added extra argument to calls to KDIST1.
C
C Revision 1.13  2001/08/08 12:36:16  ckp2
C Ignore Q atoms when doing slant void maps.
C
C Revision 1.12  2001/03/28 13:35:17  richard
C Calls to KDIST1 should have JFNVC as 0 if there is no function vector!
C
C Revision 1.11  2001/01/15 12:15:25  richard
C Append symmetry information to end of slant fourier maps,
C for Michal Husak.
C
C Revision 1.10  2001/01/12 15:06:43  CKP2
C Make slant callable
C
C Revision 1.9  2000/12/05 12:44:43  CKP2
C make SLANT into subroutine
C
C Revision 1.8  2000/10/31 15:37:12  ckp2
C New subroutine XVSLANT for slant void calculations...
C
CODE FOR XTRIAL
      SUBROUTINE XTRIAL
C--MOVE A MOLECULE AROUND AND PLOT SUM(FO*FC) AT EACH POINT
C
C  AM      MINIMUM VALUE OF FO TO BE USED (ON SCALE OF FO)
C  SCALE   MAP SCALE FACTOR  -  AUTOMATIC SCALING DONE IF ZERO
C  ITHRES  VALUE BELOW WHICH ALL NUMBERS ARE PRINTED AS ZEROES
C  NX      THE NUMBER OF POINTS ALONG X TO MOVE.
C  NY      THE NUMBER OF POINTS ALONG Y TO MOVE.
C  NZ      THE NUMBER OF POINTS ALONG Z TO MOVE.
C          (THESE DIRECTIONS ARE AFTER TRANSFORMATION.)
C  BPD     LOCATIONS 7-9 CONTAIN THE INITIAL ORIGIN DISTPALCEMENT.
C  APD     THE STEP VECTOR.
C
C--
      INCLUDE 'ISTORE.INC'
C
      DIMENSION PROCS(26)
      DIMENSION A1(26)
      DIMENSION APD(13), BPD(13)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XLST02.INC'
      INCLUDE 'XLST03.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST06.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (PROCS(1),APD(1)), (BPD(1),PROCS(14))
      EQUIVALENCE (AM,BPD(1)),(SCALE,BPD(2)),(ITHRES,BPD(3))
      EQUIVALENCE (NNX,BPD(4)),(NNY,BPD(5)),(NNZ,BPD(6))
      EQUIVALENCE (A1(1),A)
C
C
      DATA NCOL/28/
C
      NW=7
C--INITIALISE THE TIMING
      CALL XTIME1(2)
C--READ THE DIRECTIVES
      ISTAT = KRDDPV ( PROCS , 26 )
      IF ( ISTAT .LT. 0 ) GO TO 9910
C--CLEAR THE CORE
1050  CONTINUE
      CALL XRSL
      CALL XCSAE
C--ASSIGN A FEW INPUT CONTROL VALUES
      NX=MAX0(1,NNX)
      NY=MAX0(1,NNY)
      NZ=MAX0(1,NNZ)
C--LOAD A FEW LISTS
      CALL XFAL01
      CALL XFAL02
      CALL XFAL03
      CALL XFAL05
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--LINK LIST 5 TO VARIOUS OTHER LISTS
      JJ=-1
      JA=1
      IF(KSET52(-1,0))1150,1100,1100
1100  CONTINUE
      IF ( IERFLG .LT. 0 ) GO TO 9900
      JJ=0
      JA=N2
1150  CONTINUE
      N3=KSET53(0)+1
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--SET THE INITIAL TRANSFORMED COORD. VALUES
      MINX=0
      MINY=0
      MINZ=0
C--APPLY THE INITIAL DISPALCEMENT
      M5=L5
      DO 1200 I=1,N5
      STORE(M5+4)=STORE(M5+4)+BPD(7)
      STORE(M5+5)=STORE(M5+5)+BPD(8)
      STORE(M5+6)=STORE(M5+6)+BPD(9)
      M5=M5+MD5
1200  CONTINUE
C--SET UP LIST 6 FORM READING
      CALL XFAL06(6,0)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--SET UP THE INITIAL REFLECTION DATA
      CALL XSFLSQ(AM,BM)
C
C--SET UP A FEW CONSTANTS FOR THE MAP
      W=1000./BM
      IF(SCALE-ZEROSQ)1300,1300,1250
1250  CONTINUE
      W=SCALE
1300  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1350)W
      ENDIF
1350  FORMAT(///,' Scale factor',E20.3)
C--CHECK THAT THERE ARE SOME REFLECTIONS
      IF(ND)1400,1400,1500
1400  CONTINUE
      CALL XERHDR(0)
      WRITE ( CMON , 1450)
      CALL XPRVDU(NCVDU, 1,0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU, '(/A)') CMON(1)(:)
1450  FORMAT(/,' No reflections')
      GOTO 1050
C--SET UP THE MAP AND ACCUMULATION AREAS
1500  CONTINUE
      L8=NFL
      NQ=NX*NY
      LN=8
      IREC=5001
      NO=KCHNFL(3*NQ)-1
      MD8=NY
      NP=L8+NQ
C--SET UP THE NUMBER AREA
      IREC=5002
      NS=KCHLFL(NCOL)
C
C--MAIN CALCULATION LOOP
      DO 2950 N1=1,NZ
      M8=NY-1
C--CLEAR THE MAP AREA
      DO 1550 I=L8,NP
      STORE(I)=0.
1550  CONTINUE
      NB=NA
C--PASS OVER EACH REFLECTION
      DO 2300 I1=1,ND
C--CLEAR THE REFLECTION ACCUMULATION AREA
      DO 1600 J1=NP,NO
      STORE(J1)=0.
1600  CONTINUE
      JF=NB
C--PASS OVER EACH SYMMETRY POSITION FOR EACH RELFECTION
      DO 2050 J1=1,N2
      JG=JF+6
C--INCREMENT THE COS TERMS TO THE NEW LAYER
      DO 1650 K1=JF,JG,2
      A=STORE(K1)
      STORE(K1)=STORE(JF+20)*STORE(K1)-STORE(K1+8)
      STORE(K1+8)=A
1650  CONTINUE
      A=STORE(JF)
      B=STORE(JF+2)
      C=STORE(JF+4)
      D=STORE(JF+6)
      O=STORE(JF+16)
      P=STORE(JF+18)
      L=NP
C--PASS ALONG THE X ROWS
      DO 1750 J=1,NX
      A1(7)=A1(2)
      A1(2)=A1(15)*A1(2)-A1(1)
      A1(5)=A1(2)
      A1(1)=A1(7)
      A1(7)=A1(4)
      A1(4)=A1(15)*A1(4)-A1(3)
      A1(6)=A1(4)
      A1(3)=A1(7)
      M=L+M8
C--ADD IN ALONG THE Y ROWS
      DO 1700 K=L,M
      A1(7)=A1(6)
      A1(6)=A1(16)*A1(6)-A1(5)
      A1(5)=A1(7)
      STORE(K)=STORE(K)+A1(6)
1700  CONTINUE
      L=L+MD8
1750  CONTINUE
C--CHECK IF THIS IS A NON-CENTRO STRUCTURE
      IF(IC)1800,1800,2000
C--NON-CENTRO
1800  CONTINUE
C--UPDATE THE SIN TERMS
      DO 1850 K1=JF,JG,2
      A=STORE(K1+1)
      STORE(K1+1)=STORE(JF+20)*STORE(K1+1)-STORE(K1+9)
      STORE(K1+9)=A
1850  CONTINUE
      A=STORE(JF+1)
      B=STORE(JF+3)
      C=STORE(JF+5)
      D=STORE(JF+7)
      L=NP+NQ
C--PASS ALONG THE X ROWS
      DO 1950 J=1,NX
      A1(7)=A1(2)
      A1(2)=A1(15)*A1(2)-A1(1)
      A1(5)=A1(2)
      A1(1)=A1(7)
      A1(7)=A1(4)
      A1(4)=A1(15)*A1(4)-A1(3)
      A1(6)=A1(4)
      A1(3)=A1(7)
      M=L+M8
C--ADD IN ALONG THE Y ROWS
      DO 1900 K=L,M
      A1(7)=A1(6)
      A1(6)=A1(16)*A1(6)-A1(5)
      A1(5)=A1(7)
      STORE(K)=STORE(K)+A1(6)
1900  CONTINUE
      L=L+MD8
1950  CONTINUE
2000  CONTINUE
      JF=JF+NE
2050  CONTINUE
      NB=NB+NC
C--CALCULATE THE FINAL FC AND ADD IT IN
      I=L8
      J=L8+NQ-1
      L=NP
      M=NP+NQ
      IF(IC)2100,2100,2200
C--NON-CENTRO
2100  CONTINUE
      DO 2150 K=I,J
      STORE(K)=STORE(K)+SQRT(STORE(L)*STORE(L)+STORE(M)*STORE(M))
      L=L+1
      M=M+1
2150  CONTINUE
      GOTO 2300
C--CENTRO
2200  CONTINUE
      DO 2250 K=I,J
      STORE(K)=STORE(K)+ABS(STORE(L))
      L=L+1
2250  CONTINUE
2300  CONTINUE
C
C--MAIN MAP PRINTING ROUTINES
      JA=MINY
      JB=NY
      JZ=1
      M8=L8
2400  CONTINUE
      JY=MIN0(JB,NCOL)-1
      JC=JA+JY
      CALL XPRTCN
      JD=NS-1
      DO 2450 I=JA,JC
      ISTORE(JD+1)=I
      JD=JD+1
2450  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2500)MINZ,JZ,(ISTORE(I),I=NS,JD)
      ENDIF
2500  FORMAT(' Trial map',5X,'Section',I4,5X,'Part',I3///8X,28I4)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2550)(IA,I=NS,JD)
      ENDIF
2550  FORMAT(8X,28(3X,A1))
      JE=M8
      JG=MINX
      DO 2850 I=1,NX
      JF=JE+JY
      DO 2750 J=JE,JF
      STORE(J)=STORE(J)*W
      IF(STORE(J)-999.)2650,2650,2600
2600  CONTINUE
      ISTORE(J)=999
      GOTO 2750
2650  CONTINUE
      ISTORE(J)=NINT(STORE(J))
      IF(ISTORE(J)-ITHRES)2700,2750,2750
2700  CONTINUE
      ISTORE(J)=0
2750  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2800)JG,IA,IB,(ISTORE(J),J=JE,JF)
      ENDIF
2800  FORMAT(/1X,I4,1X,2A1,28I4)
      JE=JE+MD8
      JG=JG+1
2850  CONTINUE
      JZ=JZ+1
      JY=JY+1
      JA=JA+JY
      M8=M8+JY
      JB=JB-JY
C--MORE TO PRINT
      IF(JB)2900,2900,2400
2900  CONTINUE
      MINZ=MINZ+1
2950  CONTINUE
C
C
C
3000  CONTINUE
C
C -- FINAL MESSAGE
C
      CALL XOPMSG ( IOPTRI , IOPEND , 200 )
      CALL XTIME2(2)
      RETURN
C
9900  CONTINUE
C -- ERRORS
      CALL XOPMSG ( IOPTRI , IOPABN , 0 )
      GO TO 3000
9910  CONTINUE
C -- INPUT ERROR
      CALL XOPMSG ( IOPTRI , IOPCMI , 0 )
      GO TO 9900
      END
C
CODE FOR XSFLSQ
      SUBROUTINE XSFLSQ(S,U)
C--MAIN STRUCTURE FACTOR CALCULATION ROUTINE
C
C  S  MIN VALUE OF FO (ON SCALE OF FO)
C  U  MAX. VALUE OF SUM(FO*FC)
C
C--USEAGE OF CONTROL VARIABLES :
C
C  JA  SET TO 1 FOR ISO ATOMS ONLY , ELSE N2
C  JE
C  JF  USED FOR POINTERS TO THE SIN/COS TERMS FOR EACH REFLECTION
C  JG
C  JS  WORK VARIABLE
C  JT  WORK VARIABLES USED DURING ACCUMULATION OF PARTIAL DERIVATIVES
C  JU
C  JV
C  JW
C  JX  LOOP VARIABLE FOR EQUIVALENT POSITIONS
C  JY  LOOP VARIABLE FOR ATOMS
C  JZ  LOOP VARIABLE FOR THE VARIOUS SYMMETRIES
C
C--USEAGE OF GENERAL VARIABLES
C
C  TC    COEFFICIENT FOR THE ISO-TEMPERATURE FACTORS
C  SST   SIN(THETA)/LAMBDA SQUARED
C  ST    SIN(THETA)/LAMBDA
C  FOCC  FORM FACTOR MULTIPLIED BY THE OCCUPATION NUMBER
C  T     TEMPERATURE FACTOR
C  TFOCC T*FOCC
C
C--XLST07 CONTROLS THE REFLECTION STACK :
C
C  NA    ADDRESS OF THE FIRST ENTRY IN THE STACK
C  NB    CURRENT ADDRESS IN THE STACK
C  NE    NUMBER OF WORDS PER SYMMETRY POSITION IN THE REFLECTION STACK
C  ND    NUMBER OF REFLECTIONS IN THE STACK
C
C  NC   NUMBER OF WORDS PER REFLECTION IN THE STACK (=N2*NE)
C
C--THE FORMAT OF THE STACK IS :
C
C   0  SUM[ COS2PI(H'.S.X + H'.T - 2H'.S.DX - 2H'.S.DY -  H'.S.DZ) ]
C   1  SUM[ SIN2PI(H'.S.X + H'.T - 2H'.S.DX - 2H'.S.DY -  H'.S.DZ) ]
C   2  SUM[ COS2PI(H'.S.X + H'.T -  H'.S.DX - 2H'.S.DY -  H'.S.DZ) ]
C   3  SUM[ SIN2PI(H'.S.X + H'.T -  H'.S.DX - 2H'.S.DY -  H'.S.DZ) ]
C   4  SUM[ COS2PI(H'.S.X + H'.T - 2H'.S.DX -  H'.S.DY -  H'.S.DZ) ]
C   5  SUM[ SIN2PI(H'.S.X + H'.T - 2H'.S.DX -  H'.S.DY -  H'.S.DZ) ]
C   6  SUM[ COS2PI(H'.S.X + H'.T -  H'.S.DX -  H'.S.DY -  H'.S.DZ) ]
C   7  SUM[ SIN2PI(H'.S.X + H'.T -  H'.S.DX -  H'.S.DY -  H'.S.DZ) ]
C   8  SUM[ COS2PI(H'.S.X + H'.T - 2H'.S.DX - 2H'.S.DY - 2H'.S.DZ) ]
C   9  SUM[ SIN2PI(H'.S.X + H'.T - 2H'.S.DX - 2H'.S.DY - 2H'.S.DZ) ]
C  10  SUM[ COS2PI(H'.S.X + H'.T -  H'.S.DX - 2H'.S.DY - 2H'.S.DZ) ]
C  11  SUM[ SIN2PI(H'.S.X + H'.T -  H'.S.DX - 2H'.S.DY - 2H'.S.DZ) ]
C  12  SUM[ COS2PI(H'.S.X + H'.T - 2H'.S.DX -  H'.S.DY - 2H'.S.DZ) ]
C  13  SUM[ SIN2PI(H'.S.X + H'.T - 2H'.S.DX -  H'.S.DY - 2H'.S.DZ) ]
C  14  SUM[ COS2PI(H'.S.X + H'.T -  H'.S.DX -  H'.S.DY - 2H'.S.DZ) ]
C  15  SUM[ SIN2PI(H'.S.X + H'.T -  H'.S.DX -  H'.S.DY - 2H'.S.DZ) ]
C  16  H'.S.DX
C  17  2*COS2PI(H'.S.DX)
C  18  H'.S.DY
C  19  2*COS2PI(H'.S.DY)
C  20  H'.S.DZ
C  21  2*COS2PI(H'.S.DZ)
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XPDS.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XLST02.INC'
      INCLUDE 'XLST03.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST06.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--INITIALISE TIMING OF THIS SECTION
      CALL XTIME1(3)
      U=0.
      ND=0
      SCALE=1.0/STORE(L5O)
      NA=NFL
      NE=22
      NC=NE*N2
      NB=NA-NC
      IF(N5)1100,1100,2150
C
C--START OF THE LOOP OVER REFLECTIONS
C
1000  CONTINUE
      IF(S-STORE(M6+3))1050,1050,2150
1050  CONTINUE
      ND=ND+1
      NB=NB+NC
      IF(NB+NC-LFL)1150,1100,1100
C--NO MORE STORE AVAILABLE
1100  CONTINUE
      CALL XICA
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2250)ND
      ENDIF
      ND=0
      GOTO 2300
1150  CONTINUE
C
C--CALCULATE THE INFORMATION FOR THE SYMMETRY POSITIONS
C
      M2=L2
      M2T=L2T
      JF=NB
      DO 1400 JZ=1,N2
      STORE(M2T)=STORE(M6)*STORE(M2)+STORE(M6+1)*STORE(M2+3)
     2 +STORE(M6+2)*STORE(M2+6)
      STORE(M2T+1)=STORE(M6)*STORE(M2+1)+STORE(M6+1)*STORE(M2+4)
     2 +STORE(M6+2)*STORE(M2+7)
      STORE(M2T+2)=STORE(M6)*STORE(M2+2)+STORE(M6+1)*STORE(M2+5)
     2 +STORE(M6+2)*STORE(M2+8)
C--CALCULATE THE H.T TERMS
      STORE(M2T+3)=(STORE(M6)*STORE(M2+9)+STORE(M6+1)*STORE(M2+10)
     2 +STORE(M6+2)*STORE(M2+11))*TWOPI
C--CHECK IF THE ANSIO CONTRIBUTIONS ARE REQUIRED
      IF(JA-JZ)1250,1200,1200
1200  CONTINUE
      STORE(M2T+4)=STORE(M2T)*STORE(M2T)
      STORE(M2T+5)=STORE(M2T+1)*STORE(M2T+1)
      STORE(M2T+6)=STORE(M2T+2)*STORE(M2T+2)
      STORE(M2T+7)=STORE(M2T+1)*STORE(M2T+2)
      STORE(M2T+8)=STORE(M2T)*STORE(M2T+2)
      STORE(M2T+9)=STORE(M2T)*STORE(M2T+1)
1250  CONTINUE
      STORE(M2T)=STORE(M2T)*TWOPI
      STORE(M2T+1)=STORE(M2T+1)*TWOPI
      STORE(M2T+2)=STORE(M2T+2)*TWOPI
C--CLEAR THE ACCUMULATION AREAS FOR EACH SYMMETRY POSITION
      JG=JF+NE-1
      DO 1300 JY=JF,JG
      STORE(JY)=0.
1300  CONTINUE
C--CALCULATE THE STEP VECTORS
      JG=JF+16
      DO 1350 JY=1,7,3
      STORE(JG+1)=STORE(M2T)*APD(JY)+STORE(M2T+1)*APD(JY+1)
     2 +STORE(M2T+2)*APD(JY+2)
      STORE(JG)=2.*COS(STORE(JG+1))
      JG=JG+2
1350  CONTINUE
      JF=JF+NE
      M2=M2+MD2
      M2T=M2T+MD2T
1400  CONTINUE
C--CALCULATE SIN(THETA)/LAMBDA SQUARED
      SST=STORE(L1S)*STORE(L2T+4)+STORE(L1S+1)*STORE(L2T+5)
     2 +STORE(L1S+2)*STORE(L2T+6)+STORE(L1S+3)*STORE(L2T+7)
     3 +STORE(L1S+4)*STORE(L2T+8)+STORE(L1S+5)*STORE(L2T+9)
      ST=SQRT(SST)
C--CALCULATE THE TEMPERATURE FACTOR COEFFICIENT
      TC=-SST*TWOPIS*4.
C--CHECK IF THE ANISO TERMS ARE REQUIRED
      IF(JJ)1550,1450,1450
1450  CONTINUE
      M2T=L2T
      DO 1500 JZ=1,N2
      STORE(M2T+4)=STORE(M2T+4)*STORE(L1A)
      STORE(M2T+5)=STORE(M2T+5)*STORE(L1A+1)
      STORE(M2T+6)=STORE(M2T+6)*STORE(L1A+2)
      STORE(M2T+7)=STORE(M2T+7)*STORE(L1A+3)
      STORE(M2T+8)=STORE(M2T+8)*STORE(L1A+4)
      STORE(M2T+9)=STORE(M2T+9)*STORE(L1A+5)
      M2T=M2T+MD2T
1500  CONTINUE
1550  CONTINUE
C
C--CALCULATE THE FORM FACTORS
      CALL XSCATT(ST)
      DO 1600 JZ=1,N3
      M3TR=L3TR+JZ-1
      STORE(M3TR)=STORE(M3TR)*G2
1600  CONTINUE
C
C--LOOP OVER THE ATOMS IN THE CELL
      M5A=L5
      DO 2100 JY=1,N5
C--PICK UP THE FORM FACTORS FOR THIS ATOM
      M3TR=L3TR+ISTORE(M5A)
      FOCC=STORE(M3TR)*STORE(M5A+2)
C--CHECK THE TEMPERAURE TYPE FOR THIS ATOM
      IF(ISTORE(M5A+1))1700,1750,1750
C--CALCULATE THE ISO-TEMPERATURE FACTOR COEFFICIENTS FOR THIS ATOM
1700  CONTINUE
      T=EXP(STORE(M5A+7)*TC)
      TFOCC=T*FOCC
C
C--LOOP CYCLING OVER THE DIFFERENT EQUIVALENT POSITIONS FOR THIS ATOM
C
1750  CONTINUE
      JF=NB
      M2T=L2T
      DO 2050 JX=1,N2T
C--SET UP THE H'.DX COMPONENTS FOR THIS SYMMETRY POSITION
      XDS=STORE(JF+17)
      YDS=STORE(JF+19)
      ZDS=STORE(JF+21)
C--CALCULATE H'.X+H.T - H'.DX
      A=STORE(M5A+4)*STORE(M2T)+STORE(M5A+5)*STORE(M2T+1)+STORE(M5A+6)
     2 *STORE(M2T+2)+STORE(M2T+3)-XDS-YDS-ZDS
C--CHECK THE TEMPERATURE FACTOR TYPE
      IF(ISTORE(M5A+1))1850,1800,1800
C--CALCULATE THE ANISO-TEMPERATURE FACTOR
1800  CONTINUE
      T=EXP(STORE(M5A+7)*STORE(M2T+4)+STORE(M5A+8)*STORE(M2T+5)
     2 +STORE(M5A+9)*STORE(M2T+6)+STORE(M5A+10)*STORE(M2T+7)
     3 +STORE(M5A+11)*STORE(M2T+8)+STORE(M5A+12)*STORE(M2T+9))
      TFOCC=T*FOCC
C--CALCULATE THE SIN/COS TERMS
1850  CONTINUE
      C=TFOCC*STORE(M6+3)*SCALE
      U=U+C
      STORE(JF)=STORE(JF)+C*COS(A-XDS-YDS)
      STORE(JF+2)=STORE(JF+2)+C*COS(A-YDS)
      STORE(JF+4)=STORE(JF+4)+C*COS(A-XDS)
      STORE(JF+6)=STORE(JF+6)+C*COS(A)
      STORE(JF+8)=STORE(JF+8)+C*COS(A-XDS-YDS-ZDS)
      STORE(JF+10)=STORE(JF+10)+C*COS(A-YDS-ZDS)
      STORE(JF+12)=STORE(JF+12)+C*COS(A-XDS-ZDS)
      STORE(JF+14)=STORE(JF+14)+C*COS(A-ZDS)
      IF(IC)1900,1900,1950
C--ADD IN THE NON-CENTRO PART
1900  CONTINUE
      STORE(JF+1)=STORE(JF+1)+C*SIN(A-XDS-YDS)
      STORE(JF+3)=STORE(JF+3)+C*SIN(A-YDS)
      STORE(JF+5)=STORE(JF+5)+C*SIN(A-XDS)
      STORE(JF+7)=STORE(JF+7)+C*SIN(A)
      STORE(JF+9)=STORE(JF+9)+C*SIN(A-XDS-YDS-ZDS)
      STORE(JF+11)=STORE(JF+11)+C*SIN(A-YDS-ZDS)
      STORE(JF+13)=STORE(JF+13)+C*SIN(A-XDS-ZDS)
      STORE(JF+15)=STORE(JF+15)+C*SIN(A-ZDS)
1950  CONTINUE
C--UPDATE THE SYMMETRY INFORMATION POINTER
      M2T=M2T+MD2T
      JF=JF+NE
2050  CONTINUE
      M5A=M5A+MD5A
2100  CONTINUE
C
C--PICK UP THE NEXT REFLECTION
2150  CONTINUE
      IF(KFNR(0)) 2200,1000,1000
2200  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2250)ND
      ENDIF
2250  FORMAT(///,' Structure factors end after',I6,'  reflection(s)')
2300  CONTINUE
      CALL XTIME2(3)
      NFL=NB+NC
      RETURN
      END
C
CODE FOR XSLANT
      SUBROUTINE XSLANT(inproc,inn)
C--SLANT FOURIER SUBROUTINE
cdjwdec2000  make into subroutine.
c      inproc(inn) can either be a dummy, dimension 1, with value
c      -100 indicating that the contants of [rocin should be loaded
c      by a read from the user-input
c      or a real array dimensioned to NPROCS (see below) with values 
c      set by a calling routine.

C
C  IN     TYPE OF FOURIER :
C         1  FO
C         2  FC
C         3  DF
C         4  FO PATTERSON
C         5  FC PATTERSON
c         6  2Fo-Fc
c         7  FoSq-FcSq-Patterson
C  ITHRES PRINT 0 FOR ALL VALUES LESS THAN THIS
C  SCALE  MAP SCALE FACTOR
C  IWT    WEIGHTING
C         0 FOR NO, ELSE 1
C
C--USE OF VARIABLES :
C
C  R  STEP ALONG X IN THE PLANE
C  S  STEP ALONG Y IN THE PLANE
C  U  FINAL MAP SCALE FACTOR
C  V  FC SCALE FACTOR
C  W  SUM OF F*F FOR A PATTERSON
C  X  TRANSFORMED H
C  Y  TRANSFORMED K
C  Z  TRANSFORMED L
C
C--
      INCLUDE 'ISTORE.INC'
C
      dimension inproc(inn)
      PARAMETER (NPROCS = 29)
      DIMENSION PROCS(NPROCS)
      DIMENSION IPROCS(NPROCS)
      DIMENSION APD(13)
      DIMENSION A1(26)
      DIMENSION AMIN(3),XYZ(3)
      CHARACTER*16 CMAPTP(7)
      CHARACTER*8  WTED
      CHARACTER*24 CSERI
      DIMENSION KDEV(4)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XTAPES.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XLST02.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST06.INC'
      INCLUDE 'XLST20.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'XIOBUF.INC'

C For the name of the fourier.map file:
      INCLUDE 'TSSCHR.INC'
      INCLUDE 'XSSCHR.INC'
      INCLUDE 'UFILE.INC'

cjan99
        REAL START(3), STEPS(3),  TRANS(12)
        INTEGER NUM(3)
cjan99
        REAL MAT(3)
C
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (APD(1),PROCS(1))
      EQUIVALENCE (IN,APD(10)),(ITHRES,APD(11)),(SCALE,APD(12))
      EQUIVALENCE (IWT, APD(13))
      EQUIVALENCE (A1(1),A)
      EQUIVALENCE (PROCS(1), IPROCS(1))
      EQUIVALENCE (IMODE, PROCS(27)), (IOUTAP, PROCS(26))
      EQUIVALENCE (IOUFIL, PROCS(28))
      EQUIVALENCE (PROCS(29), ITYP06)
C
C
      DATA NCOL/28/
C
      DATA CMAPTP / '    F-Obs map   ' , '   F-Calc map   ' ,
     2              ' Difference map ' , '  FO-Patterson  ' ,
     3              '  FC-Patterson  ' , '    2Fo-Fc      ' ,
     3              ' FoSq-FcSq-Patt '/
C
C
      NW=7
C--INITIALISE THE TIMING FUNCTION
      CALL XTIME1(1)
cdec2000 make internally callable
      CALL XMOVEI(INPROC(1), APROC, 1)
      if (APROC .le. -100.) then
C--READ THE DATA
      ISTAT = KRDDPV ( PROCS, NPROCS)
      IF ( ISTAT .LT. 0 ) GO TO 9910
      CALL XRSL
      CALL XCSAE
      else
       if (inn .eq. nprocs) then
            call xmovei(inproc, iprocs, nprocs)
       else
            goto 9910
       endif
      endif
C
C----- FIND THE REFLECTION LIST TYPE
      IULN6=KTYP06(ITYP06)
C--LOAD LISTS ONE AND TWO
      IF (KHUNTR ( 1,0, IADDL,IADDR,IADDD, -1) .LT. 0) CALL XFAL01
      IF (KHUNTR ( 2,0, IADDL,IADDR,IADDD, -1) .LT. 0) CALL XFAL02
      IF (KHUNTR ( 20,0, IADDL,IADDR,IADDD, -1) .LT. 0) CALL XFAL20
C----- CHECK IF WE USE THE MOLAX MATRIX -
      IF (IMODE .GE. 1) THEN
      CALL XMOVE (STORE(L20V+ IMODE * MD20V), PROCS(14), 3)
C----- COPY AND TRANSPOSE
      CALL XTRANS (STORE(L20M+ IMODE * MD20M), PROCS(1), 3, 3)
      ENDIF
      IF ( IERFLG .LT. 0 ) GO TO 9900
      L2=L2I
      M2=L2+(N2-1)*MD2
C----- SET UP AREA FOR TAPE HEADER
      ITAPE = KCHLFL(21)
C--SET UP AN AREA FOR THE NEW CALCULATED INDICES
      LN=6
      IREC=8001
      JA=NFL
      JB=KCHNFL(N2*NW)
      JADUMP = JA
      JBDUMP = JB
      IF(SCALE-ZEROSQ)1100,1100,1150
1100  CONTINUE
      SCALE=10.
1150  CONTINUE
      U=SCALE
      IF (IWT .LE. 0) THEN
            WTED = '        '
      ELSE
            WTED = 'Weighted'
      ENDIF
C--INVERT THE ROTATION MATRIX
      LN=8
      IREC=8001
      L8RI=KCHLFL(9)
      L8R=KCHLFL(9)
      CALL XMOVE(PROCS(1),STORE(L8R),9)
C----- LOOK FOR SOME SORT OF MATRIX
      IF (ABS(XDETR3(PROCS(1))) .LE. ZERO) THEN
       WRITE ( CMON , 1060) (PROCS(I), I = 1,9)
       CALL XPRVDU(NCVDU, 4,0)
       IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') (CMON(II)(:),II=1,4)
1060   FORMAT (' Your matrix is probably invalid ', 3(/3F9.3))
       GOTO 9900
      ENDIF
      IF(KINV2(3,STORE(L8R),STORE(L8RI),9,0,APD(1),APD(1),9))9920 ,
     1 1300 , 9920
C--MOVE THE CENTROID AND STEPS IN X, Y AND THE Z HEIGHT
1300  CONTINUE
C----- SPACE FOR THE SECTION LIMITS
      L8T= NFL
      I = KCHNFL(12)
C--READ DOWN THE SCALE FACTOR FROM LIST 5
      V=1.
      IF(KEXIST(5))1600,1600,1550
C--LOAD THE CURRENT LIST 5
1550  CONTINUE
      CALL XFAL05
      IF ( IERFLG .LT. 0 ) GO TO 9900
      V=1./STORE(L5O)
1600  CONTINUE
C--SET UP THE INPUT OF REFLECTION LIST
      CALL XFAL06(IULN6,0)
      L6DUMP = L6R
      N6DUMP = N6R
C
      CALL XMOVE(PROCS(14),STORE(L8T),12)
C----- FLOAT THE NUMBER  OF POINTS (THE INTEGER IS STILL IN ISTORE)
      PROCS(18) = FLOAT( ISTORE(L8T+4))
      PROCS(21) = FLOAT( ISTORE(L8T+7))
      PROCS(24) = FLOAT( ISTORE(L8T+10))
C
C----- WRITE THE M/T HEADER  DETAILS
      IF (IOUTAP .GT. 0) THEN
          REWIND (MT1)
          WRITE (MT1) 'INFO  DOWN, ACROSS AND SECTION '
          WRITE (MT1) 'TRAN', (STORE(I), I=L8R, L8R+8),
     1       (PROCS(I), I=14,16)
          WRITE (MT1) 'CELL', (STORE(I), I = L1P1, L1P1+5)
          WRITE (MT1) 'L14 ',
     1       (STORE(I),STORE(I+2),(STORE(I)+(ISTORE(I+1)-1)*STORE(I+2)),
     1       1. , I = L8T+3, L8T+9, 3)
          WRITE (MT1) 'SIZE', ISTORE(L8T+4), ISTORE(L8T+7),
     1       ISTORE(L8T+10)
           NXNY = ISTORE(L8T+4) * ISTORE(L8T+7)
      END IF

      IF (IOUFIL .EQ. 1 ) THEN
           CALL XMOVEI(KEYFIL(1,23), KDEV, 4)
           CALL XRDOPN(6, KDEV , CSSMAP, LSSMAP)
1651       FORMAT(A)
1652       FORMAT(F15.8)
1653       FORMAT(I8)
           WRITE (NCFPU1,1651) 'INFO  DOWN, ACROSS AND SECTION '
           WRITE (NCFPU1,1651) 'TRAN'
           WRITE (NCFPU1,1652) (STORE(I),I=L8R,l8R+8),(PROCS(I),I=14,16)
           WRITE (NCFPU1,1651) 'CELL'
           WRITE (NCFPU1,1652) (STORE(I), I = L1P1, L1P1+5)
           WRITE (NCFPU1,1651) 'L14 '
           WRITE (NCFPU1,1652)
     1     (STORE(I),STORE(I+2),(STORE(I)+(ISTORE(I+1)-1)*STORE(I+2)),
     1      1. , I = L8T+3, L8T+9, 3)
           WRITE (NCFPU1,1651) 'SIZE'
           WRITE (NCFPU1,1653)ISTORE(L8T+4),ISTORE(L8T+7),ISTORE(L8T+10)
           NXNY = ISTORE(L8T+4) * ISTORE(L8T+7)
      ENDIF
C

      IF ( IOUFIL .EQ. 2 ) THEN
          CALL XMOVEI(KEYFIL(1,23), KDEV, 4)
          CALL XRDOPN(7, KDEV , CSSMAP, LSSMAP)  !Close unit
          OPEN ( UNIT   = NCFPU1,                !Special open
     1         FILE = CSSMAP(1:LSSMAP),
     1         STATUS = 'UNKNOWN' ,
     1         ACCESS = 'DIRECT' ,
     1         FORM   = 'UNFORMATTED' ,
     1         RECL   = 1 ,
     1         IOSTAT = IOS ,
     1         ERR    = 9900 )

C WRITE THE MAPVIEW HEADER DETAILS
          DO I = 1,3
            WRITE (NCFPU1,REC=I) ISTORE(L8T+1+I*3)   !NX,NY,NZ
          END DO
C STEPX,STEPY,STEPZ
          WRITE (NCFPU1,REC=4) STORE(L8T+5)
          WRITE (NCFPU1,REC=5) STORE(L8T+8)
          WRITE (NCFPU1,REC=6) STORE(L8T+11)
C MAP UNITS
          DO I = 0,2
            WRITE (NCFPU1,REC=I+7) ISTORE(L8T+4+I*3) * STORE(L8T+5+I*3)
          END DO
          DO I = 3,5
            WRITE (NCFPU1,REC=I+7) 90.0
          END DO
C STARTX,Y,Z
          WRITE (NCFPU1,REC=13) STORE(L8T+3)
          WRITE (NCFPU1,REC=14) STORE(L8T+6) 
          WRITE (NCFPU1,REC=15) STORE(L8T+9)
C Projection axis 1=A*,2=B*,3=C*
          WRITE (NCFPU1,REC=16) 3
C Mode 1=3D, 2=Slant
          WRITE (NCFPU1,REC=17) 2
C Min max values
          WRITE (NCFPU1,REC=18) -100.0
          WRITE (NCFPU1,REC=19) 100.0
          JPOINT = 19
          DENMIN =  100000.
          DENMAX =  -100000.
          NXNY = ISTORE(L8T+4) * ISTORE(L8T+7)
      ENDIF



C--CHECK THAT THERE ARE SOME REASONABLE INTERVALS
      IF(ABS(STORE(L8T+5))-0.0001)1400,1400,1350
1350  CONTINUE
      IF(ABS(STORE(L8T+8))-0.0001)1400,1400,1500
C--INCORRECT INTERVALS
1400  CONTINUE
      WRITE ( CMON ,1450)
      CALL XPRVDU(NCVDU, 1,0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU, '(/A)') CMON(1 )(:)
1450  FORMAT(' Illegal x or y divisions')
      GOTO 9910
C--COMPUTE THE NUMBER OF STEPS AND THE FIRST PONTS
1500  CONTINUE
      NX=MAX0(1,ISTORE(L8T+4))
      NY=MAX0(1,ISTORE(L8T+7))
      A=STORE(L8T+3)/ABS(STORE(L8T+5))
      MINX=NINT(A)
      A=STORE(L8T+6)/ABS(STORE(L8T+8))
      MINY=NINT(A)
C--CALCULATE THE STEPS ALONG X AND Y IN THE PLANE
      R=STORE(L8T+5)*TWOPI
      S=STORE(L8T+8)*TWOPI
C
C--SET UP THE MAP AREA
      LN=8
      IREC=8003
      L8=NFL
      MD8=NY
      M8=KCHNFL(MD8*NX)-1
      IREC=8004
      NS=KCHLFL(NCOL)
      M8DUMP = M8
      L8DUMP = L8
      NSDUMP = NS
C
C----- START LOOPING OVER SECTIONS
      DO 3300, ISECT = 1, ISTORE(L8T+10)
      ZCOORD=STORE(L8T+9)
C--CALCULATE THE COORDINATES OF THE FIRST POINT
      AMIN(1)=STORE(L8T)+STORE(L8RI)*STORE(L8T+3)+STORE(L8RI+1)
     2 *STORE(L8T+6)+STORE(L8RI+2)*STORE(L8T+9)
      AMIN(2)=STORE(L8T+1)+STORE(L8RI+3)*STORE(L8T+3)+STORE(L8RI+4)
     2 *STORE(L8T+6)+STORE(L8RI+5)*STORE(L8T+9)
      AMIN(3)=STORE(L8T+2)+STORE(L8RI+6)*STORE(L8T+3)+STORE(L8RI+7)
     2 *STORE(L8T+6)+STORE(L8RI+8)*STORE(L8T+9)
      AMIN(1)=AMIN(1)*TWOPI
      AMIN(2)=AMIN(2)*TWOPI
      AMIN(3)=AMIN(3)*TWOPI
C
C--CLEAR THE MAP AREA
      M8 = M8DUMP
      L8 = L8DUMP
      NS = NSDUMP
      DO 1650 I=L8,M8
      STORE(I)=0.
1650  CONTINUE
      W=0.
C
C--START OF THE REFLECTION FETCHING LOOP
1700  CONTINUE
      IF(KFNR(0)) 2600,1750,1750
C--GENERATE THE EQUIVALENT REFLECTIONS FOR THESE INDICES
1750  CONTINUE
      JB=JA
      DO 2000 I=L2,M2,MD2
C--CALCULATE THE NEW INDICES
      STORE(JB)=STORE(M6)*STORE(I)+STORE(M6+1)*STORE(I+3)+STORE(M6+2)
     2 *STORE(I+6)
      STORE(JB+1)=STORE(M6)*STORE(I+1)+STORE(M6+1)*STORE(I+4)
     2 +STORE(M6+2)*STORE(I+7)
      STORE(JB+2)=STORE(M6)*STORE(I+2)+STORE(M6+1)*STORE(I+5)
     2 +STORE(M6+2)*STORE(I+8)
C--CHECK IF THESE INDICES HAVE BEEN FOUND BEFORE
      IF(JB-JA)1950,1950,1800
C--CYCLE THROUGH ALL THE PREVIOUS INDICES
1800  CONTINUE
      JC=JB-NW
      DO 1900 J=JA,JC,NW
      IF(ABS(STORE(J)-STORE(JB))+ABS(STORE(J+1)-STORE(JB+1))
     2 +ABS(STORE(J+2)-STORE(JB+2))-0.01)2000,2000,1850
1850  CONTINUE
      IF(ABS(STORE(J)+STORE(JB))+ABS(STORE(J+1)+STORE(JB+1))
     2 +ABS(STORE(J+2)+STORE(JB+2))-0.01)2000,2000,1900
1900  CONTINUE
C--THIS REFLECTION IS UNIQUE
1950  CONTINUE
      IF (IWT .LE. 0) THEN
            STORE(JB+3)=STORE(M6+3)*V
            STORE(JB+4)=STORE(M6+4)
            STORE(JB+5)=STORE(M6+5)
      ELSE
            STORE(JB+3)=STORE(M6+3)*V*STORE(M6+4)
            STORE(JB+4)=STORE(M6+4)
            STORE(JB+5)=STORE(M6+5)*STORE(M6+4)
      ENDIF
      STORE(JB+6)=STORE(M6+6)-TWOPI*(STORE(JB)*STORE(I+9)+STORE(JB+1)
     2 *STORE(I+10)+STORE(JB+2)*STORE(I+11))
      JB=JB+NW
2000  CONTINUE
      JB=JB-NW
C
C--MAIN LOOP FOR ADDING IN THE GENERATED REFLECTIONS
      DO 2550 I=JA,JB,NW
      GOTO(2100,2150,2200,2250,2300,2310,2320,2050),IN
C2050  STOP 275
2050  CALL GUEXIT(275)
C--'FO' FOURIER
2100  CONTINUE
      F=STORE(I+3)
      GOTO 2400
C--'FC' FOURIER
2150  CONTINUE
      F=STORE(I+5)
      GOTO 2400
C--'DF' FOURIER
2200  CONTINUE
      F=STORE(I+3)-STORE(I+5)
      GOTO 2400
C--'FO' PATTERSON
2250  CONTINUE
      F=STORE(I+3)*STORE(I+3)
      GOTO 2350
C--'FC' PATTERSON
2300  CONTINUE
      F=STORE(I+5)*STORE(I+5)
      GOTO 2350
c--'2Fo-Fc' Fourier
2310  continue
      F=2. * STORE(I+3)-STORE(I+5)
csep09      GOTO 2350
      GOTO 2400
C--'FOsq-FCsq' PATTERSON
2320  CONTINUE
      F=(STORE(I+3)*STORE(I+3)) - STORE(I+5)*STORE(I+5)
      GOTO 2350
C--ACCUMULATE THE ORIGIN FOR SCALING
2350  CONTINUE
      STORE(I+6)=0.
      W=W+F
C--CALCULATE THE TRANSFORMED INDICES
2400  CONTINUE
      X=STORE(I)*STORE(L8RI)+STORE(I+1)*STORE(L8RI+3)+STORE(I+2)
     2 *STORE(L8RI+6)
      Y=STORE(I)*STORE(L8RI+1)+STORE(I+1)*STORE(L8RI+4)+STORE(I+2)
     2 *STORE(L8RI+7)
C--COMPUTE A FEW INTIAL CONSTANTS NEEDED BEFORE ADDING INTO THE MAP
      O=X*R
      P=Y*S
      H=STORE(I)*AMIN(1)-O+STORE(I+1)*AMIN(2)-P+STORE(I+2)*AMIN(3)
     2 -STORE(I+6)
      A=F*COS(H-O-P)
      B=F*COS(H-P)
      C=F*COS(H-O)
      D=F*COS(H)
      O=2.*COS(O)
      P=2.*COS(P)
C
C--MAIN LOOP FOR ADDING INTO THE MAP
      L=L8
      M8=NY-1
C--PASS ALONG THE X ROWS
      DO 2500 J=1,NX
      A1(7)=A1(2)
      A1(2)=A1(15)*A1(2)-A1(1)
      A1(5)=A1(2)
      A1(1)=A1(7)
      A1(7)=A1(4)
      A1(4)=A1(15)*A1(4)-A1(3)
      A1(6)=A1(4)
      A1(3)=A1(7)
      M=L+M8
C--ADD IN ALONG THE Y ROWS
      DO 2450 K=L,M
      A1(7)=A1(6)
      A1(6)=A1(16)*A1(6)-A1(5)
      A1(5)=A1(7)
      STORE(K)=STORE(K)+A1(6)
2450  CONTINUE
      L=L+MD8
2500  CONTINUE
2550  CONTINUE
C--GO BACK FOR MORE REFLECTIONS
      GOTO 1700
C
C--END OF THE MAP  -  CALCULATE THE SCALE FACTORS
2600  CONTINUE
      GOTO(2700,2700,2700,2750,2750,2700,2650),IN
C2650  STOP 344
2650  CALL GUEXIT(344)
2700  CONTINUE
      W=U*2./STORE(L1P1+6)
      GOTO 2800
2750  CONTINUE
      W=999./W
C
C--MAIN MAP PRINTING ROUTINES
2800  CONTINUE
      IF (IOUTAP .GT. 0) THEN
        WRITE(MT1) NXNY, (STORE(I)*W, I= L8, L8+NXNY-1)
      ENDIF
      IF (IOUFIL .EQ. 1) THEN             !MCE file
2801    FORMAT (A)
2802    FORMAT (I8)
2803    FORMAT (F15.8)
        WRITE(NCFPU1,2801) 'BLOCK'
        WRITE(NCFPU1,2802) NXNY
        WRITE(NCFPU1,2803) (STORE(I)*W, I= L8, L8+NXNY-1)
      ENDIF
      IF ( IOUFIL .EQ. 2 ) THEN           !MapView file
        DO I = L8,L8+NXNY-1
          JPOINT = JPOINT + 1
          WRITE(NCFPU1,REC=JPOINT) STORE(I)*W
          DENMIN = MIN(DENMIN,STORE(I)*W)
          DENMAX = MAX(DENMAX,STORE(I)*W)
        END DO
      ENDIF
      JA=MINY
      JB=NY
      JZ=1
      M8=L8
2850  CONTINUE
      JY=MIN0(JB,NCOL)-1
      JC=JA+JY
      CALL XPRTCN
      JD=NS-1
      DO 2900 I=JA,JC
      ISTORE(JD+1)=I
      JD=JD+1
2900  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 2950 ) WTED, CMAPTP(IN) ,
     2 ZCOORD , JZ , ( ISTORE(I) , I = NS , JD )
      ENDIF
2950  FORMAT ( 1X , A, 'Slant Fourier' , 5X , 'Map type is ' , A ,
     2 5X , 'Z =' , F7.3 , 5X , 'Part' , I3 , /// , 8X , 28I4 )
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3000)(IA,I=NS,JD)
      ENDIF
3000  FORMAT(8X,28(3X,A1))
      JE=M8
      JG=MINX
      DO 3200 I=1,NX
      JF=JE+JY
      DO 3100 J=JE,JF
      ISTORE(J)=NINT(STORE(J)*W)
      IF(ISTORE(J)-ITHRES)3050,3100,3100
3050  CONTINUE
      ISTORE(J)=ITHRES
3100  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3150)JG,IA,IB,(ISTORE(J),J=JE,JF)
      ENDIF
3150  FORMAT(/1X,I4,1X,2A1,28I4)
      JE=JE+MD8
      JG=JG+1
3200  CONTINUE
      JZ=JZ+1
      JY=JY+1
      JA=JA+JY
      M8=M8+JY
      JB=JB-JY
C--MORE TO PRINT
      IF(JB)3250,3250,2850
3250  CONTINUE
C----- GET READY FOR NEXT SECTION
      STORE(L8T+9) = STORE(L8T+9) + STORE(L8T+11)
C----- RESTORE REFLECTION ADDRESSES
      N6R = N6DUMP
      L6R = L6DUMP
C----- RESTORE NEW INDEX AREAS
      JA = JADUMP
      JB = JBDUMP
3300  CONTINUE
3301  FORMAT(A)
3302  FORMAT(I8)
3303  FORMAT(F15.8)
      IF (IOUTAP .GT. 0) THEN
        WRITE(MT1) N5, MD5
        M5 = L5
        DO 3310 I = 1, N5
            WRITE(MT1) (STORE(J),J=M5, M5+MD5-1)
            M5 = M5 + MD5
3310    CONTINUE
      ENDIF
      IF (IOUFIL .EQ. 1) THEN
        WRITE(NCFPU1,3301)'LIST5'
        WRITE(NCFPU1,3302)N5,MD5
        M5 = L5
        DO I = 1, N5
            WRITE(NCFPU1,3301) STORE(M5)
            DO J = M5+1,M5+MD5-1
                WRITE(NCFPU1,3303) STORE(J)
            END DO
            M5 = M5 + MD5
        END DO
        WRITE ( NCFPU1 ,' ( ''SYMM'' )' )
C--FIND OUT IF THE STRUCTURE IS CENTRIC
        IF ( STORE(L2C) .LT. 0.5 ) THEN
          WRITE ( NCFPU1 , '(''NONC'')' )
        ELSE
          WRITE ( NCFPU1 , '(''CENT'')' )
        END IF
        DO IND1=L2P,M2P,3
          DO IND2=L2,M2,MD2
C--COMBINE T(I) & P(K) VECTORS
            MAT(1)=STORE(IND2+9)+STORE(IND1)
            MAT(2)=STORE(IND2+10)+STORE(IND1+1)
            MAT(3)=STORE(IND2+11)+STORE(IND1+2)
            DO N = 1 , 3
              MAT(N) = MAT(N) - INT(MAT(N))
            END DO
C--DO NOT PRINT UNIT MATRIX.
            IF ( (STORE(IND2) .NE. 1.0 )   .OR.
     1           (STORE(IND2+4) .NE. 1.0 ) .OR.
     1           (STORE(IND2+8) .NE. 1.0 ) .OR.
     1           ( ( MAT(1) + MAT(2) + MAT(3) )  .NE.  0.0 ) ) THEN
              WRITE ( NCFPU1 , '( ''MATR'' )')
              IND4=0
              DO IND3=IND2,IND2+6,3
                IND4=IND4+1
                WRITE (NCFPU1,3340) STORE(IND3),STORE(IND3+1),
     1                               STORE(IND3+2),MAT(IND4)
3340            FORMAT (4(F7.3,1X))
              END DO
            END IF
          END DO
        END DO
        WRITE ( NCFPU1 , '(''END'')' )

C Close the fourier.map file
        CALL XMOVEI(KEYFIL(1,23), KDEV, 4)
        CALL XRDOPN(7, KDEV , CSSMAP, LSSMAP)
      ENDIF
      IF ( IOUFIL .EQ. 2 ) THEN
        WRITE (NCFPU1,REC=18) DENMIN
        WRITE (NCFPU1,REC=19) DENMAX
        JPOINT = JPOINT + 1
        WRITE (NCFPU1,REC=JPOINT) N5
        JPOINT = JPOINT + 1
        M5 = L5
        DO K = 1, N5          
          CALL CATSTR (STORE(M5),STORE(M5+1),1,1,0,0,0,CSERI,LSERI)
          WRITE ( NCFPU1,REC=JPOINT) CSERI(1:4)
          WRITE ( NCFPU1,REC=JPOINT+1) CSERI(5:8)
          JPOINT = JPOINT + 2
          CALL XSUBTR(STORE(M5+4),STORE(L8T),AMIN(1),3)
          CALL XMLTTM(STORE(L8R),AMIN(1),XYZ(1),3,3,1)
          WRITE ( NCFPU1,REC=JPOINT)   XYZ(1)
          WRITE ( NCFPU1,REC=JPOINT+1) XYZ(2)
          WRITE ( NCFPU1,REC=JPOINT+2) XYZ(3)
          JPOINT = JPOINT + 3
          M5 = M5 + MD5
        END DO
        CALL XMOVEI(KEYFIL(1,23), KDEV, 4)
        CALL XRDOPN(7, KDEV , CSSMAP, LSSMAP)
      END IF

C
3350  CONTINUE
      CALL XOPMSG (IOPSLA, IOPEND, 201)
      CALL XTIME2(1)
      RETURN
C
9900  CONTINUE
C -- ERRORS
      CALL XOPMSG ( IOPSLA , IOPABN , 0 )
      GOTO 3350
9910  CONTINUE
C -- INPUT ERROR
      CALL XOPMSG ( IOPSLA , IOPCMI , 0 )
      GO TO 9900
9920  CONTINUE
C -- SINGULAR MATRIX
      WRITE ( CMON, 9925 )
      CALL XPRVDU(NCVDU, 1,0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') CMON( 1)(:)
9925  FORMAT ( 1X , 'Rotation matrix is singular' )
      CALL XERHND ( IERERR )
      GO TO 9900
C
C
      END


CODE FOR XVSLANT
      SUBROUTINE XVSLANT
C--SLANT VOID SUBROUTINE
C
C  ITHRES PRINT 0 FOR ALL VALUES LESS THAN THIS
C  SCALE  MAP SCALE FACTOR
C
C--USE OF VARIABLES :
C
C       TOLER   CURRENTLY A DUMMY
C
C       THE COMMON BLOCK /XWORKA/ IS USED :
C
C       JB  ADDRESS OF THE TEMP. STORAGE FOR ATOMS
C       JC  ADDRESS OF THE ATOM HEADER FOR MOVING ATOMS FROM 'JB'
C       JD  WORK SPACE FOR 'KATOMS'
C       JE  START OF DISTANCE STACK.
C       JF  NUMBER OF ATOMS LEFT TO SCAN
C       JG  CURRENT LAST ENTRY IN LIST 5 OR 10
C       JH  MD5-1
C       JI  MD5+MD5
C       JK  ADDRESS OF LAST ATOM ON PRINCIPAL DISTANCE STACK
C       JL  NEXT FREE ADDRESS AFTER PRINCIPAL DISTANCE STACK
C       JT  WORDS PER ENTRY IN THE STACK
C       JU  5 WORD WORK AREA
C       SX  DISTANCE NO BONDED CONTACT TO USE
C
C       THE FOLLOWING VARIABLES MUST BE SET ON ENTRY TO KDIST1:-
C
C       AT     MINIMUM ALLOWED DISTANCE FOR DISTANCES
C       AC     MAXIMUM ALLOWED DISTANCE FOR DISTANCES
C       BT     MINIMUM ALLOWED DISTANCE FOR ANGLES
C       BC     MAXIMUM ALLOWED DISTANCE FOR ANGLES
C       AO     MAXIMUM ALLOWED DISTANCE OVERALL
C       AP     MAXIMUM ALLOWED DISTANCES SQUARED OVERALL
C       BP     MINIMUM ALLOWED DISTANCE SQUARED OVERALL
C       M5A    ADDRESS OF THE CURRENT TARGET ATOM IN LIST 5
C       M5     ADDRESS OF THE FIRST ATOM TO MOVE AROUND IN LIST 5
C
C
C       ATOMS WHICH FORM ACCEPTABLE CONTACTS ARE STORED IN A STACK
C       WHICH HAS THE FOLLOWING FORMAT :
C
C       0  ADDRESS OF THE ATOM IN LIST 5
C       1  ACCEPTANCE FLAG
C
C          1  ACCEPTABLE TO NONE
C          2  DISTANCES ONLY
C          3  ANGLES ONLY
C          4  ACCEPTABLE TO BOTH
C
C       2  S, THE SYMMETRY MATRIX TO BE USED (NEGATIVE FOR CENTRE OF SYM
C       3  NON-PRIMITIVE LATTICE INDICATOR
C       4  T(X)
C       5  T(Y)
C       6  T(Z)
C       7  TRANSFORMED X
C       8  TRANSFORMED Y
C       9  TRANSFORMED Z
C      10  DISTANCE
C      11  DISTANCE SQUARED
C      12  ADDRESS IN LIST 12  (IF USED).
C      13  TARGET CONTACT DISTANCE FOR RESTRAINTS (OPTIONAL)
C
C
C
C--
      PARAMETER (NPROCS = 28)
      DIMENSION PROCS(NPROCS)
      DIMENSION IPROCS(NPROCS)
      DIMENSION A1(26)
      DIMENSION AMIN(3)
      CHARACTER*16 CMAPTP(5)
      CHARACTER*8  WTED
      DIMENSION KDEV(4)

      INCLUDE 'STORE.INC'
      INCLUDE 'QSTORE.INC'
      INCLUDE 'ISTORE.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XTAPES.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XWORKA.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XLST02.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST06.INC'
      INCLUDE 'XLST12.INC'
      INCLUDE 'ICOM12.INC'
      INCLUDE 'XLST20.INC'
      INCLUDE 'XLST29.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XDSTNC.INC'
      INCLUDE 'TSSCHR.INC'
      INCLUDE 'XSSCHR.INC'
      INCLUDE 'UFILE.INC'
      INCLUDE 'XPDS.INC'

      EQUIVALENCE (APD(1),PROCS(1))
      EQUIVALENCE (IN,APD(10)),(ITHRES,APD(11)),(SCALE,APD(12))
      EQUIVALENCE (IWT, APD(13))
      EQUIVALENCE (A1(1),A)
      EQUIVALENCE (PROCS(1), IPROCS(1))
      EQUIVALENCE (IMODE, PROCS(27)), (IOUTAP, PROCS(26))
      EQUIVALENCE (IOUFIL, PROCS(28))

      DATA NCOL/28/
#ifdef _HOL_
      DATA IPEAK /4HQ   /
#else
      DATA IPEAK /'Q   '/
#endif
      
C----- MAXIMUM DISTANCE FOR A 1-3 CONTACT, AND ITS SQUARE
      DATA D13 / 4.0 /, D13S / 9.0 /
      DATA TOLER /0.6/, ITRANS / 0 /
      DATA EDGES /2.0/

C--INITIALISE THE TIMING FUNCTION
      CALL XTIME1(1)

      JU = NFL
      NFL = NFL + 5

      JT=12
      AT = 0.5
      AC = D13

C-------NO ANGLES TO BE LOOKED FOR
      BT = 0.
      BC = 0.


C--USE A NULL LIST 12.
      IDIM12=40
      DO I=1,IDIM12
          ICOM12(I)=NOWT
      END DO
      L12=-1
      M12=-1


C--READ THE DATA
      ISTAT = KRDDPV ( PROCS, NPROCS)
      IF ( ISTAT .LT. 0 ) GO TO 9910
C--LOAD LISTS ONE, TWO, FIVE AND TWENTY
      CALL XRSL
      CALL XCSAE
      CALL XFAL01
      CALL XFAL05
      IF ( IERFLG .LT. 0 ) GO TO 9900
      CALL XFAL20
C----- CHECK IF WE USE THE MOLAX MATRIX -
      IF (IMODE .GE. 1) THEN
      CALL XMOVE (STORE(L20V+ IMODE * MD20V), PROCS(14), 3)
C----- COPY AND TRANSPOSE
      CALL XTRANS (STORE(L20M+ IMODE * MD20M), PROCS(1), 3, 3)
      ENDIF
      IF ( IERFLG .LT. 0 ) GO TO 9900

C--INVERT THE ROTATION MATRIX
      LN=8
      IREC=8001
      L8RI=KCHLFL(9)
      L8R=KCHLFL(9)
      CALL XMOVE(PROCS(1),STORE(L8R),9)
C----- LOOK FOR SOME SORT OF MATRIX
      IF (ABS(XDETR3(PROCS(1))) .LE. ZERO) THEN
        WRITE ( CMON , 1060) (PROCS(I), I = 1,9)
        CALL XPRVDU(NCVDU, 4,0)
        IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') (CMON(II)(:),II=1,4)
1060    FORMAT (' Your matrix is probably invalid ', 3(/3F9.3))
        GOTO 9900
      ENDIF
      IF(KINV2(3,STORE(L8R),STORE(L8RI),9,0,APD(1),APD(1),9))9920 ,
     1                                                1300 , 9920

C--MOVE THE CENTROID AND STEPS IN X, Y AND THE Z HEIGHT
1300  CONTINUE
C----- SPACE FOR THE SECTION LIMITS
      L8T= NFL
      I = KCHNFL(12)
      CALL XMOVE(PROCS(14),STORE(L8T),12)
C----- FLOAT THE NUMBER  OF POINTS (THE INTEGER IS STILL IN ISTORE)
      PROCS(18) = FLOAT( ISTORE(L8T+4))
      PROCS(21) = FLOAT( ISTORE(L8T+7))
      PROCS(24) = FLOAT( ISTORE(L8T+10))
C
C----- WRITE THE MAP FILE HEADER  DETAILS
      IF (IOUFIL .GT. 0 ) THEN
           CALL XMOVEI(KEYFIL(1,23), KDEV, 4)
           CALL XRDOPN(6, KDEV , CSSMAP, LSSMAP)
1651       FORMAT(A)
1652       FORMAT(F15.8)
1653       FORMAT(I8)
           WRITE (NCFPU1,1651) 'INFO  DOWN, ACROSS AND SECTION '
           WRITE (NCFPU1,1651) 'TRAN'
           WRITE (NCFPU1,1652) (STORE(I),I=L8R,l8R+8),(PROCS(I),I=14,16)
           WRITE (NCFPU1,1651) 'CELL'
           WRITE (NCFPU1,1652) (STORE(I), I = L1P1, L1P1+5)
           WRITE (NCFPU1,1651) 'L14 '
           WRITE (NCFPU1,1652)
     1     (STORE(I),STORE(I+2),(STORE(I)+(ISTORE(I+1)-1)*STORE(I+2)),
     1      1. , I = L8T+3, L8T+9, 3)
           WRITE (NCFPU1,1651) 'SIZE'
           WRITE (NCFPU1,1653)ISTORE(L8T+4),ISTORE(L8T+7),ISTORE(L8T+10)
           NXNY = ISTORE(L8T+4) * ISTORE(L8T+7)
      ENDIF
C
C--CHECK THAT THERE ARE SOME REASONABLE INTERVALS
      IF(ABS(STORE(L8T+5))-0.0001)1400,1400,1350
1350  CONTINUE
      IF(ABS(STORE(L8T+8))-0.0001)1400,1400,1500
C--INCORRECT INTERVALS
1400  CONTINUE
      WRITE ( CMON ,1450)
      CALL XPRVDU(NCVDU, 1,0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU, '(/A)') CMON(1 )(:)
1450  FORMAT(' Illegal x or y divisions')
      GOTO 9910

1500  CONTINUE


C----- LOAD LIST 29
      CALL XFAL29
C----- SCAN LIST 5 SETTING SPARE TO VDW RADIUS
      I29=L29 + (N29-1)*MD29
      I5 = L5 + (N5-1)*MD5
      DO M5=L5,I5,MD5
         IFOUND = 0
         DO M29= L29,I29,MD29
            JZ=M29+2
            IF (ISTORE(M5) .EQ. ISTORE(M29)) THEN
               STORE(M5+14) = STORE(JZ)
               if ( issprt .eq.0 ) then
                 WRITE(CMON,'(3A,F7.3)')'Atom type: ',ISTORE(M5),
     2           ' VDW radius set to ', STORE(M5+14)
                 IFOUND = 1
               endif
            END IF
         END DO
         IF ( IFOUND .EQ. 0 ) THEN
           IF ( ISTORE(M5) .EQ. IPEAK ) THEN
            STORE(M5+14) = 0.0
               if ( issprt .eq.0 ) then
                 WRITE(CMON,'(3A)')'Atom type: ',ISTORE(M5),
     2           ' ignored.'
               endif
           ELSE
            STORE(M5+14) = 1.78
               if ( issprt .eq.0 ) then
                 WRITE(CMON,'(3A)')'Atom type: ',ISTORE(M5),
     2           ' not in LIST 29 - using carbon VDW of 1.78A'
               endif
           END IF
         END IF
      END DO

2801  FORMAT (A)
2802  FORMAT (I8)
2803  FORMAT (F15.8)

C-------LOAD LISTS 1 AND 2, AND SET UP SOME CONSTANTS
      CALL XDIST2

C-------SET UP A FEW STACK CONSTANTS
      JB=NFL
      JC=JB+MD5
      JD=JC+20
      JE=JD+30
C-------CHECK THE STORE AREA
      IF ( JE .GE. LFL ) GOTO 9930

C-------FIX THE RADII FOR 1-2 CONTACTS
      AO = AC
      AP = AC * AC

C-------SET THE TARGET ATOM ADDRESSES
      IABAT=NFL
      M5A = IABAT
      NFL=NFL+6

      AXMN = 99.99
      AYMN = 99.99
      AZMN = 99.99
      AXMX = -99.99  
      AYMX = -99.99
      AZMX = -99.99


C----- START LOOPING OVER SECTIONS

      DO IZSECT = 0, ISTORE(L8T+10)-1
        ZCOORD=STORE(L8T+9) + STORE(L8T+11) * IZSECT
        IF (IOUFIL .GT. 0) THEN
          WRITE(NCFPU1,2801) 'BLOCK'
          WRITE(NCFPU1,2802) NXNY
        ENDIF
        DO IXSECT = 0, ISTORE(L8T+4)-1
          XCOORD=STORE(L8T+3) + STORE(L8T+5) * IXSECT
          DO IYSECT = 0, ISTORE(L8T+7)-1
            YCOORD=STORE(L8T+6) + STORE(L8T+8) * IYSECT

C--CALCULATE THE COORDINATES OF THE POINT

            AMIN(1)=STORE(L8T)  +STORE(L8RI)  *XCOORD
     2                          +STORE(L8RI+1)*YCOORD
     3                          +STORE(L8RI+2)*ZCOORD
            AMIN(2)=STORE(L8T+1)+STORE(L8RI+3)*XCOORD
     2                          +STORE(L8RI+4)*YCOORD
     3                          +STORE(L8RI+5)*ZCOORD
            AMIN(3)=STORE(L8T+2)+STORE(L8RI+6)*XCOORD
     2                          +STORE(L8RI+7)*YCOORD
     3                          +STORE(L8RI+8)*ZCOORD
C
C            WRITE(CMON,'(A,3F5.2)')'Points: ',AMIN
C            CALL XPRVDU(NCVDU, 1,0)

            AXMN = MIN(AMIN(1),AXMN)
            AXMX = MAX(AMIN(1),AXMX)
            AYMN = MIN(AMIN(2),AYMN)
            AYMX = MAX(AMIN(2),AYMX)
            AZMN = MIN(AMIN(3),AZMN)
            AZMX = MAX(AMIN(3),AZMX)

            STORE(IABAT+4)=AMIN(1)
            STORE(IABAT+5)=AMIN(2)
            STORE(IABAT+6)=AMIN(3)
            STORE(IABAT+2)=1.0
            STORE(IABAT+3)=.05
C------ RESET THE CONTACT ATOM
            M5=L5
C------ RESET BEGINNING OF DISTANCE STACK TO JE EVERY TIME
            NFL=JE
            JFNVC = 0
C------ COMPUTE DISTANCE STACK TO A TWO BOND MAXIMUM
            NDIST = KDIST1( N5, JL, JT, JFNVC, TOLER, ITRANS, 0, 4, 0)
            NBONDS = NDIST
            DIST = AC
            DO K = JE, JE+(JT*(NBONDS-1)),JT
               IF ( ISTORE(ISTORE(K)) .NE. IPEAK ) THEN
                  DIST = MIN(DIST, STORE(K+10) - STORE(ISTORE(K)+14))
               END IF
            END DO

C-------JK IS CURRENT NEXT FREE ADDRESS - SAVE AND SET LAST ENTRY
            NFL = JL
            JK = JL - JT

            IF (IOUFIL .GT. 0) THEN
               WRITE(NCFPU1,2803) DIST
            ENDIF
          END DO
        END DO
      END DO



      IF (IOUFIL .GT. 0) THEN
        WRITE(NCFPU1,2801)'LIST5'

C Get some store:
        MDBOX = 4
        LBOX = NFL
        NBOX = 6
        I = KCHNFL(28)
C Centroid.
        CALL XMOVE(STORE(L8T), STORE(LBOX), 3)

C Calculate six enclosing planes.
C NB dot product gives distance of plane from origin!
C The **2 arises because the vector used for the
C dot product is derived from the matrix used to
C deorthogonalise the co-ordinates.
CX
        STORE(LBOX+4) =  STORE(L8RI)
        STORE(LBOX+5) =  STORE(L8RI+3)
        STORE(LBOX+6) =  STORE(L8RI+6)
        STORE(LBOX+7) =  STORE(L8RI)**2    * (-(STORE(L8T+3)-EDGES))
     4                  + STORE(L8RI+3)**2 * (-(STORE(L8T+3)-EDGES))
     7                  + STORE(L8RI+6)**2 * (-(STORE(L8T+3)-EDGES))
C-X
        STORE(LBOX+8)  = -STORE(LBOX+4)
        STORE(LBOX+9)  = -STORE(LBOX+5)
        STORE(LBOX+10) = -STORE(LBOX+6)
        STORE(LBOX+11) = STORE(LBOX+7)
C The D term does not change sign because the plane changes sign, and
C the vector to the origin also changes sign.
CY
        STORE(LBOX+12) =  STORE(L8RI+1)
        STORE(LBOX+13) =  STORE(L8RI+4)
        STORE(LBOX+14) =  STORE(L8RI+7)
        STORE(LBOX+15) =   STORE(L8RI+1)**2 * (-(STORE(L8T+6)-EDGES))
     4                  +  STORE(L8RI+4)**2 * (-(STORE(L8T+6)-EDGES))
     7                  +  STORE(L8RI+7)**2 * (-(STORE(L8T+6)-EDGES))
C-Y
        STORE(LBOX+16) = -STORE(LBOX+12)
        STORE(LBOX+17) = -STORE(LBOX+13)
        STORE(LBOX+18) = -STORE(LBOX+14)
        STORE(LBOX+19) = STORE(LBOX+15)
CZ
        STORE(LBOX+20) =  STORE(L8RI+2)
        STORE(LBOX+21) =  STORE(L8RI+5)
        STORE(LBOX+22) =  STORE(L8RI+8)
        STORE(LBOX+23) =   STORE(L8RI+2)**2 * (-(STORE(L8T+9)-EDGES))
     4                   + STORE(L8RI+5)**2 * (-(STORE(L8T+9)-EDGES))
     7                   + STORE(L8RI+8)**2 * (-(STORE(L8T+9)-EDGES))
C-Z     
        STORE(LBOX+24) = -STORE(LBOX+20)
        STORE(LBOX+25) = -STORE(LBOX+21)
        STORE(LBOX+26) = -STORE(LBOX+22)
        STORE(LBOX+27) = STORE(LBOX+23)

C-------LOAD LISTS 1 AND 2, AND SET UP SOME CONSTANTS
        CALL XDIST3

        BPD(4) = AXMN - 2.0 / STORE(L1P1)
        BPD(5) = AYMN - 2.0 / STORE(L1P1+1)
        BPD(6) = AZMN - 2.0 / STORE(L1P1+2)
        BPD(7) = AXMX + 2.0 / STORE(L1P1)
        BPD(8) = AYMX + 2.0 / STORE(L1P1+1)
        BPD(9) = AZMX + 2.0 / STORE(L1P1+2)

        JE=NFL
        M5=L5
        JFNVC = 0
        ITRANS = 0 !Allow translation
        NDIST = KDIST1( N5, JL, JT, JFNVC, TOLER, ITRANS, 0, 4, 0)

        WRITE(NCFPU1,2802)NDIST,MD5
        DO K = JE, JE+(JT*(NDIST-1)),JT
            M5 = ISTORE(K) 
            WRITE(NCFPU1,2801) STORE(M5)
            DO J = M5+1, M5+3
                WRITE(NCFPU1,2803) STORE(J)
            END DO
            DO J = 0,2
                WRITE(NCFPU1,2803) STORE(K+J+7)
            END DO
            DO J = M5+7, M5+MD5-1
                WRITE(NCFPU1,2803) STORE(J)
            END DO
        END DO
C Close the fourier.map file
        CALL XMOVEI(KEYFIL(1,23), KDEV, 4)
        CALL XRDOPN(7, KDEV , CSSMAP, LSSMAP)
      ENDIF
C
3350  CONTINUE
      CALL XOPMSG (IOPSLA, IOPEND, 201)
      CALL XTIME2(1)
      RETURN
C
9900  CONTINUE
C -- ERRORS
      CALL XOPMSG ( IOPSLA , IOPABN , 0 )
      GOTO 3350
9910  CONTINUE
C -- INPUT ERROR
      CALL XOPMSG ( IOPSLA , IOPCMI , 0 )
      GO TO 9900
9920  CONTINUE
C -- SINGULAR MATRIX
      WRITE ( CMON, 9925 )
      CALL XPRVDU(NCVDU, 1,0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') CMON( 1)(:)
9925  FORMAT ( 1X , 'Rotation matrix is singular' )
      CALL XERHND ( IERERR )
      GO TO 9900
9930  CONTINUE
C
C-------INSUFFICIENT SPACE
      CALL XOPMSG ( IOPHYD , IOPSPC , 0 )
      GO TO 9900
      END

