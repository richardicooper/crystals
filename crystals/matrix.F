C $Log: not supported by cvs2svn $
C Revision 1.23  2012/03/23 13:52:07  rich
C Inter compiler support.
C
C Revision 1.22  2011/07/27 08:02:22  djw
C       FUNCTION FDPROD(A,B)
C THE SUBROUTINE DPROD PACKAGED AS A FUNCION  FOR USE IN EXPRESSIONS
C
C Revision 1.21  2011/07/01 13:42:45  djw
C Change the dot product module name from VPROD to DPROD
C
C Revision 1.20  2009/06/03 09:04:04  djw
C Highlight singularities in RED on monitor
C
C Revision 1.19  2008/03/07 16:09:48  djw
C changes to help with the correct computation of Fourier maps from twinned crystals.  THe old COPY67 subroutine did not pack the data properly unless the keys were the default keys.  The job is now done
C
C Revision 1.18  2005/05/14 13:28:14  stefan
C 1. Corrected a mistake I made with a format statement.
C
C Revision 1.17  2005/05/13 12:03:23  stefan
C 1. Added some of my own routines for accessing the triangular normal matrix or any other trianglare matrix.
C
C Revision 1.16  2005/02/27 21:28:10  rich
C RIC: the WXS version would not refine at all. Fixed problem
C in XCHOLS - compiler didn't recognise /0.1D1/ in a data statement. Changed
C it to /1.0/ as the compiler will automatically cast it to double precision
C anyway.
C
C Revision 1.15  2005/02/25 17:25:20  stefan
C 1. Added some preprocessor if defined lines for the mac version.
C
C Revision 1.14  2005/02/10 15:13:49  djw
C eror in INV in #MATRIX
C
C Revision 1.13  2005/01/23 08:29:11  rich
C Reinstated CVS change history for all FPP files.
C History for very recent (January) changes may be lost.
C
C Revision 1.2  2004/12/13 16:16:08  rich
C Changed GIL to _GIL_ etc.
C
C Revision 1.1.1.1  2004/12/13 11:16:08  rich
C New CRYSTALS repository
C
C Revision 1.12  2004/07/02 13:26:01  rich
C Remove dependency on HARWELL and NAG libraries. Replaced with LAPACK
C and BLAS code (and a home-made bessel function approximation).
C
C Revision 1.11  2003/09/24 09:44:25  rich
C Added routine XMXUIJ to matrix.src to apply a transformation to
C a vector of Uijs. Added new vector to store Uijs for the "new"
C list of atoms in \REGULARISE, and apply rotation at appropriate
C point.
C
C Revision 1.10  2003/08/05 11:11:12  rich
C Commented out unused routines - saves 50Kb off the executable.
C
C Revision 1.9  2003/07/08 10:05:25  rich
C Upon inversion of a matrix in the #MATRIX command,
C put the determinant in the script variable MATRIX:DET,
C in case anyone wants it.
C
C Revision 1.8  2003/07/01 17:47:36  rich
C
C This is an odd one: Added two new directives to #MATRIX. SCR2A moves
C script variables MATRIX:A11 - MATRIX:A33 into the A register. SCR2B
C moves MATRIX:B11 - MATRIX:B33 into the B register. Upon any operation
C that updates the accumulator, the result is stuffed into the script
C variables MATRIX:M11 - MATRIX:M33.
C
C If a script is not running, or the variables are not defined everything
C fails safe.
C
C Revision 1.7  2003/05/07 12:18:54  rich
C
C RIC: Make a new platform target "WXS" for building CRYSTALS under Windows
C using only free compilers and libraries. Hurrah, but it isn't very stable
C yet (CRYSTALS, not the compilers...)
C
C Revision 1.6  2002/11/29 15:26:26  rich
C Remove unecessary blank line during SFLS output.
C
C Revision 1.5  2002/10/14 12:33:24  rich
C Support for DVF command line version.
C
C Revision 1.4  2002/06/21 09:49:03  Administrator
C Fix zero esds on bonds across a symmetry operator between atoms on special positions
C
C Revision 1.3  2001/12/12 17:48:59  Administrator
C matrix calculator
C
C Revision 1.2  2001/02/26 10:29:08  richard
C Added changelog to top of file
C
CODE FOR SMATRX
      SUBROUTINE SMATRX
C      A BASIC MATRIX CALCULATOR
C   1.A        
C   2.B        
C   3.MM       
C   4.TM       
C   5.MT       
C   6.MM       
C   7.TRANS    
C   8.INV      
C   9.EIG      
C  10.ACC2A    
C  11.ACC2B    
C  12.EXECUTE  
C  13.SCR2A    
C  14.SCR2B    
C  15.MATRIX   
C
      DIMENSION A(3,3),B(3,3),C(3,3),TEMP(3,3),ROW(9)
      DIMENSION ACC(3,3)
      INCLUDE 'ISTORE.INC'
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
C
C
      DATA IVERSN /100/
C
C--SET UP THE TIMING CONTROL
      CALL XTIME1(2)
C--CLEAR THE CORE
      CALL XCSAE
      LEF1 = 0
C----- WORKSPACE FOR REPLACEMENT
      IWORK = KSTALL(3)
      JWORK = KSTALL(9)
C----- SPACE FOR HEADERS
      MQ = KSTALL (100)
C----- COMMAND BUFFER
      IDIMBF = 50
      ICOMBF = KSTALL (IDIMBF)
C----- ZERO THE BUFFER
      CALL XZEROF (ISTORE(ICOMBF), IDIMBF)
C----- COMMON BLOCK OFFSET(-1) FOR INPUT LIST
      IMDINP = 35
C----- INITIALSE LEXICAL PROCESSING
      ICHNG = 1
      CALL XLXINI (INEXTD, ICHNG)
C
C--MAIN INSTRUCTION CYCLING LOOP
C
1100  CONTINUE
      IDIRNM = KLXSNG (ISTORE(ICOMBF), IDIMBF, INEXTD)
      IF (IDIRNM .LT. 0) GOTO 1100
      IF (IDIRNM .EQ. 0) GOTO 4910
C--NEXT RECORD HAS BEEN LOADED  -  BRANCH ON THE TYPE
      GOTO (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 
     1  1100, 13, 14, 1210, 1200), IDIRNM
1200  CONTINUE
      GOTO 9910
C
1210  CONTINUE
C----- MATRIX ITSELF
C--SET UP THE INITIAL CONTROL FLAGS
      CALL XZEROF(A(1,1),9)
      CALL XZEROF(B(1,1),9)
      CALL XZEROF(C(1,1),9)
      CALL XZEROF(TEMP(1,1),9)
      CALL XZEROF(ROW(1),9)
      GOTO 1100
C
C
C--'A' INSTRUCTION
1     CONTINUE
      Z=1.
C--CHECK FOR SOME ARGUMENTS
      IF(KFDARG(I))1300,1320,1320
C--ERROR(S)  -  INCREMENT THE ERROR COUNT
1300  CONTINUE
      LEF1=LEF1+1
      GOTO 1100
C--CHECK IF THERE ARE MORE ARGUMENTS ON THIS CARD
1320  CONTINUE
      DO 1550 I = 1,9
1350  CONTINUE
      IF(KOP(8))1850,1400,1400
C--CHECK IF NEXT ARGUMENT IS A NUMBER
1400  CONTINUE
      IF(KSYNUM(Z))3950,1450,3950
1450  CONTINUE
      ROW(I) = Z
      ME=ME-1
      MF=MF+LK2
1550  CONTINUE
1850  CONTINUE
C      CONVERT TO COLUMN-WISE
      IF (IDIRNM .EQ.1 ) THEN
       CALL XTRANS(ROW,A,3,3)
      ELSE IF (IDIRNM .EQ.2 ) THEN
       CALL XTRANS(ROW,B,3,3)
      ENDIF
      WRITE(CMON,'(9F8.3)') ROW
#if defined(_GID_) || defined(_GIL_) || defined(_WXS_)  || defined(_MAC_)|| defined(_INW_)
      CALL ZMORE(CMON,0)
#endif
      GOTO 1100
C
C
C
C--'B' INSTRUCTION
2     CONTINUE
      CALL XZEROF(ROW(1),9)
C--CHECK FOR SOME ARGUMENTS
      IF(KFDARG(I))1300,3860,3860
3860  CONTINUE
C----- LOOP FOR 9 ELEMEMNTS ROW-WISE
      DO 4400 I = 1,9
      IF(KOP(8))4450,3900,3900
C--CHECK IF THERE IS A NUMBER NEXT ON THE CARD
3900  CONTINUE
      IF(ME)3950,3950,4050
C--READ THE NUMBER
4050  CONTINUE
      IF(KSYNUM(Z))3950,4100,3950
C--WE HAVE FOUND A NUMBER  -  UPDATE THE CARD POSITION
4100  CONTINUE
      ROW(I) = Z
      ME=ME-1
      MF=MF+LK2
4400  CONTINUE
4450  CONTINUE
C      CONVERT TO COLUMN-WISE
      IF (IDIRNM .EQ.1 ) THEN
       CALL XTRANS(ROW,A,3,3)
      ELSE IF (IDIRNM .EQ.2 ) THEN
       CALL XTRANS(ROW,B,3,3)
      ENDIF
      WRITE(CMON,'(9F8.3)') ROW
#if defined(_GID_) || defined(_GIL_) || defined(_WXS_)  || defined(_MAC_)|| defined(_INW_)
      CALL ZMORE(CMON,0)
#endif
      GOTO 1100
C
C--ERROR IN THE INPUT NUMBER
3950  CONTINUE
      CALL XPCLNN(LN)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4000)
      ENDIF
      WRITE(NCAWU,4000)
4000  FORMAT(/34H Argument missing or of wrong type)
      GOTO 4910
C
C-----MM     
3     CONTINUE
C--MATRIX MULTIPLICATION OF 'A' BY 'B' TO GIVE 'C'.
C  A(L,M).B(M,N)=C(L,N)
      CALL XMLTMM(A,B,ACC,3,3,3)
      GOTO 101
C-----TM     
4     CONTINUE
C--MATRIX MULTIPLICATION OF 'A' TRANSPOSED BY 'B' TO GIVE 'C'.
C  A(M,L)'.B(M,N)=C(L,N)
      CALL XMLTTM(A,B,ACC,3,3,3)
      GOTO 101
C-----MT
5     CONTINUE
C--MATRIX MULTIPLICATION OF 'A' BY 'B' TRANSPOSED  TO GIVE 'C'.
C  A(M,L).B'(M,N)=C(L,N)
      CALL XMLTMT(A,B,ACC,3,3,3)
      GOTO 101
C-----TT
6     CONTINUE
C--MATRIX MULTIPLICATION OF 'A' TRANS BY 'B' TRANS TO GIVE 'C'.
C  A(M,L)'.B'(M,N)=C(L,N)
      CALL XMLTTT(A,B,ACC,3,3,3)
      GOTO 101
C-----TRANS   
7     CONTINUE
C--MATRIC TRANSPOSITION ROUTINE
C  C(N,L)=A(L,N)'
      CALL XTRANS(A,ACC,3,3)
      GOTO 101
C-----INV     
8     CONTINUE
      CALL MATINV(A,ACC,D)
      CALL MTRANS(ACC)
      ISTAT = KSCTRN ( 1 , 'MATRIX:DET' ,D, 1 )
      WRITE(CMON,'(A, F12.5)') 'Determinant = ', D
#if defined(_GID_) || defined(_GIL_) || defined(_WXS_)  || defined(_MAC_)|| defined(_INW_)
      CALL ZMORE(CMON,0)
#endif
      GOTO 101
C-----EIG     
9     CONTINUE
#if defined(_GID_) || defined(_GIL_) || defined(_WXS_)  || defined(_MAC_)|| defined(_INW_)
      call zmore('Not yet implemented',0)
#endif
      GOTO 101
C-----ACC2A 
10     CONTINUE
      CALL XMOVE (ACC,A,9)
      GOTO 1100
C-----ACC2B 
11     CONTINUE
      CALL XMOVE (ACC,B,9)
      GOTO 1100
C-----SCR2A 
13     CONTINUE
      ISTAT = KSCTRN ( 2 , 'MATRIX:A11' ,A(1,1), 2 )
      ISTAT = KSCTRN ( 2 , 'MATRIX:A12' ,A(1,2), 2 )
      ISTAT = KSCTRN ( 2 , 'MATRIX:A13' ,A(1,3), 2 )
      ISTAT = KSCTRN ( 2 , 'MATRIX:A21' ,A(2,1), 2 )
      ISTAT = KSCTRN ( 2 , 'MATRIX:A22' ,A(2,2), 2 )
      ISTAT = KSCTRN ( 2 , 'MATRIX:A23' ,A(2,3), 2 )
      ISTAT = KSCTRN ( 2 , 'MATRIX:A31' ,A(3,1), 2 )
      ISTAT = KSCTRN ( 2 , 'MATRIX:A32' ,A(3,2), 2 )
      ISTAT = KSCTRN ( 2 , 'MATRIX:A33' ,A(3,3), 2 )
      GOTO 1100
C-----SCR2B 
14     CONTINUE
      ISTAT = KSCTRN ( 2 , 'MATRIX:B11' ,B(1,1), 2 )
      ISTAT = KSCTRN ( 2 , 'MATRIX:B12' ,B(1,2), 2 )
      ISTAT = KSCTRN ( 2 , 'MATRIX:B13' ,B(1,3), 2 )
      ISTAT = KSCTRN ( 2 , 'MATRIX:B21' ,B(2,1), 2 )
      ISTAT = KSCTRN ( 2 , 'MATRIX:B22' ,B(2,2), 2 )
      ISTAT = KSCTRN ( 2 , 'MATRIX:B23' ,B(2,3), 2 )
      ISTAT = KSCTRN ( 2 , 'MATRIX:B31' ,B(3,1), 2 )
      ISTAT = KSCTRN ( 2 , 'MATRIX:B32' ,B(3,2), 2 )
      ISTAT = KSCTRN ( 2 , 'MATRIX:B33' ,B(3,3), 2 )
      GOTO 1100
C
101    CONTINUE
      WRITE(CMON,'(9F8.3)') ACC
#if defined(_GID_) || defined(_GIL_) || defined(_WXS_)  || defined(_MAC_)|| defined(_INW_)
      CALL ZMORE(CMON,0)
C Keep script up-to-date with what's going on, if it cares.
#endif
      ISTAT = KSCTRN ( 1 , 'MATRIX:M11' ,ACC(1,1), 1 )
      ISTAT = KSCTRN ( 1 , 'MATRIX:M12' ,ACC(1,2), 1 )
      ISTAT = KSCTRN ( 1 , 'MATRIX:M13' ,ACC(1,3), 1 )
      ISTAT = KSCTRN ( 1 , 'MATRIX:M21' ,ACC(2,1), 1 )
      ISTAT = KSCTRN ( 1 , 'MATRIX:M22' ,ACC(2,2), 1 )
      ISTAT = KSCTRN ( 1 , 'MATRIX:M23' ,ACC(2,3), 1 )
      ISTAT = KSCTRN ( 1 , 'MATRIX:M31' ,ACC(3,1), 1 )
      ISTAT = KSCTRN ( 1 , 'MATRIX:M32' ,ACC(3,2), 1 )
      ISTAT = KSCTRN ( 1 , 'MATRIX:M33' ,ACC(3,3), 1 )
      GOTO 1100
C
C--MAIN TERMINATION ROUTINES
4910  CONTINUE
4960  CONTINUE
9910  CONTINUE
      CALL XOPMSG ( IOPAXS , IOPEND , IVERSN )
      CALL XTIME2(2)
      RETURN
      END
C
C
CODE FOR XMLTMM
      SUBROUTINE XMLTMM(A,B,C,L,M,N)
C--MATRIX MULTIPLICATION OF 'A' BY 'B' TO GIVE 'C'.
C
C--THE PARAMETERS CAN BEST BE DESCRIBED BY THE MATRIX OPERATION :
C
C  A(L,M).B(M,N)=C(L,N)
C
C--
C
      DIMENSION A(L,M),B(M,N),C(L,N)
C
C--LOOP OVER ROWS OF THE OUTPUT MATRIX
      DO 1000 K=1,N
C--LOOP OVER COLUMNS OF THE OUTPUT MATRIX
      DO 1000 I=1,L
      C(I,K)=0.
C--LOOP OVER THE CONTRIBUTIONS OF THIS ELEMENT
      DO 1000 J=1,M
1000  C(I,K)=C(I,K)+A(I,J)*B(J,K)
      RETURN
      END
C
CODE FOR XMLTMT
      SUBROUTINE XMLTMT(A,B,C,L,M,N)
C--MATRIX MULTIPLICATION OF 'A' BY 'B' TRANSPOSED TO GIVE 'C'.
C
C--THE PARAMETERS CAN BEST BE DESCRIBED BY THE MATRIX OPERATION :
C
C  A(L,M).B(N,M)'=C(L,N)
C
C
C--
C
      DIMENSION A(L,M),B(N,M),C(L,N)
C
C--LOOP OVER ROWS OF THE OUTPUT MATRIX
      DO 1000 K=1,N
C--LOOP OVER COLUMNS OF THE OUTPUT MATRIX
      DO 1000 I=1,L
      C(I,K)=0.
C--LOOP OVER THE CONTRIBUTIONS OF THIS ELEMENT
      DO 1000 J=1,M
1000  C(I,K)=C(I,K)+A(I,J)*B(K,J)
      RETURN
      END
C
CODE FOR XMLTTM
      SUBROUTINE XMLTTM(A,B,C,L,M,N)
C--MATRIX MULTIPLICATION OF 'A' TRANSPOSED BY 'B' TO GIVE 'C'.
C
C--THE PARAMETERS CAN BEST BE DESCRIBED BY THE MATRIX OPERATION :
C
C  A(M,L)'.B(M,N)=C(L,N)
C
C--
C
      DIMENSION A(M,L),B(M,N),C(L,N)
C
C--LOOP OVER ROWS OF THE OUTPUT MATRIX
      DO 1000 K=1,N
C--LOOP OVER COLUMNS OF THE OUTPUT MATRIX
      DO 1000 I=1,L
      C(I,K)=0.
C--LOOP OVER THE CONTRIBUTIONS OF THIS ELEMENT
      DO 1000 J=1,M
1000  C(I,K)=C(I,K)+A(J,I)*B(J,K)
      RETURN
      END
C
CODE FOR XMLTTT
      SUBROUTINE XMLTTT(A,B,C,L,M,N)
C--MATRIX MULTIPLICATION OF 'A' TRANSPOSED BY 'B' TRANSPOSED TO GIVE 'C'
C
C--THE PARAMETERS CAN BEST BE DESCRIBED BY THE MATRIX OPERATION :
C
C  A(M,L)'.B(N,M)'=C(L,N)
C
C--
C
      DIMENSION A(M,L),B(N,M),C(L,N)
C
C--LOOP OVER ROWS OF THE OUTPUT MATRIX
      DO 1000 K=1,N
C--LOOP OVER COLUMNS OF THE OUTPUT MATRIX
      DO 1000 I=1,L
      C(I,K)=0.
C--LOOP OVER THE CONTRIBUTIONS OF THIS ELEMENT
      DO 1000 J=1,M
1000  C(I,K)=C(I,K)+A(J,I)*B(K,J)
      RETURN
      END
C
CODE FOR XTRANS
      SUBROUTINE XTRANS(A,C,L,N)
C--MATRIC TRANSPOSITION ROUTINE
C
C--IN MATRIX NOTATION, THIS MAY BE REPRESENTED AS :
C
C  C(N,L)=A(L,N)'
C
C--
C
      DIMENSION A(L,N),C(N,L)
C
      DO 1000 I=1,L
      DO 1000 J=1,N
1000  C(J,I)=A(I,J)
      RETURN
      END
C
CODE FOR MTRANS
      SUBROUTINE MTRANS(A)
C IN-PLACE TRANSPOSITION OF 3X3 MATRIX
C
      DIMENSION A(3,3)
      T = A(2,1)
      A(2,1) = A(1,2)
      A(1,2) = T
C
      T = A(2,3)
      A(2,3) = A(3,2)
      A(3,2) = T
C
      T = A(3,1)
      A(3,1) = A(1,3)
      A(1,3) = T
      END
C
CODE FOR XNEGMT
      SUBROUTINE XNEGMT(A,M,N)
C--NEGATE ALL ELEMENTS OF A MATRIX
      DIMENSION A(M,N)
      DO I=1,N
            DO J=1,M
                  A(M,N)=-A(M,N)
            ENDDO
      ENDDO
      END
C
CODE FOR XNEGTR
      SUBROUTINE XNEGTR(A,B,N)
C--NEGATE THE 'N' ELEMENTS OF 'A' TO 'B'.
C
C  A  INPUT VECTOR.
C  B  OUTPUT VECTOR.
C  N  THE NUMBER OF ELEMENTS IN 'A' AND 'B'.
C
C--
C
      DIMENSION A(N),B(N)
C
C
      DATA I/0/
C
C--CHECK FOR SOME ELEMENTS
      IF(N)1100,1100,1000
1000  CONTINUE
      DO 1050 I=1,N
      B(I)=-A(I)
1050  CONTINUE
C--AND NOW RETURN
1100  CONTINUE
      RETURN
      END
C
CODE FOR XADDR
      SUBROUTINE XADDR(A,B,C,N)
C--ADD THE 'N' ELEMENTS OF 'A' TO 'B' AND STORE THE RESULTS IN 'C'
C
C  A  FIRST INPUT VECTOR.
C  B  SECOND INPUT VECTOR.
C  C  THE RESULTS VECTOR.
C  N  THE ORDER OF 'A', 'B' AND 'C'.
C
C--
C
      DIMENSION A(N),B(N),C(N)
C
C
      DATA I/0/
C
C--CHECK FOR SOME ELEMNTS
      IF(N)1100,1100,1000
1000  CONTINUE
      DO 1050 I=1,N
      C(I)=A(I)+B(I)
1050  CONTINUE
C--AND NOW RETURN
1100  CONTINUE
      RETURN
      END
C
CODE FOR XSUBTR
      SUBROUTINE XSUBTR(A,B,C,N)
C--SUBTRACT THE 'N' ELEMENTS OF 'B' FROM 'A' AND STORE THE RESULTS IN 'C
C
C  A  FIRST INPUT VECTOR.
C  B  SECOND INPUT VECTOR.
C  C  THE RESULTS VECTOR.
C  N  THE ORDER OF 'A', 'B' AND 'C'.
C
C--
C
      DIMENSION A(N),B(N),C(N)
C
C
      DATA I/0/
C
C--CHECK FOR SOME ELEMNTS
      IF(N)1100,1100,1000
1000  CONTINUE
      DO 1050 I=1,N
      C(I)=A(I)-B(I)
1050  CONTINUE
C--AND NOW RETURN
1100  CONTINUE
      RETURN
      END
C
CODE FOR XMULTR
      SUBROUTINE XMULTR(A,B,C,N)
C--MULTIPLY THE 'N' ELEMENTS OF 'A' BY THE SCALAR 'B'
C  AND STORE THE RESULTS IN 'C'.
C
C  A  THE INPUT VECTOR.
C  B  THE SCALAR MULTIPLIER.
C  C  THE OUTPUT VECTOR.
C  N  THE NUMBER OF ELEMENTS IN 'A' AND 'C'.
C
C--
C
      DIMENSION A(N),C(N)
C
C
      DATA I/0/
C
C--CHECK FOR SOME ELEMENTS
      IF(N)1100,1100,1000
1000  CONTINUE
      DO 1050 I=1,N
      C(I)=A(I)*B
1050  CONTINUE
1100  CONTINUE
      RETURN
      END
C
CODE FOR XDVDR
      SUBROUTINE XDVDR(A,B,C,N)
C--DIVIDE THE 'N' ELEMENTS OF 'A' BY THE SCALAR 'B'
C  AND STORE THE RESULTS IN 'C'.
C
C  A  THE INPUT VECTOR.
C  B  THE SCALAR MULTIPLIER.
C  C  THE OUTPUT VECTOR.
C  N  THE NUMBER OF ELEMENTS IN 'A' AND 'C'.
C
C--
C
      DIMENSION A(N),C(N)
C
C
      DATA I/0/
C
C--CHECK FOR SOME ELEMENTS
      IF(N)1100,1100,1000
1000  CONTINUE
      DO 1050 I=1,N
      C(I)=A(I)/B
1050  CONTINUE
1100  CONTINUE
      RETURN
      END
C
CODE FOR XDETR3
      FUNCTION XDETR3(AMAT)
C--COMPUTE THE DETERMINANT OF THE 3 BY 3 MATRIX 'AMAT'.
C
C  AMAT  THE MATRIX.
C
C--THE RETURN VALUE IS THE VALUE OF THE DETERMINANT.
C
C--
C
      DIMENSION AMAT(9)
C
      XDETR3=(AMAT(5)*AMAT(9)-AMAT(8)*AMAT(6))*AMAT(1)-(AMAT(2)*AMAT(9)
     2 -AMAT(8)*AMAT(3))*AMAT(4)+(AMAT(2)*AMAT(6)-AMAT(5)*AMAT(3))
     3 *AMAT(7)
      RETURN
      END
C
C
cCODE FOR XMTCEX
c      SUBROUTINE XMTCEX (A,B,K,L)
cC----- EXCHANGE ORDER OF COLUMNS OF MATRIX A(K,L)
c      DIMENSION  A(K,L), B(K,L)
c      N = L + 1
c      DO 200 J = 1, L
c      DO 100 I = 1, K
c      B(I,J) = A(I,N-J)
c100   CONTINUE
c200   CONTINUE
c      RETURN
c      END

CODE FOR XMTREX
      SUBROUTINE XMTREX (A,B,K,L)
C----- EXCHANGE ORDER OF ROWS OF MATRIX A(K,L)
      DIMENSION  A(K,L), B(K,L)
      N = K + 1
      DO 200 I = 1, L
      DO 100 J = 1, K
      B(J,I) = A(N-J,I)
100   CONTINUE
200   CONTINUE
      RETURN
      END
C
CODE FOR MATINV
      SUBROUTINE MATINV(A,B,D)
C
C
      DIMENSION A(3,3),B(3,3)
      CALL VMULT(A(1,2),A(1,3),B(1,1))
      CALL VMULT(A(1,3),A(1,1),B(1,2))
      CALL VMULT(A(1,1),A(1,2),B(1,3))
      D=A(1,1)*B(1,1)+A(2,1)*B(2,1)+A(3,1)*B(3,1)
      IF(D.EQ.0.0)RETURN
      N=1
1000  K=1
1100  B(K,N)=B(K,N)/D
      K=K+1
      IF(K.LE.3)GOTO 1100
      N=N+1
      IF(N.LE.3)GOTO 1000
      CALL MTRANS(B)
      RETURN
      END
CODE FOR XUNTM
      SUBROUTINE XUNTM(AMAT, N)
C--SET UP A UNIT MATRIX IN 'AMAT'
C
C  AMAT  THE MATRIX TO BE SET UP AS A UNIT MATRIX.
C  N     DIMENSION OF SQUARE MATRIX
C--
C
      DIMENSION AMAT(N*N)
C
C--ZERO THE MATRIX
      CALL XZEROF(AMAT(1),N*N)
      IZAP = 1
      DO JZAP=1,N
       AMAT(IZAP)=1.
       IZAP=IZAP+N+1
      ENDDO
      RETURN
      END
CODE FOR XUNTM3
      SUBROUTINE XUNTM3(AMAT)
C--SET UP A 3*3 UNIT MATRIX IN 'AMAT'
C
C  AMAT  THE MATRIX TO BE SET UP AS A UNIT MATRIX.
C
C--
C
      DIMENSION AMAT(9)
C
C--ZERO THE MATRIX
      CALL XZEROF(AMAT(1),9)
      AMAT(1)=1.
      AMAT(5)=1.
      AMAT(9)=1.
      RETURN
      END
C
CODE FOR XUNTMM3
      SUBROUTINE XUNTMM3(AMAT)
C--SET UP A 3*3 UNIT MATRIX IN 'AMAT'
C
C  AMAT  THE MATRIX TO BE SET UP AS A UNIT MATRIX.
C
C--
C
      DIMENSION AMAT(9)
C
C--ZERO THE MATRIX
      CALL XZEROF(AMAT(1),9)
      AMAT(1)=-1.
      AMAT(5)=-1.
      AMAT(9)=-1.
      RETURN
      END
C
CODE FOR NROT
      FUNCTION NROT(AL,T,AMAT)
C--COMPUTE THE ROTATION MATRIX RESULTING FROM A ROTATION OF 'T' DEGREES
C  ABOUT THE AXIS WITH DIRECTION COSINES GIVEN BY 'AL'.
C
C  AL    THE DIRECTION COSINES OF THE LINE ABOUT WHICH THE ROTATION IS
C        TO BE PERFORMED. THIS SET OF COSINES MUST BE WITH RESPECT TO AN
C        ORTHOGONAL SYSTEM OF AXES.
C  T     THE ANGLE OF ROTATION IN DEGREES.
C  AMAT  THE RESULTANT ROTATION MATRIX. THE MATRIX IS STORED BY COLUMNS.
C
C--RETURN VALUES OF 'NROT' ARE :
C
C  -1  THE VECTOR IN 'AL' HAS ZERO LENGTH.
C  >0  MATRIX COMPUTED CORRECTLY.
C
C--
C
      DIMENSION AL(3),AMAT(9)
C
      INCLUDE 'XCONST.INC'
C
C
      DATA E/0.0/,S/0.0/,C/0.0/,D/0.0/
C
C--NORMALISE THE INPUT VECTOR
      CALL XZEROF(AMAT(1),9)
      NROT=-1
      IF(NORM3(AL))1050,1050,1000
C--CONVERT THE ANGLE TO DEGREES
1000  CONTINUE
      NROT=1
      E=T*PI/180.0
      S=SIN(E)
      C=COS(E)
      D=1.-C
C--COMPUTE THE REQUIRED ELEMENTS
      AMAT(1)=C+AL(1)*AL(1)*D
      AMAT(2)=AL(1)*AL(2)*D+AL(3)*S
      AMAT(3)=AL(3)*AL(1)*D-AL(2)*S
      AMAT(4)=AL(1)*AL(2)*D-AL(3)*S
      AMAT(5)=C+AL(2)*AL(2)*D
      AMAT(6)=AL(2)*AL(3)*D+AL(1)*S
      AMAT(7)=AL(3)*AL(1)*D+AL(2)*S
      AMAT(8)=AL(2)*AL(3)*D-AL(1)*S
      AMAT(9)=C+AL(3)*AL(3)*D
1050  CONTINUE
      RETURN
      END
C
CODE FOR NCROP3
      FUNCTION NCROP3(A,B,C)
C--COMPUTES THE CROSS PRODUCT OF THE VECTORS A AND B AND STORES THE
C  RESULT IN C.
C
C  A  THE FIRST VECTOR.
C  B  THE SECOND VECTOR.
C  C  THE CROSS PRODUCT OF A WITH B. (C = A CROSS B).
C
C--THE RETURN VALUES OF 'NCROP' ARE :
C
C  -1  THE INPUT VECTORS ARE PARALLEL  RESULTANT VECTOR HAS ZERO LENGTH.
C  >0  THE RESULTANT VECTOR IS NOT ZERO.
C
C--THE OUTPUT VECTOR IN 'C' IS NORMALISED BEFORE RETURN.
C
C--
C
      DIMENSION A(3),B(3),C(3)
C
      NCROP3=1
      CALL VMULT(A,B,C)
      IF(NORM3(C))1000,1000,1050
C--ZERO LENGTH VECTOR
1000  CONTINUE
      NCROP3=-1
1050  CONTINUE
      RETURN
      END
C
CODE FOR VMULT
      SUBROUTINE VMULT(A,B,C)
C----- FORM THE UN-NORMALISED VECTOR (cross) PRODUCT
      DIMENSION A(3),B(3),C(3)
      C(1)=A(2)*B(3)-A(3)*B(2)
      C(2)=A(3)*B(1)-A(1)*B(3)
      C(3)=A(1)*B(2)-A(2)*B(1)
      RETURN
      END
C
CODE FOR FDPROD
      FUNCTION FDPROD(A,B) 
C----- THE SUBROUTINE DVPROD PACKAGED AS A FUNCION
C      FOR USE IN EXPRESSIONS
C----- RETURN VALUE IS THE PRODUCT.
C 
      DIMENSION A(3), B(3)
      CALL DVPROD(A,B,C)
      FDPROD = C
      RETURN
      END
C
CODE FOR DVPROD
      SUBROUTINE DVPROD(A,B,C)
C----- FORM THE SCALAR (DOT) PRODUCT.
      DIMENSION A(3),B(3)
      C=A(1)*B(1)+A(2)*B(2)+A(3)*B(3)
      RETURN
      END
CODE FOR NORM3
      FUNCTION NORM3(X)
C--NORMALISE THE VECTOR 'X' SO THAT THE SUM OF THE SQUARES
C  OF ITS THREE ELEMENTS IS UNITY.
C
C  X  THE VECTOR, CONTAINING THREE ELEMENTS.
C
C--THE RETURN VALUES OF 'NORM' ARE :
C
C  -1  THE VECTOR HAS ZERO LENGTH  (<0.0001).
C  >0  ALL OKAY.
C
C--
C
      DIMENSION X(3)
C
      INCLUDE 'XCONST.INC'
C
C
      DATA D/0.0/
C
C--SUM THE SQUARES
      D=X(1)*X(1)+X(2)*X(2)+X(3)*X(3)
C--CHECK THAT THE VECTOR IS NOT OF ZERO LENGTH
      NORM3=-1
      IF(D-ZEROSQ)1050,1050,1000
C--NORMALISE THE COMPONENTS
1000  CONTINUE
      D=1./SQRT(D)
      X(1)=X(1)*D
      X(2)=X(2)*D
      X(3)=X(3)*D
      NORM3=1
C--AND NOW RETURN
1050  CONTINUE
      RETURN
      END
C
CODE FOR KINV2
      FUNCTION KINV2(N,A,B,NA,NM,C,D,NC)
C--MATRIX INVERSION AND SOLUTION OF SIMULTANEOUS LINEAR EQUATIONS
C
C  N       ORDER OF THE MATICES TO BE INVERTED.
C  A       MATRIX TO BE INVERTED  I.E. A(N,N)
C  B       INVERSE MATRIX  -  CALCULATED BY THIS SUBROUTINE  -  B(N,N)
C  NA      THE ORDER OF 'A' AND 'B'  -  GREATER THAN OR EQUAL
C          TO 'N*N'.
C  NM      NUMBER OF COLUMN VECTORS TO BE MULTIPLIED ONTO THE INVERSE
C          MATRIX
C  C       COLUMN VECTORS TO BE MULTIPLIED ONTO THE INVERSE MATRIX C(N,M
C  D       RESULTS OF MULTIPLICATION ON TO THE INVERSE MATRIX  -  D(N,M)
C  NC      THE ORDER OF 'C' AND 'D'  -  GREATER THAN OR EQUAL
C          TO THE MAXIMUM OF 'N' AND 'N*NM'. THIS MEANS THAT A COLUMN
C          VECTOR AT LEAST MUST BE PROVIDED FOR BOTH.
C
C--IN MATRIX NOTATION
C
C  D=B.C
C  C=A.D
C
C--RETURN VALUES OF 'KINV2' ARE :
C
C   0  INVERSION ETC. WENT OKAY.
C  >0  SINGULAR  -  RETURN VALUE INDICATES FIRST SIGNULAR ELEMENT FOUND.
C
C--
C
      DIMENSION A(NA),B(NA),C(NC),D(NC)
C
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      DATA ASING/0.0/,BSING/0.0/,CSING/0.0/,E/0.0/,F/0.0/
      DATA M1/0/,M2/0/,M3/0/,M4/0/,M5/0/,M6/0/,M7/0/,M8/0/
      DATA I/0/,J/0/,K/0/,L/0/,M/0/
C
      KINV2=0
C--SET 'EPS', SUCH THAT 'EPS' IS THE SMALLEST NUMBER FOR 1.0+EPS>1.0
      BSING=16.0**(-5)
C--SET THE SMALLEST NUMBER THAT CAN BE EXACTLY REPRESENTED ON THE MACHIN
      CSING=SLAMCH( 'S' )
C--SET THE SINGULARITY CHECK LIMITS
      CSING=CSING/BSING
      BSING=BSING*16.
C--SET ROW INTERCHANGE FLAGS
      DO 1000 I=1,N
      D(I)=FLOAT(I)
1000  CONTINUE
C--COMMENCE DECOMPOSITION A=L.U  -  BY ROWS WITH INTERCHANGES
      M5=1
      M6=1
      M1=M5
      M2=M6
      DO 1100 I=1,N
      DO 1050 J=1,N
      B(M2)=A(M1)
      M1=M1+1
      M2=M2+1
1050  CONTINUE
1100  CONTINUE
      M8=1
      DO 1900 J=1,N
      M2=M6
      M7=M8
      F=-1.
      L=J-1
C--CALCULATE THE L PART , EXCEPT FOR THE DIVISION BY U(I,I)
      DO 1450 I=J,N
      E=B(M2)
      ASING=BSING*ABS(E)
      IF(L)1250,1250,1150
1150  CONTINUE
      M3=I
      M4=M7
      DO 1200 K=1,L
      E=E-B(M3)*B(M4)
      M3=M3+N
      M4=M4+1
1200  CONTINUE
C--TRANSFER TO THE B ARRAY AND CHECK FOR THE MAXIMUM VALUE
1250  CONTINUE
      B(M2)=E
      M2=M2+1
      IF(F-ABS(E))1300,1450,1450
C--THIS IS THE CURRENT MAXIMUM
1300  CONTINUE
      F=ABS(E)
      M=I
      D(M)=ABS(D(M))
C--CHECK SINGULARITY FOR THIS ELEMENT
      IF(ASING-F)1350,1400,1400
1350  CONTINUE
      IF(CSING-F)1450,1400,1400
1400  CONTINUE
      D(M)=-D(M)
1450  CONTINUE
C--CHECK IF THE MAXIMUM VALUE IS INDICATED AS SINGULAR
      IF(D(M))1500,1500,1550
1500  CONTINUE
      KINV2=J
      GOTO 3100
C--INTERCHANGE ROWS
1550  CONTINUE
      CALL XINT2(N,B,NA,D,NC,J,M,N)
      E=1./B(M6)
      B(M6)=E
      IF(J-N)1600,1900,1600
1600  CONTINUE
      M=J+1
      M3=M6+1
      DO 1650 I=M,N
      B(M3)=B(M3)*E
      M3=M3+1
1650  CONTINUE
      IF(L)1850,1850,1700
C--COMPLETE CALCULATION OF U
1700  CONTINUE
      M2=M6+N
      M7=M7+N
      DO 1800 I=M,N
      M3=J
      M4=M7
      DO 1750 K=1,L
      B(M2)=B(M2)-B(M3)*B(M4)
      M3=M3+N
      M4=M4+1
1750  CONTINUE
      M2=M2+N
      M7=M7+N
1800  CONTINUE
C--UPDATE VARIOUS FLAGS
1850  CONTINUE
      M6=M6+N+1
      M8=M8+N
1900  CONTINUE
C--DECOMPOSITION ENDS.
C
C--INVERT THE LOWER TRIANGULAR MATRIX L
      M5=2
C--PROCESS BY ROWS
      DO 2150 I=2,N
      M4=M5
C--PROCESS BY COLUMNS
      DO 2100 J=I,N
      B(M5)=-B(M5)
      K=J-I
      IF(K)2050,2050,1950
1950  CONTINUE
      M1=M5+N
      M2=M4
      DO 2000 L=1,K
      B(M5)=B(M5)-B(M1)*B(M2)
      M1=M1+N
      M2=M2+1
2000  CONTINUE
2050  CONTINUE
      M5=M5+1
2100  CONTINUE
      M5=M5+I
2150  CONTINUE
C
C--INVERT THE UPPER TRIANGULAR MATRIX U
      M5=N*N-1
      DO 2300 I=2,N
      M4=M5+1
      DO 2250 J=I,N
      K=J-I+1
      M1=M5
      M2=M4
      E=0.
      DO 2200 L=1,K
      E=E-B(M1)*B(M2)
      M1=M1-N
      M2=M2-1
2200  CONTINUE
      B(M5)=E*B(M1)
      M5=M5-1
2250  CONTINUE
      M5=M5-I
2300  CONTINUE
C
C--ASSEMBLY OF THE FINAL MATRIX  -  STILL WITH ROWS INTERCHANGED
      M5=1
      DO 2700 J=1,N
      M3=M5+N
      M4=M5+J
      DO 2650 I=1,N
      M1=M3
      M2=M4
      IF(I-J)2350,2350,2400
2350  CONTINUE
      E=B(M5)
      M3=M3+1
      K=N-J
      GOTO 2450
2400  CONTINUE
      E=0.
      M3=M3+N+1
      M4=M4+1
      K=N-I+1
2450  CONTINUE
      IF(K)2600,2600,2500
2500  CONTINUE
      DO 2550 L=1,K
      E=E+B(M1)*B(M2)
      M1=M1+N
      M2=M2+1
2550  CONTINUE
2600  CONTINUE
      B(M5)=E
      M5=M5+1
2650  CONTINUE
2700  CONTINUE
C--ASSEMBLY ENDS.
C
C--SORT OUT THE INTERCHANGES AND STORE FINAL INVERSE MATRIX
      DO 2850 I=1,N
      DO 2800 J=1,N
      K=NINT(D(J))
      IF(K-I)2800,2750,2800
2750  CONTINUE
      CALL XINT2(N,B,NA,D,NC,I,J,1)
      GOTO 2850
2800  CONTINUE
      WRITE(NCAWU,2830)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2830)
      ENDIF
      WRITE ( CMON, 2830)
      CALL XPRVDU(NCVDU, 1,0)
2830  FORMAT(' Inverter fails  ')
      CALL XERHND ( IERSEV )
2850  CONTINUE
C--FINAL ASSEMBLY ENDS.
C
C--SOLVE THE GIVEN EQUATIONS IF ANY
      IF(NM)3100,3100,2900
2900  M3=1
      M4=1
      DO 3050 I=1,NM
      DO 3000 J=1,N
      M1=J
      M2=M3
      D(M4)=0.
      DO 2950 K=1,N
      D(M4)=D(M4)+B(M1)*C(M2)
      M1=M1+N
2950  M2=M2+1
3000  M4=M4+1
3050  M3=M3+N
C
3100  RETURN
      END
C
CODE FOR XINT2
      SUBROUTINE XINT2(N,B,NB,D,ND,J,K,ITYPE)
C--INTERCHANGES EITHER ROWS OR COLUMNS J AND K
C
C--THE TYPE OF INTERCHANGE IS DETERMINATED BY 'ITYPE' :
C
C  1  COLUMNS.
C  2  ROWS.
C
C--
C
      DIMENSION B(NB),D(ND)
C
C
      DATA I/0/,L/0/,M/0/
      DATA F/0.0/
C
      IF(J-K)1000,1100,1000
1000  CONTINUE
      L=(J-1)*(N/ITYPE)+1
      M=(K-1)*(N/ITYPE)+1
      F=D(J)
      D(J)=D(K)
      D(K)=F
      DO 1050 I=1,N
      F=B(L)
      B(L)=B(M)
      B(M)=F
      L=L+ITYPE
      M=M+ITYPE
1050  CONTINUE
1100  CONTINUE
      RETURN
      END
C
CODE FOR XCHOLS
      SUBROUTINE XCHOLS(N,IBASE,IRES)
C--INVERSION OF A SYMMETRIC UPPER TRIANGULAR MATRIX BY THE CHOLESKI
C  METHOD
C
C--THE MATRIX IS HELD IN THE ARRAY 'STORE' IN THE COMMON BLOCK 'XDATA'.
C  THE MATRIX IS STORED AS ITS UPPER TRIANGLE BY ROWS.
C
C  N      ORDER OF THE MATRIX
C  IBASE  ADDRESS OF THE FIRST ELEMENT
C  IRES   ADDRESS OF WORK SPACE OF LENGTH N
C
C--
C
C----- IF THE MATRIX HAS BEEN ACCUMULATED DOUBLE PRECISION,
C      THE FOLLOWING VARIABLES WOULD BEST BE IN QUADRUPLE PRECISION.
C      SINCE QUAD PRECISION IS NOT PART OF FORTRAN77, WE USE DOUBLE
C      LENGTH VARIABLES FOR BOTH SINGLE AND DOUBLE LENGTH MATRICES.
C
      INCLUDE 'TYPDBL.INC'
C      REAL *16  DPV,ASING,BSING,CSING,DSING,EPV,ONE
C
      INCLUDE 'TYPE11.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XSTR11.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XSSVAL.INC'
C
      INCLUDE 'QSTR11.INC'
C
C
      DATA ONE/1.0/
C      DATA ONE/0.1D1/
C      DATA ONE/0.1Q1/
C
C--ASSIGN THE SINGULARITY CHECK LIMITS
      CSING=0.2D1**(-32)
C      CSING=0.2Q1**(-32)
      BSING = SQRT(CSING)
C      BSING = QSQRT(CSING)
C--DECOMPOSE THE MATRIX INTO L.L'
      LU=IRES
      N1=N-1
      K=IBASE
      DPV=STR11(K)
      ASING=BSING
      IF ((N1 .GT. 100) .AND. (IQUN .EQ. JQUN) .AND. (ISSSPD .EQ. 2))
     1THEN
        MDISP = 1
      ELSE
        MDISP = 0
      ENDIF
C--CHECK THE FIRST ELEMENT OF THE FIRST ROW
      IF(N1)2000,2050,1000
1000  CONTINUE
      IF(DPV-BSING)1050,1050,1100
1050  CONTINUE
      CALL XSING(0,N,IBASE,K)
      STR11(LU)=0.
      GOTO 1200
1100  CONTINUE
      DPV = SQRT(DPV)
C      DPV = QSQRT(DPV)
      STR11(K)=DPV
      STR11(LU) = 1.D0/DPV
      K=K+1
      DO 1150 I=1,N1
      STR11(K)=STR11(K)*STR11(LU)
      K=K+1
1150  CONTINUE
C--CONTINUE WITH THE REST OF THE MATRIX
      IF (MDISP .EQ. 1)
     1 CALL XWHIZZ ( '        Decomposing the matrix ', 2 )
1200  CONTINUE
      LU=LU+1
      DO 1650 I=1,N1
      IF (MDISP .EQ. 1) THEN
            IF (ISSTML .EQ. 4) THEN
             CALL SLIDER (I, N1)
            ELSE
             CALL XWHIZZ('  ', I)
            ENDIF
      ENDIF
      DPV=STR11(K)
      ASING=DPV*CSING
      L=IBASE+I
      DO 1250 J=1,I
         DPV = DPV - DPROD( STR11(L), STR11(L) )
C      DPV = DPV- QLEN(STR11(L)*STR11(L))
      L=L+N-J
1250  CONTINUE
      IF(DPV-BSING)1350,1350,1300
1300  CONTINUE
      IF(DPV-ASING)1350,1350,1400
1350  CONTINUE
      CALL XSING(I,N,IBASE,K)
      STR11(LU)=0.
      GOTO 1600
1400  CONTINUE
      DPV = SQRT(DPV)
C      DPV = QSQRT(DPV)
      EPV=ONE/DPV
      STR11(K)=DPV
      STR11(LU) = EPV
      K=K+1
      IF(I-N1)1450,1600,1450
1450  CONTINUE
      LW=I+1
      DO 1550 J=LW,N1
      DPV=STR11(K)
      LS=IBASE+I
      LT=IBASE+J
      DO 1500 M=1,I
         DPV = DPV - DPROD( STR11(LS), STR11(LT) )
C      DPV= DPV- QLEN(STR11(LS)*STR11(LT))
      LS=LS+N-M
      LT=LT+N-M
1500  CONTINUE
      STR11(K)=DPV*EPV
      K=K+1
1550  CONTINUE
1600  CONTINUE
      LU=LU+1
1650  CONTINUE
C
C--INVERSION OF THE TRIANGULAR MATRIX L
      LV=K
      K=K-1
      LU=LU-1
      STR11(K)=STR11(LU)
      K=K-1
      LU=LU-1
      IF (MDISP .EQ. 1)
     1 CALL XWHIZZ ( '        Inverting the triangular matrix ', 2)
      DO 1800 I=1,N1
      IF (MDISP .EQ. 1) THEN
            IF (ISSTML .EQ. 4) THEN
             CALL SLIDER (I, N1)
            ELSE
             CALL XWHIZZ('  ', I)
            ENDIF
      ENDIF
      LW=LV
      DO 1750 J=1,I
      ADD=0.0
      LW=LW-J
      LT=K
      LS=LW
      DO 1700 L=J,I
        ADD = ADD - DPROD( STR11(LS), STR11(LT) )
      LT=LT-1
      LS=LS-L
1700  CONTINUE
      STR11(K)=ADD*STR11(LU)
      K=K-1
1750  CONTINUE
      STR11(K)=STR11(LU)
      K=K-1
      LU=LU-1
1800  CONTINUE
C
C--FORM THE INVERSE MATRIX FROM THE TWO INVERTED TRIANGLES
      K=IBASE
      LS=IBASE-1
      IF (MDISP .EQ. 1)
     1 CALL XWHIZZ ( '        Forming the full inverse matrix ', 2)
      DO 1950 I=1,N
      IF (MDISP .EQ. 1) THEN
            IF (ISSTML .EQ. 4) THEN
             CALL SLIDER (I, N)
            ELSE
             CALL XWHIZZ('  ', I)
            ENDIF
      ENDIF
      LT=LS
      DO 1900 J=I,N
      ADD=0.0
      DO 1850 M=J,N
      LV=M+LT
      LW=M+LS
        ADD = ADD + DPROD( STR11(LV), STR11(LW) )
1850  CONTINUE
      STR11(K)=ADD
      K=K+1
      LT=LT+N-J
1900  CONTINUE
      LS=LS+N-I
1950  CONTINUE
C
2000  CONTINUE
c      WRITE ( CMON,'(1X)' )
c      CALL XPRVDU(NCVDU, 1,0)
      RETURN
C
C--ONLY ONE ELEMENT
2050  CONTINUE
      IF(DPV-ASING)2100,2100,2150
2100  CONTINUE
      CALL XSING(0,N,IBASE,K)
      STR11(LU)=0.
      GOTO 2000
2150  CONTINUE
      STR11(K)=1.0/STR11(K)
      GOTO 2000
      END
C
CODE FOR XSOLVE
      SUBROUTINE XSOLVE(N,IBASE,IVECT,IRES)
C--SOLVE THE NORMAL EQUATIONS
C
C  N     ORDER OF THE MATRIX
C  IBASE FIRST LOCATION OF THE MATRIX
C  IVECT FIRST LOCATION OF THE VECTOR
C  IRES  FIRST LOCATION OF THE RESULTS
C
C--
C
C
      INCLUDE 'TYPE11.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XSTR11.INC'
C
      INCLUDE 'QSTR11.INC'
C
C--WORK OUT THE ANSWERS
      K=IRES
      DO 1250 I=1,N
      LS=IBASE+I-1
      STR11(K)=0.0
      LT=IVECT
      DO 1200 J=1,N
      STR11(K)=STR11(K)+STR11(LT)*STR11(LS)
      IF(J-I)1050,1100,1100
1050  CONTINUE
      LS=LS+N-J
      GOTO 1150
1100  CONTINUE
      LS=LS+1
1150  CONTINUE
      LT=LT+1
1200  CONTINUE
      K=K+1
1250  CONTINUE
      RETURN
      END
C
CODE FOR XSING
      SUBROUTINE XSING(NOC,N,IBASE,K)
C--SINGULARITY ERROR
C
C  NOC     THE SINGULAR PARAMETER MINUS ONE.
C  N       THE ORDER OF THE MATRIX.
C  IBASE   THE ADDRESS OF THE FIRST WORD.
C
C--
      INCLUDE 'TYPE11.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XSTR11.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTR11.INC'
C
      LS=NOC+1
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1000)LS
      ENDIF
      WRITE(NCAWU,1000) LS
      WRITE ( CMON, 1000) LS
      CALL XPRVDU(NCVDU, 1,0)
1000  FORMAT('{E Singularity - relative parameter',I5)
      LS=IBASE+NOC
      DO 1150 LT=1,N
      STR11(LS)=0.0
      IF(NOC-LT)1100,1050,1050
1050  CONTINUE
      LS=LS+N-LT
      GOTO 1150
1100  CONTINUE
      LS=LS+1
      K=K+1
1150  CONTINUE
      RETURN
      END
C
CODE FOR XMXMPI
      SUBROUTINE XMXMPI(A,B,N)
C -- B = INVERSE (A)
C----- MOORE-PENROSE INVERTOR
C----- ACTA (1977),A33 212-215. A. L. MACKAY
      DIMENSION A(N,N)
      DIMENSION B(N,N)
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
C --
      INCLUDE 'QSTORE.INC'
C --
C -- SET UP NUMBERS REQUIRED LATER
      NSQ=N*N
C -- ILIMIT IS THE MAXIMUM NUMBER OF ITERATIONS FOR ANY MATRIX
      ILIMIT=20
C -- ITRLIM IS THE MAXIMUM NUMBER OF INITIAL TRIALS MADE
      ITRLIM=5
C --
      CALL XZEROF(B(1,1),NSQ)
C -- ALLOCATE WORKING SPACE FOR CALCULATIONS
      IPMAT=KSTALL(NSQ)
      IQMAT=KSTALL(NSQ)
      IRMAT=KSTALL(NSQ)
      IINIT=KSTALL(NSQ)
      ISCALE=KSTALL(N)
C -- SAVE INITIAL MATRIX
      CALL XMOVE(A(1,1),STORE(IINIT),NSQ)
C -- CALCULATE SCALE FACTORS FOR MATRIX
      DO 1050 I=1,N
      NSCALE=ISCALE+I-1
      STORE(NSCALE)=10.
      IF (ABS(A(I,I)) .LT. 0.01) GO TO 1050
      STORE(NSCALE)=1/SQRT(ABS(A(I,I)))
1050  CONTINUE
C -- SCALE INITIAL MATRIX
      CALL XMXSCL(A(1,1),A(1,1),STORE(ISCALE),N)
C -- SUM ELEMENTS - NECCESSARY FOR DETERMINING FIRST TRIAL INVERSE
      CALL XMXSEL(A(1,1),N,N,ALP)
C -- IF ALP=0. THEN WE HAVE A ZERO MATRIX
      IF (ALP .LE. 0.000001) GOTO 9500
      ALP=1./ALP
C -- SET P = 2I
      CALL XZEROF(STORE(IPMAT),NSQ)
      NDIAG=IPMAT
      DO 1200 I=1,N
      STORE(NDIAG)=2.
      NDIAG=NDIAG+N+1
1200  CONTINUE
C -- SET ATTEMPTS COUNTER
      ITRIES=1
1300  CONTINUE
C -- INITIAL TRY IS ALP*TRANSPOSE(A)
      CALL XTRANS (A(1,1),STORE(IQMAT),N,N)
      CALL XMULTR (STORE(IQMAT),ALP,STORE(IQMAT),NSQ)
C --
      ITIMES=1
C -- INITIAL VALUE OF OLD TRACE = 0
      TR=0.
1500  CONTINUE
C -- ITERATION LOOP
C -- R = AQ
      CALL XMLTMM(A(1,1),STORE(IQMAT),STORE(IRMAT),N,N,N)
C -- CALCULATE TRACE OF R
      X=XMXTRC(STORE(IRMAT),N)
C -- R = P - R
      CALL XSUBTR(STORE(IPMAT),STORE(IRMAT),STORE(IRMAT),NSQ)
C -- B = Q R
      CALL XMLTMM(STORE(IQMAT),STORE(IRMAT),B(1,1),N,N,N)
C -- CHECK FOR CONVERGENCE
      IF (ABS(X-TR).LT.0.01) GOTO 4000
C -- NOT CONVERGED
C -- IF TRACE IS NEGATIVE OR GREATER THAN ORDER THEN TRY
C    ANOTHER INITIAL MATRIX
      IF ( (X .LE. 0.) .OR. (X .GT. N) ) GOTO 3000
      ITIMES=ITIMES+1
C -- IF WE HAVE HAD ENOUGH ATTEMPTS WITH THIS MATRIX TRY ANOTHER
      IF (ITIMES.GE.(ILIMIT+1)) GOTO 3000
C -- REMEMBER TRACE FOR COMPARISON
      TR=X
C -- SET NEXT TRIAL MATRIX
      CALL XMOVE(B(1,1),STORE(IQMAT),NSQ)
C -- REPEAT
      GO TO 1500
3000  CONTINUE
C -- THIS ATTEMPT HAS NOT WORKED
C -- INCREMENT TRIES COUNT
        ITRIES=ITRIES+1
C -- IF WE HAVE DONE THE MAXIMUM NUMBER OF LOOPS THEN GIVE UP HOPE
      IF (ITRIES.GT.(ITRLIM+1)) GOTO 9800
C -- TRY AGAIN WITH A DIFFERENT INITIAL MATRIX
      ALP=.3*ALP
      GOTO 1300
4000  CONTINUE
C -- PROCESS HAS APPARENTLY CONVERGED
C    IF THE CURRENT TRACE IS NEARLY ZERO THEN ABANDON ATTEMPT
      IF (X.LT.0.01) GOTO 9810
C -- PROCESS HAS SUCCESSFULLY CONVERGED
C -- SCALE MATRIX AGAIN TO RELATE IT TO THE INITIAL VALUES
      CALL XMXSCL(B(1,1),B(1,1),STORE(ISCALE),N)
9500  CONTINUE
C -- RESTORE INITIAL MATRIX
      CALL XMOVE(STORE(IINIT),A(1,1),NSQ)
C -- RELEASE WORK SPACE
      CALL XSTRLL(IINIT)
      CALL XSTRLL(IPMAT)
      CALL XSTRLL(IQMAT)
      CALL XSTRLL(IRMAT)
      CALL XSTRLL(ISCALE)
      RETURN
9800  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE (NCWU,9801)
      ENDIF
      WRITE (NCAWU,9801)
      WRITE ( CMON, 9801)
      CALL XPRVDU(NCVDU, 1,0)
9801  FORMAT (' Inversion process has failed to converge  ')
      GO TO 9900
9810  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE (NCWU,9811)
      ENDIF
      WRITE (NCAWU,9811)
      WRITE ( CMON, 9811)
      CALL XPRVDU(NCVDU, 1,0)
9811  FORMAT (' Trace of inverse has become zero   ')
9900  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE (NCWU,9901)
      ENDIF
      WRITE (NCAWU,9901)
      WRITE ( CMON, 9901)
      CALL XPRVDU(NCVDU, 1,0)
9901  FORMAT (' Error in Moore-Penrose inverter   ')
C -- CALL ERROR ROUTINE
      CALL XERHND ( IERERR )
      RETURN
      END
C
C --
C
CODE FOR XMXSCL
      SUBROUTINE XMXSCL(A,B,SCALE,N)
C -- B(I,J)=A(I,J)*SCALE(I)*SCALE(J)
      DIMENSION A(N,N)
      DIMENSION B(N,N)
      DIMENSION SCALE(N)
C --
      DO 1200 I=1,N
      DO 1100 J=1,N
      B(I,J)=A(I,J)*SCALE(I)*SCALE(J)
1100  CONTINUE
1200  CONTINUE
      RETURN
      END
C
C --
C
CODE FOR XMXSEL
      SUBROUTINE XMXSEL(A,N,M,SUM)
C -- SUM=A(1,1)+A(1,2)+... A(N,M)
      DIMENSION A(N,M)
      SUM=0.
      DO 1200 J=1,N
      DO 1100 I=1,M
      SUM=SUM+A(I,J)
1100  CONTINUE
1200  CONTINUE
      RETURN
      END
C
C --
C
CODE FOR XMXTRC
      FUNCTION XMXTRC(A,N)
C -- XMXTRC = TRACE ( A )
      DIMENSION A(N,N)
C --
      SUM=0.
      DO 2000 I=1,N
      SUM=SUM+A(I,I)
2000  CONTINUE
      XMXTRC=SUM
      RETURN
      END
C
C --
C
cCODE FOR XMXPRM
c      SUBROUTINE XMXPRM(RMAT)
cC -- PRINTS ROTATION MATRIX
c      DIMENSION RMAT(3,3)
c\XUNITS
c\XSSVAL
cC --
c      IF (ISSPRT .EQ. 0) THEN
c      WRITE (NCWU,2010)
c      ENDIF
c2010  FORMAT (1X)
c      DO 3000 J=1,3
c      IF (ISSPRT .EQ. 0) THEN
c      WRITE (NCWU,2020) (RMAT(I,J),I=1,3)
c      ENDIF
c2020  FORMAT (1X,3F10.5)
c3000  CONTINUE
c      IF (ISSPRT .EQ. 0) THEN
c      WRITE (NCWU,3010)
c      ENDIF
c3010  FORMAT (/)
c      RETURN
c      END

C --
C
CODE FOR XMXEGV
      SUBROUTINE XMXEGV(XM1,XM2,XM3)
      DOUBLE PRECISION DM1,DM2,DM3,DWORK
      DIMENSION XM1(3,3),XM2(3,3),XM3(3)
      DIMENSION DM1(3,3),DM2(3,3),DM3(3),DWORK(10)
C --
      DO 2000 J=1,3
      DO 1500 I=1,3
      DM1(I,J)=DBLE(XM1(I,J))
1500  CONTINUE
2000  CONTINUE
c      I=0
c      CALL F02ABF (DM1(1,1),3,3,DM3(1),DM2(1,1),3,DWORK(1),I)
      INFO = 0
      CALL DSYEV('V','L',3,DM1,3,DM3,DWORK,10,INFO)
      DO 3000 J=1,3
      DO 2500 I=1,3
c      XM2(I,J)=SNGL(DM2(I,J))
      XM2(I,J)=SNGL(DM1(I,J))
      XM3(I)=SNGL(DM3(I))
2500  CONTINUE
3000  CONTINUE
      RETURN
      END
C
C --
C
CODE FOR XMXMFV
      SUBROUTINE XMXMFV(VECTOR,XMATR,NDIM)
C -- CONVERTS VECTOR TO MATRIX
      DIMENSION VECTOR(NDIM)
      DIMENSION XMATR(NDIM,NDIM)
C --
      DO 2000 J=1,NDIM
      DO 1500 I=1,NDIM
      IF (I-J) 1200,1300,1200
1200  CONTINUE
      XMATR(I,J)=0.
      GOTO 1500
1300  CONTINUE
      XMATR(I,J)=VECTOR(J)
1500  CONTINUE
2000  CONTINUE
      RETURN
      END
C
C --
C
CODE FOR XMXRTI
      SUBROUTINE XMXRTI (ATOMS,XMATR,MDATM,NATM)
C -- APPLIES XMATR TO ATOMS
      DIMENSION ATOMS(MDATM,NATM)
      DIMENSION XMATR(3,3)
      DIMENSION RESULT(3)
C --
      DO 2000 J=1,NATM
      CALL XMLTMT(XMATR(1,1),ATOMS(1,J),RESULT(1),3,3,1)
      CALL XMOVE (RESULT(1),ATOMS(1,J),3)
2000  CONTINUE
      RETURN
      END
C
C --
C
CODE FOR XMXUIJ
      SUBROUTINE XMXUIJ (ATOMS,XMATR,MDUIJ,NATM,RCPC)
C -- APPLIES XMATR TO LIST of Uij
C -- First variable in each block is the FLAG parameter.
C -- For now, only apply transform to atoms where flag is zero
C -- (anisotropic atoms).
C -- RCPC is the reciprocal cell lengths.
      DIMENSION ATOMS(MDUIJ,NATM)
      DIMENSION XMATR(3,3), RTEMP(9), STEMP(9)
      DIMENSION RCPC(3), RCPM(9), RCPI(9)
     
      CALL XZEROF(RCPM,9)
      RCPM(1) = RCPC(1)
      RCPM(5) = RCPC(2)
      RCPM(9) = RCPC(3)
      CALL XZEROF(RCPI,9)
      RCPI(1) = 1.0/RCPC(1)
      RCPI(5) = 1.0/RCPC(2)
      RCPI(9) = 1.0/RCPC(3)

      DO J=1,NATM

        IF ( NINT(ATOMS(1,J)) .EQ. 0) THEN


C Get full tensor from upper diagonal storage:
          RTEMP(1)=ATOMS(2,J)  !U11
          RTEMP(2)=ATOMS(7,J)  !U12
          RTEMP(3)=ATOMS(6,J)  !U13       2 7 6
          RTEMP(4)=ATOMS(7,J)  !U21       7 3 5
          RTEMP(5)=ATOMS(3,J)  !U22       6 5 4
          RTEMP(6)=ATOMS(5,J)  !U23
          RTEMP(7)=ATOMS(6,J)  !U31
          RTEMP(8)=ATOMS(5,J)  !U32
          RTEMP(9)=ATOMS(4,J)  !U33

C Transform = RCPI * R * RCPM * U * trans(RCPM) * trans(R) * trans(RCPI))
C where RCPN is a matrix with a*, b* and c* on the diagonal,
C and RCPI is its inverse. Start from the middle to the left:
          CALL XMLTMM (RCPM,RTEMP,STEMP,3,3,3)  ! RCPM*U
          CALL XMLTMM (XMATR,STEMP,RTEMP,3,3,3)! R*RESULT
          CALL XMLTMM (RCPI,RTEMP,STEMP,3,3,3)  ! RCPI*RESULT
C Now to the right:
          CALL XMLTMT (STEMP,RCPM,RTEMP,3,3,3)  ! RESULT*RCPM
          CALL XMLTMT (RTEMP,XMATR,STEMP,3,3,3)! RESULT*R'
          CALL XMLTMT (STEMP,RCPI,RTEMP,3,3,3)  ! RESULT*RCPI
C Get upper diagonal form from full tensor:
          ATOMS(2,J)=RTEMP(1)
          ATOMS(3,J)=RTEMP(5)
          ATOMS(4,J)=RTEMP(9)
          ATOMS(5,J)=RTEMP(6)
          ATOMS(6,J)=RTEMP(3)
          ATOMS(7,J)=RTEMP(2)
        END IF
      END DO
      RETURN
      END
C
C --
C
CODE FOR XMXTRL
      SUBROUTINE XMXTRL (ATOMS,VECTOR,MDATM,NATM)
C -- TRANSLATES ATOMS BY VECTOR
C    FINAL ATOM COORDINATES ARE MULTIPLIED BY WEIGHT
C    (SETTING THOSE WITH ZERO WEIGHT TO 0. 0. 0.)
C --
      DIMENSION ATOMS(MDATM,NATM)
      DIMENSION VECTOR(3)
C --
      DO 2000 I=1,3
      DO 1000 J=1,NATM
      ATOMS(I,J)=ATOMS(I,J)-VECTOR(I)
      ATOMS(I,J)=ATOMS(I,J)*ATOMS(4,J)
1000  CONTINUE
2000  CONTINUE
      RETURN
      END
C
C --
C
CODE FOR XMXCLO
      SUBROUTINE XMXCLO(DATA,XMATR)
      DIMENSION DATA(6)
      DIMENSION XMATR(9)
C --
      XMATR(1)=DATA(1)*SIN(DATA(5))*SIN(DATA(6))
      XMATR(2)=0.
      XMATR(3)=0.
      XMATR(4)=-DATA(1)*SIN(DATA(5))*COS(DATA(6))
      XMATR(5)=DATA(2)*SIN(DATA(4))
      XMATR(6)=0.
      XMATR(7)=DATA(1)*COS(DATA(5))
      XMATR(8)=DATA(2)*COS(DATA(4))
      XMATR(9)=DATA(3)
C --
      RETURN
      END
C
C --
C
CODE FOR XMXCRM
      SUBROUTINE XMXCRM(ROTN,XMATR)
      DIMENSION ROTN(3)
      DIMENSION XMATR(3,3)
      INCLUDE 'STORE.INC'
C --
      ITMP1=KSTALL(9)
      ITMP2=KSTALL(27)
C -- GET UNIT MATRIX
      CALL XUNTM3(STORE(ITMP1))
C -- CALCULATE ROTATION MATRIX ABOUT X,Y,Z, AXES
      DO 2000 I=1,3
      IPL1=3*(I-1)
      IPL2=9*(I-1)
      J=NROT(STORE(IPL1+ITMP1),ROTN(I),STORE(ITMP2+IPL2))
2000  CONTINUE
      CALL XMLTMM(STORE(ITMP2+9),STORE(ITMP2),STORE(ITMP1),3,3,3)
      CALL XMLTMM(STORE(ITMP2+18),STORE(ITMP1),XMATR(1,1),3,3,3)
C -- RELEASE WORK SPACE
      CALL XSTRLL(ITMP1)
      CALL XSTRLL(ITMP2)
      RETURN
      END
C

C=================================================================================C
C                 Upper triangular matrix routines added by stefan                C
C                             Also some matlab output subroutines                 C
C=================================================================================C     

C======================================================================C
C                  Upper triangular matrix routines                    C
C======================================================================C     
CODE FOR tri_matrix_normalise      
      subroutine tri_matrix_normalise(matrix, mat_size, mat_dim, vector)
      implicit none
C
C     Description:
C        Takes upper tri matrix and normalises all the values in it using the diagonal elments.
C       Vector must be an array of reals which is at least mat_dim big.
C
C     Returns: 
C         The vector used to normalise the matrix in vector
C
C  ================   Arguments   ================
      integer mat_dim            ! the size of one dimention of the matrix
      integer mat_size           ! the number of elements in the 
      real matrix(mat_size)      ! the matrix to normalise
      double precision vector(mat_dim)
C  ================Local Variables================      
      integer x   ! Position in the matrix
      
      do x= 0, mat_dim-1 ! Run though matrix getting sqrt of the diagonal elements
            vector(x+1) = sqrt(matrix((mat_dim - x)*x+x*(x+1)/2+1))
      enddo
      call tri_matrix_normalise_with_inv(matrix, mat_size, mat_dim,
     1  vector)
      end      
      
CODE FOR matrix_normalise_with
      subroutine tri_matrix_normalise_with(matrix, mat_size, mat_dim,
     1 vector)
      implicit none
C
C     Description:
C        Takes upper tri matrix and pre and post multiplies it with the
C       inverse of the diagonal matrix vector.
C
C     Returns:
C        Returns the normalised matrix in the matrix parameter
C
C  ================   Arguments   ================
      integer mat_dim            ! the size of one dimention of the matrix
      integer mat_size           ! the number of elements in the 
      real matrix(mat_size)   ! the matrix to normalise
      double precision vector(mat_dim)       ! the vector to normalise with
      
      call tri_diag_mul_matrix(vector, mat_dim, matrix, mat_size)
      call tri_matrix_mul_diag(matrix, mat_size, vector, mat_dim)
      end

CODE FOR matrix_normalise_with_inv
      subroutine tri_matrix_normalise_with_inv(matrix, mat_size,
     1 mat_dim, vector)
      implicit none
C
C     Description:
C        Takes upper tri matrix and pre and post multiplies it with the 
C       inverse of the diagonal matrix vector.
C
C     Returns:
C        Returns the denormalised matrix in the matrix parameter
C
C  ================   Arguments   ================
      integer mat_dim                        ! the size of one dimention of the matrix
      integer mat_size                       ! the number of elements in the 
      real matrix(mat_size)                  ! the matrix to normalise
      double precision vector(mat_dim)       ! the vector to normalise with
      
      call tri_invdiag_mul_matrix(vector, mat_dim, matrix, mat_size)
      call tri_matrix_mul_invdiag(matrix, mat_size, vector, mat_dim)
      end
            
CODE FOR tri_matrix_mul_diag
      subroutine tri_matrix_mul_diag(matrix, matrix_size, diag, 
     1 diag_size)
      implicit none
C     
C     Description:
C        Takes a upper triangular matrix and multiplies it with a diag 
C       matrix. The matrices are assumed to be the same dimension.
C
C     Returns:
C        The result of the multiplication in the matrix parameter
C
C  ================   Arguments   ================
      integer matrix_size
      real matrix(matrix_size)
      integer diag_size
      double precision diag(diag_size)
C  ================Local Variables================         
      integer row, column
      integer mat_elem
      double precision const 
      
      mat_elem = 1
      do row = 1, diag_size
        const = diag(row)
        do column = row, diag_size
            matrix(mat_elem) = const*matrix(mat_elem);
            mat_elem = mat_elem + 1;
        end do 
      end do
      end

CODE FOR tri_diag_mul_matrix
      subroutine tri_diag_mul_matrix(diag, diag_size, matrix, 
     1  matrix_size)
      implicit none
C
C     Description:
C        Takes a diag matrix and multiplies it with a upper triangular matrix.
C       The matrices are assumed to be the same dimension.
C
C     Returns:
C        The result of the multiplication in the matrix parameter
C
C  ================   Arguments   ================
      integer matrix_size
      real matrix(matrix_size)
      integer diag_size
      double precision diag(diag_size)
C  ================Local Variables================ 
      integer mat_elem
      double precision const 
      integer row, column     
      
      row = 1
      mat_elem = 1
      do while (mat_elem .le. matrix_size)
            do column = row, diag_size
                  matrix(mat_elem) = diag(column)*matrix(mat_elem)
                  mat_elem = mat_elem + 1
            end do 
            row = row + 1
      end do
      end

CODE FOR tri_matrix_mul_invdiag
      subroutine tri_matrix_mul_invdiag(matrix, matrix_size, diag, 
     1 diag_size)
      implicit none
C     
C     Description:
C        Takes a upper triangular matrix and multiplies it the inverse of the diag matrix.
C       The matrices are assumed to be the same dimension.
C
C     Returns:
C        The result of the multiplication in the matrix parameter
C
C  ================   Arguments   ================
      integer matrix_size
      real matrix(matrix_size)
      integer diag_size
      double precision diag(diag_size)
C  ================Local Variables================ 
      integer row, column
      integer mat_elem
      double precision const 
      
      mat_elem = 1
      do row = 1, diag_size
        const = diag(row)
        do column = row, diag_size
            matrix(mat_elem) = matrix(mat_elem)/const;
            mat_elem = mat_elem + 1;
        end do 
      end do
      end

CODE FOR tri_invdiag_mul_matrix
      subroutine tri_invdiag_mul_matrix(diag, diag_size, matrix, 
     1  matrix_size)
      implicit none
C
C     Description:
C        Takes a diag matrix and multiplies it's unverse with an upper triangular matrix.
C       The matrices are assumed to be the same dimension.
C
C     Returns:
C        The result of the multiplication in the matrix parameter
C
C  ================   Arguments   ================
      integer matrix_size
      real matrix(matrix_size)
      integer diag_size
      double precision diag(diag_size)
C  ================Local Variables================       
      integer row, column
      integer mat_elem
      double precision const 
      
      row = 1
      mat_elem = 1
      do while (mat_elem .le. matrix_size)
            do column = row, diag_size
                  matrix(mat_elem) = matrix(mat_elem)/diag(column)
                  mat_elem = mat_elem + 1
            end do 
            row = row + 1
      end do
      end

CODE FOR tri_get
      function tri_get(mat, nmat, mat_dim, xpos, ypos)
      implicit none
      real tri_get
C
C     Description:
C        Get the value of the element in mat at position xpos ypos.
C       Treets mat as a upper triangler symetric matrix. It is indexed from 1
C
C     Precondition:
C        xpos, ypos must both be less then or equal to the dimension of the matrix
C
C     Returns:
C        The value stored at the position xpos, ypos
C
C  ================   Arguments   ================
      integer nmat, mat_dim
      real mat(nmat)
      integer xpos, ypos
C  ================Local Variables================
      integer maxpos, minpos
C  ================Function calls ================      
      integer max, min
      
      maxpos = max(xpos, ypos)
      minpos = min(xpos, ypos) - 1
      tri_get = mat((mat_dim-(minpos+1))*minpos+minpos*(minpos+1)/2+
     1 maxpos)
      end
      
CODE FOR tri_set
      subroutine tri_set(mat, nmat, mat_dim, xpos, ypos, value)
      implicit none
C
C     Description:
C        Set the value of the element in mat at position xpos ypos.
C       Treets mat as a upper triangler symetric matrix
C
C     Precondition:
C        xpos, ypos must both be less then the dimension of the matrix
C
C  ================   Arguments   ================
      integer nmat, mat_dim
      real mat(nmat)
      integer xpos, ypos
      real value
C  ================Local Variables================
      integer maxpos, minpos
C  ================Function calls ================      
      integer max, min
      
      maxpos = max(xpos, ypos)
      minpos = min(xpos, ypos) - 1
      mat((mat_dim-(minpos+1))*minpos+minpos*(minpos+1)/2+
     1 maxpos) = value
      end

C======================================================================C
C                         Diagonal matrix routines                     C
C======================================================================C     

CODE FOR inv_diag      
      subroutine inv_diag(diag, diag_size)
      implicit none
C
C     Description:
C           Invertes the diagonal matrix which is represented as a vector
C     Precondition:
C
C  ================   Arguments   ================
      integer diag_size
      double precision diag(diag_size)
C  ================Local Variables================
      integer i
      
      do i = 1, diag_size
            diag(i) = 1.0/diag(i)
      end do
      end

CODE FOR diag_get
      function diag_get(diag, diag_dim, xpos, ypos)
      implicit none
      real diag_get
C
C     Description:
C           Returns the value at xpos, ypos in the diagonal matrix
C     Returns:
C           Returns the value at xpos, ypos in the diagonal matrix
C  ================   Arguments   ================
      integer diag_dim
      real diag(diag_dim)
      integer xpos, ypos
      
      if (xpos .ne. ypos) then
            diag_get = 0.0
      else 
            diag_get = diag(xpos)
      end if
      return
      end
      
CODE FOR tri_matrix_apply_threshhold
      function tri_matrix_apply_threshhold(matrix, matrix_size, 
     1 mat_dim, threshhold)
      implicit none
      integer tri_matrix_apply_threshhold
C
C     Description:
C           Take a upper triangluar matrix and replaces all values 
C          which are less then threshold*sqrt(Mii)*sqrt(Mjj) with zero
C
C     Returns:
C           The number of elements which where zeroed and 
C           the thresh holded matrix in the variable matrix.
C
C  ================   Arguments   ================      
      integer matrix_size
      real matrix(matrix_size)
      integer mat_dim         ! dimension of the matrix
      real threshhold      ! Threshhold value for the matrix
C  ================Local Variables================      
      integer curx, cury      ! Current x and y position
      real normilisers(mat_dim)
      real curr_val
C  ================Function calls ================            
      real tri_get            
      
      tri_matrix_apply_threshhold =0
      do curx = 1, mat_dim
            normilisers(curx) = 1/sqrt(tri_get(matrix, matrix_size, 
     1       mat_dim, curx, curx))
      end do 
      do curx = 2, mat_dim
            do cury = curx+1, mat_dim
                  curr_val = tri_get(matrix, matrix_size, mat_dim,
     1             curx, cury)*normilisers(curx)*normilisers(cury)
                  if (curr_val .lt. threshhold
     1             ) then
                        call tri_set(matrix, matrix_size, mat_dim, curx,
     1                    cury, 0.0)
                        tri_matrix_apply_threshhold = 
     1                   tri_matrix_apply_threshhold + 1
                  end if
            end do
      end do
      print '(A, F7.5, I10)', 'Threshold is: ', threshhold, 
     1 tri_matrix_apply_threshhold
      end
            
C======================================================================C
C                         matlab output routines                       C
C======================================================================C     
CODE FOR matlab_tri_mat
      subroutine matlab_tri_mat(unit, matrix, matrix_size, mat_dim,
     1  var_name)
      implicit none
      
      integer unit
      character*(*) var_name
      integer mat_dim
      integer matrix_size
      real matrix(matrix_size)
      
      integer xpos, ypos, maxpos, minpos, mat_elem
      
      write (unit, '(A, '' = ['')'), var_name
      do xpos = 1, mat_dim
            do ypos = 1, mat_dim
                  if (mod(ypos, 6) .eq. 0) write (unit, '(A)'), '...'
                  maxpos = max(xpos, ypos)
                  minpos = min(xpos, ypos) - 1
                  mat_elem = (mat_dim-(minpos+1))*minpos+minpos*
     1             (minpos+1)/2 + maxpos
                  write (unit, '(G16.8$)'), matrix(mat_elem)
            end do
            if (xpos .ne. mat_dim)
     1             write (unit, '(A)'), ';'
      end do
      write (unit, '(A)'), '];'
      end
      
CODE FOR matlab_vector
      subroutine matlab_vector(unit, vector, vec_dim, var_name)
      implicit none
      
      integer unit
      character*(*) var_name
      integer vec_dim
      real vector(vec_dim)
      integer pos
      
      write (unit, '(A, '' = ['')'), var_name
      do pos = 1, vec_dim
            if (mod(pos, 6) .eq. 0) write (unit, '(A)'), '...'
            write (unit, '(G16.8$)'), vector(pos)
      end do 
      write (unit, '(A)'), '];'
      end
      
CODE FOR matlab_add_vector_to_cell
      subroutine matlab_add_vector_to_cell(unit, vector, vec_dim,
     1 var_name)
      implicit none
      
      integer unit
      character*(*) var_name
      integer vec_dim
      real vector(vec_dim)
      character*80 tempstring
      
      tempstring = var_name
      call matlab_vector(unit, vector, vec_dim, 
     1 tempstring(1:len(var_name)) // '{length(' // 
     2 tempstring(1:len(var_name)) // ')+1}')
      end

CODE FOR matlab_add_matrix_to_cell
      subroutine matlab_add_matrix_to_cell(unit, matrix, matrix_size,
     1 mat_dim, var_name)
      implicit none
      
      integer unit
      character*(*) var_name
      integer matrix_size, mat_dim
      real matrix(matrix_size)
      character*80 tempstring
      
      tempstring = var_name
      call matlab_tri_mat(unit, matrix, matrix_size, mat_dim, 
     1 tempstring(1:len(var_name)) // '{length(' // 
     2 tempstring(1:len(var_name)) // ')+1}')
      end
      
C======================================================================C
C                       Sub block matrix routines                      C
C======================================================================C     
CODE FOR sum_block
      function sum_block(mat, nmat, mat_dim, params1_add, 
     1 params2_add, num_param_sumed, block_start_parm)
     
      double precision sum_block
C
C     Description:
C        Sums all the values in the block of the mat pointed to by the
C       parameters in the parts which are pointed to by. 
C
C     Precondition:
C       params1_add and params2_add are pointers to valid atoms parts
C       List 12 has already been loaded.
C       List 12 has been loaded with the parameter numbers set
C        to there number not to pointer in the derivative stack.
C
C     Returns:
C           The sum of the values for the rectangle referenced or -1 
C           if for some reason the suming was invalid
C
      INCLUDE 'ISTORE.INC'
      INCLUDE 'STORE.INC'
      INCLUDE 'QSTORE.INC'
C  ================   Arguments   ================
      integer nmat, mat_dim          !The size of the matrix and it's dimension
      real mat(nmat)                 !The upper triangulare matrix
      integer params1_add            !Address in istore of the part information. 
      integer params2_add            !Address in istore of the part information. 
      integer num_param_sumed        !On return the number of values sumed
      integer block_start_parm       !The first parameter in this block.
C  ================Local Variables================     
      integer param_iterator1(3)
      integer param_iterator2(3)
      integer tempa, tempb
C  ================Function calls ================     
      integer list_iter_next
      logical iter_has_next
      real tri_get, abs
            
      sum_block = 0.0
      num_param_sumed = 0
      block_start = block_start - 1
      
      call part_create_list_iter(param_iterator1, istore(params1_add))  ! Create an iterator to go over the part
      do while (iter_has_next(param_iterator1))                         ! Check that there is a parameter to use
            tempa = istore(list_iter_next(param_iterator1))
     1               -block_start_parm                                  ! Get the current parameter number in this block
            if (tempa .gt. 0 .and. 
     1       tempa .le. mat_dim) then                                   ! If the parameter is withing this block 
              call part_create_list_iter(param_iterator2,
     1         istore(params2_info_add))
              do while (iter_has_next(param_iterator2))
                  tempb = istore(list_iter_next(param_iterator2))
     1               -block_start_parm                                  ! Get the current parameter number in this block
                  if (tempb .gt. 0 .and.
     1                tempb .le. mat_dim) then                          ! If the parameter is withing this block 
                  sum_block = sum_block + abs(tri_get(mat, nmat,        ! Get the current element and add it to the current number total
     2              mat_dim, tempa, tempb))
                   num_param_sumed = num_param_sumed + 1                ! Count that this element has been included
                  else                                                  ! If the parameter was outside the matrix block then don't sum any of it.
                        sum_block = -1                                  ! Inform the caller that we didn't sum it.
                        return
                  end if
             enddo
           else                                                         ! If the parameter was outside the matrix block then don't sum any of it.
              sum_block = -1                                            ! Inform the caller that we didn't sum it.
              return
           end if
      end do
      end
      
CODE FOR mean_of_block
      function mean_of_block(mat, nmat, mat_dim, params1_add, 
     1 params2_add, block_start_parm)
      implicit none
      double precision mean_of_block
C
C     Description:
C        Calculates the mean of the abs rectange of parameters pointed to by the part which
C       is pointed to by params1_add and params2_add. 
C
C     Precondition:
C       params1_info_add and params2_info_add are pointers to valid atoms parts
C       List 12 has already been loaded.
C       List 12 has been loaded with the parameter numbers set
C        to there number not to pointer in the derivative stack.
C
C     Returns:
C           Returns the mean of the abs rectange referenced or -1 if for some reason the
C          mean wasn't calculated
C

C  ================   Arguments   ================
      integer nmat, mat_dim               ! The size of the block of the normal matrix
      real mat(nmat)                      ! The current upper triangler block of the normal matrix
      integer params1_add, params2_add    ! The addresses to the parameter parts
      integer block_start_parm            ! The parameter number of the first element in the matrix

C  ================Local Variables================       
      integer block_size
C  ================Function calls ================       
      double precision sum_block

      mean_of_block = sum_block(mat, nmat, mat_dim, params1_add,
     1 params2_add, block_size, block_start_parm)                 ! Get the sum of a
      if (mean_of_block .ge. 0)                                   ! If the sum isn't negative
     1       mean_of_block = mean_of_block/block_size             ! There wasn't a problem
      end
