C $Log: not supported by cvs2svn $
C Revision 1.7  2010/12/14 13:08:20  djw
C Output more info in execute/compile mode
C
C Revision 1.6  2005/01/23 08:29:12  rich
C Reinstated CVS change history for all FPP files.
C History for very recent (January) changes may be lost.
C
C Revision 1.1.1.1  2004/12/13 11:16:05  rich
C New CRYSTALS repository
C
C Revision 1.5  2003/08/05 11:11:12  rich
C Commented out unused routines - saves 50Kb off the executable.
C
C Revision 1.4  2001/02/26 10:30:24  richard
C Added changelog to top of file
C
C
CODE FOR XFCOLS
      SUBROUTINE XFCOLS(IULN)
C--FORM COMPILER OUTPUT LIST, FOR LIST TYPE 'IN'.
C
C  IULN  THE LIST TYPE TO BE USED.
C
C--THIS ROUTINE USES AND SETS WHERE NECESSARY THE FOLLOWING VARIABLES :
C
C  LK      THE LENGTH OF THE STORED ARGUMENT DETAILS IN WORDS.
C  LK1     THE LENGTH OF THE COMPLETE ARGUMENT IN WORDS MINUS ONE.
C  LK2     THE LENGTH OF THE COMPLETE ARGUMENT PRODUCED BY THE LEXICAL
C          SCANNER. THE FORMAT OF THIS IS AS FOLLOWS :
C
C          0  THE ARGUMENT TYPE :
C
C             -1  A VARIABLE, STORED AS 'LK' WORDS OF A4 CHARACTER DATA.
C              0  A NUMBER, WHOSE VALUE IS GIVEN IN WORD 2.
C             >0  AN OPERATOR, WHOSE TYPE IS GIVEN BY THE NUMBER IN THIS
C                 LOCATION. ALLOWED VALUES ARE :
C
C                 1  +
C                 2  -
C                 3  *
C                 4  /
C                 5  **
C                 6  (
C                 7  )
C                 8  ,
C                 9  =
C
C          1  THE CHARACTER NUMBER ON THE CARD WHERE THIS ARGUMENT ENDED
C          2  THE FIRST WORD OF THE ARGUMENT. FOR A NUMBER THIS IS THE
C             VALUE, WHILE FOR THE OTHERS IT IS THE START OF OF 'LK' WOR
C             CONTAINING THE ARGUMENT IN CHARACTER FORM.
C          3  THE SECOND WORD OF THE ARGUMENT.
C
C  NWCARD  THE NUMBER OF WORDS PER CARD WHEN IT IS STORED IN A4 FORMAT.
C  LARG    THE DISC ADDRESS OF THENEXT DATA RECORD HEADER BLOCK TO
C          BE PROCESSED.
C  MARG    THE DISC ADDRESS OF THE LAST DATA RECORD HEADER BLOCK
C          LOOKED AT BY 'KLDNLR'.
C  MDARG   THE NUMBER OF WORDS PER ARGUMENT, EQUAL TO 'LK2'.
C  NARG    THE NUMBER OF ARGUMENTS CURRENTLY IN CORE, EQUAL TO 'ME'.
C  MA      THE DISC ADDRESS OF THE NEXT DATA RECORD HEADER BLOCK TO
C          BE PROCESSED BY THE PRINT ROUTINE 'XPCLNN'.
C  MB      THE DISC ADDRESS OF THE LAST DATA RECORD HEADER BLOCK
C          PROCESSED BY THE PRINT ROUTINE 'XPCLNN'.
C  MC      THE NUMBER OF CARDS PRINTED MINUS ONE.
C  MD      THE ADDRESS IN CORE OF THE CURRENT SET OF ARGUMENTS.
C  ME      THE NUMBER OF ARGUMENTS ON THE CURRENT CARD.
C  MF      THE ADDRESS IN CORE OF THE CURREN ARGUMENT.
C  MG      THE FUNCTION OF THIS CARD, IN THE RANGE 1 TO N.
C
C  MQ      THE ADDRESS IN CORE AT WHICH ATOM AND PARAMETER HEADER BLOCKS
C          ARE SET UP.
C
C--THE COMMON BLOCK 'XLST26' CONTROLS THE OUTPUT OF DATA TO
C  THE DISC. THE VARIABLES ARE USED AS FOLLOWS :
C
C  L26D    THE ADDRESS OF THE NEXT DATA RECORD TO BE OUTPUT.
C  M26D    THE ADDRESS OF THE LAST DATA RECORD OUTPUT TO THE DISC.
C  MD26D   THE ADDRESS OF THE FIRST DATA RECORD OUTPUT FOR THIS LIST.
C  N26D    THE CURRENT LENGTH OF THE LIST ON DISC.
C
C  L26IR   THIS GROUP OF VARIABLES CONTROL THE INTERDEPENDENCIES
C          RECORD.
C
C  L26CB   THIS GROUP OF VARIABLES CONTROL THE DATA RECORD USED TO
C          HOLD THE CONTROL BLOCK 'XCNTRL' ON DISC. THE RECORD
C          ASSOCIATED WITH THIS SET OF POINTERS IS -101.
C          ONLY THE VARIABLES FROM 'LCG' TO 'NCS' ARE OUTPUT TO THE
C          DISC, AS 'LC' IS DETERMINED DYNAMICALLY AT EXECUTION TIME.
C
C  L26CA   THIS GROUP OF VARIABLES CONTROLS THE DATA RECORD THAT
C          CONTAINS GENERATED CODE ON THE DISC. THE RECORD
C          ASSOCIATED WITH THIS SET OF POINTERS IS -102.
C
C--THE COMMON BLOCK 'XCNTRL' CONTROLS THE FORMAT OF THE
C  INFORMATION OUTPUT TO THE DISC. WHILE THE LIST IS STILL IN
C  CORE, THE VARIABLES HAVE THE FOLLOWING SIGNIFICANCE :
C
C  LC      BASE ADDRESS OF THE WORK STACK, WHICH HOLDS CONSTANTS
C          AND VARIABLES GENERATED BY THE CODE.
C          THIS VARIABLE SET UP DYNAMICALLY BOTH DURING SYNTAX
C          ANALYSIS AND DURING EXECUTION, AND IS THUS NOT OUTPUT TO
C          DISC.
C  ISTAT2  THIS IS A PRINT CONTROL FLAG :
C
C          -1  PRINT THE CARD IMAGES AS THEY ARE PROCESSED.
C           0  NO PRINTING.
C          +1  PRINT THE CARD IMAGES AND THE GENERATED CODE.
C
C--THE REMAINING 12 WORDS OF THIS COMMON BLOCK ARE OUTPUT TO THE
C  DISC AND DEFINE THE LOCATIONS AND LENGTH OF THE REMAINING BLOCKS
C  ASSOCIATED WITH THIS INSTRUCTION. IN CORE THE FORMAT OF THIS CONTROL
C  BLOCK IS :
C
C  LCG   ADDRESS IN CORE OF THE HEADER BLOCK FOR THE GENERAL CHAIN.
C        FOR OUTPUT PRODUCED BY THE PARSE ROUTINES, THIS CHAIN CONTAINS
C        ONLY INSTRUCTIONS OR CODE. IN OTHER CASES THE CONTENTS
C        OF THE CHAIN ARE DEFINED BY THE FUNCTION OF THE ROUTINE
C        THAT SET IT UP.
C        (ON THE DISC, THIS VARIABLE IS STORED RELATIVE TO 'LCG',
C        THAT IS AS ZERO).
C  MCG   CURRENT ADDRESS IN CORE OF THE NEXT FREE WORD FOR THE GENERAL,
C        PARAMETER HEADER AND CONSTANT CHAINS. THESE CHAINS MOVE UP THE
C        STORE AND MUST UPDATE 'MCG' AS THEY DO SO.
C  MDCG  CURRENT ADDRESS IN CORE OF THE LAST GENERAL (OR INSTRUCTION)
C        BLOCK INSERTED.
C  NCG   NOT DEFINED.
C        (ON THE DISC, THIS VARIABLE IS SET TO THE TOTAL LENGTH
C        OF ALL THE CHAINS FORMED AT THE BOTTOM OF CORE  -  THE
C        GENERAL, PARAMETER AND CONSTANT CHAINS).
C
C  LCA   ADDRESS IN CORE OF THE FIRST BLOCK ON THE PARAMETER HEADER
C        BLOCK CHAIN.
C        (ON THE DISC, THIS VARIABLE IS STORED WITH ITS ADDRESS
C        SET RELATIVE TO 'LCG').
C  MCA   USED TO PROCESS THE PARAMETER HEADER BLOCK CHAIN.
C  MDCA  USED TO PROCESS THE PARAMETER HEADER BLOCK CHAIN.
C  NCA   NUMBER OF PARAMETER HEADER BLOCKS ON THE CHAIN.
C
C  LCS   ADDRESS IN CORE OF THE CONSTANT AND WORK STACK HEADER BLOCK.
C        (ON THE DISC, THIS VARIABLE IS STORED WITH ITS ADDRESS
C        SET RELATIVE TO 'LCG').
C  MCS   CURRENT ADDRESS OF THE LAST BLOCK INSERTED ON THE CONSTANT
C        CHAIN. THIS MUST BE UPDATED WHEN A NEW BLOCK IS ADDED.
C  MDCS  NEXT FREE ADDRESS IN THE WORK STACK. THIS STACK STARTS AT
C        'LC' AND COMES DOWN THE STORE.
C        (THIS PARAMETER SHOULD BE UPDATED WHENEVER SPACE IS
C        ALLOCATED IN THE WORK STACK).
C
C--DURING ALL OPERATIONS EXCEPT PARSING BY 'KPARSE', THE NEXT FREE
C  LOCATION IS STORED IN 'MCG' AND THE LAST FREE LOCATION IS HELD IN 'LF
C
C--FORMAT OF THE GENERAL CHAIN HEADER BLOCK IS :
C
C  0  ADDRESS OF THE FIRST BLOCK ON THE CHAIN REL. TO 'LCG' OR 'NOWT'.
C  1  TYPE OF OPERATION DESCRIBED BY THIS HEADER BLOCK AND ALL THE
C     OTHER HEADER BLOCKS DEFINED BY THE CONTROL BLOCK.
C  2  NOT DEFINED  -  FOR CONSTRAINTS MAY BE A WORK STACK ADDRESS REL.
C                     TO 'LC'..
C  3  NOT DEFINED  -  FOR CONSTRAINTS THE WEIGHT.
C  4  NOT DEFINED  -  FOR CONSTRAINTS THE INPUT OR OBSERVED VALUE.
C
C--THE FORMAT OF THE INSTRUCTION BLOCKS ON THE CHAIN IS :
C
C  0  ADDRESS OF THE NEXT BLOCK RELATIVE TO 'LCG' OR 'NOWT'.
C  1  FUNCTION OF THIS BLOCK.
C  2  ADDRESS IN THE WORK STACK RELATIVE TO 'LC'  -  OPERAND 1.
C  3  ADDRESS IN THE WORK STACK RELATIVE TO 'LC'  -  OPERAND 2.
C  4  ADDRESS IN THE WORK STACK RELATIVE TO 'LC'  -  THE RESULT.
C
C--THE TERMS IN WORDS 2, 3 AND 4 ARE THOSE SET UP BY THE PARSE ROUTINES,
C  AND THE ADDRESSES ARE CONVERTED TO ABSOLUTE VALUES BY 'KLOADR' WHEN
C  THE INFORMATION IS READ BACK FROM THE DISC.
C  THE FORMAT OF THE BLOCK BEYOND WORD 4 IS NOT DEFINED, AND THESE
C  LOCATIONS MAY BE USED AS REQUIRED.
C
C--THE PARAMETER HEADER BLOCKS ARE DIVIDED INTO THOSE FOR ATOMS
C  AND THOSE FOR OVERALL PARAMETERS. THE FORMAT OF THE FORMER IS
C  AS FOLLOWS :
C
C  0   ADDR. OF NEXT HEADER BLOCK REL. TO LCG OR 'NOWT'
C  1   TYPE OF HEADER BLOCK :
C         0  HEADER BLOCK FOR ONE ATOM
C      1024  HEADER BLOCK FOR THE FIRST ATOM OF AN 'UNTIL' SEQUENCE
C  2   ATOM TYPE
C  3   ATOM SERIAL
C  4   NOT USED
C  5   NUMBER OF PARAMETERS
C  6   ADDR. OF FIRST PARAMETER ENTRY REL. TO 'LCG'
C  7   S
C  8   L
C  9   T(X)
C  10  T(Y)
C  11  T(Z)
C  12  ADDR. OF THIS ATOM IN LIST 5 (NOT SET HERE)
C  13  ADDR. OF THIS ATOM IN LIST 12 (NOT SET HERE)
C  14  NOT USED
C  15  ADDR. OF GENERATED PARAMETERS IN WORK STACK REL. TO 'LC'
C  16  ADDR. OF PARAMETERS TO BE USED IN WORK STACK REL. TO 'LC'
C
C--FOR EACH PARAMETER :
C
C  0   LINK TO NEXT PARAMETER REL. TO 'LCG' OR 'NOWT'.
C  1   REL. ADDR. IN LIST 5 (U[ISO]=4, FOR EXAMPLE).
C  2   PARTIAL DERIVATIVE WHEN CALCULATED.
C  .
C
C--THE INFORMATION FOR EACH OVERALL PARAMETER ALSO CONSISTS OF A HEADER
C  WITH THE SPECIFIED PARAMETER GIVEN AS THE COORDINATE ON THE CHAIN AT
C  WORD 6.
C
C  0   ADDR. OF NEXT HEADER BLOCK REL. TO 'LCG' OR 'NOWT'.
C  1   TYPE :
C      1  OVERALL PARAMETER
C      2  LAYER SCALE
C      3  ELEMENT SCALE
C  2   THE POSITION OF THE PARAMETER IN ITS GROUP
C  3   0.0
C  4   NOT USED
C  5   THE NUMBER OF PARAMETERS ON THE CHAIN GIVEN AT WORD 6.
C  6   ADDRESS OF THE PARAMETER CHAIN REL. TO 'LCG' (STARTS AT WORD 7).
C  7   'NOWT'  LINK TO THE NEXT PARAMETER ON THE CHAIN
C  8   THE POSITION OF THE PARAMETER IN ITS GROUP (STARTING FROM 1).
C  9   NOT USED
C  10  'NOWT'
C  11  'NOWT'
C  12  ADDR. OF THE GROUP CONTAINING THIS PARAMETER IN LIST 5 ('NOWT')
C  13  ADDR. OF THE GROUP CONTAINING THIS PARAMETER IN LIST 12 ('NOWT'
C  14  NOT USED
C  15  ADDR. OF THE PARAMETER IN THE WORK STACK REL. TO 'LC'
C  16  ADDR. OF THE SPACE TO BE USED IN THE WORK STACK REL. TO 'LC'
C
C--THE FORMAT OF THE CONSTANT AND WORK STACK HEADER IS :
C
C  0  ADDRESS OF THE NEXT CONSTANT OR WORK STACK HEADER RELATIVE
C     TO 'LCG' OR 'NOWT'.
C  1  LENGTH OF THIS BLOCK (=6)
C  2  ADDRESS AT WHICH THE WORK STACK BEGINS REL. TO 'LC' OR 'NOWT'
C  3  NUMBER OF WORDS REQUIRED FOR THE WORK STACK.
C  4  ADDRESS OF THE FIRST CONSTANT BLOCK ON THE CONSTANT CHAIN REL. TO
C     'LCG' OR 'NOWT'.
C  5  NUMBER OF CONSTANTS ON THE CONSTANT CHAIN.
C
C--THE FORMAT OF THE CONSTANT CHAIN IS :
C
C  0  ADDRESS OF THE NEXT CONSTANT BLOCK RELATIVE TO 'LCG' OR 'NOWT'
C  1  ADDRESS OF THIS CONSTANT IN THE WORK STACK RELATIVE TO 'LC'.
C  2  THE VALUE TO BE PLACED IN THE WORK STACK.
C
C--
      INCLUDE 'ISTORE.INC'
      INCLUDE 'HEADES.INC'
      INCLUDE 'ICOM26.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST26.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QLST26.INC'
C
      INCLUDE 'IDIM26.INC'
C--PREPARE LIST 26 FOR OUTPUT
      CALL XWLSTD(-IULN,ICOM26,IDIM26,0,0)
C--PRESERVE THE INITIAL DISC ADDRESS
      MD26D=M26D
C--OUTPUT THE INTERDEPENDENCIES RECORD
      CALL XWDRTD(IULN,1,L26D,M26D,N26D,ICOM26,IDIM26,0,IBUFF)
      RETURN
      END
C
CODE FOR XLSV
      SUBROUTINE XLSV
      use unitcell_mod
      use xparse_mod
      implicit none
C--LOAD SYSTEM VARIABLES
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      !INCLUDE 'XLST01.INC'
      INCLUDE 'XLST02.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XPARSE.INC'
C
      INCLUDE 'QSTORE.INC'
      
      integer i
      
      integer, external :: kchlfl
      real, dimension(:), allocatable :: rtemp
      
      interface 
          subroutine XSPRDD_new(data_record, new_address)
          integer, intent(out) :: new_address
          real, dimension(:), intent(in) :: data_record  
          end subroutine    
      end interface
C
C--SET UP THE BASE ADDRESS OF THE WORK STACK
      LC=LFL
C--LOAD LIST 1
      CALL XFAL01
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--EXPAND LIST 1 TO ALLOW FOR THE DERIVATIVES

      ! unit cell parameters
      allocate(rtemp(7))
      rtemp=(/ unitcells(1)%a, unitcells(1)%b, unitcells(1)%c, 
     1     unitcells(1)%alpha, unitcells(1)%beta, unitcells(1)%gamma, 
     1     unitcells(1)%volume() /)
      CALL XSPRDD_new(rtemp,KSV_new(1)%address)
      !CALL XSPRDD(7,L1P1,KSV(1,1))
      
      KSV_new(2)%address=KSV_new(1)%address+12
      !KSV(1,2)=KSV(1,1)+12
      
      ! reciprocal unit cell parameters
      rtemp=(/ unitcells(1)%ra, unitcells(1)%rb, unitcells(1)%rc, 
     1     unitcells(1)%ralpha, unitcells(1)%rbeta, unitcells(1)%rgamma, 
     1     unitcells(1)%rvolume() /)
      CALL XSPRDD_new(rtemp,KSV_new(3)%address)
      !CALL XSPRDD(7,L1P2,KSV(1,3))
      
      KSV_new(4)%address=KSV_new(3)%address+12
      !KSV(1,4)=KSV(1,3)+12
      
      ! real metric tensor
      CALL XSPRDD_new(reshape(unitcells(1)%metric(),(/9/)),
     1     KSV_new(5)%address)
      !CALL XSPRDD(9,L1M1,KSV(1,5))

      ! real metric tensor without cell parameters
      CALL XSPRDD_new(reshape(unitcells(1)%metric_exclcell(),(/9/)),
     1     KSV_new(6)%address)
      !CALL XSPRDD(9,L1M2,KSV(1,6))
      
      ! orthogonalisation matrix
      CALL XSPRDD_new(reshape(unitcells(1)%orthogonalisation(),(/9/)),
     1     KSV_new(7)%address)
      !CALL XSPRDD(9,L1O1,KSV(1,7))

      ! orthogonalisation matrix without cell parameters
      CALL XSPRDD_new(reshape(unitcells(1)%orthogonalisation_exclcell()
     1         ,(/9/)),
     1     KSV_new(8)%address)
      !CALL XSPRDD(9,L1O2,KSV(1,8))
      
      ! constants to convert from iso to aniso
      CALL XSPRDD_new(unitcells(1)%iso_to_aniso(), KSV_new(9)%address)      
      !CALL XSPRDD(3,L1C,KSV(1,9))
      
      ! the r(ii)'s and r(ij)'s used to calculate sin(theta)/lambda
      CALL XSPRDD_new(unitcells(1)%Rij_linear(), KSV_new(10)%address)
      !CALL XSPRDD(6,L1S,KSV(1,10))
      
      ! anisotropic temperature factor coefficients
      CALL XSPRDD_new(unitcells(1)%adp_coefs(), KSV_new(11)%address)
      !CALL XSPRDD(6,L1A,KSV(1,11))
      
C--LOAD LIST 2
      CALL XFAL02
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--SPREAD THE SYMMETRY OPERATORS
      CALL XSPRDD(N2*MD2,L2,KSV_new(12)%address)
C--SPREAD THE INVERSE SYMMETRY OPERATORS
      CALL XSPRDD(N2I*MD2I,L2I,KSV_new(13)%address)
C--SPREAD THE NON-PRIMITIVE LATTIVE TRANSLATIONS
      CALL XSPRDD(MD2P*N2P,L2P,KSV_new(14)%address)
C--SET UP THE USEFUL CONSTANTS
      LN=2001
      IREC=2001
      I=KCHLFL(12)
C--ZERO THE ALLOCATED AREA
      CALL XZEROF(STORE(I),12)
      store(i:i+11)=0.0
      STORE(I)=PI
      STORE(I+2)=TWOPI
      STORE(I+4)=TWOPIS
      STORE(I+8)=DTR
      STORE(I+6)=RTD
      STORE(I+10)=0.0
C--SET UP THE ADDRESSES OF THE USEFUL CONSTANTS
      KSV_new(15)%address=I
      KSV_new(16)%address=I+2
      KSV_new(17)%address=I+4
      KSV_new(18)%address=I+6
      KSV_new(19)%address=I+8
      KSV_new(20)%address=I+10
C--CONVERT ALL THE STORED ADDRESSES TO RELATIVE ONES
      KSV_new(:)%address=KSV_new(:)%address-LC
C--SET UP THE INITIAL USER VARIABLE STACK
      LUV=LFL
      MDUV=LK2
      NUV=0
      MDFA=LK2
C--SET THE PRINT CATEGORY TO NONE INITIALLY
      ISTAT2=0
C -- GENERAL AND ERROR RETURN
9900  CONTINUE
      RETURN
      END
C
CODE FOR XSPRDD
      SUBROUTINE XSPRDD(N,L1,L2)
C--EXPAND A DATA RECORD TO ALLOW FOR STORAGE OF ITS VALUE AND ITS
C  FIRST DIFFERENTIAL.
C
C  N   NUMBER OF WORDS TO BE SPREAD.
C  L1  INITIAL ADDRESS OF THE DATA TO BE SPREAD.
C  L2  SET TO THE ADDRESS OF THE SPREAD DATA ON EXIT.
C
C--
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
C
C--SET THE RECORD TYPE
      IREC=2001
      L2=KCHLFL(N+N)
      K=L2
      J=L1
C--LOOP OVER EACH VALUE
      DO 1000 I=1,N
      STORE(K)=STORE(J)
      STORE(K+1)=0.
      K=K+2
      J=J+1
1000  CONTINUE
      RETURN
      END
      
      subroutine XSPRDD_new(data_record, new_address)      
      implicit none
      
      integer, intent(out) :: new_address
      real, dimension(:), intent(in) :: data_record
C--EXPAND A DATA RECORD TO ALLOW FOR STORAGE OF ITS VALUE AND ITS
C  FIRST DIFFERENTIAL.
C
C  N   NUMBER OF WORDS TO BE SPREAD.
C  L1  INITIAL ADDRESS OF THE DATA TO BE SPREAD.
C  L2  SET TO THE ADDRESS OF THE SPREAD DATA ON EXIT.
C
C--
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
      
      integer i, k
      integer, external :: kchlfl
C
C--SET THE RECORD TYPE
      IREC=2001
      new_address=KCHLFL(2*size(data_record))
      K=new_address
C--LOOP OVER EACH VALUE
      DO I=1,size(data_record)
        STORE(K)=data_record(I)
        STORE(K+1)=0.
        K=K+2
      end do 
      RETURN
      END
      
C
CODE FOR XSETCC
      SUBROUTINE XSETCC
C--SET THE COMPILER CONSTANTS BEFORE EACH PARSE PASS.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XCONST.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET UP THE BASE ADDRESS FOR THE CHAINS FROM THE BOTTOM OF CORE
      LCG=NFL
C--SET UP THE GENERAL OR CODE HEADER BLOCK
      ISTORE(LCG)=NOWT
      ISTORE(LCG+1)=NOWT
      ISTORE(LCG+2)=NOWT
      STORE(LCG+3)=1.0
      STORE(LCG+4)=1.0
      ISTORE(LCG+5)=-1
      MDCG=LCG
      MCG=LCG+6
      NCG=0
C--SET THE FLAGS TO INDICATE THAT NO ATOMS HAVE BEEN INPUT THUS FAR
      NCA=0
      LCA=NOWT
      MCA=LCA
      MDCA=NOWT
C--SET UP THE WORK STACK AND CONSTANT HEADER
      LCS=MCG
      ISTORE(LCS)=NOWT
      ISTORE(LCS+1)=6
      ISTORE(LCS+2)=LFL-LC
      ISTORE(LCS+4)=NOWT
      ISTORE(LCS+5)=0
C--SET UP THE WORK STACK CONTROL VARIABLES
      MCS=LCS+4
      MCG=MCG+6
C--SET UP THE NEXT FREE LOCATION IN THE WORK STACK IN 'MDCS'
      MDCS=ISTORE(LCS+2)+1
      NCS=0
      RETURN
      END
C
CODE FOR XOGCTD
      SUBROUTINE XOGCTD(IULN)
C--OUTPUT COMPILED CODE TO THE DISC
C
C  IULN  THE OUTPUT LIST TYPE.
C
C--
      INCLUDE 'ISTORE.INC'
      INCLUDE 'ICNTRL.INC'
      INCLUDE 'HEADES.INC'
      INCLUDE 'ICOM26.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XLST26.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCONST.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QCNTRL.INC'
      INCLUDE 'QLST26.INC'
C
      INCLUDE 'IDIM26.INC'
C--ALTER THE PARAMETER BLOCK ADDRESSES ON THE HEADER CHAIN
      MCA=LCA
C--CHECK FOR MORE HEADERS
1000  CONTINUE
      IF(MCA)1250,1250,1050
C--ANOTHER HEADER  -  PROCESS ITS PARAMETERS
1050  CONTINUE
      KA=MCA+6
      KB=KA
C--CHECK FOR MORE PARAMETERS
1100  CONTINUE
      IF(KA)1200,1200,1150
C--ALTER THE ADDRESS FOR REL. TO 'MCA' TO REL. TO 'LCG'
1150  CONTINUE
      ISTORE(KA)=ISTORE(KA)+MCA-LCG
      KB=KA
      KA=ISTORE(KA)+LCG
      GOTO 1100
C--MOVE TO THE NEXT HEADER BLOCK
1200  CONTINUE
      ISTORE(KB)=NOWT
      MCA=ISTORE(MCA)+LCG
      GOTO 1000
C--COMPUTE THE LENGTH OF THE WORK STACK
1250  CONTINUE
      ISTORE(LCS+3)=ISTORE(LCS+2)-MDCS+1
C--CONVERT THE HEADER BLOCK ADDRESSES TO RELATIVE VALUES
      LCA=LCA-LCG
      LCS=LCS-LCG
COMPUTE THE LENGTH OF THE CHAINED DATA AT THE BOTTOM OF STORE
      NCG=MCG-LCG
      N26CA=NCG
C--PRESERVE THE VALUE OF 'LCG' THAT WAS USED
      MCG=LCG
C--COMPUTE THE RELATIVE VALUE FOR 'LCG'  -  EQUALS ZERO
      LCG=0
C--OUTPUT THE COMMON BLOCK RECORD
      CALL XWDRTD(IULN,-101,L26D,M26D,N26D,ICOM26,IDIM26,0,IBUFF)
C--OUTPUT THE DATA
      CALL XUPF(L26CB,ICNTRL(1),MD26CB*N26CB)
C--UPDATE THE SIZE OF THE CODE RECORD
      CALL XUDRH(IULN,-102,0,N26CA)
C--WRITE THE RECORD HEADER TO DISC
      CALL XWDRTD(IULN,-102,L26D,M26D,N26D,ICOM26,IDIM26,0,IBUFF)
C--OUTPUT THE DATA
      CALL XUPF(L26CA,ISTORE(MCG),N26CA)
C--CHECK IF WE SHOULD PRINT THE GENERATED DATA
      IF(ISTAT2)1350,1350,1300
1300  CONTINUE
      CALL XPCLNN(LN)
      KA=MCG
      KB=LC
C--PRINT THE GENERATED CODE AND ATOM BLOCKS
      CALL XPRTOC(KA,KB)
1350  CONTINUE
      RETURN
      END
C
CODE FOR XTCO
      SUBROUTINE XTCO(IULN)
C--TERMINATE THE COMPILER OUTPUT FOR LIST TYPE 'IULN'
C
C--
      use lists1_mod, only: xrlind
      
      INCLUDE 'STORE.INC'
      INCLUDE 'ISTORE.INC'
      INCLUDE 'QSTORE.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLST26.INC'
C
C--READ DOWN THE DATA FOR THE OLD LIST OF THIS TYPE
      LN=IULN
      CALL XRLIND(LN,LSN,IADDL,IOLEN,IOW,NOS,ISTORE(NFL:NFL+1))
C--CHECK IF SUCH A LIST EXISTS
      IF(IADDL)1000,1000,1050
C--LIST DOES NOT EXIST
1000  CONTINUE
      CALL XWLIND(LN,MD26D,N26D,0,0)
      CALL XALTES(LN,1)
      GOTO 1150
C--LIST DOES EXIST  -  CHECK THE LENGTH
1050  CONTINUE
      IF(N26D-IOLEN)1100,1100,1000
C--MARK THE LIST FOR OVERWRITING
1100  CONTINUE
      CALL XMKOWF(LN,-1)
C--WRITE THE DETAILS
      CALL XWLIND(LN,IADDL,IOLEN,0,0)
C--COPY THE LIST
      CALL XCPYLN(MD26D,IADDL)
C--CLEAR THE FLAGS
      CALL XMKOWF(LN,0)
      CALL XALTES(LN,1)
C--AND NOW RETURN
1150  CONTINUE
      RETURN
      END
C
C
CODE FOR XPRTOC
      SUBROUTINE XPRTOC(IA,IB)
C--PRINT THE OUTPUT CODE
C
C  IA  BASE ADDRESS OF THE CODE INFORMATION (LCG)
C  IB  BASE ADDRESS OF WORK STACK (LC)
C
      CHARACTER*11  COPERATE(25)
C--
      INCLUDE 'ICNTRL.INC'
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XAPK.INC'
      INCLUDE 'XOPK.INC'
      INCLUDE 'XSCALE.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QCNTRL.INC'
C

C
C----- ISTORE (LCG + 1) OPERATIONS
      data coperate
     1 /'Define',  'Restrain', 'Distance',  'Mean D',
     1 'Delta D',  'Angle',  'Mean A',   'Delta A',
     1 'Vibration',  'executioN',  'Nolist',  'Uij',
     1 'Equate',  'Planar',  'sum',  'Form',
     1 'Average', 'Limit',  'Energy',  'Origin',
     1 'Rem', 'Same', 'Delu', 'Simu','Uknown(bug)'/
C
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1000)IA,IB,NFL,LFL,LC,ICNTRL
      ENDIF
1000  FORMAT(/' Listing of the code chain.',5X,'Chain base =',I8,5X,
     2 'Data base =',I8,5X,'Control block :',3I8/(1X,12I10))
C--PRINT THE WORK STACK CONSTANTS
      MCS=LCS+IA
      J=MCS+5
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1050)MCS,(ISTORE(I),I=MCS,J)
      ENDIF
1050  FORMAT(' Work stack header at',I8,'  :',6I10)
      MCS=ISTORE(MCS+4)+IA
1100  CONTINUE
      IF(MCS)1250,1250,1150
1150  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1200)MCS,ISTORE(MCS),ISTORE(MCS+1),ISTORE(MCS+2),
     2 STORE(MCS+2)
      ENDIF
1200  FORMAT(I10,'  :',3I10,E20.10)
      MCS=ISTORE(MCS)+IA
      GOTO 1100
C
C--PRINT THE PARAMETER STACK
1250  CONTINUE
      MCA=LCA+IA
1300  CONTINUE
      IF(MCA)2100,2100,1350
1350  CONTINUE
      MDCA=MCA+16
C--FIND THE TYPE OF HEADER BLOCK
C----- NOTE THE '+1' TO MAKE ROOM FOR ATOMS
      KA=ISTORE(MCA+1)-ISTORE(MCA+1)/1024*1024+1
C--CHECK IF THIS IS AN ATOM HEADER OR AN OVERALL PARAMETER
      J=MCA+2
      IF(KA-1)1500,1500,1400
C--OVERALL PARAMETER
1400  CONTINUE
      K=MCA+12
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1450)MCA,(ISTORE(I),I=MCA,J),ISTORE(MCA+5),
     2 ISTORE(MCA+6),(ISTORE(I),I=K,MDCA)
      ENDIF
1450  FORMAT(' Overall parameter header at',I8,'  :',3I10,10X,
     2 2I10/39X,5I10)
      GOTO 1600
C--THIS IS AN ATOM HEADER
1500  CONTINUE
      K=MCA+5
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1550)MCA,(ISTORE(I),I=MCA,J),STORE(MCA+3),(ISTORE(I),
     2 I=K,MDCA)
      ENDIF
      WRITE(NCAWU,1550)MCA,(ISTORE(I),I=MCA,J),STORE(MCA+3)
1550  FORMAT(' Atom header at',I8,'  :',2I10,5X,A4,F6.0,5X,2I10,5X,
     2 5I5/26X,5I10)
C--PRINT THE PARAMETER STACK INFORMATION
1600  CONTINUE
      J=ISTORE(MCA+6)+IA
1650  CONTINUE
      IF(J)2050,2050,1700
1700  CONTINUE
      L=ISTORE(J+1)
C--BRANCH ON THE TYPE OF HEADER
      GOTO (1800, 1950, 2000, 2000, 2000, 2000, 2000, 2000, 1750), KA
1750  CONTINUE
      WRITE ( CMON,1755)KA
      CALL XPRVDU(NCVDU, 1,0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') trim(CMON(1))
1755  FORMAT(' Illegal header type ',I10)
      CALL XERHND ( IERCAT )
C--ATOMIC PARAMETERS TO BE PRINTED
1800  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1850)J,ISTORE(J),ISTORE(J+1),(ICOORD(M,L),M=1,NWKA)
      ENDIF
1850  FORMAT(I10,'  :',2I10,5X,5A4)
C--PASS TO THE NEXT PARAMETER
1900  CONTINUE
      J=ISTORE(J)+IA
      GOTO 1650
C--AN OVERALL PARAMETER
1950  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1850)J,ISTORE(J),ISTORE(J+1),(KVP(M,L),M=1,NWKO)
      ENDIF
      GOTO 1900
C--A LAYER SCALE OR AN ELEMENT SCALE TO BE PRINTED
2000  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1850)J,ISTORE(J),ISTORE(J+1),(KSCAL(M,KA),M=1,NWSC)
      ENDIF
      GOTO 1900
C--PASS ONTO THE NEXT HEADER BLOCK
2050  CONTINUE
      MCA=ISTORE(MCA)+IA
      GOTO 1300
C
C--PRINT THE INSTRUCTION STACK
2100  CONTINUE
      MCG=LCG+IA
      if(abs(istore(mcg+1))>size(coperate) .or. 
     1  abs(istore(mcg+1))<1) then
        it=25
      else
        it=abs(istore(mcg+1))
      end if
      IF (ISSPRT .EQ. 0) THEN
C     DJWsep2011. The asymmetric restraints have -ve keys
c      WRITE(NCWU,2150)MCG,ISTORE(MCG+1),coperate(istore(mcg+1))
      WRITE(NCWU,2150)MCG,ISTORE(MCG+1),coperate(it)
      ENDIF
c      WRITE(NCAWU,2150)MCG,ISTORE(MCG+1),coperate(istore(mcg+1))
      WRITE(NCAWU,2150)MCG,ISTORE(MCG+1),coperate(it)
2150  FORMAT(' Function at',I8,'  :',I5, 3x,a)
      MCG=ISTORE(MCG)+IA
2200  CONTINUE
      IF(MCG)2350,2350,2250
2250  CONTINUE
      L=MCG+4
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2300)MCG,(ISTORE(I),I=MCG,L)
      ENDIF
2300  FORMAT(I10,'  :',5I10)
      MCG=ISTORE(MCG)+IA
      GOTO 2200
C
C--EXIT
2350  CONTINUE
      RETURN
      END
C
CODE FOR KFMDEF
      FUNCTION KFMDEF(IN)
C--FORM THE CODE NECESSARY FOR A 'DEFINE'
C
C  IN  DUMMY ARGUMENT
C
C--RETURN VALUES OF 'KFMDEF' ARE :
C
C  -1  ERROR(S).
C   0  OKAY.
C
C--THE VARIABLE IS ENTERED IN THE USER VARIABLE STACK, WHICH IS
C  AT THE TOP OF THE STORE. AFTER EACH ENTRY IN THE STACK, 'LFL'
C  IS ALTERED TO REFLECT THE BASE ADDRESS OF THE WORK STACK FOR
C  THE NEXT INSTRUCTION. THE FORMAT OF THE ENTRY IN THE USER VARIABLE
C  STACK IS :
C
C  0  VALUE
C  1  ADDR. REL. TO LC
C  2  ALPHA-NUMERIC IDENTIFICATION
C  .
C
C--FORMAT OF THE HEADER BLOCK AT 'LCG' :
C
C  0  LINK TO FIRST INSTRUCTION OR 'NOWT'
C  1  VALUE ASSOCIATED WITH DEFINE INSTRUCTION
C  2  ADDR. REL. TO LC AT WHICH TO STORE THE 'DEFINED' VALUE
C
C--
      INCLUDE 'ISTORE.INC'
      INCLUDE 'KCHAR.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XPARSE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QCHAR.INC'
C
C--CHECK THAT THE CARD IS NOT BLANK
      IF(ME)1000,1000,1100
1000  CONTINUE
      CALL XPCLNN(LN)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1050)
      ENDIF
1050  FORMAT(/' ''DEFINE'' format error')
      LEF=LEF+1
      GOTO 1900
1100  CONTINUE
      KFMDEF=0
C--CHECK THE TYPE OF THE FIRST OPERAND
      IF(ISTORE(MF))1250,1150,1200
C--NUMBER  -  ILLEGAL
1150  CONTINUE
      CALL XILNUM(ISTORE(MF+1))
      GOTO 1900
C--OPERATOR  -  ILLEGAL
1200  CONTINUE
      CALL XILOP(ISTORE(MF+1))
      GOTO 1900
C--VARIABLE TO BE ASSIGNED THE NAME OF THIS USER VARIABLE
1250  CONTINUE
      IF (NUV .LE. 0 ) GOTO 1300
      MUV=KCOMP(LK,ISTORE(MF+2),ISTORE(LUV+2),NUV,MDUV)
C--CHECK IF THIS VARIABLE ALREADY HAS A SLOT
      IF(MUV)1300,1300,1500
C--NO PREVIOUS ENTRY
1300  CONTINUE
      LFL=LFL-MDUV
C--CHECK THE CORE ALLOCATION
      IF(LFL-MCG)1350,1350,1400
C--NOT ENOUGH CORE
1350  CONTINUE
      CALL XCSO(ISTORE(MF+1))
      GOTO 1900
C--SET THE REST OF THE POINTERS
1400  CONTINUE
      MDCS=MDCS-MDUV
      MUV=-(LFL+1)
      I=-MUV+2
      J=MF+2
C--MOVE THE NAME
      DO 1450 K=1,LK
      ISTORE(I)=ISTORE(J)
      I=I+1
      J=J+1
1450  CONTINUE
      GOTO 1550
C--THIS NAME IS ALREADY PRESENT
1500  CONTINUE
      MUV=(MUV-1)*MDUV+LUV
C--CHECK FOR THE '=' SIGN
1550  CONTINUE
      ME=ME-1
      MF=MF+LK2
      IF(KOP(9))1600,1700,1650
C--ERROR BECAUSE THE '=' IS NOT PRESENT
1600  CONTINUE
      MF=MF-LK2
1650  CONTINUE
      CALL XMISOP(KCHAR(9),ISTORE(MF+1))
      GOTO 1900
C--PRODUCE THE NECESSARY CODE
1700  CONTINUE
      IF(KPARSE(IN))1900,1750,1900
C--CHECK ON THE TYPE OF VARIABLE BEING INSERTED
1750  CONTINUE
      IF(MUV)1800,1850,1850
C--THIS IS A NEW VALUE  -  SET THE POINTERS
1800  CONTINUE
      MUV=-MUV
      LUV=MUV
      NUV=NUV+1
      ISTORE(MUV)=0
      ISTORE(MUV+1)=MUV-LC
C--SET THE ADDRESS OF THE DEFINED VALUE
1850  CONTINUE
      ISTORE(LCG+2)=MUV-LC
      GOTO 1950
C--ERROR DURINF PROCESSING
1900  CONTINUE
      KFMDEF=-1
1950  CONTINUE
      RETURN
      END
C
CODE FOR KPARSE
      FUNCTION KPARSE(IN)
      use xparse_mod
C--BASIC COMPILER PARSING ROUTINES  -  OUTPUT CONSISTS OF THE GENERATED
C  CODE
C
C  IN  DUMMY ARGUMENT
C
C--THIS ROUTINE USES AND SETS WHERE NECESSARY THE FOLLOWING VARIABLES :
C
C  LK      THE LENGTH OF THE STORED ARGUMENT DETAILS IN WORDS.
C  LK1     THE LENGTH OF THE COMPLETE ARGUMENT IN WORDS MINUS ONE.
C  LK2     THE LENGTH OF THE COMPLETE ARGUMENT PRODUCED BY THE LEXICAL
C          SCANNER. THE FORMAT OF THIS IS AS FOLLOWS :
C
C          0  THE ARGUMENT TYPE :
C
C             -1  A VARIABLE, STORED AS 'LK' WORDS OF A4 CHARACTER DATA.
C              0  A NUMBER, WHOSE VALUE IS GIVEN IN WORD 2.
C             >0  AN OPERATOR, WHOSE TYPE IS GIVEN BY THE NUMBER IN THIS
C                 LOCATION. ALLOWED VALUES ARE :
C
C                 1  +
C                 2  -
C                 3  *
C                 4  /
C                 5  **
C                 6  (
C                 7  )
C                 8  ,
C                 9  =
C
C          1  THE CHARACTER NUMBER ON THE CARD WHERE THIS ARGUMENT ENDED
C          2  THE FIRST WORD OF THE ARGUMENT. FOR A NUMBER THIS IS THE
C             VALUE, WHILE FOR THE OTHERS IT IS THE START OF OF 'LK' WOR
C             CONTAINING THE ARGUMENT IN CHARACTER FORM.
C          3  THE SECOND WORD OF THE ARGUMENT.
C
C  NWCARD  THE NUMBER OF WORDS PER CARD WHEN IT IS STORED IN A4 FORMAT.
C  LARG    THE DISC ADDRESS OF THENEXT DATA RECORD HEADER BLOCK TO
C          BE PROCESSED.
C  MARG    THE DISC ADDRESS OF THE LAST DATA RECORD HEADER BLOCK
C          LOOKED AT BY 'KLDNLR'.
C  MDARG   THE NUMBER OF WORDS PER ARGUMENT, EQUAL TO 'LK2'.
C  NARG    THE NUMBER OF ARGUMENTS CURRENTLY IN CORE, EQUAL TO 'ME'.
C  MA      THE DISC ADDRESS OF THE NEXT DATA RECORD HEADER BLOCK TO
C          BE PROCESSED BY THE PRINT ROUTINE 'XPCLNN'.
C  MB      THE DISC ADDRESS OF THE LAST DATA RECORD HEADER BLOCK
C          PROCESSED BY THE PRINT ROUTINE 'XPCLNN'.
C  MC      THE NUMBER OF CARDS PRINTED MINUS ONE.
C  MD      THE ADDRESS IN CORE OF THE CURRENT SET OF ARGUMENTS.
C  ME      THE NUMBER OF ARGUMENTS ON THE CURRENT CARD.
C  MF      THE ADDRESS IN CORE OF THE CURREN ARGUMENT.
C  MG      THE FUNCTION OF THIS CARD, IN THE RANGE 1 TO N.
C
C  MQ      USED IN ATOM GENERATION
C  MR      0, UNLESS AN '(' HAS BEEN FOUND
C  MS      0, UNLESS AN ')' HAS BEEN FOUND
C  MT      WORK SPACE
C  MU      TOP OPERATOR STACK POINTER
C  MV      TOP OPERAND STACK POINTER
C  MW      NEXT TO TOP OPERATOR STACK POINTER
C  MX      OPERATOR STACK STEP
C  MY      OPERAND STACK STEP
C   Z      USED FOR NUMBERS
C
C--RETURNS SET :
C
C  -1  ERROR DURING THE PARSE.
C   0  PARSE COMPLETED OKAY.
C
C--THE FORMAT OF THE OPERAND STACK :
C
C  0  OPERAND CHECK VALUE
C  1  OPERAND POSITION IN THE ACCUMULATION ROUTINES
C
C--THE PARSE IS DONE IN THE ORDER :
C
C  1  '('
C  2  OPERAND
C  3  OPERATOR
C  4  AN ERROR  -  NO SENSIBLE PARSE FOUND.
C
C--THE LEXICAL SCANNER CHECKS THAT NO LINE ENDS WITH AN OPERATOR
C
C  '(' OR 'START' MAY BE FOLLOWED BY A '+' OR A '-' , WHEN A
C  DUMMY OPERAND OF 0.0 IS INSERTED
C
C--
      INCLUDE 'ISTORE.INC'
      INCLUDE 'KCHAR.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XPARSE.INC'
      INCLUDE 'XCONST.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QCHAR.INC'
C
C--SET THE INITIAL STACK ADDRESSES
      MX=-4
      MY=-4
      MU=LFL+MX
      MV=LFL+2
      ISTORE(MU)=IOPTS
      ISTORE(MU+1)=IOPTS
C--CHECK THAT THERE IS SOME CODE TO PROCESS
      IF(ME)1000,1000,1950
1000  CONTINUE
      CALL XPCLNN(LN)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1050)
      ENDIF
1050  FORMAT(/,' No code found')
      GOTO 2550
C--CHECK FOR '('
1100  CONTINUE
      MR=-1
      MS=0
      MT=6
      IF(KOP(6))2450,1600,1150
C--CHECK FOR AN OPERAND OR NUMBER
1150  CONTINUE
      MR=0
      IF(KNUVAR(IN))2550,1200,1100
C--CHECK THE POSITION ON THE CARD
1200  CONTINUE
      MS=0
      IF(ME)2450,2450,1250
C--CHECK IF THE NEXT INFORMATION IS AN OPERATOR
1250  CONTINUE
      IF(ISTORE(MF))1300,1300,1350
C--NOT AN OPERATOR  -  ERROR
1300  CONTINUE
      CALL XMISOP(IQ,ISTORE(MF+1))
      GOTO 2550
C--CHECK IF THE OPERATOR IS AN '('  -  IF SO ERROR
1350  CONTINUE
      IF(ISTORE(MF)-6)1550,1400,1450
1400  CONTINUE
      CALL XILOP(ISTORE(MF+1))
      GOTO 2550
C--CHECK IF THE OPERATOR IS AN ')'  -  IF SO FLAG IT
1450  CONTINUE
      IF(ISTORE(MF)-7)1400,1500,1400
C--OPERATOR IS A ')'
1500  CONTINUE
      MS=-1
1550  CONTINUE
C--SET UP THE OPERATOR IN 'MT' AND UPDATE 'ME' AND 'MF'
      MT=ISTORE(MF)
      ME=ME-1
      MF=MF+LK2
C--INSERT THE OPERATOR IN THE OPERAND STACK
1600  CONTINUE
      MU=MU+MX
      ISTORE(MU)=MT-1
      ISTORE(MU+1)=MT
C--BEGIN COMPARING THE TOP TWO OPERATORS
1650  CONTINUE
      IF(ISTORE(MU)-IOPTS)1700,1800,1700
1700  CONTINUE
      MW=MU-MX
      I=ISTORE(MU)*LOPT+ISTORE(MW)
      I=IOPT(I+1)
C--BRANCH ON THE STORED FUNCTION
      GOTO(1800,2400,2150,2100,2500,1750),I
C1750  STOP74
1750  CALL GUEXIT(74)
C--CONTINUE ADDING TO THE STACKS
1800  CONTINUE
      IF(MS)1200,1850,1850
C--CHECK FOR '('
1850  CONTINUE
      IF(MR)1900,1100,1100
C--CHECK THAT THERE IS MORE ON THIS CARD
1900  CONTINUE
      IF(ME)2450,2450,1950
C--CHECK FOR '+'
1950  CONTINUE
      IF(ISTORE(MF)-1)2000,2050,2000
C--CHECK FOR '-'
2000  CONTINUE
      IF(ISTORE(MF)-2)1100,2050,1100
2050  CONTINUE
      MV=MV+MY
      ISTORE(MV)=KSV_new(20)%address
      MR=0
      GOTO 1200
C--ERROR
2100  CONTINUE
      MF=MF-LK2
      GOTO 1400
C--CODE GENERATION ROUTINES
C
C--CHECK IF THE OPERATOR IS A SYSTEM FUNCTION
2150  CONTINUE
      IF(ISTORE(MW)-IOPTSF)2250,2200,2250
C--FIDDLE THE OPERAND ADDRESSES
2200  CONTINUE
      MV=MV+MY
C--CHECK THAT THE STORE IS SUFFICIENT
2250  CONTINUE
      IF(MIN0(MCG,MU,MV)-MCG)2300,2350,2300
2300  CONTINUE
      CALL XCSO(ISTORE(MF+1))
      GOTO 2550
C--REMOVE THE CODE FROM THE STACK AND TRANSFER TO THE OUTPUT AREA
2350  CONTINUE
      ISTORE(MDCG)=MCG-LCG
C--CLAIM A NEW CODE AREA
      MDCG=MCG
      ISTORE(MDCG)=NOWT
      ISTORE(MDCG+1)=ISTORE(MW+1)
      ISTORE(MDCG+3)=ISTORE(MV)
      MV=MV-MY
      ISTORE(MDCG+2)=ISTORE(MV)
      MDCS=MDCS-2
      MCG=MCG+5
      ISTORE(MDCG+4)=MDCS
C--REARRANGE THE STACKS
      ISTORE(MV)=MDCS
      ISTORE(MW)=ISTORE(MU)
      ISTORE(MW+1)=ISTORE(MU+1)
      MU=MU-MX
      GOTO 1650
C--REMOVE THE TOP TWO OPERANDS BECAUSE THEY ARE EQUAL
2400  CONTINUE
      MU=MU-MX-MX
      GOTO 1650
C--END OF THE CARD IMAGE
2450  CONTINUE
      MU=MU+MX
      ISTORE(MU)=IOPTE
      ISTORE(MU+1)=IOPTE
      GOTO 1650
C
C--NORMAL RETURN
2500  CONTINUE
      ISTORE(MDCG)=MCG-LCG
      ISTORE(MCG)=NOWT
      ISTORE(MCG+1)=ISTOP
      ISTORE(MCG+2)=0
      ISTORE(MCG+3)=0
      ISTORE(MCG+4)=ISTORE(MV)
      MCG=MCG+5
      KPARSE=0
C--CHECK THE CORE ALLOCATION
      IF(LFL-MCG)2300,2600,2600
C
C--ERROR RETURN
2550  CONTINUE
      KPARSE=-1
2600  RETURN
      END
C
CODE FOR KNUVAR
      FUNCTION KNUVAR(IN)
      use xparse_mod
C--PROCESS A CARD IMAGE AND LOOK FOR AN NUMBER, OR OPERAND
C
C  IN  DUMMY ARGUMENT
C
C--THE SEARCH IS MADE IN THE ORDER :
C
C  1  NUMBER
C  2  SYSTEM FUNCTION
C  3  USER DEFINED VARIABLES
C  4  SYSTEM DEFINED VARIABLES
C  5  DEFAULT IS AN ATOM PARAMETER
C
C--RETURN VALUES ARE :
C
C  -1  ERROR
C   0  NUMBER OR VARIABLES
C   1  FUNCTION
C
C--DOES NOT CHECK FOR END OF CARD AT THE START
C
C--
      INCLUDE 'ISTORE.INC'
      INCLUDE 'KCHAR.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XPARSE.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XAPK.INC'
      INCLUDE 'XOPK.INC'
      INCLUDE 'XSCALE.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QCHAR.INC'
      
      integer kshape
      
      IDWZAP = IN
C
      KNUVAR=0
      MV=MV+MY
C--CHECK FOR A NUMBER
      IF(KSYNUM(Z))1150,1100,1050
C--MISPLACED OPERATORS
1050  CONTINUE
      CALL XILOP(ISTORE(MF+1))
      GOTO 1350
C--INSERT THE NUMBER IN THE WORK STACK AND IN THE OPERAND STACK
1100  CONTINUE
      ISTORE(MV)=KACTWS(Z)
      GOTO 1600
C
C--CHECK AGAINST THE SYSTEM DEFINED FUNCTIONS
1150  CONTINUE
      I=KCOMP(NWSF,ISTORE(MF+2),KSYSF,NSF,LSF)
      IF(I)1500,1500,1200
C--INSERT THE SYSTEM FUNCTION
1200  CONTINUE
      MU=MU+MX
      ISTORE(MU)=IOPTSF
      ISTORE(MU+1)=IOPL+I
      ME=ME-1
      MF=MF+LK2
C--CHECK THAT FOLLOWING THE FUNCTION NAME IS AN '('
      IF(KOP(6))1250,1450,1300
C--NO '('
1250  CONTINUE
      MF=MF-LK2
1300  CONTINUE
      CALL XMISOP(KCHAR(6),ISTORE(MF+1))
C--ERROR EXIT
1350  CONTINUE
      MV=MV-MY
      KNUVAR=-1
1400  CONTINUE
      RETURN
C--BACK TRACK ONE OPERAND AND RESET MV
1450  CONTINUE
      ME=ME+1
      MF=MF-LK2
      MV=MV-MY
      KNUVAR=1
      GOTO 1400
C
C--CHECK AGAINST USER DEFINED VARIABLES
1500  CONTINUE
      IF(NUV)1650,1650,1520
1520  CONTINUE
      I=KCOMP(LK,ISTORE(MF+2),ISTORE(LUV+2),NUV,MDUV)
      IF(I)1650,1650,1550
C--INSERT THE ADDRESS IN THE OPERAND STACK
1550  CONTINUE
      I=(I-1)*MDUV+LUV
      ISTORE(MV)=ISTORE(I+1)
1600  CONTINUE
      ME=ME-1
      MF=MF+LK2
      GOTO 1400
C
C--CHECK THE ARGUMENT AGAINST THE SYSTEM DEFINED VARIABLES
1650  CONTINUE
      I=KCOMP(NWSV,ISTORE(MF+2),KSV(3,1),NSV,LSV)
      IF(I)2400,2400,1700
C--CHECK IF THE VARIABLE IS DIMENSIONED
1700  CONTINUE
      ISTORE(MV)=KSV_new(I)%address
      ME=ME-1
      MF=MF+LK2
      !J=KSV(2,I)
      J=0
      kshape=size(KSV_new(I)%kshape)
      IF(kshape)2050,1750,1850
C--CHECK THAT THE FOLLOWING SYMBOL IS NOT '('
1750  CONTINUE
      IF(ME)1400,1400,1800
1800  CONTINUE
      IF(ISTORE(MF)-6)1400,1050,1400
C--START OF THE LOOP TO FIND THE DIMENSIONS AND CHECK THEM
1850  CONTINUE
C--LOOK FOR THE '('
      IF(KOP(6))2000,1900,2050
1900  CONTINUE
      N=kshape
C--CHECK THAT THE DIMENSION IS NUMERIC
1950  CONTINUE
      IF(KSYNUM(Z))2050,2150,2050
2000  CONTINUE
      MF=MF-LK2
C--ERROR IN DEFINING DIMENSIONS
2050  CONTINUE
      CALL XPCLNN(LN)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2100)ISTORE(MF+1)
      ENDIF
2100  FORMAT(/,' Error in variable dimensioning at about column',I5)
      GOTO 1350
C--CHECK THE INPUT DIMENSION
2150  CONTINUE
      ME=ME-1
      MF=MF+LK2
      M=NINT(Z)-1
      IF(M)2000,2200,2200
2200  CONTINUE
      J=J+1
      IF(M-KSV_new(I)%kshape(J))2250,2000,2000
C--CHECK IF THIS IS THE LAST DIMENSION
2250  CONTINUE
      M=M+M
      N=N-1
      IF(N)2000,2350,2300
C--INCREMENT AND GO ROUND FOR MORE
2300  CONTINUE
      ISTORE(MV)=ISTORE(MV)+KSV_new(I)%kshape(J)*M
C--CHECK FOR THE ','
      IF(KOP(8))2000,1950,2050
C--LAST DIMENSION
2350  CONTINUE
      ISTORE(MV)=ISTORE(MV)+M
C--CHECK FOR THE TERMINATING ')'
      IF(KOP(7))2000,1400,2050
C
C--CHECK IF THIS IS AN OVERALL PARAMETER
2400  CONTINUE
      MQ=MCG
      K=KOVPMG(I)
C--CHECK THE REPLY
      IF(K)2450,2600,2500
C--ERROR IN DEFINITION OF SCALE
2450  CONTINUE
      CALL XSFDE(ISTORE(MF+1))
      GOTO 1350
C--CHECK THAT ONLY ONE SCALE HAS BEEN DEFINED
2500  CONTINUE
      IF(ISTORE(MQ+2))2450,2450,2550
C--SET THE FLAGS
2550  CONTINUE
      KE=ISTORE(MQ+1)
      KA=ISTORE(MQ+2)
      KB=KA
      KF=1
      KG=0
      GOTO 2700
C
C--ASSUMED TO BE AN ATOM  -  GENERATE THE HEADER BLOCK
2600  CONTINUE
      KE=0
      KF=NKA
      KG=2
      MQ=MCG
      K=KATOMG(IDWZAP)
C--CHECK IF AN ATOM HAS BEEN FOUND
      IF(K)2650,2650,2700
2650  CONTINUE
      CALL XADE(ISTORE(MF+1))
      GOTO 1350
C
C--GENERAL ROUTINE TO INSERT THE HEADER IF NECESSARY AND ADD THE VARIABL
C  STACK.
C
C--THE FOLLOWING VARIABLES ARE USED :
C
C  KA  THE FIRST PARAMETER TO BE INSERTED IN ITS GROUP  (STARTING FROM 1
C  KB  THE LAST PARAMETER IN THE GROUP TO INCLUDE
C  KE  THE TYPE OF HEADER BLOCK
C      0  ATOM
C      1  OVERALL PARAMETER
C      2  LAYER SCALE
C      3  ELEMENT SCALE
C  KF  THE NUMBER OF PARAMETERS THAT REQUIRE WORK SPACE FOR THIS TYPE OF
C  KG  NUMBER OF WORDS BY WHICH TO MULTIPLY THE PARAMETER NUMBER
C      TO FIND ITS ADDRESS REL. TO THE ADDRESS STORED IN WORD 16.
C      (2 FOR AN ATOM, AND 0 FOR AN OVERALL PARAMETER, WHICH HAS WORD 16
C       POINTING TO THE PARAMETER OF INTEREST).
C
C  K   THE NEXT FREE LOCATION IN THE STACK IF THE DUMMY HEADER IS ADDED
C  L   ADDR. AS FOUND ON THE CARD OF THE PARAMETER HEADER TO ADD
C  M   ADDR. IN THE ATOM STACK OF THE PARAMETER HEADER TO ADD
C  N   ADDR. OF THE LAST PARAMETER HEADER
C
C--CHECK THAT THE STORE HAS NOT CLASHED
2700  CONTINUE
      IF(K-MIN0(K,MU,MV))2750,2800,2750
2750  CONTINUE
      CALL XCSO(ISTORE(MF+1))
      GOTO 1350
C--CHECK THAT ONLY ONE PARAMETER HAS BEEN SPECIFIED
2800  CONTINUE
      IF(ISTORE(MCG+5)-1)2650,2850,2650
C--BEGIN SEARCH THROUGH THE PARAMETER STACK FOR THIS ATOM OR OVERALL PAR
2850  CONTINUE
      MCA=LCA
      MDCA=0
C--CHECK IF THERE ARE MORE HEADER BLOCKS LEFT
2900  CONTINUE
      IF(MCA)3550,3550,2950
C--CHECK ON THE TYPE OF THIS HEADER BLOCK
2950  CONTINUE
      IF(ISTORE(MCA+1)-KE)3500,3000,3500
C--THIS HEADER IS OF THE RIGHT TYPE  -  ARE WE SEARCHING FOR AN ATOM
3000  CONTINUE
      IF(KE)3050,3100,3050
C--WE ARE SEARCHING FOR AN OVERALL PARAMETER  -  HAVE WE FOUND THE ONE W
3050  CONTINUE
      IF(ISTORE(MCA+2)-KA)3500,3350,3500
C--WE ARE SEARCHING FOR AN ATOM  -  COMPARE THE 'TYPE'
3100  CONTINUE
      IF(KCOMP(1,ISTORE(MCA+2),ISTORE(MCG+2),1,1))3500,3500,3150
C--COMPARE THE SERIAL NUMBERS
3150  CONTINUE
      IF(ABS(STORE(MCA+3)-STORE(MCG+3))-0.0005)3200,3500,3500
C--CHECK THE SYMMETRY POSITIONS
3200  CONTINUE
      L=MCA+7
      M=MCG+7
      DO 3300 I=1,5
      IF(ISTORE(L)-ISTORE(M))3500,3250,3500
3250  CONTINUE
      L=L+1
      M=M+1
3300  CONTINUE
C--INSERT THE PARAMETER(S) IN THE HEADER BLOCK AS NECESSARY
3350  CONTINUE
      L=ISTORE(MQ+6)+MQ
C--MAKE SURE THAT THIS PARAMETER AND RELATED ONES ARE PRESENT
      M=KPARIN(MCA,1,ISTORE(L+1),MIN0(MU,MV))
      IF(M)2750,2750,3450
C--ADD THE ADDRESS TO THE OPERAND STACK
3450  CONTINUE
      ISTORE(MV)=ISTORE(MCA+16)+(ISTORE(M+1)-1)*KG
      GOTO 1600
C--NOT THE CORRECT HEADER  -  MOVE ONTO THE NEXT ONE
3500  CONTINUE
      MDCA=MCA
      MCA=ISTORE(MCA)+LCG
      GOTO 2900
C--HEADER BLOCK NOT IN THE STACK , SO INCLUDE IT
3550  CONTINUE
C--LINK THE NEW HEADER BLOCK
      ISTORE(MCG)=NOWT
      ISTORE(MCG+1)=KE
      MCA=MDCA
      IF(KPARCH(MCA,K,MIN0(MU,MV),KF))2750,3350,3350
      END
C
CODE FOR KPARCH
      FUNCTION KPARCH(ILAST,NEWADD,LIMIT,NPARAM)
C--ADD A NEW ATOM OR PARAMETER HEADER BLOCK ONTO THE CORRECT CHAIN
C
C  ILAST   THE ADDRESS OF THE PREVIOUS HEADER BLOCK  -  UPDATED ON RETUR
C  NEWADD  THE ADDRESS OF THE NEXT FREE LOCATION  -  USED TO UPDATE 'MCG
C  LIMIT   THE MAXIMUM STORE LIMIT.
C  NPARAM  THE NUMBER OF PARAMETERS FOR WHICH SPACE MUST BE ALLOCATED IN
C          THE WORK STACK.
C
C--THE HEADER IS ASSUMED TO BE STORED AT 'MQ', AND 'MCG' IS UPDATED TO
C  THE MAXIMUM OF ITS OLD VALUE AND 'NEWADD'.
C
C--'ILAST' IS SET TO THE ADDRESS OF PREVIOUS HEADER BLOCK ON ENTRY, AND
C  GIVES THE ADDRESS OF THE ONE INSERTED ON EXIT.
C
C--RETURN VALUES OF 'KPARCH' ARE :
C
C  -1  INSUFFICIENT CORE AVAIVABLE.
C   0  BLOCK ADDED SUCCESSFULLY.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XCNTRL.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CHECK IF THIS IS THE FIRST HEADER BLOCK
      IF(LCA)1000,1000,1050
C--THIS IS THE FIRST HEADER BLOCK
1000  CONTINUE
      LCA=MQ
      ILAST=MQ
      GOTO 1100
C--THIS IS NOT THE FIRST HEADER BLOCK  -  LINK IT INTO THE CHAIN
1050  CONTINUE
      ISTORE(ILAST)=MQ-LCG
      ILAST=MQ
C--CHECK THE CORE OVERFLOW
1100  CONTINUE
      MCG=MAX0(MCG,NEWADD)
      IF(MCG-LIMIT)1250,1150,1150
C--NOT ENOUGH SPACE AVAILABLE
1150  CONTINUE
      KPARCH=-1
1200  CONTINUE
      RETURN
C--ALLOCATE SPACE IN THE WORK STACK
1250  CONTINUE
      MDCS=MDCS-NPARAM
      ISTORE(ILAST+15)=MDCS
      MDCS=MDCS-NPARAM
      ISTORE(ILAST+16)=MDCS
C--UPDATE THE NUMBER OF ATOMS USED
      NCA=NCA+1
      KPARCH=0
      GOTO 1200
      END
C
CODE FOR KPARIN
      FUNCTION KPARIN(IADD,NPAR,IFRPAR,LIMIT)
C--ADD A SELECTED PARAMETER OR GROUP OF PARAMETERS TO A HEADER BLOCK.
C
C  IADD    THE ADDRESS OF THE HEADER BLOCK.
C  NPAR    THE NUMBER OF PARAMETERS TO BE ADDED.
C  IFRPAR  THE NUMBER OF THE FIRST PARAMETER TO ADD (1 TO N).
C  LIMIT   THE MAXIMUM CORE ADDRESS FOR CHECKING PURPOSES.
C
C--RETURN VALUES FOR 'KPARIN' ARE :
C
C  -1  CORE OVERFLOW.
C   0  OVERALL PARAMETER GROUP CONTAINIG 'SCALES'  -  NO PROCESSING DONE
C  >0  ADDRESS OF THE BLOCK FOR THE FIRST PARAMETER.
C
C--IF THE HEADER BLOCK INDICATES AN ATOM, THE INCLUSION OF A COORDINATE
C  FORCES ALL THE POSITIONAL COORDINATES TO BE INCLUDED, WHILE THE
C  INCLUSION OF AN ANISOTROPIC TEMPERATURE FACTOR FORCES ALL THE
C  ANISOTROPIC TEMPERATURE FACTORS TO BE INCLUDED.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XCONST.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--FIND THE TYPE OF THE CURRENT HEADER BLOCK
      I=ISTORE(IADD+1)-ISTORE(IADD+1)/1024*1024
      J=NPAR
      K=IFRPAR
      KPARIN=0
C--CHECK IF THERE ARE MORE PARAMETERS TO INCLUDE
1000  CONTINUE
      IF(J)1800,1800,1050
C--MORE PARAMETERS  -  CHECK IF THIS IS AN OVERALL PARAMETER HEADER BLOC
1050  CONTINUE
      IF(I)1350,1150,1100
C--THIS IS AN OVERALL PARAMETER  -  CHECK FOR A GROUP OF PARAMETERS
1100  CONTINUE
      IF(ISTORE(IADD+2))1800,1800,1350
C--THIS IS AN ATOM  -  CHECK THE TYPE OF PARAMETER INDICATED
1150  CONTINUE
      IF(K-5)1350,1250,1200
C--COORDINATE OR ANISOTROPIC TEMPERATURE FACTOR  -  CHECK AGAIN
1200  CONTINUE
      IF(K-7)1250,1250,1300
C--POSITIONAL COORDINATE  -  INSERT ALL THREE
1250  CONTINUE
      KA=5
      KB=7
      J=J-8+K
      K=8
      GOTO 1400
C--THIS IS AN ANISOTROPIC TEMPERATURE FACTOR  -  INSERT ALL SIX
1300  CONTINUE
      KA=8
      KB=13
      J=0
      GOTO 1400
C--THIS IS JUST A SIMPLE PARAMETER
1350  CONTINUE
      KA=K
      KB=K
      J=J-1
      K=K+1
C--FIND THE ADDRESS OF THE PARAMETER BLOCK
1400  CONTINUE
      M=IADD+6
C--CHECK IF THERE ARE ANY MORE PARAMETERS TO LOOK AT
1450  CONTINUE
      L=M
      M=ISTORE(M)+IADD
C--CHECK THE VALUE
      IF(M)1550,1550,1500
C--CHECK IF THE PARAMETER TO INSERT IS THIS ONE ALREADY THERE
1500  CONTINUE
      IF(ISTORE(M+1)-KA)1450,1600,1450
C--THE PARAMETER IS NOT PRESENT  -  INSERT IT
1550  CONTINUE
      ISTORE(IADD+5)=ISTORE(IADD+5)+1
C--LINK IT IN
      ISTORE(L)=MCG-IADD
      M=MCG
      ISTORE(MCG)=NOWT
      ISTORE(MCG+1)=KA
      STORE(MCG+2)=0.
      MCG=MCG+3
      IF(LIMIT-MCG)1750,1750,1600
C--CHECK IF THIS PARAMETER IS THE FIRST ONE REQUIRED
1600  CONTINUE
      IF(KA-IFRPAR)1700,1650,1700
C--SET THE RETURN VALUE
1650  CONTINUE
      KPARIN=M
C--UPDATE AND CHECK IF MORE PARAMETERS MUST BE ADDED
1700  CONTINUE
      KA=KA+1
      IF(KA-KB)1400,1400,1000
C--CORE OVERFLOW
1750  CONTINUE
      KPARIN=-1
1800  CONTINUE
      RETURN
      END
C
CODE FOR KACTWS
      FUNCTION KACTWS(ZZ)
C--CREATE SPACE FOR THE CONSTANT 'ZZ' IN THE WORK STACK AND ADD ITS
C  ENTRY TO THE CONSTANT CHAIN.
C
C  ZZ  THE VARIABLE CONTAINING THE CONSTANT TO BE SET UP
C
C--THE RETURN VALUE OF 'KACTWS' IS THE ADDRESS OF THE CONSTANT IN THE
C  WORK STACK. (THIS IS THE ABSOLUTE ADDRESS).
C
C--THIS ROUTINES ALLOCATES TWO WORDS FOR THE CONSTANT IN THE WORK
C  STACK WHICH ARE AS FOLLOWS :
C
C  0  THE VALUE OF 'ZZ'
C  1  THE P.D. OF  'ZZ'  -  ALWAYS ZERO.
C
C--THIS ROUTINE ALSO MAKES AN ENTRY ON THE CONSTANT CHAIN OF THE TYPE :
C
C  0  ADDRESS OF THE NEXT CONSTANT BLOCK REL. TO 'LCG' OR 'NOWT'.
C  1  ADDRESS OF THIS CONSTANT IN THE WORK STACK REL. TO 'LC'.
C  2  THE VALUE TO BE PLACED IN THE WORK STACK.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XCNTRL.INC'
      INCLUDE 'XCONST.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--PREPARE SLOT IN THE CONSTANT STACK
      ISTORE(LCS+5)=ISTORE(LCS+5)+1
C--INSERT THE VALUE CONSTANT CHAIN
      ISTORE(MCS)=MCG-LCG
      MCS=MCG
C--SET ITS LINK NEGATIVE FOR NOW
      ISTORE(MCS)=NOWT
C--UPDATE THE CURRENT TOP ADDRESS
      MCG=MCG+3
C--PREPARE A SLOT FOR IT IN THE WORK STACK
      MDCS=MDCS-2
C--WRITE THE ENTRIES IN THE CONSTANT BLOCK
      ISTORE(MCS+1)=MDCS
      STORE(MCS+2)=ZZ
C--SET THE RETURN ADDRESS
      KACTWS=MDCS
      RETURN
      END

