C $Log: not supported by cvs2svn $
C Revision 1.10  2011/01/11 16:32:21  djw
C Correct message output
C
C Revision 1.9  2005/01/23 08:29:11  rich
C Reinstated CVS change history for all FPP files.
C History for very recent (January) changes may be lost.
C
C Revision 1.1.1.1  2004/12/13 11:16:08  rich
C New CRYSTALS repository
C
C Revision 1.8  2003/08/05 11:11:12  rich
C Commented out unused routines - saves 50Kb off the executable.
C
C Revision 1.7  2003/01/14 10:19:05  rich
C g77 spots missing comma in Format statement.
C
C Revision 1.6  2002/03/13 12:36:23  richard
C Removed calls to XGDBUP (now obsolete).
C
C Revision 1.5  2002/02/12 12:49:10  Administrator
C reformat output to print new dates properly
C
C Revision 1.4  2001/03/08 14:33:06  richard
C Changed call to XGDBUP, all lists now passed over.
C
C

C ######################################################################
C Subroutine below in a module because of explicit interface necessary
C ######################################################################

C> Module containing some subroutine for lists2 because an explicit interdace is needed
      module lists2_mod
      
      contains
CODE FOR XLDLST
C> LOAD A LIST INTO CORE FROM THE DISC
      SUBROUTINE XLDLST(IULN,ICOMMN,IDIMN,IOWF,nostop)
C
C  IULN    THE LIST TYPE. THIS MAY BE SET NEGATIVE,
C          IN WHICH CASE THE LIST IS PREPARED FOR LOADING
C          AND THE ADDRESS OF THE FIRST RECORD IS RETURNED IN
C          'ICOMMN(1)'. NO DATA IS ACTUALLY LOADED INTO CORE
C          IF 'IULN' IS NEGATIVE.
C  ICOMMN  THE COMMON BLOCK TO BE SET UP.
C  IDIMN    THE DIMENSION OF THE COMMON BLOCK.
C  IOWF    THE WRITE/OVERWRITE STATUS, WHICH WILL BE USED ON THIS LIST :
C
C          -1  READ THE LIST, THEN REWRITE IT.
C           0  READ THE LIST ONLY.
C          +1  READ THE LIST, THEN CAREFULLY UPDATE IT.
C
      use lists1_mod, only: xrlind, klschk
      
      CHARACTER*24 CDT
C--
      INCLUDE 'ISTORE.INC'
      INCLUDE 'HEADES.INC'
C
C
      DIMENSION ICOMMN(IDIMN)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XLSVAL.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'TLISTC.INC'
C
      INCLUDE 'QSTORE.INC'
      
      integer, intent(out), optional :: nostop !< report error only, do not stop execution. zero=no error, negative otherwise
C
C--CHECK THAT THE LIST TYPE IS VALID
      LN=IABS(IULN)
      IREC=0
      if(.not. present(nostop)) then
        ISTAT = KLSCHK ( LN , 0 , 0 , ILSAVI , ILSMSG , I , IERERR )
      else
        ISTAT = KLSCHK(LN, 0, 0, ILSAVI, ILSMSG, I, IERERR, nostop )
      end if
      IF ( ISTAT  .LE. 0 ) GO TO 9900
C  -- ZERO THE COMMON BLOCK
      CALL XZEROF ( ICOMMN(1) , IDIMN )
C--READ THE DETAILS OF THE LIST
      if(.not. present(nostop)) then
        CALL XRLIND(LN,LSN,IADDI,I,J,K,IBUFF(1:2))
      else
        CALL XRLIND(LN,LSN,IADDI,I,J,K,IBUFF(1:2), nostop)
      end if
C
C -- MONITOR LIST OPERATION IF REQUIRED
      IF ( ( ISSLSM .EQ. 2 ) .OR. ( ISSLSM .EQ. 4 ) ) THEN
        IF ( ( ISSLNM .EQ. 0 ) .OR. ( ISSLNM .EQ. LN ) ) THEN
      IF (ISSPRT .EQ. 0) THEN
       IF ( IBUFF(1) .NE. 0 ) THEN
C -- Old style date format.
            WRITE(CDT,'(2A4)') IBUFF(1),IBUFF(2)
       ELSE
C -- New style date format.
        CALL XCDATE(IBUFF(2),CDT)
       ENDIF
       WRITE(NCWU,901)LN,LSN,K,IADDI,I,J,CDT
901    FORMAT
     1 (' List',I3,' Serial',I5,' Original',I4,' Address',I7,' Size',
     2 I7,' Write flag',I3,' Date ',A24,' From Disc')
        WRITE ( NCAWU,911) LN,LSN,CDT
        WRITE ( CMON, 911) LN,LSN,CDT
        CALL XPRVDU(NCVDU, 1,0)
911     FORMAT(1X,'List ',I4,' Serial ',I4,'  Date ',A24,
     1  '  read from disc.')
      ENDIF
        ENDIF
      ENDIF
C
      LSN=IABS(LSN)
C--CHECK IF THIS LIST WAS BEING WRITTEN TO DURING JOB TERMINATION
      IF ( J ) 9910 , 1150 , 1100
1100  CONTINUE
      IF ( IOWF .LE. 0 ) GO TO 9910
C--CHECK THAT THE LIST IS NOT MARKED AS AN ERROR LIST
1150  CONTINUE
      IF ( K .LT. 0 ) GO TO 9920
C--SEARCH FOR THE INTER-DEPENDENCIES RECORD
      K=0
      IF(KFNDRI(LN,1,IADDR,IBUFF))1850,1350,1350
C--RECORD FOUND  -  SET UP SOME POINTERS
1350  CONTINUE
      L=IBUFF(4)
      N=IBUFF(5)
C--FIND THE INCREMENTS
      N1=KINCRF(N)
      M1=KINCRF(1)
C--CHECK IF THERE ARE MORE INTER-DEPENDENCIES TO CHECK
1400  CONTINUE
      IF(N)1750,1750,1450
C--BRING DOWN THE NEXT GROUP
1450  CONTINUE
      CALL XDOWNF(L,IBUFF(1),1)
      L1=L+N1
      L=L+M1
      N=N-1
C--READ THE DATA FROM THE INDICATED LIST TYPE
      if(present(nostop)) then
        CALL XRLIND(IBUFF(1),I,IBUFF(3),IBUFF(4),IBUFF(5),J,IBUFF(6), 
     1  nostop)
      else
        CALL XRLIND(IBUFF(1),I,IBUFF(3),IBUFF(4),IBUFF(5),J,IBUFF(6))
       end if
C--CHECK IF SUCH A LIST EXISTS
      IF(IBUFF(3))1500,1500,1600
C--LIST DOES NOT EXIST  -  PRINT THE ERROR MESSAGE
1500  CONTINUE
      K=K+1
      if(.not. present(nostop)) then
        IF (ISSPRT .EQ. 0) THEN
          WRITE(NCWU,1550)LN,IBUFF(1)
        ENDIF
        WRITE(NCAWU,1550) LN,IBUFF(1)
        WRITE ( CMON, 1550) LN,IBUFF(1)
        CALL XPRVDU(NCEROR, 1,0)
1550    FORMAT(' List type ',I5,'  depends upon list type ',I5,
     2   ', which no longer exists')
      end if
      GOTO 1400
C--CHECK THE VALUE
1600  CONTINUE
      CALL XDOWNF(L1,IBUFF(2),1)
      IF(IABS(J)-IBUFF(2))1650,1400,1650
C--NOT THE CORRECT SERIAL NUMBER
1650  CONTINUE
      K=K+1
      if(.not. present(nostop)) then
        if(ILSMSG>0) then
          CALL OUTCOL(3)
          WRITE ( CMON, 1700) LN, CLISTS(LN),IBUFF(1),
     1     CLISTS(IBUFF(1)), IBUFF(2), IABS(J)
          CALL XPRVDU(NCEROR, 5,0)
          IF (ISSPRT .EQ. 0) WRITE(NCWU,'(/A/A/A/)') trim(CMON(2)), 
     1    trim(CMON(3)), trim(CMON(4))
          WRITE(NCAWU,'(/A/A/A/)')trim(CMON(2)), 
     1    trim(CMON(3)), trim(CMON(4))
          CALL OUTCOL(1)
        end if
      else
        nostop=-1
      end if
1700  FORMAT(/
     1 '              List type ',I5,' (',A,')',/
     1 ' depends upon list type ',I5,' (',A,')',/
     2 ' with original serial no.',I8,
     3 ', not the current version,',I8/)
      GOTO 1400
C--ALL INTERDEPENDENCIES PROCESSED
1750  CONTINUE
      IF ( K .GT. 0 ) GO TO 9930
C--SET UP THE POINTERS TO PROCESS EACH RECORD IN TURN
1850  CONTINUE
      I=0
C--CHECK IF THE DATA SHOULD BE LOADED
      IF(IULN)1900,1900,1950
C--NO DATA IS TO BE LOADED  -  SET THE DISC ADDRESS
1900  CONTINUE
      ICOMMN(1)=IADDI
      GOTO 2050
C--READ DOWN THE NEXT HEADER BLOCK
1950  CONTINUE
      IF(KLDDRH(I,IADDI,IBUFF(1)))2050,2000,2000
C--LOAD THE RELEVANT INFORMATION FROM THE NEXT RECORD
2000  CONTINUE
      CALL XLDREC(LN,LSN,IBUFF,ICOMMN,IDIMN,-1)
      GOTO 1950
2050  CONTINUE
      RETURN
9900  CONTINUE
      RETURN
9910  CONTINUE
      if(.not. present(nostop)) then
        IF (ISSPRT .EQ. 0) THEN
          WRITE ( NCWU , 9915 ) LN
        ENDIF
        WRITE ( NCAWU , 9915 ) LN
        WRITE ( CMON, 9915 ) LN
        CALL XPRVDU(NCEROR, 1,0)
9915    FORMAT ( 1X , 'A previous job failed when writing list ' , I5 ,
     2   ' which cannot now be accessed' )
        CALL XERHND ( IERERR )
      else 
        nostop=-1
      end if
      GO TO 9900
9920  CONTINUE
      if(.not. present(nostop)) then
        IF (ISSPRT .EQ. 0) THEN
          WRITE ( NCWU , 9925 ) LN
        ENDIF
        WRITE ( NCAWU , 9925 ) LN
        WRITE ( CMON, 9925 ) LN
        CALL XPRVDU(NCEROR, 1,0)
9925    FORMAT ( 1X , 'List type ' , I5 , ' is marked as an error list',
     2 / , 1X , 'A new version needs to be created or input ' )
        CALL XERHND ( IERERR )
      else 
        nostop=-1
      end if
      GO TO 9900
9930  CONTINUE
C -- LIST CANNOT BE LOADED BECAUSE OF INTERDEPENDCIES
      if(.not. present(nostop)) then
        if(ILSMSG>0) then
          IF (ISSPRT .EQ. 0) THEN
            WRITE ( NCWU , 9935 ) LN
          ENDIF
          WRITE ( NCAWU , 9935 ) LN
          WRITE ( CMON, 9935 ) LN
          CALL XPRVDU(NCEROR, 1,0)
9935      FORMAT ( 1X , 'List type ' , I5 , ' cannot be loaded' )
          CALL XERHND ( IERERR )
        end if
      else 
        nostop=-1
      end if      
      GO TO 9900
      END
      
      end module
      
C ######################################################################
C Subroutine below not in module
C ######################################################################
      
C
CODE FOR XLDREC
      SUBROUTINE XLDREC(IULN,IULSN,IBUFF,ICOMMN,IDIMN,ITYPE)
C--LOAD THE RELEVANT DATA FOR THE RECORD WHOSE HEADER IS IN 'IBUFF'.
C
C  IULN    THE CURRENT LIST TYPE.
C  IULSN   THE CURRENT LIST SERIAL NUMBER.
C  IBUFF   THE HEADER BLOCK OF THE RECORD TO BE LOADED, WHICH MUST BE
C          SET ON ENTRY.
C  ICOMMN  THE COMMON BLOCK FOR THIS LIST.
C  IDIMN    THE DIMENSION OF 'ICOMMN'.
C  ITYPE   THE TYPE OF DATA AREA TO SET UP IN CORE :
C
C          -1  A NORMAL DATA RECORD.
C           0  A DATA AREA AT THE TOP OF CORE, STARTING AT 'LFL'.
C
C--
      INCLUDE 'HEADES.INC'
      INCLUDE 'ISTORE.INC'
C
C
      DIMENSION ICOMMN(IDIMN)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCONST.INC'
C
      INCLUDE 'QSTORE.INC'
C
      LN=IULN
      LSN=IULSN
C--COMPUTE THE DATA AREA LENGTH
      M=MAX0(IBUFF(5)*IBUFF(6),0)
C--CHECK IF THERE IS DATA TO BE LOADED FROM THIS RECORD.
      IF(IBUFF(7))1000,1100,1100
C--NO DATA TO BE LOADED  -  CREATE ONLY A RECORD HEADER
1000  CONTINUE
      K=IBUFF(4)
      M=0
C--CHECK THE TYPE OF LOAD INDICATED
      L=NOWT
      IF(ITYPE)1050,1300,1300
C--NORMAL LOAD  -  CREATE THE RECORD HEADER
1050  CONTINUE
      L=KCEDR(LN,LSN,IBUFF(7),IBUFF(5),0,IBUFF(8))
      GOTO 1300
C--CHECK ON THE TYPE OF LOAD REQUIRED
1100  CONTINUE
      IF(ITYPE)1200,1150,1150
C--AREA AT THE TOP OF CORE
1150  CONTINUE
      IREC=IBUFF(7)
      K=KCHLFL(M)
      GOTO 1250
C--DATA TO BE LOADED  -  ALLOCATE SPACE
1200  CONTINUE
      K=KCEDR(LN,LSN,IBUFF(7),IBUFF(5),IBUFF(6),IBUFF(8))
C--SET UP THE LAST ADDRESS
1250  CONTINUE
      L=K+MAX0(0,M-1)
C--CHECK IF THERE IS A COMMON BLOCK OFFSET GIVEN
1300  CONTINUE
      J=IBUFF(8)
      IF(J)1400,1400,1350
C--SET UP THE COMMON BLOCK
1350  CONTINUE
      ICOMMN(J)=K
      ICOMMN(J+1)=L
      ICOMMN(J+2)=IBUFF(5)
      ICOMMN(J+3)=IBUFF(6)
C--CHECK IF THERE IS DATA TO LOAD
1400  CONTINUE
      IF(M)1500,1500,1450
C--BRING DOWN THE DATA
1450  CONTINUE
      CALL XDOWNF(IBUFF(4),STORE(K),M)
C--CHECK IF WE SHOULD UPDATE THE LIST HEADER BLOCK
1500  CONTINUE
      IF(ITYPE)1550,1600,1600
C--UPDATE THE TOTAL LENGTH OF THE DATA AREA
1550  CONTINUE
      CALL XUDRH(LN,IBUFF(7),IBUFF(5),IBUFF(6))
C--AND NOW RETURN
1600  CONTINUE
      RETURN
      END
C
CODE FOR XWLSTD
      SUBROUTINE XWLSTD(IULN,ICOMMN,IDIMN,IOWFLG,NEW)
C--WRITE A NEW LIST AND ITS DATA TO THE DISC.
C
C  IULN    THE LIST TYPE.
C          THIS VALUE MAY BE NEGATIVE, IN WHICH CASE 'IOWFLG' IS
C          ASSUMED TO BE 0 AND NO DATA RECORDS ARE OUTPUT TO THE DISC.
C          THE CORRECT FLAGS OTHERWISE ARE SET UP.
C          THE DISC POINTERS ARE SET IN THE COMMON BLOCK AS FOLLOWS :
C
C          ICOMMN(1)  THE ADDRESS OF THE LAST RECORD OUTPUT (=0).
C          ICOMMN(2)  THE ADDRESS OF THE NEXT RECORD TO BE OUTPUT.
C          ICOMMN(4)  THE LENGTH OUTPUT SO FAR (=0).
C
C  ICOMMN  THE COMMON BLOCK ASSOCIATED WITH THIS LIST.
C  IDIMN    THE DIMENSION OF THE COMMON BLOCK.
C  IOWFLG  THE WRITE/OVERWRITE STATUS FOR THIS LIST :
C
C          -1  ATTEMPT AN OVERWRITE.
C           0  WRITE A COMPLETELY NEW LIST.
C          +1  ATTEMPT A CAREFUL OVERWRITE.
C
C  NEW     THE NEW LIST FLAG :
C
C          -1  THIS IS NOT A NEW VERSION OF THIS LIST.
C           0  THIS IS A NEW LIST, WITH LINKS TO OTHER EXISTING LISTS.
C          +1  THIS IS A NEW LIST, WITH NO LINKS TO OTHER EXISTING
C              LISTS. THIS IS NORMALLY THE CASE WHEN THE LIST HAS JUST B
C              INPUT.
C
C--DATA RECORDS WHICH ARE IN CORE ARE WRITTEN TO THE DISC BY
C  THIS ROUTINE. IF ALL THE DATA RECORDS HAVE BEEN OUTPUT, THE
C  WRITE/OVERWRITE FLAG IS LEFT CLEAR AT THE END AND THE LIST IS
C  MARKED AS NOT IN ERROR. IF ALL THE DATA HAS NOT BEEN OUTPUT,
C  THIS CLEARING IS NOT DONE, AND IS LEFT TO THE CALLING ROUTINE.
C
C--IF THE COMMON BLOCK OFFSET IS GIVEN, 'XUDRH' IS CALLED TO TAKE THE
C  LATEST VALUES FROM THE COMMON BLOCK AND INSERT THEM IN THE DATA RECOR
C
C--
      use lists1_mod, only: xrlind, klschk
      
      DIMENSION ID(2)
      INCLUDE 'HEADES.INC'
      INCLUDE 'ISTORE.INC'
C
C
C
      DIMENSION ICOMMN(IDIMN)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XLSVAL.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--ASSIGN THE WRITE/OVERWRITE FLAG
      IOWF=IOWFLG
C -- ASSIGN LIST TYPE
      LN = IABS ( IULN )
C -- CHECK FOR VAID LIST NUMBER
      ISTAT = KLSCHK ( LN , 0 , 0 , ILSCLN , ILSMSG , INDLST , IERPRG )
C
C ** FIRST SECTION. CHECK IF AN EXISTING LIST CAN BE OVERWRITTEN BY
C    THE NEW LIST. IOWF IS SET TO 0 IF A NEW LIST IS BEING CREATED
C -- CHECK IF THIS IS A NEW LIST
      IF ( IULN .LT. 0 ) IOWF = 0
C -- THE NEXT PART COMBINES PROCESSING OF THE LIST IN CORE WITH A
C    CHECK THAT THE LIST, IF TO BE OVERWRITTEN, MATCHES THE DISC COPY
      IREC = 0
      CALL XRLIND ( LN,I,IADDI,N,K,L,IBUFF(1) )
C -- CHECK IF LIST EXISTS. IF NOT CREATE NEW LIST
      IF ( IADDI .LE. 0 ) IOWF = 0
C -- CHECK IF LIST CAN BE PURGED. IF NOT CREATE NEW LIST
      IF ( I .LT. 0 ) IOWF = 0
C -- CHECK IF LIST CAN BE OVERWRITTEN. IF NOT CREATE NEW LIST
      IF ( K .LT. 0 ) IOWF = 0
C -- FIND LIST IN CORE
      I = KHUNTR ( LN , 0 , M0TEMP , J , K , 0 )
1300  CONTINUE
C -- FIND NEXT RECORD, OR JUMP TO NEXT PART IF NO MORE
      IF (  KCHNCB ( J )  .GT.  0  ) GO TO 1800
C -- GET COMMON BLOCK OFFSET
      K = ISTORE(J+7)
C -- CHECK IF THE PARAMETER IS SET
      IF ( K .LE. 0 ) GO TO 1450
C -- UPDATE THE HEADER BLOCK
      ICOMMN(K+2) = MAX0 ( ICOMMN(K+2) , 0 )
      ICOMMN(K+3) = MAX0 ( ICOMMN(K+3) , 0 )
      ISTORE(J+4) = ICOMMN(K+2)
      ISTORE(J+5) = ICOMMN(K+3)
      ISTORE(J+2) = MD0 + ( ISTORE(J+4) * ISTORE(J+5) )
1450  CONTINUE
C -- IF THIS IS A NEW LIST, PROCEED TO NEXT RECORD
      IF ( IOWF .EQ. 0 ) GO TO 1300
C -- NOW CHECK MATCH BETWEEN CORE AND DISC LISTS
C -- SEARCH FOR THE RECORD ON THE DISC
      IF ( KFNDRI ( LN,ISTORE(J+6),IADDR,IBUFF) .LT. 0 ) GO TO 1750
C -- CHECK DATA FOR THIS RECORD IS ON DISC
      IF ( IBUFF(4) .LE. 0 ) GO TO 1750
C -- CHECK LENGRP
      IF ( IBUFF(5) .NE. ISTORE(J+4) ) GO TO 1750
C -- CHECK NGRP
      IF ( IBUFF(6) .NE. ISTORE(J+5) ) GO TO 1750
C -- CHECK HEADER LENGTH
      IF ( IBUFF(3) .NE. ( MD0 + ISTORE(J+4)*ISTORE(J+5) ) ) GO TO 1750
      GO TO 1300
1750  CONTINUE
C -- MISMATCH. NO OVERWRITE
      IOWF = 0
      GO TO 1300
C
1800  CONTINUE
      IOWFM = IOWF
C -- IF PREVIOUS VERSION OF LIST EXISTS, MARK ITS OVERWRITE FLAG
      IF ( IADDI .GT. 0 ) CALL XLSALT ( LN , 0 , 0 , ILSOWF , IOWFM )
C--SET UP THE POINTERS TO THE RECORD CHAIN
      J=M0TEMP+3
C--FIND THE NEXT FREE DISC ADDRESS AND LAST ADDRESS USED
      IADDR=KNEXTF(J)
      IADDL=0
C--CHECK IF THIS IS AN OVERWRITE
      IF(IOWF)1950,1850,1950
C--NOT AN OVERWRITE  -  SET THE INITIAL ADDRESS AND LENGTH COUNTER
1850  CONTINUE
      IADDI=IADDR
      N=0
C--CHECK IF THE COMON BLOCK REQUIRES SETTING
      IF(IULN)1900,1900,1950
C--SET THE FIRST ENTRIES OF THE COMMON BLOCK
1900  CONTINUE
      ICOMMN(1)=IADDL
      ICOMMN(2)=IADDR
      ICOMMN(4)=0
C--COUNTER FOR THE NUMBER OF RECORDS NOT OUTPUT
1950  CONTINUE
      I=0
C--MOVE TO THE NEXT DATA RECORD
2000  CONTINUE
      IF(KCHNCB(J))2050,2050,2550
C--ANOTHER RECORD FOUND  -  CHECK IF THIS IS AN INTERDEPENDENCIES RECORD
2050  CONTINUE
      IF(ISTORE(J+6)-1)2400,2100,2400
C--INTERDEPENDENCIES RECORD  -  UPDATE IT
2100  CONTINUE
      N1=ISTORE(J+4)
      L1=ISTORE(J+3)
C--CHECK IF THERE ARE MORE RELATIONSHIPS TO CHECK FOR
2150  CONTINUE
      IF(N1)2400,2400,2200
C--ASSIGN THE DEPENDENCY AS NOT EXISTING INITIALLY
2200  CONTINUE
      K1=L1+ISTORE(J+4)
      ISTORE(K1)=0
C--CHECK IF THIS LIST HAS ANY LINKS TO OTHER LISTS
      IF(NEW)2250,2250,2350
C--READ THE DATA FOR THE CURRENT LIST
2250  CONTINUE
      CALL XRLIND(ISTORE(L1),IBUFF(1),IBUFF(2),IBUFF(3),IBUFF(4),
     2 IBUFF(5),IBUFF(6))
C--CHECK IF A LIST OF THE CORRECT TYPE EXISTS
      IF(IBUFF(2))2350,2350,2300
C--SUCH A LIST DOES EXIST  -  ALTER THE ENTRY
2300  CONTINUE
      ISTORE(K1)=IABS(IBUFF(5))
C--UPDATE FOR THE NEXT LIST TYPE
2350  CONTINUE
      L1=L1+1
      N1=N1-1
      GOTO 2150
C--OUTPUT THE RECORD TO THE DISC
2400  CONTINUE
      IF(IULN)2000,2000,2450
C--OUTPUT THE DATA RECORD
2450  CONTINUE
      CALL XWDRTD(LN,ISTORE(J+6),IADDL,IADDR,N,ICOMMN,IDIMN,IOWF,IBUFF)
C--CHECK IF THIS RECORD WAS WRITTEN, OR JUST ITS HEADER BLOCK
      IF(ISTORE(J+6))2500,2000,2000
C--RECORD NOT WRITTEN  -  COUNT IT
2500  CONTINUE
      I=I+1
      GOTO 2000
C
C--ALL RECORDS THAT CAN BE PROCESSED HAVE BEEN OUTPUT
2550  CONTINUE
      IF(IULN)2800,2800,2600
C--CHECK FOR AN NEW LIST
2600  CONTINUE
      IF(IOWFM)2700,2650,2700
C--NEW LIST  -  MARK FOR WRITING
2650  CONTINUE
      IOWFM=-1
C--WRITE THE DETAILS OF THE LIST TO THE DISC
2700  CONTINUE
      CALL XWLIND(LN,IADDI,N,IOWFM,NEW)
C--CHECK IF WE HAVE OUTPUT THE COMPLETE LIST
      IF(I)2750,2750,2800
C--CLEAR THE FLAGS
2750  CONTINUE
      CALL XLSALT ( LN , 0 , 0 , ILSOWF , ILSRDY )
      CALL XLSALT ( LN , 0 , 0 , ILSERF , ILSCLR )
2800  CONTINUE
      RETURN
      END
C
C
C
CODE FOR KLSSPC
      FUNCTION KLSSPC ( IULN , ICOMMN , IDIMN , IFLAG )
C
C -- THIS ROUTINE ESTIMATES THE SPACE REQUIRED FOR LIST TYPE 'LN',
C    AND EXTENDS THE DISC FILE TO FIT THE NEW LIST.
C    THE COMMON BLOCK OFFSETS FOR EACH RECORD ARE OBTAINED FROM THE
C    CORE CHAIN. THE LENGTHS OF EACH RECORD ARE CALCULATED FROM THE
C    COMMON BLOCK RATHER THAN THE RECORD HEADERS
C
C      VALUES FOR IFLAG :-
C            1            DISPLAY ESTIMATED SIZE FOR EACH RECORD AND
C                         TOTAL FOR LIST
C            2            DISPLAY ESTIMATED SIZE FOR LIST
C            3            NO DISPLAY OF ESTIMATED SIZES
C
C      RETURN VALUE IS NUMBER OF RECORDS REQUIRED FOR LIST
C
      DIMENSION ICOMMN(IDIMN)
C
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XDISC.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
C
      ISPACE = 0
C
      I = KHUNTR ( IULN , 0 , J , IADDR , K , 0 )
C
2000  CONTINUE
      I = KCHNCB ( IADDR )
      IF ( I .GT. 0 ) GO TO 3000
      IREC = ISTORE(IADDR+6)
      IOFF = ISTORE(IADDR+7)
      IREQ = ICOMMN(IOFF+2) * ICOMMN(IOFF+3) + MD0
      ISPACE = ISPACE + IREQ
      IF ( IFLAG .GT. 1 ) GO TO 2000
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 2005 ) IREC , IULN , IREQ
      ENDIF
      WRITE ( NCAWU , 2005 ) IREC , IULN , IREQ
2005  FORMAT ( 1X , 'Space required for record type ' , I6 ,
     2 ' in list ' , I4 , ' is ' , I6 , ' word(s)' )
      GO TO 2000
C
3000  CONTINUE
      CALL XDACVI ( NWDR , NWDB , NBYWD )
      IBLCK = ( ISPACE / NWDB ) + 1
      IREC = ( ISPACE / NWDR ) + 1
C
      IF ( IFLAG .GT. 2 ) GO TO 3010
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 3005 ) IULN , ISPACE , IBLCK , IREC
      ENDIF
      WRITE ( NCAWU , 3005 ) IULN , ISPACE , IBLCK , IREC
3005  FORMAT ( 1X , 'Total space required for new list ' , I3 ,
     2 ' is ' , I7 , ' word(s)' )
C
3010  CONTINUE
      IADD = KDAFRE ( NU , -1 , IREC )
      IF ( IADD .LE. 0 ) GO TO 3100
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 3015 ) IADD , IULN
      ENDIF
      WRITE ( NCAWU , 3015 ) IADD , IULN
3015  FORMAT ( 1X , 'Disc file extended by ' , I5 , ' record(s) ' ,
     2 'for new list ' , I4 )
3100  CONTINUE
      KLSSPC = IREC
      RETURN
      END
C
CODE FOR XWDRTD
      SUBROUTINE XWDRTD(IULN,IUREC,IADDL,IADDR,N,ICOMMN,IDIMN,IOWF,
     2   IBUFF)
C--THIS ROUTINE WRITES A DATA RECORD TO THE DISC.
C
C  IULN    THE LIST TYPE.
C  IUREC   THE RECORD TYPE.
C  IADDL   THE DISC ADDRESS OF THE LAST HEADER BLOCK, OR ZERO
C          FOR THE START OF THE CHAIN.
C  IADDR   THE ADDRESS OF THE CURRENT HEADER BLOCK. ON RETURN, 'IADDL'
C          POINTS TO THE RECORD JUST OUTPUT, AND 'IADDR' IS UPDATED TO
C          POINT AT THE LOCATION FOR THE NEXT RECORD.
C  N       THE LIST LENGTH, UPDATED BY THE CURRENT RECORD LENGTH ON
C          RETURN.
C  ICOMMN  THE COMMON BLOCK FOR THIS LIST.
C  IDIMN    THE LENGTH OF THE COMMON BLOCK.
C  IOWF    THE WRITE/OVERWRITE FLAG.
C  IBUFF   AN AREA TO ASSEMBLE THE RECORD HEADER FOR THE DISC.
C
C--IF THIS IS AN OVERWRITE, 'IADDL' IS NOT USED AND 'IADDR' IS FOUND
C  FROM THE RECORD ALREADY ON THE DISC.
C
C--
      INCLUDE 'HEADES.INC'
      INCLUDE 'ISTORE.INC'
C
C
      DIMENSION ICOMMN(IDIMN)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--FIND THE RECORD IN CORE
      K=KHUNTR(IULN,IUREC,I,J,IADDD,0)
C--CHECK IF THIS IS AN OVERWRITE
      IF(IOWF)1000,1050,1000
C--THIS IS AN OVERWRITE  -  FIND THE RECORD ON DISC
1000  CONTINUE
      M=KFNDRI(LN,ISTORE(J+6),IADDR,IBUFF)
      IADDD=IBUFF(4)
C--ALTER THE RECORD LENGTH
      CALL XUPF(IADDR+KINCRF(2),ISTORE(J+2),1)
C--ALTER THE NUMBER OF GROUPS IF NECESSARY
      CALL XUPF(IADDR+KINCRF(5),ISTORE(J+5),1)
      GOTO 1200
C--THIS IS A NEW LIST  -  CHECK IF THIS IS THE FIRST RECORD
1050  CONTINUE
      IF(IADDL)1100,1150,1100
C--NOT THE FIRST  -  ADJUST THE POINTER IN THE LAST
1100  CONTINUE
      IBUFF(1)=IADDR
      CALL XUPF(IADDL,IBUFF(1),1)
C--CREATE THE HEADER BLOCK FOR THIS RECORD
1150  CONTINUE
      CALL XMOVEI (ISTORE(J),IBUFF(1),MD0)
C--ALTER THE ADDRESS PPINTERS
      IBUFF(1)=0
      IBUFF(2)=IADDL
C--UPDATE THE ADDRESS POINTERS
      IADDL=IADDR
      IADDD=IADDR+KINCRF(MD0)
      IADDR=IADDR+KINCRF(IBUFF(3))
C--SET THE DATA ADDRESS
      IBUFF(4)=IADDD
C--WRITE THE BLOCK TO THE DISC
      CALL XUPF(IADDL,IBUFF(1),MD0)
C--UPDATE THE WORD COUNT
      N=N+IBUFF(3)
C--CHECK IF THE RECORD SHOULD BE OUTPUT TO THE DISC
1200  CONTINUE
      IF(ISTORE(J+6))1250,1350,1350
C--DATA NOT AVAILABLE TO BE OUTPUT  -  FETCH THE COMMON BLOCK POINTER
1250  CONTINUE
      M=ISTORE(J+7)
C--CHECK IF IT IS SET
      IF(M)1450,1450,1300
C--ALTER THE POINTER IN THE COMMON BLOCK
1300  CONTINUE
      ICOMMN(M)=IADDD
      GOTO 1450
C--DATA SHOULD BE OUTPUT  -  CHECK IF THERE IS ANY TO OUTPUT
1350  CONTINUE
      K=ISTORE(J+4)*ISTORE(J+5)
      IF(K)1450,1450,1400
C--DATA TO BE OUTPUT  -  FIND ITS ADDRESS AND OUTPUT IT TO DISC
1400  CONTINUE
      M=ISTORE(J+3)
      CALL XUPF(IADDD,ISTORE(M),K)
c      write(*,'(a,80a1)')'Hi',(istore(itemp),itemp=m,m+k)
c
C--AND NOW RETURN
1450  CONTINUE
      RETURN
      END
C
CODE FOR KFNDRI
      FUNCTION KFNDRI(IULN,IUREC,IADDR,IBUFF)
C--FIND THE DATA ABOUT A GIVEN DATA RECORD ON DISC.
C
C  IULN    THE LIST TYPE.
C  IUREC   THE USER REQUIRED RECORD.
C  IADDR   THE DISC ADDRESS OF THE RECORD.
C  IBUFF   THE ARRAY TO CONTAIN THE RECORD HEADER BLOCK ON RETURN.
C
C--RETURN VALUES ARE :
C
C  -1  NO SUCH RECORD.
C   0  OKAY.
C
C--
      use lists1_mod, only: xrlind, klschk
      
      INCLUDE 'HEADES.INC'
C
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XLSVAL.INC'
C
C--CHECK THAT THE LIST NUMBER IS VALID
      LN=IULN
      IREC=IUREC
      ISTAT = KLSCHK ( LN , 0 , 0 , ILSCLN , ILSMSG , I , IERPRG )
C--READ THE DATA FOR THIS LIST
      CALL XRLIND(LN,IBUFF(1),IBUFF(2),IBUFF(3),IBUFF(4),IBUFF(5),
     2 IBUFF(6))
C--CHECK IF THE LIST IS PRESENT
      IADDI=IBUFF(2)
      IF(IADDI)1000,1000,1100
C--NO SUCH LIST
1000  CONTINUE
      KFNDRI=-1
1050  CONTINUE
      RETURN
C--SET UP THE RECORD READING POINTERS
1100  CONTINUE
      IADDR=0
C--READ THE NEXT RECORD
1150  CONTINUE
      IF(KLDDRH(IADDR,IADDI,IBUFF(1)))1000,1200,1200
C--CHECK IF THIS IS THE RECORD WE REQUIRE
1200  CONTINUE
      IF(IREC-IBUFF(7))1150,1250,1150
C--SUCCESS  -  TRANSFER THE DATA
1250  CONTINUE
      KFNDRI=0
      GOTO 1050
      END
C
CODE FOR KLDDRH
      FUNCTION KLDDRH(LASTAD,IADDR,IBUFF)
C--LOAD A DATA RECORD HEADER INTO A CORE BUFFER
C
C  LASTAD  THE ADDRESS OF THE LAST DATA RECORD.
C          THIS VARIABLE SHOULD BE SET ON ENTRY, AND IS UPDATED
C          TO POINT AT THE CURRENT RECORD HEADER ON EXIT. IF THIS IS
C          THE START OF A CHAIN, THIS VARIABLE SHOULD BE SET TO ZERO.
C  IADDR   THE ADDRESS OF THE RECORD HEADER TO BE LOADED.
C          THIS VARIABLE IS UPDATED TO POINT AT THE NEXT RECORD
C          HEADER ON EXIT.
C  IBUFF   THE BUFFER TO RECEIVE THE DATA RECORD HEADER.
C
C--RETURN VALUES OF 'KLDDRH' ARE :
C
C  -1  END OF THE CHAIN REACHED.
C   0  NEW HEADER LOADED SUCCESSFULLY
C
C--
      INCLUDE 'HEADES.INC'
C
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
C--CHECK FOR THE END OF THE CHAIN
      KLDDRH=0
      IF(IADDR)1150,1000,1100
C--END OF THE CHAIN
1000  CONTINUE
      KLDDRH=-1
1050  CONTINUE
      RETURN
C--BRING DOWN THE NEXT RECORD
1100  CONTINUE
      CALL XDOWNF(IADDR,IBUFF(1),MD0)
C--CHECK THE BACKWARD LINK
      IF(LASTAD-IBUFF(2))1150,1250,1150
C--LINKAGE ERROR
1150  CONTINUE
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1200)LN,LASTAD,IADDR,(IBUFF(I),I=1,MD0)
      ENDIF
      WRITE(NCAWU,1200) LN,LASTAD,IADDR,(IBUFF(I),I=1,MD0)
      WRITE ( CMON, 1200) LN,LASTAD,IADDR, (IBUFF(I),I=1,MD0)
      CALL XPRVDU(NCEROR, 3,0)
1200  FORMAT(' Chain break on disc for list type ',I5,/,1X,2I10,
     1 / 1X, 12I10 )
      CALL XERHND ( IERPRG )
C--UPDATE THE POINTERS
1250  CONTINUE
      LASTAD=IADDR
      IADDR=IBUFF(1)
      GOTO 1050
      END
C
CODE FOR KCEDR
      FUNCTION KCEDR(IULN,IULSN,IUREC,LENGRP,NGRP,IOFF)
C--CREATE A DATA RECORD IN CORE.
C
C  IULN    THE LIST TYPE.
C  IULSN   THE SERIAL NUMBER OF THE LIST.
C  IUREC   THE RECORD TYPE.
C  LENGRP  THE LENGTH OF EACH REPEAT GROUP IN THE RECORD.
C  NGRP    THE NUMBER OF REPEAT GROUPS IN THE RECORD.
C  IOFF    THE COMMON BLOCK OFFSET.
C
C--RETURN VALUES ARE :
C
C  >0  THE ADDRESS OF THE DATA AREA FOR THIS RECORD.
C
C--
      use lists1_mod, only: klschk
      
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLIMIT.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XLSVAL.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CHECK THAT THE LIST SERIAL NUMBER IS VALID
      ISTAT = KLSCHK ( 0 , IULSN , 0 , ILSCLV , ILSMSG , I , IERPRG )
C--SET UP THE POINTERS
      LN=IULN
      LSN=IULSN
      IREC=IUREC
C--CHECK IF THERE IS A CORE CHAIN
      M0=L0
      IF(KVALID(NFLMIN,M0,LFLMAX))1000,1050,1050
C--NO CORE CHAIN ESTABLISHED
1000  CONTINUE
      L0=NFL
      M0=KCHNFL(1)
      ISTORE(L0)=IENDC
      M0=L0
      N0=0
C--CHECK THE NEXT HEADER FOR THIS LIST
1050  CONTINUE
      IF(KCHNCB(M0))1100,1100,1150
C--CHECK THE LIST TYPE
1100  CONTINUE
      IF(ISTORE(M0+6)-LN)1050,1200,1050
C--NO SUCH LIST AT PRESENT ON THE CORE CHAIN
1150  CONTINUE
      CALL XCEDRH(M0,LN,LSN,0,NOWT)
      N0=N0+1
      ISTORE(M0+3)=IENDC
C--SEARCH DOWN TO THE END OF THE CHAIN FOR THIS LIST
1200  CONTINUE
      I=M0+3
C--CHECK THE NEXT BLOCK
1250  CONTINUE
      IF(KCHNCB(I))1250,1250,1300
C--END OF THE CHAIN
1300  CONTINUE
      CALL XCEDRH(I,IREC,LENGRP,NGRP,IOFF)
      ISTORE(M0+2)=ISTORE(M0+2)+ISTORE(I+2)
      KCEDR=ISTORE(I+3)
      RETURN
      END
C
CODE FOR XUDRH
      SUBROUTINE XUDRH(IULN,IUREC,LENGRP,NGRP)
C--UPDATE DATA RECORD HEADER.
C
C  IULN    THE LIST TYPE.
C  IUREC   THE RECORD TYPE.
C  LENGRP  THE LENGTH OF THE REPEAT GROUP FOR THIS RECORD.
C  NGRP    THE NUMBER OF REPEAT GROUPS.
C
C--THIS ROUTINE SEARCHES FOR THE RELEVANT RECORD, AND THEN UPDATES
C  THE ENTRIES FOR 'LENGRP' AND 'NGRP'. IF ONE OF THESE QUANTITIES
C  WAS SPECIFIED TO 'XCEDRH', IT MUST BE GIVEN AS ZERO TO THIS ROUTINE,
C  WHICH SETS THE NEW VALUE FOR BOTH VARIABLES TO THE MAXIMUM PROVIDED
C  TO THIS ROUTINE, TO XCEDRH AND ZERO. THIS ROUTINE DOES NOT UPDATE
C  OR CHECK 'NFL' OR 'LFL'.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLISTI.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--SET THE RECORD TYPE INFORMATION
      LN=IULN
      IREC=IUREC
C--FIND THE RECORD IN CORE
      K=KHUNTR(IULN,IUREC,M0,I,J,0)
C--SUCCESS  -  UPDATE THE QUANTITIES
      L=MAX0(0,ISTORE(I+4))*MAX0(0,ISTORE(I+5))
C--COMPUTE THE NEW GROUP LENGTH
      M=MAX0(0,LENGRP)
C--CHECK IF THIS IS A CHANGE
      IF(M)1100,1100,1050
C--ALTER THE HEADER BLOCK ENTRY
1050  CONTINUE
      ISTORE(I+4)=M
C--COMPUTE THE NEW NUMBER OF GROUPS
1100  CONTINUE
      M=MAX0(0,NGRP)
C--CHECK IF THIS IS A CHANGE
      IF(M)1200,1200,1150
C--ALTER THE HEADER BLOCK ENTRY
1150  CONTINUE
      ISTORE(I+5)=M
C--COMPUTE THE NEW LENGTH
1200  CONTINUE
      M=ISTORE(I+4)*ISTORE(I+5)
C--ALTER THE RECORD LENGTH
      ISTORE(I+2)=MD0+M
C--CHECK IF THIS RECORD IS CORE RESIDENT
      IF(ISTORE(I+6))1300,1300,1250
C--CORE RESIDENT  -  ALTER THE LENGTH STORED
1250  CONTINUE
      ISTORE(M0+2)=ISTORE(M0+2)-L+M
C--CHECK IF THE CORE MAPS SHOULD BE PRINTED
1300  CONTINUE
      IF(MAPS)1350,1500,1350
C--PRINT THE CORE MAP
1350  CONTINUE
      CALL XPCM(1)
C--CHECK IF THE CONTENTS SHOULD BE DUMPED
      IF ( MAPS .LE. 0 ) GO TO 1500
C--PRINT THE CONTENTS
      IF(ISTORE(I+6))1500,1500,1450
C--DATA RECORD IN CORE  -  PRINT IT
1450  CONTINUE
      NFW=ISTORE(I+3)-MD0
      NLW=NFW+ISTORE(I+2)-1
      CALL XPRINT(NFW,NLW)
C--AND NOW RETURN
1500  CONTINUE
      RETURN
      END
C
CODE FOR XCEDRH
      SUBROUTINE XCEDRH(LAST,IUREC,LENGRP,NGRP,IOFF)
C--CREATE A DATA RECORD HEADER BLOCK IN CORE.
C
C  LAST    THE ADDRESS OF THE LAST DATA RECORD HEADER BLOCK, TO WHICH
C          THIS PARAMETER IS UPDATED TO POINT TO THE NEW HEADER BLOCK.
C          THE NEW ONE IS TO BE LINKED.
C  IUREC    THE RECORD TYPE.
C  LENGRP  THE LENGTH OF THE REPEAT GROUP FOR THIS RECORD TYPE.
C  NGRP    THE NUMBER OF GROUPS FOR THIS TYPE OF RECORD.
C  IOFF    THE COMMON BLOCK OFFSET FOR THIS TYPE OF RECORD.
C
C--THIS ROUTINE ALLOCATES SPACE FOR THE DATA FOR THE RECORD. IF
C  'LENGRP' OR 'NGRP' ARE NOT KNOWN WHEN THIS ROUTINE IS CALLED,
C  THEY MUST BE PROVIDED AS ZERO.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLIMIT.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--COMPUTE THE LENGTH OF THE DATA RECORD
      L=MAX0(LENGRP,0)
      M=MAX0(NGRP,0)
      I=L*M+MD0
C--SET UP THE CORE AREA FOR THIS LIST
      J=NFL
      K=KCHNFL(I)
C--SET UP THE LINKAGE INFORMATION
      ISTORE(LAST)=J
      ISTORE(J)=IENDC
      ISTORE(J+1)=LAST
      LAST=J
C--SET UP THE HEADER BLOCK
      ISTORE(J+2)=I
      ISTORE(J+3)=J+MD0
      ISTORE(J+4)=L
      ISTORE(J+5)=M
      ISTORE(J+6)=IUREC
      ISTORE(J+7)=IOFF
      RETURN
      END
C
CODE FOR KHUNTR
      FUNCTION KHUNTR(IULN,IUREC,IADDL,IADDR,IADDD,IFLAG)
C--HUNT FOR A GIVEN LIST OR LIST/RECORD ON THE CORE CHAIN.
C
C  IULN    THE LIST TYPE.
C  IUREC   THE RECORD TYPE FOR THE GIVEN LIST. IF THIS IS SET TO ZERO,
C          THE HUNT IS TERMINATED WHEN THE LIST IS FOUND.
C  IADDL   THE ADDRESS OF THE HEADER CONTROL BLOCK FOR THE LIST.
C  IADDR   THE ADDRESS OF THE HEADER CONTROL FOR THE RECORD FOUND.
C          IF THE RECORD IS GIVEN AS ZERO, THIS WORD IS SET TO THE
C          POINTER IN THE LIST HEADER BLOCK FOR THE FIRST RECORD.
C  IADDD   THE ADDRESS OF THE DATA BLOCK. THIS IS LEFT UNSET IF THE
C          RECORD IS GIVEN AS ZERO.
C  IFLAG   CONTROLS ERROR PRINTING :
C
C          -1  SUPPRESS ERROR PRINTING  -  RESULTS RETURNED THROUGH 'KHU
C           0  TAKE ERROR TERMINATIONS WHERE APPROPIATE.
C
C--RETURN VALUES OF 'KHUNTR' FOR 'IFLAG' EQUAL TO -1 ARE :
C
C  -1  NO SUCH LIST IN CORE.
C   0  ALL OKAY  -  NORMAL RETURN VALUE IF 'IFLAG' EQUALS ZERO.
C  +1  NO SUCH RECORD FOR THE GIVEN LIST.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLIMIT.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--ASSIGN THE LIST AND RECORD TYPES
      LN=IULN
      IREC=IUREC
C----- CHECK FOR A CORE CHAIN OF ANY SORT
      IF (L0 .LE. 0) GOTO 1050
C--SET THE LIST ADDRESS TO THE FIRST POINTER
      IADDL=L0
C--MOVE TO THE NEXT LIST
1000  CONTINUE
      IF(KCHNCB(IADDL))1250,1250,1050
C--END OF THE CHAIN  -  CHECK THE ERROR PROCESSING
1050  CONTINUE
      KHUNTR=-1
      IF(IFLAG)1100,1150,1150
C--AND NOW RETURN
1100  CONTINUE
      RETURN
C--ERROR PRINT FOR NO SUCH LIST
1150  CONTINUE
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1200)IULN
      ENDIF
      WRITE(NCAWU,1200)IULN
      WRITE ( CMON, 1200)IULN
      CALL XPRVDU(NCEROR, 1,0)
1200  FORMAT(' List type ',I5,' is not present in core')
      CALL XERHND ( IERPRG )
C--CHECK THE TYPE OF THE NEXT LIST
1250  CONTINUE
      IF(ISTORE(IADDL+6)-IULN)1000,1300,1000
C--CORRECT LIST TYPE  -  SET POINTERS FOR THE RECORDS
1300  CONTINUE
      IADDR=IADDL+3
      IADDD=NOWT
      KHUNTR=0
C--CHECK IF WE SHOULD SEARCH FOR A RECORD
      IF(IUREC)1350,1100,1350
C--MOVE TO THE NEXT RECORD FOR HIS LIST
1350  CONTINUE
      IF(KCHNCB(IADDR))1600,1600,1400
C--END OF THE CHAIN  -  CHECK FOR ERROR PROCESSING
1400  CONTINUE
      KHUNTR=1
      IF(IFLAG)1100,1450,1450
C--ERROR TERMINATION  -  OMITTED RECORD.
1450  CONTINUE
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1500)IULN,IUREC
      ENDIF
      WRITE(NCAWU,1500) IULN,IUREC
      WRITE ( CMON, 1500) IULN,IUREC
      CALL XPRVDU(NCEROR, 1,0)
1500  FORMAT(' List type ',I5,' and record type ',I8,
     2 ' is not present in core')
C--TERMINATION
      CALL XPCM(1)
      CALL XERHND ( IERPRG )
C--CHECK THE TYPE OF THE NEXT RECORD
1600  CONTINUE
      IF(ISTORE(IADDR+6)-IUREC)1350,1650,1350
C--SUCCESS  -  SET THE DAT ADDRESS AND RETURN
1650  CONTINUE
      IADDD=ISTORE(IADDR+3)
      GOTO 1100
      END
C
CODE FOR KCHNCB
      FUNCTION KCHNCB(IADD)
C--MOVE ON TO THE NEXT CORE BLOCK ON THE CHAIN, STARTING FROM THE
C  CONTROL BLOCK AT 'ISTORE(IADD)'. THIS ROUTINE APPLIES ALL THE CHECKS
C  VIA 'KCHKCC', BUT TERMINATES THE JOB IF AN ERROR MESSAGE IS FOUND.
C
C  IADD    THE ADDRESS OF THE CURRENT RECORD HEADER BLOCK. THIS
C          PARAMETER IS UPDATED ON RETURN, AND POINTS AT THE NEW
C          HEADER BLOCK.
C
C--RETURN VALUES ARE :
C
C   0  OKAY.
C  +1  END OF CHAIN DETECTED.
C
C--
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XERVAL.INC'
C
      INCLUDE 'XIOBUF.INC'
C--CALL THE CHAIN INCREMENTING ROUTINE
      KCHNCB=0
      IF(KCHKCC(IADD))1100,1050,1000
C--END OF THE CHAIN
1000  CONTINUE
      KCHNCB=1
1050  CONTINUE
      RETURN
C--SOME SORT OF ERROR
1100  CONTINUE
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1150)LN,IREC
      ENDIF
      WRITE(NCAWU,1150) LN,IREC
      WRITE ( CMON, 1150) LN,IREC
      CALL XPRVDU(NCEROR, 1,0)
1150  FORMAT(' Corrupt data record chain in core ',
     2 ' - indicated list type ',I5,' and record type ',I8)
      CALL XPCM(1)
      CALL XERHND ( IERPRG )
C      STOP
      CALL GUEXIT(2016)
      END
C
CODE FOR KCHKCC
      FUNCTION KCHKCC(IADD)
C--CHECK THAT THE LINKAGE AT 'ISTORE(IADD)' IS VALID, AND MOVE ON TO THE
C  NEXT ITEM IN THE CHAIN.
C
C  IADD    THE CURRENT LINK ADDRESS IN 'ISTORE'. APART FROM THE VERY FIR
C          EACH SET OF LINKAGE POINTERS HAS THE FOLLOWING FORMAT :
C
C          0  ADDRESS OF THE NEXT ITEM IN THE CHAIN, OR THE END MARKER.
C          1  ADDRESS OF THE LAST ITEM IN THE CHAIN.
C
C--RETURN VALUES OF 'KCHKCC' ARE :
C
C  -1  INVALID CHAIN LINKAGE. (ADDRESS INVALID, OR NO BACKWARD LINKAGE).
C   0  OKAY, AND ON RETURN 'IADD' POINTS TO THE FIRST WORD OF THE NEW IT
C  +1  END OF THE CHAIN.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLIMIT.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CHECK IF THE ADDRESS GIVEN IS VALID
      KCHKCC=0
      IF(KVALID(NFLMIN,IADD,LFLMAX))1200,1000,1000
C--CHECK FOR THE END OF THE CHAIN
1000  CONTINUE
      IF(ISTORE(IADD)-IENDC)1050,1250,1050
C--CHECK IF THE CONTENTS OF 'ISTORE(IADD)' ARE A VALID ADDRESS
1050  CONTINUE
      IF(KVALID(NFLMIN,ISTORE(IADD),LFLMAX))1200,1100,1100
C--UPDATE 'IADD'
1100  CONTINUE
      I=IADD
      IADD=ISTORE(IADD)
C--CHECK THAT THE BACKWARD POINTER AT THE NEW ADDRESS IS VALID
      IF(KVALID(NFLMIN,ISTORE(IADD+1),LFLMAX))1200,1150,1150
C--VALID ADDRESS  -  CHECK THAT IT IS CORRECT
1150  CONTINUE
      IF(ISTORE(IADD+1)-I)1200,1300,1200
C--INVALID CHAIN LINKAGE INFORMATION
1200  CONTINUE
      KCHKCC=-1
      GOTO 1300
C--END OF THE CHAIN
1250  CONTINUE
      KCHKCC=1
1300  CONTINUE
      RETURN
      END
C
CODE FOR KVALID
      FUNCTION KVALID(IMIN,IADD,IMAX)
C--CHECK IF THE ADDRESS 'IADD' IS VALID.
C
C  IMIN     THE MINIMUM VALUE THAT 'IADD' MAY HAVE.
C  IADD    THE ADDRESS TO BE CHECKED.
C  IMAX     THE MAXIMUM VALUE THAT 'IADD' MAY HAVE.
C          (IF 'IMAX' IS LESS THAN 'IMIN', THE SECOND CHECK ON 'IMAX' IS
C          OMITTED).
C
C--RETURN VALUES OF 'KVALID' ARE :
C
C  -1  INVALID ADDRESS.
C   0  VALID ADDRESS.
C
C--
      KVALID=0
C--CHECK THE MINIMUM VALUE
      IF(IMIN-IADD)1000,1000,1100
C--CHECK IF THE MAXIMUM CHECK SHOULD BE MADE
1000  CONTINUE
      IF(IMIN-IMAX)1050,1050,1150
C--CHECK THE MAXIMUM VALUE
1050  CONTINUE
      IF(IMAX-IADD)1100,1150,1150
C--INVALID ADDRESS
1100  CONTINUE
      KVALID=-1
1150  CONTINUE
      RETURN
      END
C
CODE FOR KCHNFL
      FUNCTION KCHNFL(INCREM)
C--INCREASE THE CURRENT VALUE OF 'NFL' BY 'INCREM'
C
C  INCREM  THE REQUIRED INCREMENT TO 'NFL'  -  MUST BE GREATER
C          THAN ZERO.
C
C--THIS ROUTINE MUST BE USED INSTEAD OF A CALL SUCH
C  AS 'KINCOR(NFL,INCREM)'.
C
C--THE RETURN VALUE IS THE NEW VALUE OF 'NFL' AFTER THE INCREMENT.
C
      INCLUDE 'STORE.INC'
C
C
C
      DATA I/0/
C
      I=NFL
      KCHNFL=KINCOR(I,INCREM)
      RETURN
      END
C
CODE FOR KCHLFL
      FUNCTION KCHLFL(INCREM)
C--DECREMENT THE CURRENT VALUE OF 'LFL' BY 'INCREM'
C
C  INCREM  THE REQUIRED CHANGE TO 'LFL'  -  MUST BE POSITIVE.
C
C--THE RETURN VALUE OF 'KCHLFL' IS THE NEW VALUE OF 'LFL' PLUS ONE.
C  FOR THIS REASON, THE MINIMUM ALLOWED CHANGE IN 'INCREM' IS 2.
C
C--THIS FUNCTION SHOULD BE USED IN PREFERENCE TO A CALL
C  OF THE TYPE 'KDECOR(LFL,INCREM)'.
C
C--
      INCLUDE 'STORE.INC'
C
C
C
      DATA I/0/,J/0/
C
C--SET UP THE VALUES FOR KINCOR
      I=LFL
      J=MIN0(-1,-INCREM+1)
      KCHLFL=KINCOR(I,J)
      RETURN
      END
C
cCODE FOR KDECOR
c      FUNCTION KDECOR(IADD,INCREM)
cC--ALTER THE ADDRESS 'IADD' NEGATIVELY BY THE AMOUNT 'INCREM-1'
cC
cC  IADD    ADDRESS TO BE ALTERED
cC  INCREM  NUMBER PLUS ONE TO BE SUBTRACTED FROM 'IADD'.
cC
cC--'LFL' IS UPDATE BY THIS PROCESS SO THAT IT IS EQUAL TO 'IADD-INCREM'.
cC
cC--RETURN VALUE IS THE NEW ADDRESS 'IADD-INCREM+1'.
cC
cC--'INCREM' ASSUMES A MINIMUM VALUE OF 2.
cC
cC--
cC
cC
c      DATA I/0/
cC
c      I=MIN0(-1,-INCREM+1)
c      KDECOR=KINCOR(IADD,I)
c      RETURN
c      END

CODE FOR KINCOR
      FUNCTION KINCOR(IADD,INCREM)
C--INCREMENT THE STORE ADDRESS AND CHECK THAT THE LIMITS HAVE NOT BEEN E
C
C  IADD    ADDRESS TO INCREMENT
C  INCREM  THE INCREMENT  -  THIS MAY BE + OR -.
C
C--THIS ROUTINE ADDS 'INCREM' TO 'IADD', AND UPDATES 'NFL' IF
C  'INCREM' IS POSITIVE OR 'LFL' IF 'INCREM' IS NEGATIVE.
C  NO UPDATE IS DONE IF 'INCREM' IS ZERO.
C
C--'LFL' IS CHANGED SO THAT IT IS EQUAL TO 'IADD-1' ON EXIT, WHILE
C  'NFL' IS CHANGED SO THAT IT IS EQUAL TO 'IADD'.
C
C--THE RETURN VALUE IS 'IADD+INCREM'.
C
C--
      INCLUDE 'STORE.INC'
C
C
C
      DATA I/0/
C
      I=IADD+INCREM
C--CHECK THE SIGN OF THE INCREMENT
      IF(INCREM)1000,1100,1050
C--UPDATE 'LFL'
1000  CONTINUE
      LFL=MIN0(LFL,I-1)
      CALL XCHCOR(I,IADD)
      GOTO 1150
C--UPDATE 'NFL'
1050  CONTINUE
      NFL=MAX0(NFL,I)
C--CHECK THAT THE CORE AREA CAN BE USED
1100  CONTINUE
      CALL XCHCOR(IADD,I)
1150  CONTINUE
      KINCOR=I
      RETURN
      END
C
CODE FOR XCHCOR
      SUBROUTINE XCHCOR(NFW,NLW)
C--CHECK THAT THE CORE LIMITS HAVE NOT BEEN EXCEEDED
C
C  NFW  FIRST WORD TO BE USED
C  NLW  LAST WORD TO BE USED
C
C--
      INCLUDE 'STORE.INC'
      INCLUDE 'XLIMIT.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
C--COMPUTE THE NUMBER OF FREE WORDS AVAILABLE
      NUL=LFL-NFL+1
C--CHECK THAT TOO MUCH STORE HAS NOT BEEN ALLOCATED
      IF(NFL-LFL+5)1150,1000,1000
C--TOO MUCH CORE HAS BEEN ALLOCATED
1000  CONTINUE
      CALL XERHDR(0)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1050)LN,IREC
      ENDIF
      WRITE(NCAWU,1050) LN,IREC
      WRITE ( CMON, 1050) LN,IREC
      CALL XPRVDU(NCEROR, 1,0)
1050  FORMAT(' Insufficient core store available for list type ',I5,
     2 1X,'record type ',I8)
C--ERROR TERMINATION
1100  CONTINUE
      CALL XPCM(0)
      CALL XERHND ( IERCAT )
C--CHECK THAT THE ALLOCATED STORE CAN BE USED
1150  CONTINUE
      IF(NFW-NFLMIN)1200,1300,1300
C--ATTEMPT TO USE CORE STORE THAT CANNOT BE USED
1200  CONTINUE
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1250)LN,IREC,NFLMIN,NFL,NFW,NLW,LFL,LFLMAX
      ENDIF
      WRITE(NCAWU,1250)LN,IREC,NFLMIN,NFL,NFW,NLW,LFL,LFLMAX
      WRITE ( CMON, 1250) LN,IREC,NFLMIN,NFL,NFW,NLW,LFL,LFLMAX
      CALL XPRVDU(NCEROR, 1,0)
1250  FORMAT(' Illegal store reference for list type ',I5,1X,
     2 'Record type ',I8,
     1 /,1X,3I10,5X,'. . .',3I10)
      GOTO 1100
1300  CONTINUE
      IF(NFL-NFLMIN)1200,1350,1350
C--CHECK THE UPPER LIMITS
1350  CONTINUE
      IF(NLW-LFLMAX)1400,1400,1200
1400  CONTINUE
      IF(LFL-LFLMAX)1450,1450,1200
C--AND NOW RETURN
1450  CONTINUE
      RETURN
      END
C
CODE FOR XPCM
      SUBROUTINE XPCM(ITYPE)
C--PRINT THE DETAILS OF THE CORE CHAIN
C
C  ITYPE   THE TYPE OF CORE MAP REQUIRED :
C
C          -1  LIST TYPE DETAILS ONLY.
C           0  LIST DETAILS, PLUS RECORDS FROM THE CURRENT LIST.
C          +1  LIST AND RECORD DETAILS FOR ALL LISTS.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLIMIT.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CHECK ON THE TYPE OF PRINT TO BE DONE
      J=1
      IF(ITYPE)1050,1000,1000
C--FULL HEADING REQUIRED
1000  CONTINUE
      J=2
C--PRINT THE INITIAL HEADING
1050  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1100)NFLMIN,NFL,LFL,LFLMAX,(IB,I=1,J)
      ENDIF
1100  FORMAT(//,' Core allocation map',//,' Absolute min. ',I8,8X,
     2 'Current min. ',I8,13X,'Current max. ',I8,8X,
     3 'Absolute max. ',I8,//,1X,7X,'List',4X,'Serial',4X,'Length',2A1,
     4 2X,'Record',3X,'Minimum',3X,'Maximum',3X,'Core used',3X,
     5 'GRPLEN',3X,'NGROUP',3X,'Length',/)
      M0=L0
C--CHECK THAT THERE IS A CORE CHAIN TO PRINT
      IF(KVALID(NFLMIN,M0,LFLMAX))1150,1250,1250
C--NO CORE CHAIN  -  PRINT A MESSAGE
1150  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1200)
      ENDIF
      WRITE(NCAWU,1200)
      WRITE ( CMON, 1200)
      CALL XPRVDU(NCEROR, 1,0)
1200  FORMAT(' No core chain established')
      GOTO 2050
C--MOVE ON TO THE NEXT LIST ON THE CHAIN
1250  CONTINUE
      IF(KCHKCC(M0))1300,1400,2050
C--INVALID CHAIN OF SOME TYPE
1300  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1350)
      ENDIF
      WRITE(NCAWU,1350)
      WRITE ( CMON, 1350)
      CALL XPRVDU(NCEROR, 1,0)
1350  FORMAT(' Chain break')
      GOTO 2050
C--PRINT THE DETAILS ABOUT THIS LIST
1400  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1450)ISTORE(M0+6),ISTORE(M0+4),ISTORE(M0+2)
      ENDIF
1450  FORMAT(1X,3I10)
C--CHECK ON THE TYPE OF PRINT REQUIRED
      IF(ITYPE)1250,1500,1550
C--CHECK IF THIS IS THE CURRENT LIST
1500  CONTINUE
      IF(LN-ISTORE(M0+6))1250,1550,1250
C--SET OFF DOWN THE RECORD CHAIN FOR THIS LIST
1550  CONTINUE
      L=M0+3
C--MOVE ON TO THE NEXT RECORD FOR THIS LIST
1600  CONTINUE
      IF(KCHKCC(L))1650,1750,1250
C--CHAIN BREAK FOR THE RECORDS
1650  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1700)
      ENDIF
      WRITE(NCAWU,1700)
      WRITE ( CMON, 1700)
      CALL XPRVDU(NCEROR, 1,0)
1700  FORMAT(1X,'Chain break')
      GOTO 1250
C--CHECK THAT THE LENGTH INDICATED IS CORRECT
1750  CONTINUE
      J=1
      IF(ISTORE(L+2)-MD0-ISTORE(L+4)*ISTORE(L+5))1800,1850,1800
C--INCORRECT LENGTH
1800  CONTINUE
      J=2
C--CHECK IF THE DATA FROM THIS RECORD IS IN CORE
1850  CONTINUE
      M=ISTORE(L+2)
      IF(ISTORE(L+6))1900,1950,1950
C--NOT IN CORE
1900  CONTINUE
      M=MD0
1950  CONTINUE
      K=L+M-1
C--PRINT THE DETAILS FOR THIS RECORD
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2000)ISTORE(L+6),L,K,M,ISTORE(L+4),ISTORE(L+5),
     2 ISTORE(L+2),(IB,I=1,J)
      ENDIF
2000  FORMAT(1X,30X,3I10,I11,I10,2I9,2A1,3X,'Inconsistent')
      WRITE ( NCAWU, '(''See the listing file for details'')')
      WRITE ( CMON, '(''See the listing file for details'')')
      CALL XPRVDU(NCEROR, 1,0)
      GOTO 1600
C--AND NOW EXIT
2050  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU,2100)NULMAX,NUL
      WRITE ( NCAWU,2100) NULMAX,NUL
      WRITE ( CMON, 2100) NULMAX, NUL
      CALL XPRVDU(NCVDU, 1,0)
2100  FORMAT(' Max. free word(s) ',I8,5X,'Current free word(s) ',I8)
      CALL XLINES
      RETURN
      END
C
CODE FOR XCSAE
      SUBROUTINE XCSAE
C--DETELE DETAILS OF THE CORE CHAIN HOLDING LIST INFORMATION
C
C--USUALLY USED IN CONJUNCTION WITH 'XRSL'.
C
C--
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCONST.INC'
C
      L0=NOWT
      M0=NOWT
      N0=0
      RETURN
      END
C
CODE FOR XSSL
      SUBROUTINE XSSL(NFL,LFL,NUL)
C--SET THE STORE LIMITS - THIS SUBROUTINE STACKS THE LIMITS AWAY
C
      INCLUDE 'XLIMIT.INC'
C
      NFLMIN=NFL
      LFLMAX=LFL
      NULMAX=NUL
      CALL XRSL
      RETURN
      END
C
CODE FOR XRSL
      SUBROUTINE XRSL
C--RESET THE STORE LIMITS
C
      INCLUDE 'XLIMIT.INC'
      INCLUDE 'STORE.INC'
C
      NFL=NFLMIN
      LFL=LFLMAX
      NUL=NULMAX
      RETURN
      END
C
C --
C
CODE FOR KSTALL
      FUNCTION KSTALL(ISIZE)
C -- ALLOCATES AN AREA OF LENGTH ISIZE IN STORE
C    RETURN VALUE IS START OF ALLOCATED AREA.
C    IF SPACE IS INSUFFICIENT THEN AN ERROR MESSAGE IS PRINTED
C --
      INCLUDE 'STORE.INC'
C --
      IFREE=LFL-NFL
      IF (ISIZE.GT.IFREE) CALL XSTICA (ISIZE,IFREE)
      KSTALL=NFL
      NFL=NFL+ISIZE
      RETURN
      END
C
C --
C
CODE FOR XSTRLL
      SUBROUTINE XSTRLL(IADDR)
C -- MAKES NFL EQUAL TO LOWER OF NFL AND IADDR
C --
      INCLUDE 'STORE.INC'
C --
C -- IF ADDRESS IS LESS THAN OR EQUAL TO ZERO THEN RETURN
      IF (IADDR.LE.0) RETURN
      NFL=MIN0(NFL,IADDR)
      RETURN
      END
C
C --
C
CODE FOR KSTALH
      FUNCTION KSTALH ( ISIZE )
C -- ALLOCATES AN AREA OF LENGTH ISIZE IN STORE
C    RETURN VALUE IS START OF ALLOCATED AREA.
C    IF SPACE IS INSUFFICIENT THEN AN ERROR MESSAGE IS PRINTED
C --
      INCLUDE 'STORE.INC'
C --
      IFREE = LFL - NFL
      IF (ISIZE.GT.IFREE) CALL XSTICA (ISIZE,IFREE)
      LFL = LFL - ISIZE
      KSTALH = LFL + 1
      RETURN
      END
C
C --
C
cCODE FOR XSTRLH
c      SUBROUTINE XSTRLH(IADDR)
cC -- MAKES LFL EQUAL TO HIGHER OF LFL AND IADDR
cC --
c\STORE
cC --
cC -- IF ADDRESS IS LESS THAN OR EQUAL TO ZERO THEN RETURN
c      IF (IADDR.LE.0) RETURN
c      IF (IADDR.GT.65536) RETURN
c      LFL=MAX0(NFL,IADDR)
c      RETURN
c      END

C --
C
CODE FOR XSTICA
      SUBROUTINE XSTICA(ISIZE,IFREE)
C -- PRINTS MESSAGE TO INDICATE INSUFFICIENT CORE
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XOPVAL.INC'
C --
      IFREE = IFREE
C --
      CALL XOPMSG ( IOPCRY , IOPSPC , ISIZE )
C -- DUMMY RETURN
      RETURN
      END
CODE FOR XPRINT
      SUBROUTINE XPRINT(NFW,NLW)
C--CORE PRINT ROUTINES
C
C  NFW  FIRST WORD IN 'STORE' TO BE PRINTED
C  NLW  LAST WORD IN 'STORE' TO BE PRINTED
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
C
      INCLUDE 'QSTORE.INC'
C
C
C
      DATA I/0/,J/0/,K/0/
C
      CALL XLINES
      J=NFW
      IF(NFW-NLW)1000,1000,1200
1000  CONTINUE
      K=J+2
      IF(K-NLW)1050,1150,1150
1050  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1100)J,(STORE(I),ISTORE(I),STORE(I),I=J,K)
      ENDIF
1100  FORMAT(I7,'*',3(3X,A4,I10,E20.10))
      J=J+3
      GOTO 1000
1150  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1100)J,(STORE(I),ISTORE(I),STORE(I),I=J,NLW)
      ENDIF
1200  CONTINUE
      RETURN
      END
C
CODE FOR XMVSPD
      SUBROUTINE XMVSPD(IVALUE,IA,N)
C--DUPLICATE THE VALUE 'IVALUE' OVER THE ARRAY 'IA', STORING IN TOTAL
C  'N' VALUES.
C
C  IVALUE  THE VALUE TO STORE.
C  IA      THE FIRST ARRAY ELEMENT TO BE SET TO 'IVALUE'.
C  N       THE NUMBER OF ARRAY ELEMENTS TO BE SET.
C
C--
C
C
      DIMENSION IA(N)
C
      CALL XFILL(IVALUE,IA(1),N)
      RETURN
C
      END
C
CODE FOR XMVSPF
      SUBROUTINE XMVSPF(VALUE,A,N)
C--DUPLICATE THE VALUE 'VALUE' OVER THE ARRAY 'A', STORING IN TOTAL
C  'N' VALUES.
C
C  VALUE   THE VALUE TO STORE.
C  A       THE FIRST ARRAY ELEMENT TO BE SET TO 'VALUE'.
C  N       THE NUMBER OF ARRAY ELEMENTS TO BE SET.
C
C--
C
C
      DIMENSION A(N)
C
      CALL XFILL(VALUE,A(1),N)
      RETURN
100   CONTINUE
      END

