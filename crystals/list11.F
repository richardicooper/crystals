C $Log: not supported by cvs2svn $
C Revision 1.6  2008/12/15 14:57:44  djw
C Move List 11 error messages into XFAL11 itself
C
C Revision 1.5  2005/01/23 08:29:11  rich
C Reinstated CVS change history for all FPP files.
C History for very recent (January) changes may be lost.
C
C Revision 1.1.1.1  2004/12/13 11:16:09  rich
C New CRYSTALS repository
C
C Revision 1.4  2004/09/29 10:03:25  rich
C Removed unnecessary assignment to a dummy variable. (Would crash program if
C arguments to routine were constants.)
C
C Revision 1.3  2001/02/26 10:26:49  richard
C Added changelog to top of file
C
C
CODE FOR XPR11C
      SUBROUTINE XPR11C
C--PRINT THE LATEST LIST 11 AS A CORRELATION MATRIX.
C
C--
C
      CHARACTER*16 FORM1
      CHARACTER*12 FORM2
C
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
C
C
      DATA FORM1 / '(I6,2X,20F7.3)' /
      DATA FORM2 / '(/7X,20I7)' /
C
      DATA NCOL/16/
C
C--CHECK THAT THE LIST MAY BE PRINTED AND THEN LOAD IT
      I=11
      IF(KPRTLN(I,J))1000,1050,1050
C--LIST 11 IS NOT AVAILABLE
1000  CONTINUE
      CALL XLINES
      GOTO 1150
C--CLEAR THE STORE ALLOCATION
1050  CONTINUE
      CALL XCSAE
      CALL XRSL
C--PRINT AN INITIAL CAPTION
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1100)
      ENDIF
1100  FORMAT(/,' Print List 11 as correlation matrix')
C--LOAD LIST 12 TO PRESENT THE BLOCKING DATA
      JQ=0
      JS=-1
      CALL XFAL12(JS,JQ,JR,JN)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--LOAD LIST 11
      CALL XFAL11(1,1)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--PRINT THE MATRIX TYPE
      CALL XTYP11
C--FORM THE CORRELATION MATRICES
      CALL XFCM
C--PRINT THE RESULTANT MATRICES
      CALL XPRTNM ( NCOL , FORM1 , FORM2 )
C--AND NOW RETURN
1150  CONTINUE
C -- ERROR AND GENERAL RETURN
9900  CONTINUE
      RETURN
      END
C
CODE FOR XPR11N
      SUBROUTINE XPR11N
C--PRINT THE LATEST LIST 11 AS IT IS STORED.
C
C--
C
      CHARACTER*16 FORM1
      CHARACTER*12 FORM2
      CHARACTER*16 FORM3
C
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
C
      DATA FORM1 / '(I6,2X,10E14.5)' /
      DATA FORM2 / '(/ 2X,10I14)' /
      DATA FORM3 / '(// 8X,10E14.5)' /
      DATA NCOL/8/
C
C--CHECK THAT THE LIST CAN LOADED AND THEN BRING IT DOWN
      I=11
      IF(KPRTLN(I,J))1000,1050,1050
C--LIST 11 CANNOT BE PRINTED
1000  CONTINUE
      CALL XLINES
      GOTO 1100
C--CLEAR THE SORE ALLOCATION
1050  CONTINUE
      CALL XCSAE
      CALL XRSL
C--LOAD LIST 12 FOR THE BLOCKING DATA
      JQ=0
      JS=-1
      CALL XFAL12(JS,JQ,JR,JN)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--LOAD LIST 11
      CALL XFAL11(1,1)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--PRINT THE MATRIX TYPE
      CALL XTYP11
C--PRINT THE LEFT HAND SIDE
      CALL XPRTNM ( NCOL , FORM1 , FORM2 )
C--PRINT THE RIGHT HAND SIDE
      CALL XPRTMV ( NCOL , FORM3 , FORM2 )
C--AND NOW RETURN
1100  CONTINUE
C -- ERROR AND GENERAL RETURN
9900  CONTINUE
      RETURN
      END
C
CODE FOR XPR11L
      SUBROUTINE XPR11L(CHOP)
C--PRINT ELEMENTS ABOVE A CERTAIN VALUE FROM THE CORRELATION MATRIX.
C
C  CHOP    THE LEVEL ABOVE WHICH A CORRELATION COEFFICIENT MUST BE
C          FOR IT TO BE PRINTED.
C
C--
      PARAMETER ( NAMELN = 24 )
      PARAMETER ( LOVER = 10 , NOVER = 6 )
      PARAMETER ( LATOMP = 8 , NATOMP = 13 )
C
      CHARACTER*132 CLINE1 , CLINE2
C
      CHARACTER*(LOVER) COVER(NOVER)
      CHARACTER*(LATOMP) CATOMP(NATOMP)
      INCLUDE 'TYPE11.INC'
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XSTR11.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST11.INC'
      INCLUDE 'XLST12.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QSTR11.INC'
      SAVE LSORT, MSORT, NSORT, MDSORT, JPOS, ITEM, XVALUE
C
      DATA COVER  / '   SCALE' , ' DU[ISO]' , ' OU[ISO]' ,
     2              'POLARITY' , ' ENANTIO' , 'EXTPARAM' /
      DATA CATOMP / ' ' , ' ' , '   OCC  ' , ' U[ISO] ' ,
     2 '    X   ' , '    Y   ' , '    Z   ' ,
     3 '  U[11] ' , '  U[22] ' , '  U[33] ' ,
     4 '  U[23] ' , '  U[13] ' , '  U[12] ' /
C
C
C--CHECK IF THE LIST CAN BE LOADED FOR PRINTING
      I=11
      IF(KPRTLN(I,J))1550,1000,1000
C--PRINT AN INITIAL CAPTION
1000  CONTINUE
1050  FORMAT(' Correlation coefficients greater than',F10.5)
C--CLEAR THE STORE
      CALL XCSAE
      CALL XRSL
C--ALLOCATE A BUFFER SPACE
      NW=3
      NP=4
      LN=11
      IREC=1001
      ITEMP=KCHLFL(NW*NP)
C^ NOV 98
C----- INITIALISE THE BUFFER before everything else loaded
      JPOS = -2
      MDSORT = 11
C----- INITIALISE NSORT TO AN EVEN NUMBER
      NSORT = 10
      ITEM = 0
      CALL SRTDWN(LSORT,MDSORT,NSORT, JPOS, ITEM, XVALUE,0)
      JPOS = 2
      NFLSRT = NFL
C^ NOV 98
C--LOAD LIST 12
      JQ=0
      JS=-1
      CALL XFAL12(JS,JQ,JR,JN)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--LOAD LIST 11
      CALL XFAL11(1,1)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--PRINT THE MATRIX TYPE
      CALL XTYP11
C--FORM THE CORRELATION MATRIX
      CALL XFCM
C--SET THE INITIAL ADDRESS
      M=ITEMP-NW
      N=0
C--AN INITIAL HEADING
      CALL XLINES
      WRITE(NCAWU,1050) CHOP
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU ,1050) CHOP
      ENDIF
C--LOOP OVER EACH MATRIX BLOCK
      M12B=L12B
      M11=L11
      DO 1450 I=1,N12B
      NA=ISTORE(M12B+1)
      NB=ISTORE(M12B)
C--LOOP OVER EACH ROW OF THE CURRENT MATRIX
      DO 1400 J=1,NA
      NC=NB
C--LOOP OVER EACH COLUMN OF THE CURRENT BLOCK
      DO 1350 K=J,NA
C--CHECK THE VALUE
      IF(ABS(STR11(M11))-CHOP)1300,1300,1100
C--CHECK IF THIS IS THE DIAGONAL ELEMENT  -  TO BE REJECTED
1100  CONTINUE
      IF(NC-NB)1150,1300,1150
C--NOT THE DIAGONAL  -  STORE THE VALUE
1150  CONTINUE
      M=M+NW
C--STORE THE PARAMETER NUMBERS AND THE VALUE
      ISTORE(M)=NB
      ISTORE(M+1)=NC
      STORE(M+2)=STR11(M11)
      IF (ABS(STORE(M+2)) .GE. ABS(XVALUE))
     1 CALL SRTDWN(LSORT,MDSORT,NSORT, JPOS, M, XVALUE,0)
C--INCREMENT THE NUMBER STORED
      N=N+1
C--CHECK IF WE SHOULD PRINT SOME
      IF(N-NP)1300,1200,1200
C--PRINT THE LATEST FOUND
1200  CONTINUE
      IF (ISSPRT .EQ. 0)
     1 WRITE(NCWU,1251)(ISTORE(N),ISTORE(N+1),STORE(N+2),N=ITEMP,M,NW)
      WRITE(NCAWU,1251)(ISTORE(N),ISTORE(N+1),STORE(N+2),N=ITEMP,M,NW)
1250  FORMAT(4 (I5,' &',I5,' =',F4.1,','))
1251  FORMAT(6 (I5,' &',I5,' =',F5.2,','))
      N=0
      M=ITEMP-NW
C--MOVE TO THE NEXT MATRIX ELEMENT ON THIS ROW
1300  CONTINUE
      M11=M11+1
      NC=NC+1
C--CHANGE ROWS
1350  CONTINUE
      NB=NB+1
C--CHANGE BLOCKS
1400  CONTINUE
      M12B=M12B+MD12B
C--CHECK FOR SOME OUTSTANDING ENTRIES TO BE PRINTED
1450  CONTINUE
      IF(N)1550,1550,1500
1500  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1251)(ISTORE(N),ISTORE(N+1),STORE(N+2),N=ITEMP,M,NW)
      ENDIF
      WRITE(NCAWU,1251)(ISTORE(N),ISTORE(N+1),STORE(N+2),N=ITEMP,M,NW)
1550  CONTINUE
      CALL XLINES
C----- RESTORE THE BUFFER AND OFFSET
C^ NOV 98
c^      CALL XCSAE
c^      CALL XRSL
c^      NFL = KCHNFL(LSORT + NSORT*MDSORT +1)
c      goto 9000
c-- reinstate >
      CALL XCSAE
      CALL XRSL
      NFL = KCHNFL(LSORT + NSORT*MDSORT +1)
c --  nov98   <
C----- PRINT BUFFER OF MAXIMUM CORRELATIONS
C----- RELOAD THE LISTS
      CALL XFAL05
      IF ( IERFLG .LT. 0 ) GO TO 9900
      i = 0
      j = 0
      CALL XFAL12(i, j, jr, jn)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C
C----- LOOP OVER LIST 5 AND 12
      M12=L12O
      M5 = L5
      J = 0
C
      NATOM = N5 + 1
      NLAYER = NATOM + 1
      NELEM = NLAYER + 1
      NBATCH = NELEM + 1
      NCELL = NBATCH + 1
      NPROF = NCELL + 1
      NEXTI = NPROF + 1
C -- PASS THROUGH THE GROUPS
C
3250  CONTINUE
C
      L12A = ISTORE(M12+1)
      CLINE1 = ' '
      J = J + 1
C
C -- ASSIGN A NAME TO THIS GROUP
      IF ( J .EQ. 1 ) THEN
        CLINE1(1:NAMELN) = 'Overall '
      ELSE IF ( J .LE. NATOM ) THEN
        WRITE (CLINE1(1:NAMELN),'(A4,I6)')ISTORE(M5),NINT(STORE(M5+1))
        M5 = M5 + MD5
      ELSE IF ( J .EQ. NLAYER ) THEN
        CLINE1(1:NAMELN)  = 'Layers '
      ELSE IF ( J .EQ. NBATCH ) THEN
        CLINE1(1:NAMELN) = 'Batches '
      ELSE IF ( J .EQ. NELEM ) THEN
        CLINE1(1:NAMELN) = 'Element  '
      ELSE IF ( J .EQ. NCELL ) THEN
        CLINE1(1:NAMELN) = 'Cell param'
      ELSE IF ( J .EQ. NPROF ) THEN
        CLINE1(1:NAMELN) = 'Profile '
      ELSE IF ( J .EQ. NEXTI ) THEN
        CLINE1(1:NAMELN) = 'Extinction '
      ENDIF
C
      IPOS = NAMELN + 1
      IF ( L12A .LE. 0 ) GO TO 3050
C
C -- PASS THROUGH THE INDIVIDUAL PARTS FOR EACH GROUP
      ICOMP = ISTORE(L12A)
3350  CONTINUE
C
      MD12A=ISTORE(L12A+1)
      M12A=ISTORE(L12A+2)
      L=ISTORE(L12A+3)
      NUNREF = ISTORE(L12A+4)
C
      ICOORD = NUNREF + 1
      DO 3400 I = M12A , L , MD12A
      IF ( ISTORE(I) .GT. 0 ) THEN
C----- LOOP OVER BUFFER PREPARING TEXTUAL TABLE
        MSORT = LSORT
        DO 4000 II = 1,NSORT
          IHIT = 0
          IF(ABS(STORE(MSORT+JPOS)) .GT. 0.0) THEN
C            COMPUTE OFFSET IN BUFFER
            IF  (ISTORE(MSORT) .EQ. ISTORE(I)) THEN
                  IHIT = 1
            ELSE IF (ISTORE(MSORT+1) .EQ. ISTORE(I)) THEN
                  IHIT = 5
            ENDIF
            IF (IHIT .GT. 0) THEN
            CLINE2 = ' '
C---          WE HAVE A GOODY
              IF (J .EQ. 1) THEN
C               OVERALL
                WRITE(CLINE2,10) CLINE1(1:NAMELN), COVER(ICOORD)
              ELSE IF (J .LE. NATOM) THEN
C               AN ATOM
                WRITE(CLINE2,10) CLINE1(1:NAMELN), CATOMP(ICOORD)
              ELSE
C               SOME KIND OF SCALE FACTOR
                WRITE(CLINE2,10) CLINE1(1:NAMELN), 'No ', ICOORD
              ENDIF
10          FORMAT(1X, A, 1X, A, I6)
            CALL XCREMS( CLINE2, CLINE2, NCHAR)
            READ (CLINE2, '(4A4)') (STORE(MSORT+2+JJ),JJ=IHIT,IHIT+3)
            ENDIF
          ENDIF
          MSORT = MSORT + MDSORT
C----     END LOOP FOR BUFFER
4000    CONTINUE
C
      END IF
      ICOORD = ICOORD + 1
3400  CONTINUE
C
      IPOS = NAMELN + 1
      CLINE1(ipos:) = ' '
C
C -- INCREMENT TO THE NEXT PART
      L12A = ISTORE(L12A)
C
C -- CHECK IF THERE IS ANOTHER PART
      IF ( L12A .GT. 0 ) GO TO 3350
C
C -- INCREMENT TO THE NEXT ATOM
3050  CONTINUE
      M12=ISTORE(M12)
      IF ( M12 .GT. 0 ) GO TO 3250
C
      IF (ABS(STORE(LSORT+2)) .GT. ZERO) THEN
            IF (ISSPRT .LE. 0) WRITE(NCWU,24) CHOP
24    FORMAT (10X,' Largest Correlations over ', F5.2)
            WRITE(NCAWU,24) CHOP
            WRITE ( CMON, 24) CHOP
            CALL XPRVDU(NCVDU, 1,0)
C----- PRINT PART OF BUFFER CONTAINING INFORMATION
            MSORT = LSORT
            DO 22 I = 1, NSORT
C----- CHECK NEXT ELEMENT IS NOT 0.
      IF (ABS(STORE(MSORT+2)) .LE. ZERO) GOTO 25
            WRITE(NCAWU,23)
     1 ISTORE(MSORT), ISTORE(MSORT+1), STORE(MSORT+2),
     2 (ISTORE(J),J=MSORT+3, MSORT+10)
            IF (ISSPRT .LE. 0) WRITE(NCWU,23)
     1 ISTORE(MSORT), ISTORE(MSORT+1), STORE(MSORT+2),
     2 (ISTORE(J),J=MSORT+3, MSORT+10)
            WRITE(CMON,23)
     1 ISTORE(MSORT), ISTORE(MSORT+1), STORE(MSORT+2),
     2 (ISTORE(J),J=MSORT+3, MSORT+10)
            CALL XPRVDU(NCVDU, 1,1)
23    FORMAT (2(2I5,F8.3, 1X, 4A4, 1X, 4A4))
            MSORT = MSORT + MDSORT
22    CONTINUE
25    CONTINUE
            WRITE(CMON, '(1X)')
            CALL XPRVDU(NCVDU, 1,0)
      ENDIF
C
9000  CONTINUE
      RETURN
C -- ERROR AND GENERAL RETURN
9900  CONTINUE
      END
C
CODE FOR XTYP11
      SUBROUTINE XTYP11
C--PRINT THE TYPE OF THE MATRIX
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLST11.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CHECK THE TYPE OF THE MATRIX
      IF (ISTORE(L11P+15)) 1000, 1000, 1100
C--INVERSE MATRIX
1000  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1050)
      ENDIF
1050  FORMAT(' Inverse matrix')
      GOTO 1200
C--NORMAL MATRIX
1100  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1150)
      ENDIF
1150  FORMAT(' Normal matrix')
1200  CONTINUE
      RETURN
      END
C
CODE FOR XFCM
      SUBROUTINE XFCM
C--FORM THE CORRELATION MATRIX  -  LIST 11 IS ALREADY IN STORE
C
C--
      INCLUDE 'TYPE11.INC'
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XSTR11.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLST11.INC'
      INCLUDE 'XLST12.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QSTR11.INC'
C
C--SET THE POINTERS TO THE START OF THE L.H.S. AND BLOCKING DATA
      M11=L11
      M12B=L12B
C--ALLOCATE A TEMPORARY STORAGE AREA
      LN=11
      IREC=1001
      ITEMP=KCHLFL(N11R)
C--COMPUTE THE MULTIPLIER FOR E.S.D.'S
      B=SQRT(STORE(L11P+17)/STORE(L11P+16))
C--CYCLE BY BLOCKS
      DO 1300 I=1,N12B
      N=ISTORE(M12B+1)
      L=M11
      K=ITEMP
C--STORE 1./SQRT(A[I,I])
      DO 1150 J=1,N
C--CHECK FOR SINGULARITIES
      STORE(K)=SQRT(STR11(L))
      IF(STORE(K)*B-0.0000001)1000,1050,1050
C--SINGULAR
1000  CONTINUE
      STORE(K)=0.
      GOTO 1100
C--COMPUTE THE INVERSE OF THE DIAGONAL ELEMENT
1050  CONTINUE
      STORE(K)=1./STORE(K)
1100  CONTINUE
      K=K+1
      L=L+N-J+1
1150  CONTINUE
      M=M11
      L=ITEMP
C--PASS THROUGH THE MATRIX
      DO 1250 J=1,N
      NX=L
      DO 1200 K=J,N
      STR11(M)=STR11(M)*STORE(L)*STORE(NX)
      M=M+1
      NX=NX+1
1200  CONTINUE
      L=L+1
1250  CONTINUE
      M11=M11+(N*(N+1))/2
      M12B=M12B+MD12B
1300  CONTINUE
      RETURN
      END
C
CODE FOR XPRTNM
      SUBROUTINE XPRTNM ( NCOL , FORM1 , FORM2 )
C--PRINT THE NORMAL MATRIX AS STORED
C
C--
      INCLUDE 'TYPE11.INC'
C
      CHARACTER*(*) FORM1 , FORM2
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XSTR11.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLST11.INC'
      INCLUDE 'XLST12.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QSTR11.INC'
C
C--FIND THE BLOCKING AND MATRIX ADDRESSES
      M12B=L12B
      M11=L11
C--SET UP A TEMORARY STORAGE LOCATION
      LN=11
      IREC=1001
      ITEMP=KCHLFL(N11R)
C--CYCLE BY BLOCKS
      DO 1450 I=1,N12B
      NA=1
      NB=ISTORE(M12B+1)
      NH=ISTORE(M12B)
      NF=NCOL
      NP=M11
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1000)I
      ENDIF
1000  FORMAT(/,' Block',I5/)
C--COME BACK FOR MORE
1050  CONTINUE
      NQ=NP
      NR=NH
      DO 1200 J=NA,NB
      NG=J-1
      NC=NQ+NG
      ND=ITEMP-1
      NE=MIN0(NF,J)
C--EXTRACT THE ELEMENTS ALONG A COLUMN AND PRINT AS A ROW
      DO 1100 K=NA,NE
      ND=ND+1
      STORE(ND)=STR11(NC)
      NC=NC+NB-K
1100  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,FORM1)NR,(STORE(K),K=ITEMP,ND)
      ENDIF
      NR=NR+1
      IF(NG-NF)1200,1150,1200
1150  CONTINUE
      NP=NC-NG
1200  CONTINUE
      ND=ITEMP-1
      NG=NH
      DO 1250 K=NA,NE
      ND=ND+1
      ISTORE(ND)=NG
      NG=NG+1
1250  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,FORM2)(ISTORE(K),K=ITEMP,ND)
      ENDIF
      NA=NA+NCOL
C--CHECK IF MORE TO DO
      IF(NB-NA)1400,1300,1300
1300  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1350)I
      ENDIF
1350  FORMAT(/,' Continuation for block',I5/)
      NF=NF+NCOL
      NH=NH+NCOL
      GOTO 1050
1400  CONTINUE
      M11=M11+(NB*(NB+1))/2
      M12B=M12B+MD12B
1450  CONTINUE
      CALL XLINES
      RETURN
      END
C
CODE FOR XPRTMV
      SUBROUTINE XPRTMV ( NCOL , FORM1 , FORM2 )
C--PRINT THE MATRIX VECTOR  -  I.E. THE LEFT HAND SIDE
C
C--
      INCLUDE 'TYPE11.INC'
C
      CHARACTER*(*) FORM1 , FORM2
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XSTR11.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLST11.INC'
      INCLUDE 'XLST12.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QSTR11.INC'
C
C--SET UP A TEMPORARY STORAGE LOCATION
      LN=11
      IREC=1001
      ITEMP=KCHLFL(N11R)
C--FIND THE ADDRESS OF THE R.H.S.
      M11R=L11R
      NA=1
      NB=N12
      NC=NCOL
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1000)
      ENDIF
1000  FORMAT(/,' Print the right hand side')
C--COME ROUND AGAIN
1050  CONTINUE
      ND=MIN0(NB,NC)
C--COMPUTE THE LAST PRINT ADDRESS
      NF=ITEMP+ND-NA
C--FETCH THE WORDS
      DO 1100 NE=ITEMP,NF
      STORE(NE)=STR11(M11R)
      M11R=M11R+1
1100  CONTINUE
C--PRINT THIS LINE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,FORM1)(STORE(NE),NE=ITEMP,NF)
      ENDIF
C--ACCUMULATE THE PARAMETER NUMBERS
      NF=ITEMP-1
      DO 1150 I=NA,ND
      NF=NF+1
      ISTORE(NF)=I
1150  CONTINUE
C--WRITE THE PARAMETER NUMBERS
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,FORM2)(ISTORE(NE),NE=ITEMP,NF)
      ENDIF
C--UPDATE THE PARAMETER COUNTERS
      NA=NA+NCOL
      NC=NC+NCOL
C--CHECK FOR END OF PARAMETERS
      IF(NA-NB)1050,1050,1200
1200  CONTINUE
      CALL XLINES
      RETURN
      END
C
CODE FOR XSET11
      SUBROUTINE XSET11(IOLD,ILHS,IRHS)
C--SET UP LIST 11
C
C--THIS LINK LOADS A LIST 11 INTO STORE FROM THE DISC
C  AND PREPARES IT FOR SUBSEQUENT REWRITING BE 'XCL11' OR
C  ALTERNATIVELY SETS UP A NEW LIST 11 READY FOR USE AND THEN
C  OUTPUT
C
C  IOLD    THIS INDICATES THE ORIGIN OF THE MATRIX :
C
C          -1  CREATE A NEW MATRIX.
C           0  LOAD THE OLD MATRIX FROM THE DISC.
C
C  ILHS    THIS INDICATES WHETHER THE LEFT HAND SIDE IS TO BE LOADED :
C
C          0  DO NOT LOAD THE L.H.S. FROM DISC.
C          1  THE L.H.S. IS REQUIRED.
C
C  IRHS    THIS INDICATES WHETHER THE RIGHT HAND SIDE IS TO BE LOADED, I
C          THE SAME WAY AS FOR 'ILHS'.
C
C--USEAGE OF VARIABLES :
C
C  L11    ADDRESS OF THE LEFT HAND SIDE IF NEEDED
C  N11    LENGTH OF THE LEFT HAND SIDE
C
C  L11R   ADDRESS OF THE RIGHT HAND SIDE
C  N11R   LENGTH OF THE RIGHT HAND SIDE
C
C  L11P   ADDRESS OF THE PREAMBLE BLOCK
C  N11P   LENGTH OF THE PREAMBLE BLOCK
C
C  L11IR  THE ADDRESS OF THE INTER-DEPENDENCIES RECORD.
C
C--
      INCLUDE 'TYPE11.INC'
      INCLUDE 'ICOM11.INC'
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XSTR11.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLST11.INC'
      INCLUDE 'XLST12.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QSTR11.INC'
      INCLUDE 'QLST11.INC'
C
      CALL XIN11
C--SET THE LIST TYPE
      IULN=11
C--CHECK IF THE OLD MATRIX SHOULD BE BROUGHT DOWN
      IF(IOLD)1100,1000,1000
C--BRING DOWN THE OLD MATRIX
1000  CONTINUE
      CALL XFAL11(ILHS,IRHS)
C--RETURN
1050  CONTINUE
      RETURN
C
C--SET UP A NEW MATRIX
1100  CONTINUE
c      IOLD=-1
      INCLUDE 'IDIM11.INC'
C--ZERO THE LIST 11 COMMON BLOCK
      CALL XZEROF(ICOM11,IDIM11)
C--CALCULATE THE SIZE OF THE L.H.S.
      N11=0
      M12B=L12B
      DO 1150 I=1,N12B
      N11=N11+((ISTORE(M12B+1)+1)*ISTORE(M12B+1))/2
      M12B=M12B+MD12B
1150  CONTINUE
C--ASSIGN THE SIZE OF THE R.H.S.
      N11R=N12
C--CREATE THE LIST
      CALL XCELST(IULN,ICOM11,IDIM11)
C--CREATE THE L.H.S. IN CORE
      L11=KADD11(-101,MD11,N11)
      IF ( IERFLG .LT. 0 ) GO TO 1050
C--SET UP THE R.H.S.
      L11R=KADD11(-102,MD11R,N11R)
      IF ( IERFLG .LT. 0 ) GO TO 1050
C--ZERO THE PREAMBLE BLOCK
      CALL XZEROF(STORE(L11P),MD11P*N11P)
C--SET UP A FEW CONSTANTS
      ISTORE(L11P+15)=1
      ISTORE(L11P+19)=1
      ISTORE(L11P+21)=1
      GOTO 1050
      END
C
CODE FOR XCL11
      SUBROUTINE XCL11(IN)
C--COMPLETE LIST 11  -  REMOVES THE MATRIX FROM CORE.
C
C--THE MATRIX MUST HAVE ALREADY BEEN SET UP BY 'XFAL11' OR 'XSET11'.
C
C--THIS ROUTINE WRITES LIST 11 TO DISC. IF EITHER THE
C  L.H.S. OR R.H.S. HAS NOT BEEN LOADED INTO CORE, THEN THE
C  CORRESPONDING SIDE IS NOT WRITTEN TO DISC.
C
C--THE PARTS THAT HAVE BEEN SET UP IN CORE ARE INDICATED BY THE
C  VALUES OF THE RELEVANT BASE ADDRESSES.
C  IF 'L11' OR 'L11R' ARE NEGATIVE, THE CORRESPONDING SIDE OF THE
C  LIST IS ASSUMED NOT TO BE IN STORE.
C  THE PREAMBLE BLOCK IS ALWAYS ASSUMED TO BE IN STORE.
C
C--
      INCLUDE 'TYPE11.INC'
      INCLUDE 'ISTORE.INC'
      INCLUDE 'ICOM11.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XSTR11.INC'
      INCLUDE 'XLST11.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XLSVAL.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QSTR11.INC'
      INCLUDE 'QLST11.INC'
C
      IDWZAP = IN
C--PRESERVE THE CORE ADDRESSES OF THE L.H.S. AND R.H.S
      L11C=L11
      L11RC=L11R
C--SET THE LIST TYPE
      IULN=11
      INCLUDE 'IDIM11.INC'
C--CREATE A NEW LIST 11 ON DISC
C -- CHECK THAT A LIST 11 EXISTS, AND IF IT DOES MARK FOR UPDATE
      ISTAT = KLSCHK ( IULN , 0 , 0 , ILSEXI , ILSNMS , I , IERNOP )
      IF ( ISTAT .GT. 0 ) CALL XLSALT ( IULN , 0 , 0 , ILSOWF , ILSUPD )
      CALL XWLSTD(IULN,ICOM11,IDIM11,-1,0)
C--CHECK IF THE L.H.S. NEDS TO BE OUTPUT
      IF(L11C)1050,1050,1000
C--OUTPUT THE L.H.S.
1000  CONTINUE
      CALL XUPF (L11, XSTR11 (MD11*L11C-MD11+1), MD11*N11)
C--CHECK IF THE R.H.S. NEEDS TO BE OUTPUT
1050  CONTINUE
      IF(L11RC)1150,1150,1100
C--OUTPUT THE R.H.S.
1100  CONTINUE
      CALL XUPF (L11R, XSTR11 (MD11R*L11RC-MD11R+1), MD11R*N11R)
C--RESTORE THE CORE POINTERS
1150  CONTINUE
      L11=L11C
      L11R=L11RC
      RETURN
      END
C
CODE FOR XFAL11
      SUBROUTINE XFAL11(ILHS,IRHS)
C--LOAD LIST 11 INTO STORE
C
C  ILHS    THIS INDICATES IF THE L.H.S. IS REQUIRED IN CORE :
C
C          0  DO NOT LOAD THE L.H.S. INTO CORE.
C          1  LOAD THE L.H.S. INTO CORE.
C
C  IRHS    THIS INDICATES IF THE R.H.S. IS REQUIRED IN CORE, IN THE SAME
C          AS FOR 'ILHS'.
C
C--IF A GIVEN PART IS NOT LOADED, ITS POINTER IS SET TO 'NOWT'.
C
C--
      INCLUDE 'TYPE11.INC'
      INCLUDE 'ICOM11.INC'
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XSTR11.INC'
      INCLUDE 'XLST11.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QSTR11.INC'
      INCLUDE 'QLST11.INC'
C
      CALL XIN11
C--SET THE LIST TYPE
      IULN=11
      INCLUDE 'IDIM11.INC'
C--LOAD THE LIST FROM THE DISC
      CALL XLDLST(IULN,ICOM11,IDIM11,0)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--CHECK IF THE L.H.S. SHOULD BE LOADED
      IF(ILHS)1000,1000,1050
C--DO NOT LOAD THE L.H.S.
1000  CONTINUE
      L11=NOWT
      GOTO 1100
C--LOAD THE L.H.S.
1050  CONTINUE
      M11=L11
      L11=KADD11(-101,MD11,N11)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--BRING DOWN THE DATA
      CALL XDOWNF (M11, XSTR11 (MD11*L11-MD11+1), MD11*N11)
C--CHECK IF THE R.H.S. SHOULD BE BROUGHT DOWN
1100  CONTINUE
      IF(IRHS)1150,1150,1200
C--DO NOT LOAD THE R.H.S.
1150  CONTINUE
      L11R=NOWT
      GOTO 1250
C--LOAD THE R.H.S.
1200  CONTINUE
      M11R=L11R
      L11R=KADD11(-102,MD11R,N11R)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--BRING DOWN THE DATA
      CALL XDOWNF (M11R, XSTR11 (MD11R*L11R-MD11R+1), MD11R*N11R)
C--AND NOW RETURN
1250  CONTINUE
      RETURN
C
9900  CONTINUE
C -- ERROR EXIT
        IF ( IERFLG .LT. 0 ) THEN
           IF (ISSPRT .EQ. 0) WRITE(NCWU,1405)
           WRITE ( CMON ,1405)
           CALL XPRVDU(NCVDU, 3,0)
1405       FORMAT(
     1     'The covariance matrix does not correspond to the atom list'/
     2     'You have changed LIST 12 or LIST 5'/
     3     'You must do another cycle of refinement')
        ENDIF
      RETURN
      END
C
CODE FOR KADD11
      FUNCTION KADD11(IUREC,MD11,N11)
C--ALLOCATE AND ZERO SPACE FOR LIST 11
C
C  IUREC   THE RECORD NUMBER OF THE AREA TO BE CREATED
C  MD11    THE NUMBER OF WORDS PER ELEMENT OF LIST 11.
C          (THIS IS ONE NORMALLY, BUT WOULD BE 2 IF THE LIST 11
C           MATRIX WAS IN DOUBLE PRECISION.)
C  N11     THE NUMBER OF ELEMENTS TO BE CREATED.
C
C--THE RETURN ADDRESS IS THE LOCATION OF THE FIRST ELEMENT CREATED.
C
C--
      INCLUDE 'TYPE11.INC'
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XSTR11.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QSTR11.INC'
C
C
      DATA NNW/8/
C
C--SET THE LIST AND RECORD TYPES
      LN=11
      IREC=IUREC
C--MAKE SPACE
      LFLD=LFLD-N11-NNW
      I=NFLD-LFLD
C--CHECK THE CORE OVERFLOW SITUATION FOR LIST 11
      IF(I)1200,1200,1000
C--NOT ENOUGH CORE
1000  CONTINUE
      CALL XERHDR(0)
      IF (ISSPRT .EQ. 0) THEN
            WRITE(NCWU,1100) IUREC
            WRITE(NCWU,1101) I, NULD
      ENDIF
      WRITE(NCAWU,1100) IUREC
      WRITE(NCAWU,1101) I, NULD

      WRITE ( CMON, 1100) IUREC
      CALL XPRVDU(NCVDU, 1,0)
      WRITE ( CMON, 1101) I, NULD
      CALL XPRVDU(NCVDU, 2,0)
1100  FORMAT(2X,
     2 'Insufficient memory allocated for LIST 11, Record number ', I5)
1101  FORMAT(I10,' words needed.'/, ' Too many for this',
     2 ' compilation of CRYSTALS (max = ', I10,')', /,
     3 ' Define a smaller matrix in LIST 12' )
      CALL XERHND ( IERERR )
C**** Clean exit forced, L. Macko
      KADD11=0
CE***
      RETURN
C--SET THE RETURN VALUE
1200  CONTINUE
      I=LFLD+1
C--ZERO THE AREA SET UP
      CALL XZEROF (XSTR11 (MD11*I-MD11+1), MD11*(N11+NNW))
C--AND NOW RETURN
      KADD11=I
      RETURN
      END
C
CODE FOR XIN11
      SUBROUTINE XIN11
C--INITIALISE THE CORE CONTROL FOR LIST 11
C
C--
      INCLUDE 'TYPE11.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XSTR11.INC'
      INCLUDE 'XSIZES.INC'
      INCLUDE 'XSSVAL.INC'
C
      INCLUDE 'QSTR11.INC'
      INCLUDE 'QSIZ11.INC'
C
C--SET THE CONSTANTS
      NFLD=1
      LFLD = ITEMP / ISSL11
      NULD=LFLD-NFLD+1
      RETURN
      END

