CODE FOR XRD06
      SUBROUTINE XRD06(IULN)
C--READ THE PLANES, LIST 6
C
C  IULN    THE LIST TYPE THAT IS BEING INPUT AS A LIST 6.
C
C--THE REFLECTIONS ARE INPUT AND STORED ON M/T. AFTER  THIS, THEY ARE
C  READ BACK AND STORED ON THE DISC.
C
C--
      CHARACTER *80 CFORM
\ISTORE
\ICOM06
\ICOM13
\ICOM30
C
C
      CHARACTER*24 ICAPT
      DIMENSION ICOM6A(79)
      DIMENSION AA(10),YCARD1(82),YCARD2(82),IFORM(40)
      DIMENSION IPARTS(4),ICAD4(11),ISLX(4),JSIGMA(1), JRATIO(1)
      DIMENSION JFOT(1),JFOO(1)
C
\STORE
\XUNITS
\XSSVAL
\UFILE
\XCHARS
\XCARDS
\XCONST
\XLISTI
\XLST01
\XLST06
\XPCK06
\XLST6A
\XLST13
\XLST50
\XLST30
\XTAPES
\XERVAL
\XOPVAL
\XLSVAL
\XIOBUF
C
\QSTORE
\QLST06
C
      EQUIVALENCE (YCARD1(1),IMAGE(1))
      EQUIVALENCE (ICOM6A(1),L6IMP)
\QLST13
\QLST30
C
C
      DATA NCARD/82/
C
      DATA NFORM/41/
C
      DATA ISLX(1)/'(3F4'/,ISLX(2)/'.0,2'/,ISLX(3)/'F8.2'/
      DATA ISLX(4)/')   '/
      DATA LSLX/4/
C
C
      DATA ICAD4(1)/'(5X,'/,ICAD4(2)/'3F4.'/,ICAD4(3)/'0,F9'/
      DATA ICAD4(4)/'.0,F'/,ICAD4(5)/'7.0,'/,ICAD4(6)/'F4.0'/
      DATA ICAD4(7)/',F9.'/,ICAD4(8)/'0,F4'/,ICAD4(9)/'.0,4'/
      DATA ICAD4(10)/'F7.2'/,ICAD4(11)/')   '/
C
      DATA LCAD4/11/
C
      DATA IPARTS(1)/5/,IPARTS(2)/6/,IPARTS(3)/7/,IPARTS(4)/8/
      DATA JSIGMA(1)/12/
      DATA JRATIO / 20 /
      data JFOT(1) / 10 /
      data JFOO(1) / 3 /
C
      DATA ICAPT / 'Observation too small   ' /
C
C--SET THE TIMING FUNCTION
      CALL XTIME1(2)
C--BLANK OUT THE FORMAT ARRAY
      CALL XMVSPD(IB,IFORM(1),NFORM-1)
\IDIM06
C--ASSIGN THE LENGTH OF THE TEMPORARY PART OF THE COMMON BLOCK
      IDIM6A=79
C--SET THE INITIAL FORMAT CONTROL FLAG
      LFORM=1
C--SET UP AN AREA TO HOLD DETAILS OF THE DIRECTIVES FOUND ON INPUT
      LN=IULN
      IREC=1001
      KZ=KCHLFL(NR60)
C--ZERO THIS AREA
      CALL XZEROF(STORE(KZ),NR60)
C--SET UP A COMMON BLOCK FOR INPUT
      KY=IDIM06+IDIM6A
      IREC=1002
      KX=KCHLFL(KY)
C--ZERO THIS COMMON BLOCK
      CALL XZEROF(STORE(KX),KY)
C--INDICATE THAT NO CARDS HAVE BEEN READ
      NCARDS=0
C--INDICATE THAT WE ARE POCESSING NO DIRECTIVE
      IDIR=-1
C--READ THE NEXT DIRECTIVE CARD FROM THE INPUT STREAM
1000  CONTINUE
      LAST=IDIR
      IDIR=KRDNDC(ISTORE(KX),KY)
C--CHECK THE REPLY
      IF(IDIR)1550,1050,1100
C--CONTINUATION CARD  -  RESET THE POINTER
1050  CONTINUE
      IDIR=LAST
      GOTO 1150
C--NEW DIRECTIVE  -  INDICATE THAT IT HAS BEEN INPUT
1100  CONTINUE
      I=KZ+IDIR
      ISTORE(I-1)=1
C--CHECK FOR A 'FORMAT' DIRECTIVE
1150  CONTINUE
      IF(IDIR-5)1450,1200,1450
C--FORMAT STATEMENT  -  FIND THE KEYWORD/FORMAT EXPRESSION
1200  CONTINUE
      IDWZAP = 0
      IF(KFNDNP(IDWZAP))1000,1000,1250
C--COMPUTE THE LENGTH OF DATA ON THIS CARD
1250  CONTINUE
      M=LFORM
      N=LASTCH-NC+1
C--COMPUTE THE NEW MAXIMUM LENGTH OF THE FORMAT
      LFORM=LFORM+(N+NWCHAR-1)/NWCHAR
C--CHECK FOR OVERFLOW OF THE FORMAT AREA
      IF(LFORM-NFORM)1400,1400,1300
C--FORMAT STATEMNT IS TOO LONG
1300  CONTINUE
      CALL XMONTR(0)
      CALL XERHDR(0)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1350)
      ENDIF
1350  FORMAT(' Format statement is too large')
      GOTO 7450
C--STORE THE NEW FORMAT OR PART OF FORMAT
1400  CONTINUE
      CALL XFA4CS(IMAGE(NC),IFORM(M),N)
C--UPDATE THE POINTERS
      NC=LASTCH+1
      GOTO 1000
C--NORMAL DIRECTIVE TO BE INPUT  -  FIND THE KEYWORD
1450  CONTINUE
      IDWZAP = 0
      IF(KFNDNP(IDWZAP))1000,1000,1500
C--READ THE VALUE
1500  CONTINUE
      IF(KRDPV(ISTORE(KX),KY))1000,1450,1450
C
C--END OF THE DIRECTIVES  -  CHECK FOR ERRORS DURING THE INPUT
1550  CONTINUE
      LN=IULN
      IF(LEF)7450,1600,7450
C--PRESERVE THE CARD INPUT COMMON BLOCK
1600  CONTINUE
      CALL XMOVE(YCARD1(1),YCARD2(1),NCARD)
C--SET THE POINTERS READY FOR INPUT
      NC=LASTCH
C--STORE THE LIST 6 PART OF THE COMMON BLOCK
      CALL XMOVEI(ISTORE(KX),ICOM06(1),IDIM06)
C--STORE THE TEMPORARY PART OF THE COMMON BLOCK
      I=KX+IDIM06
      CALL XMOVE(ISTORE(I),ICOM6A(1),IDIM6A)
CDJW DEC97
C ITYPE COPY FIXED FREE COMPRESSED TWIN (HKLI) FIXED FREE COMP
C        1     2    3       4        5           6    7    8
      IF (ITYPE6 .GT. 8) THEN
        WRITE(NCAWU,'('' Invalid READ type'')')
        GOTO 7450
      ENDIF
      IF (ITYPE6 .EQ. 5) THEN
C----- TWINNED DATA - MOVE OVER THE DEFAULT POINTERS
C     L6BMP ETC (TWINNED DEFAULTS) MOVED TO LODFK
      CALL XMOVE(ICOM6A(9), ICOM6A(29),4)
      ENDIF
CDJW DEC97
C--SET THE NUMBER OF REJECTED REFLECTIONS TO ZERO
      N6DEAD=0
      N6NEG=0
C--POINT INITIALLY TO '/FO/'
      IFO=3
C--ZERO THE CORE BUFFER
      M6=L6
      CALL XZEROF(STORE(M6),MD6)
C--BLANK OUT THE CONTROL BLOCK
      CALL XZEROF(STORE(L6P),MD6P*N6P)
C--CHECK IF THE READ KEYS HAVE BEEN INPUT
      IF(ISTORE(KZ+2))1650,1650,1750
C--NO KEYS HAVE BEEN INPUT  -  SET UP THE DEFAULTS
1650  CONTINUE
      MD6IMP=MIN0(MD6IMP,MDIDFK)
C--CHECK THAT THERE ARE SOME NUMBERS TO BE MOVED
      IF(MD6IMP)4550,4550,1700
C--MOVE THE DEFAULT KEYS ACROSS
1700  CONTINUE
      CALL XMOVE(STORE(LIDFK),STORE(L6IMP),MD6IMP)
      GOTO 1800
C--CHECK IF THERE ARE SOME INPUT KEYWORDS
1750  CONTINUE
      IF(MD6IMP)4550,4550,1800
C--CHECK IF THE PHASE HAS BEEN INPUT AS BOSS PHASES REQUIRE CONVERSION
1800  CONTINUE
      KH=KCOMP(1,IPARTS(2),ISTORE(L6IMP),MD6IMP,1)-1
C--CHECK IF THE 'SIGMA' VALUE IS BEING INPUT
      ISIGMA=KCOMP(1,JSIGMA,ISTORE(L6IMP),MD6IMP,1)
C--CHECK IF THE KEYS TO BE STORED HAVE BEEN INPUT
C -- CHECK IF 'RATIO' ( OF FO AND SIGMA ) HAS BEEN INPUT
      IRATIO = KCOMP ( 1 , JRATIO , ISTORE(L6IMP) , MD6IMP , 1 )
C -- CHECK IF 'FO ' OR 'FOT' HAS BEEN INPUT
      INFO = KCOMP ( 1 , JFOO , ISTORE(L6IMP) , MD6IMP , 1 )
      INFT = KCOMP ( 1 , JFOT , ISTORE(L6IMP) , MD6IMP , 1 )
      IF(ISTORE(KZ+3))1850,1850,2050
C--NO STORAGE KEYS HAVE BEEN INPUT  -  SET THE DEFAULTS
1850  CONTINUE
      MD6DMP=MIN0(MD6DMP,MDODFK)
C--CHECK IF ANY OUTPUT KEYS ARE INDICATED
      IF(MD6DMP)1900,1900,2000
C--NO OUTPUT DATA
1900  CONTINUE
      CALL XERHDR(0)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1950)
      ENDIF
1950  FORMAT(' Insufficient output coefficients per reflection',
     2 ' have been indicated')
      GOTO 7400
C--MOVE THE DEFAULT VALUES ACROSS
2000  CONTINUE
      CALL XMOVE(STORE(LODFK),STORE(L6DMP),MD6DMP)
      GOTO 2100
C--CHECK IF ANY OUTPUT KEYS HAVE BEEN INDICATED
2050  CONTINUE
      IF(MD6DMP)1900,1900,2100
C--CHECK IF THE INDICES SHOULD BE PACKED ON OUTPUT TO THE DISC
2100  CONTINUE
      IPACKW=KCOMP(1,I14,ISTORE(L6DMP),MD6DMP,1)
C -- CHECK IF 'FO ' OR 'FOT' HAS BEEN SAVED
      JNFO = KCOMP ( 1 , JFOO , ISTORE(L6DMP) , MD6DMP , 1 )
      JNFT = KCOMP ( 1 , JFOT , ISTORE(L6DMP) , MD6DMP , 1 )
C--CHECK IF THE PHASE AND THE BATCH NUMBER SHOULD BE PACKED
      IPHSEW=KCOMP(1,I15,ISTORE(L6DMP),MD6DMP,1)
C -- CHECK IF THE JCODE AND RATIO SHOULD BE PACKED TOGETHER
      JCDRAW = KCOMP ( 1 , I31 , ISTORE(L6DMP) , MD6DMP , 1 )
C--CHECK IF A AND B PARTS SHOULD BE GENERATED FROM INPUT /FC/ AND PHASE
      KD=-1
      DO 2300 I=1,4
C--CHECK IF THIS IS /FC/ AND PHASE OR THE TWO PARTS
      IF(I-2)2150,2150,2200
C--/FC/ AND PHASE MUST HAVE BEEN INPUT
2150  CONTINUE
      IF(KCOMP(1,IPARTS(I),ISTORE(L6IMP),MD6IMP,1))2350,2350,2300
C--A AND B PARTS MUST BE ABOUT TO BE STORED
2200  CONTINUE
      IF(KCOMP(1,IPARTS(I),ISTORE(L6DMP),MD6DMP,1))2350,2350,2250
C--A AND B PARTS MUST NOT HAVE BEEN INPUT
2250  CONTINUE
      IF(KCOMP(1,IPARTS(I),ISTORE(L6IMP),MD6IMP,1))2300,2300,2350
2300  CONTINUE
C--CONVERSION IS REQUIRED
      KD=1
C--CONVERT THE INPUT POINTERS TO ABSOLUTE VALUES
2350  CONTINUE
      M6IMP=L6IMP+MD6IMP-1
      DO 2400 I=L6IMP,M6IMP
      ISTORE(I)=ISTORE(I)+M6
2400  CONTINUE
C--CONVERT THE DISC POINTERS TO ABSOLUTE VALUES
      CALL XABP06(1)
C--SET THE INPUT UNIT NUMBER
      IF(IUNIT)2450,2500,2500
C--NORMAL REFLECTION INPUT CHANNEL
2450  CONTINUE
      IUNIT=NCARU
      GOTO 2550
C--DATA IN THE NORMAL INSTRUCTION CHANNEL  -  NOT USUAL
2500  CONTINUE
      IF (IEOF .LE. 0) THEN
C----- READ FROM CURRENT 'USE' FILE
        IUNIT = NCUFU(IFLIND)
      ELSE
C----- SRQ IN USE - FIND CALLING I/O UNTIT
        IUNIT = NCUFU(IFLIND-1)
      ENDIF
C--SET UP THE DEFAULT NUMBER OF REFLECTIONS PER CARD
2550  CONTINUE
      NGROUP=1
      INCREM=1
C--SET THE END POINTER FOR THE INPUT BUFFER
      M6IB=L6IB+MD6IB-1
C--INITIALISE THE REFLECTION VALUE COLLECTION
      DO 2600 I=1,MD6
      CALL XIRTAC(I)
2600  CONTINUE
      M6R=L6R
      CALL XFAL01
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--CHECK IF THIS IS A SIMPLE COPY
      IF ((ITYPE6 .EQ. 1) .OR. (ITYPE6 .EQ. 5)) GOTO 2800
C--CHECK IF THIS IS AN APPEND OPERATION
2750  CONTINUE
      IF(IAPPND)3350,2800,2800
C
C--AN APPEND OR COPY IS REQUIRED
2800  CONTINUE
      I=KHUNTR(IULN,0,IADDL,IADDR,IADDD,0)
C--MOVE TO THE END OF THE RECORD CHAIN FOR THE CURRENT LIST 6
2850  CONTINUE
      IF(KCHNCB(IADDR))2850,2850,2900
C--PRESERVE THE LAST POINTER
2900  CONTINUE
      LASTPN=ISTORE(IADDR)
C--PRESERVE THE OUTPUT INDEX COMPRESS FLAG
      KW=IPACKW
C--PRESERVE THE PHASE/BATCH FLAGS
      KT=IPHSEW
C -- PRESERVE THE JCODE/RATIO FLAG
      KS = JCDRAW
C--PRESERVE THE LIST 6 COMMON BLOCK
      CALL XMOVEI(ICOM06(1),ISTORE(KX),IDIM06)
C--INITIATE THE READ FROM LIST 6
      CALL XFLT06(IULN,0)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--ELIMINATE THE LAST LIST 6 LOADED FROM THE CORE CHAIN
      ISTORE(IADDR)=LASTPN
C--CONVERT THE MOVE POINTERS TO POINT TO THE ORIGINAL LIST 6
      M6DMP = L6DMP + MD6DMP - 1
      IRFO = -1
      IRFT = -1
      DO 2950 I=L6DMP,M6DMP
C---- SET POINTERS TO INFORMATION ON DISK
      IF ((ISTORE(I)-M6) .EQ. JFOO(1)) IRFO = JFOO(1)
      IF ((ISTORE(I)-M6) .EQ. JFOT(1)) IRFT = JFOT(1)
      ISTORE(I)=ISTORE(I)-M6+ISTORE(KX+1)
2950  CONTINUE
C--PRESERVE THE MOVE POINTERS
      KP=L6DMP
      KQ=M6DMP
C--PRESERVE THE NEW READ FLAGS
      CALL XMOVEI(ICOM06(5),ISTORE(KZ),4)
C--RESTORE THE INPUT DATA TO THE COMMON BLOCK
      CALL XMOVEI(ISTORE(KX),ICOM06(1),IDIM06)
C--RESET THE OUTPUT PACKING FLAGS
      IPACKW=KW
      IPHSEW=KT
      JCDRAW = KS
C--CHECK FOR A COPY OPERATION
      IF ((ITYPE6 .EQ. 1) .OR. (ITYPE6 .EQ. 5)) THEN
            GOTO 3000
      ELSE
            GOTO 3050
      ENDIF
C--COPY  -  SET UP THE OUTPUT TYPE
3000  CONTINUE
      N6D=ISTORE(KZ+3)
C -- IF COPY IS TO DISC, CHECK THAT ENOUGH SPACE WILL BE AVAILABLE
      IF ( MEDIUM .GT. 0 ) I = KLSSPC ( IULN , ICOM06 , IDIM06 , 3 )
      CALL XSTR06(IULN,MEDIUM,-1,-1,0)
      GOTO 3100
C--NOW INITIALISE THE OUTPUT SEQUENCE
3050  CONTINUE
      CALL XSTR06(IULN,-1,-1,1,0)
C--RESET THE READ FLAGS
3100  CONTINUE
      CALL XMOVEI(ISTORE(KZ),ICOM06(5),4)
C--LOAD THE NEXT REFLECTION  -  SET ALL THE POINTERS
3150  CONTINUE
      L6DMP=KP
      M6DMP=KQ
C--LOAD THE REFLECTION
      IF(KLDRNR(1))3300,3200,3200
3200  CONTINUE
CDJW DEC97        TWINS - SORT OUT  fO TO fot
C--- PUT SOMETHING INTO FO
      IF ((JNFO .GT. 0) .AND. (IRFO .LE. 0) .AND. (IRFT .GT. 0))
     1 STORE(L6+JFOO(1)) = STORE(L6+JFOT(1))
C---- PUT SOMETING INTO FOT
      IF ((JNFT .GT. 0) .AND. (IRFT .LE. 0) .AND. (IRFO .GT. 0))
     1 STORE(L6+JFOT(1)) = STORE(L6+JFOO(1))
C----- PUT SOMETHING INTO ELEMENTS
      IF ((JNFT .GT. 0) .AND. (STORE(L6+11)  .LE. ZERO))
     1 STORE(L6+11) = 12.0
C--RESET THE MOVE POINTERS
      L6DMP=ISTORE(KX+16)
      M6DMP=ISTORE(KX+17)
C--STORE THE REFLECTION
      CALL XSLR(1)
C--ACCUMULATE THE TOTALS
      DO 3250 I=1,MD6
      CALL XACRT(I)
3250  CONTINUE
      GOTO 3150
C--END OF THE REFLECTIONS  -  RESTORE THE COMMON BLOCK COMPLETELY
3300  CONTINUE
      L6DMP=ISTORE(KX+16)
      M6DMP=ISTORE(KX+17)
      MD6R = MD6W
      CALL XZEROF(STORE(M6),MD6)
      GOTO 3400
C
C--INITIALISE THE OUTPUT OF THE REFLECTIONS TO M/T
3350  CONTINUE
      CALL XSTR06(IULN,-1,-1,1,0)
C--RESET THE CURRENT LIST TYPE
3400  CONTINUE
      LN=IULN
      IREC=0
C--LOAD LIST 13 FOR THE TWIN DATA
      CALL XFAL13
      IF ( IERFLG .LT. 0 ) GO TO 9900
      WAVE = STORE(L13DC)
C--CHECK IF THIS CRYSTAL IS TWINNED
      IF(ISTORE(L13CD+1))3550,3500,3500
C--DATA IS FROM A TWINNED CRYSTAL  -  ALTER THE POINTER TO /FO/
3500  CONTINUE
      IFO=10
C--BRANCH ON THE TYPE OF OUTPUT
3550  CONTINUE
C----- INITIALISE THE ABSORPTION CORRECTION
      I=MABS(-1)
      IF ( IERFLG .LT. 0 ) GO TO 9900
      LN=IULN
      GOTO(7150,3650,4300,4500,7150,6050,6050,6050,3600),ITYPE6
C3600  STOP 'LIST 6 ERROR'
3600  CALL GUEXIT(2019)
C
C--FIXED FORMAT INPUT
3650  CONTINUE
      IF(DENSTY-ZERO)3700,3700,3750
C--THE NUMBER OF REFLECTIONS PER CARD IS ZERO  -  DEFAULT TO ONE
3700  CONTINUE
      DENSTY=1.
C--RECOMPUTE THE NUMBER OF REFLECTIONS PER CARD AND THE NUMBER OF CARDS
3750  CONTINUE
      NGROUP=MAX0(1,NINT(DENSTY))
      INCREM=MAX0(1,NINT(1./DENSTY))
C--RECREATE THE INPUT DATA AREA
      MD6IB=MD6IB*NGROUP
      L6IB=KCEDR(106,1,1004,MD6IB,N6IB,41)
      M6IB=L6IB+MD6IB-1
C--CHECK IF A FORMAT HAS BEEN PROVIDED
      IF(LFORM-1)3800,3800,4000
C--NO FORMAT INPUT  -  SET UP THE DEFAULT VALUE
3800  CONTINUE
      IF(ITYPE6-6)3900,3850,3900
C--THIS IS REFLECTION INPUT IN FIXED FORMAT  -  CHECK LIST 13
3850  CONTINUE
      IDIF=ISTORE(L13DT)-5
C     NORMAL         EQUI           ANTI           PRECESSION     NONE
C     CAD4           ROLLETT        Y290           KAPPA
      GOTO(3950,3950,3950,3950,3950,3900,3950,3950,3900),IDIF+5
C--'CAD4' DATA
3900  CONTINUE
      CALL XMOVEI(ICAD4(1),IFORM(1),LCAD4)
      LFORM=LCAD4
      GOTO 4000
C--'SHELX' INPUT FORMAT IS THE DEFAULT TO BE USED
3950  CONTINUE
      CALL XMOVEI(ISLX(1),IFORM(1),LSLX)
      LFORM=LSLX
C--COMPRESS THE FORMAT FOR USE
4000  CONTINUE
      CALL XFCCS(IFORM(1),IFORM(1),LFORM)
C----- CONVERT TO CHARACTERS
      WRITE(CFORM, '(20A4)' ) (IFORM(IZZ), IZZ = 1, LFORM)
C--READ THE NEXT REFLECTION
4050  CONTINUE
      READ(IUNIT,CFORM,END=4200,ERR=4170) (STORE(I), I= L6IB, M6IB)
      NCARDS=NCARDS+INCREM
C--CHECK FOR BLANK ENTRY
      DO 4100 I=L6IB,M6IB
      IF(NINT(STORE(I)))4150,4100,4150
4100  CONTINUE
      GOTO 4050
C--CHECK FOR THE END OF THE REFLECTIONS
4150  CONTINUE
      IF(STORE(L6IB)+511.) 7150, 6100, 6100
C--END OF FILE DURING THE READ  -  CHECK IF THIS IS ON THE INPUT UNIT
C----- ERROR DURING READ -
4170  CONTINUE
      IF (NCARDS .LE. 0) THEN
       WRITE(CMON,'(A)') ' Check the reflection filename, and format'
       CALL XPRVDU(NCVDU, 1,0)
       IF (ISSPRT .EQ. 0) WRITE(NCWU,'(A)') CMON(1)(:)
       LEF = -1
      ELSE
       WRITE(CMON,4171)
       CALL XPRVDU(NCVDU, 3,0)
       IF (ISSPRT .EQ. 0) WRITE(NCWU,4171)
       WRITE(NCAWU, 4171)
4171   FORMAT(' Error during reading reflections'/
     1  ' Some reflections may be lost'/
     2  ' They should be terminated with an h value of -512')
      CALL XPAUSE(500)
      BACKSPACE (UNIT=IUNIT,ERR=4200)
      END IF
      GOTO 7150
4200  CONTINUE
      IF(IUNIT .EQ. NCaRU) goto 7150
C--NORMAL CONTROL INPUT UNIT  -  INDICATE END OF FILE
4250  CONTINUE
      IEOF=-1
      GOTO 7150
C
C--FREE FORMAT REFLECTION INPUT
4300  CONTINUE
      NW=MD6IMP-1
      IF(NW)4550,4550,4350
C--READ THE FIRST WORD OF THE NEXT REFLECTION
4350  CONTINUE
      IF(KRD06(STORE(L6IB),1,-1))7150,4400,7400
C--CHECK FOR END OF FILE
4400  CONTINUE
      IF(STORE(L6IB)+511.) 7150, 4450, 4450
C--READ THE REMAINDER OF THE DATA
4450  CONTINUE
      IF(KRD06(STORE(L6IB+1),NW,0))7400,6100,7400
C
C--THIS IS A COMPRESSED INPUT  -  COMPUTE THE NUMBER OF COEFFICIENTS
4500  CONTINUE
      NW=MD6IMP-3
C--CHECK IF ANY COEFFICIENTS ARE INDICATED
      IF(NW)4550,4550,4650
C--NO DATA
4550  CONTINUE
      CALL XERHDR(0)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4600)
      ENDIF
4600  FORMAT(' Insufficient input coefficients per reflection',
     2 ' Have been indicated')
      GOTO 7400
C--SET THE TRUE POINTER FOR THE MULTIPLIERS
4650  CONTINUE
      M6MLT=L6MLT+3
C--INVERT THE MULTIPLIERS
      DO 4700 I=1,NW
      AA(I)=1./STORE(M6MLT)
      M6MLT=M6MLT+1
4700  CONTINUE
C--READ THE NEXT 'KL' PAIR
4750  CONTINUE
      IF(KRD06(STORE(L6IB+1),2,0))7400,4800,7400
C--READ THE NEXT 'H' VALUE
4800  CONTINUE
      IF(KRD06(STORE(L6IB),1,0))7400,4850,7400
C--CHECK IF THIS VALUE INDICATES THE END OF THIS 'KL' PAIR
4850  CONTINUE
      IF(STORE(L6IB)-511.)4900,4900,4750
C--CHECK IF THIS VALUE OF 'H' INDICATES THE END OF THE REFLECTIONS
4900  CONTINUE
      IF(STORE(L6IB)+511.)7150,4950,4950
C--READ THE COEFFICIENTS
4950  CONTINUE
      IF(KRD06(STORE(L6IB+3),NW,0))7400,5000,7400
C--MULTIPLY UP THE COEFFICIENTS
5000  CONTINUE
      L=L6IB
      DO 5050 K=1,NW
      STORE(L+3)=STORE(L+3)*AA(K)
      L=L+1
5050  CONTINUE
      GOTO 6100
C
C--INPUT FROM A BOSS TAPE  -  READ THE TITLES AND DETAILS
5100  CONTINUE
C----- THE LINK TO THE 'BOSS' SYSTEM IS NO LONGER SUPPORTED
      GOTO 7150
C
C--REFLECTION INPUT, INCLUDING SCALING AND ABSORPTION CORRECTIONS
6050  CONTINUE
      I=MSCALE(-1)
      IF ( IERFLG .LT. 0 ) GO TO 9900
      GOTO(7150,3650,4300,4500,7150,3650,4300,4500,3600),ITYPE6
C
C--UPDATE AND STORE THE REFLECTION
6100  CONTINUE
      L=L6IB
C--LOOP OVER EACH INPUT GROUP
      DO 7050 K=1,NGROUP
      STORE(M6+27)=1.
      STORE(M6+12)=0.
C--MOVE THE DATA FROM THE INPUT BUFFER TO THE CORE BUFFER
      DO 6150 I=L6IMP,M6IMP
      J=ISTORE(I)
      STORE(J)=STORE(L)
      L=L+1
6150  CONTINUE
C----- CHECK INDICES
      IF((ABS(STORE(M6))+ ABS(STORE(M6+1))+ ABS(STORE(M6+2)))
     1 .LE. ZERO) GOTO 7050
C--CHECK IF WE SHOULD COMPUTE SIN(THETA)/LAMBDA SQUARED
      IF(L1S)6250,6250,6200
C--COMPUTE IT
6200  CONTINUE
      STORE(M6+16)=SNTHL2(I)
C--ENSURE A MINIMUM BATCH NUMBER OF ONE
6250  CONTINUE
      STORE(M6+13)=AMAX1(STORE(M6+13),1.)
C----- ENSURE POSITIVE JCODES AND LESS THAN 10
      STORE(M6+18) = AMIN1( 9., AMAX1(0., STORE(M6+18)) )
C--ENSURE A MINIMUM SERIAL OF ZERO
      STORE(M6+19)=AMAX1(STORE(M6+19),0.)
C--CHECK IF WE SHOULD COMPUTE THE A-PART AND B-PART FROM /FC/ AND PHASE
      IF(KD)6350,6300,6300
C--COMPUTE THE PARTS
6300  CONTINUE
      STORE(M6+7)=STORE(M6+5)*COS(STORE(M6+6))
      STORE(M6+8)=STORE(M6+5)*SIN(STORE(M6+6))
C--BRANCH ON THE INPUT TYPE
6350  CONTINUE
      GOTO(6550,6550,6550,6550,6550,6450,6450,6450,3600),ITYPE6
C6400  STOP 323
6400  CALL GUEXIT(323)
C--REFLECTION INPUT  -  APPLY ANY SCALES AND COEFFICIENTS
6450  CONTINUE
      IF(MSCALE(0))7050,6500,6500
C--AND NOW APPLY ANY ABSORPTION CORRECTION THAT IS REQUIRED
6500  CONTINUE
      IF(MABS(0))7050,6550,6550
C--CHECK IF WE SHOULD TAKE THE SQUARE ROOT
6550  CONTINUE
      JFO=M6+IFO
C--ARE WE INPUTTING /FO/ **2 ?
      IF(ISQ)6600,6700,6700
6600  CONTINUE
CDJWMAP99[
      CALL XSQRT(STORE(JFO), FSIGN, FABS, STORE(M6+12), SIG)
      STORE(JFO) = FSIGN
      STORE(M6+12) = SIG
CDJWMAP99]
C
C--APPLY THE SCALE STORED IN THE 'CORRECTIONS' SLOT
6700  CONTINUE
      STORE(JFO)=STORE(JFO)*STORE(M6+27)
      STORE(M6+12)=STORE(M6+12)*STORE(M6+27)
C----- RESET TO UNITY SINCE WE DONT NEED IT AGAIN
      STORE(M6+27) = 1.
C--CHECK THAT THE GIVEN VALUES OF /FO/ ARE NOT ZERO
6750  CONTINUE
      IF(STORE(JFO) .GT. ZERO )GOTO 6950
C--CHECK IF THIS IS THE FIRST REJECTED REFLECTION
6900  CONTINUE
      CALL XL6RRP(N6NEG,1000,IFO,ICAPT)
C--SEE IF WE SOULD REJECT THIS REFLECTION
      IF(ICHECK .GE. 0) THEN
            N6DEAD = N6DEAD + 1
            GOTO 7050
      ENDIF
6950  CONTINUE
C -- CALCULATE RATIO OF (FO)**2 AND SIGMA((FO)**2),IF IT HAS NOT BEEN IN
      IF ( IRATIO .LE. 0 ) THEN
        IF ( STORE(M6+12) .LE. ZERO ) THEN
          STORE(M6+20) = 0.0
        ELSE
          STORE(M6+20) = MIN( STORE(JFO) / (2.*STORE(M6+12)), 999.)
        ENDIF
      ENDIF
C
C----- WE HAVE FINISHED WITH 'CORRECTIONS' - SET TO UNITY
      STORE(M6+27) = 1.0
C -- AND NOW STORE THE REFLECTION
      CALL XSLR(1)
C--ACCUMULATE THE REFLECTION TOTALS
      DO 7000 I=1,MD6
      CALL XACRT(I)
7000  CONTINUE
7050  CONTINUE
C--BRANCH ON THE TYPE OF INPUT
       GOTO(4050,4050,4350,4800,4050,4050,4350,4800,7100),ITYPE6
7100  CONTINUE
      WRITE(CMON,7120)
      CALL XPRVDU(NCVDU, 1,0)
      WRITE(NCAWU,'(/A/)') CMON(1)(:)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,'(/A/)') CMON(1)(:)
7120  FORMAT(' Unsupported input data format')
      GOTO 7400
C
C--END OF THE REFLECTION INPUT  -  STORE THEM ON THE DISC
7150  CONTINUE
      N6D=N6W
C--NO ERRORS  -  CALCULATE THE REFLECTION DETAILS
      DO 7200 I=1,MD6
      CALL XCRD(I)
7200  CONTINUE
C--TERMINATE THE OUTPUT OF THE LIST
      CALL XERT(IULN)
      CALL XLINES
      WRITE(CMON, 7250) N6W, N6DEAD
      CALL XPRVDU(NCVDU, 1,0)
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , '(A)' ) CMON(1)(:)
      WRITE ( NCAWU , '(A)' ) CMON(1)(:)
7250  FORMAT ( 1X , I7 , ' reflections accepted' , 5X ,
     2 I7 , ' reflections rejected' )
C----- IF ITYPE6 .NE. 'COPY' WE WERE PROBABLY READING RAW DATA
       IF ((ITYPE6 .NE. 1) .AND. (ITYPE6 .NE. 5) ) THEN
       IF (KHUNTR (30,0, IADDL,IADDR,IADDD, -1) . LT. 0) CALL XFAL30
              IF (STORE(L30DR) .LE. ZERO) STORE(L30DR) = FLOAT(N6W)
C----- MIN AND MAX INDICES, FROM L6 DETAILS
              LIX = L6DTL
              STORE(L30IX) = STORE(LIX)
              STORE(L30IX+1) = STORE(LIX+1)
              LIX = LIX + MD6DTL
              STORE(L30IX+2) = STORE(LIX)
              STORE(L30IX+3) = STORE(LIX+1)
              LIX = LIX + MD6DTL
              STORE(L30IX+4) = STORE(LIX)
              STORE(L30IX+5) = STORE(LIX+1)
C---- THETA IS NOT AVAILABLE DURING READING REFLECTIONS
C        LIX = L6DTL + 16*MD6DTL
C        STORE(L30IX+6) = ASIN(SQRT(STORE(LIX))* WAVE)*RTD
C        STORE(L30IX+7) = ASIN(SQRT(STORE(LIX+1))*WAVE)*RTD
        CALL XWLSTD ( 30, ICOM30, IDIM30, -1, -1)
      ENDIF
C----- WRITE LIST 13 TO DISK IF TYPE IS TWIN
      IF(ITYPE6 .EQ. 5) THEN
          WRITE(NCAWU,*) 'Upating List 13 for twinned data'
          ISTORE(L13CD+1) = 0
          CALL XWLSTD ( 13, ICOM13, IDIM13, -1, -1)
      ENDIF
C
C
C---- PRINT CORRECTION DETAILS
      I=MABS(1)
C--CHECK FOR ANY ERRORS
      IF(LEF)7400,7300,7400
C--NO ERRORS  -  CHECK IF WE MUST OUTPUT TO DISC NOW
7300  CONTINUE
      CALL XSWP06(IULN,MEDIUM)
C
C--END OF THE INPUT  -  RESTORE THE INPUT CARD IMAGE
      CALL XMOVE(YCARD2(1),YCARD1(1),NCARD)
      GOTO 7500
C--ERROR(S) DURING INPUT  -  RESTORE THE CURRENT CARD IMAGE
7400  CONTINUE
      CALL XMOVE(YCARD2(1),YCARD1(1),NCARD)
C--PRINT THE ERROR TERMINATION MESSAGE
7450  CONTINUE
      CALL XOPMSG ( IOPLSI , IOPLSP , IULN )
      CALL XLSALT ( IULN , 0 , 0 , ILSERF , ILSSET )
C--REWIND THE M/T BEFORE WE LEAVE
      REWIND MTA
      REWIND MTB
C--CHECK IF WE HAVE BEEN READING FROM THE MAIN INPUT FILE
7500  CONTINUE
      IF(IUNIT-NCRU)7600,7550,7600
C--INPUT FROM THE MAIN CHANNEL  -  ALTER THE COUNTERS
7550  CONTINUE
      NI=NI+NCARDS
      MON=NI
C--AND NOW RETURN
7600  CONTINUE
      CALL XOPMSG ( IOPLSI , IOPLSE , IULN )
      CALL XTIME2 ( 2 )
      RETURN
C
9900  CONTINUE
C -- ERRORS
      GO TO 7400
C
      END
C
CODE FOR MSCALE
      FUNCTION MSCALE(IPOINT)
C--CONTROL ROUTINE FOR INPUT GENERATED BY THE HILGER-WATTS DATA REDUCTIO
C  PROGRAM.
C
C  IPOINT  THE CALL CONTROL VALUE :
C
C          -1  INITIALISE.
C           0  PROCESS.
C
C--RETURN VALUES OF 'MSCALE' ARE :
C
C  -1  NO REFLECTION READ.
C   0  REFLECTION READ.
C
C--
\ISTORE
\ICOM30
C
      CHARACTER*24 ICAPT
C
\XCONST
\STORE
\XWORKA
\XLST06
\XLST6A
\XLST27
\XLST30
\XUNITS
\XSSVAL
C
\QSTORE
C
      EQUIVALENCE (JD,SCALE),(JE,GRAD),(IH,JF),(IK,JG)
\QLST30
C
      SAVE
C
C
C
      DATA ICAPT / 'Correction is zero' /
C
C--ASSIGN THE RETURN VALUE
      MSCALE=0
C--CHECK THE CALL TYPE
      IF(IPOINT)1000,1550,1550
C--CHECK IF A LIST 27 IS PRESENT
1000  CONTINUE
      SCALE=1.0
      IF(NSCALE)1100,1100,1050
C--SCALING IS INDICATED  -  CHECK FOR A LIST 27
1050  CONTINUE
      IF(KEXIST(27))1100,1100,1250
C--NO LIST 27 THAT CAN BE USED
1100  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1150)
      ENDIF
1150  FORMAT(/,' No scales found')
      N27=-1
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1200)SCALE
      ENDIF
1200  FORMAT(/,' A scale of',F10.5,'  has been assumed',/)
      GOTO 1500
C--LOAD LIST 27 FROM THE DISC
1250  CONTINUE
      CALL XFAL27
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--SET THE POINTERS TO THE SECOND SCALE
      M27=L27+MD27
C--CHECK IF ANY SCALES ARE PRESENT TO USE
      IF(N27-2)1300,1400,1400
C--NO SCALES IN LIST 27
1300  CONTINUE
      I=0
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1350)I,I
      ENDIF
1350  FORMAT(/' Scales exhausted after',I6,'  reflection(s)',5X,
     2 '(At reflection',I6,')')
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1200)SCALE
      ENDIF
      GOTO 1500
C--CALCULATE A FEW CONSTANTS
1400  CONTINUE
C----- LOAD DATA IF LIST 30 NOT ALREADY IN CORE
      IF (KHUNTR (30,0, IADDL,IADDR,IADDD, -1) .LT. 0) CALL XFAL30
      IF (IERFLG .LT. 0) GOTO 6520
      ATMP = -1000000.
      BTMP =  1000000.
      M27TMP = L27 + NSCALE
      DO 1510 I = 1, N27
      ATMP = MAX (ATMP, STORE(M27TMP))
      BTMP = MIN (BTMP, STORE(M27TMP))
      M27TMP = M27TMP + MD27
1510  CONTINUE
      STORE(L30CD+8) = 100. * (ATMP-BTMP)/ATMP
      CALL XWLSTD ( 30, ICOM30, IDIM30, -1, -1)
6520  CONTINUE
C
      JA=NINT(STORE(L27+3))
      JB=NINT(STORE(M27+3))
      IH=L27+NSCALE
      IK=M27+NSCALE
      GRAD=0.0
C--CHECK THE SERIAL NUMBERS OF THE FIRST TWO SCALES
      IF(JB-JA)1500,1500,1450
C--COMPUTE THE INITIAL GRADIENT
1450  CONTINUE
      GRAD=(STORE(IK)-STORE(IH))/(STORE(M27+3)-STORE(L27+3))
C--AND NOW RETURN AFTER THE INITIALISATION
1500  CONTINUE
      RETURN
C
C--APPLY THE SCALE FACTORS IF NECESSARY
1550  CONTINUE
      JC=NINT(STORE(M6+19))
C--CHECK IF THERE ARE SCALES WE CAN USE
      IF (N27) 2000, 2000, 1600
1600  CONTINUE
      IF(JA-JC)1700,1650,1750
1650  CONTINUE
      IF(JB-JC)1950,1750,1950
1700  CONTINUE
      IF(JB-JC)1750,1750,1950
C--INCREMENT THE SCALE POSITION
1750  CONTINUE
      L27=M27
      M27=L27+MD27
      N27=N27-1
C----- REMEMBER - M27 LOOKS ONE AHEAD
      IF (N27-1) 1800, 1800, 1850
1800  CONTINUE
      I=NINT(STORE(M6+19))
      JA=N6W+N6DEAD+1
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1350)I,JA
      ENDIF
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1200)SCALE
      ENDIF
C--COMPUTE THE NEW CONSTANTS
      GOTO 2000
1850  CONTINUE
      JA=JB
      JB=NINT(STORE(M27+3))
      IH=L27+NSCALE
      IK=M27+NSCALE
      GRAD=0.0
      IF(JB-JA)1600,1600,1900
1900  CONTINUE
      GRAD=(STORE(IK)-STORE(IH))/(STORE(M27+3)-STORE(L27+3))
      GOTO 1600
C--COMPUTE THE SCALE AT THIS POINT
1950  CONTINUE
      SCALE=STORE(IH)+GRAD*(STORE(M6+19)-STORE(L27+3))
C--CALCULATE /FO/ AND THE OTHER TERMS
2000  CONTINUE
      STORE(M6+27)=SQRT(SCALE*WFACT(I))
C--CHECK THE MULTIPLIER
      IF(STORE(M6+27)-ZERO)2050,2050,1500
C--THIS MULTIPLIER IS NOT BIG ENOUGH
2050  CONTINUE
      CALL XL6RRP(N6DEAD,1000,IFO,ICAPT)
      MSCALE=-1
      GOTO 1500
9900  CONTINUE
C -- ERRORS
      MSCALE = -1
      RETURN
      END
C
CODE FOR WFACT
      FUNCTION WFACT(IN)
C--COMPUTE THE OVERALL MULTIPLIER TO CONVERT I'S TO /FO/ **2'S
C
C  IN  DUMMY ARGUMENT
C
C--THE ADDRESSES OF THE COEFFICIENTS ARE GIVEN IN THE STACK
C  AT 'LFACT', AND THERE ARE 'MDFACT' OF THEM
C
C--
\ISTORE
C
\STORE
\XLST06
\XLST6A
C
\QSTORE
C
      IDWZAP = IN
C--SET THE INITIAL VALUE
      AFACT=1.
C--CHECK IF THERE ARE ANY COEEFICIENTS REQUIRED
      IF(MDFACT)1100,1100,1000
C--LOOP OVER THE REQUIRED COEFFICIENTS
1000  CONTINUE
      MFACT=LFACT
      DO 1050 J=1,MDFACT
      K=ISTORE(MFACT)+M6
      AFACT=AFACT*STORE(K)
      MFACT=MFACT+1
1050  CONTINUE
1100  CONTINUE
      WFACT=AFACT
      RETURN
      END
C
CODE FOR KRD06
      FUNCTION KRD06(A,N,IEOFLG)
C--FREE FORMAT READ ROUTINE USED DURING THE INPUT OF LIST 6
C
C  A       THE ARRAY TO BE FILLED.
C  N       THE NUMBER OF NUMBERS TO BE READ.
C  IEOFLG  THE FLAG TO INDIATE HOW END OF FILE IS TO BE TREATED :
C
C          -1  END OF FILE IS ACCEPTABLE NOW AND CAN BE PROCESSED.
C           0  END OF FILE IS ILLEGAL HERE.
C
C--RETURN VALUES ARE :
C
C  -1  END OF FILE DETECTED BEFORE THE FIRST REFLECTION.
C   0  DATA READ OKAY.
C  +1  ERRORS HAVE OCCURRED, WHICH INCLUDE SPURIOUS CHARACTERS AND END O
C      IN THE MIDDLE OF THE DATA.
C
C--
C
      DIMENSION A(N)
C
\XUNITS
\XSSVAL
\XCARDS
\XCHARS
\XLISTI
\XLST6A
C
C--MARK THE RETURN VALUE AS OKAY ORIGINALLY
      KRD06=0
C--LOOP OVER EACH NUMBER TO BE READ
      DO 1700 I=1,N
C--SEARCH FOR THE NEXT NON-BLANK CHARACTER
1000  CONTINUE
      NC=KNEQUL(NC,IB)
C--CHECK FOR END OF CARD
      IF(NC)1050,1050,1150
C--END OF THE CARD  -  READ THE NEXT
1050  CONTINUE
      READ(IUNIT,1100,END=1450)IMAGE
1100  FORMAT(80A1)
      NCARDS=NCARDS+INCREM
      NC=1
      GOTO 1000
C--READ THE NEXT NUMBER OFF THIS CARD
1150  CONTINUE
      IF(KINPUT(A(I)))1200,1700,1200
C--SPURIOUS CHARACTER IN THE DATA
1200  CONTINUE
      CALL XERHDR(0)
      WRITE(NCAWU,1250)NCARDS,IMAGE,(IB,J=1,NC),IA
      WRITE(NCAWU,1300)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1250)NCARDS,IMAGE,(IB,J=1,NC),IA
      WRITE(NCWU,1300)
      ENDIF
1300  FORMAT(/,' Marked by an ''*''')
1250  FORMAT(' Spurious character on record ',I5,'  : ',80A1/38X,81A1)
C--GENERAL ERROR RETURN FROM THIS ROUTINE
1350  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1400)LN,IUNIT
      ENDIF
      WRITE(NCAWU,1400)LN,IUNIT
1400  FORMAT(/,' Input of list ',I5,'  on unit ',I5,'  fails')
      KRD06=1
      GOTO 1750
C--END OF FILE DETECTED  -  CHECK IF THIS IS THE NORMAL INPUT UNIT
1450  CONTINUE
      KRD06=-1
      IF(IUNIT-NCRU)1550,1500,1550
C--NORMAL INPUT UNIT  -  FLAG END OF FILE
1500  CONTINUE
      IEOF=-1
C--CHECK IF END OF FILE IS ALLOWED HERE
1550  CONTINUE
      IF(IEOFLG)1750,1600,1600
C--ILLEGAL END OF FILE
1600  CONTINUE
      CALL XERHDR(0)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1650)NCARDS
      ENDIF
      WRITE(NCAWU,1650)NCARDS
1650  FORMAT(' End of file detected after ',I5,
     2 ' records, in the middle of a reflection'/
     3 'Check that all columns are separated by at least 1 space')
      GOTO 1350
1700  CONTINUE
C--AND NOW RETURN
1750  CONTINUE
      RETURN
      END
