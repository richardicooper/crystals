!> This module holds the unit cell parameters and related values
module unitcell_mod

type, public :: t_unitcell
    integer :: status=-1
    real :: a,b,c,alpha,beta,gamma ! angles in radians
    real :: ra,rb,rc,ralpha,rbeta,rgamma ! angles in radians
contains    
    procedure, pass(this) :: set, printall
    procedure, pass(this) :: volume
    procedure, pass(this) :: rvolume
    procedure, pass(this) :: orthogonalisation, orthogonalisation_exclcell
    procedure, pass(this) :: rorthogonalisation, rorthogonalisation_exclcell
    procedure, pass(this) :: rmetric, rmetric_exclcell
    procedure, pass(this) :: metric, metric_exclcell
    procedure, pass(this) :: Rij, adp_coefs, iso_to_aniso
end type

type(t_unitcell), dimension(:), allocatable :: unitcells

contains

subroutine set(this, a,b,c,alpha,beta,gamma)
    implicit none
    class(t_unitcell) :: this
    real a,b,c,alpha,beta,gamma
    real, dimension(3,3) :: rmetric
    
    this%a=a
    this%b=b
    this%c=c
    this%alpha=alpha
    this%beta=beta
    this%gamma=gamma
    
    this%rgamma=acos((cos(alpha)*cos(beta)-cos(gamma))/(sin(alpha)*sin(beta)))

    rmetric=this%rmetric()
    
    this%ra=sqrt(rmetric(1,1))
    this%rb=sqrt(rmetric(2,2))
    this%rc=sqrt(rmetric(3,3))
    this%rgamma=acos(rmetric(1,2)/(this%ra*this%rb))
    this%rbeta=acos(rmetric(1,3)/(this%ra*this%rc))
    this%ralpha=acos(rmetric(2,3)/(this%rb*this%rc))
    
    this%status=0    
    
end subroutine

!> Return the volume of the unit cell
function volume(this)
    use math_mod
    implicit none
    class(t_unitcell) :: this
    real :: volume   
   
    volume = this%a*this%b*this%c*(1-cos(this%alpha)**2-cos(this%beta)**2 - &
    &   cos(this%gamma)**2+2*cos(this%alpha)*cos(this%beta)*cos(this%gamma))**(0.5)
end function

!> Return the reciprocal volume of the unit cell
function rvolume(this)
    use math_mod
    implicit none
    class(t_unitcell) :: this
    real :: rvolume   
   
    rvolume = this%ra*this%rb*this%rc*(1-cos(this%ralpha)**2-cos(this%rbeta)**2 - &
    &   cos(this%rgamma)**2+2*cos(this%ralpha)*cos(this%rbeta)*cos(this%rgamma))**(0.5)
end function

!> Return a reciprocal orthogonalisation matrix
function rorthogonalisation(this)
    use math_mod
    implicit none
    class(t_unitcell) :: this
    real, dimension(3,3) :: rorthogonalisation
    logical OK_FLAG
    
    call M33INV (this%orthogonalisation(), rorthogonalisation, OK_FLAG)
    rorthogonalisation=transpose(rorthogonalisation)
end function

!> Return a reciprocal orthogonalisation matrix excluding cell parameters
function rorthogonalisation_exclcell(this)
    use math_mod
    implicit none
    class(t_unitcell) :: this
    real, dimension(3,3) :: rorthogonalisation_exclcell, cell, temp
    
    cell=0.0
    cell(1,1)=1.0/this%ra
    cell(2,2)=1.0/this%rb
    cell(3,3)=1.0/this%rc
    
    rorthogonalisation_exclcell=matmul(this%rorthogonalisation(), cell)
        
end function

!> Return a real orthogonalisation matrix
function orthogonalisation(this)
    use math_mod
    implicit none
    class(t_unitcell) :: this
    real, dimension(3,3) :: orthogonalisation
    
    orthogonalisation=0.0
    orthogonalisation(1,1) = this%a*sin(this%beta)*sin(this%rgamma)
    orthogonalisation(2,1) = -this%a*sin(this%beta)*cos(this%rgamma)
    orthogonalisation(2,2) = this%b*sin(this%alpha)
    orthogonalisation(3,1) = this%a*cos(this%beta)
    orthogonalisation(3,2) = this%b*cos(this%alpha)
    orthogonalisation(3,3) = this%c
    
end function

!> Return a real orthogonalisation matrix excluding the cell parameters
function orthogonalisation_exclcell(this)
    use math_mod
    implicit none
    class(t_unitcell) :: this
    real, dimension(3,3) :: orthogonalisation_exclcell, cell
    
    cell=0.0
    cell(1,1)=1.0/this%a
    cell(2,2)=1.0/this%b
    cell(3,3)=1.0/this%c
    
    orthogonalisation_exclcell=matmul(this%orthogonalisation(), cell)
    
end function

!> Return the reciprocal metric tensor
function metric(this)
    use math_mod
    implicit none
    class(t_unitcell) :: this
    real, dimension(3,3) :: metric, o
    
    o = this%orthogonalisation()
    metric = matmul(transpose(o), o)
end function

!> Return the metric tensor
function rmetric(this)
    use math_mod
    implicit none
    class(t_unitcell) :: this
    real, dimension(3,3) :: rmetric
    logical OK_FLAG
        
    call M33INV (this%metric(), rmetric, OK_FLAG)
end function

!> Return the reciprocal metric tensor excluding cell parameters
function rmetric_exclcell(this)
    use math_mod
    implicit none
    class(t_unitcell) :: this
    real, dimension(3,3) :: rmetric_exclcell, o
    
    o = this%rorthogonalisation_exclcell()
    rmetric_exclcell = matmul(transpose(o), o)
end function

!> Return the metric tensor excluding cell parameters
function metric_exclcell(this)
    use math_mod
    implicit none
    class(t_unitcell) :: this
    real, dimension(3,3) :: metric_exclcell
    logical OK_FLAG
        
    call M33INV (this%rmetric_exclcell(), metric_exclcell, OK_FLAG)
end function

!> Return the R(ii) and R(ij) used to calculate sin(theta)/lambda
function Rij(this)
    implicit none
    class(t_unitcell) :: this
    real, dimension(3,3) :: Rij, rmetric
    
    rmetric=this%rmetric()
    
    Rij(1,1)=0.25*rmetric(1,1)
    Rij(2,1)=0.5* rmetric(2,1)
    Rij(3,1)=0.5* rmetric(3,1)
    
    Rij(1,2)=0.5* rmetric(1,2)
    Rij(2,2)=0.25*rmetric(2,2)
    Rij(3,2)=0.5* rmetric(3,2)

    Rij(1,3)=0.5* rmetric(1,3)
    Rij(2,3)=0.5* rmetric(2,3)
    Rij(3,3)=0.25*rmetric(3,3)
    
end function

!> Constants to convert an atom from iso to aniso
function iso_to_aniso(this)
    implicit none
    class(t_unitcell) :: this
    real, dimension(3) :: iso_to_aniso
    
    iso_to_aniso=cos( (/this%ralpha, this%rbeta, this%rgamma/) )
end function

!> Anisotropic temperature factor coefficients
!! 3x3 tensor stored flat as a 1-D array of 6 elements
function adp_coefs(this)
    implicit none
    class(t_unitcell) :: this
    real, dimension(6) :: adp_coefs
    real, parameter :: pi=3.14159265358979323846
    real, dimension(3,3) :: rmetric
    
    rmetric=this%rmetric()
    
    adp_coefs(1)=-2.0*pi**2*rmetric(1,1)
    adp_coefs(2)=-2.0*pi**2*rmetric(2,2)
    adp_coefs(3)=-2.0*pi**2*rmetric(3,3)
    adp_coefs(4)=-4.0*pi**2*this%rb*this%rc
    adp_coefs(5)=-4.0*pi**2*this%rc*this%ra
    adp_coefs(6)=-4.0*pi**2*this%ra*this%rb
    
end function

subroutine printall(this)
    implicit none
    class(t_unitcell) :: this
    real, dimension(3,3) :: tensor
    real, dimension(6) :: vector
    
    print *, 'Status: ', this%status
    
    print *, ''
    print *, 'Unit cell parameters: '
    write(*, '("a=",F0.3,1X,"b=",F0.3,1X,"c=",F0.3,1X,"alpha=",F0.3,1X,"beta=",F0.3,1X,"gamma=",F0.3)') &
    &   this%a, this%b, this%c, this%alpha, this%beta, this%gamma

    print *, 'Reciprocal unit cell parameters: '
    write(*, '("a=",F0.6,1X,"b=",F0.6,1X,"c=",F0.6,1X,"alpha=",F0.3,1X,"beta=",F0.3,1X,"gamma=",F0.3)') &
    &   this%ra, this%rb, this%rc, this%ralpha, this%rbeta, this%rgamma

    print *, ''
    print *, 'Real metric tensor including and excluding cell parameters: '
    tensor=this%metric()
    write(*, '(3(3(F9.4,1X)/))') transpose(tensor)
    print *, ''
    tensor=this%metric_exclcell()
    write(*, '(3(3(F9.4,1X)/))') transpose(tensor)

    print *, ''
    print *, 'Reciprocal metric tensor including and excluding cell parameters: '
    tensor=this%rmetric()
    write(*, '(3(3(F9.6,1X)/))') transpose(tensor)
    print *, ''
    tensor=this%rmetric_exclcell()
    write(*, '(3(3(F9.6,1X)/))') transpose(tensor)

    print *, ''
    print *, 'Real orthogonalisation matrix including and excluding cell parameters: '
    tensor=this%orthogonalisation()
    write(*, '(3(3(F9.4,1X)/))') transpose(tensor)
    print *, ''
    tensor=this%orthogonalisation_exclcell()
    write(*, '(3(3(F9.4,1X)/))') transpose(tensor)
    
    print *, ''
    print *, 'Reciprocal orthogonalisation matrix including and excluding cell parameters: '
    tensor=this%rorthogonalisation()
    write(*, '(3(3(F9.6,1X)/))') transpose(tensor)
    print *, ''
    tensor=this%rorthogonalisation_exclcell()
    write(*, '(3(3(F9.6,1X)/))') transpose(tensor)
    
    print *, ''
    print *, 'The R(ii) and R(ij)''s used to calculate sin(theta)/lambda: '
    tensor=this%Rij()
    write(*, '(3(3(F9.6,1X)/))') transpose(tensor)

    print *, ''
    print *, 'The anisotropic temperature factirs coeficients: '
    vector=this%adp_coefs()
    write(*, '(6(F9.6,1X))') vector

    print *, ''
    print *, 'Contants to convert an atom from iso to aniso: '
    vector(1:3)=this%iso_to_aniso()
    write(*, '(3(F9.6,1X))') vector(1:3)

end subroutine

end module

