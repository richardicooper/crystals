C $Log: not supported by cvs2svn $
C Revision 1.35  2012/01/04 14:31:25  rich
C Fix some uninitialized variables, and output format mistakes.
C
C Revision 1.34  2011/09/20 13:15:46  rich
C Some new hollerith problems crept in.
C
C Revision 1.33  2011/07/06 10:40:00  rich
C Added HPART and NHPART atom selection keywords to the lexical scanner. They select hydrogen atoms in a specific PART, or non-hydrogen atoms (respectively).
C
C Revision 1.32  2011/03/21 13:57:21  rich
C Update files to work with gfortran compiler.
C
C Revision 1.31  2011/02/07 16:59:07  djw
C Put IDIM09 as a parameter in ICOM09 so that we can use it to declare work space
C
C Revision 1.30  2011/02/04 17:34:03  djw
C Extend parameter list on PRTGRP to enable selection by RESIDUE
C
C Revision 1.29  2009/11/03 12:10:57  djw
C Remove debugging print
C
C Revision 1.28  2009/11/03 11:18:20  djw
C Add comments and set up processing for LIST 18, the SMILES string.  Improve handling of REM cards inside CONTINUE blocks
C
C Revision 1.27  2009/10/28 16:25:55  djw
C Add comment about buffer size
C
C Revision 1.26  2009/10/13 16:39:58  djw
C Double the buffer size in XLXINI to enable very long CONTINUE lines to be processed (Spotted in DISTANGL trying to read in about 300 BONDED H atoms
C
C Revision 1.25  2005/01/23 08:29:11  rich
C Reinstated CVS change history for all FPP files.
C History for very recent (January) changes may be lost.
C
C Revision 1.2  2004/12/13 16:16:08  rich
C Changed GIL to _GIL_ etc.
C
C Revision 1.1.1.1  2004/12/13 11:16:09  rich
C New CRYSTALS repository
C
C Revision 1.24  2004/05/10 08:17:57  rich
C Errors in L16 on continuation lines would sometimes cause a PROGRAMMING
C ERROR. (The column number of the error is lost.)
C
C Revision 1.23  2004/03/10 13:10:05  rich
C Don't crash if "ALL" is too near the end of the command line during lexical
C scanning.
C
C Revision 1.22  2003/11/06 15:48:01  rich
C Improved part numbering rules. The group bit of the number (digits > 1000)
C should now be called the assembly number. The number may now be negative,
C the -ve sign is given to the part digits (<999) and these atoms are not
C allowed to form bonds to the same part using symmetry operators. Useful
C for assemblies disordered across a sym op.
C
C Revision 1.21  2003/08/05 11:11:11  rich
C Commented out unused routines - saves 50Kb off the executable.
C
C Revision 1.20  2003/06/27 11:59:04  rich
C Globally replace FRAGMENT (slot in L5) and FRAGMENT(...) lexical keyword
C with RESIDUE. This should reduce confusion about what it is, and as FRAGMENT
C is only months old, no-one should notice the change anyway. So now it is
C #EDIT
C DELETE RESI(1) RESIDUE(2)
C END
C to delete residues 1 and 2.
C
C Revision 1.19  2003/05/07 12:18:54  rich
C
C RIC: Make a new platform target "WXS" for building CRYSTALS under Windows
C using only free compilers and libraries. Hurrah, but it isn't very stable
C yet (CRYSTALS, not the compilers...)
C
C Revision 1.18  2003/02/27 12:48:54  rich
C Oops.
C
C Revision 1.17  2003/02/27 11:49:50  rich
C
C Two BRAND NEW lexical things:
C
C  You can now use, wherever appropriate, RESI(1,X's) syntax to
C  select all atoms whose residue number (slot 17 in L5) matches. This
C  works in EDIT, LIST 12, DIST, REGULARISE etc.
C
C  You can now use, wherever appropriate, TYPE(H,X's) syntax to
C  select all atoms whose type matches that given. This
C  works in EDIT, LIST 12, DIST, REGULARISE etc. Main use I can think
C  of is to quickly FIX all H positions (especially if using RESI to specify
C  bits to refine) or to special case a few heavy atoms: TYPE(AU,U'S).
C
C  If you say FULL U[ISO] TYPE(PB,U's) - it causes an error - this is better
C  than going silently crazy I suppose, but It would be nice if it just
C  overrode the iso setting, like FIX does: i.e. ALL(X'S) followed
C  by FIX(H,X'S) works as expected.
C
C Revision 1.16  2003/01/15 14:03:52  rich
C Remove debugging from PART processing.
C
C For every error message that prints a column number, output a star below the
C offending line in the offending column.
C
C In KLXRDD, return with an error on finding an invalid operator. Previously
C it muddled on, but all the card pointers were set negative causing trouble
C later.
C
C Remove all NCAWU output as part of an ongoing battle.
C
C In KATOMU, don't allow UNTIL to or from a PART - KATOMU gets called
C repeatedly for a single PART and would therefore return a range for every
C atom in the PART.
C
C Revision 1.15  2003/01/14 18:31:35  rich
C Right - this is a useful one and I'm quite pleased with it.
C
C Added a new lexical token PART to the scanner. The following
C examples show what you might do with it:
C ----
C Get distances between all atoms in part 1:
C   #DIST
C   INCLUDE PART(1)
C   END
C ----
C Competitively refine the occupancy of two parts, e.g. in disorder:
C   #LIST 12
C   FULL X'S U'S
C   EQUIV PART(1,OCC) PART(2,OCC)
C   WEIGHT -1 PART(1,OCC)
C   END
C ----
C Quickly id whole fragments in regularise:
C   #REGUL
C   target c(1) to c(6)
C   ideal c(11) to c(16)
C   cameron
C   map part(2)
C   onto part(1)
C   END
C ----
C Move a part of the structure:
C   #EDIT
C   ADD 0.2 PART(3,X)
C   END
C ----
C Have different regimes for refining e.g. a host and a guest molecule:
C   #LIST 12
C   FULL PART(0,X'S,U'S) PART(1,X'S,U[ISO])
C   END
C ----
C So it's quite handy. Part numbers are stored in the 15th slot of LIST 5, and
C are defined as follows:
C   ( 1000 * GROUPNUMBER ) + COMPONENTNUMBER.
C     e.g. 123456 is group 123 and component 456.
C   The same syntax is used to select a part in the lexical input:
C     e.g. PART(123456) selects atoms in group 123, component 456.
C   BUT, if the value of the group or component is 999, all atoms in that
C   group or component are selected.
C     e.g. PART(999003) selects all atoms with component 3 in their partnumber and
C     PART(4999) selects all atoms in group 4.
C
C The reason for having groups and parts is to enable logical grouping of, for example
C a disorder where all affected atoms are group 1, with each component being part 0,1,2 etc.
C
C NB. #script xparts runs a useful tool for defining part numbers.
C
C Revision 1.14  2002/11/06 10:50:57  rich
C Bug reading ATOM card in REGULARISE. Fixed.
C
C Revision 1.13  2001/06/19 08:19:19  richard
C Increased store limits as two people have now hit the barrier for LIST 16
C size. A complete recompilation of all fortran sources is required for consitency.
C Do at least a "code fortran", or a "buildall" to be really sure.
C
C Revision 1.12  2001/02/26 10:26:49  richard
C Added changelog to top of file
C
C
CODE FOR XILEXP
      SUBROUTINE XILEXP(IULN,IFIRST)
C--INITIATE LEXICAL SCANNER PROCESSING, BY SETTING VARIOUS CONSTANTS
C  AFTER THE SCANNER OUTPUT HAS BEEN STORED ON THE DISC.
C
C  IULN    THE LIST TYPE BEING PROCESSED
C  IFIRST  THE DISC ADDRESS OF THE FIRST RECORD HEADER.
C
C--THIS ROUTINE USES AND SETS WHERE NECESSARY THE FOLLOWING VARIABLES :
C
C  LK      THE LENGTH OF THE STORED ARGUMENT DETAILS IN WORDS.
C  LK1     THE LENGTH OF THE COMPLETE ARGUMENT IN WORDS MINUS ONE.
C  LK2     THE LENGTH OF THE COMPLETE ARGUMENT PRODUCED BY THE LEXICAL
C          SCANNER. THE FORMAT OF THIS IS AS FOLLOWS :
C
C          0  THE ARGUMENT TYPE :
C
C             -1  A VARIABLE, STORED AS 'LK' WORDS OF A4 CHARACTER DATA.
C              0  A NUMBER, WHOSE VALUE IS GIVEN IN WORD 2.
C             >0  AN OPERATOR, WHOSE TYPE IS GIVEN BY THE NUMBER IN THIS
C                 LOCATION. ALLOWED VALUES ARE :
C
C                 1  +
C                 2  -
C                 3  *
C                 4  /
C                 5  **
C                 6  (
C                 7  )
C                 8  ,
C                 9  =
C
C          1  THE CHARACTER NUMBER ON THE CARD WHERE THIS ARGUMENT ENDED
C          2  THE FIRST WORD OF THE ARGUMENT. FOR A NUMBER THIS IS THE
C             VALUE, WHILE FOR THE OTHERS IT IS THE START OF OF 'LK' WOR
C             CONTAINING THE ARGUMENT IN CHARACTER FORM.
C          3  THE SECOND WORD OF THE ARGUMENT.
C
C  NWCARD  THE NUMBER OF WORDS PER CARD WHEN IT IS STORED IN A4 FORMAT.
C  LARG    THE DISC ADDRESS OF THENEXT DATA RECORD HEADER BLOCK TO
C          BE PROCESSED.
C  MARG    THE DISC ADDRESS OF THE LAST DATA RECORD HEADER BLOCK
C          LOOKED AT BY 'KLDNLR'.
C  MDARG   THE NUMBER OF WORDS PER ARGUMENT, EQUAL TO 'LK2'.
C  NARG    THE NUMBER OF ARGUMENTS CURRENTLY IN CORE, EQUAL TO 'ME'.
C  MA      THE DISC ADDRESS OF THE NEXT DATA RECORD HEADER BLOCK TO
C          BE PROCESSED BY THE PRINT ROUTINE 'XPCLNN'.
C  MB      THE DISC ADDRESS OF THE LAST DATA RECORD HEADER BLOCK
C          PROCESSED BY THE PRINT ROUTINE 'XPCLNN'.
C  MC      THE NUMBER OF CARDS PRINTED MINUS ONE.
C  MD      THE ADDRESS IN CORE OF THE CURRENT SET OF ARGUMENTS.
C  ME      THE NUMBER OF ARGUMENTS ON THE CURRENT CARD.
C  MF      THE ADDRESS IN CORE OF THE CURREN ARGUMENT.
C  MG      THE FUNCTION OF THIS CARD, IN THE RANGE 1 TO N.
C
C  MQ      THE ADDRESS IN CORE AT WHICH ATOM AND PARAMETER HEADER BLOCKS
C          ARE SET UP.
C
C--
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XCNTRL.INC'
C
C--SET THE LIST AND RECORD TYPE
      LN=IULN
      IREC=0
C--SET THE DISC ADDRESS POINTERS
      LARG=IFIRST
      MARG=0
C--SET THE OTHER CONSTANTS
      MDARG=LK2
      NARG=0
C--SET THE PRINT VALUES
      MA=LARG
      MB=MARG
      MC=0
      MD=NFL
      ISTAT2=0
      RETURN
      END
C
CODE FOR KLDNLR
      FUNCTION KLDNLR(IN)
C--LOAD THE NXT LEXICAL RECORD FROM THE DISC FOR PROCESSING
C
C  IN      A DUMMY ARGUMENT.
C
C--RETURN VALUES ARE :
C
C  -1  END OF THE LEXICAL DATA
C   0  NEXT RECORD LOADED OKAY.
C  +1  AN ERROR PREVENTS AN MORE PROCESSING.
C
C--
      INCLUDE 'HEADES.INC'
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XLXPRT.INC'
C
      INCLUDE 'QSTORE.INC'
C
      IDWZAP = IN
      NPTTOT = -1
      NPTCUR = -1
C--SET AN INITIAL RETURN VALUE
      KLDNLR=-1
C--LOAD THE NEXT DATA RECORD HEADER
1000  CONTINUE
      IF(KLDDRH(MARG,LARG,IBUFF))1050,1100,1100
C--AND NOW RETURN
1050  CONTINUE
      RETURN
C--CHECK IF THIS RECORD IS CORE LOADABLE
1100  CONTINUE
      IF(IBUFF(7))1000,1150,1150
C--ALLOCATE SOME CORE FOR THIS RECORD  -  COMPUTE ITS LENGTH
1150  CONTINUE
      I=IBUFF(5)*IBUFF(6)
C--ASSIGN THE PARAMETER HEADER LOCATION
      MQ=MD+I
C--ASSIGN 'NFL'
      NFL=MQ+200
C--CHECK THE CORE LIMITS
      IF(NFL-LFL)1250,1250,1200
C--NOT ENOUGH CORE
1200  CONTINUE
      CALL XPCLNN(LN)
      CALL XICA
      KLDNLR=1
      GOTO 1050
C--BRING THE RECORD DOWN
1250  CONTINUE
      IF(I)1350,1350,1300
C--THERE IS SOME DATA TO LOAD
1300  CONTINUE
      CALL XDOWNF(IBUFF(4),STORE(MD),I)
C--SET THE CONTRL POINTERS
1350  CONTINUE
      ME=IBUFF(6)
      MF=MD
      NARG=ME
      IREC=IBUFF(7)
      MG=MOD(IREC,100)
      KLDNLR=0
      GOTO 1050
      END
C
C
C
C
CODE FOR KLXRDD
      FUNCTION KLXRDD ( ICOMMN , IDIMN , IADARG , IADCRD , NARGCD ,
     2 NCARD , ILAST )
C
C -- THIS ROUTINE READS A SINGLE DIRECTIVE FROM THE INPUT STREAM
C    AND SETS UP THE APPROPRIATE INTERNAL REPRESENTATIONS FOR THE
C    LEXICAL SCANNER.
C
C------ 1994. THE ARGUMENT 'ALL' IS SUBSTITUTED BY 'FIRST UNTIL LAST'
C------       'MOUSE' WILL BE SUBSTITUTED BY A STRING OF ATOM NAMES
C
C
C      ICOMMN      'COMMON BLOCK' FOR READ
C      IDIMN       DIMENSION OF 'ICOMMN'
C      IADARG      ( OUTPUT ) ADDRESS OF DATA
C      IADCRD      ( OUTPUT ) ADDRESS OF CARD IMAGES
C      NARGCD      ( OUTPUT ) NUMBER OF ARGUMENTS FOUND
C      NCARD       ( OUTPUT ) NUMBER OF CARDS READ
C      ILAST       NUMBER OF LAST DIRECTIVE READ. THIS SHOULD BE SET TO
C                  -1 BEFORE THE FIRST CALL TO THIS ROUTINE
C
C
C ---- 2001. This routine forms an image of the input cards in store.
C ---- so the size of the lexical lists is limited to approximately
C ---- ( ISIZST / 80 ). Was 131072 (1634 lines) until Jun 19 2001, and
C ---- 262144 thereafter (3278 lines). Ideally they could be compressed
C ---- somehow (e.g. omitting trailing blanks), but this makes them
C ---- difficult to store to disk. Also we must be able to guarantee that
C ---- the list can be read BACK into store later, so the compressed
C ---- format for lexical lists would have to be supported everywhere.
C
C
C            VERSION 1      AUGUST 1983
C
C
C--RETURN VALUES ARE :
C
C      -1      ERROR(S) IN DATA
C       0      END
C      >1      DIRECTIVE NUMBER READ
C
C--
C--
      DIMENSION KMOUSE(5), KCONT(4), KALL(3), KREM(3), KSMILE(3)
      CHARACTER *240 CMOUSE
      DIMENSION ICOMMN(IDIMN)
C
      INCLUDE 'ISTORE.INC'
      INCLUDE 'KCHAR.INC'
C
C      DIMENSION BLANK(1)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLST50.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XCARDS.INC'
      INCLUDE 'XLEXCH.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XLXPRT.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QCHAR.INC'
C
C      EQUIVALENCE ( BLANK , IB )
C
C
      DATA NXA/9/,LXA/1/
#ifdef _HOL_
      DATA KMOUSE/1HM ,1HO ,1HU ,1HS ,1HE /
      DATA KCONT/1HC ,1HO ,1HN ,1HT /
      DATA KALL/1HA ,1HL ,1HL /
      DATA KREM/1HR ,1HE ,1HM /
      DATA KSMILE/1HS ,1HM ,1HI /
#else
      DATA KMOUSE/'M','O','U','S','E'/
      DATA KCONT/'C','O','N','T'/
      DATA KALL/'A','L','L'/
      DATA KREM/'R','E','M'/
      DATA KSMILE/'S','M','I'/
#endif
C
C----- SET NO MOUSE INPUT YET
      IMOUSE = 0
C
      NPTTOT = -1
      NPTCUR = -1
      IDIRNM = 0

      IADARG = MD
      NCHRRD = 0
      NXTCDI = KSTALH ( NWCARD )
      IADCRD = NXTCDI
      NARGCD = 0
C
C -- MC IS THE ADDRESS OF THE CURRENT ARGUMENT GROUP ( UPDATED BEFORE
C    USE )
      MC = IADARG - LK2
      NCARD = 0
      NBRACK = 0
C
C
      IF ( ILAST .LT. 0 ) GO TO 7000
      IF ( ILAST .EQ. 0 ) GO TO 8000
C
1400  CONTINUE
C -- IF THIS IS THE FIRST DIRECTIVE, SET DIRECTIVE NUMBER
      IF ( ILAST .LE. 0 ) ILAST = IDIRNM
C
C -- RESTORE DIRECTIVE POINTERS
C
      CALL XDIRFL ( ILAST , ICOMMN , IDIMN )
C
C -- CHECK FOR A 'DATA RECORD' TYPE DIRECTIVE
      IF ( ISTORE(MR61+11) .NE. 0 ) GO TO 1600
C
1500  CONTINUE
C--NOT A DATA RECORD  -  PROCESS THIS RECORD NORMALLY
C
      IDWZAP = 0
      ISTAT = KFNDNP ( IDWZAP )
      IF ( ISTAT .LT. 0 ) GO TO 9900
      IF ( ISTAT .EQ. 0 ) GO TO 7000
C
      ISTAT = KRDPV ( ICOMMN , IDIMN )
      IF ( ISTAT .LT. 0 ) GO TO 9900
      IF ( ISTAT .GT. 0 ) GO TO 9900
C
      GO TO 1500
C
C
1600  CONTINUE
C
C -- A DATA RECORD. STORE CARD IMAGE
C
C -- IF CARDS HAVE BEEN READ IN PREVIOUSLY THESE MUST BE MOVED NOW
      IF ( NCARD .LE. 0 ) GO TO 1610
C -- MOVE PREVIOUS CARDS READ
      I = IADCRD
      IADCRD = KSTALH ( NWCARD )
      
      CALL XMOVE ( STORE(I) , STORE(IADCRD) , NCHRRD )
C
1610  CONTINUE
c      WRITE(NCWU,'(a,80a1)')'LX ',(IMAGE(JTEM),JTEM=NC,NC+80)

C----- LOOK FOR 'ALL'
C This will turn "ALL" into "FIRST UNTIL LAST" and
C "ALL(X's)" into "FIRST(X's)" UNTIL LAST

      J = KEQUAL (NC, KALL(1))
      IF (J .GT. 0) THEN
        IF (KCOMP (3, IMAGE(J), KALL(1), 1, 3) .GT. 0) THEN
C----- LOOK FOR BLANK AFTER 'ALL'
          K = KEQUAL (J+3, IB)
          CMOUSE = ' '
          CMOUSE(1:5) = 'FIRST'
          IF ( K-J .GT. 3) THEN
            WRITE(CMOUSE(6:),'(18A1)')  (IMAGE(L),L=J+3,K)
          ENDIF
          CALL XFILL (IB, IMAGE(J), 80-J+1)
          CMOUSE(6+K-J-3:)= ' UNTIL LAST '
          IF(K+16 .GT. 240) GOTO 9920
          READ (CMOUSE, '(240A1)') (IMAGE(L),L=J, K+16)
          CALL XMOVEI ( IMAGE, LCMAGE, 80)
        ENDIF
      ELSE
        J = KEQUAL (NC, KMOUSE(1))
        IF (J .GT. 0) THEN
          IF (KCOMP (5, IMAGE(J), KMOUSE(1), 1, 5) .GT. 0) THEN
              CALL XFILL (IB, IMAGE(J), 80-J+1)
              CALL XMOVEI ( IMAGE, LCMAGE, 80)
              NMOUSE = 0
#ifdef _DOS_
             CALL XRDMSE (CMOUSE, NMOUSE)
#endif
              IMOUSE = 1
          ENDIF
        ENDIF
      ENDIF
C
C -- STORE CURRENT CARD IMAGE
      CALL XFA4CS( IMAGE(1) , STORE(NXTCDI) , LASTCH )
C -- UPDATE COUNTERS
      NCARD = NCARD + 1
      NCHRRD = NCHRRD + NWCARD
c       write(ncwu,'(a,256a1)') 'o: ',(image(itemp),itemp=1,lastch)
c       write(ncwu,'(a,64a4)') 'p: ',(STORE(itemp),
c     1 itemp=nxtcdi,nxtcdi+lastch/4)

C
C--- LOOK FOR 'REM' OR 'SMILES'
      IF ((KCOMP (3, IMAGE(1), KREM(1), 1, 3) .GT. 0) .or.
     1   (KCOMP (3, IMAGE(1), KSMILE(1), 1, 3) .GT. 0)) then
c         write(ncwu,'(256a1)') (image(itemp),itemp=1,lastch)
c-----   set current position to after last character
         nc = lastch+1
         ISKIP = 1
C---- DONT INTERPRET REM OR SMILES CARDS
         goto 7000
      ENDIF
C
C----- LOOK FOR 'CONT'
      IF (KCOMP (3, IMAGE(1), KCONT(1), 1, 3) .GT. 0) THEN
            IF (ISKIP .eq. 1) THEN
C---- DONT INTERPRET IF LAST CARD WAS A REM OR SMILES CARD
                  NC = LASTCH + 1
                  GOTO 7000            
            ENDIF
      ENDIF
C
C----- RESET ISKIP TO NON-MESSAGE STATUS
      ISKIP = 0
C----- INITIALISE THE OPERATOR STATUS
      MA = 0
1750  CONTINUE
C
C -- **** ARGUMENT PROCESSING LOOP STARTS HERE ****
C
C -- CHECK IF THERE ARE ANY MORE ARGUMENTS TO PROCESS ON THIS CARD
C
      NC = KNEQUL ( NC , IB )
      IF ( NC .LE. 0 ) GO TO 7000
C
C -- AN ARGUMENT HAS BEEN FOUND. MAKE SPACE. UPDATE COUNTER. SET
C    CHARACTER PART OF DATA TO BLANKS
C
      MC = MC + LK2
C -- CHECK DATA HAS NOT OVERRUN ALLOWED AREA
      LIMIT = MG
      IF ( MG .LE. 0 ) LIMIT = LFL
      IF ( MC .GE. LIMIT ) GO TO 9910
      NARGCD = NARGCD + 1
      CALL XMVSPD ( IB , STORE(MC+2) , LK2 )
C
C -- CHECK FOR AN OPERATOR AND IF FOUND BRANCH ON ITS TYPE
C
      I = KCOMP ( 1 , IMAGE(NC) , KCHAR(1) , NXA , LXA )
      IF ( I .LE. 0 ) GO TO 2600
C
      GO TO ( 2300 , 2300 , 2000 , 2300 , 2300 ,
     2 2150 , 2200 , 2300 , 2300 , 9920 ) , I
      GO TO 9920
C
C
2000  CONTINUE
C -- OPERATOR  FOUND IS '*'  -  CHECK FOR '**'
C -- LOCATE NEXT NON-BLANK CHARACTER AND CHECK FOR A SECOND '*'
C -- IF IT IS FOUND CHANGE OPERATOR NUMBER AND CHARACTER POSITION
C
      N = NC + 1
      N =  KNEQUL ( N , IB )
      IF ( N .LE. 0 ) GO TO 2300
C
      IF (   KCOMP ( 1,IMAGE(N),KCHAR(3),1,1 )  .LE.   0  ) GO TO 2300
C
      I=5
      NC=N
C
      GOTO 2300
C
2150  CONTINUE
C -- '(' FOUND. UPDATE COUNTER
      NBRACK = NBRACK + 1
      GOTO 2300
C -- ')' FOUND. DECREMENT COUNTER AND CHECK FOR UNDERFLOW
2200  CONTINUE
      NBRACK = NBRACK - 1
      IF ( NBRACK .LT. 0 ) GO TO 9930
C
2300  CONTINUE
C -- THIS IS THE GENERAL OPERATOR PROCESSING SECTION. THE OPERATOR
C    NUMBER AND THE CHARACTERS FOR THE OPERATOR ARE STORED AS THE
C    ARGUMENT AND THE POINTER MOVED.
C
      ISTORE(MC) = I
      CALL XMOVEI ( KCHAR(I) , ISTORE(MC+2) , 1 )
      NC = NC + 1
C
2350  CONTINUE
C--SUNDRY TERMINATION OPERATIONS AFTER EACH OPERATOR, NUMBER OR
C    VARIABLE
C
C -- STORE CHARACTER POSITION FOR THE ARGUMENT FOUND. CHECK FOR ILLEGAL
C    COMBINATIONS OF ARGUMENTS
      ISTORE(MC+1)=NC+ME-1
C--CHECK THAT THE LAST OPERAND IS ALLOWED
      IF(KBITS(MA,KB(I)))2400,2550,2400

2400  CONTINUE
      J=NC-1
      CALL XMONTR(0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,2450)J
      WRITE ( CMON, 2450) J
      CALL XPRVDU(NCEROR, 1,0)
2450  FORMAT(' Illegal combination of arguments or characters',
     2 ' at or before column ',I5)
C--ERROR TERMINATION FOR THIS DIRECTIVE
      LEF=LEF+1
      IDIRFL=-1
      MB=-1000000
CRIC0103      GOTO 7000   !No good - keeps going but with invalid pointers.
      GOTO 9900

C--SET THE LAST ARGUMENT CHECK VALUE
2550  CONTINUE
      MA=KC(I)
      GOTO 1750
C
C--CHECK IF THE NEXT OPERAND IS A NUMBER
2600  CONTINUE
      IF(KINPUT(T))2650,2650,2750
C--END OF NUMBER FOUND  -  NON-NUMERIC CHARACTER WHICH IS NOT '.'
2650  CONTINUE
      ISTORE(MC)=0
      STORE(MC+2)=T
C--CHECK IF THE TERMINATOR WAS A ','
      IF(IMAGE(NC-1).EQ.ICOMMA)NC=NC-1
      I=KN
C--CHECK THAT THE NUMBER TERMINATED PROPERLY
      IF(NC)2350,2350,2700
C--CHECK FOR A BLANK
2700  CONTINUE
      IF(IMAGE(NC).EQ.IB)GOTO 2350
C--CHECK FOR AN OPERATOR
      IF(KCOMP(1,IMAGE(NC),KCHAR(1),NXA,LXA))2400,2400,2350
C
C--THE NEXT SEQUENCE OF CHARACTERS IS NOT AN OPERATOR OR A NUMBER
C  ACCORDINGLY IT IS TREATED AS A VARIABLE, TO BE TERMINATED
C  BY AN OPERATOR OR A BLANK SPACE
2750  CONTINUE
      I=KV
      ISTORE(MC)=-1
      ND=NC
C--BEGIN SEARCH FOR THE TERMINATING CHARACTER
2800  CONTINUE
      ND=ND+1
      IF(ND-LASTCH)2850,2850,2900
C--THERE IS ANOTHER CHARACTER ON THE CARD  -  CHECK IF IT IS A BLANK
2850  CONTINUE
      IF(IMAGE(ND).EQ.IB)GOTO 2900
C--CHECK THE CHARACTER AGAINST THE OPERATOR LIST
      M=KCOMP(1,IMAGE(ND),KCHAR(1),NXA,LXA)
      IF(M)2800,2800,2900
C--READ THE VARIABLE TERMINATED BY AN OPERATOR
2900  CONTINUE
      CALL XFA4CS(IMAGE(NC),STORE(MC+2),MIN0(LK*4,ND-NC))
      NC=ND
      GOTO 2350
C
C
7000  CONTINUE
C -- READ THE NEXT DIRECTIVE FROM THE INPUT STREAM
C
C
      IF (IMOUSE .EQ. 0) THEN
      IDIRNM = KRDNDC ( ICOMMN , IDIMN )
      ELSE
C----- CREATE A CONTINUATION CARD
            IDIRNM = 0
            CALL XMOVEI (KCONT(1), IMAGE(1), 4)
            IMAGE(5) = IB
            JMOUSE = MIN ( NMOUSE, MMOUSE+75-1)
            READ (CMOUSE(MMOUSE:), '(75A1)')
     1      (IMAGE(J+6-MMOUSE),J=MMOUSE,JMOUSE)
            IF (ISSPRT .EQ. 0) WRITE(NCWU,7010) (IMAGE(J),J=1,75)
            WRITE ( CMON, 7010) (IMAGE(J),J=1,75)
            CALL XPRVDU(NCEROR, 1,0)
7010        FORMAT (1X,75A1)
            MMOUSE = MMOUSE + JMOUSE
            NC = 5
            ND = 5
C            CHECK IF WE ARE AT END OF MOUSE BUFFER
            IF (MMOUSE .GE. NMOUSE) IMOUSE = 0
      ENDIF
C
C
C -- IF THIS IS A CONTINUATION OF THE PREVIOUS DIRECTIVE RETURN TO
C    PROCESS PARAMETERS
      IF ( IDIRNM .EQ. 0 ) GO TO 1400
C
C
8000  CONTINUE
C
C -- **** TERMINATION ROUTINES ****
C
C -- FINAL SYNTAX CHECK
      IF ( NBRACK .NE. 0 ) GO TO 9930
C
C -- SET RETURN VALUE
      KLXRDD = ILAST
      ILAST = IDIRNM
C -- CHANGE NUMBER FOR 'END' TO 0
      IF ( ILAST .LT. 0 ) ILAST = 0
C
      RETURN
C
C
9900  CONTINUE
C
C -- **** ERROR HANDLING ****
C
      KLXRDD = -1
      ILAST = -1
      RETURN
C
9910  CONTINUE
C -- INSUFFICIENT SPACE AVAILABLE
      CALL XOPMSG ( IOPCRY , IOPSPC , 0 )
      GO TO 9900
9920  CONTINUE
C -- INTERNAL ERROR
      CALL XOPMSG ( IOPCRY , IOPINT , 0 )
      GO TO 9900
9930  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 9935 )
      WRITE ( CMON, 9935 )
      CALL XPRVDU(NCEROR, 1,0)
9935  FORMAT ( 1X , 'The numbers of ( and ) do not match ' )
      GO TO 9900
C
      END
C
C
C
CODE FOR KLXSNG
      FUNCTION KLXSNG ( ICOMMN , IDIMN , ILAST )
C
C -- THIS ROUTINE READS A SINGLE ITEM FROM THE INPUT STREAM USING
C    'KLXRDD' AND SETS UP THE POINTERS FOR IMMEDIATE PROCESSING
C
C
      DIMENSION ICOMMN(IDIMN)
C
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
C
C
      IDIR = KLXRDD ( ICOMMN,IDIMN,IARGC,ICARD,NARGC,NCARD,ILAST )
C
      LARG = 0
C
      MA = 0
      ME = NARGC
      MF = IARGC
C
C
      KLXSNG = IDIR
      RETURN
      END
C
C
C
CODE FOR XLXINI
      SUBROUTINE XLXINI ( ILAST , ICHNG )
C
C -- FIX UP DIRECTIVES ETC. FOR LEXICAL SCANNER INPUT
C----- ICHNG  SWITCH TO CAUSE MODIFICATION OF READ COUNTS
C             0      DO NOT MODIFY
C             1      MODIFY
C
C
      LOGICAL INSTR
      LOGICAL DATREC
C
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST50.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XOPVAL.INC'
C
      INCLUDE 'QSTORE.INC'
C
C
C -- FIX UP EACH DIRECTIVE IN AN APPROPRIATE WAY
C
      IF ( NR60 .LE. 0 ) GO TO 1400
C
      MR60 = LR60
      MR61 = LR61
C
C -- EACH DIRECTIVE MUST APPEAR TO HAVE BEEN READ ONCE EXCEPT FOR THOSE
C    WHICH WILL APPEAR ONCE ONLY, SUCH AS NON DATA RECORD DIRECTIVES
C    WHICH ARE ALSO INSTRUCTION NAMES ( E.G. 'MODIFY' , BUT NOT 'HELP')
C
      DO 1300 I = 1 , NR61
C
      IDATA = ISTORE(MR61+11)
      IF ( IDATA .LT. 0 ) GO TO 9910
C --
      DATREC = ( IDATA .GT. 0 )
      INSTR = ( I .EQ. NR61 )
C
C -- CHECK FOR AN INSTRUCTION WHICH IS NOT A DATA RECORD
      IF ( INSTR .AND. ( .NOT. DATREC ) ) GO TO 1250
      IF (  ( ICHNG .LE. 0 ) .AND. ( .NOT. DATREC )  ) GO TO 1250
C
      ISTORE(MR61+8) = 1
      ISTORE(MR61+9) = LK2
      ISTORE(MR61+12) = 5
C
1250  CONTINUE
      MR60 = MR60 + MDR60
      MR61 = MR61 + MDR61
C
1300  CONTINUE
C
C
C
1400  CONTINUE
C
C -- ALLOCATE A BUFFER FOR COMMAND PROCESSING
C -- 'MD' IS BEGINNING AND 'MG' IS THE END
cdjwoct09 double buffer size
      MD = KSTALL ( 32000 )
      MG = MD + 32000
C -- SET DIRECTIVE TYPE FLAG
      ILAST = -1
C
      RETURN
C
9910  CONTINUE
      CALL XOPMSG ( IOPCRY , IOPINT , 0 )
C      STOP
      CALL GUEXIT(2011)
      END
C
C
C
CODE FOR KATOMU
      FUNCTION KATOMU(IN)
C--PROCESS THE OUTPUT FROM THE LEXICAL SCANNER TO FIND
C  ONE OR MORE LINKED ATOM NAMES, AND THEN FIND THE ATOMS IN LIST 5.
C
C--RETURN VALUES :
C
C  -1  END OF CARD FOUND.
C   0  ERROR IN ATOM DEFINITION.
C  >0  NEXT FREE LOCATION
C
C--LIST 5 IS SEARCHED IF L5 IS GREATER THAN ZERO. LIST 12 IS SEARCHED
C  IF L12A IS GREATER THAN ZERO AND L5 IS GREATER THAN ZERO.
C
C--OTHER IMPORTANT VARIABLES :
C
C  MQ   SET TO THE ADDRESS OF THE FIRST ATOM HEADER (BEFORE ENTRY)
C  M5A  LOCATION OF THE FIRST ATOM IN LIST 5
C  N5A  NUMBER OF ATOMS FOUND
C  L12A ADDRESS OF THE FIRST ATOM IN LIST 12  (L12 NEG. IF NOT NEC.)
C
C--THE FORMAT OF THE OUTPUT ATOMS IS IN STANDARD FORMAT.
C  THE SECOND OF AN 'UNTIL' SEQUENCE IS LINKED TO THE FIRST
C  IN TERMS OF ABSOLUTE ADDRESSES
C
C--THE FORMAT OF THE ATOM INFORMATION IS :
C
C   0  LINK LOCATION OR 'NOWT'
C   1  LENGTH OF THE ENTRY  (NOT SET HERE)
C   1  TYPE
C   3  SERIAL
C   4  NOT USED ('NOWT')
C   5  NUMBER OF PARAMETERS
C   6  ADDRESS OF THE FIRST PARAMETER REL. TO MQ OR 'NOWT'
C   7  S
C   8  L
C   9  T(X)
C  10  T(Y)
C  11  T(Z)
C  12  ADDRESS OF THE ATOM IN LIST 5 ('NOWT')
C  13  ADDRESS OF THE ATOM IN LIST 12 ('NOWT')
C  14  NOT USED ('NOWT')
C  15  ADDRESS OF THE GENERATED PARAMETERS ('NOWT')
C  16  ADDRESS OF THE PARAMETERS TO BE USED ('NOWT')
C
C--FOR EACH PARAMETER :
C
C  0  LINK TO NEXT PARAMETER REL. TO MQ OR 'NOWT'
C  1  POSITION IN THE ARGUMENT LIST
C  2  NOT USED (PARTIAL DERIVATIVE)
C
C--
      INCLUDE 'ISTORE.INC'
C
      DIMENSION IOPS(1)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST12.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XAPK.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XLXPRT.INC'
C
      INCLUDE 'QSTORE.INC'
C
C
#ifdef _HOL_ 
      DATA NOPS/1/,LOPS/1/,IOPS(1)/4HUNTI/
#else
      DATA NOPS/1/,LOPS/1/,IOPS(1)/'UNTI'/
C
#endif
      IDWZAP = IN
      II=KATOMH(MQ)
      IF(II)1000,1050,1200   !CHECK THAT AN ATOM HAS BEEN FOUND CORRECTLY

1000  CONTINUE     !END OF CARD  -  BACKSPACE ONE ARGUMENT
      MF=MF-LK2

1050  CONTINUE     !ERROR IN ATOM DEFINITION
      CALL XADE(ISTORE(MF+1))

1100  CONTINUE     !SET THE RETURN VALUE AND EXIT
      KATOMU=II
1150  CONTINUE
      RETURN

1200  CONTINUE
      INPART = 0
      IF ( NPTCUR .GE. 0 ) INPART = 1   !Are we processing a part or frag?
      IF(L5)1400,1400,1250 !CHECK IF WE SHOULD LOOK FOR THIS ATOM IN LIST 5
C--SEARCH FOR THE ATOM IN LIST 5
1250  CONTINUE
      M5A=L5
      N5A=N5
      L12A=L12
      IF(KATOMF(STORE(MQ+2),M5A,N5A,MD5A,L12A))1300,1400,1300

C--ATOM NOT IN LIST 5
1300  CONTINUE
      II=MQ+2
      CALL XPCLNN(LN)
      CALL XMISL5(1,ISTORE(MQ+1),II)
C--SET THE ERROR FLAG
1350  CONTINUE
      KATOMU=0
      GOTO 1150

C--CHECK IF THIS IS AN 'UNTIL' TYPE OF COMMAND
1400  CONTINUE
      IF(ME)1450,1450,1500   !END OF CARD - NOT AN 'UNTIL' SEQUENCE

1450  CONTINUE
      N5A=1
      GOTO 1100

1500  CONTINUE
      IF(ISTORE(MF))1550,1450,1450   !CHECK THE TYPE OF THE NEXT ARGUMENT

1550  CONTINUE
      JJ=KCOMP(1,ISTORE(MF+2),IOPS,NOPS,LOPS) !SEARCH FOR 'UNTIL' COMMAND
      IF(JJ)1450,1450,1600

1600  CONTINUE
      ME=ME-1
      IF ( INPART .EQ. 1 ) GOTO 1650 !No UNTILs with PARTs or RESIs, please.
      IF(ME)1700,1700,1800        !CHECK FOR AN END OF CARD AFTER 'UNTIL'

1650  CONTINUE                   !ERROR IN AN 'UNTIL' SEQUENCE
      MF=MF-LK2
1700  CONTINUE
      CALL XPCLNN(LN)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1750)BLANKS(1:ISTORE(MF+1)+6),
     1                                   ISTORE(MF+1)
      WRITE ( CMON, 1750) BLANKS(1:ISTORE(MF+1)+6),ISTORE(MF+1)
      CALL XPRVDU(NCEROR, 2,0)
1750  FORMAT(A,'*',/,' Illegal ''UNTIL'' sequence at about column',I5)
      LEF=LEF+1
      GOTO 1350

1800  CONTINUE                      !COMPILE THE DATA FOR THE SECOND ATOM
      MF=MF+LK2
      JJ=MQ
      ISTORE(MQ+1)=STORE(MQ+1)+1024
      MQ=II
      II=KATOMH(MQ)
      IF(II)1000,1050,1850 !CHECK THE REPLY

1850  CONTINUE
      IF ( INPART .EQ. 1 ) GOTO 1650 !No UNTILs with PARTs or RESIs, please.
      IF(ISTORE(MQ+5))1650,1900,1650 !CHECK NO PARAMS READ FOR THIS ATOM

C--LINK THE ATOM HEADERS AND CHECK IF WE MUST SEARCH THROUGH LIST 5
1900  CONTINUE
      ISTORE(JJ)=MQ
      IF(L5)2050,2050,1950
C--SEARCH FOR THE ATOM IN LIST 5
1950  CONTINUE
      KK=M5A
      LL=N5A
      NN=L12A
      IF(KATOMF(STORE(MQ+2),KK,LL,MD5A,NN))1300,2000,1300
C--COMPUTE THE NUMBER OF ATOMS
2000  CONTINUE
      N5A=N5A-LL+1
C--UPDATE AND RETURN
2050  CONTINUE
      MQ=JJ
      GOTO 1100
      END
C
CODE FOR KATOMH
      FUNCTION KATOMH(IN)
C--GENERATE THE ATOM INFORMATION FROM THE RESULTS OF THE LEXICAL SCAN
C
C  IN      A DUMMY ARGUMENT.
C
C--RETURN VALUES ARE :
C
C  -1   END OF CARD DETECTED.
C   0   ERROR DURING THE PROCESSING.
C  >0   THE NEXT FREE ADDRESS AFTER THE LAST PIECE OF ATOM INFORMATION.
C
C--RETURNS WITH 'ME' AND 'MF' SET TO THE NEXT ELEMENT ON THE
C  CARD TO BE PROCESSED, AND CHECKS FOR THE END OF CARD
C  AT THE START OF THE SCAN.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLEXIC.INC'
C
      INCLUDE 'QSTORE.INC'
C
      IDWZAP = IN
C--CHECK FOR END OF CARD
      IF(ME)1000,1000,1050
C--END OF CARD FOUND
1000  CONTINUE
      KATOMH=-1
      GOTO 1200
C--CALL 'KATOMG' TO PROCESS THE ARGUMENT LIST
1050  CONTINUE
      KA=KATOMG(MQ)
C--CHECK THE REPLY
      IF(KA)1100,1100,1150
C--ERROR DURING THE PROCESSING
1100  CONTINUE
      KATOMH=0
      GOTO 1200
C--ATOM HEADER OUTPUT OKAY
1150  CONTINUE
      ME=ME-1
      MF=MF+LK2
      KATOMH=KA
1200  CONTINUE
      RETURN
      END
C
CODE FOR KATOMG
      FUNCTION KATOMG(IN)
C--GENERATE THE ATOM INFORMATION FROM THE RESULTS OF THE LEXICAL SCAN
C
C  IN      A DUMMY ARGUMENT.
C
C--RETURN VALUES ARE :
C
C  <1  ERROR
C  >0  THE NEXT FREE ADDRESS AFTER THE LAST PIECE OF ATOM INFORMATION.
C
C--RETURNS WITH 'ME' AND 'MF' SET TO THE LAST ELEMENT ON THE
C  CARD PROCESSED, NOT THE NEXT ONE TO BE PROCESSED.
C  THIS IS SO THAT DIAGNOSTICS CAN BE ACCURATELY POSITIONED.
C
C--THE FORMAT OF THE ATOM INFORMATION IS :
C
C   0  LINK LOCATION OR 'NOWT'
C   1  LENGTH OF THE ENTRY  (NOT SET HERE)
C   2  TYPE
C   3  SERIAL
C   4  NOT USED ('NOWT')
C   5  NUMBER OF PARAMETERS
C   6  ADDRESS OF THE FIRST PARAMETER REL. TO MQ OR 'NOWT'
C   7  S
C   8  L
C   9  T(X)
C  10  T(Y)
C  11  T(Z)
C  12  ADDRESS OF THE ATOM IN LIST 5 ('NOWT')
C  13  ADDRESS OF THE ATOM IN LIST 12 ('NOWT')
C  14  NOT USED ('NOWT')
C  15  ADDRESS OF THE GENERATED PARAMETERS ('NOWT')
C  16  ADDRESS OF THE PARAMETERS TO BE USED ('NOWT')
C
C--FOR EACH PARAMETER :
C
C  0  LINK TO NEXT PARAMETER REL. TO MQ OR 'NOWT'
C  1  POSITION IN THE ARGUMENT LIST
C  2  NOT USED (PARTIAL DERIVATIVE)
C
C--DOES NOT CHECK FOR THE END OF THE CARD AT THE START
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XSCALE.INC'
      INCLUDE 'XFIRST.INC'
      INCLUDE 'XAPK.INC'
      INCLUDE 'XSHORT.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XLXPRT.INC'
      INCLUDE 'QSTORE.INC'

100   CONTINUE

      IDWZAP = IN
      KA=0
      KB=0
      KBB=0
      IF(ISTORE(MF).GT.0) GOTO 1000 ! CHECK 1st OP IS A VARIABLE (ATOM TYPE)

C--START TO FORM THE ATOM HEADER BLOCK  -
C-- CHECK FOR 'FIRST', 'LAST', 'PART', 'RESIDUE', 'TYPE'
1100  CONTINUE
      II=KCOMP(1,ISTORE(MF+2),IFIRST(1),7,1)
      IF ( ( II. EQ. 1 ) .OR. ( II .EQ. 2 ) ) THEN !This is First or Last
        KA = -1
      ELSE IF ( ( II .GE. 3 ) .AND. ( II .LE. 7 ) ) THEN  !Part,REsi or Type
        KB = 1
        IF ( II .EQ. 5 ) KBB = 1 ! We are looking for a char.
        OME=ME
        OMF=MF
        IF ( NPTCUR .LT. 0 ) THEN   !First time. Initialise.
           NPTCUR = 0
           NPTTOT = 1
        ELSE
           NPTCUR = NPTCUR + 1
           IF ( NPTCUR .GT. NPTTOT ) THEN
             NPTCUR = -1
             GOTO 1000
           END IF
        END IF
      END IF

C SET UP THE HEADER LINK INFORMATION
      ISTORE(MQ)=NOWT
      ISTORE(MQ+1)=0
      J=MQ+2

      CALL XMOVE(STORE(MF+2),STORE(J),1)  ! SET UP THE ATOM TYPE
      ME=ME-1
      MF=MF+LK2

      K=J+1                    ! UPDATE THE HEADER POINTER
      STORE(K)=0.              ! INSERT A DUMMY SERIAL NUMBER

      IF(KOP(6))1250,1350,1300 ! TEST FOR '(' AFTER THE ATOM NAME

1250  CONTINUE                ! END OF CARD. 
      IF ( KA .GE. 0 ) THEN     ! OK if first or last, otherwise:
          ME = ME + 1             ! ERROR. BACKSPACE ONE ARGUMENT AND RETURN
          MF = MF - LK2
          GO TO 1000
      END IF

1300  CONTINUE                ! NO '(' FOUND
      KA=-KA
      IF(KA)1450,1000,1450      ! Allowed for first or last

1350  CONTINUE                ! FOUND '('

      IF(KA.EQ.0) THEN                   ! CHECK IF SERIAL EXPECTED
        IF ( KBB .EQ. 1 ) THEN
          CALL XMOVE(ISTORE(MF+2),IPTVAL,1)
          ME=ME-1
          MF=MF+LK2
        ELSE
          IF(KNUMBR(STORE(K)).NE.0) GOTO 1000   ! READ SERIAL NUMBER OF ATOM
          IF(KB.EQ.1) IPTVAL = NINT(STORE(K))    ! PART NUMBER EXPECTED
        END IF
      END IF

C--SET UP THE ATOM HEADER BLOCK
1450  CONTINUE
      ISTORE(K+1)=NOWT
      ISTORE(K+2)=0
      ISTORE(K+3)=NOWT
      M=K+3
      K=K+4
C--SET UP THE DEFAULT VALUES FOR THE SYMMETRY OPERATORS
      ISTORE(K)=1
      ISTORE(K+1)=1
      ISTORE(K+2)=0
      ISTORE(K+3)=0
      ISTORE(K+4)=0
      L=0
C--SET THE STORE ADDRESSES AS NOT SET
      ISTORE(K+5)=NOWT
      ISTORE(K+6)=NOWT
      ISTORE(K+7)=NOWT
      ISTORE(K+8)=NOWT
      ISTORE(K+9)=NOWT
C--CHECK IF 'FIRST' OR 'LAST' WAS FOLLOWED BY A '('
      IF(KA)1550,1500,1800
C--MAIN LOOP FOR READING THE SYMMETRY OPERATORS
C  IF ANY ARE OMITTED OR LEFT BLANK THE DEFAULT VALUES ARE ASSUMED
1500  CONTINUE
C--CHECK THAT THE LAST PIECE OF INFORMATION ENDED WITH A ','
      IF(KOP(8))1000,1550,1750
C--READ THE SYMMETRY OPERATOR
1550  CONTINUE
      IF(KSYNUM(STORE(K)))1900,1600,1650
C--STORE THE OPERATOR AS AN INTEGER
1600  CONTINUE
      ISTORE(K)=NINT(STORE(K))
      ME=ME-1
      MF=MF+LK2
C--UPDATE THE NUMBER OF SYMMETRY OPERATORS FOUND
      K=K+1
      L=L+1
C--CHECK THAT TOO MANY OPERATORS HAVE NOT BEEN INPUT
      IF(L-6)1500,1000,1000
C--OPERATOR IS FOUND INSTEAD OF A NUMBER  -  CHECK IF ',' OR ')'
1650  CONTINUE
      IF(KOP(8))1000,1700,1750
1700  CONTINUE
      K=K+1
      L=L+1
      IF(L-6)1550,1000,1000
C--CHECK IF THE OPERATOR IS AN ')'
1750  CONTINUE
      IF(ISTORE(MF)-7)1000,1850,1000
C--'FIRST' OR 'LAST' BY ITSELF  -  CORRECT THE CARD POINTERS POSITIONS
1800  CONTINUE
      ME=ME+1
      MF=MF-LK2
C--SUCCESSFUL EXIT
1850  CONTINUE
      L=J+15
      KATOMG=MAX0(K,L)
      GOTO 1050
C--PROCESS THE PARAMETERS
1900  CONTINUE
      K=J+15
1950  CONTINUE
      IF(ISTORE(MF))2000,1000,1750
2000  CONTINUE
c----- zero the true parameter index from coord
      lorig = 0
c-c-c-if u[iso] or special parameters for sphere, line, ring are found
c-c-c-(see block data cryblk in crystals code for presets),
c-c-c-move them to correct position (originally u[ij])
      L=KCOMP(NWKA,ISTORE(MF+2),ICOORD,NKA,LKA)
c----- save the true parameter index from coord
      lorig = l
CDJWJAN00
       if (l .ge. NKAS) then
       l=l-NKAO
       endif
C--IS IT A PARAMETER
      N=1
      IF(L)2050,2050,2300
C--CHECK TO SEE IF IT IS ONE OF THE SHORT FORMS
2050  CONTINUE
      L=KCOMP(NWXS,ISTORE(MF+2),MXS,NXS,LXS)
      IF(L)1000,1000,2100
C--THIS IS A SHORT FORM
2100  CONTINUE
      N=3
      GOTO (2150,2200,2250,2500,1000,1000),L
C--ALL THE U'S
2150  CONTINUE
      L=8
      N=6
      GOTO 2290
C--ONLY THE U(II)'S
2200  CONTINUE
      L=8
      GOTO 2290
C--ONLY THE U(IJ)'S
2250  CONTINUE
      L=11
      GOTO 2290
2500  CONTINUE
C----- POSITIONS
      L=5
2290  continue
      lorig = l
2300  CONTINUE
      DO 2350 I=1,N
      ISTORE(M)=K-MQ
      M=K
      ISTORE(K)=NOWT
      ISTORE(K+1)=L
c----- store the orginal parameter index in the list
      istore(k+2)=lorig
      K=K+3
      L=L+1
      lorig = lorig+1
2350  CONTINUE
      MF=MF+LK2
      ME=ME-1
      ISTORE(J+3)=ISTORE(J+3)+N
      IF(ISTORE(MF)-8)1750,2400,1750
2400  CONTINUE
      MF=MF+LK2
      ME=ME-1
      GOTO 1950

C--GENERAL ERROR ROUTINE
1000  CONTINUE
      KATOMG=-1

1050  CONTINUE
      RETURN
      END
C
CODE FOR KATOMF
      FUNCTION KATOMF(ARG,M5F,N5F,MD5F,M12F)
C--FIND AN ATOM IN LIST 5
C
C  M5F     FIRST LOCATION AT WHICH TO START LOOKING
C  N5F     NUMBER OF ATOMS THROUGH WHICH TO PASS
C  MD5F    STEP BETWEEN ATOMS
C  M12F    LIST 12 ADDRESS  -  NOT USED IF SET NEGATIVE INITIALLY
C
C--RETURN VALUES :
C
C  -1  NO MATCH  -  NO ERROR MESSAGE EITHER.
C   0  OKAY  -  ALL RETURN VALUES SET.
C--
      INCLUDE 'ISTORE.INC'
C
CDJWAPR99      DIMENSION ARG(2)
      DIMENSION ARG(3)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XFIRST.INC'
      INCLUDE 'XLXPRT.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
#ifdef _HOL_
      DATA KHYD /4HH   /
      DATA KDET /4HD   /
#else
      DATA KHYD /'H   '/
      DATA KDET /'D   '/
#endif
C
      IATOMF=-1
C--CHECK IF ANY ATOMS HAVE BEEN GIVEN
      IF(N5F)1200,1200,1450

C--CHECK IF THERE ARE MORE ATOMS TO PROCESS
1000  CONTINUE
      IF(N5F)1100,1100,1250

C--SUCCESSFUL FIND  -  RESET 'IATOMF'
1050  CONTINUE
      IATOMF=0
C--TIME TO RETURN  -  CHECK IF WE HAVE BEEN SUCCESSFUL
1100  CONTINUE
      IF(IATOMF)1200,1150,1150
C--SUCCESS  -  MOVE THE ATOM NAME ACROSS
1150  CONTINUE
CDJWAPR99      CALL XMOVE(STORE(M5F),ARG(1),2)
      CALL XMOVE(STORE(M5F),ARG(1),3)
C--UPDATE THE NUMBER OF ATOMS LEFT
      N5F=MAX0(N5F,IATOMF)

C--AND NOW RETURN
1200  CONTINUE
      KATOMF=MIN0(0,IATOMF)
      RETURN

C--CHECK THE SERIAL NUMBERS
1250  CONTINUE
      IF(ABS(STORE(M5F+1)-ARG(2))-0.0005)1400,1300,1300
C--UPDATE FOR THE NEXT ATOM
1300  CONTINUE
      M5F=M5F+MD5F
      N5F=N5F-1
C--CHECK IF WE ARE USING LIST 12
      IF(M12F)1000,1000,1350
C--USING LIST 12  -  UPDATE THE POINTERS
1350  CONTINUE
      M12F=ISTORE(M12F)
      GOTO 1000
C--CHECK THE ATOM TYPES
1400  CONTINUE
      IF(KCOMP(1,ARG,STORE(M5F),1,1))1300,1300,1050
C
C--ATOMS PROVIDED  -  CHECK FOR 'FIRST', 'LAST', 'PART', 'RESIDUE', 'TYPE'
1450  CONTINUE
      J=KCOMP(1,ARG(1),IFIRST(1),7,1)
C--CHECK THE REPLY
      IF(J.LE.0) GOTO 1250 !Process as an element type
      IF ( J .EQ. 1 ) THEN ! 'FIRST' - CHECK WE CAN ACCESS THE FIRST ATOM
        IF(L5-M5F)1200,1050,1200
      ELSE IF ( J .EQ. 2 ) THEN ! 'LAST' - CHECK THE ADDRESSING
        J=L5+(N5-1)*MD5
        IF(J.LT.M5F) GOTO 1200
        IATOMF=1    !RESET THE REPLY
        N5F=N5F-1
        GOTO 1000
      ELSE IF ((J.EQ.3).OR.(J.EQ.6).OR.(J.EQ.7)) THEN ! 'PART,HPART,NHPART' - CHECK THE ADDRESSING
C IPTVAL = requested part. NPTTOT = # matching atoms. NPTCUR = Current atom.
        CALL PRTGRP ( IPTVAL, IPT, IGR, 1 )
c        WRITE(CMON,'(2(A,I4))') 'Group: ',IGR,' part: ',IPT
c        CALL XPRVDU(NCVDU,1,0)
        IF ( NPTCUR .LE. 1 ) THEN   !First time.
           NPTCUR = 1
           NPTTOT = 0
C Count the parts
           DO I = M5F,M5F+(MD5F*(N5F-1)),MD5F
             JPTVAL = ISTORE(I+14)
             IF ( ( ((ISTORE(I).EQ.KHYD) .OR. (ISTORE(I).EQ.KDET)).AND.
     1            ((J.EQ.3).OR.(J.EQ.6)) ) .OR.
     2          ( ((ISTORE(I).NE.KHYD).AND.(ISTORE(I).NE.KDET)).AND.
     1            ((J.EQ.3).OR.(J.EQ.7)) ) ) THEN
               CALL PRTGRP ( JPTVAL, JPT, JGR, 1 )
               IF ( ((JPT .EQ. IPT) .OR. (IPT .EQ. 999 )) .AND. 
     1          ((JGR .EQ. IGR) .OR. (IGR. EQ. 999 )))NPTTOT=NPTTOT+1
             END IF
           END DO
c           WRITE(CMON,'(A,I4)') 'Npttot: ',NPTTOT
c           CALL XPRVDU(NCVDU,1,0)
        END IF
        II = 0
        DO I = M5F,M5F+(MD5F*(N5F-1)),MD5F
           JPTVAL = ISTORE(I+14)
	   IF ( ( ((ISTORE(I).EQ.KHYD).OR. (ISTORE(I).EQ.KDET)).AND.
     1            ((J.EQ.3).OR.(J.EQ.6)) ) .OR.
     2          ( ((ISTORE(I).NE.KHYD).AND.(ISTORE(I).NE.KDET)).AND.
     1            ((J.EQ.3).OR.(J.EQ.7)) ) ) THEN
              CALL PRTGRP ( JPTVAL, JPT, JGR, 1 )
              IF ( ((JPT .EQ. IPT) .OR. (IPT .EQ. 999 )) 
     1       .AND. ((JGR .EQ. IGR) .OR. (IGR. EQ. 999 ))) II=II+1
              IF ( II .GE. NPTCUR ) THEN
                 M5F = I
                 IF ( NPTCUR .GE. NPTTOT ) THEN
c                   WRITE(CMON,'(A,I4)') 'Final Nptcur: ',NPTCUR
c                   CALL XPRVDU(NCVDU,1,0)
                   NPTCUR = -1
                 ELSE
                   ME=OME    !Backspace to trick calling routine
                   MF=OMF
c                   WRITE(CMON,'(A,I4)') 'Nptcur: ',NPTCUR
c                   CALL XPRVDU(NCVDU,1,0)
                 END IF
                 GOTO 1050
              END IF
           END IF
           IF ( M12F .GT. 0 ) M12F = ISTORE( M12F )
        END DO
        IATOMF=-1    !Not found
        GOTO 1000
      ELSE IF ( J .EQ. 4 ) THEN ! 'RESIDUE' - CHECK THE ADDRESSING
C IPTVAL = requested frag. NPTTOT = # matching atoms. NPTCUR = Current atom.
        IF ( NPTCUR .LE. 1 ) THEN   !First time.
           NPTCUR = 1
           NPTTOT = 0
C Count the frags
           DO I = M5F,M5F+(MD5F*(N5F-1)),MD5F
             JPTVAL = ISTORE(I+16)
             IF (JPTVAL .EQ. IPTVAL) NPTTOT=NPTTOT+1
           END DO
        END IF
        II = 0
        DO I = M5F,M5F+(MD5F*(N5F-1)),MD5F
           JPTVAL = ISTORE(I+16)
           IF (JPTVAL .EQ. IPTVAL) II = II + 1
           IF ( II .GE. NPTCUR ) THEN
              M5F = I
              IF ( NPTCUR .GE. NPTTOT ) THEN
                NPTCUR = -1
              ELSE
                ME=OME    !Backspace to trick calling routine
                MF=OMF
              END IF
              GOTO 1050
           END IF
           IF ( M12F .GT. 0 ) M12F = ISTORE( M12F )
        END DO
        IATOMF=-1    !Not found
        GOTO 1000
      ELSE IF ( J .EQ. 5 ) THEN ! 'TYPE' - CHECK THE ADDRESSING
C IPTVAL = requested type. NPTTOT = # matching atoms. NPTCUR = Current atom.
        IF ( NPTCUR .LE. 1 ) THEN   !First time.
           NPTCUR = 1
           NPTTOT = 0
C Count the types
           DO I = M5F,M5F+(MD5F*(N5F-1)),MD5F
             JPTVAL = ISTORE(I)
             IF (JPTVAL .EQ. IPTVAL) NPTTOT=NPTTOT+1
           END DO
        END IF
        II = 0
        DO I = M5F,M5F+(MD5F*(N5F-1)),MD5F
           JPTVAL = ISTORE(I)
           IF (JPTVAL .EQ. IPTVAL) II = II + 1
           IF ( II .GE. NPTCUR ) THEN
              M5F = I
              IF ( NPTCUR .GE. NPTTOT ) THEN
                NPTCUR = -1
              ELSE
                ME=OME    !Backspace to trick calling routine
                MF=OMF
              END IF
              GOTO 1050
           END IF
           IF ( M12F .GT. 0 ) M12F = ISTORE( M12F )
        END DO
        IATOMF=-1    !Not found
        GOTO 1000
      END IF

      GOTO 1000
      END
C
CODE FOR KCHPRM
      FUNCTION KCHPRM(IN)
C--CHECK IF THE NEXT ARGUMENT OUTPUT BY THE LEXICAL ANALYZER IS
C  A PARAMETER SPECIFICATION OF THE FORM 'X', 'X'S' ETC.
C  INDICATING A PARAMETER NAME
C
C    IF THE PARAMETER SPECIFICATION IS FOLLOWED BY A LEFT PARENTHESIS,
C    IT IS NOT TREATED AS AN OVERALL PARAMETER. THIS ALLOWS ATOM NAMES
C    SUCH AS X(1) TO BE SPECIFIED WITHOUT INTERFERENCE BY THIS ROUTINE
C
C      DJW JAN 2000
C
C  IN  THE NUMBER OF PARAMETER KEYS IMPLIED
C
C--RETURN VALUES ARE :
C
C  -1  END OF CARD FOUND
C  0   NOT AN ATOMIC PARAMETER
C  >1  THE PARAMETER EXTENDED KEY VALUE
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XAPK.INC'
      INCLUDE 'XSHORT.INC'
      INCLUDE 'XFIRST.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
C
      IN = 0
      N = 0
      J = 0
C--CHECK FOR END OF CARD
      IF(ME)1050,1050,1150
C--EXIT BECAUSE THIS IS NOT AN ATOMIC PARAMETER
1000  CONTINUE
      KCHPRM=0
      GOTO 1100
C--END OF CARD FOUND
1050  CONTINUE
      KCHPRM=-1
1100  CONTINUE
      RETURN
C--CHECK THE TYPE OF THE NEXT ARGUMENT
1150  CONTINUE
      IF ( ISTORE(MF) .GE. 0 ) GO TO 1000
C
C -- IF THERE IS ANOTHER ARGUMENT ON THE CARD, CHECK THAT IT IS NOT A
C    LEFT PARENTHESIS, AS THIS INDICATES THAT AN ATOM NAME HAS BEEN
C    GIVEN
      IF ( ME .LE. 1 ) GO TO 1200
      IF ( ISTORE(MF+LK2) .EQ. 6 ) GO TO 1000
C
C--SEARCH FOR THE ATOMIC PARAMETER
1200  CONTINUE
cdjwjan99
c----- zero the true parameter index from coord
      lorig = 0
C----- CHECK FOR SHORT FORM
      N=3
      J=KCOMP(NWXS,STORE(MF+2),MXS,NXS,LXS)
      IF(J)1400,1400,1220
1220  CONTINUE
      GOTO(1250,1300,1350,1600,1000,1000),J
C--ALL THE U'S ARE REQUIRED
1250  CONTINUE
      N=6
      I=8
      GOTO 1610
C----- U(II)'S ONLY
1300  CONTINUE
      I=8
      GOTO 1610
C--THIS IS THE U(IJ)'S
1350  CONTINUE
      I=11
      GOTO 1610
1600  CONTINUE
C----- POSITIONS
      I=5
      GOTO 1610
1610  continue
      lorig = i
      goto 1430
C--CHECK IF THIS IS A NORMAL PARAMETER
1400  CONTINUE
      N=1
      I=KCOMP(NWKA,STORE(MF+2),ICOORD,NKA,LKA)
c      write ( cmon, '(''Kcomp = '',i5)') i
c      call xprvdu(nceror, 1,0)
c----- save the true parameter index from coord
      lorig = i
1430  continue
CDJW JAN00
      if (i .ge. NKAS) i = i - NKAO
      IF(I)1000,1000,1450
1450  CONTINUE
      KCHPRM = LORIG
      IN = N
      ME=ME-1
      MF=MF+LK2
      GOTO 1100
      END
C
CODE FOR KCORCH
      FUNCTION KCORCH(IN)
C--CHECK IF THE NEXT ARGUMENT OUTPUT BY THE LEXICAL ANALYZER IS
C  A PARAMETER SPECIFICATION OF THE FORM 'X' ETC. , INDICATING THE
C  X PARAMETER OF ALL THE ATOMS IN LIST 5.
C
C    IF THE PARAMETER SPECIFICATION IS FOLLOWED BY A LEFT PARENTHESIS,
C    IT IS NOT TREATED AS AN OVERALL PARAMETER. THIS ALLOWS ATOM NAMES
C    SUCH AS X(1) TO BE SPECIFIED WITHOUT INTERFERENCE BY THIS ROUTINE
C
C
C
C  IN  A DUMMY ARGUEMNT
C
C--RETURN VALUES ARE :
C
C  -1  END OF CARD FOUND
C  0   NOT AN ATOMIC PARAMETER
C  >1  THE NEXT FREE ADDRESS AFTER THE HEADER SET UP FOR
C      ATOMIC PARAMETER.
C
C--ON RETURN THE FOLLOWING VARIABLES ARE SET :
C
C  M5A  ADDRESS OF THE FIRST ATOM
C  N5A  THE NUMBER OF ATOMS
C  L12A THE ADDRESS OF THE FIRST ATOM GROUP HEADER
C
C--'MQ' IS ASSUMED TO HAVE BEEN SET, AND TWO LINKED HEADER BLOCKS ARE
C  SET UP THERE. THE TYPE OF THE FIRST IS 'FIRST' AND THAT OF THE SECOND
C  IS 'LAST', AND THE 'UNTIL' BIT OF THE FIRST HEADER IS SET.
C
C   0  LINK LOCATION OR 'NOWT'
C   1  LENGTH OF THE ENTRY  (NOT SET HERE)
C   2  TYPE  'FIRST' OR 'LAST', DEPENDING ON THE HEADER.
C   3  SERIAL  -  SET TO 0.0.
C   4  NOT USED ('NOWT')
C   5  NUMBER OF PARAMETERS
C   6  ADDRESS OF THE FIRST PARAMETER REL. TO MQ OR 'NOWT'
C   7  S (ALL SYMMETRY OPERATORS TAKE ON DEFAULT VALUES)
C   8  L
C   9  T(X)
C  10  T(Y)
C  11  T(Z)
C  12  ADDRESS OF THE ATOM IN LIST 5 ('NOWT')
C  13  ADDRESS OF THE ATOM IN LIST 12 ('NOWT')
C  14  NOT USED ('NOWT')
C  15  ADDRESS OF THE GENERATED PARAMETERS ('NOWT')
C  16  ADDRESS OF THE PARAMETERS TO BE USED ('NOWT')
C
C--FOR EACH PARAMETER :
C
C  0  LINK TO NEXT PARAMETER REL. TO MQ OR 'NOWT'
C  1  POSITION IN THE ARGUMENT LIST
C  2  NOT USED (PARTIAL DERIVATIVE)
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST12.INC'
      INCLUDE 'XAPK.INC'
      INCLUDE 'XSHORT.INC'
      INCLUDE 'XFIRST.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
C
      IDWZAP = IN
C--CHECK FOR END OF CARD
      IF(ME)1050,1050,1150
C--EXIT BECAUSE THIS IS NOT AN ATOMIC PARAMETER
1000  CONTINUE
      KCORCH=0
      GOTO 1100
C--END OF CARD FOUND
1050  CONTINUE
      KCORCH=-1
1100  CONTINUE
      RETURN
C--CHECK THE TYPE OF THE NEXT ARGUMENT
1150  CONTINUE
      IF ( ISTORE(MF) .GE. 0 ) GO TO 1000
C
C -- IF THERE IS ANOTHER ARGUMENT ON THE CARD, CHECK THAT IT IS NOT A
C    LEFT PARENTHESIS, AS THIS INDICATES THAT AN ATOM NAME HAS BEEN
C    GIVEN
      IF ( ME .LE. 1 ) GO TO 1200
      IF ( ISTORE(MF+LK2) .EQ. 6 ) GO TO 1000
C
C--SEARCH FOR THE ATOMIC PARAMETER
1200  CONTINUE
cdjwjan99
c----- zero the true parameter index from coord
      lorig = 0
C----- CHECK FOR SHORT FORM
      N=3
      J=KCOMP(NWXS,STORE(MF+2),MXS,NXS,LXS)
      IF(J)1400,1400,1220
1220  CONTINUE
      GOTO(1250,1300,1350,1600,1000,1000),J
C--ALL THE U'S ARE REQUIRED
1250  CONTINUE
      N=6
      I=8
      GOTO 1610
C----- U(II)'S ONLY
1300  CONTINUE
      I=8
      GOTO 1610
C--THIS IS THE U(IJ)'S
1350  CONTINUE
      I=11
      GOTO 1610
1600  CONTINUE
C----- POSITIONS
      I=5
      GOTO 1610
1610  continue
      lorig = i
      goto 1430
C--CHECK IF THIS IS A NORMAL PARAMETER
1400  CONTINUE
      N=1
      I=KCOMP(NWKA,STORE(MF+2),ICOORD,NKA,LKA)
c      write ( cmon, '(''Kcomp = '',i5)') i
c      call xprvdu(nceror, 1,0)
c----- save the true parameter index from coord
      lorig = i
1430  continue
CDJW JAN00
      if (i .ge. NKAS) i = i - NKAO
      IF(I)1000,1000,1450
C--SET UP A DUMMY ATOM HEADER
1450  CONTINUE
      L12A=L12
      N5A=N5
      M5A=L5
C--SPREAD THIS OVER THE WHOLE HEADER
      CALL XFILL(NOWT,ISTORE(MQ),17)
      ISTORE(MQ+1)=0
      STORE(MQ+3)=0.0
C--SET UP THE DEFAULT SYMMETRY OPERATORS
      ISTORE(MQ+7)=1
      ISTORE(MQ+8)=1
      ISTORE(MQ+9)=0
      ISTORE(MQ+10)=0
      ISTORE(MQ+11)=0
C--SET UP THE SECOND HEADER BLOCK
      J=MQ+17
      CALL XMOVEI (ISTORE(MQ), ISTORE(J),17)
C--LINK THE TWO HEADER BLOCKS
      ISTORE(MQ)=J
      ISTORE(MQ+1)=ISTORE(MQ+1)+1024
C--SET UP THE TYPES PROPERLY
      CALL XMOVEI (IFIRST(1),ISTORE(MQ+2),1)
      CALL XMOVEI (IFIRST(2),ISTORE(J+2),1)
C--SET UP THE PARAMETER ADDRESSES
      ISTORE(MQ+5)=N
      ISTORE(MQ+6)=J+17-MQ
C--SET UP THE ADDRESSES TO INSERT THE PARAMETERS
      J=ISTORE(MQ+6)+MQ
      L=J
C--LOOP ROUND ADDING THE SPECIFIED PARAMETER(S)
      DO 1500 K=1,N
      ISTORE(J)=L-MQ
      J=L
      L=L+3
      ISTORE(J)=NOWT
      ISTORE(J+1)=I
      istore(j+2)=lorig
      I=I+1
      lorig = lorig + 1
1500  CONTINUE
C--SET THE LAST ADDRESS USED
      KCORCH=L
      ME=ME-1
      MF=MF+LK2
      GOTO 1100
      END
C
CODE FOR KOVPCH
      FUNCTION KOVPCH(IN)
C--CHECK THE OUTPUT FROM THE LEXICAL ANALYZER FOR AN OVERALL
C  PARAMETER OR GROUP OF PARAMETERS.
C
C  IN  A DUMMY ARGUMENT
C
C--THE RETURN VALUES OF 'KOVPCH' ARE :
C
C  -1  AN ERROR DURING THE PROCESSING OF THE OVERALL VARIABLES
C   0  NO OVERALL VARIABLE FOUND
C  >0  OVERALL VARIABLE FOUND.
C
C--IF THE RETURN VALUE IS GREATER THAN ZERO, ITS MAGNITUDE
C  INDICATES THE TYPE OF OVERALL PARAMETER FOUND :
C
C  1  SCALE, DU[ISO] OR OU[ISO]
C  2  LAYER SCALES
C  3  ELEMENT SCALES
C
C--UPON RETURN, THE FOLLOWING VARIABLES ARE SET :
C
C  M5A   ADDRESS OF THE FIRST VARIABLE IN LIST 5
C  N5A   NUMBER OF VARIABLE FOUND
C  L12A  ADDRESS OF THE GROUP HEADER IN LIST 12
C  M5O   NUMBER OF THE FIRST VARIABLE FOUND (IN THE RANGE 1 TO N).
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLEXIC.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--READ THE OVERALL PARAMETERS IF IT IS POSSIBLE
      I=KOVPMU(IN)
C--CHECK THE REPLY
      IF(I)1050,1050,1000
C--PROCESSING WAS OKAY  -  FIND THE TYPE OF PARAMETER
1000  CONTINUE
      I=ISTORE(MQ+1)-(ISTORE(MQ+1)/1024)*1024
C--ASSIGN THE VALUE AND RETURN
1050  CONTINUE
      KOVPCH=I
      RETURN
      END
C
CODE FOR KOVPMU
      FUNCTION KOVPMU(IN)
C--PROCESS THE OUTPUT FROM THE LEXICAL SCANNER FOR AN OVERALL PARAMETER,
C  AND FIND THE PARAMETERS IN LIST 5 IF NECESSARY.
C
C  IN  A DUMMY ARGUMENT.
C
C--RETURN VALUES OF 'KOVPMU' ARE :
C
C
C  -1  ERROR IN PROCESSING AN OVERALL PARAMETER  -  MESSAGE PRINTED.
C   0  NOT AN OVERALL PARAMETER.
C  >0  NEXT FREE LOCATION AFTER THE OVERALL PARAMETER HEADER BLOCK.
C
C--RETURNS WITH 'ME' AND 'MF' SET TO THE NEXT ELEMENT ON THE
C  CARD TO BE PROCESSED, AND CHECKS FOR THE END OF CARD
C  AT THE START OF THE SCAN.
C
C--IF 'L5' IS GREATER THAN ZERO, THE ATOMS ARE LOCATED IN LIST 5,
C  AND THE FOLLOWING VARIABLES ARE SET UPON RETURN :
C
C  M5O   THE POSITION OF THE FIRST PARAMETER IN ITS GROUP (1 TO N).
C  M5A   ADDRESS OF THE FIRST PARAMETER IN LIST 5.
C  N5A   THE NUMBER OF PARAMETERS FOUND.
C  L12A  ADDRESS OF THE GROUP HEADER IN LIST 12.
C
C--THIS ROUTINE WILL PROCESS 2 OVERALL PARAMETERS SEPARATED BY 'UNTIL'
C  AND SET THE VARIABLES ABOVE CORRECTLY IF NECESSARY.
C
C--
      INCLUDE 'ISTORE.INC'
C
      DIMENSION IOPS(1)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST12.INC'
      INCLUDE 'XOPK.INC'
      INCLUDE 'XSCALE.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
C
C
#ifdef _HOL_ 
      DATA IOPS(1)/4HUNTI/,NOPS/1/,LOPS/1/,NWOPS/1/
#else
      DATA IOPS(1)/'UNTI'/,NOPS/1/,LOPS/1/,NWOPS/1/
C
C--READ THE FIRST OVERALL PARAMETER DEFINITION IF POSSIBLE
#endif
      I=KOVPMH(IN)
C--CHECK THE REPLY
      IF(I)1000,1050,1100
C--ERROR DURING THE PROCESSING OF AN OVERALL PARAMETER
1000  CONTINUE
      MF=MF-LK2
      CALL XSFDE(ISTORE(MF+1))
C--ASSIGN THE VALUE AND RETURN
1050  CONTINUE
      KOVPMU=I
      RETURN
C--CHECK IF WE SHOULD FIND THE PARAMETER IN LIST 5
1100  CONTINUE
      IF(L5)1250,1250,1150
C--WE CAN FIND THE PARAMETER IN LIST 5
1150  CONTINUE
      IF(KOVPMF(MQ,M5O,M5A,N5A,L12A))1200,1300,1050
C--THE PARAMETER IS NOT IN LIST 5
1200  CONTINUE
      CALL XPCLNN(LN)
      CALL XMISL5(1,ISTORE(MQ+1),ISTORE(MQ+2))
      I=-1
      GOTO 1050
C--PARAMETER NEED NOT BE FOUND  -  CHECK IF IT DEFINES MORE THAN ONE PAR
1250  CONTINUE
      IF(ISTORE(MQ+2))1050,1050,1300
C--ONE PARAMETER THUS FAR  -  CHECK FOR A SIMPLE PARAMETER
1300  CONTINUE
      IF(ISTORE(MQ+1)-1)1350,1050,1350
C--NOT A SIMPLE PARAMETER  -  LOOK FOR 'UNTIL'
1350  CONTINUE
      IF(ME)1050,1050,1400
C--CHECK THE TYPE OF THE ARGUMENT
1400  CONTINUE
      IF(ISTORE(MF))1450,1050,1050
C--COMPARE THE VARIABLE
1450  CONTINUE
      IF(KCOMP(NWOPS,ISTORE(MF+2),IOPS(1),NOPS,LOPS))1050,1050,1500
C--THIS IS AN 'UNTIL' SEQUENCE  -  UPDATE THE CARD POINTERS
1500  CONTINUE
      ME=ME-1
      MF=MF+LK2
C--SET THE POINTERS SO THAT WE CAN READ THE NEXT PARAMETER
      J=MQ
      MQ=I
      I=KOVPMH(IN)
C--CHECK THE REPLY
      IF(I)1000,1000,1550
C--CHECK THAT THE READ SCALE DOES NOT DEFINE A GROUP
1550  CONTINUE
      IF(ISTORE(MQ+2))1600,1600,1700
C--'UNTIL' SEQUENCE ERROR
1600  CONTINUE
      LEF=LEF+1
      MF=MF-LK2
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1650)ISTORE(MF+1)
      WRITE ( CMON, 1650) ISTORE(MF+1)
      CALL XPRVDU(NCEROR, 1,0)
1650  FORMAT(' Illegal ''UNTIL'' sequence for a scale factor',
     2 ' at about column',I5)
      GOTO 1200
C--CHECK THAT THE PARAMETER READ IS OF THE SAME TYPE AS THE FIRST
1700  CONTINUE
      IF(ISTORE(J+1)-ISTORE(MQ+1))1600,1750,1600
C--CHECK THAT THE ORDER OF THE PARAMETERS IS CORRECT
1750  CONTINUE
      IF(ISTORE(J+2)-ISTORE(MQ+2))1800,1800,1600
C--CHECK IF WE SHOULD SEARCH FOR THIS PARAMETER
1800  CONTINUE
      IF(L5)1950,1950,1850
C--FIND THE PARAMETER
1850  CONTINUE
      IF(KOVPMF(MQ,K,L,M,N))1200,1900,1600
C--COMPUTE THE NUMBER OF PARAMETERS FOUND
1900  CONTINUE
      N5A=K-M5O+1
C--RESET THE LINK ADDRESSES
1950  CONTINUE
      ISTORE(J)=MQ
      MQ=J
      ISTORE(MQ+1)=ISTORE(MQ+1)+1024
      GOTO 1050
      END
C
CODE FOR KOVPMH
      FUNCTION KOVPMH(IN)
C--PROCESS AN OVERALL PARAMETER FROM THE OUTPUT OF THE LEXICAL SCANNER
C
C  IN  A DUMMY ARGUMENT.
C
C--RETURN VALUES ARE :
C
C  -1  ERROR IN PROCESSING AN OVERALL PARAMETER  -  MESSAGE PRINTED.
C   0  NOT AN OVERALL PARAMETER.
C  >0  NEXT FREE LOCATION AFTER THE OVERALL PARAMETER HEADER BLOCK.
C
C--RETURNS WITH 'ME' AND 'MF' SET TO THE NEXT ELEMENT ON THE
C  CARD TO BE PROCESSED, AND CHECKS FOR THE END OF CARD
C  AT THE START OF THE SCAN.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLEXIC.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CALL THE FUNCTION TO READ THE PARAMETERS
      KA=KOVPMG(IN)
C--CHECK THE REPLY
      IF(KA)1050,1050,1000
C--CORRECTLY PROCESSED  -  UPDATE THE POINTERS
1000  CONTINUE
      ME=ME-1
      MF=MF+LK2
C--RETURN
1050  CONTINUE
      KOVPMH=KA
      RETURN
      END
C
CODE FOR KOVPMG
      FUNCTION KOVPMG(IN)
C--CHECK THE OUTPUT FROM THE LEXICAL SCANNER FOR AN OVERALL PARAMETER
C
C  IN  A DUMMY ARGUMENT.
C
C--RETURN VALUES OF 'KOVPMG' ARE :
C
C  -1  ERROR IN PROCESSING AN OVERALL PARAMETER  -  MESSAGE PRINTED.
C   0  NOT AN OVERALL PARAMETER.
C  >0  NEXT FREE LOCATION AFTER THE OVERALL PARAMETER HEADER BLOCK.
C
C--THIS ROUTINE SETS UP ONE HEADER BLOCK FOR ONE OVERALL PARAMETER OR
C  SCALE FACTOR, UNLESS THE SCALE FACTOR IS GIVEN AS 'LAYER OR ELEMENT S
C  WHEN TWO HEADER BLOCKS ARE SET UP WITH THE 'UNTIL' BIT SET AND WORD 2
C  AS 'NOWT'.
C
C--THE FORMAT OF THE HEADER BLOCK IS AS FOLLOWS :
C
C  0   ADDR. OF NEXT HEADER BLOCK OR 'NOWT'.
C  1   TYPE OF OVERALL PARAMETER :
C
C      1  OVERALL PARAMETER
C      2  LAYER SCALE
C      3  ELEMENT SCALE
C      4  BATCH SCALE.
C
C      5  CELL PARAMETER
C      6  PROFILE PARAMETER
C      7  ANISOTROPIC EXTINCTION PARAMETER
C      (THIS WORD MAY HAVE 1024 ADDED TO IT FOR AN 'UNTIL' TYPE).
C  2   THE POSITION OF THE PARAMETER IN ITS GROUP (1 TO N)..
C      (IF THIS IS SPECIAL FORM OF SCALE INPUT, TERMINATING WITH 'SCALES
C       THIS WORD WILL BE SET TO 'NOWT' AND 1024 WILL BE ADDED TO WORD
C  3   0.0
C  4   NOT USED
C  5   THE NUMBER OF PARAMETERS ON THE CHAIN GIVEN AT WORD 6.
C  6   ADDRESS OF THE PARAMETER CHAIN REL. TO 'MQ' (STARTS AT WORD 7).
C  7   'NOWT'  LINK TO THE NEXT PARAMETER ON THE CHAIN
C  8   THE POSITION OF THE PARAMETER IN ITS GROUP - AS WORD 2.
C  9   NOT USED
C  10  'NOWT'
C  11  'NOWT'
C  12  'NOWT'
C  13  'NOWT'
C  14  'NOWT'
C  15  'NOWT'
C  16  'NOWT'
C
C--THIS ROUTINE CHECKS FOR END OF CARD, RETURNS WITH 'ME' AND 'MF'
C  POINTING TO THE LAST ARGUMENT PROCESSED.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XOPK.INC'
      INCLUDE 'XSCALE.INC'
C
      INCLUDE 'QSTORE.INC'
C
      IDWZAP = IN
C--CHECK FOR THE START OF THE CARD
      IF(ME)1050,1050,1000
C--CHECK THE TYPE OF THE NEXT ARGUMENT
1000  CONTINUE
      IF(ISTORE(MF))1150,1050,1050
C--THE NEXT ARGUMENT CANNOT BE AN OVERALL PARAMETER
1050  CONTINUE
      KOVPMG=0
1100  CONTINUE
      RETURN
C--CHECK IF THE NEXT ARGUMENT IS A SIMPLE OVERALL PARAMETER
1150  CONTINUE
      KA=1
      KB=KCOMP(LK,ISTORE(MF+2),KVP,NKO,LKO)
C--CHECK THE REPLY
      IF(KB)1200,1200,1300
C----- NOT A SIMPLE PARAMETER - CHECK THE REST
1200  CONTINUE
      KA=KCOMP( LK, ISTORE(MF+2), KSCAL(1,3), NSC, LSC)
C--CHECK THE REPLY AGAIN
      IF(KA)1050,1050,1250
C--UPDATE THE TYPE OF PARAMETER POINTER
1250  CONTINUE
      KA=KA+1
C--SET UP THE HEADER BLOCK
1300  CONTINUE
      ISTORE(MQ)=NOWT
C--BLANK OUT THE REST OF THE HEADER
      CALL XFILL(NOWT,ISTORE(MQ),17)
      ISTORE(MQ+1)=KA
      STORE(MQ+3)=0.0
C--SET UP THE RETURN VALUE
      I=MQ+17
C--CHECK IF THIS IS A SIMPLE PARAMETER
      IF(KA-1)1550,1550,1350
C----- NOT SIMPLE
1350  CONTINUE
      KB=NOWT
      ME=ME-1
      MF=MF+LK2
C--CHECK FOR A '(' AFTER THE TYPE OF SCALE
      IF(KOP(6))1400,1600,1450
C--NO MORE ON THE CARD  -  THIS IS AN ERROR
1400  CONTINUE
      LEF=LEF+1
      KOVPMG=-1
      GOTO 1100
C----- NO '(' FOUND - MUST BE 'SCALES' OR 'PARAMETER'
1450  CONTINUE
      IF(KCOMP(LK,ISTORE(MF+2),KSCAL(1,1),1,LSC))1460,1460,1500
1460  CONTINUE
C----- 'PARAMETER'
      IF(KCOMP(LK,ISTORE(MF+2),KSCAL(1,2),1,LSC))1400,1400,1500
C--IT IS 'SCALES'  -  SET UP A SECOND HEADER BLOCK AND ADD IN 1024 TO WO
1500  CONTINUE
      CALL XMOVEI (ISTORE(MQ),ISTORE(I),17)
C--LINK THE TWO HEADERS
      ISTORE(MQ)=I
      ISTORE(MQ+1)=ISTORE(MQ+1)+1024
      I=I+17
C--INSERT THE PARAMETER TYPE AND ITS BLOCK
1550  CONTINUE
      ISTORE(MQ+5)=1
      ISTORE(MQ+6)=7
      ISTORE(MQ+8)=KB
C--SET WORD TWO
      ISTORE(MQ+2)=KB
      KOVPMG=I
      GOTO 1100
C--'(' FOUND SUCCESSFULLY  -  READ THE NUMBER
1600  CONTINUE
      IF(KNUMBR(ZZ))1400,1650,1400
C--FIX THE NUMBER AND CHECK ITS VALUE
1650  CONTINUE
      KB=NINT(ZZ)
      IF(KB)1400,1400,1700
C--CHECK FOR END OF CARD
1700  CONTINUE
      IF(ME)1400,1400,1750
C--CHECK THAT THE NEXT ARGUMENT IS ')'
1750  CONTINUE
      IF(ISTORE(MF)-7)1400,1550,1400
      END
C
CODE FOR KOVPMF
      FUNCTION KOVPMF(IADD,M5OF,M5AF,N5AF,M12F)
C--FIND THE ADDRESS OF AN OVERALL PARAMETER IN LIST 5
C
C  IADD  THE ADDRESS OF THE HEADER BLOCK IN WHICH THE PARAMETER IS DEFIN
C  M5OF  THE NUMBER OF THE PARAMETER WITHIN ITS GROUP (1 TO N).
C  M5AF  ADDRESS OF THE PARAMETER IN LIST 5 (OR ADDRESS OF THE FIRST PAR
C  N5AF  NUMBER OF PARAMETERS FOUND  -  NOT ONE ONLY FOR 'SCALES' SEQUEN
C  M12F  ADDRESS IN LIST 12 OF THE HEADER BLOCK FOR THE RELEVANT GROUP.
C
C--THE RETURN VALUES OF 'KOVPMF' ARE :
C
C  -1  AN ERROR HAS BEEN FOUND.
C   0  ONE OVERALL PARAMETER HAS BEEN LOCATED SUCCESSFULLY.
C  >0  A LAYER OR ELEMENT 'SCALES' SEQUENCE HAS BEEN FOUND, AND THIS
C      RETURN VALUE IS THE ADDRESS OF THE SECOND HEADER BLOCK PROCESSED.
C      IN THIS LATER CASE, INDICATED BY THE 'UNTIL' BIT BEING SET
C      AND WORD 2 BEING 'NOWT', N5AF IS SET TO THE NUMBER OF PARAMETER
C      IN THE GROUP.
C--
      INCLUDE 'ISTORE.INC'
      INCLUDE 'ICOM05.INC'
      INCLUDE 'ICOM12.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST12.INC'
      INCLUDE 'XOPK.INC'
      INCLUDE 'XSCALE.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QLST05.INC'
      INCLUDE 'QLST12.INC'
C NOW A PARAMETER      INCLUDE 'IDIM05.INC'
C
C--ASSIGN THE INITIAL RETURN VALUE AND FIND THE TYPE OF PARAMETER
      KOVPMF=0
      I = ISTORE(IADD+1) - (ISTORE(IADD+1)/1024) * 1024
C--ASSIGN THE PARAMETER NUMBER
      M5OF=ISTORE(IADD+2)
C--COMPUTE THE ADDRESS IN LIST 5 AND 12
      K=I*4
      IF (K+12 - IDIM05) 1000, 1000, 1050
1000  CONTINUE
C--FIND THE ADDRESS OF THE PARAMETERS
      M5AF=ICOM05(K+9)
C--FIND THE NUMBER OF PARAMETERS
      J=ICOM05(K+11)
C--FIND THE ADDRESS IN LIST 12
      M12F=ICOM12(K+9)
C--CHECK IF THERE ARE ANY SCALES OF THIS TYPE STORED
      IF(J)1050,1050,1150
C--SET THE ERROR FLAG AND RETURN
1050  CONTINUE
      LEF=LEF+1
      KOVPMF=-1
1100  CONTINUE
      RETURN
C--CHECK IF THIS IS A GROUP OF SCALE FACTORS TERMINATED BY 'SCALES'
1150  CONTINUE
      N5AF=1
      IF(M5OF)1200,1200,1250
C--THIS IS A GROUP  -  SET UP THE PARTS OF THE GROUP
1200  CONTINUE
      M5OF=1
      ISTORE(IADD+2)=1
C--ALTER THE SECOND HEADER BLOCK OF THIS LINKED SEQUENCE
      N5AF=J
      K=ISTORE(IADD)
      ISTORE(K+2)=J
      KOVPMF=J
C--CHECK IF THE SCALE IS IN LIST 5
1250  CONTINUE
      IF(M5OF-J)1300,1300,1050
C--COMPUTE THE FIRST ADDRESS
1300  CONTINUE
      M5AF=M5AF+M5OF-1
      GOTO 1100
      END
C
CODE FOR XMISL5
      SUBROUTINE XMISL5(IADV,ITYPE,IPOINT)
C--SUBROUTINE TO PRINT A MESSAGE ABOUT AN ITEM MISSING FROM LIST 5
C
C  IADV    THE NUMBER OF LINES TO INSERT BEFORE THE MESSAGE.
C  ITYPE   THE TYPE OF MISSING ITEM :
C
C          0  AN ATOM.
C          1  AN OVERALL PARAMETER.
C          2  A LAYER SCALE FACTOR.
C          3  AN ELEMENT SCALE FACTOR.
C          4  A BATCH SCALE FACTOR.
C
C  IPOINT  A POINTER TO THE MISSING ITEM, AS FOLLOWS :
C
C          'ITYPE' = 0, THEN 'IPOINT' IS THE ADDRESS IN 'STORE' OF THE
C                       ATOM NAME AND SERIAL NUMBER.
C          'ITYPE' > 0, THEN 'IPOINT' IS THE PARAMETER NUMBER THAT IS
C                       MISSING. IF 'IPOINT' IS LESS THAN ONE, THEN THE
C                       GROUP INVOLVED IS ASSUMED TO BE MISSING FROM
C          LIST 5.
C
C--THIS ROUTINE FINDS THE REAL TYPE FROM 'ITYPE' BY EXPRESSING THE INPUT
C  VALUE MODULO 1024, TO ALLOW FOR 'UNTIL' SEQUENCES.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XUSLST.INC'
      INCLUDE 'XOPK.INC'
      INCLUDE 'XSCALE.INC'
      INCLUDE 'XFIRST.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CHECK IF A ANY LINES SHOULD BE OUTPUT
      IF(IADV)1150,1150,1000
C--OUTPUT SOME BLANK LINES
1000  CONTINUE
      DO 1100 I=1,IADV
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1050)
      ENDIF
1050  FORMAT(1X)
1100  CONTINUE
C--UPDATE THE ERROR COUNTER
1150  CONTINUE
      LEF=LEF+1
C--COMPUTE THE TRUE TYPE
      JTYPE=ITYPE-ITYPE/1024*1024
C--BRANCH ON THE TYPE OF DATA STORED
      IF(JTYPE-1)1200,1450,1550
C--AN ATOM IS MISSING  -  CHECK IF THE DATA INDICATES 'FIRST' OR 'LAST'
1200  CONTINUE
      IF(KCOMP(1,STORE(IPOINT),IFIRST,2,1))1350,1350,1250
C--SOME FORM OF ILLEGAL 'FIRST' OR 'LAST' DIRECTIVE
1250  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1300)(IFIRST(I),I=1,2)
      WRITE ( CMON, 1300) (IFIRST(I),I=1,2)
      CALL XPRVDU(NCEROR, 1,0)
1300  FORMAT(' Misplaced ''',A4,'T'' or ''',A4,
     2 ''' directive in an atom definition')
      GOTO 1800
C--A SPECIFIC ATOM IS MISSING FROM LIST 5
1350  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1400)LN5
      WRITE ( CMON, 1400) LN5
      CALL XPRVDU(NCEROR, 1,0)
1400  FORMAT(' Atom not in list ',I5,
     2 ' or out of order for an ''UNTIL'' sequence')
      CALL XPRTCO(2,IPOINT,1)
      GOTO 1800
C--SIMPLE OVERALL PARAMETER NOT IN LIST 5
1450  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1500)LN5,(KVP(J,IPOINT),J=1,NWKO)
      WRITE ( CMON, 1500) LN5,(KVP(J,IPOINT),J=1,NWKO)
      CALL XPRVDU(NCEROR, 1,0)
1500  FORMAT(' Overall parameter not in list ',I5,5X,': ',5A4)
      GOTO 1800
C--SOME FORM LAYER, ELEMENT OR BATCH SCALE FACTOR MISSING  -  CHECK FOR
1550  CONTINUE
C----- INCREMENT TO FIRST REAL PARAMETER
      JTYPE = JTYPE +1
      IF(IPOINT)1600,1600,1700
C--THE COMPLETE GROUP IS MISSING
1600  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1650)(KSCAL(J,JTYPE),J=1,2),LN5
      WRITE ( CMON, 1650) (KSCAL(J,JTYPE),J=1,2),LN5
      CALL XPRVDU(NCEROR, 1,0)
1650  FORMAT(' No ',2A4,'Scales in list ',I5)
      GOTO 1800
C--AN INDIVIDUAL SCALE FACTOR IS MISSING
1700  CONTINUE
      IF(ISSPRT.EQ.0)WRITE(NCWU,1750)(KSCAL(J,JTYPE),J=1,2),IPOINT,LN5
      WRITE ( CMON, 1750) (KSCAL(J,JTYPE),J=1,2),IPOINT,LN5
      CALL XPRVDU(NCEROR, 1,0)
1750  FORMAT(1X,2A4,'Scale factor number ',I3,' is not in list ',I3)
C--AND NOW RETURN
1800  CONTINUE
      RETURN
      END
C
CODE FOR XPRTCO
      SUBROUTINE XPRTCO(IN,MQ,MT)
C--PRINT THE PARAMETERS SPECIFIED BY 'IN'
C
C  MQ  DETERMINES THE POSITION OF THE ATOM
C  MT  DETERMINES THE PARAMETER POISITION IN COORD
C
C--VALUES OF IN :
C
C  1  PRINT TYPE
C  2  PRINT TYPE AND SERIAL
C  3  PRINT TYPE, SERIAL AND PARAMETER
C  4  PRINT PARAMETER
C
C--
C
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XAPK.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--BRANCH ON THE TYPE OF PRINT
      GOTO(1050,1150,1200,1250,1000),IN
1000  CONTINUE
      CALL XERHND ( IERCAT )
1050  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1100)STORE(MQ)
      WRITE ( CMON, 1100) STORE(MQ)
      CALL XPRVDU(NCVDU, 1,0)
1100  FORMAT(' Atom type : ',A4,A4,'serial no. : ',F6.0,A4,
     2 'Parameter : ',5A4)
      GOTO 1350
1150  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1100)STORE(MQ),IB,STORE(MQ+1)
      WRITE ( CMON, 1100) STORE(MQ),IB,STORE(MQ+1)
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 1350
1200  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1100)STORE(MQ),IB,STORE(MQ+1),IB,(ICOORD(I,MT),I=1,
     2 NWKA)
      ENDIF
      WRITE ( CMON, 1100) STORE(MQ),IB,STORE(MQ+1),IB,
     2 (ICOORD(I,MT),I=1,NWKA)
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 1350
1250  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1300)(ICOORD(I,MT),I=1,NWKA)
      ENDIF
      WRITE ( CMON, 1300) (ICOORD(I,MT),I=1,NWKA)
      CALL XPRVDU(NCVDU, 1,0)
1300  FORMAT(A2,' Atomic parameter : ',5A4)
C
1350  CONTINUE
      RETURN
      END
C
CODE FOR XPRTOP
      SUBROUTINE XPRTOP(IN)
C--PRINT THE OVERALL PARAMETER DEFINED BY IN
C
C--
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XOPK.INC'
      INCLUDE 'XIOBUF.INC'
C
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1000)(KVP(I,IN),I=1,NWKO)
      WRITE ( CMON, 1000) (KVP(I,IN),I=1,NWKO)
      CALL XPRVDU(NCVDU, 1,0)
1000  FORMAT(' Overall parameter : ',5A4)
      RETURN
      END
C
CODE FOR KFDARG
      FUNCTION KFDARG(IN)
C--CHECK THAT THERE ARE SOME ARGUMENTS ON THE CURRENT CARD PRODUCED
C  BY THE LEXICAL SCANNER.
C
C  IN  DUMMY ARGUMENT.
C
C--THE RETURN VALUES ARE :
C
C  -1  NO ARGUMENTS ON THE CARD  -  ERROR MESSAGE PRINTED.
C  >0  OKAY.
C
C--
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XIOBUF.INC'
C
      IDWZAP = IN
      KFDARG=1
C--CHECK FOR SOME ARGUMENTS
      IF(ME)1000,1000,1100
C--NO ARGUMENTS FOUND
1000  CONTINUE
      KFDARG=-1
      CALL XPCLNN(LN)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1050)
      WRITE ( CMON, 1050)
      CALL XPRVDU(NCVDU, 1,0)
1050  FORMAT(' No arguments found')
      LEF=LEF+1
1100  CONTINUE
      RETURN
      END
C
CODE FOR KFDNUM
      FUNCTION KFDNUM(ZZ)
C--CHECK THE CURRENT POSITION OF THE LEXICAL SCANNER OUTPUT FOR
C  A NUMBER, AND REPORT AN ERROR IF THERE IS NOT ONE.
C
C  ZZ  THE NUMBER THAT HAS BEEN FOUND.
C
C--RETURN VALUES ARE :
C
C  -1  NOT A NUMBER  -  ERROR MESSAGE PRINTED.
C  >0  NUMBER FOUND AND PLACED IN 'ZZ'.
C
C--FOR A SUCCESSFUL RETURN, 'ME' AND 'MF' WILL HAVE BEEN UPDATED. AT THE
C  START THEY ARE CHECKED FOR END OF CARD.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLEXIC.INC'
C
      INCLUDE 'QSTORE.INC'
C
      KFDNUM=-1
C--CHECK FOR END OF CARD
      IF(ME)1000,1000,1050
C--END OF CARD FOUND
1000  CONTINUE
      MF=MF-LK2
      CALL XILARG(ISTORE(MF+1))
      GOTO 1250
C--CHECK THE TYPE OF THE NEXT ARGUMENT(S)
1050  CONTINUE
      IF(KSYNUM(ZZ))1100,1200,1150
C--ILLEGAL VARIABLE
1100  CONTINUE
      CALL XILOPD(ISTORE(MF+1))
      GOTO 1250
C--ILLEGAL OPERATOR
1150  CONTINUE
      CALL XILOP(ISTORE(MF+1))
      GOTO 1250
C--NUMBER FOUND OKAY
1200  CONTINUE
      ME=ME-1
      MF=MF+LK2
      KFDNUM=1
1250  CONTINUE
      RETURN
      END
C
CODE FOR KFDOPD
      FUNCTION KFDOPD(NCIARG,NWIARG,IARG,NIARG,LIARG)
C--CHECK THE CURRENT POSITION OF THE LEXICAL SCANNER OUTPUT FOR A
C  VARIABLE AND REPORT AN ERROR IF ONE IS NOT FOUND. IF ONE
C  IS FOUND AND 'NCIARG' IS GREATER THAN ZERO, IT IS COMPARED WITH
C  THE ARGUMENTS IN 'IARG' AND AN ERROR REPORTED IF NO MATCH IS MADE.
C
C  NCIARG  POSITIVE IF VARIABLE COMPARISON IS REQUIRED, ELSE
C          LESS THAN OR EQUAL TO ZERO.
C  NWIARG  NUMBERS OF WORDS PER ARGUMENT IN 'IARG'.
C  IARG    LIST OF ARGUMENTS TO BE CHECKED FOR.
C  NIARG   NUMBER OF ARGUMENTS TO CHECK FOR.
C  LIARG   NUMBER OF WORDS BETWEEN SUCCESSIVE ARGUMENTS IN 'IARG'.
C
C--THE RETURN VALUES ARE :
C
C  -1  A VARIABLE HAS NOT BEEN FOUND  -  ERROR MESSAGE PRINTED.
C      (ALTERNATIVELY, IF 'NCIARG' IS GREATER THAN ZERO, NO MATCH HAS
C       BEEN FOUND).
C  >0  A VARIABLE HAS BEEN FOUND. IF 'NIARG' IS GREATER THAN ZERO,
C      THE RETURN VALUE INDICATES THE POSITION OF THE ARGUMENT THAT
C      HAS BEEN FOUND, AND 'ME' AND 'MF' WILL BE UPDATED IN THIS
C      CASE.
C
C--
C
      DIMENSION IARG(LIARG,NIARG)
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLEXIC.INC'
C
      INCLUDE 'QSTORE.INC'
C
      KFDOPD=-1
C--CHECK FOR END OF CARD
      IF(ME)1000,1000,1100
C--END OF CARD FOUND
1000  CONTINUE
      MF=MF-LK2
1050  CONTINUE
      KFDOPD=-1
      CALL XILARG(ISTORE(MF+1))
      GOTO 1400
C--CHECK THE TYPE OF THE NEXT ARGUMENT(S)
1100  CONTINUE
      IF(ISTORE(MF))1250,1150,1200
C--ILLEGAL NUMBER
1150  CONTINUE
      CALL XILNUM(ISTORE(MF+1))
      GOTO 1400
C--ILLEGAL OPERATOR
1200  CONTINUE
      CALL XILOP(ISTORE(MF+1))
      GOTO 1400
C--VARIABLE FOUND OKAY
1250  CONTINUE
      KFDOPD=1
C--CHECK IF THERE ARE ANY ARGUMENTS
      IF(NCIARG)1400,1400,1300
C--COMPARE THE ARGUMENTS
1300  CONTINUE
      I=KCOMP(NWIARG,ISTORE(MF+2),IARG,NIARG,LIARG)
      IF(I)1050,1050,1350
C--UPDATE AND RETURN
1350  CONTINUE
      ME=ME-1
      MF=MF+LK2
      KFDOPD=I
1400  CONTINUE
      RETURN
      END
C
CODE FOR KNUMBR
      FUNCTION KNUMBR(ARG)
C--READ THE OUTPUT FROM THE LEXICAL SCANNER, AND CHECK IF
C  THE NEXT ARGUMENTS INDICATE A NUMBER.
C  IF A NUMBER IS FOUND, IT IS PUT INTO 'ARG' ON RETURN.
C
C--RETURNS WITH 'ME' AND 'MF' SET TO THE NEXT ELEMENT ON THE
C  CARD TO BE PROCESSED, AND CHECKS FOR THE END OF CARD
C  AT THE START OF THE PROCESSING.
C
C--RETURN VALUES ARE :
C
C  -1  END OF CARD DETECTED.
C   0  NUMBER FOUND CORRECTLY
C  >0  NOT A NUMBER IN THIS POSITION.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLEXIC.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CHECK FOR THE END OF THE CARD
      IF(ME)1100,1100,1000
C--CALL THE NUMBER FINDING FUNCTION
1000  CONTINUE
      IF(KSYNUM(ARG))1050,1150,1050
C--A NUMBER IS NOT THERE
1050  CONTINUE
      KNUMBR=1
      GOTO 1200
C--END OF CARD FOUND
1100  CONTINUE
      KNUMBR=-1
      GOTO 1200
C--NUMBER READ CORRECTLY  -  UPDATE ME AND MF
1150  CONTINUE
      ME=ME-1
      MF=MF+LK2
      KNUMBR=0
1200  CONTINUE
      RETURN
      END
C
CODE FOR KSYNUM
      FUNCTION KSYNUM(ARG)
C--READ THE OUTPUT FROM THE LEXICAL SCANNER, AND CHECK IF
C  THE NEXT ARGUMENTS INDICATE A NUMBER.
C  IF A NUMBER IS FOUND, IT IS PUT INTO 'ARG' ON RETURN.
C
C--RETURNS WITH 'ME' AND 'MF' SET TO THE LAST ELEMENT ON THE
C  CARD PROCESSED, NOT THE NEXT ELEMENT TO BE PROCESSED.
C  THIS IS SO THAT DIAGNOSTICS CAN BE ACCURATELY POSITIONED.
C
C--DOES NOT CHECK FOR END OF CARD AT THE START
C
C--RETURN VALUES ARE :
C
C  <0  OPERAND FOUND INSTEAD OF A NUMBER
C   0  NUMBER FOUND CORRECTLY
C  >0  OPERATOR FOUND
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLEXIC.INC'
C
      INCLUDE 'QSTORE.INC'
C
      T=1.
      KSYNUM=0
C--CHECK THE TYPE OF THE NEXT ARGUMENT
      IF(ISTORE(MF))1100,1000,1150
C--APPLY THE SIGN AND RETURN
1000  CONTINUE
      ARG=STORE(MF+2)*T
1050  CONTINUE
      RETURN
1100  CONTINUE
      KSYNUM=-1
      GOTO 1050
1150  CONTINUE
C--FIRST ARGUMENT IS AN OPERATOR  -  CHECK FOR A '+' OR A '-'
      IF(ISTORE(MF)-2)1300,1250,1200
C--THE OPERATOR IS NOT PART OF A NUMBER
1200  CONTINUE
      KSYNUM=ISTORE(MF)
      GOTO 1050
C--'-' FOUND  -  ALTER THE SIGN WORD
1250  CONTINUE
      T=-T
C--UPDATE AND CHECK FOR END OF CARD
1300  CONTINUE
      MF=MF+LK2
      ME=ME-1
      IF(ME)1350,1350,1400
C--END OF CARD  -  NOT A NUMBER BUT ONLY AN OPERATOR
1350  CONTINUE
      ME=ME+1
      MF=MF-LK2
      GOTO 1200
C--CHECK ON THE TYPE OF THE NEXT ARGUMENT
1400  CONTINUE
      IF(ISTORE(MF))1350,1000,1350
      END
C
cCODE FOR KNPAR
c      FUNCTION KNPAR(IN)
cC--CHECK THAT THE CURRENT ATOM HEADER AT 'MQ' HAS ONLY 'IN' PARAMETERS
cC  ASSOCIATED WITH IT.
cC
cC  IN  THE NUMBER OF PARAMETERS ALLOWED.
cC
cC--THE RETURN VALUES ARE :
cC
cC  -1  NUMBER OF PARAMETERS IS WRONG  -  ERROR MESSAGE PRINTED.
cC  >0  OKAY.
cC
cC--
c\ISTORE
cC
c\STORE
c\XUNITS
c\XSSVAL
c\XLISTI
c\XLEXIC
c\XIOBUF
c\XCONST
cC
c\QSTORE
cC
c      KNPAR=1
cC--CHECK THE NUMBER OF PARAMETERS
c      IF(ISTORE(MQ+5)-IN)1000,1100,1000
cC--THE NUMBER OF PARAMETERS IS WRONG
c1000  CONTINUE
c      KNPAR=-1
c      MF=MF-LK2
c      CALL XPCLNN(LN)
c      IF (ISSPRT .EQ. 0)
c     1             WRITE(NCWU,1050)BLANKS(1:ISTORE(MF+1)+6),ISTORE(MF+1)
c      WRITE ( CMON, 1050) BLANKS(1:ISTORE(MF+1)+6),ISTORE(MF+1)
c      CALL XPRVDU(NCEROR, 2,0)
c1050  FORMAT(A,'*',/,' Incorrect number of atomic parameters given',
c     2 ' at about column',I5)
c
c      LEF=LEF+1
c1100  CONTINUE
c      RETURN
c      END
C
CODE FOR KOP
      FUNCTION KOP(IN)
C--CHECK IF THE NEXT OPERATOR IS 'IN'
C
C--RETURN VALUES ARE :
C  -1  END OF CARD
C   0  YES
C   1  NO
C
C--CHECKS FOR END OF CARD IMAGE AT THE START
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLEXIC.INC'
C
      INCLUDE 'QSTORE.INC'
C
      IF(ME)1000,1000,1100
1000  CONTINUE
      KOP=-1
1050  CONTINUE
      RETURN
1100  CONTINUE
      IF(ISTORE(MF)-IN)1150,1200,1150
1150  CONTINUE
      KOP=1
      GOTO 1050
1200  CONTINUE
      ME=ME-1
      MF=MF+LK2
      KOP=0
      GOTO 1050
      END
C
CODE FOR XSFDE
      SUBROUTINE XSFDE(IN)
C--SCALE FACTOR DEFINITION ERROR AT COLUMN 'IN'
C
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XCONST.INC'
C
      CALL XPCLNN(LN)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1000)BLANKS(1:IN+6),IN
      WRITE ( CMON, 1000) BLANKS(1:IN+6),IN
      CALL XPRVDU(NCEROR, 2,0)
1000  FORMAT(A,'*',/,
     1 ' Error in scale factor definition at about column',I5)
      LEF=LEF+1
      RETURN
      END
C
CODE FOR XADE
      SUBROUTINE XADE(IN)
C--ATOM DEFINITION ERROR AT COLUMN 'IN'
C
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XCONST.INC'
C
      CALL XPCLNN(LN)
      IN = MIN ( IN, 88 ) ! Calls for some continued L16 
      IN = MAX ( IN, 0  ) ! records will otherwise fail.
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1000)BLANKS(1:IN+6),IN
      WRITE ( CMON, 1000) BLANKS(1:IN+6),IN
      CALL XPRVDU(NCEROR, 2,0)
1000  FORMAT(A,'*',/,' Error in atom definition at about column',I5)
      LEF=LEF+1
      RETURN
      END
C
CODE FOR XCSO
      SUBROUTINE XCSO(IN)
C--COMPILER STACK OVERFLOW
C
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XCONST.INC'
C
      CALL XPCLNN(LN)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1000)BLANKS(1:IN+6),IN
      WRITE ( CMON, 1000) BLANKS(1:IN+6),IN
      CALL XPRVDU(NCEROR, 2,0)
1000  FORMAT(A,'*',/,' Compiler requires more core at about column',I5)
      LEF=LEF+1
      RETURN
      END
C
C
CODE FOR XPCA
      SUBROUTINE XPCA(IN)
C--PROCESSING OF THE LAST CARD ABANDONED.
C
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      IDWZAP = IN
      CALL XPCLNN(LN)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1000)
      WRITE ( CMON, 1000)
      CALL XPRVDU(NCEROR, 1,0)
1000  FORMAT(' Processing of the card above has been abandoned')
      LEF=LEF+1
      RETURN
      END
C
CODE FOR XILNUM
      SUBROUTINE XILNUM(IN)
C--ERROR BECAUSE OF AN ILLEGAL NUMBER AT COLUMN IN
C
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XCONST.INC'
C
      CALL XPCLNN(LN)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1000)IN
      WRITE ( CMON, 1000) BLANKS(1:IN+6),IN
      CALL XPRVDU(NCEROR, 2,0)
1000  FORMAT(A,'*',/,' Illegal number at about column',I5)
      LEF=LEF+1
      RETURN
      END
C
CODE FOR XILOP
      SUBROUTINE XILOP(IN)
C--ERROR BECAUSE OF AN ILLEGAL OPERATOR AC COLUMN IN
C
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XCONST.INC'
C
      CALL XPCLNN(LN)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1000)BLANKS(1:IN+6),IN
      WRITE ( CMON, 1000) BLANKS(1:IN+6),IN
      CALL XPRVDU(NCEROR, 2,0)
1000  FORMAT(A,'*',/,' Illegal operator at about column',I5)
      LEF=LEF+1
      RETURN
      END
C
CODE FOR XILOPD
      SUBROUTINE XILOPD(IN)
C--ERROR DURING THE PROCESSING OF THE LEXICAL SCANNER OUTPUT BECAUSE
C  THE LAST ARGUMENT WAS AN ILLEGAL OPERAND.
C
C  IN  COLUMN WHERE THE ERROR OCCURRED.
C
C--
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XCONST.INC'
C
      CALL XPCLNN(LN)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1000)BLANKS(1:IN+6),IN
      WRITE ( CMON, 1000) BLANKS(1:IN+6),IN
      CALL XPRVDU(NCEROR, 2,0)
1000  FORMAT(A,'*',/,' Illegal operand or variable at about column',I5)
      LEF=LEF+1
      RETURN
      END
C
CODE FOR XILARG
      SUBROUTINE XILARG(IN)
C--ERROR DURING THE PROCESSING OF THE LEXICAL SCANNER OUTPUT BECAUSE
C  THE PARAMETER FOUND IS OF THE WRONG TYPE.
C
C  IN  COLUMN WHERE THE ERROR OCCURRED.
C
C--
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XCONST.INC'
C
      CALL XPCLNN(LN)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1000)BLANKS(1:IN+6),IN
      WRITE ( CMON, 1000) BLANKS(1:IN+6),IN
      CALL XPRVDU(NCEROR, 2,0)
1000  FORMAT(A,'*',/,' An argument is incorrect or has been',
     2 ' omitted at or just after column',I5)
      LEF=LEF+1
      RETURN
      END
C
CODE FOR XMISOP
      SUBROUTINE XMISOP(OP,IN)
C--OPERATOR 'OP' IS MISSING AT COLUMN 'IN'
C
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XCONST.INC'
C
      CALL XPCLNN(LN)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1000)BLANKS(1:IN+6),OP,IN
      WRITE ( CMON, 1000) BLANKS(1:IN+6),OP,IN
      CALL XPRVDU(NCEROR, 2,0)
1000  FORMAT(A,'*'/' Operator ''',A1,''' not found at about column',I5)
      LEF=LEF+1
      RETURN
      END
C
CODE FOR XPCLNN
      SUBROUTINE XPCLNN(IN)
C--PRINT LIST 'IN'  -  THIS SUBROUTINE PRINTS UP TO AND INCLUDING THE
C  PRESENT CARD
C
C--
      INCLUDE 'ISTORE.INC'
      INCLUDE 'HEADES.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLEXIC.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CHECK IF THIS CARD IMAGE HAS ALREADY BEEN PRINTED
      IF(MA-LARG)1000,1350,1000
C--CHECK IF IT IS NECESSARY TO PRINT THE HEADING
1000  CONTINUE
      IF(MB)1050,1050,1150
C--PRINT THE INITIAL HEADING
1050  CONTINUE
      CALL XPRTCN
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1100)IN
      WRITE ( CMON, 1100) IN
      CALL XPRVDU(NCEROR, 1,0)
1100  FORMAT(' Print symbolic list ',I5)
C--LOAD THE NEXT DATA RECORD HEADER
1150  CONTINUE
      IF(KLDDRH(MB,MA,IBUFF))1350,1200,1200
C--CHECK IF THIS RECORD SHOULD BE PRINTED
1200  CONTINUE
      IF(IBUFF(7))1250,1300,1300
C--PRINT THE RECORD
1250  CONTINUE
      CALL XPRTLC(MC,IBUFF(4),IBUFF(5),IBUFF(6))
      MC=MC+1
C--CHECK FR END OF THE PRINT
1300  CONTINUE
      IF(LARG-MA)1150,1350,1150
C--AND NOW EXIT
1350  CONTINUE
      RETURN
      END
C
C
C --
C
CODE FOR XLXRDV
      FUNCTION XLXRDV(DEFVAL)
C -- RETURNS THE NEXT NUMBER IN THE LEXICAL SCANNER OUTPUT
C    IF THE NEXT ITEM IS NOT A NUMBER THEN ERROR.(CALLS XERHND)
C    IF END OF CARD THEN RETURN VALUE IS DEFVAL
C --
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XIOBUF.INC'
C --
      VALUE=DEFVAL
      IF (KOP(8)) 3000,9500,2000
2000  CONTINUE
      IF (KFDNUM(VALUE)) 9500,3000,3000
3000  CONTINUE
      XLXRDV=VALUE
      RETURN
9500  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE (NCWU,9510)
      WRITE ( CMON, 9510)
      CALL XPRVDU(NCEROR, 1,0)
9510  FORMAT ( ' The item given is not a number ')
      CALL XERHND(4)
C FINAL ASSIGNEMENT TO CLOSE IN ORDER: MARKUS NEUBURGER.
      XLXRDV=DEFVAL
      RETURN
      END
C
C --
C
CODE FOR XLXRVN
      FUNCTION XLXRVN(DUMMY)
C -- READS A VALUE FROM THE LEXICAL SCANNER OUTPUT WHICH HAS NO
C    DEFAULT. THE ONLY POSSIBLE RESULT NOT AVAILIBLE IS -98765.
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XIOBUF.INC'
C --
      RDUMMY = DUMMY
C -- READ A VALUE
      VALUE=XLXRDV(-98765.)
      IF (ABS(VALUE+98765.) .LT. 0.0001) GO TO 9500
      XLXRVN=VALUE
      RETURN
9500  CONTINUE
C -- ERROR NO VALUE HAS BEEN GIVEN
      IF (ISSPRT .EQ. 0) WRITE (NCWU,9510)
      WRITE ( CMON, 9510)
      CALL XPRVDU(NCEROR, 1,0)
9510  FORMAT (' No default value is availible for parameter ')
      CALL XERHND(4)
C FINAL ASSIGNEMENT TO CLOSE IN ORDER: MARKUS NEUBURGER.
      XLXRVN=0
      RETURN
      END
C
C --
C
cCODE FOR XLXRDA
c      SUBROUTINE XLXRDA(VALUE,NVALUE,DEFVAL)
cC -- READS AN ARRAY OF VALUES FROM THE LEXICAL SCANNER OUTPUT.ANY VALUES
cC    REMAINING UNFILLED AT THE END OF THE CARD AND GIVEN THE VALUE DEFVA
cC --
c      DIMENSION VALUE(NVALUE)
c\XUNITS
c\XSSVAL
c\XIOBUF
cC --
c      DO 3000 I=1,NVALUE
c      VALUE(I)=DEFVAL
c      IF (KOP(8)) 3000,9500,2000
c2000  CONTINUE
c      IF ( KFDNUM(VALUE(I)) .LT. 0 ) GO TO 9500
c3000  CONTINUE
c      RETURN
c9500  CONTINUE
c      IF (ISSPRT .EQ. 0) WRITE (NCWU,9510)
c      WRITE ( CMON, 9510)
c      CALL XPRVDU(NCEROR, 1,0)
c9510  FORMAT ( ' The item given is not a number ')
c      CALL XERHND(4)
c      RETURN
c      END

