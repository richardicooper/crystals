C $Log: not supported by cvs2svn $
C Revision 1.18  2004/05/11 10:19:42  rich
C Add #PURGE MON=LOW option to prevent printing of entire disk
C index.
C
C Revision 1.17  2003/09/24 14:07:39  rich
C Fix glaring bug in new .dsc purging code. Only showed
C up under linux.
C
C Revision 1.16  2003/09/24 08:40:02  rich
C Modified XPURGE so that if a list-specific purge is being done in-situ (ie.
C not a 'PURGE NEW'), the new .dsc is initially built in a direct access
C scratch file and then copied back over the currently open dsc. This prevents
C the new index (written before data is shuffled around) from overwriting low
C lying, unchanging lists in the file. (i.e. 1,2 and 3). For extra safety,
C the internal disk cache buffer is re-initialised before continuing.
C
C Revision 1.15  2003/08/05 11:11:12  rich
C Commented out unused routines - saves 50Kb off the executable.
C
C Revision 1.14  2003/07/01 16:46:09  rich
C
C If a call to #DISK/EXTEND does not require a DSC length extension,
C (e.g. #DISK/EXTEND SIZE=0/END in the .srt file), then there is no
C point in seeking the end of the file since it may take a long time.
C
C Revision 1.13  2003/02/20 16:02:26  rich
C When list4 is read from disc, fiddle around with the common block.
C
C Revision 1.12  2003/01/15 13:50:35  rich
C Remove all output to NCAWU as part of an ongoing project.
C
C Revision 1.11  2001/09/28 10:51:32  ckp2
C New date format when printing lists.
C
C Revision 1.10  2001/09/11 16:27:51  Administrator
C Show record sizes in #disk checkdisk
C
C Revision 1.9  2001/09/11 09:29:16  ckp2
C New #DISK options. Give a list number to the PRINT directive to only
C get info for that list.
C
C Revision 1.8  2001/09/07 14:21:35  ckp2
C Fiddled around with #DISK to allow time and date to be stored for each entry.
C There is a year 2038 problems with the date format, it'll seem like 1970 again.
C Also added a punch directive which will allow scripts to get hold of the DSC
C info in a script readable format. Will write some scripts soon.
C
C Revision 1.7  2001/02/26 10:36:08  richard
C Added changelog to top of file
C
C
CODE FOR XRDLN
      SUBROUTINE XRDLN(IULN,IOWFLG)
C--GENERAL LIST READING ROUTINE
C
C  IULN    THE LIST NUMBER TO BE INPUT.
C  IOWFLG  THE WRITE/OVERWRITE FLAG :
C
C          -1  ATTEMPT AN OVERWRITE.
C           0  WRITE A COMPLETELY NEW LIST.
C          +1  ATTEMPT A CAREFUL OVERWRITE.
C
C--
\ISTORE
C
\STORE
\XUNITS
\XSSVAL
\XLISTI
\XCARDS
\XCHARS
\XLST50
\XERVAL
\XLSVAL
\XOPVAL
C
\XIOBUF
\QSTORE
C
C--SET THE LIST AND RECORD TYPE
      LN=IULN
      IREC=0
C--SET UP THE INPUT COMMON BLOCK
      JA=NFL
      JB=512
      JC=KCHNFL(JB)
C--READ THE DATA FROM THE INPUT STREAM
      IF (   KRDDPV ( ISTORE(JA) , JB )   .LT.  0  ) GO TO 9910
C
C--LIST READ OKAY  -  CHECK IF THE INPUT WAS FOR LIST 4
      IF(IULN-4)1100,1050,1100
C--LIST TYPE 4:
1050  CONTINUE
      I=ISTORE(JA+8)      
      ISTORE(I)=ISTORE(JA)      ! STORE THE WEIGHTING SCHEME TYPE
      ISTORE(I+1)=ISTORE(JA+1)  ! STORE THE FO,FO2,1/FO modifier
      ISTORE(I+2)=ISTORE(JA+16) ! STORE THE ROBUST FLAG
      ISTORE(I+3)=ISTORE(JA+17) ! STORE THE DUNITZ SEILER FLAG
      I = ISTORE(JA+12)
      STORE(I) = FLOAT (ISTORE(JA+2))    !STORE THE CHEBYCHEV WEIGHTER
      STORE(I+1) = FLOAT (ISTORE(JA+3))  !STORE THE MAXIMUM WEIGHT
      STORE(I+2) = STORE(JA+18)          !STORE THE ROBUST TOLERANCE
      STORE(I+3) = STORE(JA+19)          !STORE THE D-S SCHEME P1
      STORE(I+4) = STORE(JA+20)          !STORE THE D-S SCHEME P2
      GOTO 2300
C
C--CHECK FOR LIST TYPE 5
1100  CONTINUE
      IF(IULN-5)1300,1150,1300
C--LIST TYPE 5  -  FLOAT THE ABSOLUTE INDEX FLAG FOR STORAGE
1150  CONTINUE
      I=ISTORE(JA+8)
C--CHECK IF THE ABSOLUTE FLAG IS SET
      IF(ISTORE(I+4))1200,1250,1250
C--DO NOT TAKE THE ABSOLUTE VALUE
1200  CONTINUE
      STORE(I+4)=-1.
      GOTO 2300
C--TAKE THE ABSOLUTE VALUE
1250  CONTINUE
      STORE(I+4)=1.
      GOTO 2300
C
C--CHECK IF THIS IS LIST 13
1300  CONTINUE
      IF(IULN-13)1500,1350,1500
C--THIS IS LIST 13  -  CHECK WHICH ORIENTATION TYPE HAS BEEN GIVEN
1350  CONTINUE
      CALL WSTUP ( ISTORE(JA) , JB )
      GOTO 2300
C
C--CHECK FOR LIST TYPE 14
1500  CONTINUE
      IF(IULN-14)1650,1550,1650
C--LIST 14  -  MOVE THE AXIS DATA FROM LIST 114 TO LIST 14
1550  CONTINUE
      L14 = ISTORE(JA)
      LP = ISTORE(JA+12)
      J = JA
C--LOOP OVER EACH AXIS
      DO 1600 K=1,3
C----- FOURIER LIMITS
      LX = ISTORE(J +16)
C----- PATTERSON LIMITS
      LXP = ISTORE(J +28)
      CALL XMOVE(STORE(LX), STORE(L14), ISTORE(J+18))
      CALL XMOVE(STORE(LXP), STORE(LP), ISTORE(J+18))
C--UPDATE THE POINTERS
      L14 = L14 + ISTORE(JA + 2)
      LP = LP + ISTORE(JA + 2 + 12)
      J=J+4
1600  CONTINUE
      GOTO 2300
C
C--CHECK FOR LIST 25
1650  CONTINUE
      IF(IULN-25)2000,1700,2000
C--LIST 25  -  FORM THE INVERSE OPERATORS
1700  CONTINUE
      IF(ISTORE(JA+3))2300,2300,1750
C--LOOP OVER EACH IN TURN
1750  CONTINUE
      I=ISTORE(JA)
      N=ISTORE(JA+3)
      J=ISTORE(JA+4)
      DO 1950 K=1,N
C--INVERT THE CURRENT MATRIX
      IF (   KINV2 ( 3 , STORE(I) , STORE(J) , 9 , 0 , STORE(NFL) ,
     1 STORE(NFL) , 3 )   .GT.   0   ) GO TO 9920
C--UPDATE THE POINTERS
      I=I+ISTORE(JA+2)
      J=J+ISTORE(JA+6)
1950  CONTINUE
      GOTO 2300
C
C--CHECK IF THIS IS LIST 28
2000  CONTINUE
      IF(IULN-28)2300,2050,2300
C--LIST 28  -  SET UP THE 'USE' AND 'NAME' RECORDS
2050  CONTINUE
      DO 2250 I=2,3
C--SET UP THE POINTERS FOR THIS DATA RECORD  -  THE INPUT ONE
      CALL XDIRFL(I,ISTORE(JA),JB)
C--COMPUTE THE COMMON BLOCK OFFSETS
      J=(I-2)*8+JA
      K=I*4+JA
C--FIND THE ADDRESS OF THE OUTPUT 'NAME' DATA RECORD
      M=ISTORE(J+4)
C--FIND THE INCREMENT FOR THE 'NAME' RECORD
      MM=ISTORE(J+6)
C--FIND THE INCREMENT FOR THE OUTPUT 'USE' RECORD
      JJ=ISTORE(J+2)
C--FIND THE ADDRESS OF THE OUTPUT 'USE' DATA RECORD
      KK=ISTORE(J)
C--FIND THE ADDRESS OF THE INPUT DATA RECORD
      K=ISTORE(K+12)
C--SET THE NUMBER OF PARAMETERS TO BE STORED TO ZERO
      N=0
C--LOOP OVER EACH INPUT KEYWORD
      DO 2200 L=1,NR62D
      IF(ISTORE(MR62D+10))2150,2150,2100
C--THIS KEYWORD WAS INPUT  -  SET UP THE 'USE' RECORD
2100  CONTINUE
      ISTORE(KK)=L-1
      STORE(KK+1)=STORE(K)
C--SET UP THE NAME RECORD
      CALL XFA4CS(STORE(MR62N+1),STORE(M),MIN0(3*NWCHAR,MDR62N-1))
      STORE(M+3)=STORE(K)
C--UPDATE THE POINTERS
      KK=KK+JJ
      M=M+MM
      N=N+1
C--UPDATE THE KEYWORD POINTERS
2150  CONTINUE
      K=K+1
      MR62N=MR62N+MDR62D
      MR62D=MR62D+MDR62D
2200  CONTINUE
C--UPDATE THE RECORD PROPERTIES
      ISTORE(J+3)=N
      ISTORE(J+7)=N
2250  CONTINUE
C
C--NOW OUTPUT THE LIST TO THE DISC
2300  CONTINUE
      CALL XWLSTD(IULN,ISTORE(JA),JB,IOWFLG,1)
9000  CONTINUE
      RETURN
C
9900  CONTINUE
C -- ERRORS
      CALL XOPMSG ( IOPLSI , IOPLSP , IULN )
      CALL XLSALT ( IULN , 0 , 0 , ILSERF , ILSSET )
      GO TO 9000
9910  CONTINUE
C -- COMMAND INPUT ERRORS
      CALL XOPMSG ( IOPCRY , IOPCMI , 0 )
      GO TO 9900
9920  CONTINUE
C -- SINGULAR MATRIX
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 9925 ) I , IULN
      WRITE ( CMON, 9925 ) I , IULN
      CALL XPRVDU(NCEROR, 1,0)
9925  FORMAT ( 1X, 'Matrix ' , I2 , ' in list ' , I3 , ' is singular' )
      CALL XERHND ( IERERR )
      GO TO 9900
      END
C
CODE FOR XPRTLN
      SUBROUTINE XPRTLN(IULN)
C--GENERAL LIST PRINT ROUTINE
C
C  IULN    THE LIST TO BE PRINTED
C
C--
\HEADES
\ISTORE
C
C
\STORE
\XUNITS
\XSSVAL
\XLISTI
\XLST50
\XIOBUF
C
\QSTORE
C
C--CHECK IF THE LIST IS AVAILABLE FOR PRINTING
      IF(KPRTLN(IULN,IADDI))1000,1050,1050
C--TERMINATING LINES AND RETURN
1000  CONTINUE
      CALL XLINES
      RETURN
C--PRESERVE THE CORE LIMITS
1050  CONTINUE
      JA=NFL
      JB=LFL
C--LOAD LIST TYPE 50
      CALL XFAL50
C--LOAD THE DETAILS OF THE LIST TO BE PRINTED
      CALL XLL50R(IULN+LSTOFF)
C--RESET THE LIST POINTERS
      LN=IULN
      IREC=0
C--SET UP A COMMON BLOCK
      JC=512
      JD=NFL
      JE=KCHNFL(JC)
C--PRESERVE THE CURRENT TOP OF CORE
      JF=LFL
C--SET THE LAST DISC ADDRESS
      LAST=0
C--RESTORE THE CORE LIMITS TO THOSE BEFORE WE ENTERED
1100  CONTINUE
      NFL=JA
      LFL=JB
C--READ THE NEXT DATA RECORD HEADER BLOCK
      IF(KLDDRH(LAST,IADDI,IBUFF(1)))1000,1150,1150
C--SET THE CORE LIMITS TO PROTECT LIST 50
1150  CONTINUE
      NFL=JE
      LFL=JF
C--CHECK IF THIS LIST HAS ANY DIRECTIVES STORED FOR IT
      IF(NR60)1100,1100,1200
C--DIRECTIVES STORED  -  LOOK FOR THE DATA RECORD WE HAVE FOUND ON DISC
1200  CONTINUE
      MR61=LR61
      DO 1400 I=1,NR61
C--CHECK IF THIS IS THE CORRECT LIST TYPE
      IF(IULN-ISTORE(MR61+13))1350,1250,1350
C--COMPARE THE RECORD TYPES
1250  CONTINUE
      IF(ISTORE(MR61+11)-IBUFF(7))1350,1300,1350
C--SUCCESS  -  LOAD THE DETAILS FOR THIS DIRECTIVE
1300  CONTINUE
      CALL XDIRFL(I,ISTORE(JD),JC)
      GOTO 1500
C--UPDATE FOR THE NEXT DIRECTIVE
1350  CONTINUE
      MR61=MR61+MDR61
1400  CONTINUE
C--NO MATCH  -  PRINT THE RECORD NAME ONLY
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1450)IBUFF(7),IBUFF(5),IBUFF(6)
      ENDIF
      WRITE ( CMON, 1450) IBUFF(7),IBUFF(5),IBUFF(6)
      CALL XPRVDU(NCEROR, 1,0)
1450  FORMAT(' No details available for record ',I5,'  LGRP ',I4,
     2 '  NGRP ',I6)
      GOTO 1100
C--LOAD THE RECORD FROM THE DISC
1500  CONTINUE
      CALL XLDREC(LN,LSN,IBUFF,ISTORE(JD),JC,0)
C--CHECK IF A TITLE HAS BEEN GIVEN FOR THIS DATA RECORD
      IF(ISTORE(MR61+15))1650,1650,1550
C--TITLE GIVEN  -  FIND ITS ADDRESS AND LENGTH
1550  CONTINUE
      K=LR62+ISTORE(MR61+16)
      L=K+ISTORE(MR61+14)-1
C--FIND THE NUMBER OF TIMES WE SHOULD PRINT THE TITLE
      M=ISTORE(MR61+15)
C--PRINT THE TITLE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1600)IBUFF(7),IBUFF(5),IBUFF(6),((ISTORE(I),I=K,L),
     2 J=1,M)
      ENDIF
1600  FORMAT(//,' Record ',I4,'    LGRP ',I4,'  NGRP ',I6,3X,20A4/(26X,
     2 20A4))
      GOTO 1700
C--NO TITLE AVAILABLE  -  PRINT THE RECORD NUMBER ONLY
1650  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1600)IBUFF(7),IBUFF(5),IBUFF(6)
      ENDIF
C--OUTPUT A SPACE AFTER THE TITLE
1700  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1750)
      ENDIF
1750  FORMAT(1X)
C--CHECK IF A REPEAT COUNT FOR THE KEYWORDS HAS BEEN GIVEN
      IF(ISTORE(MR61+18))1900,1900,1800
C--CHECK IF THERE ARE ANY KEYWORDS TO PRINT
1800  CONTINUE
      IF(NR62N)1900,1900,1850
C--KEYWORDS TO PRINT  -  COMPRESS THE GIVEN TITLE FOR OUTPUT
1850  CONTINUE
      JG=NFL
      JH=KCHNFL(ISTORE(MR61+17))
      I=LR62+ISTORE(MR61+19)
      CALL XFCCS(STORE(I),STORE(JG),ISTORE(MR61+17))
C--PRINT THE KEYWORDS
      CALL XPRTIK(ISTORE(LR62N+1),MDR62N-1,NR62N,MDR62D,ISTORE(MR61+18)
     2 ,STORE(JG),ISTORE(MR61+17))
C--OUTPUT A BLANK LINE AFTER THE KEYWORDS
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1750)
      ENDIF
C--CHECK IF A REPEAT COUNT HAS BEEN GIVEN FOR THE PARAMETER VALUES
1900  CONTINUE
      IF(ISTORE(MR61+21))1100,1100,1950
C--COMPRESS THE OUTPUT FORMAT FOR THE VALUES
1950  CONTINUE
      JG=NFL
      JH=KCHNFL(ISTORE(MR61+20))
      I=LR62+ISTORE(MR61+22)
      CALL XFCCS(STORE(I),STORE(JG),ISTORE(MR61+20))
C--FIND THE ADDRESS OF THE DATA
      LLN=KVALCM(IBUFF(8),ISTORE(JD),JC)
C--FIND THE NUMBER OF WORDS PER GROUP
      MDLN=KVALCM(IBUFF(8)+2,ISTORE(JD),JC)
C--FIND THE NUMBER OF GROUPS
      NLN=KVALCM(IBUFF(8)+3,ISTORE(JD),JC)
C--CHECK THAT THE GROUP LENGTH IS NOT ZERO
      IF(MDLN)1100,1100,2000
C--CHECK THAT THE NUMBER OF GROUPS IS NOT ZERO
2000  CONTINUE
      IF(NLN)1100,1100,2050
C--FIND THE TYPE OF PRINT REQUIRED FOR THIS RECORD
2050  CONTINUE
      ITYPE=1
C--CHECK IF THERE ARE ANY PARAMETERS TO INVESTIGATE
      IF(NR62D)2300,2300,2100
C--LOOP OVER EACH PARAMETER
2100  CONTINUE
      MR62D=LR62D
      DO 2250 I=1,NR62D
      IF(ISTORE(MR62D+5)-2)2150,2300,2200
C--INTEGER NUMBER
2150  CONTINUE
      ITYPE=0
      GOTO 2300
C--UPDATE FOR THE NEXT PARAMETER
2200  CONTINUE
      MR62D=MR62D+MDR62D
2250  CONTINUE
C--CHECK IF THE DATA IS IN CORE OR ON DISC
2300  CONTINUE
      IF(IBUFF(7))2600,2400,2400
C--UPDATE FOR THE NEXT ITEM(S) IN CORE
2350  CONTINUE
      NLN=NLN-N
      LLN=LLN+N*MDLN
C--FIND THE NUMBER OF ITEMS TO PRINT THIS TIME
2400  CONTINUE
      N=MIN0(NLN,ISTORE(MR61+21))
C--CHECK IF THERE IS ANYTHING TO PRINT THIS TIME
      IF(N)1100,1100,2450
C--DATA IN CORE  -  CHECK THE TYPE OF PRINT REQUIRED
2450  CONTINUE
      IF(ITYPE)2500,2500,2550
C--INTEGER PRINT REQUIRED
2500  CONTINUE
      CALL XPRTIK(ISTORE(LLN),MDLN,N,MDLN,1,STORE(JG),ISTORE(MR61+20))
      GOTO 2350
C--FLOATING POINT PRINT REQUIRED
2550  CONTINUE
      CALL XPRTFK(STORE(LLN),MDLN,N,MDLN,1,STORE(JG),ISTORE(MR61+20))
      GOTO 2350
C--DATA NOT IN CORE  -  CHECK THAT THE DISC ADDRESS IS VALID
2600  CONTINUE
      IF(LLN)2650,2650,2750
C--DATA NOT ON DISC
2650  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU,2700)
      WRITE ( CMON, 2700)
      CALL XPRVDU(NCEROR, 1,0)
2700  FORMAT(' Data is not on disc')
      GOTO 1100
C--DATA ON DISC  -  SET UP A BUFFER
2750  CONTINUE
      MLN=NFL
      I=KCHNFL(ISTORE(MR61+21)*MDLN)
C--CHECK IF THERE IS MORE DATA TO PRINT
2800  CONTINUE
      IF(NLN)1100,1100,2850
C--COMPUTE THE NUMBER TO PRINT THIS TIME
2850  CONTINUE
      N=MIN0(ISTORE(MR61+21),NLN)
C--COMPUTE THE NUMBER OF WORDS
      M=N*MDLN
C--BRING DOWN THE DATA
      CALL XDOWNF(LLN,STORE(MLN),M)
C--UPDATE THE POINTERS
      LLN=LLN+KINCRF(M)
      NLN=NLN-N
C--CHECK ON THE TYPE OF PRINT REQUIRED
      IF(ITYPE)2900,2900,2950
C--INTEGER PRINT REQUIRED
2900  CONTINUE
      CALL XPRTIK(ISTORE(MLN),MDLN,N,MDLN,1,STORE(JG),ISTORE(MR61+20))
      GOTO 2800
C--FLOATING POINT PRINT REQUIRED
2950  CONTINUE
      CALL XPRTFK(STORE(MLN),MDLN,N,MDLN,1,STORE(JG),ISTORE(MR61+20))
      GOTO 2800
      END
C
CODE FOR XPRTIK
      SUBROUTINE XPRTIK(IKEYS,LENGTH,NUMBER,ISTEP,IREP,FORM,IDIMN)
C--GENERAL PRINT FOR INTEGER INFORMATION
C
C  IKEYS   THE ARRAY HOLDING THE INTEGERS TO BE PRINTED.
C  LENGTH  THE LENGTH OF EACH COLUMN TO BE PRINTED.
C  NUMBER  THE NUMBER OF COLUMNS TO BE PRINTED.
C  ISTEP   THE LENGTH OF EACH COLUMN AS STORED.
C  IREP    THE NUMBER OF TIMES TO REPEAT THE DATA.
C  FORM    AN ARRAY HOLDING THE FORMAT TO BE USED.
C  IDIMN    THE DIMENSION OF THE ARRAY HOLDING THE FORMAT.
C
C--
C
      CHARACTER *132 CFORM
      DIMENSION IKEYS(ISTEP,NUMBER)
      DIMENSION FORM(IDIMN)
C
\XUNITS
\XSSVAL
C
      WRITE(CFORM, '(33A4)') (FORM(L), L=1,IDIMN)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,CFORM)
     1 (((IKEYS(I,J),I=1,LENGTH),J=1,NUMBER),K=1,IREP)
      ENDIF
      RETURN
      END
C
CODE FOR XPRTFK
      SUBROUTINE XPRTFK(AKEYS,LENGTH,NUMBER,ISTEP,IREP,FORM,IDIMN)
C--GENERAL PRINT FOR FLOATING POINT INFORMATION
C
C  AKEYS   THE ARRAY HOLDING THE FLOATING POINT NUMBERS TO BE PRINTED.
C  LENGTH  THE LENGTH OF EACH COLUMN TO BE PRINTED.
C  NUMBER  THE NUMBER OF COLUMNS TO BE PRINTED.
C  ISTEP   THE LENGTH OF EACH COLUMN AS STORED.
C  IREP    THE NUMBER OF TIMES TO REPEAT THE DATA.
C  FORM    AN ARRAY HOLDING THE FORMAT TO BE USED.
C  IDIMN    THE DIMENSION OF THE ARRAY HOLDING THE FORMAT.
C
C--
C
      CHARACTER *132 CFORM
      DIMENSION AKEYS(ISTEP,NUMBER)
      DIMENSION FORM(IDIMN)
C
\XUNITS
\XSSVAL
C
      WRITE(CFORM, '(33A4)') (FORM(L), L=1,IDIMN)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,CFORM)(((AKEYS(I,J),I=1,LENGTH),J=1,NUMBER),K=1,IREP)
      ENDIF
      RETURN
      END
C
CODE FOR XRDLEX
      SUBROUTINE XRDLEX(IULN)
C--THIS ROUTINE READS A LIST THAT IS TO BE INPUT VIA THE LEXICAL SCANNER
C
C  IULN    THE LIST NUMBER BEING INPUT.
C
C--
\STORE
\XLSVAL
\XOPVAL
C
C--USE THE LEXICAL SCANNER TO READ THE CARDS
      IF(KLEXAN(IULN,IFIRST,LENGTH))1200,1000,1000
C--SUCCESSFUL INPUT  -  CHECK FOR ANOTHER LIST OF THIS TYPE
1000  CONTINUE
      CALL XRLIND(IULN,LSN,IADDL,IOLEN,IOW,NOS,STORE(NFL))
C--CHECK FOR SUCH A LIST
      IF(IADDL)1150,1150,1050
C--THERE IS SUCH A LIST  -  CHECK THE LENGTH
1050  CONTINUE
      IF(LENGTH-IOLEN)1070,1070,1150
1070  CONTINUE
C----- CHECK THE WRITE  STATUS
      IF(LSN) 1150,1100,1100
C--OVERWRITE CAN BE DONE  -  MARK THE LIST AS BEING OVERWRITTEN
1100  CONTINUE
      CALL XMKOWF(IULN,-1)
C--CREATE THE LIST DATA, GENERATING A NEW VERSION FOR LINKAGE PURPOSES
      CALL XWLIND(IULN,IADDL,IOLEN,0,0)
C--COPY THE LIST
      CALL XCPYLN(IFIRST,IADDL)
C--CLEAR THE LIST FLAG
      CALL XMKOWF(IULN,0)
      CALL XALTES(IULN,1)
      GOTO 1250
C--NOT ENOUGH ROOM FOR AN OVERWRITE  -  NEW LIST
1150  CONTINUE
      CALL XWLIND(IULN,IFIRST,LENGTH,0,0)
      CALL XALTES(IULN,1)
      GOTO 1250
C--INPUT ERROR(S)
1200  CONTINUE
      CALL XOPMSG ( IOPLSI , IOPLSP , IULN )
      CALL XLSALT ( IULN , 0 , 0 , ILSERF , ILSSET )
C--AND NOW RETURN
1250  CONTINUE
      RETURN
      END
C
CODE FOR KLEXAN
      FUNCTION KLEXAN(IULN,IFIRST,LENGTH)
C--THIS IS THE LEXICAL SCANNER LINK, WHICH CONVERTS EACH CARD
C  INTO A STANDARD INTERNAL FORMAT, REMOVING SPACES, CHECKING
C  FOR OPERATORS AND CONTROL STATEMENTS AND COMBINING MULTI-CARD
C  IMAGES TOGETHER.
C
C--THE ARGUMENTS ARE :
C
C  IULN    THE LIST NUMBER THAT HAS BEEN GENERATED
C  IFIRST  THE DISC ADDRESS OF THE FIRST WORD OUTPUT.
C  LENGTH  THE LENGTH OF THE DATA OUTPUT.
C
C--RETURN VALUES ARE :
C
C  -1  ERROR(S) IN DATA
C  >0  NEXT DISC ADDRESS THAT CAN BE USED  (ALL OKAY)
C
C--THE OUTPUT IS ALWAYS TO THE NEXT FREE DISC ADDRESS. THE ARGUMENTS
C  ARE TAKEN FROM LIST 50, WHICH IS ASSUMED TO HAVE BEEN LOADED. THE SCA
C  USES THE WHOLE OF CORE TO FORM THE OUTPUT IMAGES, STORING THE ARGUMEN
C  LIST AT THE BOTTOM AND THE CARD IMAGES AT THE TOP OF CORE.
C
C--THE ARGUMENTS ARE STORED IN A DATA RECORD ON THE DISC, AND EACH ARGUM
C  HAS THE FOLLOWING FORMAT :
C
C  0  TYPE OF INFORMATION
C     LESS THAN ZERO  -  VARIABLE
C     ZERO  -  NUMBER
C     GREATER THAN ZERO  -  OPERATOR, WITH ITS VALUE
C  1  POSITION ON THE MULTICARD IMAGE WHERE THIS INFORMATION ENDED
C  2  FIRST WORD OF THE QUANTITY  -  HOLERITH STRING, UNLESS
C     THE QUANTITY IS A NUMBER
C
C--THE LENGTH OF THE ARGUMENT IS TAKEN FROM THE DATA RECORD, AND
C  USED TO SET UP THE FOLLOWING VARIABLES :
C
C  LK   THE NUMBER OF WORDS IN THE VALUE PART OF THE ARGUMENT.
C  LK1  THE TOTAL LENGTH OF AN ARGUMENT MINUS 1.
C  LK2  THE TOTAL LENGTH OF AN ARGUMENT.
C
C--VARIABLES ARE USED AS :
C
C  MA  TYPE OF THE LAST ARGUMENT, FOR CHECKING PURPOSES.
C  MB  NUMBER OF ARGUMENTS FOUND SO FAR.
C  MC  ADDRESS OF THE CURRENT DATA LOCATION.
C  MD  THE NUMBER OF CARDS PROCESSED.
C  ME  CHARACTER NUMBER OF THE CURRENT ARGUMENT.
C  MF  NUMBER OF PARENTHESES FOUND SO FAR ON THE CURRENT CARD.
C  MG  THE ADDRESS AT WHICH TO INSERT NEW CARD IMAGES.
C  MH  DISC ADDRESS OF THE LAST RECORD OUTPUT TO DISC.
C  MI  DISC ADDRESS OF THE NEXT RECORD OUTPUT TO DISC.
C  MJ  NUMBER OF REAL CARDS READ FOR THIS LOGICAL CARD.
C  MK  ADDRESS OF THE CARDS IN CORE.
C  ML  LIST TYPE NUMBER.
C  MM  LAST RECORD TYPE FOR ARGUMENTS.
C  MN  LAST RECORD TYPE FOR CARDS.
C  MO  CURRENT LIST LENGTH, UPDATED AS EACH RECORD IS OUTPUT.
C  MP  PRESERVES 'NFL'.
C  MQ  PRESERVES 'LFL'.
C  MR  THE NUMBER OF ERRORS FOUND UPTO THE CURRENT CARD.
C
C--THE CARD IMAGES ARE STORED IN ANOTHER DATA RECORD, WHICH IS GIVEN
C  BY THE ORIGINAL DATA RECORD PLUS ONE NEGATED.
C
C--
\ICOMLX
\ISTORE
\HEADES
C
\STORE
\XUNITS
\XSSVAL
\XLISTI
\XLST50
\XCHARS
\XCARDS
\XLEXCH
\XLEXIC
\XERVAL
C
\QSTORE
\QCOMLX
C
C
\IDIMLX
C
C -- INITIALISE DIRECTIVES FOR LEXICAL INPUT
      CALL XLXINI ( ILAST , 1 )
C -- INDICATE THAT THE WHOLE REGION UP TO 'LFL' CAN BE USED. THIS
C    ROUTINE DOES NOT USE THE BUFFER SET UP AT 'MD' BY XLXINI.
      MG = 0
      CALL XSTRLL ( MD )
C
      LSTTYP = ISTORE(LR61+13)
      LSTSER = 1
C
      IULN = LSTTYP
      LN = LSTTYP
C
      IOWF = 0
C
C
      IDWZAP = 0
      IFIRST = KNEXTF ( IDWZAP )
      LSTLEN = 0
C
      IADDL = 0
      IADDR = IFIRST
C
C
C
1350  CONTINUE
C
C -- CLEAR PREVIOUS DATA FROM CORE. INDICATE
C    THAT THE NEW DATA IS TO BE WRITTEN AT NFL + 24 , TO ALLOW
C    SPACE FOR LIST /RECORD HEADERS CREATED LATER BY 'KCEDR'
C
      CALL XCSAE
      MD = NFL + 32
C
C -- READ THE NEXT SET OF DIRECTIVES FROM THE INPUT STREAM
C
      IDIRNM = KLXRDD ( ILEXCM , IDIMLX , IADARG , IADCRD , NARGCD ,
     2 NCARD , ILAST )
C
      IF ( IDIRNM .LT. 0 ) GO TO 1350
      IF ( IDIRNM .EQ. 0 ) GO TO 3000
C
      CALL XDIRFL ( IDIRNM , ILEXCM , IDIMLX )
C
C -- IF THE DIRECTIVE JUST READ IS NOT A 'DATA RECORD' THEN GO ON TO
C    THE NEXT DIRECTIVE IMMEDIATELY
C
      IF ( ISTORE(MR61+11) .EQ. 0 ) GO TO 1350
C
C
C -- **** FORMERLY SUBROUTINE XOLLCD ****
C
C
      LENCRD = NWCARD
      IOFCRD = 9
C
      IDATRC = ISTORE(MR61+11)
      ICRDRC = - IDATRC
C
      LENDAT = LK2
      MDARG = LK2
      IOFDAT = ISTORE(MR61+12)
C
C -- OUTPUT THE LOGICAL CARD TO DISK
C
C -- CREATE RECORD HEADER. UPDATE HEADER. WRITE HEADER TO DISC.
C    WRITE DATA TO DISC ( NOTE NEGATIVE RECORD NUMBER )
C
      ICARD = KCEDR ( LSTTYP, LSTSER , ICRDRC , LENCRD, 0 , IOFCRD)
C
      CALL XUDRH ( LSTTYP , ICRDRC , LENCRD , NCARD )
C
      CALL XWDRTD ( LSTTYP, ICRDRC, IADDL, IADDR, LSTLEN, ILEXCM,
     2 IDIMLX , IOWF , IBUFF )
C
      LENGTH = NWCARD * NCARD
      CALL XUPF ( LCRD ,ISTORE(IADCRD) , LENGTH )
C
C
C -- OUTPUT THE DATA TO DISC
C
C -- CREATE DATA RECORD. COPY DATA TO NEW RECORD. WRITE RECORD TO DISC
C
      IDATA = KCEDR ( LSTTYP, LSTSER, IDATRC, LK2 , NARGCD , IOFDAT )
C
      LARG = IDATA
      MARG = IDATA
      MDARG = LK2
      NARG = NARGCD
C
      LENGTH = LENDAT * NARGCD
      IF ( LENGTH .GT. 0 ) CALL XMOVE ( STORE(IADARG) ,
     2 STORE(IDATA) , LENGTH )
C
      CALL XWDRTD ( LSTTYP , IDATRC , IADDL , IADDR , LSTLEN , ILEXCM ,
     2 IDIMLX , IOWF , IBUFF )
C
C
      GO TO 1350
C
C
3000  CONTINUE
C
C
C
C -- IF THE LIST LENGTH 'LSTLEN' IS ZERO, THEN SET THE ADDRESS
C    OF THE FIRST RECORD TO ZERO. THIS SHOULD STOP PROCESSING
C    ERRORS WHEN THE ONLY DIRECTIVE READ IN IS 'END'
C --
      KLEXAN = IFIRST + LSTLEN
C
      LENGTH = LSTLEN
      IF ( LSTLEN .EQ. 0 ) IFIRST = 0
C
      IF ( LEF .NE. 0 ) GO TO 9900
C
      RETURN
C
C
9900  CONTINUE
C -- ERRORS
      KLEXAN = -1
      RETURN
C
C
      END
C
CODE FOR XPRTLX
      SUBROUTINE XPRTLX(IULN,ITYPE)
C--PRINT OR PUNCH THE OUTPUT FROM THE LEXICAL SCANNER
C
C  IULN    THE LIST NUMBER TO BE PRINTED.
C  ITYPE   THE TYPE OF PRINT REQUIRED :
C
C          -1  PRINT ONLY THE CARD IMAGES STORED ON DISC.
C           0  PRINT THE CARD IMAGES AND CRACKED CODE.
C           1  PUNCH A REUSABLE LIST
C
C--
\HEADES
\ISTORE
C
\STORE
\XUNITS
\XSSVAL
C
\QSTORE
C
C--CHECK IF THE LIST IS AVAILABLE FOR PRINTING
      IF(KPRTLN(IULN,NEXT))1000,1050,1050
C--AND NOW RETURN
1000  CONTINUE
      IF ( ITYPE .EQ. 1) THEN
        CALL XPCHND
        CALL XPCHUS
      ENDIF
      CALL XLINES
      RETURN
C--SET THE POINTERS FOR THE PRINT
1050  CONTINUE
      IF ( ITYPE .EQ. 1) CALL XPCHLH ( IULN)
      LAST=0
      N=-1
C--LOAD THE NEXT HEADER BLOCK FROM THE DISC
1100  CONTINUE
      IF(KLDDRH(LAST,NEXT,IBUFF))1000,1150,1150
C--CHECK THE TYPE OF RECORD WE HAVE FOUND
1150  CONTINUE
      IF(IBUFF(7))1200,1250,1250
C--CARD IMAGE  -  PRINT IT
1200  CONTINUE
      N=N+1
      IF ( ITYPE .EQ. 1) CALL XPCHLX (N,IBUFF(4),IBUFF(5),IBUFF(6))
      CALL XPRTLC(N,IBUFF(4),IBUFF(5),IBUFF(6))
      GOTO 1100
C--CRACKED CODE  -  CHECK IF WE SHOULD PRINT IT
1250  CONTINUE
      IF (ITYPE) 1100, 1300, 1100
C--PRINT THE CODE  -  SET UP THE REQUIRED POINTERS
1300  CONTINUE
      L=IBUFF(4)
      M=IBUFF(5)
      K=0
C--CHECK IF THERE IS ENOUGH CORE
      IF(LFL-NFL-M)1350,1400,1400
C--NOT ENOUGH CORE
1350  CONTINUE
      CALL XICA
      GOTO 1000
C--CHECK IF THERE ARE MORE ARGUMENTS TO PROCESS
1400  CONTINUE
      IF(IBUFF(6))1100,1100,1450
C--BRING DOWN THE NEXT ARGUMENT
1450  CONTINUE
      CALL XDOWNF(L,STORE(NFL),M)
C--CHECK THE KIND OF PRINT REQUIRED
      IF(ISTORE(NFL))1500,1600,1500
C--PRINT VARIABLES AND OPERATORS
1500  CONTINUE
      J=NFL+M-1
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1550)K,(ISTORE(I),I=NFL,J)
      ENDIF
1550  FORMAT(10X,3I6,5X,20A4)
      GOTO 1700
C--PRINT NUMBERS
1600  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1650)K,ISTORE(NFL),ISTORE(NFL+1),STORE(NFL+2)
      ENDIF
1650  FORMAT(10X,3I6,E20.10)
C--UPDATE FOR THE NEXT ARGUMENT
1700  CONTINUE
      K=K+1
      L=L+KINCRF(M)
      IBUFF(6)=IBUFF(6)-1
      GOTO 1400
      END
C
CODE FOR XPRTLC
      SUBROUTINE XPRTLC(NUMB,IADDD,LENGRP,NGRP)
C--PRINT A CARD IMAGE PRODUCED BY THE LEXICAL SCANNER.
C
C  NUMB    THE CARD NUMBER.
C  IADDD   THE DISC ADDRESS OF THE LOGICAL CARD.
C  LENGRP  THE LENGTH OF EACH REAL CARD.
C  NGRP    THE NUMBER OF REAL CARDS IN THIS LOGICAL CARD.
C
C--
C
      CHARACTER *88 CLINE
      DIMENSION CARD(20)
C
\XUNITS
\XSSVAL
\XIOBUF
C
C--MARK THIS AS THE FIRST REAL CARD
      J=0
C--FIND THE ADDRESS AND LENGTH POINTERS
      N=NGRP
      M=LENGRP
      L=IADDD
C--FIND THE LENGTH TO PRINT
      K=MIN0(M,20)
C--CHECK IF THERE ARE MORE CARDS TO PRINT
1000  CONTINUE
      IF(N)1050,1050,1100
C--NO MORE CARDS  -  RETURN
1050  CONTINUE
      RETURN
C--READ THIS IMAGE DOWN
1100  CONTINUE
      CALL XDOWNF(L,CARD(1),K)
C--UPDATE THE POINTERS
      L=L+KINCRF(M)
      N=N-1
C--CHECK IF THIS IS THE FIRST CARD
      IF(J)1150,1150,1250
C--FIRST CARD
1150  CONTINUE
      WRITE(CLINE, 1200) NUMB, CARD
1200  FORMAT(I5, 1X, 20A4)
      J=1
      GOTO 1400
C--NOT THE FIRST CARD
1250  CONTINUE
      WRITE(CLINE, 1300) CARD
1300  FORMAT(8X,20A4)
1400  CONTINUE
      CALL XCTRIM (CLINE, NCHARS)
      KK = MIN0 ( 78, NCHARS)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,'(1X,A)')  CLINE(1:KK)
         WRITE ( CMON, '(1X,A)') CLINE(1:KK)
         CALL XPRVDU(NCVDU, 1,0)
      IF (NCHARS .GE. 79) THEN
       KK = KK + 1
       IF (ISSPRT .EQ. 0) WRITE(NCWU,'(9X,A)')  CLINE(KK:NCHARS)
          WRITE ( CMON, '(9X,A)') CLINE(KK:NCHARS)
          CALL XPRVDU(NCVDU, 1,0)
      ENDIF
      GOTO 1000
      END
C
CODE FOR XCELST
      SUBROUTINE XCELST(IULN,ICOMMN,IDIMN)
C--CREATE A LIST IN CORE FROM THE DATA STORED IN LIST 50
C
C  IULN    THE LIST TYPE TO SET UP.
C  ICOMMN  THE COMMON BLOCK TO BE USED WITH THIS LIST.
C  IDIMN    THE DIMENSION OF THE COMMON BLOCK.
C
C--
C
      DIMENSION ICOMMN(IDIMN)
\ISTORE
C
\STORE
\XUNITS
\XSSVAL
\XLST50
\XERVAL
\XLSVAL
\XIOBUF
C
\QSTORE
C
C--CHECK THE LIST TYPE GIVEN
      ISTAT = KLSCHK ( IULN , 0 , 0 , ILSCLN , ILSMSG , I , IERPRG )
C--RECORD THE CURRENT CORE LIMITS
      JA=NFL
      JB=LFL
C--LOAD THE DETAILS OF LIST 50
      CALL XFAL50
      LFL=LR52-1
C--LOAD THE DETAILS FOR THE LIST IN QUESTION
      CALL XLL50R(IULN+LSTOFF)
C--CHECK IF THERE ARE ANY DIRECTIVES FOR THE LIST
      IF(NR60)1800,1800,1000
C--DIRECTIVES STORED  -  LOOP OVER THEM
1000  CONTINUE
      MR60=LR60
      MR61=LR61
      DO 1750 I=1,NR60
C--CHECK IF THE CURRENT DIRECTIVE DEFINES A DATA RECORD
      IF(ISTORE(MR61+11))1050,1700,1050
C--DATA RECORD DEFINED HERE  -  FIND THE ADDRESS OF 'LENGRP' AND 'NGRP'
1050  CONTINUE
      K=MR61+9
      L=K+1
C--LOOP OVER EACH ITEM, SETTING THEM FROM THE COMMON BLOCK IF NEC.
      DO 1150 J=K,L
C--CHECK IF THE VALUE OR ITS ADDRESS IS GIVEN
      IF(ISTORE(J))1100,1150,1150
C--ITS ADDRESS IS GIVEN  -  FIND THE VALUE
1100  CONTINUE
      ISTORE(J)=KVALCM(IABS(ISTORE(J)),ICOMMN,IDIMN)
C--ENSURE THE VALUE IS OKAY
      ISTORE(J)=MAX0(ISTORE(J),0)
1150  CONTINUE
C--SET UP THE POINTERS FOR THIS DIRECTIVE
      CALL XDIRFL(I,ICOMMN,IDIMN)
C--CREATE THE NECESSARY DATA RECORD AND SET THE COMMON BLOCK POINTERS
      IF(KCDRFI(ICOMMN,IDIMN,1))1200,1300,1300
C--ERROR WHILE PERFORMING THE RECORD CREATION
1200  CONTINUE
      GO TO 9900
C--CHECK IF THE RECORD IS IN CORE
1300  CONTINUE
      IF(ISTORE(MR61+11))1700,1700,1350
C--RECORD IS IN CORE  -  FIND THE LENGTH OF THE DATA
1350  CONTINUE
      K=ISTORE(MR61+12)
      J=ICOMMN(K+2)*ICOMMN(K+3)
C--CHECK FOR SOME DATA
      IF(J)1700,1700,1400
C--DATA STORED  -  ZERO IT INITIALLY
1400  CONTINUE
      L=ICOMMN(K)
      CALL XZEROF(STORE(L),J)
C--CHECK FOR SOME PARAMETER KEYWORDS FOR THIS DIRECTIVE
      IF(NR62D)1700,1700,1450
C--KEYWORDS  -  FIND THE NUMBER OF GROUPS FOR THIS DIRECTIVE
1450  CONTINUE
      N=ICOMMN(K+3)
      MR62D=LR62D
C--PASS OVER EACH PARAMETER KEYWORD, LOOKING FOR DEFAULT VALUES TO USE
      DO 1650 J=1,NR62D
C--CHECK FOR A DEFAULT VALUE
      IF(ISTORE(MR62D+7))1600,1500,1500
C--DEFAULT VALUE  -  ASSIGN IT TO EACH REPEAT GROUP
1500  CONTINUE
      M=L
      DO 1550 K=1,N
      CALL XMOVE(STORE(MR62D+8),STORE(M),1)
      M=M+ISTORE(MR61+9)
1550  CONTINUE
C--UPDATE FOR THE NEXT KEYWORD
1600  CONTINUE
      MR62D=MR62D+MDR62D
      L=L+1
1650  CONTINUE
C--UPDATE FOR THE NEXT DIRECTIVE
1700  CONTINUE
      MR60=MR60+MDR60
      MR61=MR61+MDR61
1750  CONTINUE
C--RESET THE UPPER CORE LIMIT
1800  CONTINUE
      LFL=JB
      RETURN
C
9900  CONTINUE
C -- ERRORS
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 9905 ) IULN , ISTORE(MR61+11)
      WRITE ( CMON, 9905 ) IULN , ISTORE(MR61+11)
      CALL XPRVDU(NCEROR, 1,0)
9905  FORMAT ( 1X , 'Error while creating list type ' , I3 ,
     1 ' record ' , I8 )
      CALL XERHND ( IERPRG )
      RETURN
      END
C
CODE FOR XFAOLS
      SUBROUTINE XFAOLS(IULN,JREC,ICOMMN,IDIMN)
C--FORM AN ABSOLUTE ORDERED LIST IN CORE.
C
C  IULN    THE LIST TYPE.
C  JREC    THE RECORD TYPE NUMBER THAT MUST BE PLACED LAST IN CORE.
C  ICOMMN  THE CONTROLLING COMMON BLOCK.
C  IDIMN    THE DIMENSION OF 'ICOMMN'.
C
C--
\HEADER
\ISTORE
C
      DIMENSION ICOMMN(IDIMN)
C
\STORE
\XLISTI
\XCONST
\XUNITS
\XSSVAL
C
\QSTORE
C
C--ZERO THE COMMON BLOCK INITIALLY
      CALL XZEROF(ICOMMN(1),IDIMN)
C--SET THE LENGTH OF THE SPECIAL RECORD TO 'NOWT' INITIALLY
      JBUFF(3)=NOWT
C--LOAD THE DETAILS FOR THE REQUIRED LIST
      CALL XLDLST(-IULN,ISTORE(NFL),1,0)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--SET THE DISC POINTERS INITIALLY
      IADD1=0
      IADD2=ISTORE(NFL)
C--FIND THE NEXT RECORD ON DISC
1000  CONTINUE
      IF(KLDDRH(IADD1,IADD2,IBUFF))1200,1050,1050
C--CHECK IF THIS IS THE SPECIAL RECORD
1050  CONTINUE
      IF(IBUFF(7)-JREC)1150,1100,1150
C--THIS IS THE SPECIAL RECORD  -  PRESERVE ITS RECORD HEADER
1100  CONTINUE
      CALL XMOVE(IBUFF(1),JBUFF(1),8)
      GOTO 1000
C--LOAD THE RECORD WE HAVE FOUND
1150  CONTINUE
      CALL XLDREC(IULN,1,IBUFF,ICOMMN,IDIMN,-1)
      GOTO 1000
C--CHECK IF WE HAVE FOUND AN SPECIAL RECORD
1200  CONTINUE
      IF(JBUFF(3))1300,1300,1250
C--LOAD THE 'ATOM' RECORD
1250  CONTINUE
      CALL XLDREC(IULN,1,JBUFF,ICOMMN,IDIMN,-1)
C--AND NOW RETURN
1300  CONTINUE
C -- NORMAL AND ERROR RETURN
9900  CONTINUE
      RETURN
      END
C
CODE FOR XRCN
      SUBROUTINE XRCN
C--READ THE NEW COMPOUND OR JOB TITLE
C
C--
\STORE
\XUNITS
\XSSVAL
\XCARDS
\XCHARS
\XCOMPD
\XIOBUF
C
C--READ THE NEXT DIRECTIVE CARD
1000  CONTINUE
      IF(KRDNDC(STORE(NFL),1))1250,1050,1100
C--'CONTINUATION' CARD  -  IGNORE IT
1050  CONTINUE
      CALL XMONTR(0)
      GOTO 1000
C--SEARCH FOR THE PARAMETER KEYWORD
1100  CONTINUE
      IDWZAP = 0
      IF(KFNDNP(IDWZAP))1150,1150,1300
C--ERROR DURING PROCESSING OF THE NEW TITLE
1150  CONTINUE
      CALL XMONTR(0)
      CALL XERHDR(0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1200)
      WRITE ( CMON, 1200 )
      CALL XPRVDU(NCEROR, 1,0)
1200  FORMAT ( 1X, 'Illegal TITLE card. A new title must be specified')
      IDIRFL=-1
C--AND NOW RETURN
1250  CONTINUE
      RETURN
C--COMPUTE THE LENGTH OF THE NEW TITLE
1300  CONTINUE
      NC=KNEQUL(NC,IB)
      IF(NC)1150,1150,1350
C--SOME CHARACTERS TO USE  -  NOW COMPUTE THE LENGTH
1350  CONTINUE
      N=LASTCH-NC+1
C--CHECK THAT THERE IS A NEW TITLE
      IF(N)1150,1150,1400
C--SET THE TITLE ARRAY TO BLANKS
1400  CONTINUE
      CALL XMVSPD(IB,KTITL(1),20)
C--FORM THE TITLE INTO A4 CHARACTERS
      CALL XFA4CS ( LCMAGE(NC) , KTITL(1) , N )
C--WRITE THE TITLE TO THE DISC
      CALL XWTTLE
C--ALTER THE CHARACTER POINTER
      NC=LASTCH+1
      GOTO 1000
      END
C
CODE FOR XDISCF
      SUBROUTINE XDISCF
C--THIS ROUTINE PERFORMS VARIOUS HOUSE-KEEPING FUNCTIONS ON THE DISC
C
C--
\ISTORE
C
\STORE
\XLISTI
\XUNITS
\XSSVAL
\XCARDS
\XLST50
\XDISCS
\XDAVAL
\XERVAL
\XLSVAL
\XOPVAL
C
\XIOBUF
\QSTORE
C
C--SET THE MAXIMUM LENGTH OF THE COMMON BLOCK TO BE USED HERE
C -- SET UP AREA FOR COMMAND PROCESSING
      ICOMSZ = 5
CMAR98
      ICOMBL = KSTALL ( ICOMSZ )
      CALL XZEROF (STORE(ICOMBL), ICOMSZ)
C -- LOAD DIRECT ACCESS CONTROL DATA
      CALL XDAEXC
C--ENSURE THAT THE ALL THE DIRECTIVES APPEAR TO HAVE BEEN READ ONCE
      MR61=LR61
      DO 1000 I=1,NR60
      ISTORE(MR61+8)=1
      MR61=MR61+MDR61
1000  CONTINUE
C--MARK THE DIRECTIVE POINTER AS CONTAINING NO DIRECTIVE
      IDIR=-1
C
1050  CONTINUE
C -- READ NEXT DIRECTIVE
      IDIR = KRDNDC ( ISTORE(ICOMBL) , ICOMSZ )
C -- CHECK IF THE DIRECTIVE JUST READ IN IS 'END' OR 'CONTINUE'
      IF ( IDIR .LT. 0 ) GO TO 8800
      IF ( IDIR .EQ. 0 ) GO TO 9930
C
1100  CONTINUE
C -- PROCESS THE KEYWORDS AND PARAMETERS
      IDWZAP = 0
      IF (  KFNDNP ( IDWZAP )  .LE.  0  ) GO TO 1200
      IF (  KRDPV ( ISTORE(ICOMBL) , ICOMSZ )  .LT.  0 ) GO TO 1200
      GO TO 1100
C
1200  CONTINUE
      ISTAT = KCHKPV ( IDIR , ISTORE(ICOMBL) , ICOMSZ , -1 )
      IF ( ISTAT .LT. 0 ) GO TO 2150
      IF ( LEF .GT. 0 ) GO TO 2150
C -- DISPLAY CARD JUST READ IN
      CALL XMONTR ( -1 )
C
C -- SET DATA FROM COMMAND READ IN
      LN = ISTORE(ICOMBL)
      LSN = ISTORE(ICOMBL+1)
      LRSN = ISTORE(ICOMBL+2)
      IVAL = ISTORE(ICOMBL+3)
      KB = ILSSET
C -- BRANCH ON THE FUNCTION
      GO TO ( 1250 , 1400 , 1550 , 1700 , 1850 ,
     1 1510 , 1875 , 1900, 9910 ) , IDIR
      GO TO 9910
C
C
1250  CONTINUE
      IF ( ISTORE(ICOMBL) ) 1310 , 1320 , 1330
1310  CONTINUE
      CALL XPRTLI(ISTORE(ICOMBL+1),ISTORE(ICOMBL+2))
      GO TO 4000
C
1320  CONTINUE
      CALL XPRTFI(ISTORE(ICOMBL+1),ISTORE(ICOMBL+2))
      GO TO 4000
C
1330  CONTINUE
      CALL XDASUM(ISTORE(ICOMBL+1))
      GO TO 4000
C
1400  CONTINUE
C -- 'MARK' DIRECTIVE
      IF ( IVAL .LT. 0 ) KB = ILSCLR
      IFUNC = 1
      GO TO 1870
1510  CONTINUE
C -- 'USAGE' DIRECTIVE
      IF ( IVAL .LT. 0 ) KB = ILSOVR
      IF ( IVAL .EQ. 0 ) KB = ILSRDY
      IF ( IVAL .GT. 0 ) KB = ILSUPD
      IFUNC = 4
      GO TO 1870
1550  CONTINUE
C -- 'RETAIN' DIRECTIVE
      IF ( IVAL .LT. 0 ) KB = ILSCLR
      IFUNC = 2
      GO TO 1870
1700  CONTINUE
C -- 'DELETE' DIRECTIVE
      IF ( IVAL .LT. 0 ) KB = ILSCLR
      IFUNC = 3
      GO TO 1870
1850  CONTINUE
C -- 'RESET' DIRECTIVE
      IFUNC = 5
      GO TO 1870
1870  CONTINUE
C -- PERFORM OPERATION
      CALL XLSALT ( LN , LSN , LRSN , IFUNC , KB )
      GO TO 4000
C
1875  CONTINUE
C -- 'EXTEND' DIRECTIVE
      IRECS = ISTORE(ICOMBL)
      IFREE = ISTORE(ICOMBL+1)
      IDATRY = ISTORE(ICOMBL+2)
      IDAQUA = ISTORE(ICOMBL+3)
      CALL XDACVI ( NWDRCI , NWDBLI , NBYWDI )
C -- CHECK FOR INVALID VALUES SUPPLIED
      IF ( IRECS .LT. 0 ) GO TO 9900
      IF ( IFREE .LT. 0 ) GO TO 9900
      IF ( IFREE + IRECS  .GT. 0 ) THEN
C -- IF AN AMOUNT OF FREE SPACE HAS BEEN REQUESTED, FIND OUT HOW MUCH
C    SPACE MUST BE ADDED.
        CALL XDAEND ( NCDFU , IEND )
        IDWZAP = 0
        ILASTU = ( KNEXTF ( IDWZAP ) / NWDRCI ) + 1
        IUNUSE = IEND - ILASTU - 1
        IADD = MAX0 ( ( IFREE - IUNUSE ) , 0 ) + IRECS
C -- ADD REQUIRED EXTRA RECORDS TO FILE
        CALL XDAXTN ( NCDFU , IEND , IADD )
C -- CALCULATE THE NUMBER OF WORDS THAT HAVE BEEN ADDED TO THE FILE
        IWORDS = IADD * NWDRCI
C -- WRITE A MESSAGE TO INFORM THE USER
        IF (ISSPRT .EQ. 0) WRITE ( NCWU , 1877 ) IADD , IWORDS
1877    FORMAT ( 1X,'Disc file extended by ',I3, ' record(s)' ,
     1  ' ( ' , I6 , ' integer words ) ' )
      END IF
      GO TO 4000
C
1900  CONTINUE
C -- 'CHECKDISC' DIRECTIVE
C    CHECK THE INTEGRITY OF THE DISC STRUCTURE
      LSTBUF = KSTALL ( 8 )
      IADBUF = KSTALL ( 8 )
C
C -- MINDSC/MAXDSC SHOULD DEFINE LIMITS OF FILE
C -- MINUSE/MAXUSE SHOULD DEFINE AREA OF FILE IN USE
C -- MINLST/MAXLST SHOULD DEFINE AREA ALLOCATED TO LIST
      MINDSC = 1
      MAXDSC = 999999999
      MINUSE = 1
      IDWZAP = 0
      MAXUSE = KNEXTF ( IDWZAP )
C
      IDSPLV = ISTORE(ICOMBL)
C
      NLISTS = 0
      NRCRDS = 0
      NLSTER = 0
C
      DO 2880 I = 1 , 49
      ISRCH = 0
C
2810  CONTINUE
      ISTORE(LSTBUF) = I
      ISTAT = KRFI ( ISTORE(LSTBUF) , ISRCH , ISTORE(LSTBUF+2) ,
     2 ISTORE(LSTBUF+3) , ISTORE(LSTBUF+4) , ISTORE(LSTBUF+5) ,
     3 ISTORE(LSTBUF+6) )
      IF ( ISTAT .LT. 0 ) GO TO 2880
C
      ISTORE(LSTBUF+1) = ISRCH
C
      ITYPE = ISTORE(LSTBUF)
      ISER = ISTORE(LSTBUF+1)
      MINLST = ISTORE(LSTBUF+2)
      MAXLST = ISTORE(LSTBUF+3)
C
      NLISTS = NLISTS + 1
C
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 2815 ) ITYPE , ISER , MINLST , MAXLST
     1 ,MAXLST-MINLST+1
      ENDIF
2815  FORMAT ( 1X , 'List type ' , I3 , ' serial ' , I3 ,
     2 ' uses from ' , I10 , ' to ' , I10, I10 )
2817  CONTINUE
C
      IF ( MINLST .LT. MINDSC ) GO TO 2890
      IF ( MINLST .LT. MINUSE ) GO TO 2892
      IF ( MAXLST .GT. MAXDSC ) GO TO 2890
      IF ( MAXLST .GT. MAXUSE ) GO TO 2892
C
      IADDL = 0
      IADDR = ISTORE(LSTBUF+2)
2820  CONTINUE
C -- SCAN EACH DISC DATA RECORD
      ISTAT = KLDDRH ( IADDL , IADDR , ISTORE(IADBUF) )
      IF ( ISTAT .LT. 0 ) GO TO 2810
C
      NRCRDS  = NRCRDS  + 1
C
      ISTART = ISTORE(IADBUF+3)
      LENGTH = ISTORE(IADBUF+4) * ISTORE(IADBUF+5)
      IEND = ISTART + LENGTH - 1
      IRECNM = ISTORE(IADBUF+6)
C
      IF ( IDSPLV .GT. 1 ) GO TO 2827
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 2825 ) IRECNM , ISTART , IEND
     1 ,IEND-ISTART+1
      ENDIF
2825  FORMAT ( 1X , 'Record type ' , I5 , '  Data from ' , I10 ,
     2 ' to ' , I10, I10 )
2827  CONTINUE
C
      IF ( ISTART .LT. MINLST ) GO TO 2894
      IF ( IEND .GT. MAXLST ) GO TO 2894
C
      GO TO 2820
C
2890  CONTINUE
      NLSTER = NLSTER + 1
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 2891 )ITYPE,ISER
      WRITE ( CMON, 2891 )ITYPE,ISER
      CALL XPRVDU(NCVDU, 1,0)
2891  FORMAT (1X,'List',I3,' Serial',I6,
     1' - List address points outside file')
      GO TO 2810
2892  CONTINUE
      NLSTER = NLSTER + 1
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 2893 )ITYPE,ISER
      WRITE ( CMON, 2893 )ITYPE,ISER
      CALL XPRVDU(NCVDU, 1,0)
2893  FORMAT (1X,'List',I3,' Serial',I6,
     1' - List address points to unused space')
      GO TO 2810
2894  CONTINUE
      NLSTER = NLSTER + 1
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 2895 )ITYPE,ISER
      WRITE ( CMON, 2895 )ITYPE,ISER
      CALL XPRVDU(NCVDU, 1,0)
2895  FORMAT (1X, 'List',I3,' Serial',I6,
     1 ' - Record address points to space outside list' )
      GO TO 2820
C
2880  CONTINUE
C
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 2885 )
      ENDIF
      WRITE ( CMON, 2885 )
      CALL XPRVDU(NCVDU, 1,0)
2885  FORMAT ( 1X , 'List scan complete' )
      CALL XSTRLL ( LSTBUF )
      CALL XSTRLL ( IADBUF )
C
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 2887 ) NLISTS , NRCRDS  , NLSTER
      ENDIF
      WRITE ( CMON, 2887 ) NLISTS , NRCRDS  , NLSTER
      CALL XPRVDU(NCVDU, 1,0)
2887  FORMAT ( 1X , I5 , ' list(s) containing ' , I5 ,
     2 ' record(s) . ' , I3 , ' error(s) detected ' )
      GOTO 4000
C
4000  CONTINUE
C -- FINISHED THIS DIRECTIVE
      IF ( IERFLG .LT. 0 ) GO TO 2150
      GO TO 1050
C
C
8800  CONTINUE
      IF ( IERFLG .LT. 0 ) GO TO 2150
      IF ( LEF .NE. 0 ) GO TO 2150
      RETURN
C
C
2150  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 2200 )
      ENDIF
      WRITE ( CMON, 2200 )
      CALL XPRVDU(NCEROR, 1,0)
2200  FORMAT ( 1X , 'Disc control error(s). Processing abandoned' )
      RETURN
C
9900  CONTINUE
C
C -- ERROR - NEGATIVE NUMBER OF RECORDS
C
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 9905 ) IRECS
      ENDIF
      WRITE ( CMON, 9905 ) IRECS
      CALL XPRVDU(NCEROR, 1,0)
9905  FORMAT ( 1X,I5 , ' is an invalid number of records for EXTEND' )
      CALL XERHND ( IERERR )
      GO TO 2150
9910  CONTINUE
      CALL XOPMSG ( IOPCRY , IOPINT , 0 )
      GO TO 2150
9930  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 9935 )
      ENDIF
      WRITE ( CMON, 9935 )
      CALL XPRVDU(NCEROR, 1,0)
9935  FORMAT ( 1X , 'Continuation cards are not allowed for this' ,
     2 ' instruction ' )
      GO TO 2150
C
      END
C
CODE FOR XPURGE
      SUBROUTINE XPURGE
C--SUBROUTINE TO ELIMINATE UNWANTED LISTS FROM THE DISC
C
C      FILE=OLD/DATE/FILENAME
C            OLD  PUGE EXISTING DSC
C            DATE CREATE FILENAME FROM DATE
C            OTHERWISE USE GIVEN NAME
C      INITIALSIZE=
C      LOG=ON/OFF
C      LIST=N
C      MONITOR=HIGH/LOW
C
C      NEWFIL      0      PURGE CURRENT FILE
C                  1      CREATE NEW FILE FOR DATA ( 'PURGE NEW' )
C
C
C
C----- 8M - THE BIGGEST DISK ADDRESS WE CAN EXPECT (1995). WAS 1M
      PARAMETER (MADRES = 2 147 483 647) 
c
CDJWAPR99
      CHARACTER*16 COLDD, CNEWD
      DIMENSION IRECOR(ISSRLI)
C--
C
\TSSCHR
C
\ISTORE
C
\STORE
\XLISTI
\XDISC
\XDISCS
\XUNITS
\XSSVAL
\XERVAL
\XOPVAL
\XSSCHR
\XIOBUF  
C
\QSTORE
C
CDJWMAY00
      DATA ICOMSZ / 8 /
      DATA MINSIZ / 5 /
C
C
C--SET THE TIMING AND READ THE CONSTANTS
      CALL XTIME1(2)
      IEXTND = 0
C----- CLEAR THE FILENAMES
      COLDD = ' '
      CNEWD = ' '
C
C -- ALLOCATE SPACE TO HOLD RETURN VALUES FROM INPUT
CMAR98
      ICOMBF = KSTALL ( ICOMSZ )
      CALL XZEROF (STORE(ICOMBF), ICOMSZ)
      I = KRDDPV ( ISTORE(ICOMBF) , ICOMSZ )
      IF ( I .LT. 0 ) GO TO 9920
C
CDJWAPR99
      WRITE (CNEWD ,'(4A4)') (ISTORE(ICOMBF+I),I=0,3)
      IF ((CNEWD(1:4) .EQ. 'old ') .OR.
     1   (CNEWD(1:4) .EQ. 'OLD ')) THEN
C---- NO NEW FILE
            NEWFIL = 0
      ELSE IF ((CNEWD(1:4) .EQ. 'date') .OR.
     1        (CNEWD(1:4) .EQ. 'DATE')) THEN
            LNEWD = 8
            I= IGDAT(CNEWD)
            NEWFIL = 1
      ELSE
C -- SET NEW FILE FLAG
            NEWFIL = 1
      ENDIF

C----- SET TYPE OF LIST TO BE PURGED
      IPGTYP = ISTORE(ICOMBF+6)

      IF ( (NEWFIL .EQ. 0) .AND. (IPGTYP .NE. 0) ) THEN
        NEWFIL=2
        WRITE (CMON,'(A,I3)') 'Specific list type purge: ', IPGTYP
        CALL XPRVDU(NCVDU, 1,0)
        CSSNDA=''
        LSSNDA = 0
        WRITE (CMON,'(A)') 'Opening temporary dsc file '
        CALL XPRVDU(NCVDU, 1,0)
      END IF
C
CDJWOCT20000 - THE 'NEW DSC' NAME SET IN CSSNDA IS NO LONGER USED
CDJWAPR99{
      IF (NEWFIL .EQ. 1) THEN
        LNEWD = LEN(CNEWD)
        CALL XCRAS(CNEWD(1:LNEWD), JLEN)
        DO 1710 ISTAT = 1,JLEN
C----- REMOVE ANY '.'
        IF (CNEWD(ISTAT:ISTAT) .EQ. '.') THEN
          CNEWD(ISTAT:) = ' '
          JLEN = ISTAT - 1
          GOTO 1715
        ENDIF
1710    CONTINUE
1715    CONTINUE
        CSSNDA=CNEWD(1:JLEN)//'.dsc'
        LSSNDA = JLEN+4
        CALL XCRAS(CSSNDA(1:LSSNDA), LSSNDA)
        CALL FCASE(CSSNDA, CSSNDA, ISSFLC)
        WRITE (CMON,'(A,A)') 'Opening new dsc file: ', CSSNDA(1:LSSNDA)
        CALL XPRVDU(NCEROR, 1,0)
        IF (ISSPRT .EQ. 0) WRITE ( NCWU , '(A)' ) CMON(1)(:)
      ENDIF
CDJWAPR99}


C -- INITIAL SIZE REQUESTED
      IRQSIZ = ISTORE(ICOMBF+4)
C -- SET LOG FLAG
      LOGREQ = ISTORE(ICOMBF+5)
C -- SET THE MONITOR FLAG
      MONREQ = ISTORE(ICOMBF+7)
C -- SET TOTAL LENGTH OF FILE REQUIRED FOR NEW LISTS
      LENTOT = 0
CDJWMAY99

C -- OLD AND NEW FILE UNITS = 'NCDFU'
      NUOLD = NCDFU
      NUNEW = NCDFU
C -- UNLESS A NEW FILE IS REQUIRED, IN WHICH CASE NEW FILE UNIT = NCNDU
      IF ( NEWFIL .GT. 0 ) NUNEW = NCNDU

C -- CHECK INITIAL SIZE VALUE
      IF ( IRQSIZ .LT. 0 ) GO TO 9910
      IF ( IRQSIZ .EQ. 0 ) GO TO 910
      IF ( NEWFIL .GT. 0 ) GO TO 910
C -- AN INITIAL SIZE HAS BEEN REQUESTED WITH NO NEW FILE -- IGNORE AND
C    WARN USER
C --
      CALL XPUMSG ( 1 , 0 )
910   CONTINUE
C--RESET THE CORE
      CALL XRSL
      CALL XCSAE
C--SET SOME INITIAL CONSTANTS
      MLN=49
      KA=NFL
      KB=8
      LN=51
      IREC=0
      KC=KCHNFL(KB)
C--SELECT ENTRIES FROM THE CURRENT LIST INDEX
      DO 1200 I=1,MLN
      KD=KC-KB
C--SET THE LIST TYPE
      ISTORE(KD)=I
C--READ THE ENTRY
      IF(KRCLI(ISTORE(KD),ISTORE(KD+1),ISTORE(KD+2),ISTORE(KD+3),
     2 ISTORE(KD+4),ISTORE(KD+5),ISTORE(KD+6)))1200,1000,1000
C--CHECK THAT THIS LIST IS NOT OPEN FOR WRITING
1000  CONTINUE
C----- CHECKIF ITS A DELETED LIST
      IF(ISTORE(KD))1010,1010,1040
1010  CONTINUE
      CALL XPUMSG ( 5 , KD )
      GOTO 1200
1040  CONTINUE
      IF(ISTORE(KD+4))1050,1150,1150
C--ERROR BECAUSE THE LIST IS OPEN FOR WRITING
1050  CONTINUE
      CALL XPUMSG ( 6 , KD )
      GOTO 1200
C--ALLOCATE SPACE FOR THIS LIST
1150  CONTINUE
      KC=KCHNFL(KB)
C -- INCREASE TOTAL SPACE REQUIRED FOR SAVED LISTS
      LENTOT = LENTOT + ( ISTORE(KD+3) - ISTORE(KD+2) + 1 )
1200  CONTINUE
C--CHECK IF THERE ARE ANY LISTS ON THIS DISC
      IF(KC-KB+KA)2700,2700,1250
C--PRESERVE THE ADDRESS OF THE LAST LIST IN THE CURRENT LIST INDEX
1250  CONTINUE
      KE=KC-KB-KB
C--FIND ANY LISTS IN THE FILE INDEX WHICH CANNOT BE PURGED
      DO 1700 I=1,MLN
      ISRCH=0
C--SET THE POINTERS
1300  CONTINUE
      KD=KC-KB
      ISTORE(KD)=I
C--SEARCH FOR THE NEXT LIST OF THE CORRECT TYPE
      IF(KRFI(ISTORE(KD),ISRCH,ISTORE(KD+2),ISTORE(KD+3),ISTORE(KD+4),
     2 ISTORE(KD+5),ISTORE(KD+6)))1700,1350,1350
C--CHECK IF THIS LIST IS IN THE CURRENT LIST INDEX
1350  CONTINUE
      ISTORE(KD+1)=ISRCH
      DO 1450 J=KA,KE,KB
      IF(ISTORE(J)-ISTORE(KD))1450,1400,1450
C--CHECK THE SERIAL NUMBERS
1400  CONTINUE
      IF(IABS(ISTORE(J+1))-IABS(ISTORE(KD+1)))1500,1300,1500
1450  CONTINUE
C--CHECK IF THIS LIST SHOULD BE SAVED
1500  CONTINUE
CDJWMAY99{
C----- IS THIS LIST TYPE TO BE PURGED?
      IF ( (IPGTYP .NE. 0) .AND. (IPGTYP .NE. ISTORE(KD))) GOTO 1550
CDJWMAY99}
      IF ( ISTORE(KD+1) .LT. 0 ) GO TO 1550
C -- CHECK IF THIS SHOULD BE LOGGED
      IF ( LOGREQ .GT. 0 ) CALL XPUMSG ( 8 , KD )
      GO TO 1300
1550  CONTINUE
C -- LIST IS MARKED FOR RETENTION
C----- CHECK IF THIS IS A DELETED LIST
      IF(ISTORE(KD)) 1560,1560,1590
1560  CONTINUE
      CALL XPUMSG ( 5 , KD )
      GOTO 1300
1590  CONTINUE
      IF(ISTORE(KD+4))1600,1650,1650
C--LIST IS OPEN FOR WRITING
1600  CONTINUE
      CALL XPUMSG ( 6 , KD )
      GOTO 1300
C--CREATE SPACE FOR THE ENTRY
1650  CONTINUE
      KC=KCHNFL(KB)
C -- INCREASE TOTAL SPACE REQUIRED FOR SAVED LISTS
      LENTOT = LENTOT + ( ISTORE(KD+3) - ISTORE(KD+2) + 1 )
      GOTO 1300
1700  CONTINUE
C--FIND THE ADDRESS OF THE LAST ENTRY
      KD=KC-KB-KB
C
C -- CREATE NEW FILE IF REQUIRED
C
      IF ( NEWFIL .LE. 0 ) GO TO 1740
C -- CREATE NEW FILE
      IF ( NEWFIL .EQ. 1 ) THEN
        ISTAT = KDAOPN ( NUNEW , CSSNDA(1:LSSNDA) , ISSNEW , ISSWRI )
      ELSE
        ISTAT = KDAOPN ( NUNEW , CSSNDA(1:LSSNDA) , ISSSCR , ISSWRI )
      END IF
C -- CALCULATE THE SPACE REQUIRED FOR THE NEW FILE. THIS IS THE MAXIMUM
C    OF 0 , ( 'IRQSIZ'- 'MINSIZ' ) , AND 'LSTLEN'
C
      CALL XDACVI ( NWDRCI , NWDBLI , NBYWDI )
C
      LSTLEN = ( LENTOT / NWDRCI ) + 1
C
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 1732 ) LSTLEN
      ENDIF
1732  FORMAT ( 1X , 'The space required for the lists to be saved is ',
     2 I5 , ' record(s)' )
C
      IEXTND = MAX0 ( ( IRQSIZ - MINSIZ ) , 0 )
      IEXTND = MAX0 ( IEXTND , LSTLEN )
      CALL XDAXTN ( NUNEW , -1 , IEXTND )
C --
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 1735 ) IEXTND
1735  FORMAT ( 1X , 'The new file has been extended by ' , I5 ,
     1 ' record(s)' )
C --
1740  CONTINUE
C
C -- INFORM THE USER THAT THE INDEXES ARE ABOUT TO BE RESET
      CALL XPUMSG ( 12 , NUNEW )
C -- CHANGE TO THE OUTPUT DISC
      NSAVEU = KSWPDU ( NUNEW )
C
      CALL XLOADF
      CALL XLOADL
C
      CALL XSETFI
      CALL XSETLI
C
C -- RESTORE THE STORED LIST INDEX ENTRIES TO THE DISC INDEX
C
      DO 2000 I = KA , KD , KB
C
C -- CHECK THAT THE LIST HAS NOT BEEN LOST, BY BEING OVERWRITTEN BY THE
C    INDEX ENTRIES ( THIS IS NOT POSSIBLE IF A NEW FILE IS CREATED )
      IF ( NEWFIL .GT. 0 ) GO TO 1900
      IF ( ISTORE(I+2) .GE. KNEXTF(I) ) GO TO 1900
C -- LIST HAS BEEN LOST
      CALL XPUMSG ( 7 , I )
      ISTORE(I+2)=0
      GOTO 2000
C--WRITE THE LIST INTO THE FILE INDEX
1900  CONTINUE
      CALL XWFI(ISTORE(I),ISTORE(I+1),ISTORE(I+2),ISTORE(I+3),
     2 ISTORE(I+4),ISTORE(I+5),ISTORE(I+6),0)
C--CHECK IF THIS SHOULD BE ENTERED IN THE CURRENT LIST INDEX
      IF(I-KE)1950,1950,2000
C--WRITE THE ENTRY INTO THE CURRENT LIST INDEX
1950  CONTINUE
      CALL XWCLI(ISTORE(I),ISTORE(I+1),ISTORE(I+2),ISTORE(I+3),
     2 ISTORE(I+4),ISTORE(I+5),ISTORE(I+6))
2000  CONTINUE
C -- INFORM USER INDEX ( PARTIALLY RESTORED )
      CALL XPUMSG ( 13 , 0 )
C
C -- A FILE INDEX HAS NOW BEEN WRITTEN TO OUTPUT DISC.
C -- REWRITE LISTS TO THE OUTPUT DISC
C
C--FIND THE NEXT LIST TO BE OUTPUT
2100  CONTINUE
      IDWZAP = 0
      N=KNEXTF(IDWZAP)
      M = MADRES
      L=0
C--LOOP OVER ALL THE LISTS, SEARCHING FOR THE SMALLEST INITIAL ADDRESS
      DO 2350 I=KA,KD,KB
C--CHECK IF THE LIST HAS ALREADY BEEN PROCESSED
      IF(ISTORE(I+2))2350,2350,2150
C--CHECK THE ADDRESS
2150  CONTINUE
      IF(ISTORE(I+2)-M)2200,2350,2350
C--THIS IS THE SMALLEST  -  CHECK THE VALUE IS NOT TOO SMALL
2200  CONTINUE
      IF ( NEWFIL .GT. 0 ) GO TO 2300
      IF(ISTORE(I+2)-N)2250,2300,2300
C--THIS LIST HAS BEEN OVERWRITTEN BEFORE WE CAN USE IT
2250  CONTINUE
      CALL XPUMSG ( 7 , I )
C--ALTER THE WRITE FLAG TO INDICATE WE CANNOT USE THIS LIST
      ISTORE(I+4)=1
C--ALTER THE ERROR STATUS OF THIS LIST
      ISTORE(I+5)=-MAX0(IABS(ISTORE(I+5)),1)
      L=I
      IFLAG=-1
      GOTO 2550
C--THIS LIST IS BETTER  -  RECORD THE DETAILS
2300  CONTINUE
      L=I
      M=ISTORE(I+2)
2350  CONTINUE
C--CHECK IF WE HAVE PROCESSED ALL THE LISTS
      IF(L)2700,2700,2400
C--CHECK IF WE SHOULD REWRITE THIS LIST
2400  CONTINUE
      IULN=IABS(ISTORE(L))
      IF (  ( M .EQ. N ) .AND. ( NUOLD .EQ. NUNEW ) ) GO TO 2500
C -- DISC UNITS AND/OR ADDRESSES ARE DIFFERENT -- LIST SHOULD BE
C    REWRITTEN
C -- SET LIST NUMBER
      LN = IABS ( ISTORE(I) )
      CALL XPUCPY ( M , N , NUOLD , NUNEW )
2500  CONTINUE
      IFLAG=0
C--COMPUTE THE NEXT LIST LENGTH
      K=ISTORE(L+3)-ISTORE(L+2)+1
C--COMPUTE THE NEW ADDRESSES
      ISTORE(L+2)=N
      ISTORE(L+3)=N+K-1
C--COMPUTE THE NEXT FREE ADDRESS
      N=N+K
      CALL XNEXTF(N)
C--ALTER THE LIST INDEX ENTRIES
2550  CONTINUE
      CALL XWFI(ISTORE(L),ISTORE(L+1),ISTORE(L+2),ISTORE(L+3),
     2 ISTORE(L+4),ISTORE(L+5),ISTORE(L+6),-1)
C--CHECK IF THIS SHOULD BE ENTERED IN THE CURRENT LIST INDEX
      IF(L-KE)2600,2600,2650
C--WRITE THE ENTRY INTO THE CURRENT LIST INDEX
2600  CONTINUE
      CALL XWCLI(ISTORE(L),ISTORE(L+1),ISTORE(L+2),ISTORE(L+3),
     2 ISTORE(L+4),ISTORE(L+5),ISTORE(L+6))
2650  CONTINUE
      ISTORE(L+2)=0
      GOTO 2100
C--END OF THE PROCESS  -  TERMINATION MESSAGES
2700  CONTINUE
C
C
      CALL XPUMSG ( 11 , NUNEW )
      IF ( MONREQ .EQ. 0 ) CALL XPRTFI ( 0, 0 )
C
2720  CONTINUE
C Close new DA file / copy back from scratch.
      IF (NEWFIL .EQ. 1) THEN
        ISTAT = KFLCLS(NUNEW)
      ELSE IF ( NEWFIL .EQ. 2 ) THEN  ! Copy back over current dsc
        NRECOR = 1
        IOS = ISSOKF
        DO WHILE ( IOS .EQ. ISSOKF )
          READ ( NUNEW, REC = NRECOR, ERR = 2740, IOSTAT = IOS ) IRECOR
          IF ( IOS .EQ. ISSOKF ) THEN
            WRITE(NUOLD,REC = NRECOR, ERR = 2735, IOSTAT = IOS )IRECOR
          END IF
          NRECOR = NRECOR + 1
        END DO
        GOTO 2740
2735    CONTINUE
        WRITE (CMON,'(A,I4)') 'Error copying scratch back to dsc: ',IOS
        CALL XPRVDU(NCVDU, 1,0)
        IF (ISSPRT .EQ. 0) WRITE ( NCWU , '(a)' ) cmon(1)(:)
2740    CONTINUE
        WRITE (CMON,'(1X,A,I6,A)') 'Copied: ',NRECOR,' dsc records.'
        CALL XPRVDU(NCVDU, 1,0)
        IF (ISSPRT .EQ. 0) WRITE ( NCWU , '(a)' ) cmon(1)(:)
        ISTAT = KFLCLS(NUNEW)     ! and then close scratch.
      ENDIF

C FLUSH DISK BUFFERS
      CALL XGIVE

C -- PROCESSING COMPLETED. RESTORE LIST 50 INDEX ENTRY
      KA = KSWPDU ( NCIFU )
C--LOAD THE INDICES
      CALL XLOADF
      CALL XLOADL
C--READ THE DETAILS OF LIST 50
      LN50=50
      I=KRCLI(LN50,LSN50,NFW50,NLW50,IOWF50,NOS50,ISTORE(NFL))
C--SWOP BACK TO THE DATA DISC
      N = KSWPDU ( NSAVEU )
C--RELOAD ITS INDICES
      CALL XLOADF
      CALL XLOADL
C--WRITE THE INDEX DATA FOR LIST 50 INTO THIS INDEX
      CALL XWCLI(LN50,LSN50,NFW50,NLW50,IOWF50,NOS50,ISTORE(NFL))

C -- FINAL MESSAGE
      CALL XOPMSG ( IOPPUR , IOPEND , 610 )
      CALL XTIME2(2)
      CALL XRSL
      CALL XCSAE
      RETURN
C
C
9900  CONTINUE
      CALL XOPMSG ( IOPPUR , IOPABN , 0 )
      GO TO 2720
9910  CONTINUE
C -- NEGATIVE INITIAL SIZE
      CALL XPUMSG ( 2 , IRQSIZ )
      GO TO 9900
9920  CONTINUE
C -- INPUT ERRORS
CDJWAPR99
      WRITE(CMON,'(A)') 'Filename limited to 16 characters'
      CALL XPRVDU(NCEROR, 1,0)
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , '(a)' ) cmon(1)(:)
      CALL XOPMSG ( IOPPUR , IOPCMI , 0 )
      GO TO 9900
C
      END
C
C --
C
CODE FOR XPUCPY
      SUBROUTINE XPUCPY ( IFROM , ITO , NUOLD , NUNEW )
C
C -- COPY LIST FROM IFROM TO ITO. NUOLD AND NUNEW ARE THE DISC UNITS
C    FOR IFROM AND ITO RESPECTIVELY.
C
C--THIS ROUTINE USES ALL THE AVAILABLE STORE
C
C--
\HEADES
\ISTORE
C
\STORE
\XLISTI
C
\QSTORE
C
C--SET UP THE OLD DISC ADDRESSES
      IOLD1 = 0
      IOLD2 = IFROM
C--SET UP THE OUTPUT ADDRESSES
      INEW1 = 0
      INEW2 = ITO
C--FIND THE MAXIMUM AMOUNT OF CORE WE CAN USE
      JA = LFL - NFL
C--LOAD THE NEXT RECORD HEADER
1000  CONTINUE
      NUNIT = KSWPDU ( NUOLD )
C -- CHECK IF THERE IS A NEW RECORD. IF NOT, GOTO END
      IF ( KLDDRH ( IOLD1,IOLD2,IBUFF ) .LT. 0 ) GO TO 1500
C--NEW RECORD TO COPY  -  CHECK IF THIS IS THE FIRST
      IF ( INEW1 .LE. 0 ) GO TO 1150
C--NOT THE FIRST  -  UPDATE THE LAST FORWARD POINTER
      IBUFF(1) = INEW2
      NUNIT = KSWPDU ( NUNEW )
      CALL XUPF(INEW1,IBUFF(1),1)
C--ALTER THE ADDRESS POINTERS IN 'IBUFF'
1150  CONTINUE
      IBUFF(1) = 0
      IBUFF(2) = INEW1
C--FIND THE ADDRESS OF THE DATA FOR THIS RECORD
      M = IBUFF(4)
C--CHECK IF THE DATA IS ON DISC. ( M POSITIVE IF ON DISC )
      IF ( M .LE. 0 ) GO TO 1250
C--COMPUTE THE NEW ADDRESS
      IBUFF(4) = INEW2 + KINCRF ( MD0 )
C--OUTPUT THE HEADER
1250  CONTINUE
      NUNIT = KSWPDU ( NUNEW )
      CALL XUPF ( INEW2 , IBUFF(1) , MD0 )
C--SWITCH ADDRESSES
      INEW1 = INEW2
C--CHECK IF THE DATA IS ON DISC
      IF ( M .GT. 0 ) GO TO 1350
C--THE DATA IS NOT ON DISC
      INEW2 = INEW2 + KINCRF ( MD0 )
      GOTO 1000
C--DATA IS ON DISC  -  COMPUTE THE NEW ADDRESS
1350  CONTINUE
      INEW2 = INEW2 + KINCRF ( IBUFF(3) )
C--FIND THE NEW OUTPUT ADDRESS FOR THE DATA
      L = IBUFF(4)
C--FIND THE LENGTH OF THE RECORD
      N = IBUFF(3) - MD0
C--CHECK IF THERE IS MORE DATA TO OUTPUT
1400  CONTINUE
      IF ( N .LE. 0 ) GO TO 1000
C--OUTPUT THE NEXT BLOCK OF DATA
      K = MIN0 ( JA , N )
C--READ THE NEXT BLOCK DOWN
      NUNIT = KSWPDU ( NUOLD )
      CALL XDOWNF ( M , STORE(NFL) , K )
C--WRITE IT BACK
      NUNIT = KSWPDU ( NUNEW )
      CALL XUPF ( L , ISTORE(NFL) , K )
C--UPDATE THE ADDRESSES
      L = L + KINCRF ( K )
      M = M + KINCRF ( K )
C--UPDATE THE COUNT
      N = N - K
      GOTO 1400
C--DUMP THE DISC BUFFERS
1500  CONTINUE
      CALL XDUMP
      NUNIT = KSWPDU ( NUNEW )
      RETURN
      END
C
C --
C
CODE FOR XPUMSG
      SUBROUTINE XPUMSG ( IMSG , IPARAM )
C
C -- THIS ROUTINE PRODUCES MESSAGES FOR 'XPURGE'
C
C
C
C -- MESSAGE NUMBERS :-
C
C    1    INITIAL SIZE FOR OLD FILE IGNORED
C    2    ILLEGAL INITIAL SIZE REQUEST
C    3    ( NOT USED )
C    4    ( NOT USED )
C    5    LIST MARKED FOR DELETION
C    6    LIST BEING WRITTEN TO
C    7    LIST LOST
C    8      OLD VERSION
C    9    ( NOT USED )
C   10    ( NOT USED )
C   11    INDEX RESTORED COMPLETELY
C   12    INDEX UNUSABLE
C   13    INDEX PARTIALLY RESTORED
C
C
      CHARACTER*10 FILNAM
      CHARACTER*20 REASON(4)
C
\ISTORE
C
\STORE
\XUNITS
\XSSVAL
\XERVAL
\XOPVAL
\XIOBUF
C
\QSTORE
C
      DATA REASON(1) / '( deleted )     ' /
      DATA REASON(2) / '( being updated )' /
      DATA REASON(3) / '( lost )        ' /
      DATA REASON(4) / '( old version ) ' /
C
C
      MSGNUM = IMSG
      LIMIT = 13
C
C
      IF ( MSGNUM .GT. LIMIT ) GO TO 9910
      GO TO ( 2010 , 2020 , 9910 , 9910 , 2050 ,
     1 2050 , 2050 , 2050 , 9910 , 9910 ,
     2 2110 , 2120 , 2130 , 9910 ) , MSGNUM
C
      GO TO 9910
C
C
2010  CONTINUE
C
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 2015 )
      WRITE ( CMON, 2015)
      CALL XPRVDU(NCEROR, 2,0)
2015  FORMAT ( 1X , 'An initial size has been requested even though ',
     1 'an old file is being used' , / ,
     2 1X , 'Value ignored' )
      CALL XERHND ( IERWRN )
      GO TO 8000
C
2020  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 2025 ) IPARAM
      WRITE ( CMON, 2025 ) IPARAM
      CALL XPRVDU(NCEROR, 1,0)
2025  FORMAT ( 1X , 'An illegal initial size of ' , I8 ,
     1 ' has been requested' )
      GO TO 8000
C
C -- MESSAGE 3 REMOVED
C -- MESSAGE 4 REMOVED
C
2050  CONTINUE
C
      IREASN = MSGNUM - 4
C
      IULN = IABS ( ISTORE(IPARAM) )
      IULSN = IABS ( ISTORE(IPARAM+1) )
C
      ISTART = IABS ( ISTORE(IPARAM+2) )
      IEND   = IABS ( ISTORE(IPARAM+3) )
C
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 2053 ) IULN, IULSN, ISTART, IEND , REASON(IREASN)
      ENDIF
2053  FORMAT ( 1X , 'List type  ' , I3 , '  serial number ' , I4 ,
     2 ' from ' , I8 , ' to ' , I8 ,
     3 ' will not be copied ' , A )
      WRITE ( CMON, 2055 ) IULN , IULSN , REASON(IREASN)
      CALL XPRVDU(NCEROR, 1,0)
2055  FORMAT ( 1X , 'List type ' , I3 , ' serial number ' , I4 ,
     2 ' will not be copied ' , A20 )
C
      GO TO 8000
C
C -- MESSAGE 6 SEE ABOVE
C -- MESSAGE 8 SEE ABOVE
C
C -- MESSAGE 9 REMOVED
C -- MESSAGE 10 REMOVED
C
C
2110  CONTINUE
      CALL XDANAM ( IPARAM , FILNAM )
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 2115 ) FILNAM
      WRITE ( CMON, 2115 ) FILNAM
      CALL XPRVDU(NCVDU, 1,0)
2115  FORMAT ( 1X , 'Disc index completely restored' , // ,
     1 1X , 'Listing of file index of ' , A10 , ' file ' )
      GO TO 8000
C
2120  CONTINUE
      CALL XDANAM ( IPARAM , FILNAM )
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 1750 ) FILNAM
      WRITE ( CMON, 1750 ) FILNAM
      CALL XPRVDU(NCEROR, 2,0)
1750  FORMAT (' The ' , A10 , ' file is being rebuilt -'
     1 /' DO NOT abort the program' )
      GO TO 8000
C
2130  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 2135 )
      WRITE ( CMON, 2135 )
      CALL XPRVDU(NCEROR, 1,0)
2135  FORMAT ( 1X , 'The new disc index has been re-written ')
      GO TO 8000
C
C
C
8000  CONTINUE
C
      RETURN
C
C
9910  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 9915 ) MSGNUM
      WRITE ( CMON, 9915 ) MSGNUM
      CALL XPRVDU(NCEROR, 1,0)
9915  FORMAT ( 1X , 'Illegal or unexpected message code ' , I8 )
      CALL XERHND ( IERPRG )
C -- DUMMY RETURN
      RETURN
C
      END
C
C
C
CODE FOR XSIMUL
      SUBROUTINE XSIMUL
C -- A ROUTINE TO SIMULATE VARIOUS EVENTS, ETC.
C
C -- THIS ROUTINE IS INTENDED TO BE USED FOR SYSTEM TESTING ONLY,
C    USING THE 'SIMULATE' INSTRUCTION.
C
C      WRITTEN BY PAUL BETTERIDGE
C
C    VERSION 1        JUNE 1983       FIRST VERSION
C            1.1      AUGUST 1983     COMMANDS EXECUTED IMMEDIATELY
C            1.11                     ADD 'CHECKDISC' COMMAND
C            1.12                     ADD 'EXAMINE' COMMAND
C            1.13     NOVEMBER 1983   ADD 'IDENTIFY' COMMAND
C            1.14     DECEMBER 1983   ADD 'ENTER' COMMAND
C            1.15                     ADD 'DEPOSIT' COMMAND
C            1.16     JANUARY 1985    EXTEND 'EXAMINE' COMMAND
C            1.17     DECEMBER 1985   MAKE 'ENVIRONMENT' REFLECT CURRENT
C                                     BEHAVIOUR OF PROGRAM
C
C
C    DIRECTIVES AVAILABLE WITH SIMULATE
C
C    1  ENVIRONMENT
C         SET MODE FLAG
C    2  LIMIT
C         SET MAXIMUM NUMBER OF OCCURENCES OF SPECIFIED ERROR TYPE
C    3  ACTION
C         SET ACTION FOR SPECIFIED ERROR TYPE
C    4  RESET
C         CLEAR COUNTER FOR SPECIFED ERROR TYPE
C    5  CAUSE
C         CAUSE SPECIFIED ERROR TYPE
C    6  INITIALISE
C         REINITIALISE ERROR OR ENVIRONMENT VARIABLES
C    7  MESSAGE
C         GENERATE SPECIFIED MESSAGE
C    8  CHECKDISC
C         CHECK INTEGRITY OF DISC STRUCTURE (DISPLAY PARAMETER IGNORED)
C    9  IDENTIFY
C         IDENTIFY PROGRAM VERSION AND DATA FILES
C   10  EXAMINE
C         EXAMINE SPECIFIED DATA FROM DIRECT ACCESS DATA FILE
C   11  DEPOSIT
C         DEPOSIT SPECIFIED DATA IN DIRECT ACCESS DATA FILE
C   12  ENTER
C         WRITE ENTRY IN FILE LIST INDEX
C
C
C
      DIMENSION ID(2)
      DOUBLE PRECISION DSTORE(32678)
C
\ISTORE
C
\STORE
\XLISTI
\XUNITS
\XSSVAL
\XCARDS
\XCOMPD
\XLST50
\XERVAL
\XLSVAL
\XOPVAL
\XERCNT
\XIOBUF
C
\QSTORE
C
      EQUIVALENCE ( DSTORE(1) , STORE(1) )
C
      DATA IVERSN / 117 /
      DATA ICOMSZ / 6 /
C
C -- SET THE SIZE OF SPACE REQUIRED FOR COMMAND PROCESSING AND ACQUIRE
CMAR98
      ICOMBL = KSTALL ( ICOMSZ )
      CALL XZEROF (STORE(ICOMBL), ICOMSZ)
C -- ENSURE THAT THE ALL THE DIRECTIVES APPEAR TO HAVE BEEN READ ONCE
      MR61 = LR61
      DO 1000 I = 1 , NR60
      ISTORE(MR61+8) = 1
      MR61 = MR61 + MDR61
1000  CONTINUE
C
1050  CONTINUE
C -- READ NEXT DIRECTIVE
      IDIR = KRDNDC ( ISTORE(ICOMBL) , ICOMSZ )
C -- CHECK IF THE DIRECTIVE JUST READ IN IS 'END' OR 'CONTINUE'
      IF ( IDIR .LT. 0 ) GO TO 8800
      IF ( IDIR .EQ. 0 ) GO TO 9930
C
1100  CONTINUE
C -- PROCESS THE KEYWORDS AND PARAMETERS
      IDWZAP = 0
      IF (  KFNDNP ( IDWZAP )  .LE.  0  ) GO TO 1200
      IF (  KRDPV ( ISTORE(ICOMBL) , ICOMSZ )  .LT.  0 ) GO TO 1200
      GO TO 1100
C
1200  CONTINUE
C -- CHECK INPUT OF DIRECTIVE COMPLETE AND BRANCH ON THE FUNCTION
      ISTAT = KCHKPV ( IDIR , ISTORE(ICOMBL) , ICOMSZ , -1 )
      IF ( ISTAT .LT. 0 ) GO TO 9900
      IF ( LEF .GT. 0 ) GO TO 9900
C -- DISPLAY DIRECTIVE
      CALL XMONTR ( -1 )
C
      GO TO ( 2100 , 2200 , 2300 , 2400 , 2500 , 2600 , 2700 , 2800 ,
     2 2900 , 3000 , 3100 , 3200 ,
     3  9910 ) , IDIR
      GO TO 9910
C
2100  CONTINUE
C -- 'ENVIRONMENT' DIRECTIVE
      NEWMOD = ISTORE(ICOMBL)
      IF ( NEWMOD .EQ. 1 ) THEN
        IQUN = 1
        JQUN = 1
      ELSE IF ( NEWMOD .EQ. 2 ) THEN
        IQUN = 2
        JQUN = 2
      ELSE IF ( NEWMOD .EQ. 3 ) THEN
        IQUN = 3
        JQUN = 0
      ENDIF
      GO TO 8000
2200  CONTINUE
C -- 'LIMIT' DIRECTIVE
      ICODE = ISTORE(ICOMBL)
      INUM = ISTORE(ICOMBL+1)
      IERLIM(ICODE) = INUM
      GO TO 8000
2300  CONTINUE
C -- 'ACTION' DIRECTIVE
      ICODE = ISTORE(ICOMBL)
      IACTN = ISTORE(ICOMBL+1)
      IERCNT(ICODE) = IACTN
      GO TO 8000
2400  CONTINUE
C -- 'RESET' DIRECTIVE
      ICODE = ISTORE(ICOMBL)
      IERCOU(ICODE) = 0
      GO TO 8000
2500  CONTINUE
C -- 'CAUSE' DIRECTIVE
      ICODE = ISTORE(ICOMBL)
      CALL XERHND ( ICODE )
      GO TO 8000
2600  CONTINUE
C -- 'INITIALISE' DIRECTIVE
      IF ( ISTORE(ICOMBL) .GT. 0 ) CALL XQUEN
      IF ( ISTORE(ICOMBL+1) .GT. 0 ) CALL XERINI
      GO TO 8000
C
C
2700  CONTINUE
C -- 'MESSAGE' DIRECTIVE
      IFAC = ISTORE(ICOMBL)
      IMSG = ISTORE(ICOMBL+1)
      IPAR = ISTORE(ICOMBL+2)
      CALL XOPMSG ( IFAC , IMSG , IPAR )
      GO TO 8000
C
C
2800  CONTINUE
C -- 'CHECKDISC' DIRECTIVE
C    CHECK THE INTEGRITY OF THE DISC STRUCTURE
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 2891 )
      WRITE ( CMON, 2891 )
      CALL XPRVDU(NCVDU, 1,0)
2891  FORMAT (1X,' Now a function in #DISK')
      GO TO 8000
2900  CONTINUE
C -- 'IDENTIFY' COMMAND
C
      CALL XOPMSG ( IOPCRY , IOPVER , ISSVER )
      CALL XOPMSG ( IOPSIM , IOPVER , IVERSN )
C
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 2915 ) KTITL
      ENDIF
      WRITE ( CMON, 2915 ) KTITL
      CALL XPRVDU(NCVDU, 1,0)
2915  FORMAT ( / , 1X , 'Data file is :- ' , / , 1X , 20A4 , // )
C
      GO TO 8000
C
3000  CONTINUE
C -- 'EXAMINE' COMMAND
      ISTART = ISTORE(ICOMBL)
      LENGTH = ISTORE(ICOMBL+1)
      IMODE = ISTORE(ICOMBL+2)
C
C
      IF ( IMODE .EQ. 4 ) LENGTH = LENGTH + MOD ( LENGTH , 2 )
C
      IBUFFR = KSTALL ( LENGTH + 1 )
      ITMPBF = IBUFFR + MOD ( IBUFFR , 2 )
      IENDBF = ITMPBF + LENGTH - 1
      CALL XDOWNF ( ISTART , ISTORE(ITMPBF) , LENGTH )
C
      GO TO ( 3010 , 3020 , 3030 , 3040 , 3050 , 9910 ) , IMODE
      GO TO 9910
C
3010  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 3015 ) ( ISTORE(I) , I = ITMPBF , IENDBF )
      ENDIF
      WRITE ( CMON, 3015 ) ( ISTORE(I) , I = ITMPBF , IENDBF )
      CALL XPRVDU(NCVDU, 1,0)
3015  FORMAT ( 1X , 8I10 )
      GO TO 3090
3020  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 3025 ) ( STORE(I) , I = ITMPBF , IENDBF )
      ENDIF
      WRITE ( CMON, 3025 ) ( STORE(I) , I = ITMPBF , IENDBF )
      CALL XPRVDU(NCVDU, 1,0)
3025  FORMAT ( 1X , 8F10.4 )
      GO TO 3090
3030  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 3035 ) ( STORE(I) , I = ITMPBF , IENDBF )
      ENDIF
      WRITE ( CMON, 3035 ) ( STORE(I) , I = ITMPBF , IENDBF )
      CALL XPRVDU(NCVDU, 1,0)
3035  FORMAT ( 1X , 16A4 )
      GO TO 3090
3040  CONTINUE
      IDBLBF = ITMPBF / 2
      IDBEND = IENDBF / 2
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 3045 ) ( DSTORE(I) , I = IDBLBF , IDBEND )
      ENDIF
      WRITE ( CMON, 3045 ) ( DSTORE(I) , I = IDBLBF , IDBEND )
      CALL XPRVDU(NCVDU, 1,0)
3045  FORMAT ( 1X , 8F10.4 )
      GO TO 3090
3050  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 3055 ) ( STORE(I) , I = ITMPBF , IENDBF )
      ENDIF
      WRITE ( CMON, 3055 ) ( STORE(I) , I = ITMPBF , IENDBF )
      CALL XPRVDU(NCVDU, 1,0)
3055  FORMAT ( 1X , 5E16.5 )
      GO TO 3090
3090  CONTINUE
      CALL XSTRLL ( IBUFFR )
      GO TO 8000
C
C
3100  CONTINUE
C -- 'DEPOSIT' DIRECTIVE
      IADDRS = ISTORE(ICOMBL)
      IOFFST = ISTORE(ICOMBL+1)
C
      CALL XUPF ( IADDRS , ISTORE(ICOMBL+IOFFST) , 1 )
C
      GO TO 8000
C
3200  CONTINUE
C -- 'ENTER' DIRECTIVE
      LN = ISTORE(ICOMBL)
      LSN = ISTORE(ICOMBL+1)
      NFW = ISTORE(ICOMBL+2)
      LFW = ISTORE(ICOMBL+3)
      IOWF = ISTORE(ICOMBL+4)
      NOS = ISTORE(ICOMBL+5)
      NEW = 0
C
      ISTAT = KLSCHK ( LN , LSN , 0 , ILSCLS , ILSMSG , IADDR , IERWRN)
      IF ( ISTAT .LT. 0 ) GO TO 8000
C
      CALL XDATE ( ID(1) , ID(2) )
      CALL XWFI ( LN , LSN , NFW , LFW , IOWF , NOS , ID , NEW )
      GO TO 8000
C
C
C
8000  CONTINUE
      GO TO 1050
C
8800  CONTINUE
C -- 'END' FOUND  -  CHECK FOR INPUT ERRORS
      IF ( LEF .NE. 0 ) GO TO 9920
8900  CONTINUE
C -- RELEASE RESOURCES
      CALL XSTRLL ( ICOMBL )
      RETURN
C
9900  CONTINUE
      CALL XOPMSG ( IOPSIM , IOPABN , 0 )
      GO TO 8900
9910  CONTINUE
      CALL XOPMSG ( IOPSIM , IOPINT , 0 )
      GO TO 9900
9920  CONTINUE
      CALL XOPMSG ( IOPSIM , IOPCMI , 0 )
      GO TO 9900
9930  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 9935 )
      WRITE ( CMON, 9935 )
      CALL XPRVDU(NCVDU, 1,0)
9935  FORMAT ( 1X , 'CONTINUE is not allowed in SIMULATE' )
      GO TO 9900
C
C
      END
C
C
C
C
CODE FOR XCPYLN
      SUBROUTINE XCPYLN(IOLD,INEW)
C--THIS ROUTINE COPIES A LIST FROM ONE PART OF THE DISC TO ANOTHER
C
C  IOLD    THE OLD DISC ADDRESS.
C  INEW    THE NEW DISC ADDRESS.
C
C--THIS ROUTINE USES ALL THE AVAILABLE STORE
C
C--
\HEADES
\ISTORE
C
\STORE
\XLISTI
C
\QSTORE
C
C--SET UP THE OLD DISC ADDRESSES
      IOLD1=0
      IOLD2=IOLD
C--SET UP THE OUTPUT ADDRESSES
      INEW1=0
      INEW2=INEW
C--FIND THE MAXIMUM AMOUNT OF CORE WE CAN USE
      JA=LFL-NFL
C--LOAD THE NEXT RECORD HEADER
1000  CONTINUE
      IF(KLDDRH(IOLD1,IOLD2,IBUFF))1500,1050,1050
C--NEW RECORD TO COPY  -  CHECK IF THIS IS THE FIRST
1050  CONTINUE
      IF(INEW1)1150,1150,1100
C--NOT THE FIRST  -  UPDATE THE LAST FORWARD POINTER
1100  CONTINUE
      IBUFF(1)=INEW2
      CALL XUPF(INEW1,IBUFF(1),1)
C--ALTER THE ADDRESS POINTERS IN 'IBUFF'
1150  CONTINUE
      IBUFF(1)=0
      IBUFF(2)=INEW1
C--FIND THE ADDRESS OF THE DATA FOR THIS RECORD
      M=IBUFF(4)
C--CHECK IF THE DATA IS ON DISC
      IF(M)1250,1250,1200
C--COMPUTE THE NEW ADDRESS
1200  CONTINUE
      IBUFF(4)=INEW2+KINCRF(MD0)
C--OUTPUT THE HEADER
1250  CONTINUE
      CALL XUPF(INEW2,IBUFF(1),MD0)
C--SWITCH ADDRESSES
      INEW1=INEW2
C--CHECK IF THE DATA IS ON DISC
      IF(M)1300,1300,1350
C--THE DATA IS NOT ON DISC
1300  CONTINUE
      INEW2=INEW2+KINCRF(MD0)
      GOTO 1000
C--DATA IS ON DISC  -  COMPUTE THE NEW ADDRESS
1350  CONTINUE
      INEW2=INEW2+KINCRF(IBUFF(3))
C--FIND THE NEW OUTPUT ADDRESS FOR THE DATA
      L=IBUFF(4)
C--FIND THE LENGTH OF THE RECORD
      N=IBUFF(3)-MD0
C--CHECK IF THERE IS MORE DATA TO OUTPUT
1400  CONTINUE
      IF(N)1000,1000,1450
C--OUTPUT THE NEXT BLOCK OF DATA
1450  CONTINUE
      K=MIN0(JA,N)
C--READ THE NEXT BLOCK DOWN
      CALL XDOWNF(M,STORE(NFL),K)
C--WRITE IT BACK
      CALL XUPF(L, ISTORE(NFL),K)
C--UPDATE THE ADDRESSES
      L=L+KINCRF(K)
      M=M+KINCRF(K)
C--UPDATE THE COUNT
      N=N-K
      GOTO 1400
C--DUMP THE DISC BUFFERS
1500  CONTINUE
      CALL XDUMP
      RETURN
      END
C
CODE FOR KPRTLN
      FUNCTION KPRTLN(IULN,IADDI)
C--CHECK I A LIST IS AVAILABLE FOR PRINTING AND OUTPUT THE NECESSARY CAP
C
C  IULN    THE LIST TYPE TO BE PRINTED.
C  IADDI   THE DISC ADDRESS OF THE FIRST HEADER BLOCK.
C
C--RETURN VALUES OF 'KPRTLN' ARE :
C
C          -1  ERROR  -  NO PROCESSING IS POSSIBLE
C           0  ALL OKAY FOR PRINTING.
C
C--
\ISTORE
C
      DIMENSION ID(2)
      CHARACTER*24 CDT
\STORE
\XLISTI
\XUNITS
\XSSVAL
\XERVAL
\XLSVAL
\XIOBUF
C
\QSTORE
C
      KPRTLN=-1
C--SET THE LIST AND RECORD TYPES
      LN=IULN
      IREC=0
      ISTAT = KLSCHK ( LN , 0 , 0 , ILSAVI , ILSMSG , IADDR , IERERR )
      IF ( ISTAT .LE. 0 ) GO TO 9900
C -- READ INDEX
      CALL XRLIND ( LN , LSN , IADDI , LL , IOW , NOS , ID )
C -- START NEW PAGE
      CALL XPRTCN
C--PRINT THE LIST TYPE AND DETAILS
      LSN=IABS(LSN)
      IF (ISSPRT .EQ. 0) THEN
        IF (ID(1).NE.0) THEN
          WRITE(NCWU,1300)LN,LSN,IADDI,LL,ID
        ELSE
          CALL XCDATE(ID(2),CDT)
          WRITE(NCWU,1300)LN,LSN,IADDI,LL,CDT
        END IF
      ENDIF
1300  FORMAT(' Print list type ',I5,5X,'serial number ',I8,5X,
     2 'Address ',I8,5X,'Length ',I7,5X,'Created on  ',2A4/)
1301  FORMAT(' Print list type ',I5,5X,'serial number ',I8,5X,
     2 'Address ',I8,5X,'Length ',I7,5X,'Created on  ',A24/)
      KPRTLN=0
      RETURN
C
9900  CONTINUE
C -- ERRORS
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 9905 ) LN
      WRITE ( CMON, 9905 ) LN
      CALL XPRVDU(NCEROR, 1,0)
9905  FORMAT ( 1X, 'List type ' ,I5, ' is not available for printing' )
      KPRTLN = -1
      RETURN
      END
C
cCODE FOR XDUMDR
c      SUBROUTINE XDUMDR(ICOMMN,IDIMN)
cC--DUMP DATA RECORDS THAT ARE HELD IN CORE
cC
cC  ICOMMN  THE CONTROLLING COMMON BLOCK.
cC  IDIMN    THE DIMENSION OF THE COMMON BLOCK.
cC
cC--
cC
c      DIMENSION ICOMMN(IDIMN)
cC
c\XUNITS
c\XSSVAL
cC
cC--WRITE THE COMMON BLOCK
c      CALL XLINES
c      IF (ISSPRT .EQ. 0) THEN
c      WRITE(NCWU,1000)ICOMMN
c      ENDIF
c1000  FORMAT(12I10)
cC--COMPUTE THE NUMBER OF DATA RECORDS
c      N=IDIMN/4
c      DO 1050 I=1,N
c      J=(I-1)*4+1
c      K=ICOMMN(J)
c      L=K+ICOMMN(J+2)*ICOMMN(J+3)-1
c      CALL XPRINT(K,L)
c1050  CONTINUE
c      CALL XLINES
c      RETURN
c      END

CODE FOR KBITS
      FUNCTION KBITS(IF,IV)
C--RETURNS SET TO THE VALUE OF THE BIT MONITORED
C
C  IF  VARIABLE HOLDING THE WORD TO BE CHECKED
C  IV  VALUE OF THE BIT TO BE MONITORED
C      IF BIT N IS TO BE CHECKED, IV=2**N  (BITS RUN FROM 23-0)
C      FOR EXAMPLE, IV=1 FOR BIT 0, IV=4 FOR BIT 2, ETC.
C
C--
C
C
      DATA I/0/
C
C
      I=IF/IV
      KBITS=I-I/2*2
      RETURN
      END
C
CODE FOR XICA
      SUBROUTINE XICA
C--INSUFFICIENT CORE AVAILABLE
C
\XLISTI
\XUNITS
\XSSVAL
\XIOBUF
C
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1000)
      WRITE ( CMON, 1000)
      CALL XPRVDU(NCEROR, 1,0)
1000  FORMAT(' Insufficient core available')
      LEF=LEF+1
      RETURN
      END
