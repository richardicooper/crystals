C $Log: not supported by cvs2svn $
C Revision 1.38  2012/09/17 12:24:53  rich
C DPROD subroutine name clashes with intrinsic function. Renamed DVPROD.
C
C Revision 1.37  2012/03/16 15:51:42  rich
C Bugfix.
C
C Revision 1.36  2012/03/16 11:09:53  rich
C Preserve sign of F in Fo-patterson coefficient.
C
C Revision 1.35  2012/01/04 14:31:25  rich
C Fix some uninitialized variables, and output format mistakes.
C
C Revision 1.34  2011/07/01 13:42:45  djw
C Change the dot product module name from VPROD to DPROD
C
C Revision 1.33  2011/03/21 13:57:21  rich
C Update files to work with gfortran compiler.
C
C Revision 1.32  2011/02/07 16:59:30  djw
C Put IDOM09 into ICOM09
C
C Revision 1.31  2010/07/29 15:29:24  djw
C remove diagnostic print
C
C Revision 1.30  2010/07/16 11:35:31  djw
C Enable XPCHLX to output lists 12 and 16 to the cif file.  This means carrying the I/O chanel (as NODEV)
C in XPCHLX,XPCHLH,PPCHND and XPCHUS.
C Fixed oversight in distangle for esds of H-bonds
C
C Revision 1.29  2010/03/29 13:46:43  djw
C Get hols of scale for difference Pattersons
C
C Revision 1.28  2010/03/10 12:26:17  djw
C ensure correct scaling of all Pattersons
C
C Revision 1.27  2009/07/31 12:42:05  djw
C Remove de-bugging out put from the monitor
C
C Revision 1.26  2009/05/19 14:37:01  djw
C Provide the orthogonalisation matrix as a rotation matrix, set the LIST 14 intervals in A
C
C Revision 1.25  2005/01/23 08:29:11  rich
C Reinstated CVS change history for all FPP files.
C History for very recent (January) changes may be lost.
C
C Revision 1.2  2004/12/13 16:16:08  rich
C Changed GIL to _GIL_ etc.
C
C Revision 1.1.1.1  2004/12/13 11:16:10  rich
C New CRYSTALS repository
C
C Revision 1.24  2004/09/29 11:56:28  rich
C Main weights update.
C
C Revision 1.23  2004/08/09 11:33:42  rich
C Updated Fourier code with support for Main's weights. This version passes
C regression tests with the following exceptions:
C 1. The OPTIMAL Fourier type had a bug which caused Fc not to be weighted
C    each time a new min or max weight was found.
C 2. The Sim weights were incorrect (X doubled) for non-centro structures,
C    this overweighted all reflections, so the maps don't change much.
C 3. Sim weights were set to units for X>6. This has been increased without
C    danger of overflow to 600, and gives a more continous function as X->large.
C
C Routine XMASKF returns the Fourier transform of List 42.
C
C List 42 operations extended: #MASK CLOSETO sets points in L42 to one if they
C are within RADIUS+VOID of an atom, but outside RADIUS - use to find atoms
C close to other atoms. #MASK SHOW puts 'R' atoms into L5 at points where the
C mask is non-zero - warning, could take forever, intended for testing only.
C #MASK SETFC sets the FC and phase slots in List 6 to the Fourier transform
C of the mask. New L42 source option allows the mask to be specified based on
C the current L14, but at a different resolution: SOURCE MOD14 XD=.1 YD=.1 ZD=.1
C creates a mask using .1 Angstrom divisions in each direction.
C
C Revision 1.22  2004/07/08 15:25:33  rich
C Updated \MASK code to include mask generation for solvent accessible volume.
C (It wasn't finished before.) Mask is stored in list 42.
C
C Revision 1.21  2004/07/02 13:26:01  rich
C Remove dependency on HARWELL and NAG libraries. Replaced with LAPACK
C and BLAS code (and a home-made bessel function approximation).
C
C Revision 1.20  2003/12/02 11:52:33  rich
C Code for \MASK command.
C
C Changed output of Fourier map data, so that the cell is NOT permuted
C in the output file. This makes the output the same form as the
C \slant file. The permutation can be recovered from the translation
C matrix given at the top of the file.
C
C Revision 1.19  2003/05/07 12:18:54  rich
C
C RIC: Make a new platform target "WXS" for building CRYSTALS under Windows
C using only free compilers and libraries. Hurrah, but it isn't very stable
C yet (CRYSTALS, not the compilers...)
C
C Revision 1.18  2003/03/25 19:41:05  djw
C Label holes as QN
C
C Revision 1.17  2003/03/25 14:02:34  rich
C Move DELRHOMIN/MAX back to their original locations in LIst 30.
C
C Revision 1.16  2003/02/17 13:28:43  djw
C Remove writes to .mon from FOURIER, save Rho and positions in LIST 30 CIFEXTRA (was in REFINEMENT), adjust output of 30
C
C Revision 1.15  2003/02/14 17:09:02  djw
C Extend codes to work wih list 6 and list 7.  Note that sfls, calc and
C recine have the parameter ityp06, which corresponds to the types
C pickedip for lists 6 and 7  from the command file
C
C Revision 1.14  2002/12/16 18:24:05  rich
C Reduce output, update calls to KDIST1
C
C Revision 1.13  2002/10/02 13:39:00  rich
C Mapview file output.support.
C
C Revision 1.12  2002/06/07 16:13:46  richard
C Just some tidying.
C
C Revision 1.11  2002/03/13 12:35:21  richard
C Added extra argument to calls to KDIST1.
C
C Revision 1.10  2001/06/27 12:15:11  richard
C Spelling error.
C
C Revision 1.9  2001/02/26 10:26:47  richard
C Added changelog to top of file
C
c---------- FOURIE.FPP
c      CALL XFOURA
CODE FOR XFOURA
c      SUBROUTINE XFOURA
c      CALL XFOURB
c---------- FOURIER.FPP
CODE FOR XFOURB
c      SUBROUTINE XFOURB
c      CALL XFOURI
c      CALL XFOURJ(ITYP06)
c      CALL XFOURM
c      CALL XFOURN
c      CALL XFOURO
c      CALL XFOURP(LNOUT)
CODE FOR XFOURI
c      SUBROUTINE XFOURI
CODE FOR XFOURJ
c      SUBROUTINE XFOURJ(ITYP06)
CODE FOR XFOURM
c      SUBROUTINE XFOURM
CODE FOR XFOURN
c      SUBROUTINE XFOURN
CODE FOR XFOURO
c      SUBROUTINE XFOURO
CODE FOR XFOURP
c      SUBROUTINE XFOURP(LNOUT)
C
CODE FOR XFOURB
      SUBROUTINE XFOURB
C--MAIN FOURIER ROUTINE
C
C  NTYP    TYPE OF FOURIER
C
C          1  /FO/ FOURIER, WITH REJECTION IF /FC/<0.001
C          2  /FC/ FOURIER, WITH REJECTION IF /FC/<0.001
C          3   DF  FOURIER, WITH REJECTION IF /FC/<0.001
C          4  2FO-FC FOURIER
C          5  'OPTIMAL' (WEIGHTED) FOURIER
C          6  FO PATTERSON
C          7  FC PATTERSON
C          8  (FO-FC)**2 PATTERSON
C          9  FO**2-FC**2 PATTERSON
C         10  'E' MAP WITH DATA FROM TAPE
C         
C
C  NE      NUMBER OF THE E-MAP TO COMPUTE.
C  NWT     WEIGHTING PARAMETER :
C
C          -2  MAIN's WEIGHTS
C          -1  SIM WEIGHTED.
C           0  NO WEIGHTS.
C           1  WEIGHTS TAKEN FROM LIST 6.
C
C  IPRINT  PRINT CONTROL FLAG :
C
C          -1  NO PRINTING OF THE MAP
C           0  PRINT THE MAP.
C
C  THRES1  VALUES ON THE MAP BELOW THIS ARE PRINTED AS BLANKS.
C  THRES2  VALUES ABOVE THIS ON THE MAP ARE PRINTED AS BLANKS.
C  IALL    REFLECTIONS REJECTION FLAG :
C
C           0  DO NOT USE AN /FC/ REJECTION TEST.
C       1 - 3  USE A REJECTION TEST FOR /FC/'S
C
C  NLINE   NUMBER OF LINES PER GRID POINT ON THE MAP
C  NCHAR   NUMBER OF CHARACTERS PER NUMBER ON THE MAP.
C  NCHARC  NUMBER OF CHARACTERS PER LINE NUMBER ON THE MAP.
C  NSPACE  NUMBER OF SPACES AT THE EDGE OF THE MAP.
C  ISCAN   PEAK SEARCH CONTROL FLAG :
C
C          -1  NO PEAK SCAN.
C           0  PEAK SCAN, USING DEFAULT VALUE FOR 'HEIGHT*SCALE FACTOR'.
C           1  PEAK SCAN, USING THE ACTUAL VALUE OF 'HEIGHT'.
C
C  HEIGHT  THE MINIMUM PEAK HEIGHT FLAG, MULTIPLIED BY THE SCALE
C          FACTOR IF 'SCAN' IS ZERO.
C  NPEAK   THE NUMBER OF PEAKS ALLOWED.
C  INTAPE  A MAP CAN BE READ FROM TAPE IS THIS PARAMETER IS NON-ZERO.
C  IOUTAP  THE MAP SHOULD BE OUTPUT TO TAPE IS THIS PARAMETER IS NON-ZER
C  F000    THE VALUE OF F(000) TO BE USED.
C  ISC     TYPE OF SCALING REQUIRED :
C
C          -1  TAKE SCALE FACTOR FROM LIST 14.
C           0  TAKE SCALE FACTOR FROM LIST 14, EXCEPT FOR E-MAPS AND PAT
C           1  COMPUTE A SCALE FACTOR FOR ALL TYPES.
C
C  SCLCON  VALUE TO WHICH THE ORIGIN IS TO BE SCALED.
C  REJECT  REJECTION DISTANCE FOR PEAKS DURING THE PEAK SEARCH.
C          IF A NEW PEAK HAS A GREATER PEAK HEIGHT THAN ANY OTHERS
C          WITHIN 'REJECT' ANGSTROM OF IT, THE OTHER PEAKS ARE DELETED
C          AND THE NEW ONE RETAINED. ON THE OTHER HAND, IF THE HEIGHT OF
C          THE NEW PEAK IS LESS THAN 'REJECT' ANGSTROM, THE NEW PEAK IS
C          OMITTED.
C  NGMAP   -1 NEGATES 'F' BEFORE COMPUTATION OF MAP, FOR FINDING 'HOLES'
C             PEAK HEIGHTS RESTORED LATER.
C           0 FOR A NORMAL MAP, RESET AT STARTUP TO +1
C
C  IFCALC  -1 DONOT COMPUTE STRUCTURE FACTORS
C           0 DO   COMPUTE STRUCTURE FACTORS
C
C--USE OF THE VARIABLES IN THE COMMON BLOCK 'XWORKA' :
C
C  JA  MINIMUM X
C  JB  MINIMUM Y
C  JC  MINIMUM Z
C
C--THE THREE ABOVE ARE EQUIVALENCED TO 'MINW'
C
C  JD  NUMBER OF DIVISIONS IN THE UNIT CELL ALONG THE X DIRECTION
C  JE  NUMBER OF DIVISIONS IN THE UNIT CELL ALONG THE Y DIRECTION
C  JF  NUMBER OF DIVISIONS IN THE UNIT CELL ALONG THE Z DIRECTION
C
C--THE THREE ABOVE ARE EQUIVALENCED TO 'NUN'
C
C  JG  NUMBER OF DIVISIONS TO COMPUTE ALONG THE X DIRECTION
C  JH  NUMBER OF DIVISIONS TO COMPUTE ALONG THE Y DIRECTION
C  JI  NUMBER OF DIVISIONS TO COMPUTE ALONG THE Z DIRECTION
C
C--THE THREE ABOVE ARE EQUIVALENCED TO 'NUM'
C
C  JJ  ADDRESS OF THE COSINE TABLE FOR X
C  JK  ADDRESS OF THE COSINE TABLE FOR Y
C  JL  ADDRESS OF THE COSINE TABLE FOR Z
C
C--THE THREE ABOVE ARE EQUIVALENCED TO 'IAC'
C
C  JM  ADDRESS OF THE SINE TABLE FOR X RELATIVE TO COSINE TABLE
C  JN  ADDRESS OF THE SINE TABLE FOR Y RELATIVE TO COSINE TABLE
C  JO  ADDRESS OF THE SINE TABLE FOR Z RELATIVE TO COSINE TABLE
C
C--THE THREE ABOVE ARE EQUIVALENCED TO 'IAS'
C
C  JP  MAXIMUM COSINE ADDRESS FOR X
C  JQ  MAXIMUM COSINE ADDRESS FOR Y
C  JR  MAXIMUM COSINE ADDRESS FOR Z
C
C--THE THREE ABOVE ARE EQUIVALENCED TO 'MXC'
C
C  JS  ADDRESS OF THE LOOK UP TABLE FOR 'H'
C  JT  START OF THE 'HK' PAIRS STACK  -  HELD IN 'FSTORE'.
C  JU  ADDRESS OF THE LAST ENTRY IN THE 'HK' STACK
C  JV  NUMBER OF WORDS PER 'HK' ENTRY IN THE STACK
C  JW  NUMBER OF HEADER WORDS PER 'HK' ENTRY, AS FOLLOWS :
C      0  H VALUE FOR THIS PAIR
C      1  K VALUE FOR THIS PAIR
C  JX  NUMBER OF Y POSITIONS TO BE CALCULATED AT A TIME
C  JY  NUMBER OF 'HK' PAIRS FOUND
C  JZ  (NUMBER OF Z LAYERS PER HK ENTRY)*2
C
C  KB  INCREMENT UP Z SIN/COS TABLE FOR THE CURRENT SCAN.
C  KC  NUMBER OF POINTS ALONG Y MINUS JX.
C
C  KF  INCREMENT ALONG THE FOR X DIRECTION.
C  KG  INCREMENT ALONG THE FOR Y DIRECTION.
C  KH  INCREMENT ALONG THE FOR Z DIRECTION.
C
C--THE VARIABLES ABOVE ARE EQUIVALENCED TO 'ISTEP'.
C
C  KI  CURRENT SECTION POINTER IN THE 'KH' PAIR STACKS
C  KJ  NUMBER OF SECTIONS COMPUTED.
C  KK
C  KL
C  KM
C  KN  NUMBER OF WORDS IN PARTIAL TOTAL AREA
C  KO  INCREMENT ALONG THE PARTIAL SUM TABLE FOR Y FOR 'JX' TERMS.
C  KP  NOT USED
C  KQ
C  KR  ADDRESS OF THE EQUIVALENT INDICES TABLE
C  KS  USED IN EQUIVALENT INDICES PROCESSING.
C  KT  USED IN EQUIVALENT INDICES PROCESSING.
C  KU  NUMBER OF WORDS PER EQUIVALENT INDEX ENTRY.
C  KV  ADDRESS OF THE PARTIAL SUM FOR Y.
C  KW  WORK VARIABLE FOR KV.
C
C  KX  MAXIMUM ALONG THE X DIRECTION.
C  KY  MAXIMUM ALONG THE Y DIRECTION
C  KZ  MAXIMUM ALONG THE Z DIRECTION.
C
C--THE ABOVE THREE VARIABLES ARE EQUIVALENCED TO 'MAXW'
C
C--FORMAT OF THE ENTRY FOR EACH H VALUE IN THE INITIAL SEARCH :
C
C   0  LINK TO THE NEXT H VALUE
C  -1  H VALUE
C  -2  ADDRESS OF THE FIRST K FOR THIS H
C  -3  MAXIMUM VALUE OF K FOUND FOR THIS H
C  -4  MINIMUM VALUE OF K FOUND FOR THIS H
C
C--FORMAT OF THE ENTRY FOR EACH K VALUE IN THE INITIAL SEARCH :
C
C   0  LINK TO THE NEXT K VALUE
C  -1  THIS K VALUE
C
C--DURING THE INITIAL SEARCH, THE TWO STACKS ABOVE ARE FORMED FROM
C  THE TOP DOWN.
C
C--AFTER THE INITIAL SEARCH, THE 'HK' PAIRS ARE ORGANIZED AS :
C
C  FOR EACH H VALUE, IN THE H LOOK UP TABLE, THE ADDRESS OF THE
C  ASSOCIATED K LOOK UP TABLE.
C
C  FOR EACH K VALUE, IN THE K LOOK UP TABLE, THE ADDRESS OF THE
C  THE INFORMATION FOR THIS 'HK' PAIR .
C
C--THE VARIABLES IN THE COMMON BLOCK 'XWORK' ARE USED AS FOLLOWS :
C
C  IAXIS   THE ORIENTATION PARAMETERS.
C  IXYZ    SORTED AXIS NAMES  -  I.E. SORTED 'X', 'Y' AND 'Z'.
C  NV      THE NUMBER OF SCANS COMPLETED.
C  SCALE   THE SCALE FACTOR FROM LIST 5.
C  SS      MAP SCALE FACTOR ON THE SCALE OF ELECTRONS
C  SC      THE MAP SCALE FACTOR USED.
C  VOL     THE VOLUME, TAKEN FROM LIST 1.
C  NORFL   THE NUMBER OF REFLECTIONS USED ON THE PRESENT SCAN.
C  L6DUMP  A DUMP OF THE READ POINTER FOR LIST 6  -  'L6R'.
C  N6DUMP  A DUMP OF THE NUMBER OF REFLECTIONS TO BE READ  -  'N6R'.
C  SSV     SUM OF THE FORM FACTORS SQUARED TIMES THE NUMBER OF
C          ATOMS IN THE ASYMMETRIC UNIT FOR EACH ATOM TYPE IN LIST 29.
C          THIS IS USED FOR SIM WEIGHTING, AND LIST 29 IS CORRECTED
C          BY REMOVING ATOMS THAT ARE IN LIST 5 BEFORE THIS TOTAL IS
C          COMPUTED.
C  SSU     RATIO OF SUM(W FO) / SUM(FO)
C  DENMIN  MINIMUM ELECTRON DENSITY
C  FXMIN   FOURIER X COORD OF DENMIN (AND Y AND Z)
C  IPMAP   INDEX OF FIRST PATTERSON MAP IN NTYP
C  IEMAP   INDEX OF E - MAP IN NTYP. ALSO LAST MAP TYPE
C  HWMIN   THE DETAILS OF THE MAX. AND MIN. SIM WEIGHTS ARE HELD IN
C          THIS ARRAY.
C  AAA     THE MEAN DENSITY AT ORIGINAL ATOMIC SITE.
C  BBB     THE NUMBER OF ORIGINAL ATOMIC SITES FOUND.
C  CCC     SUM THE SQUARED DEVIATIONS AT THE ORIGINAL ATOMIC SITES.
C  DDD     THE ROOT MEAN SQUARE DEVIATION FROM THE MEAN AT THE ORIGINAL
C          ATOMIC SITES.
C  L81     ADDRESS OF THE CURRENT MAP SECTION. THE MAP IS HELD
C          IN 'FSTORE' AND 'L8' POINTS TO THE START OF THIS AREA.
C  L82     ADDRESS OF THE LAST SECTION CALCULATED.
C  L83     ADDRESS OF THE LAST BUT ONE SECTION COMPUTED.
C  N10MAX  THE MAXIMUM OF PEAKS THAT CAN COLLECTED DURING THIS FOURIER.
C          THIS IS A FUNCTION OF 'NPEAK', BUT NOT EQUAL TO IT TO ALLOW
C          FOR DUPLICATED PEAKS.
C  NY      THE NUMBER OF POINTS ACROSS THE PAGE.
C  NZ      THE NUMBER OF POINTS DOWN THE PAGE.
C  NYNZ    THE PRODUCT OF 'NY' AND 'NZ'.
C  NYM2    THE NUMBER OF POINTS ACROSS THE PAGE, MINUS 2.
C  NY2     TWICE THE NUMBER OF POINTSACROSS THE PAGE
C  NYNZM2  THE PRODUCT OF 'NY' AND 'NZ' MINUS 2.
C
C--
      CHARACTER *10 CRADTP
      CHARACTER *25 CSERI
      DIMENSION KDEV(4)
      DIMENSION THKL(3)
      INCLUDE 'ICOM30.INC'
      INCLUDE 'FOURTP.INC'
      INCLUDE 'ISTORE.INC'
C
C
C
      INCLUDE 'IFOURB.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XFOURC.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XNWPGE.INC'
      INCLUDE 'XLST14.INC'
      INCLUDE 'XLST13.INC'
      INCLUDE 'XLST30.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XLST02.INC'
      INCLUDE 'XLST03.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST42.INC'
      INCLUDE 'XTAPES.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XPDS.INC'
      INCLUDE 'XDSTNC.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QLST30.INC'
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QFOURC.INC'
C
C
      INCLUDE 'QFOURB.INC'
C
C To access the MAP file name
      INCLUDE 'TSSCHR.INC'
      INCLUDE 'XSSCHR.INC'
      INCLUDE 'UFILE.INC'
C
C
C
      DATA IVERSN /835/
      INCLUDE 'IDIMFB.INC'
C
C
C--READ THE REMAINDER OF THE DATA
      CALL XTIME1(2)
      ISTAT = KRDDPV ( PROCS, IDIMFB)
      IF ( ISTAT .LT. 0 ) GO TO 9910
C      SET THE REFLECTION LIST TYPE (1/2 = 6/7)
      ITYP06 = INFILE
C
C----- SET THE START OF THE PATTERSON  MAPS
      IPMAP =6
C----- SET THE EMAP, WHICH IS ALSO LAST TYPE
      IEMAP = 10
C--CHECK THE FOURIER TYPE
      IF(NTYP)1100,1100,1150
1100  NTYP=1
C--CHECK THAT THIS IS AN ALLOWED FOURIER TYPE
1150  CONTINUE
C---- SET MULTIPLIER +VE FOR MORMAL MAP
      IF (NGMAP .GT. -1) THEN
            NGMAP = 1
      ENDIF
      IF (NTYP .GT. IEMAP) GOTO 9920
C--CLEAR THE CORE CONTROL FLAGS
      IF( (IFCALC .EQ. 0) .AND. (NTYP .LT. IPMAP) ) THEN
         IF (KEXIST(33) .LE. 0) THEN
            IF (ISSPRT .EQ. 0) WRITE(NCWU, 1151)
            WRITE ( CMON ,1151)
            CALL XPRVDU(NCVDU, 1,0)
1151        FORMAT(' This option NOT available unless SFLS ',
     2             'have been performed in the past')
            GOTO 9900
         ENDIF
         CALL XSFLSB(IFCALC, ITYP06)
      ENDIF
      IF (IERFLG .LT. 0) GOTO 9900
      CALL XRSL
      CALL XCSAE
C----- INITIALISE THE MINIMUM DENSITY
      DENMIN =  100000.
      DENMAX =  -100000.
      JPOINT = 19
CDJW99[
C----- GET LIST 13 FOR THE RADIATION TYPE
      IRADTP = -1
      IF (KEXIST(13) .GE. 1) THEN
            CALL XFAL13
            IRADTP = ISTORE(L13DT+1)
      ENDIF
CDJW99]
C--LOAD LIST 5 AND SET UP LIST 10, and load 3,23,29
      CALL XFOURI
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--LOAD LISTS 1, 2, 6 AND 14, SORT LIST 5, AND SET UP LIST 10
      CALL XFOURJ(ITYP06)
      IF ( IERFLG .LT. 0 ) GO TO 9900

      IF ( NWT .EQ. -2 ) THEN   ! Load stuff required for Main's weights
        IF (KEXIST(42) .LE. 0) GOTO 9942
        IF (KHUNTR (23,0, IADDL,IADDR,IADDD, -1) .LT. 0) CALL XFAL23
        IF (KHUNTR (42,0, IADDL,IADDR,IADDD, -1) .LT. 0) CALL XFAL42
c        CALL XFSWOP(STORE(L42),9,3,1,3)
      END IF

C--PRESERVE THE CORE LIMITS AT THIS POINT
      NFL1=NFL
      LFL1=LFL
C--SET UP THE PRINT ROUTINES
      CALL XFPRT1
C--CHECK FOR A MAP SCAN
      IF(ISCAN)1350,1550,1550
C--NO MAP SCAN  -  CHECK FOR A MAP PRINT
1350  CONTINUE
      IF ( IPRINT .GE. 0 ) GO TO 1550
C--NEITHER OF THE FIRST TWO  -  CHECK FOR A SUPERPOSITION
      IF ( IOUTAP )   9930 , 9930 , 1550
C
C--SEARCH THROUGH THE REFLECTIONS FOR THE 'HK' PAIRS AND SET UP THEIR TA
1550  CONTINUE
      CALL XFOURM
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--START OF THE CALCULATION FOR THE NEXT GROUP OF SECTIONS
1600  CONTINUE
      CALL XFOURN
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--PROCESS THE NEXT SECTION
1650  CONTINUE
      K=JT
C--ZERO THE PARTIAL SUM AREA
      CALL XZEROF(FSTORE(KV),KN)
C--ZERO THE MAP AREA
      J=L81+N8-1
      DO 1700 I=L81,J
      FSTORE(I)=F000
1700  CONTINUE
C--LOOP OVER THE 'HK' PAIRS
      DO 2000 I=JT,JU,JV
C--CHECK IF THIS STILL HAS THE SAME 'H' VALUE
      IF(JSTORE(I)-JSTORE(K))1850,1750,1850
C--FETCH THE ADDRESS OF THE FIRST K COSINE
1750  CONTINUE
      KL=JB*JSTORE(I+1)
      KM=KG*JSTORE(I+1)
      N=I+KI
      A=FSTORE(N)*SC
      B=FSTORE(N+1)*SC
      KW=KV
C--PASS OVER THE Y ROWS
      DO 1800 J=1,JH
C--CHECK IF WE OFF THE END OF THE K COSINE TABLE
      L=MOD(KL,JE)+JK
      M=L+JN
      STORE(KW)=STORE(KW)+A*STORE(L)+B*STORE(M)
      STORE(KW+1)=STORE(KW+1)+B*STORE(L)-A*STORE(M)
      KL=KL+KM
      KW=KW+2
1800  CONTINUE
      GOTO 2000
C--FETCH THE ADDRESS OF THE FIRST COSINE FOR X
1850  CONTINUE
      KL=JA*ISTORE(K)
      KM=KF*ISTORE(K)
      M8=L81
C--PASS ALONG EACH OF THE X ROWS IN TURN
      DO 1950 J=1,JG
      KW=KV
C--CHECK IF WE ARE OFF THE END OF X COSINE TABLE
      KD=MOD(KL,JD)+JJ
      KE=KD+JM
      KB=M8+KC
C--PASS ALONG THE Y ROW
      DO 1900 M=M8,KB,JX
      FSTORE(M)=FSTORE(M)+STORE(KW)*STORE(KD)+STORE(KW+1)*STORE(KE)
      KW=KW+KO
1900  CONTINUE
      KL=KL+KM
      M8=M8+MD8
1950  CONTINUE
      CALL XZEROF(STORE(KV),KN)
      K=I
C--CHECK FOR THE END OF TABLE
      IF(JSTORE(I))2000,1750,1750
2000  CONTINUE
C
C----- CHECK IF WE MUST NEGATE THE MAP
      IF (NGMAP .LE. -1) THEN
        M81 = L81 + NYNZ - 1
        DO 2020 I = L81, M81
            FSTORE(I) = -FSTORE(I)
2020    CONTINUE
      END IF

      IF ( IOUTAP .GT. 0 ) THEN
C--OUTPUT THIS SECTION TO M/T
          M81=L81+NYNZ-1
          WRITE(MT1)NYNZ,(FSTORE(I),I=L81,M81)
      ENDIF

      IF ( IOUFIL .EQ. 1 ) THEN
C--OUTPUT THIS SECTION TO ASCII FILE
          M81=L81+NYNZ-1
2051      FORMAT (A)
2052      FORMAT (I8)
2053      FORMAT (F15.8)
          WRITE(NCFPU1,2051) 'BLOCK'
          WRITE(NCFPU1,2052) NYNZ
          WRITE(NCFPU1,2053) (FSTORE(I),I=L81,M81)
      ENDIF

      IF ( IOUFIL .EQ. 2 ) THEN
C--OUTPUT THIS SECTION TO BINARY MAPVIEW FILE
          M81=L81+NYNZ-1
          DO I = L81,M81
            JPOINT = JPOINT + 1
            WRITE(NCFPU1,REC=JPOINT) FSTORE(I)
          END DO
      ENDIF

C--LOCATE THE MAXIMA IN THE MAP IF NECESSARY
2100  CONTINUE
      CALL XFOURO
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--PRINT THE MAP IF NECESSARY
      CALL XFPRT2
C--CHANGE THE SECTION POINTERS
      I=L83
      L83=L82
      L82=L81
      L81=I
C--INCREMENT THE CURRENT SCAN POINTER
      KI=KI+2
C--INCREMENT THE NUMBER OF SECTIONS COMPUTED POINTER
      KJ=KJ+1
      STORE(L14+12)=STORE(L14+12)+STORE(L14+13)
C--SEE IF THIS WAS THE LAST LAYER TO BE CALCULATED
      IF(NUM(3)-KJ)2200,2200,2150
C--CHECK IF THERE ARE MORE SECTIONS LEFT IN THIS SCAN
2150  IF(JZ+JW-KI)1600,1650,1650
C
2200  CONTINUE
C----- END OF THE FOURIER WORK 
C----- STORE HOLE IF DIFFERENCE MAP
cfeb03
      IF (NTYP .EQ. 3) THEN
       IF(DENMIN .LT. 100000) THEN
        M10 = L10+N10*MD10
        IF (STORE(M10-MD10) .GT. DENMIN) THEN
          IF (N10+1 .GT. N10MAX) THEN
            N10=N10-1
            M10 = M10-MD10
           ENDIF    
          STORE(M10)   = DENMIN
          STORE(M10+1) = FXMIN
          STORE(M10+2) = FYMIN
          STORE(M10+3) = FZMIN
          ISTORE(M10+4) = 4
          N10=N10+1
          CALL XSHELR(STORE(L10),MD10,1,N10,MD10*N10,STORE(NFL))
        ENDIF
       ENDIF
      ENDIF
cdjwmay09
c---- commented out - list 5 has been overwritten with list 29 info
      IF (IOUFIL .EQ. 1) THEN
3301  FORMAT(A)
3302  FORMAT(I8)
3303  FORMAT(F15.8)
        WRITE(NCFPU1,3301)'LIST5'
        WRITE(NCFPU1,3302)N5,MD5
        M5 = L5
        DO I = 1, N5
            WRITE(NCFPU1,3301) STORE(M5)
            DO J = M5+1,M5+MD5-1
                WRITE(NCFPU1,3303) STORE(J)
            END DO
            M5 = M5 + MD5
        END DO
        WRITE ( NCFPU1 , '(''END'')' )
      END IF
c
C--CHECK IF WE HAVE BEEN DOING OUTPUT
      IF( IOUTAP .GT. 0 ) THEN
          ENDFILE MT1
          REWIND MT1
      ENDIF
C
      IF( IOUFIL .EQ. 1 ) THEN
          CALL XMOVEI(KEYFIL(1,23), KDEV, 4)
          CALL XRDOPN(7, KDEV , CSSMAP, LSSMAP)
      ENDIF
C
      IF( IOUFIL .EQ. 2 ) THEN
C
          READ(NCFPU1,REC=1) JXTOT
          READ(NCFPU1,REC=2) JYTOT
          READ(NCFPU1,REC=3) JZTOT
          READ(NCFPU1,REC=4) XSTP
          READ(NCFPU1,REC=5) YSTP
          READ(NCFPU1,REC=6) ZSTP
          READ(NCFPU1,REC=13) XSTAR
          READ(NCFPU1,REC=14) YSTAR
          READ(NCFPU1,REC=15) ZSTAR
          XEND = XSTAR + XSTP * JXTOT
          YEND = YSTAR + YSTP * JYTOT
          ZEND = ZSTAR + ZSTP * JZTOT
          XAV = ( XSTAR + XEND ) / 2.0
          YAV = ( YSTAR + YEND ) / 2.0
          ZAV = ( ZSTAR + ZEND ) / 2.0


          WRITE(cmon,'(a,3F15.5)')'Steps: ',XSTP,YSTP,ZSTP
          call xprvdu(ncvdu,1,0)
          WRITE(cmon,'(a,3F15.5)')'Start: ',XSTAR,YSTAR,ZSTAR
          call xprvdu(ncvdu,1,0)

C Get some store:
          MDBOX = 4
          LBOX = NFL
          NBOX = 6
          I = KCHNFL(28)
C Centroid.
          STORE(LBOX) =   XAV
          STORE(LBOX+1) = YAV
          STORE(LBOX+2) = ZAV
          STORE(LBOX+3) = 0

C Six enclosing planes.
CX
          STORE(LBOX+4) =  -1
          STORE(LBOX+5) =  0
          STORE(LBOX+6) =  0
          STORE(LBOX+7) =  XAV

          STORE(LBOX+8)  = 1
          STORE(LBOX+9)  = 0
          STORE(LBOX+10) = 0
          STORE(LBOX+11) = XAV
CY
          STORE(LBOX+12) =  0
          STORE(LBOX+13) =  -1
          STORE(LBOX+14) =  0
          STORE(LBOX+15) =  YAV

          STORE(LBOX+16) =  0
          STORE(LBOX+17) =  1
          STORE(LBOX+18) =  0
          STORE(LBOX+19) =  YAV
CZ
          STORE(LBOX+20) =  0
          STORE(LBOX+21) =  0
          STORE(LBOX+22) =  -1
          STORE(LBOX+23) =  ZAV
  
          STORE(LBOX+24) =  0
          STORE(LBOX+25) =  0
          STORE(LBOX+26) =  1
          STORE(LBOX+27) =  ZAV

C------ SET UP SOME CONSTANTS
          CALL XDIST3

          BPD(4) = XSTAR
          BPD(5) = YSTAR
          BPD(6) = ZSTAR
          BPD(7) = XEND
          BPD(8) = YEND
          BPD(9) = ZEND

c          WRITE(CMON,'(A,9F7.3)') 'BPD1-9 ',(BPD(J),J=1,9)
c          CALL XPRVDU(NCVDU, 1,0)


          LSTK=NFL

          IF (NTYP .LT. IPMAP)  THEN   !List 5 is loaded:
            M5=L5
            JFNVC = 0
            TOLER = 0.0
            ITRANS = 0 !Allow translation
            NDIST = KDIST1( N5, MSTK, 12, JFNVC, TOLER, ITRANS, 0, 2, 0)
          ELSE
            NDIST = 0
          END IF

          WRITE(cmon,'(a,i7,A,I7)')'Last value should be: ', 
     1    19+JXTOT*JYTOT*JZTOT,' and it is: ',JPOINT
          call xprvdu(ncvdu,1,0)


          WRITE (NCFPU1,REC=JPOINT+1) NDIST
          JPOINT = JPOINT + 2


          DO K = LSTK, LSTK+(12*(NDIST-1)),12
            M5 = ISTORE(K)

            CALL CATSTR (STORE(M5),STORE(M5+1),1,1,0,0,0,CSERI,LSERI)
            WRITE ( NCFPU1,REC=JPOINT) CSERI(1:4)
            WRITE ( NCFPU1,REC=JPOINT+1) CSERI(5:8)
            JPOINT = JPOINT + 2

C Mapview assumes XY plane origin is 0,0, so offset.
            WRITE ( NCFPU1,REC=JPOINT)   STORE(K+7) ! - XSTAR
            WRITE ( NCFPU1,REC=JPOINT+1) STORE(K+8) ! - YSTAR
            WRITE ( NCFPU1,REC=JPOINT+2) STORE(K+9)

            WRITE(CMON,'(a,3F15.4)') cseri(1:LSERI),(STORE(K+J+7),J=0,2)
            CALL XPRVDU(NCVDU, 1,0)

            JPOINT = JPOINT + 3
          END DO


          WRITE (NCFPU1,REC=18) DENMIN
          WRITE (NCFPU1,REC=19) DENMAX
          CALL XMOVEI(KEYFIL(1,23), KDEV, 4)
          CALL XRDOPN(7, KDEV , CSSMAP, LSSMAP)
      ENDIF

C--CHECK IF THIS WAS A WEIGHTED FOURIER
      IF (NWT .EQ. 0) GOTO 2450
      IF (ABS(SSU - 1.) .GT. ZERO) THEN
      IF (ISSPRT .EQ. 0) WRITE(NCWU,2310) SSU
2310    FORMAT(
     1 ' Peak height multiplier tries to scale weighted map peaklist',
     2 /,' to unweighted map peak heights',
     2 /' Peak height multiplier is ',G15.5//)
      ENDIF
      IF (NWT) 2350, 2450, 2450
C--SIM or MAIN WEIGHTED FOURIER  -  PRINT SOME STATISTICS
2350  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2400)SSV,((HWMIN(I,J),I=1,6),J=1,2)
      ENDIF
2400  FORMAT(/' Sum of squares of light atom atomic numbers is ',
     2 G15.3,/,
     3 ' Minimum weight for reflection : ',3F4.0,2F9.2,E15.5//
     4 ' Maximum weight for reflection : ',3F4.0,2F9.2,E15.5)
      IF ( NWT .EQ. -2 ) THEN
        IF ( MAINWL .GT. 0 ) THEN
           WRITE(CMON,'(4X,I7,A)')MAINWL,
     1 ' weights set to 1: tiny scattering power in given direction.'
           CALL XPRVDU(NCVDU,1,0)
        END IF
        IF ( MAINWS .GT. 0 ) THEN
           WRITE(CMON,'(4X,I7,A)')MAINWS,
     1 ' weights set to -1: cause large negative Fo?'
           CALL XPRVDU(NCVDU,1,0)
        END IF
      END IF
C--FORM LIST 5 OR 10, WHICHEVER IS APPROPIATE
2450  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU, 2451) APEAKH
      WRITE ( CMON , 2451) APEAKH
      CALL XPRVDU(NCVDU, 1,0)
2451  FORMAT(1X, 'Minimum peak height for search is ', F8.2)
      CALL XRSL
      CALL XCSAE
      NFL=NFL1
      LFL=LFL1
      CALL XFOURP(LNOUT)
      IF ( IERFLG .LT. 0 ) GO TO 9900
      CALL XCSAE
      CALL XRSL
      AAA = AAA * SSU/SS
      DDD = DDD * SSU/SS
C----- RESTORE CORRECT SIGN
      DENMIN = FLOAT(NGMAP) * DENMIN * SSU / SS
      DENMAX = FLOAT(NGMAP) * DENMAX * SSU / SS
      IF (DENMIN .GT. DENMAX) THEN
C----- NEGATED MAP
            TMP = DENMIN
            DENMIN = DENMAX
            DENMAX = TMP
      ENDIF
      IF (IRADTP .LE. -1) THEN
            CRADTP = 'electrons '
      ELSE
            CRADTP = '    barns '
      ENDIF
      WRITE ( CMON ,2610) DENMIN,DENMAX, CRADTP,
     1 FXMIN,FYMIN,FZMIN
      CALL XPRVDU(NCVDU, 2,0)
2610  FORMAT(' The minimum and maximum',
     1' map densities are ',2G10.3,A,'/A^3',
     2 / 17X,' The deepest hole is at ', 3F8.3)
      IF (ISSPRT .EQ. 0) WRITE (NCWU,'(A)') CMON(1),CMON(2)
C----- STORE IN LIST30 IF DIFFERENCE MAP
      IF (NTYP .EQ. 3) THEN
C--DIFFERENCE MAP  -  PRINT THE AVERAGE ELECTRON DENSITY AT AN ATOMIC SI
        CALL XFAL30
CFEB03 - WAS STORED AT L30RF
        STORE(L30RF+5) = MIN (DENMIN, DENMAX)
        STORE(L30RF+6) = MAX (DENMIN, DENMAX)
        STORE(L30CF+15) = FXMIN
        STORE(L30CF+16) = FYMIN
        STORE(L30CF+17) = FZMIN
        CALL XWLSTD ( 30, ICOM30, IDIM30, -1, -1)
C--CHECK IF WE CAN PRINT THE MEAN ELECTION DENSITY
        IF (ISSPRT .EQ. 0) WRITE(NCWU,2550)AAA,DDD
        WRITE(CMON,2550)AAA,DDD
        CALL XPRVDU(NCVDU, 2,0)
2550  FORMAT(' Mean electron density at original atomic sites is' ,
     2  F9.2,/21X, ' with an R.M.S. deviation of ',F9.2)
      ENDIF
C--PRINT THE TERMINATION MESSAGE
2600  CONTINUE
      CALL XOPMSG ( IOPFOU , IOPEND , IVERSN )
      CALL XTIME2(2)
      RETURN
9900  CONTINUE
C -- ERRORS DETECTED
      CALL XOPMSG ( IOPFOU , IOPABN , 0 )
      GO TO 2600
9910  CONTINUE
C -- INPUT ERRORS
      CALL XOPMSG ( IOPFOU , IOPCMI , 0 )
      GO TO 9900
9920  CONTINUE
C -- ILLEGAL MAP TYPE
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 9925 )
      WRITE ( CMON , 9925 )
      CALL XPRVDU(NCVDU, 1,0)
9925  FORMAT ( 1X , ' Impossible Fourier type ' )
      CALL XERHND ( IERERR )
      GO TO 9900
9930  CONTINUE
C -- NO OPERATION
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 9935 )
      WRITE ( CMON , 9935 )
      CALL XPRVDU(NCVDU, 1,0)
9935  FORMAT ( 1X , 'Flags set for no map, no scan, ' ,
     1 'and no output tape' )
      CALL XERHND ( IERERR )
      GO TO 9900
9942  CONTINUE
      WRITE ( CMON , 9943 )
      CALL XPRVDU(NCVDU, 1,0)
9943  FORMAT ( 1X , ' No list of type 42 stored, run #MASK first. ' )
      CALL XERHND ( IERERR )
      GO TO 9900
      END
C
CODE FOR XFOURI
      SUBROUTINE XFOURI
C--THIS ROUTINE LOADS LIST 5 FROM DISC, IF ONE EXISTS AND IT
C  IS REQUIRED. LIST 5 IS STORED IN COMPRESSED FORM AT THE TOP
C  OF CORE SO THAT PEAK SEARCH DATA CAN INSERTED INTO IT.
C  IF A SIM-WEIGHTED FOURIER IS BEING CALCULATED, THIS ROUTINE ALSO
C  LOADS LISTS 3 AND 29 AND SETS UP THE NECESSARY SIM WEIGHTING CONSTANT
C
C  NWT   THE TYPE OF WEIGHTING TO BE USED :
C
C          -2  MAIN'S WEIGHTS
C          -1  SIM WEIGHTED.
C           0  NO WEIGHTS.
C           1  WEIGHTS TAKEN FROM LIST 6.
C
C--THE FORMAT OF LIST 5 SET UP HERE IS :
C
C  0  TYPE.
C  1  SERIAL.
C  2  X
C  3  Y
C  4  Z
C  5  INTERPOLATED HEIGHT FROM THE MAP.
C  6  SECTION IN THE MAP ON WHICH THIS ATOM APPEARS.
C
C--THESE COORDINATES ARE SWOPPED OVER BY 'XFOURI' LATER ON, AND THE
C  ENTRY IN WORD 6 IS CALCULATED AT THE SAME TIME.
C  THESE ORIGINAL ATOMIC SITES ARE CONTROLLED BY THE 'L10A' VARIABLES.
C
C--THE FORMAT OF TH PEAKS LIST ACCUMULATED DURING THE MAP SCAN IS AS FOL
C
C  0  HEIGHT.
C  1  X
C  2  Y
C  3  Z
C  4  THE METHOD OF FINDING THE PEAK HEIGHT :
C
C      1  LEAST SQUARES.
C      2  QUADRATIC INTERPOLATION.
C
C  THESE COORDINATES ARE SORTED WHEN THEY ARE STORED. THIS LIST OF PEAKS
C  CONTROLLED BY THE 'L10' VARIABLES.
C
C--
      INCLUDE 'FOURTP.INC'
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XFOURC.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLST02.INC'
      INCLUDE 'XLST03.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST23.INC'
      INCLUDE 'XLST29.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QFOURC.INC'
C
C----- SET DEFAULT SIM WEIGHTS
      SSV=1.0
      SSU = 1.0
C----- SET DEFAULT SCALE FACTOR
      SCALE=1.
C--CHECK IF THIS MAP REQUIRES /FC/'S AND THUS A LIST 5
      L10A=LFL+1
      N10A = 0
C
C
C
      IF (NTYP .LT. IPMAP)  GOTO 1050
C--PATTERSON OR E-MAP  -  SUPPRESS SIM or MAIN WEIGHTING
      IF ( NWT .LT. 0 ) NWT=1
C--THIS OPERATION IS UNWEIGHTED  -  CHECK IF LIST 5 IS OBLIGATORY
C--CHECK IF THERE IS A LIST 5 TO USE
      IF(KEXIST(5).LE.0) GOTO 1950
C--BRING DOWN LIST 5 TO FIND THE SCALE FACTOR
      CALL XFAL05
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--ASSIGN THE SCALE FACTOR FROM LIST 5
      SCALE=STORE(L5O)
      GOTO 1950
C
C
C
C--A MAP USING PHASES AND POSSIBLY /FC/'S
1050  CONTINUE
C----- 'OPTIMAL' MAP, SET WEIGHTING to SIM
      IF (NTYP .EQ. 5) NWT = -1

      IF( NWT .LT. 0) THEN
C----- LOAD 29, FOR SIM or MAIN WEIGHTING
         CALL XFAL29
         IF (IERFLG .LT. 0) GOTO 9900
C----- SHORTEN AND REORGANISE LIST 29 into 'Quick list 29' at LQ29, with
C      step MDQ29 (to avoid losing pointers to the original list 29).
         M5=L29
         N5=N29
         MD5=MD29
C--ALLOCATE SOME SPACE
         LN=29
         IREC=1001
         MDQ29=3
         LQ29=KCHLFL(MD29*N29)
         LFL = LQ29 - 1
C--MOVE THE DATA AROUND
         M29=LQ29
         DO I=1,N29
C--SECOND COPY OF THE ATOM TYPE
            CALL XMOVE(STORE(M5),STORE(M29),1)
            CALL XMOVE(STORE(M5),STORE(M29+1),1)
C----- AND RELOCATE THE CELL CONTENTS
            CALL XMOVE(STORE(M5+4),STORE(M29+2),1)
            M29=M29+MDQ29
            M5=M5+MD5
         END DO
      END IF
C
C--BRING DOWN LIST 5 TO FIND THE SCALE FACTOR
      CALL XFAL05
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--CHECK IF THERE ARE ANY ATOMS IN LIST 5
      IF(N5.GT.0)THEN
C--SET THE ATOMS UP AT THE TOP OF CORE IN A LIST 10
         LN=10
         IREC=1002
         N10A=N5
         MD10A=7
         L10A=KCHLFL(MD10A*N10A)
         M10A=L10A
C--SET THE POINTERS TO LOOP OVER ALL THE ATOMS
         M5=L5
         DO I=1,N5
C--MOVE THE TYPE AND SERIAL
            CALL XMOVE(STORE(M5),STORE(M10A),2)
C--MOVE THE COORDINATES
            CALL XMOVE(STORE(M5+4),STORE(M10A+2),3)
C--SET THE INITIAL PEAK HEIGHT TO ZERO
            STORE(M10A+5)=0.0
C--INITIALISE THE SECTION FLAG
            ISTORE(M10A+6)=-1
            M10A=M10A+MD10A
            M5=M5+MD5
         END DO
C----- LOAD DATA IF NOT ALREADY IN CORE
         IF (KHUNTR (1,0, IADDL,IADDR,IADDD, -1) .LT. 0) CALL XFAL01
         IF (KHUNTR (2,0, IADDL,IADDR,IADDD, -1) .LT. 0) CALL XFAL02
         IF (KHUNTR (5,0, IADDL,IADDR,IADDD, -1) .LT. 0) CALL XFAL05
         IF (KHUNTR (23,0, IADDL,IADDR,IADDD, -1) .LT. 0) CALL XFAL23
         IF (IERFLG .LT. 0) GOTO 9900
C----- SAVE THE TOLERANCE AND UPDATE VALUES
         STOLER = STORE(L23SP+5)
         IUPDAT = ISTORE(L23SP+1)
C----- SET THE OCCUPANCIES
         IF (IUPDAT .GE. 0) THEN
            I = KSPINI( -1, STOLER)
            NUPDAT = 0
C----- SAVE SOME WORK SPACE
            J =NFL
            I = KCHNFL(40)
            M5 = L5
            DO I = 1, N5
               IF (IUPDAT .GE. 0)
     1            IGSTAT =KSPGET ( STORE(J), STORE(J+10), ISTORE(J+20),
     2                            STORE(J+30), MGM, M5, IUPDAT, NUPDAT)
               M5 = M5 + MD5
            END DO
C----- RESTORE WORKSPACE
            NFL= J                            
         ENDIF
      END IF
C
C--ASSIGN THE SCALE FACTOR FROM LIST 5
      SCALE=STORE(L5O)
C
C--CHECK IF THIS IS A SIM WEIGHTED FOURIER
      IF( NWT .LT. 0 ) THEN
C--FIND THE ATOM TYPES IN LIST 5 AND ADJUST LIST 29 ACCORDINGLY
C -- CHECK THAT THERE ARE ATOMS IN LIST 5
         IF ( N5 .LE. 0 ) GO TO 9910
C--LOOP OVER EACH ATOM
         L5A=L5
         MD5A=MD5
         M5A=L5A
         DO I=1,N5
            J=KCOMP(1,STORE(M5A),STORE(LQ29+1),N29,MDQ29)
C--CHECK IF THIS ATOM IS IN LIST 29
            IF ( J .LE. 0 ) GO TO 9920
C--ADJUST THE CONTENTS OF LIST 29 TO ELIMINATE THIS ATOM
            J=LQ29+(J-1)*MDQ29
            STORE(J+2)=AMAX1(0.0,STORE(J+2)-STORE(M5A+2)* STORE(M5A+13))
            M5A=M5A+MD5A
         END DO
C----- CHECK IF ANY ATOMS TO BE FOUND
         M29=LQ29
         SSV=0.0
         DO I=1,N29
            SSV=SSV+STORE(M29+2)
            M29=M29+MDQ29
         END DO
         IF (SSV .LT. ZERO) GOTO 9930
         HWMIN(6,1)=10.
         HWMIN(6,2)=0.
         SSU=1./SCALE
      END IF

C--RESET THE CORE LIMITS TO REASONABLE VALUES
1950  CONTINUE
      CALL XRSL
      CALL XCSAE
      IF (NWT .LT. 0) THEN
C----- LOAD LIST 3 AND LINK IT TO QLIST 29 (PRETEND IT IS A LIST5 for KSET53)
         CALL XFAL03
         IF ( IERFLG .LT. 0) GOTO 9900
         N5 = N29
         M5 = LQ29
         L5 = LQ29
         MD5 = MDQ29
         J = 0
         I = KSET53(J)
         IF ( IERFLG .LT. 0) GOTO 9900
C--COMPUTE THE SIM WEIGHT MULTILPIER
         CALL XSCATT(0.0)
         SSV=0.
         M29=LQ29
C--FORM THE SUM OF THE SQUARES OF THE FORM FACTORS
         DO I=1,N29
            J=L3TR+ISTORE(M29)*MD3TR
            SSV = SSV + STORE(M29+2) * STORE(J) * STORE(J)
            M29=M29+MDQ29
         END DO
         IF ( SSV .LE. ZERO) SSV = 1.
      ENDIF
C----- SAVE LIST 29 AND L10 AT TOP OF STORE
      LFL=L10A-1
C----- AND NOW RETURN OK

9900  CONTINUE
      RETURN

C -- ERRORS
9910  CONTINUE
C -- NO ATOMS IN LIST 5 FOR SIM WEIGHTS
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 9915 )
      WRITE ( CMON , 9915 )
      CALL XPRVDU(NCVDU, 1,0)
9915  FORMAT(
     1 ' LIST 5 contains no atoms for SIM weighting.',
     2 ' Unit Weights used')
      SSV = 1.0
      GOTO 1950
9920  CONTINUE
C -- ATOM NOT IN LIST 29
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 9925 )
      WRITE ( CMON , 9925 )
      CALL XPRVDU(NCVDU, 1,0)
9925  FORMAT ( 1X , 'Atom in list 5 but not in list 29' )
      CALL XPRTCO ( 2 , M5A , I )
      CALL XERHND ( IERERR )
      GO TO 9900
C
9930  CONTINUE
C----- NO ATOMS LEFT IN LIST 29
      IF (ISSPRT .EQ. 0) WRITE(NCWU,9935)
      WRITE ( CMON ,9935)
      CALL XPRVDU(NCVDU, 3,0)
9935  FORMAT('  Sim weighting inapplicable.',/,
     1 1X, ' LIST 5 and LIST 29 contain the same number of atoms.',
     2 /,1X,' Unit Weights applied')
      SSV = 1.
      GOTO 1950
C
      END
CODE FOR XFOURJ
      SUBROUTINE XFOURJ(ITYP06)
C--THIS ROUTINE LOADS LISTS 1, 2, 6 AND 14 FROM DISC, SORTS
C  LIST 5 TO ALLOW FOR VARYING PROJECTIONS AND SETS UP LIST 10
C  FOR PEAKS LIST OUTPUT.
C
C--WHEN THE LISTS ARE LOADED THEY ARE SORTED TO ALLOW FOR THE DIFFERING
C  PROJECTS AND LIST 14 IS CHECKED TO SEE THAT IT IS VALID.
C  ALL THE VARIABLES DESCRIBING THE MAP ARE SET UP IN 'XWORKA', AND THE
C  VALUES IN LIST 14 ARE LEFT IN FRACTIONAL COORDINATES, EXCEPT FOR THE
C  NUMBER OF DIVISIONS ALONG EACH AXIS WHICH IS SIMPLY STORED IN
C  FLOATING POINT.
C
C--
      INCLUDE 'FOURTP.INC'
      INCLUDE 'ISTORE.INC'
C
C
      DIMENSION DISTS(4)
      DIMENSION KDEV(4)
C
      CHARACTER*24 CDIREC(3)
C
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XFOURC.INC'
      INCLUDE 'XDSTNC.INC'
      INCLUDE 'XPDS.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XLST02.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST06.INC'
      INCLUDE 'XLST14.INC'
      INCLUDE 'XLST42.INC'
      INCLUDE 'XTAPES.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
CRICjul99 - access store map file name
      INCLUDE 'TSSCHR.INC'
      INCLUDE 'XSSCHR.INC'
      INCLUDE 'UFILE.INC'

CRich3DFour99
C        REAL STEPS(3), START(3)
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QFOURC.INC'
C
C
      EQUIVALENCE (DISTS(1),AT)
C
C
C
      DATA CDIREC / ' Axis  down  the page : ' ,
     2  ' Axis across the page : ' , ' Sectioned through    : ' /
C
C--LOAD A FEW LISTS
      CALL XZEROF(DISTS(1),4)
      DISTS(2)=AMAX1(REJECT,2.*VALUE)
C----- LOAD LISTS 1 AND 2
      CALL XDIST2
      IF ( IERFLG .LT. 0 ) GO TO 9900
C----- SET UP SIM WEIGHTING FACTORS
      SSV=SSV*G2*FLOAT(N2)
      SSU=SSU*FLOAT(2-IC)/(SSV)
C--SET UP THE VOLUME OF THE CELL
      VOL=STORE(L1P1+6)
C----- SET THE NUMBER OF PEAKS, ASSUMING AN ATOMIC VOLUME OF AVOL
      AVOL = 15.0
      IF (NPEAK .LE. 0) NPEAK = NINT((VOL )/(AVOL))/ T2
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1050) NPEAK
      WRITE ( CMON ,1050) NPEAK
      CALL XPRVDU(NCVDU, 1,0)
1050  FORMAT(' Number of new peaks to be retained is : ', I6)
C----- ADD IN THE EXISTING ATOMS IF NOT A DIFFERENCE MAP
      IF (NTYP .NE. 3)   NPEAK = NPEAK + N10A
      M2I=L2I+MD2I*(N2I-1)
      CALL XFAL14
      IF ( IERFLG .LT. 0 ) GO TO 9900
C----- SWOP ADDRESSES IF PATTERSON BEING DONE
      IF (NTYP .GE. IPMAP .AND. NTYP .LT. IEMAP) THEN
        L14 = L14P
        N14 = N14P
        ND14 = MD14P
      ENDIF
C--UNPACK THE SORT DIRECTIVES
      IAXIS(1)=ISTORE(L14O)
      IAXIS(2)=ISTORE(L14O+1)
      IAXIS(3)=ISTORE(L14O+2)
C--CHECK THAT THE ORIENTATION PARAMETERS ARE VALID
      DO 1150 I=1,2
      DO 1100 J=I,2
      IF ( IAXIS(I) - IAXIS(J+1) ) 1100 , 9910 , 1100
1100  CONTINUE
1150  CONTINUE
C--INTERCHANGE THE LIST 14 DIRECTIVES
      CALL XFSWOP(STORE(L14),3*MD14,MD14,1,MD14)
C--KEEP ORIGINAL CELL PARAMS
      CALL XMOVE(STORE(L1P1),C1ORIG,6)
C--SORT THE CELL PARAMETERS
      CALL XFSWOP(STORE(L1P1),6,1,3,2)
C--SORT THE D/A CONTROL BLOCK
      CALL XFSWOP(BPD,3,1,3,1)
C--SORT THE COORDINATE DIRECTIONS
      CALL XSWOP(IAXIS,IX,3,1,1,IXYZ,3,1,1,1)
C--SET UP THE NUMBER OF HEADER WORDS PER 'HK' BLOCK
      JW=2
C--SET UP THE NUMBER OF Y POINTS TO BE CALCULATED AT A TIME
      JX=1
C
C--PROCESS THE FOURIER DIRECTIVES AND SET UP THE COSINE TABLES
      I=L1P1
      M14=L14
      LN=14
      IREC=1010
      DO 2200 J=1,3
C--CHECK IF WE ARE GOING POSITIVELY OR NEGATIVELY ALONG THIS AXIS
      K=1
      IF(STORE(M14)-STORE(M14+2)-0.0001)1250,1200,1200
C--NEGATIVE MOVEMENT
1200  CONTINUE
      K=-1
C--FETCH THE NUMBER OF DIVISIONS
1250  CONTINUE
      NUN(J)=NINT(STORE(M14+3))
C--CHECK IF THE NUMBER OF DIVISIONS HAS BEEN GIVEN
      IF(NUN(J))1300,1300,1600
C--THE NUMBER OF DIVISIONS MUST BE SET UP  -  CHECK THE INCREMENT
1300  CONTINUE
      IF(ABS(STORE(M14+1))-0.05)1350,1350,1400
C--NO INCREMENT HAS BEEN GIVEN  -  INSERT THE DEFAULT OF 0.3 ANGSTROM
1350  CONTINUE
      STORE(M14+1)=0.3
C--COMPUTE THE DIVISIONS ALONG THIS AXIS
1400  CONTINUE
      NUN(J)=IABS(NINT(STORE(I)/STORE(M14+1)))
C--MAKE SURE THAT THE NUMBER OF DIVISIONS IS A MULTIPLE OF 4
1450  CONTINUE
      IF(NUN(J)-NUN(J)/4*4)1500,1550,1500
C--NOT A MULTIPLE OF 4  -  DECREMENT
1500  CONTINUE
      NUN(J)=NUN(J)-1
      GOTO 1450
C--COMPUTE THE INTERVALS AND MAX. AND MIN. ALONG THE AXIS
1550  CONTINUE
      ISTEP(J)=K
      MINW(J)=NINT(FLOAT(NUN(J))*STORE(M14))-ISTEP(J)
      MAXW(J)=NINT(FLOAT(NUN(J))*STORE(M14+2))+ISTEP(J)
C--STORE THE INFORMATION IN LIST 14
      STORE(M14  )=FLOAT(MINW(J))
      STORE(M14+1)=FLOAT(ISTEP(J))
      STORE(M14+2)=FLOAT(MAXW(J))
      STORE(M14+3)=FLOAT(NUN(J))
      GOTO 1700
C--THE INTERVALS ALONG THE AXIS HAVE BEEN GIVEN
1600  CONTINUE
      MINW(J)=NINT(STORE(M14))
      ISTEP(J)=NINT(STORE(M14+1))
      MAXW(J)=NINT(STORE(M14+2))
C--CHECK THAT WE WILL MOVE ALONG THIS AXIS
      IF(ISTEP(J))1700,1650,1700
1650  CONTINUE
      ISTEP(J)=K
C--COMPUTE THE NUMBER OF INTERVALS AND CHECK IT
1700  CONTINUE
      NUM(J)=(MAXW(J)-MINW(J)+ISTEP(J)-K)/ISTEP(J)+1
      IF ( NUM(J) )  9920 , 9920 , 1850
C--CHECK IF THIS AXIS CAN SHARE A SIN/COS TABLE
1850  CONTINUE
      CALL XDVDR(STORE(M14),STORE(M14+3),STORE(M14),3)
      IF(J-1)2050,2050,1900
1900  CONTINUE
      DO 2000 K=2,J
      IF(NUN(J)-NUN(K-1))2000,1950,2000
C--THESE TWO CAN SHARE TABLES
1950  CONTINUE
      IAC(J)=IAC(K-1)
      IAS(J)=IAS(K-1)
      MXC(J)=MXC(K-1)
      GOTO 2150
2000  CONTINUE
C--SINE/COSINE TABLE FOR THIS AXIS  -  COMPUTE THE LENGTH OF THE ENTRY
2050  CONTINUE
      IAS(J)=NUN(J)+1
      L=IAS(J)
C--ADDRESS OF THE COSINE TABLE
      IAC(J)=NFL+IAS(J)
      MXC(J)=IAC(J)+NUN(J)
      IAS(J)=IAS(J)+IAS(J)
      KO=KCHNFL(IAS(J)+IAS(J))
C--SET UP THE SINES AND COSINES
      B=TWOPI/FLOAT(NUN(J))
      DO 2100 K=1,L
      M=K-1
      A=B*FLOAT(M)
C--SET UP THE COSINE PART
      N=IAC(J)+M
      STORE(N)=COS(A)
      M=IAC(J)-M
      STORE(M)=STORE(N)
C--SET UP THE SINE PART
      N=N+IAS(J)
      STORE(N)=SIN(A)
      M=M+IAS(J)
      STORE(M)=-STORE(N)
2100  CONTINUE
C--NEXT AXIAL DIRECTION
2150  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE (NCWU,2300)  CDIREC(J), IXYZ(J), MINW(J), ISTEP(J),
     2 MAXW(J),NUN(J)
      ENDIF
2300  FORMAT( / ( /A, A1, 3X, 'Running from ', I4, '  in steps of ', I3,
     2 5H  to ,I4,18H  in divisions of ,I4))
      I=I+1
      M14=M14+MD14
2200  CONTINUE
C--INTERCHANGE THE SYMMETRY OPERATORS FOR THE DIFFERENT AXIAL PROJECTION
      IF ( NWT .EQ. -2 ) THEN
C  Store the original ones if using List 42.
         L42I=NFL
         N42I=N2I
         MD42I=MD2I
         I=KCHNFL(N2I*MD2I)
         CALL XMOVE(STORE(L2I),STORE(L42I),N2I*MD2I)
      END IF
      M2=L2
      DO K=L2I,M2I,MD2I
         CALL XFSWOP(STORE(K),12,1,3,4)
         CALL XFSWOP(STORE(K),9,3,1,3)
C--NOW THE TRUE SYMMETRY OPERATORS, NOT THE INVERSE ONES
         CALL XFSWOP(STORE(M2),12,1,3,4)
         CALL XFSWOP(STORE(M2),9,3,1,3)
         M2=M2+MD2
      END DO
C--SORT THE NON-PRIMITIVE LATTICE OPERATORS
      CALL XFSWOP(STORE(L2P),MD2P*N2P,1,MD2P,N2P)
C--SET UP THE EQUIVALENT INDICES FLAGS
      KU=4
      KR=NFL
      I=KCHNFL(2*KU*N2I)
C--SET UP THE INCREMENT ALONG THE PARTIAL SUM FOR Y
      KO=JX+JX
C
C--CHECK IF A SCAN IS POSSIBLE  -  SET UP THE LIMITS FOR A BOX SEARCH
      M14=L14
      N=1000000
      DO 2450 I=1,3
C--CHECK IF WE HAVE ENOUGH POINTS TO INTERPOLATE WITH ALONG THIS AXIS
      IF(NUM(I)-3)2350,2400,2400
C--NOT ENOUGH POINTS ALONG THIS AXIS
2350  CONTINUE
      ISCAN=-1
      N=-1
C--THERE ARE ENOUGH  -  MOVE THE LIMITS ACROSS
2400  CONTINUE
      BPD(I+3)=AMIN1(STORE(M14),STORE(M14+2))
      BPD(I+6)=AMAX1(STORE(M14),STORE(M14+2))
      M14=M14+MD14
2450  CONTINUE
C--SET THE ADDRESS OF THE MISSING ATOMS
      M=NFL
C--CHECK IF THERE ARE ANY ATOM IN LIST 5
      IF(N10A)2850,2850,2500
C--INDICATE A BOX SEARCH
2500  CONTINUE
      IDIST=0
C--SET THE POINTERS TO LIST 5
      L5=L10A
      M5=L5-2
      M5A=M5
      MD5=MD10A
      N5=N10A
C--LOOP OVER EACH ATOM IN TURN, PLACING IT IN THE REQUIRED VOLUME
      DO 2700 I=1,N5
C--SWOP THE COORDINATES OF THE CURRENT ATOM
      CALL XFSWOP(STORE(M5+4),3,1,1,1)
C--MOVE THE ATOM AROUND
C
      J = KDIST1(1, K, 10, 0, .2, 0, 0, 4, 0)
C
      M5=M5-MD5
      IF(J)2650,2550,2600
C--ATOM IS NOT IN THE CURRENT UNIT CELL VOLUME
2550  CONTINUE
      LN=5
      IREC=1002
      CALL XMOVE(STORE(M5+2),STORE(NFL),2)
      J=KCHNFL(2)
      GOTO 2650
C--MOVE THE TRANSPOSED COORDINATES OVER
2600  CONTINUE
      CALL XMOVE(STORE(NFL+7),STORE(M5+4),3)
C--COMPUTE THE SECTION ON WHICH THIS ATOM OCCURS
      ISTORE(M5+8)=MIN0(N,MIN0(NUM(3)-2,MAX0(1,NINT((STORE(M5+6)
     2 -STORE(L14+12))/STORE(L14+13)))))+1
C--UPDATE FOR THE NEXT ATOM
2650  CONTINUE
      M5=M5+MD5
2700  CONTINUE
C--CHECK IF WE HAVE OMITTED ANY ATOMS
      IF(M-NFL)2750,2850,2850
C--PRINT THE OMITTED ATOMS
2750  CONTINUE
      NFL=NFL-1
      IF (ISSPRT .EQ. 0) WRITE(NCWU,2800)(STORE(I),I=M,NFL)
2800  FORMAT(//9(' *** Warning'),' *** '//' The following atoms',
     2 ' do not fit in the',
     3 ' volume of the cell to be calculated :' //(5(3X,A4,F8.0,7X)))
      WRITE ( CMON ,2801)(STORE(I),I=M,NFL)
      CALL XPRVDU(NCVDU, 2,0)
2801  FORMAT(' *** Warning ***  Some atoms ',
     2 'do not fit in the',/
     3 ' volume of the cell to be calculated :' /(6(1X,A4,F6.0,2X)))
      CALL XERHND ( IERWRN )
C
C--SET THE NUMBER OF PEAKS FOUND AS ZERO
2850  CONTINUE
      NFL=M
      MD10=0
      N10=0
C--COMPUTE THE INCREMENT ALONG EACH Y ROW
      MD8=(JH+JX-1)/JX*JX
C--NOW CHECK IF WE ARE DOING A PEAK SCAN
      IF(ISCAN)3100,2900,2900
C--SET UP THE MAP REGION FLAGS FOR THE SCAN
2900  CONTINUE
      NY=MD8
      NZ=NUM(1)
      NYNZ=NY*NZ
      NY2=NY+NY
      NYM2=NY-2
      NYNZM2=NYNZ-NY2
C--SET UP THE FLAGS FOR THE PEAK STORAGE
      MD10=5
C--COMPUTE THE MAXIMUM NUMBER OF PEAKS THAT WE CAN HOLD
      N10MAX=(3*NPEAK+1)/2
C--SET UP THE CORE AREA
      L10=KCHLFL(MD10*(N10MAX+1))
C--CHECK IF THIS IS A PATTERSON
      IF( (NTYP .GE. IPMAP) .AND. (NTYP .LT. IEMAP)) THEN
C--THIS IS A PATTERSON  -  MAKE THE STRUCTURE CENTRO
      IC=1
      M2=L2
      DO 3050 I=1,N2
      CALL XZEROF(STORE(M2+9),3)
      M2=M2+MD2
3050  CONTINUE
      END IF
C
C--ADJUST THE PEAK SCAN CONSTANTS AS NECESSARY
3100  CONTINUE
      IF(ISCAN)3400,3150,3150
C--PEAK SCAN IS INDICATED  -  CHECK IF THE HEIGHT HAS BEEN GIVEN
3150  CONTINUE
      IF(HEIGHT-ZERO)3200,3200,3350
C--NO HEIGHT HAS BEEN GIVEN  -  CHECK THE FOURIER TYPE
3200  CONTINUE
      IF (NTYP .GE. IPMAP) GOTO 3300
C--/FO/, /FC/ OR DIFFERENCE FOURIER  -  DEFAULT TO '1.5*SCALE'
      HEIGHT=1.5
      GOTO 3400
C--PATTERSON OR E-MAP
3300  CONTINUE
      HEIGHT=50.
C--INDICATE THAT THE SCALE FACTOR IS NOT NEEDED
3350  CONTINUE
      ISCAN=1
C--CHECK IF AUTOMATIC SCALING IS REQUIRED
3400  CONTINUE
      IF(ISC)3550,3450,3550
C--AUTOMATIC SCALING  -  CHECK THE TYPE
3450  CONTINUE
cdjwmar2010      IF (NTYP .NE. IPMAP) GOTO 3550
catch all the funny pattersons
      IF (NTYP .lt. IPMAP) GOTO 3550
      IF (NTYP .ge. 10) GOTO 3550
C--COMPUTE THE SCALE FACTOR
      ISC=1
C
C--SET UP LIST 6  -  CHECK THE FOURIER TYPE
3550  CONTINUE
      IF (NTYP .EQ. IEMAP) GOTO 3650
C--USING NORMAL REFLECTIONS
      IULN = KTYP06(ITYP06)
      CALL XFAL06(IULN,0)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--RECORD THE REFLECTION DETAILS
      L6DUMP=L6R
      N6DUMP=N6R
      GOTO 3700
C--E-MAP  -  SET THE REFLECTION TRANSFER
3650  CONTINUE
      MD6=6
      CALL XIMTR(MD6)
C--ALLOCATE A SPACE
      LN=6
      IREC=2001
      M6=KCHLFL(MD6)
C--ZERO THE DUMP VARIABLES
      L6DUMP=NOWT
      N6DUMP=0
C--POSITION FOR THE E-MAP REQUIRED
      CALL ESKIP(NE)
C--SET THE NUMBER OF REFLECTIONS READ
3700  CONTINUE
      NORFL=0
C--CHECK IF WE REQUIRE AN OUTPUT TAPE
C NB The original logic here said IF(IOUTAP)3800,3750,3750
C which is .GE. 0 rather than .GT. 0. I have changed it to
C prevent the FOURIER from writing to an unopen file.
      IF ( IOUTAP .GT. 0 ) THEN

CDJW99[
C THE MAP IS GENERATED LINE BY LINE IN EACH SECTION. ONCE ALL THE
C LINES HAVE BEEN GENERATED, THE WHOLE SECTION IS WRITTEN TO THE
C OUTPUT FILE.
C
C THE SECTION CAN BE IMAGINED AS A PAGE OF PAPER. THE COLUMNS IN
C EACH LINE GO ACROSS THE PAGE, AND THE LINER ARE WRITTEN ONE AFTER
C ANOTHER DOWN THE PAGE.
C
C THE RELATIONSHIP BETWEEN THE PAGE 'AXES' (ACROSS, DOWN, SECTION)
C AND THE CRYSTALLOGRAPHIC AXES (X,Y,Z) IS STORED IN THE MATRIX
C STORE(NFL) TO STORE(NFL+8).
C
C   WRITE (MT1) 'INFO  DOWN, ACROSS AND SECTION '
C   WRITE (MT1) 'TRAN', (STORE(I), I=NFL,NFL+8)
C
C THE UNIT CELL PARAMETERS, A,B,C, ALPHA, BETAA, GAMMA (RADIANS)
C
C   WRITE (MT1) 'CELL', (STORE(I), I = L1P1, L1P1+5)
C
C THE 'LIST 14' ITEMS, THREE ROWS OF FOUR VALUES. THE ROWS
C CORRESPOND TO X,Y,Z
C THE COLUMNS ARE:
C START, STEP, FINISH, DIVISION
C
C   WRITE (MT1) 'L14 ', ((STORE(J), J=I,I+3),
C  1                        I=L14,2*MD14+L14, MD14)
C
C SIZE ARE THE NUMBER OF LINES , NUMBER OF COLUMNS, NUMBER OF
C SECTIONS
C   WRITE (MT1) 'SIZE', NUM
C
C--OUTPUT THIS SECTION TO M/T
C THERE ARE NXNY POINTS IN THE SECTION, WHICH ARE WRITTEN AS A
C CONTINUOUS RECORD
C   M81=L81+NYNZ-1
C   WRITE(MT1)NYNZ,(FSTORE(I),I=L81,M81)
C
C EACH SECTION IS OUTPUT IN THE SAME FORMAT
CDJW99]

C AN OUTPUT TAPE IS REQUIRED
          REWIND MT1

C SET UP TRANSFORMATION MATRIX  (BRIEFLY)
          CALL XZEROF (STORE(NFL), 12)
          STORE(NFL-1+IAXIS(1)) = 1.0
          STORE(NFL+2+IAXIS(2)) = 1.0
          STORE(NFL+5+IAXIS(3)) = 1.0
          IF (XDETR3 (STORE(NFL)) .LE. 0) STORE(NFL+5+IAXIS(3)) = -1.0

C WRITE THE M/T HEADER  DETAILS
          WRITE (MT1) 'INFO  DOWN, ACROSS AND SECTION '
          WRITE (MT1) 'TRAN', (STORE(I), I=NFL,NFL+8)
          WRITE (MT1) 'CELL', (STORE(I), I = L1P1, L1P1+5)
          WRITE (MT1) 'L14 ', ((STORE(J), J=I,I+3),
     1                        I=L14,2*MD14+L14, MD14)
          WRITE (MT1) 'SIZE', NUM
      ENDIF

      IF ( IOUFIL .EQ. 1 ) THEN

C AN OUTPUT FILE IS REQUIRED
          CALL XMOVEI(KEYFIL(1,23), KDEV, 4)
          CALL XRDOPN(6, KDEV , CSSMAP, LSSMAP)

C SET UP TRANSFORMATION MATRIX  (BRIEFLY)
          CALL XZEROF (STORE(NFL), 12)
          STORE(NFL-1+IAXIS(1)) = 1.0
          STORE(NFL+2+IAXIS(2)) = 1.0
          STORE(NFL+5+IAXIS(3)) = 1.0
          IF (XDETR3 (STORE(NFL)) .LE. 0) STORE(NFL+5+IAXIS(3)) = -1.0
cdjwmay09
      write(ncwu,'(3f10.3)') (store(i),i=l1o1,l1o1+8)
      write(ncwu,'(3i10)')  (istore(i),i=l14o,l14o+2)
      call xmove(store(l1o1  +3*(iaxis(1)-1)), store(nfl  ),3)
      call xmove(store(l1o1  +3*(iaxis(2)-1)), store(nfl+3),3)
      call xmove(store(l1o1  +3*(iaxis(3)-1)), store(nfl+6),3)
C WRITE THE M/T HEADER  DETAILS
3751      FORMAT(A)
3752      FORMAT(F15.8)
3753      FORMAT(I8)
          WRITE (NCFPU1,3751) 'INFO  DOWN, ACROSS AND SECTION '
          WRITE (NCFPU1,3751) 'TRAN'
          WRITE (NCFPU1,3752) (STORE(I), I=NFL,NFL+8),0.0,0.0,0.0
          WRITE (NCFPU1,3751) 'CELL'
          WRITE (NCFPU1,3752) (C1ORIG(I), I = 1, 6)
          WRITE (NCFPU1,3751) 'L14 '
c          WRITE (NCFPU1,3752) ((STORE(J),J=I,I+3),I=L14,2*MD14+L14,MD14)
            m14=l14
            do k=1,3
             write(ncfpu1,3752) (store(l1p1+iaxis(k)-1)*store(m14+j)
     1       ,j = 0,3)
             m14 = m14+md14
            end do
          WRITE (NCFPU1,3751) 'SIZE'
          WRITE (NCFPU1,3753) (NUM(I),I=1,3)

      ENDIF
      IF ( IOUFIL .EQ. 2 ) THEN

C AN OUTPUT FILE IS REQUIRED
          CALL XMOVEI(KEYFIL(1,23), KDEV, 4)
          CALL XRDOPN(7, KDEV , CSSMAP, LSSMAP)
          OPEN ( UNIT   = NCFPU1,
     1         FILE = CSSMAP(1:LSSMAP),
     1         STATUS = 'UNKNOWN' ,
     1         ACCESS = 'DIRECT' ,
     1         FORM   = 'UNFORMATTED' ,
     1         RECL   = 1 ,
     1         IOSTAT = IOS ,
     1         ERR    = 9905 )


C SET UP TRANSFORMATION MATRIX  (BRIEFLY)
          CALL XZEROF (STORE(NFL), 12)
          STORE(NFL-1+IAXIS(1)) = 1.0
          STORE(NFL+2+IAXIS(2)) = 1.0
          STORE(NFL+5+IAXIS(3)) = 1.0
          IF (XDETR3 (STORE(NFL)) .LE. 0) STORE(NFL+5+IAXIS(3)) = -1.0

C WRITE THE MAPVIEW HEADER DETAILS
C NX,NY,NZ
          DO I = 1,3
            WRITE (NCFPU1,REC=I) NUM(I)
          END DO
C STEPX,STEPY,STEPZ
          WRITE (NCFPU1,REC=4) STORE(L14+1)
          WRITE (NCFPU1,REC=5) STORE(L14+MD14+1)
          WRITE (NCFPU1,REC=6) STORE(L14+MD14*2+1)
C TRANSFORMED CELL
          DO I = 0,2
            WRITE (NCFPU1,REC=I+7) STORE(L1P1+I)
          END DO
          DO I = 3,5
            WRITE (NCFPU1,REC=I+7) STORE(L1P1+I) * RTD
          END DO

          WRITE(cmon,'(a,3F15.5)')'Cell: ',(STORE(L1P1+I),I=0,2)
          call xprvdu(ncvdu,1,0)
          WRITE(cmon,'(a,3F15.5)')'      ',(STORE(L1P1+I)*RTD,I=3,5)
          call xprvdu(ncvdu,1,0)

C STARTX,Y,Z
          WRITE (NCFPU1,REC=13) STORE(L14)
          WRITE (NCFPU1,REC=14) STORE(L14+MD14) 
          WRITE (NCFPU1,REC=15) STORE(L14+MD14*2)
C Projection axis 1=A*,2=B*,3=C* (always C* as axes are permed to acheive this)
          WRITE (NCFPU1,REC=16) 3
C Mode 1=3D, 2=Slant
          WRITE (NCFPU1,REC=17) 1
C Min max values
          WRITE (NCFPU1,REC=18) -100.0
          WRITE (NCFPU1,REC=19) 100.0
      ENDIF

      RETURN

9900  CONTINUE
C -- ERRORS
      GO TO 3700
9905  CONTINUE
C -- FILE OPEN ERROR
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 9908 ),IOS
      WRITE ( CMON , 9915 ) ,IOS
      CALL XPRVDU(NCVDU, 1,0)
9908  FORMAT ( 1X , 'Failed to open direct access mapview file ', I4 )
      CALL XERHND ( IERERR )
      GO TO 9900
9910  CONTINUE
C -- INVALID ORIENTATION PARAMETER
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 9915 ) IAXIS
      WRITE ( CMON , 9915 ) IAXIS
      CALL XPRVDU(NCVDU, 1,0)
9915  FORMAT ( 1X , 'Illegal orientation parameters ' , 3I4 )
      CALL XERHND ( IERERR )
      GO TO 9900
9920  CONTINUE
C -- ILLEGAL NUMBER OF POINTS
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 9925 ) IXYZ(J) , NUM(J)
      WRITE ( CMON , 9925 ) IXYZ(J) , NUM(J)
      CALL XPRVDU(NCVDU, 1,0)
9925  FORMAT ( 1X , 'Number of points along ' , A1 , ' is ' , I8 ,
     1 ' which is illegal' )
      CALL XERHND ( IERERR )
      GO TO 9900
      END
C
CODE FOR XFOURM
      SUBROUTINE XFOURM
C--SET THE 'HK' PAIRS TABLE, AND THE MAP AREA
C
C--
      INCLUDE 'FOURTP.INC'
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XFOURC.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLST02.INC'

Ctemp
      INCLUDE 'XLST03.INC'

      INCLUDE 'XLST06.INC'
      INCLUDE 'XLST14.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QFOURC.INC'

      ININFL = NFL

C
C--START OF THE INITIAL SEARCH TO SET UP THE 'HK' PAIR FLAGS
      KA=LFL
      JY=1
      JZ=0   ! Max value of H
C--SET THE LIST AND RECORD TYPE
      LN=8
      IREC=1001
C--SCAN COUNTER TO ONE
      NV=1
C--SET THE NUMBER OF REFLECTIONS USED TO ZERO
      NORFL=0
C--SET UP THE POINTER TO THE START OF THE 'K' CHAIN
      I=LFL
      ISTORE(I)=NOWT
      K=KCHLFL(1)
C--FETCH THE NEXT REFLECTION
1000  CONTINUE
      DO WHILE ( KFOURC(I) .GE. 0 )
C--COMPUTE THE EQUIVALENT SETS OF INDICES
        DO 1550 N=L2I,M2I,MD2I
C--COMPUTE THE NEW H
          M=NINT(STORE(M6)*STORE(N)+STORE(M6+1)*STORE(N+3)
     2                             +STORE(M6+2)*STORE(N+6))
C--COMPUTE THE NEW K
          L=NINT(STORE(M6)*STORE(N+1)+STORE(M6+1)*STORE(N+4)
     2                               +STORE(M6+2)*STORE(N+7))
C--CHECK THE SIGN OF H
          IF(M)1100,1150,1150
C--H IS NEGATIVE  -  REVERSE THE SIGNS OF BOTH INDICES
1100  CONTINUE
          M=-M
          L=-L
C--COMPUTE THE MAXIMUM VALUE OF H
1150  CONTINUE
          JZ=MAX0(JZ,M)
C--START THE SEARCH THROUGH THE H CHAIN
          J=I
C--MOVE ONTO THE NEXT H VALUE
1200      CONTINUE
          K=J
          J=ISTORE(K)
C--CHECK FOR THE END OF THE CHAIN
          IF(J)1300,1300,1250
C--CHECK THE CURRENT VALUE OF H AGAINST THE VALUE IN THE CHAIN
1250      CONTINUE
          IF(ISTORE(J-1)-M)1200,1350,1300
C--INSERT THIS VALUE OF H IN THE CHAIN
1300      CONTINUE
          ISTORE(K)=LFL
          ISTORE(LFL)=J
          J=LFL
          K=KCHLFL(5)
C--SET UP THE REMAINDER OF THE HEADER
          ISTORE(J-1)=M
          ISTORE(J-2)=NOWT
          ISTORE(J-3)=NOWT
          ISTORE(J-4)=1000000
C--ALTER THE FLAGS TO CHECK FOR THIS VALUE OF K WITH THE CURRENT H
1350      CONTINUE
          M=J
          J=J-2
C--MOVE TO THE NEXT K VALUE IN THE CHAIN
1400      CONTINUE
          K=J
          J=ISTORE(K)
C--CHECK FOR THE END OF THE K CHAIN
          IF(J)1500,1500,1450
C--CHECK FOR THE VALUE OF INTEREST
1450      CONTINUE
          IF(ISTORE(J-1)-L)1400,1550,1500
C--INSERT THIS VALUE OF K IN THE CHAIN
1500      CONTINUE
          JY=JY+1
          ISTORE(K)=LFL
          ISTORE(LFL)=J
C--SET THE REST OF THE HEADER
          ISTORE(LFL-1)=L
          K=KCHLFL(2)
C--SET UP THE MAXIMUM VALUE OF K FOUND FOR THIS VALUE OF H
          ISTORE(M-3)=MAX0(ISTORE(M-3),L)
C--SET UP THE MINIMUM VALUE OF K FOUND FOR THIS VALUE OF H
          ISTORE(M-4)=MIN0(ISTORE(M-4),L)
1550    CONTINUE
      END DO
C
C--START OF THE LOOP THAT UNRAVELS THE H STACK AND SETS UP ITS TABLE
1600  CONTINUE
      J=I
      JS=NFL
C--ALLOCATE THE STORAGE AREA FOR THE H LOOK UP TABLE
      IREC=1002
      K=KCHNFL(JZ+1)
      M=-1
      N=JS
      IREC=1003
C--FETCH THE NEXT LINK IN THE H CHAIN
1650  CONTINUE
      J=ISTORE(J)
C--CHECK FOR THE END OF THE CHAIN
      IF(J)1900,1900,1700
C--CHECK IF THIS IS THE NEXT H VALUE WE REQUIRE
1700  CONTINUE
      M=M+1
      IF(ISTORE(J-1)-M)1850,1750,1800
C--THIS IS THE NEXT H VALUE THAT WE REQUIRE
1750  CONTINUE
      ISTORE(N)=NFL-ISTORE(J-4)
      K=KCHNFL(ISTORE(J-3)-ISTORE(J-4)+1)
      N=N+1
      GOTO 1650
C--THIS IS NOT AN H VALUE FOR WHICH THERE IS AN ENTRY IN THE CHAIN
1800  CONTINUE
      ISTORE(N)=NOWT
      N=N+1
      GOTO 1700
C--ERROR BECAUSE THE H CHAIN IS OUT OF STEP
1850  CONTINUE
      STOP 160
C
C--RESET 'LFL' AND ALLOCATE THE MAP STORAGE AREA
1900  CONTINUE
      KB=LFL
      LFL=KA
C--COMPUTE THE SIZE NEEDED FOR EACH FOURIER SECTION
      N8=MD8*JG
      K=0
      J=1
C--CHECK FOR A MAP SCAN
      IF(ISCAN)2000,1950,1950
C--THERE IS TO BE A MAP SCAN
1950  CONTINUE
      K=1
      J=3
C--ALLOCATE MAP SPACE
2000  CONTINUE
      LN=8
      IREC=101
      L8=KCHLFL(N8*J)
C--SET THE FLAGS TO THE VARIOUS MAP SECTIONS
      L81=L8
      L82=L81+N8*K
      L83=L82+N8*K
      KC=MD8-JX
C--NOW SET 'LFL' SO THAT IT IS THE MINIMUM OF ITSELF AND 'KB'
      LFL=MIN0(LFL,KB)
C--SET UP THE Y PARTIAL SUM AREA
      KN=MD8+MD8
      IREC=1004
      KV=KCHLFL(KN)
C--COMPUTE THE NUMBER OF Z LAYERS WE CAN GET IN CORE AT ONE TIME
      JZ=MIN0((LFL-NFL-MD10-JY*JW)/(JY*2),JI)
      MDM=LFL-NFL
C--CHECK THAT WE CAN GET AT LEAST ONE LAYER IN CORE
      IF ( JZ  )  9910 , 9910 , 2200
C--SET UP THE ENTRIES FOR EACH 'HK' PAIR
2200  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2250)JZ
      ENDIF
2250  FORMAT(//34H Number of section(s) per scan is ,I3)
      JZ=JZ+JZ
      JT=NFL
      JV=JW+JZ
      JU=JT+(JY-1)*JV
      IREC=1005
C--FETCH THE NEXT LINK ON THE H CHAIN
2300  CONTINUE
      I=ISTORE(I)
C--CHECK FOR THE END OF THE H CHAIN
      IF(I)2500,2500,2350
C--START PROCESSING THE K CHAIN  -  FIND THE ADDRESS OF THE K TABLE
2350  CONTINUE
      J=ISTORE(I-1)+JS
      J=ISTORE(J)
      K=I-2
C--FETCH THE NEXT LINK IN THE  K CHAIN
2400  CONTINUE
      K=ISTORE(K)
C--CHECK FOR THE END OF THE CHAIN
      IF(K)2300,2300,2450
C--SET THE ENTRY FOR THIS VALUE OF K
2450  CONTINUE
      L=ISTORE(K-1)+J
C--SET THE ADDRESS IN THE K TABLE
      ISTORE(L)=NFL
C--STORE THE 'H' VALUE
      JSTORE(NFL)=ISTORE(I-1)
C--STORE THE 'K' VALUE
      JSTORE(NFL+1)=ISTORE(K-1)
      L=KCHNFL(JV)
      GOTO 2400
C
C--SET UP A DUMMY LAST ENTRY
2500  CONTINUE
      JSTORE(NFL)=NOWT
      JSTORE(NFL+1)=NOWT
C--ALLOCATE SPACE FOR THE FINAL ENTRY
      L=KCHNFL(JV)
      JZ=JZ-1
      KJ=0
      RETURN
9900  CONTINUE
C -- ERRORS
      RETURN
9910  CONTINUE
C -- NOT ENOUGH SPACE
      N = ( JW + 2 ) * JY + NFL - LFL + 1
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 9915 )
      WRITE ( CMON , 9915 )
      CALL XPRVDU(NCVDU, 1,0)
9915  FORMAT(1X, ' Insufficient memory for 1 layer')
      CALL XOPMSG ( IOPFOU , IOPSPC , N )
      GO TO 9900
C
      END
C
CODE FOR XFOURN
      SUBROUTINE XFOURN
C--SCAN THE REFLECTIONS TO SET UP THE 'KH' TABLE FOR THE NEXT SECTIONS
C
C--
      DOUBLE PRECISION B, BS0, BS1
      INCLUDE 'FOURTP.INC'
      INCLUDE 'ISTORE.INC'
C
C
      DIMENSION RFL(3), HKL42(3)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XFOURC.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XLST02.INC'
      INCLUDE 'XLST03.INC'
      INCLUDE 'XLST06.INC'
      INCLUDE 'XLST14.INC'
      INCLUDE 'XLST29.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QFOURC.INC'
C
C
      EQUIVALENCE (IX,IAXIS(1)),(IY,IAXIS(2)),(IZ,IAXIS(3))
C
C     I1/I0 BESSEL FUNCTION RATIO FROM MULTAN
C ONLY USED IF STATEMENT AROUND LABEL 1600 IS UNCOMMENTED
C      VEC(U) = U*(U + 0.4807)/((U + 0.8636)*U + 1.3943)
C
C----- INITIALISE SUM WEIGHTED FO AND FO
      SSU = 0.0
      SST = 0.0
C----- SYMMETRY DEPENDANT MULTIPLICITY
      SSC = G2 * FLOAT(N2)                    ! Correct
c       SSC = (G2 * FLOAT(N2) ) / FLOAT(2-IC)    ! Now wrong


      IF ( NWT .LT. 0 ) THEN
        MAINWL = 0
        MAINWS = 0
        DO I=0,N29-1
          WRITE(CMON,'(A,F8.2,2A)')'Missing ',STORE(LQ29+MDQ29*I+2),
     1    'atoms of type ', ISTORE(L3+MD3*I)
          CALL XPRVDU(NCVDU,1,0)
        END DO
      END IF


C--ZERO THE ACCUMULATION AREA FOR THE HK PAIRS
      W=0.
      DO I=JT,JU,JV
        K=I+JW
        L=K+JZ
        DO M=K,L
          FSTORE(M)=0.
        END DO
      END DO
      NORFL=0
      KB=KJ*KH+JC
C--SET UP THE ENTRIES IN THE 'HK' STACK FOR THE NEXT FEW LAYERS
1100  CONTINUE
      I = 0
      IF(KFOURC(I))3050,1150,1150
C--GENERATE THE EQUIVALENT REFLECTIONS FOR THESE INDICES
1150  CONTINUE
      KS=KR
      A=0.
      DO I=L2I,M2I,MD2I
C--CALCULATE THE NEW INDICES
        RFL(1)=STORE(M6)*STORE(I)+STORE(M6+1)*STORE(I+3)+STORE(M6+2)
     2         *STORE(I+6)
        RFL(2)=STORE(M6)*STORE(I+1)+STORE(M6+1)*STORE(I+4)+STORE(M6+2)
     2         *STORE(I+7)
        RFL(3)=STORE(M6)*STORE(I+2)+STORE(M6+1)*STORE(I+5)+STORE(M6+2)
     2         *STORE(I+8)
        J=KS
        K=KS+KU
C--FIX AND STORE THIS SET OF EQUIVALENT INDICES
        DO L=1,3
          ISTORE(J)=NINT(RFL(L))
          ISTORE(K)=-ISTORE(J)
          J=J+1
          K=K+1
        END DO
C--COMPUTE THE PHASE SHIFT FOR THIS SET OF EQUIV. INDICES
        STORE(KS+3)=-TWOPI*(RFL(1)*STORE(I+9)+RFL(2)*STORE(I+10)+RFL(3)
     2 *STORE(I+11))
C--COMPUTE THE LAUE GROUP MULTIPLICITY FOR THIS REFLECTION
        KT=KS+KU
C--LOOP OVER THE NEW INDICES AND THEIR FRIEDEL RELATED SET
        DO 1350 J=KS,KT,KU
          IF(ISTORE(J)-ISTORE(KR))1350,1250,1350
1250      CONTINUE
          IF(ISTORE(J+1)-ISTORE(KR+1))1350,1300,1350
1300      CONTINUE
          IF(ISTORE(J+2)-ISTORE(KR+2))1350,1400,1350
1350    CONTINUE
        GOTO 1450
C--THIS GROUP DUPLICATES THE FIRST SET OF EQUIVALENT INDICES
1400    CONTINUE
        A=A+1.
C--UPDATE FOR THE NEXT SET OF EQUIVALENT INDICES
1450    CONTINUE
        KS=KS+KU+KU
      END DO
      A=1./A
C
C--CHECK IF THE NEXT REFLECTION SHOULD BE WEIGHTED
      U=STORE(M6+3)/SCALE   ! FO
C----- SUM FO
      SST = SST + U
      V=STORE(M6+5)         ! FC



      IF ( NWT .EQ. -1 ) THEN            ! SIM WEIGHTED FOURIER
C----- SET DEFAULT TO CENTRO-SYMMETRIC SIM WEIGHTING
         ISMWT = 1
         STORE(M6+4) = 1.
C--COMPUTE THE SIM WEIGHT MULTILPIER
C----- GET SINTH/LAM**2 AND HENCE SIG (F**2)
         IN = 0
c         SSW = SNTHL2(IN)
         SSW = STORE(M6+16)   ! Already computed by KALLOW
C----- GET AN AVERAGE TEMPERATURE FACTOR CORRECTION. DON'T.
         BT = EXP(4.*SSW)    ! Assume U of 0.05? (and positive?)
c         BT = 1.0
         SSW = SQRT( SSW)
         CALL XSCATT(SSW)
         SSW=0.
         M29=LQ29
C--FORM THE SUM OF THE SQUARES OF THE FORM FACTORS
         DO I=1,N29
            J=L3TR+ISTORE(M29)*MD3TR
            SSW= SSW + STORE(M29+2) * STORE(J) * STORE(J)
            M29=M29+MDQ29
         END DO
         SSW = SSW * SSC * BT
         IF (SSW .LE. ZERO)   GOTO 1700
         B = U * V / SSW
C--CHECK IF THE STRUCTURE IS CENTRO OR NOT
         IF(IC)1600,1600,1650

1600     CONTINUE                    ! NON-CENTRO STRUCTURE
C----- MODIFY WEIGHTS FOR OPTIMAL MAPS
         IF (NTYP .EQ. 5) THEN
C----   CHECK IF ALMOST CENTRO
            Q = STORE(M6+6)/PI + 2.
            Q = Q - AINT(Q)
C-----  CHECK LE 12 DEGREES ( IN RADIANS)
            IF (Q .LE. .07) GOTO 1650
            ISMWT = -1
         ENDIF
         B = 2.* B
         IF (B .GT. 600.) GOTO 1700  ! Bessel function would overflow.
c         IF (B .GT. 6.) GOTO 1700  ! Old statement (not so good).
c         IFAIL = 1
c         STORE(M6+4)=S18AFF(B,IFAIL)/S18AEF(B,IFAIL)
C----- SIMPLER CALC USING FUNCTION STATEMENT FROM MULTAN
C         STORE(M6+4) = VEC(B)
C Replace NAG routines (above) with this polynomial approximation.
         CALL MDBESL(B,BS0,BS1)
c         STORE(M6+4)=MAX(0.0,BS1/BS0)  !Min w zero
         STORE(M6+4)=BS1/BS0  !Old code
         GOTO 1700

1650     CONTINUE                     ! CENTRO STRUCTURE
c         STORE(M6+4)=MAX(0.0,TANH(B))   ! Min w zero
         STORE(M6+4)=TANH(B)    !Old code

1700     CONTINUE                 ! STORE MAX. AND MIN. WEIGHTS
         I=2
         IF(STORE(M6+4)-HWMIN(6,2))1750,1750,1800
C--CHECK FOR A NEW MINIMUM
1750     CONTINUE
         I=1
         IF(STORE(M6+4)-HWMIN(6,1))1800,1810,1810
C--NEW WEIGHT LIMIT
1800     CONTINUE
         HWMIN(IX,I)=STORE(M6)
         HWMIN(IY,I)=STORE(M6+1)
         HWMIN(IZ,I)=STORE(M6+2)
         HWMIN(4,I)=U
         HWMIN(5,I)=V
         HWMIN(6,I)=STORE(M6+4)
c         U = U * STORE(M6+4)
c         IF (NTYP .NE. 5) V = V * STORE(M6+4)   ! 'OPTIMAL' DON'T WEIGHT FC
1810     CONTINUE
         U = U * STORE(M6+4)
         V = V * STORE(M6+4)                    ! RIC: 'OPTIMAL' DO WEIGHT FC

c         WRITE(99,'(F15.8)') STORE(M6+4)

      ELSE IF ( NWT .EQ. -2 ) THEN             ! MAIN'S WEIGHTS

         STL2 = STORE(M6+16)
         BT = 1.0
         STL = SQRT(STL2)
         CALL XSCATT(STL)
         SSW=0.
         SSF=0.
C--
         DO I=0,N29-1 ! FORM THE SUM OF THE SQUARES OF THE FORM FACTORS
            J=L3TR+ISTORE(LQ29+MDQ29*I)*MD3TR
            SSF= SSF + STORE(LQ29+MDQ29*I+2) * STORE(J)
            SSW= SSW + STORE(LQ29+MDQ29*I+2) * STORE(J) * STORE(J)
         END DO
         SSW = SSW * SSC * BT
         SSF = SSF * SSC * BT

         CALL XMASKF( FA, FB, STORE(M6), STORE(M6+16), 1 ) ! Tell XMASKF to unswap axes.
         FMAG = SQRT(FA**2+FB**2)
         IF ( FMAG .LT. ZERO ) THEN
           FPHI = 0.0
         ELSE
           FPHI = ATAN2(FB,FA)
         END IF

         AP=V*COS(STORE(M6+6))
         BP=V*SIN(STORE(M6+6))

         FPS1F = SQRT((AP+SSF*FA)**2 + (BP+SSF*FB)**2)
         RDEN = SSW * ( 1 - FMAG )**2

         IF ( ISCNTRC(STORE(M6)) .EQ. 0 ) THEN

           RNUM = 2 * U * FPS1F 
c           RNUM = 2 * U * FPS1F * EXP(4.*STL2)  ! Sharpen Fo.

           IF ( RDEN .LT. ZERO ) THEN
             BSRAT = 1.0
             B = 99999.99
             MAINWL = MAINWL + 1
           ELSE
             B = RNUM / RDEN
             IF ( B > 600.0 )  THEN
                MAINWL = MAINWL + 1
                BSRAT = 1.0
             ELSE IF ( B < -600.0 )  THEN
                MAINWS = MAINWS + 1
                BSRAT = -1.0
             ELSE
                CALL MDBESL(B,BS0,BS1)
                BSRAT = BS1 / BS0
             END IF
           END IF

c           WRITE(CMON,'(3I3,1X,F5.2,F7.2,F7.0,7F7.3)')
c     2   (NINT(STORE(M6+I)),I=0,2),STL,SSF,SSW,FA,FB,FMAG,FPHI,RNUM,
c     2   RDEN,B
c           CALL XPRVDU(NCVDU,1,0)


           TNUM = SSF * FMAG * SIN ( FPHI - STORE(M6+6) )
           TDEN = V + SSF * FMAG * COS ( FPHI - STORE(M6+6) )
      
           IF ( TNUM**2 + TDEN**2 .LT. ZEROSQ ) THEN
             TPHI = 0.0
           ELSE
             TPHI = ATAN2(TNUM,TDEN)
           END IF

           U = BSRAT * U
           V = BSRAT * V
           STORE(M6+6) = STORE(M6+6) + TPHI

         ELSE

           RNUM = U * FPS1F
c           RNUM = U * FPS1F * EXP(4.*STL2) ! Sharpen Fo.
           TPHI = 0.0

           IF ( RDEN .LT. ZERO ) THEN
             BSRAT = 1.0
             MAINWL = MAINWL + 1
           ELSE
             B = RNUM / RDEN
             IF ( B > 600.0 )  THEN
                BSRAT = 1.0
                MAINWL = MAINWL + 1
             ELSE IF ( B < -600.0 )  THEN
                BSRAT = -1.0
                MAINWS = MAINWS + 1
             ELSE
                BSRAT = TANH(B)
             END IF
           END IF

           U = BSRAT * U
           V = BSRAT * V

         END IF

c         WRITE(CMON,'(A,2F15.8)')'Main''s corrections:',BSRAT,TPHI
c         CALL XPRVDU(NCVDU,1,0)

c         WRITE(99,'(2F15.8)') BSRAT, STORE(M6+6)

      ELSE IF ( NWT .EQ. 1 ) THEN             ! LIST-6 WEIGHTS

C--WEIGHTS FROM LIST 6  -  CHECK IF THIS IS AN E-MAP
         IF (NTYP .EQ. IEMAP) THEN
C--THIS IS AN E-MAP  -  COMPUTE THE WEIGHTS
            B=0.
            KS=KR
            DO I=L2I,M2I,MD2I
               KT=KS+KU*IC
C--LOOP OVER THE NECESSARY NUMBER OF REFLECTIONS
               DO 2050 J=KS,KT,KU
                  IF(ISTORE(J).NE.ISTORE(KR)) CYCLE
                  IF(ISTORE(J+1).NE.ISTORE(KR+1))CYCLE
                  IF(ISTORE(J+2).EQ.ISTORE(KR+2))GOTO 2100
2050           CONTINUE
               GOTO 2150

2100           CONTINUE
C--THIS REFLECTION DUPLICATES THE FIRST SET OF EQUIVALENT INDICES
               B=B+1.

2150           CONTINUE
               KS=KS+KU+KU
            END DO
            STORE(M6+4)=SQRT(B)
         END IF

C--COMPUTE THE WEIGHTED MULTIPLICITY TERM / APPLY LIST 6 WEIGHTS
         U=U*STORE(M6+4)
         V=V*STORE(M6+4)
      END IF

C---- SUM THE (NOW POSSIBLY WEIGHTED) FO
      SSU = SSU + U
C--LOOP OVER EACH EQUIVALENT AND ADD IN ITS CONTRIBUTION
      KS=KR
      DO I=L2I,M2I,MD2I

C--BRANCH ON THE TYPE OF FOURIER
c     F-OBS          F-CALC         DIFFERENCE     2FO-FC         OPTIMAL
c     FO-PATTERSON   FC-PATTERSON   FO-FC-SQP      FOSQ-FCSQ-P
c     EXTERNAL
         GOTO (2450, 2500, 2550, 2555, 2557,
     1         2600, 2650, 2657, 2658,
     2         2500, 2400), NTYP

2400  STOP 265

C--'FO' FOURIER
2450     CONTINUE
         F=U
         GOTO 2750
C--'FC' FOURIER
2500     CONTINUE
         F=V
         GOTO 2750
C--'DF' FOURIER
2550     CONTINUE
         F=U-V
         GOTO 2750
C----- 2Fo - FC MAP
2555     CONTINUE
         F = 2.*U - V
         GOTO 2750
C----- OPTIMAL - WTD FO OR WTD 2 FO - FC
2557     CONTINUE
         IF (ISMWT .GT. 0) THEN
               F = U
         ELSE
               F = 2.*U - V
         ENDIF
         GOTO 2750
C--'FO' PATTERSON
2600     CONTINUE
         F=U*ABS(U)   !Ensure sign is retained
c         IF ( U .LT. 0.0 ) F = -F
         GOTO 2700
C--'FC' PATTERSON
2650     CONTINUE
         F=V*V
         GOTO 2700
2657     CONTINUE
C---- (FO-FC)**2 PATTERSON
         F = (U-V)**2
c         IF ( U .LT. V ) F = -F
         GOTO 2700
2658     CONTINUE
C----- FO**2 - FC**2 PATTERSON
         F = U*U - V*V
c         WRITE (188, *) 'Fo2-Fc2: ', U*U, V*V, F, A
         GOTO 2700
C--ACCUMULATE THE ORIGIN FOR SCALING
2700     CONTINUE
         F=F*A
         P=F
         Q=0.
         GOTO 2800
C--COMPUTE A AND B
2750     CONTINUE
         H=STORE(M6+6)+STORE(KS+3)
         F=F*A
         P=F*COS(H)
         Q=F*SIN(H)
C--SUM THE TERMS USED
2800     CONTINUE
         W=W+F
C--ADD IN THE CONTRIBUTIONS FOR THIS 'HK' PAIR
         S=1.
         L=ISTORE(KS)
         M=ISTORE(KS+1)
C--CHECK THE SIGN OF  'H'
         IF(L)2850,2900,2900
C--'H' IS NEGATIVE
2850     CONTINUE
         L=-L
         M=-M
         S=-1.0
C--FIND THE ADDRESS OF THE 'H' AND 'K' TABLES
2900     CONTINUE
         L=L+JS
         K=ISTORE(L)+M
         K=ISTORE(K)+JW
C--COMPUTING THE STARTING POINT FOR THIS Z LAYER
         KL=KB*ISTORE(KS+2)
         KM=KH*ISTORE(KS+2)
C--LOOP OVER EACH SECTION TO BE COMPUTED IN THIS PASS
         DO 2950 L=1,JZ,2
            N=MOD(KL,JF)+JL
            M=N+JO
            FSTORE(K)=FSTORE(K)+P*STORE(N)+Q*STORE(M)
            FSTORE(K+1)=FSTORE(K+1)+S*(Q*STORE(N)-P*STORE(M))
c            WRITE(191,*)' HK: ', FSTORE(K), FSTORE(K+1), W, F
            K=K+2
            KL=KL+KM
2950     CONTINUE
         KS=KS+KU+KU
      END DO
      GOTO 1100
C
C--PROCESS THE NEXT GROUP OF SECTIONS
3050  CONTINUE
      SC=0.
      IF(W-ZERO)3070,3060,3060
3060  CONTINUE
      SC=SCLCON/W
C--CHECK FOR SCALE FACTOR FROM LIST 14
3070  CONTINUE
      IF(ISC)3100,3100,3150
3100  CONTINUE
      SC=STORE(L14SC)*2.0/VOL
C--INCREMENT THE SCAN COUNTER
3150  CONTINUE
      SS=SC*VOL*0.5
      NV=NV+1
C--PRINT THE NUMBER OF REFLECTIONS USED ON THIS SCAN
      IF (ISSPRT .EQ. 0) WRITE(NCWU,3250)N6D,NORFL,NV
      WRITE ( CMON ,3250)N6D,NORFL,NV
      CALL XPRVDU(NCVDU, 2,0)
3250  FORMAT( ' Total number of reflections is ',I6,/,
     1        '                       of which ',I6,
     2 ' have been used for scan ',I3)
C--CHECK IF THERE ARE ANY REFLECTIONS
      IF ( NORFL .LE. 0 ) GO TO 9910
C---- PEAK HEIGHT NORMALISATION
      IF (NWT .EQ. 0) THEN
            SSU = 1.
      ELSE
            SSU = SST / SSU
      ENDIF
      KI=JW
      RETURN
9900  CONTINUE
C -- ERRORS
      RETURN
9910  CONTINUE
C -- NO REFLECTIONS
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 9915 )
      WRITE ( CMON , 9915 )
      CALL XPRVDU(NCVDU, 1,0)
9915  FORMAT ( 1X , 'No reflections for Fourier' )
      CALL XERHND ( IERERR )
      GO TO 9900
C
      END
C
CODE FOR XFOURO
      SUBROUTINE XFOURO
C--LOCATE MAXIMA IN THE FOURIER IF NECESSARY
C
C--
      INCLUDE 'FOURTP.INC'
      INCLUDE 'ISTORE.INC'
C
      DIMENSION AMULT(3),SOL1(4,4),SOL2(3,3),SOL3(3,3),P(7),QQ(4),XX(3)
     2 ,RHO(3,3,3)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XFOURC.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLST14.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QFOURC.INC'
C
      EQUIVALENCE (P(1),AA),(P(2),AE),(P(3),AF),(P(4),AG)
      EQUIVALENCE (P(5),AB),(P(6),AC),(P(7),AD)
C
C
      DATA AMULT(1)/1.0/,AMULT(2)/0.0/,AMULT(3)/1.0/
C
      DATA SOL1(1,1)/18./,SOL1(1,2)/-10./,SOL1(1,3)/-10./,SOL1(1,4)/
     2 -10./
      DATA SOL1(2,1)/-10./,SOL1(2,2)/11./,SOL1(2,3)/4./,SOL1(2,4)/4./
      DATA SOL1(3,1)/-10./,SOL1(3,2)/4./,SOL1(3,3)/11./,SOL1(3,4)/4./
      DATA SOL1(4,1)/-10./,SOL1(4,2)/4./,SOL1(4,3)/4./,SOL1(4,4)/11./
C
C--COMPUTE THE FRACTIONAL 'Z' FOR THIS SECTION
      Z=STORE(L14+12)-STORE(L14+13)
C--CHECK IF WE SHOULD DO THE PEAK SEARCH
      IF(ISCAN)1950,1000,1050
1000  CONTINUE
      APEAKH = HEIGHT  * SS / SSU
      GOTO 1100
1050  CONTINUE
      APEAKH=HEIGHT
C--CHECK IF WE HAVE CALCULATED 3 SECTIONS YET
1100  IF(KJ-2)1950,1150,1150
C--PASS THROUGH EACH POINT OF THE CENTRAL SECTION
1150  CONTINUE
      X=STORE(L14)
      DO 1910 II = NY , NYNZM2 , NY
      X=X+STORE(L14+1)
      Y=STORE(L14+6)
      DO 1900 IK=1,NYM2
      Y=Y+STORE(L14+7)
      NK=II+IK
      M=NK+L82
C----- SAVE THE MINIMUM DENSITY
      IF (DENMIN .GT. FSTORE(M)) THEN
       DENMIN = FSTORE(M)
       FXMIN = X
       FYMIN = Y
       FZMIN = Z
      ENDIF
      DENMAX = MAX(DENMAX, FSTORE(M))
C
C--CHECK IF THE CENTRAL POINT IS GREATER THAN THE MINIMUM REQUIRED
      IF(FSTORE(M)-APEAKH)1900,1200,1200
C--POINTER TO THE LAYER BELOW
1200  CONTINUE
      L=NK+L83
C--POINTER TO THE LAYER ABOVE
      N=NK+L81
      LM=L-NY
      LN=L+NY
      NA=M-NY
      NB=M+NY
      NM=N-NY
      NN=N+NY
C--COMPUTE THE MAXIMUM OF THE NEAREST 19 POINTS
      W=AMAX1(FSTORE(L),FSTORE(M),FSTORE(N),FSTORE(M-1),FSTORE(M+1),
     2 FSTORE(NA),FSTORE(NB))
      Q=AMAX1(W,FSTORE(N+1),FSTORE(N-1),FSTORE(L+1),FSTORE(L-1),
     2 FSTORE(NA+1),FSTORE(NA-1))
      W=AMAX1(Q,FSTORE(NB-1),FSTORE(NB+1),FSTORE(LN),FSTORE(LM),
     2 FSTORE(NN),FSTORE(NM))
C--CHECK IF THE MAXIMUM IS GREATER THAN THE CENTRAL POINT
      IF(FSTORE(M)-W+0.01)1900,1250,1250
C--TRY THE LEAST SQUARES FIT FIRST
1250  CONTINUE
      M10=L10+MD10*N10
      A=1.+VALUSQ
C--SET UP THE DENSITY VALUES
      RHO(1,1,1)=A
      RHO(2,1,1)=FSTORE(L-1)
      RHO(3,1,1)=A
      RHO(1,2,1)=FSTORE(LM)
      RHO(2,2,1)=FSTORE(L)
      RHO(3,2,1)=FSTORE(LN)
      RHO(1,3,1)=A
      RHO(2,3,1)=FSTORE(L+1)
      RHO(3,3,1)=A
C
      RHO(1,1,2)=FSTORE(NA-1)
      RHO(2,1,2)=FSTORE(M-1)
      RHO(3,1,2)=FSTORE(NB-1)
      RHO(1,2,2)=FSTORE(NA)
      RHO(2,2,2)=FSTORE(M)
      RHO(3,2,2)=FSTORE(NB)
      RHO(1,3,2)=FSTORE(NA+1)
      RHO(2,3,2)=FSTORE(M+1)
      RHO(3,3,2)=FSTORE(NB+1)
C
      RHO(1,1,3)=A
      RHO(2,1,3)=FSTORE(N-1)
      RHO(3,1,3)=A
      RHO(1,2,3)=FSTORE(NM)
      RHO(2,2,3)=FSTORE(N)
      RHO(3,2,3)=FSTORE(NN)
      RHO(1,3,3)=A
      RHO(2,3,3)=FSTORE(N+1)
      RHO(3,3,3)=A
C--CONVERT TO LOGS
      DO 1450 I=1,3
      DO 1400 J=1,3
      DO 1350 K=1,3

C--CHECK IF THE RHO VALUE IS LESS THAN 1.
      IF(RHO(K,J,I)-1.)1800,1300,1300
C--TAKE LOGS
1300  CONTINUE
      RHO(K,J,I)=ALOG(RHO(K,J,I))
1350  CONTINUE
1400  CONTINUE
1450  CONTINUE
C--COMPUTE THE 'B', 'C', AND 'D' TERMS
      AB=0.
      AC=0.
      AD=0.
      DO 1550 I=1,3
      DO 1500 J=1,3
      AB=AB+RHO(3,J,I)-RHO(1,J,I)
      AC=AC+RHO(J,3,I)-RHO(J,1,I)
      AD=AD+RHO(J,I,3)-RHO(J,I,1)
1500  CONTINUE
1550  CONTINUE
      AB=0.1*AB
      AC=0.1*AC
      AD=0.1*AD
C--COMPUTE THE 'H', 'K' AND 'L' TERMS
      AH=0.25*(RHO(2,1,1)-RHO(2,1,3)-RHO(2,3,1)+RHO(2,3,3))
      AK=0.25*(RHO(1,2,1)-RHO(1,2,3)-RHO(3,2,1)+RHO(3,2,3))
      AL=0.25*(RHO(1,1,2)-RHO(1,3,2)-RHO(3,1,2)+RHO(3,3,2))
C--COMPUTE THE 'Q' TERMS
      CALL XZEROF(QQ(1),4)
      DO 1700 I=1,3
      DO 1650 J=1,3
      DO 1600 K=1,3
      QQ(1)=QQ(1)+RHO(K,J,I)
      QQ(2)=QQ(2)+RHO(K,J,I)*AMULT(K)
      QQ(3)=QQ(3)+RHO(K,J,I)*AMULT(J)
      QQ(4)=QQ(4)+RHO(K,J,I)*AMULT(I)
1600  CONTINUE
1650  CONTINUE
1700  CONTINUE
C--SOLVE THE EQUATIONS
      CALL XMLTMM(SOL1,QQ,P,4,4,1)
      CALL XDVDR(P,42.,P,4)
C--SOLVE FOR THE ATOMIC COORDINATES
      SOL2(1,1)=-(AE+AE)
      SOL2(1,2)=-AL
      SOL2(2,1)=-AL
      SOL2(1,3)=-AK
      SOL2(3,1)=-AK
      SOL2(2,2)=-(AF+AF)
      SOL2(2,3)=-AH
      SOL2(3,2)=-AH
      SOL2(3,3)=-(AG+AG)
      IF(KINV2(3,SOL2,SOL3,9,1,P(5),XX,3))1800,1750,1800
1750  CONTINUE
C -- L.S. FIT MADE TO PEAK. CALCULATE NEW X,Y,Z
      STORE(M10+1)=X+XX(1)*STORE(L14+1)
      STORE(M10+2)=Y+XX(2)*STORE(L14+7)
      STORE(M10+3)=Z+XX(3)*STORE(L14+13)
C -- IF THE CALCULATED POSITION OF THE PEAK IS UNREASONABLE, GO ON TO
C    INTERPOLATION
      IF ( KFRRSN ( XX, STORE(M10+1), STORE(M10+2), STORE(M10+3), 0 )
     1  .LT. 0 ) GO TO 1800
      STORE(M10)=EXP(AA+XX(1)*(AB+XX(1)*AE)+XX(2)*(AC+XX(2)*AF)+XX(3)
     2 *(AD+XX(3)*AG)+AH*XX(2)*XX(3)+AK*XX(1)*XX(3)+AL*XX(1)*XX(2))
      STORE(M10)= STORE(M10) * SSU
      ISTORE(M10+4)=1
      GOTO 1850
C--COMPUTE THE TERMS OF THE PARABOLIC INTERPOLATION
1800  Q=FSTORE(M)+FSTORE(M)
      U=FSTORE(L)-FSTORE(N)
      V=FSTORE(M-1)-FSTORE(M+1)
      W=FSTORE(NA)-FSTORE(NB)
      R=U/(FSTORE(N)+FSTORE(L)-Q)
      S=V/(FSTORE(M-1)+FSTORE(M+1)-Q)
      T=W/(FSTORE(NA)+FSTORE(NB)-Q)
C--COMPUTE THE AVERAGE INTERPOLATED PEAK HEIGHT
      Q=FSTORE(M)-(U*R+V*S+W*T)*.041667
C--COMPUTE THE NEW 'X', 'Y' AND 'Z' COORDINATES OF THE PEAK
      XX(1) = 0.5 * T
      XX(2) = 0.5 * S
      XX(3) = 0.5 * R
      STORE(M10) = Q * SSU
      STORE(M10+1)=X+0.5*STORE(L14+1)*T
      STORE(M10+2)=Y+0.5*STORE(L14+7)*S
      STORE(M10+3)=Z+0.5*STORE(L14+13)*R
      ISTORE(M10+4)=2
      IF ( KFRRSN ( XX, STORE(M10+1), STORE(M10+2), STORE(M10+3), 0 )
     1  .LT. 0 ) THEN
C----- L-S AND INTERPOLATION FAIL - SET TO MAXIMUM
        STORE(M10)   = FSTORE(M)
        STORE(M10+1) = X
        STORE(M10+2) = Y
        STORE(M10+3) = Z
        ISTORE(M10+4) = 3
      END IF
C
C--SORT THE PEAKS INTO ORDER
1850  CONTINUE
      N10=N10+1
      CALL XSHELR(STORE(L10),MD10,1,N10,MD10*N10,STORE(NFL))
      N10=MIN0(N10,N10MAX)
1900  CONTINUE
1910  CONTINUE
C
C
C--CHECK IF THERE ARE ANY ATOMS IN LIST 5 TO CHECK
1950  CONTINUE
      IF(N10A)2200,2200,2000
C--CHECK FOR ANY ATOMS ON THIS SECTION
2000  CONTINUE
      M10A=L10A
C--PASS THROUGH ALL THE ATOMS
      DO 2150 NC=1,N10A
      IF(KJ-ISTORE(M10A+6))2100,2050,2100
C--WE ARE ON THE RIGHT SECTION FOR THIS ATOM
2050  CONTINUE
      I=MIN0(NUM(1)-2,MAX0(1,NINT((STORE(M10A+2)-STORE(L14))/
     2 STORE(L14+1))))
      K=MIN0(NUM(2)-2,MAX0(1,NINT((STORE(M10A+3)-STORE(L14+6))/
     2 STORE(L14+7))))
      NK=I*NY+K
C--SECTION POINTERS
      L=NK+L83
      M=NK+L82
      N=NK+L81
C--DIFFERENT ROW POINTERS
      NA=M-NY
      NB=M+NY
C--INITIAL CONSTANTS
      T=(STORE(M10A+2)-STORE(L14))/STORE(L14+1)-FLOAT(I)
      S=(STORE(M10A+3)-STORE(L14+6))/STORE(L14+7)-FLOAT(K)
      R=(STORE(M10A+4)-Z)/STORE(L14+13)
C--DOUBLE THE CENTRAL MAP POINT
      Q=FSTORE(M)+FSTORE(M)
C--INTERPOLATE THE HEIGHT OF THE GIVEN ATOM
      STORE(M10A+5)=FSTORE(M)+0.5/3.0*(T*(T*(FSTORE(NA)+FSTORE(NB)-Q)
     2 -FSTORE(NA)+FSTORE(NB))+S*(S*(FSTORE(M+1)+FSTORE(M-1)-Q)
     3 -FSTORE(M-1)+FSTORE(M+1))+R*(R*(FSTORE(N)+FSTORE(L)-Q)-FSTORE(L)
     4 +FSTORE(N)))
      STORE(M10A+5) = SSU * STORE(M10A+5)
2100  CONTINUE
      M10A=M10A+MD10A
2150  CONTINUE
2200  CONTINUE
      RETURN
      END
C
CODE FOR XFOURP
      SUBROUTINE XFOURP(LNOUT)
C--OUTPUT THE RESULTS OF THE PEAK SEARCH TO THE DISC
C
C  LNOUT  THE TYPE OF LIST OUTPUT, USUALLY A LIST TYPE 10.
C
C--
      INCLUDE 'FOURTP.INC'
      INCLUDE 'ISTORE.INC'
      INCLUDE 'ICOM05.INC'
C
C
      DIMENSION BLANK(1) , ACCUR(3)
C
      CHARACTER*16 CFOUND
      CHARACTER*12 CFIT(4)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XFOURC.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XDSTNC.INC'
      INCLUDE 'XPDS.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XLST02.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST14.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QFOURC.INC'
      INCLUDE 'QLST05.INC'
C
C
      EQUIVALENCE (IB,BLANK(1))
C
C
C
      DATA CFIT / 'Good Shape  ' , 'Poor Shape  ' , 'Dubious Peak',
     1 'Hole' /
C
      DATA CFOUND / '  Not in the map' /
      DATA LFOUND / 16 /
#if defined (_HOL_)
      DATA IQNEG/4HQN  /
#else
      DATA IQNEG/'QN  '/
#endif
C
C----- GET THE MAP SIGN
      SMAP = FLOAT(NGMAP)
C--COMPUTE THE ACCURACY TERMS FOR THE COORDS.
      M14=L14
      DO 1000 I=1,3
      ACCUR(I)=0.01*STORE(M14+1)
      M14=M14+MD14
1000  CONTINUE
C--SORT OUT LIST 14 TO CALCULATE THE MAP COORDINATES
      CALL XUSWOP(IAXIS,STORE(L14+3),3*MD14,MD14,1,BPD(10),3,1,1,1)
C--SET UP THE INITIAL GUESS OF A LIST AS 10
      LNOUT=10
C-NOW A PARAMETER      INCLUDE 'IDIM05.INC'
C--CHECK IF WE HAVE FOUND ANY PEAKS
      IF(N10)2550,2550,1050
C--BRANCH ON THE FOURIER TYPE
1050  CONTINUE
      IF (NTYP .LT. IPMAP) GOTO 1150
C--OLD ATOMS ARE NOT REQUIRED  -  DELETE THEM IF NECESSARY
      N10A=0
      ORGOCC=1.
C--BRING DOWN THE OLD LIST 5 IF THIS IS POSSIBLE
1150  CONTINUE
      IF(KEXIST(5))1200,1200,1250
C--NO LIST 5 TO USE  -  SET UP A COMPLETELY NEW LIST
1200  CONTINUE
      CALL XZEROF(ICOM05(1),IDIM05)
      N5=N10A+N10
      CALL XCELST(LNOUT,ICOM05,IDIM05)
      MD5A=MD5
C--OUTPUT THE CAPTIONS FOR THE PEAK SEARCH DATA
      CALL XPRTCN
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1300)LNOUT,SS,APEAKH,N10MAX
      GOTO 1750
C
C--LOAD THE OLD LIST 5
1250  CONTINUE
      CALL XFAL05
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--CREATE THE OUTPUT LIST TYPE
      N5=N10+N10A
      NEW=1
      CALL XCPYL5(5,LNOUT,N10A,NEW)
C--CAPTION FOR THE LIST 5 AND PEAK SCAN RESULTS
      CALL XPRTCN
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1300)LNOUT,SS,APEAKH,N10MAX
1300  FORMAT(' Results of the peak search and contents',
     2 ' of the new list ',I3//' Map scale factor = ',F10.3,5X,
     3 'Minimum peak height = ',F10.1,5X,
     4 'Maximum number of peaks allowed = ',I5//' Type',3X,'Serial',
     5 4X,'X',9X,'Y',9X,'Z',11X, 'Height'/)
C----- NEED A PRINT?
      IF (IPKMON .GE. 0) THEN
      WRITE ( CMON , 1305 ) LNOUT
      CALL XPRVDU(NCVDU, 2,0)
1305  FORMAT ( 'Results of the peak search and contents ' ,
     2 'of the new list ' , I3 , / ,
     3 8X , 'Atom' , 10X , 'Height' ,
     4 9X , 'x' , 9X , 'y' , 9X , 'z' , 4X , 'Fit' )
      ENDIF
C--CHECK IF WE SHOULD PRINT DETAILS OF THE ORIGINAL ATOMS
      IF(N10A)1750,1750,1350
C--LOOP OVER EACH ATOM IN TURN
1350  CONTINUE
      M5=L5
      M5A=NOWT
      M10A=L10A
C--SET THE PEAK HEIGHTS OF THE INPUT ATOMS
      AAA=0.
      BBB=0.00001
C--LOOP OVER THE ORIGINAL ATOMS
      DO 1550 I=1,N10A
      STORE(M5+13) = STORE(M10A+5) * SMAP
      N = LFOUND
C--CHECK IF WE CAN FIND THIS ATOM ON THIS MAP
      IF(ISTORE(M10A+6))1450,1400,1400
C--ADD IN THE PEAK HEIGHT TO COMPUTE THE MEAN
1400  CONTINUE
      AAA=AAA+STORE(M10A+5)
      BBB=BBB+1.
      N=1
C--UNSWOP THE COORDINATES AND COMPUTE THE MAP POSITION
1450  CONTINUE
      CALL XUSWOP(IAXIS,STORE(M10A+2),3,1,1,APD,3,1,1,1)
      CALL XMLTVR(APD(1),BPD(10),APD(4),3)
C--PRINT THE RESULTS
      IF (ISSPRT .EQ. 0)
     1 WRITE(NCWU,1500)STORE(M5),STORE(M5+1),(APD(J),J=1,3),
     2 STORE(M5+13), CFOUND(1:N)
1500  FORMAT ( 1X,A4,F8.0,1X,3F10.4,1X,F10.1,2X,A )
      IF (IPKMON .GT. 0) THEN
      WRITE ( CMON ,1501)STORE(M5),STORE(M5+1),STORE(M5+13),
     1 (APD(J),J=1,3), CFOUND(1:N)
      CALL XPRVDU(NCVDU, 1,0)
1501  FORMAT ( 6X , A4 , F5.0 , 5X , F8.1 , 3F10.4 , 2X , A )
      ENDIF
C--UPDATE THE POINTERS
      M10A=M10A+MD10A
      M5=M5+MD5
1550  CONTINUE
C--COMPUTE THE MEAN ELECTRON DENSITY AT THE ATOMIC SITE CENTRES
      AAA=AAA/BBB
      CCC=0.
      M10A=L10A
C--COMPUTE THE R.M.S. DEVIATION
      DO 1700 I=1,N10A
      IF(ISTORE(M10A+6))1650,1600,1600
C--ADD IN THIS CONTRIBUTION
1600  CONTINUE
      DDD=STORE(M10A+5)-AAA
      CCC=CCC+DDD*DDD
C--UPDATE THE POINTER
1650  CONTINUE
      M10A=M10A+MD10A
1700  CONTINUE
C--COMPUTE THE R.M.S. VALUE
      DDD=SQRT(CCC/BBB)
C
C--ADD THE DATA FROM THE PEAK SEARCH
1750  CONTINUE
      KE=N10A
      N5=N10A
C--CHECK IF THERE ARE ANY ATOMS TO OUTPUT
      IF(N10)2400,2400,1800
C--SET UP THE AREA FOR THE OUTPUT PEAKS
1800  CONTINUE
      K=L5+MD5*N10A
C--PASS THROUGH THE PEAKS, TRUNCATING TO THE CORRECT ACCURACY
      M10=L10
      DO 1900 I=1,N10
      J=M10
      DO 1850 L=1,3
      STORE(J+1)=ACCUR(L)*FLOAT(NINT(STORE(J+1)/ACCUR(L)))
      J=J+1
1850  CONTINUE
      M10=M10+MD10
1900  CONTINUE
C--SET UP THE FLAGS BEFORE WE PASS THROUGH
      M10=L10
      KD=12
      IDIST=-1
      MD5A=MD5
      MD5=MD10
C--LOOP OVER EACH ATOM FOUND DURING THE PEAK SEARCH
      DO 2350 I=1,N10
C--CHECK IF THIS PEAK HEIGHT IS POSITIVE
cfeb03  Save deepest hole
      if ((i .eq. n10) .and. (ntyp .eq. 3)) goto 1950
      IF(STORE(M10))2300,1950,1950
C--PEAK TO OUTPUT  -  COMPUTE THE COORDINATES
1950  CONTINUE
      N5=N5+1
      CALL XUSWOP(IAXIS,STORE(M10+1),3,1,1,STORE(K+4),3,1,1,1)
C----- RE-SAVE THE POSITION IN CELL FRACTIONS
      FXMIN = STORE(K+4)
      FYMIN = STORE(K+5)
      FZMIN = STORE(K+6)
C--SET THE PEAK SERIAL NUMBER
      STORE(K+1)=FLOAT(N5-KE)
      STORE(K+2)=ABS(XOCC(M10-3))
      CALL XMLTVR(STORE(K+4),BPD(10),APD(1),3)
C--SET THE PEAK HEIGHT
C----- CORRECT SIGN OF MAP ELEMENTS
      STORE(M10) = SMAP * STORE(M10)
      STORE(K+13)=STORE(M10)
Cnov98> - ZERO THE ANISO, SET U11 AND FLAG
      STORE(K+3)= 1.
      CALL XZEROF (STORE(K+7), 6)
      STORE(K+7) = 0.05
CNOV <
      L=K+2
      N=ISTORE(M10+4)
      IF (N .EQ. 4) ISTORE(K)=IQNEG
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1500)STORE(K),STORE(K+1),( STORE(M+4),M=K,L ),
     2 STORE(K+13), CFIT(N)
      ENDIF
      IF (IPKMON .GE. 0) THEN
      WRITE(CMON,1501) STORE(K),STORE(K+1),STORE(K+13),
     1 ( STORE(M+4),M=K,L ) , CFIT(N)
      CALL XPRVDU(NCVDU, 1,0)
      ENDIF
      K=K+MD5A
C -- IF PEAK IS UNREASONABLE, MARK AS DELETED
      IF ( N .EQ. 3 ) STORE(M5+3) = -1.
C--CHECK FOR ANY CONTACTS TO THIS PEAK
      M5A=M10-3
      M5=M5A+MD10
      N = KDIST1( N10-I, KC, KD, 0, .2, 0, 0, 4, 0)
C--CHECK IF THERE ARE ANY CONTACTS TO THIS ATOM
      IF(N)2300,2300,2000
C--MARK THE OTHER CONTACTS NOT TO BE USED
2000  CONTINUE
      KC=NFL
C--DELETE THE NEXT PEAK
2050  CONTINUE
      IF(STORE(KC+10)-REJECT)2100,2100,2250
C----- DISTANCE TOO SHORT - REJECT
2100  CONTINUE
      M5=ISTORE(KC)
C----- REJECT ALTOGETHER IF COINCIDENT
      IF (STORE(KC+10) - VALUE) 2210,2210,2110
2110  CONTINUE
C--CHECK IF THIS PEAK HAS ALREADY BEEN DELETED
      IF(STORE(M5+3))2250,2150,2150
C--UNSWOP THE COORDINATES OF THE ATOM TO BE DELETED
2150  CONTINUE
      CALL XUSWOP(IAXIS,STORE(M5+4),3,1,1,APD,3,1,1,1)
      CALL XMLTVR(APD(1),BPD(10),APD(4),3)
C--PRINT THE DELETED MESSAGE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2200)(APD(M),M=1,3),STORE(M5+3),STORE(KC+10)
      ENDIF
2200  FORMAT(14X,3F10.5,1X,F10.1,2X,'Rejected',F8.6,
     2 '  angstrom contact')
2210  CONTINUE
C--MARK THE PEAK AS DELETED
      STORE(M5+3)=-1.
C--UPDATE FOR THE NEXT PEAK
2250  CONTINUE
      KC=KC+KD
      N=N-1
      IF(N)2300,2300,2050
C--UPDATE FOR THE NEXT PEAK
2300  CONTINUE
      M10=M10+MD10
2350  CONTINUE
C--UPDATE THE POINTERS
2400  CONTINUE
      N5=MIN0(N5,KE+NPEAK)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,2450)LNOUT,N5
      WRITE ( CMON ,2450)LNOUT,N5
      CALL XPRVDU(NCVDU, 1,0)
2450  FORMAT(' The new list ',I3,' contains ',I5,' atoms')
      MD5=MD5A
      CALL XSTR05(LNOUT,0,NEW)
C--AND NOW RETURN
2500  CONTINUE
      RETURN
C
C--NO PEAKS FOUND  -  SEE IF WE SHOULD OUTPUT A LIST 5 INSTEAD
2550  CONTINUE
      IF(N10A)2600,2600,1250
C--NO ATOMS EITHER  -  NO LIST 10 TO OUTPUT
2600  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU,2650)
      WRITE ( CMON ,2650)
      CALL XPRVDU(NCVDU, 1,0)
2650  FORMAT(' No peaks found, so no LIST 10 formed')
      CALL XALTES(LNOUT,-1)
      GOTO 2500
C
9900  CONTINUE
C -- ERRORS
      RETURN
C
      END
C
CODE FOR XMLTVR
      SUBROUTINE XMLTVR(A,B,C,N)
C--MULTIPLY THE 'N' ELEMENTS OF 'A' BY THE 'N' ELEMENTS OF 'B'
C  AND STORE THE RESULTS IN 'C'.
C
C  A  THE INPUT VECTOR.
C  B  THE SECOND INPUT VECTOR.
C  C  THE OUTPUT VECTOR.
C  N  THE NUMBER OF ELEMENTS IN 'A' AND 'C'.
C
C--
C
C
      DIMENSION A(N),B(N),C(N)
C
C
C
      DATA I/0/
C
C--CHECK FOR SOME ELEMENTS
      IF(N)1100,1100,1000
1000  CONTINUE
      DO 1050 I=1,N
      C(I)=A(I)*B(I)
1050  CONTINUE
1100  CONTINUE
      RETURN
      END
C
CODE FOR KFOURC
      FUNCTION KFOURC(IN)
C--FETCH THE NEXT REFLECTION FOR A FOURIER
C
C--RETURN VALUES ARE:
C
C  -1  END OF THE REFLECTIONS
C   0  REFLECTION FOUND
C
C--
      INCLUDE 'FOURTP.INC'
      INCLUDE 'ISTORE.INC'
C
C
      DIMENSION RFL(3)
      DIMENSION FFILTR(3)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XFOURC.INC'
      INCLUDE 'XLST06.INC'
      INCLUDE 'XTAPES.INC'
      INCLUDE 'XTAPED.INC'
      INCLUDE 'XUNITS.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QFOURC.INC'
C
C
      EQUIVALENCE (IAXIS(1),IX),(IAXIS(2),IY),(IAXIS(3),IZ)
      DATA FFILTR(1)/ 0.0/,  FFILTR(2)/ 0.25/,  FFILTR(3)/ 0.5/
C
      IDWZAP = IN
C--READ THE REFLECTIONS  -  CHECK FOR AN E-MAP
1000  CONTINUE
      IF (NTYP .EQ. IEMAP) GOTO 1350
      IF(KFNR(0)) 1550,1100,1100
C--CHECK IF THIS MAP REQUIRES THAT /FC/ BE SET
1100  CONTINUE
      IF (NTYP .EQ. IPMAP) GOTO 1250
C--CHECK IF WE SHOULD APPLY THE REJECTION TEST
      IF (IALL .GT. 0) THEN
C----- CHECK FC GREATER THAN A FRATION OF FO, PLUS A RESIDUAL
      IF (ABS(STORE(M6+5))*SCALE .LT.
     1  0.001+ FFILTR(IALL)*ABS(STORE(M6+3))) GOTO 1000
      ENDIF
cdjwjul2010      check first twin element is unity
          LJXDJW = 1
          NKDJW=NINT(STORE(M6+11))  ! FIND THE ELEMENT FOR WHICH THE INDICES ARE GIVEN
          DO WHILE ( NKDJW .GT. 0 ) 
            NLDJW=NKDJW
            NKDJW=NKDJW/10
            LJXDJW=NLDJW-NKDJW*10
          END DO
          IF (LJXDJW .NE. 1)   GOTO 1000
cdjwjul2010 
C--SORT THE INDICES FOR THE DIFFERENT PROJECTIONS
1250  CONTINUE
      RFL(1)=STORE(M6)
      RFL(2)=STORE(M6+1)
      RFL(3)=STORE(M6+2)
C--SORT BACK
1300  CONTINUE
      STORE(M6)=RFL(IX)
      STORE(M6+1)=RFL(IY)
      STORE(M6+2)=RFL(IZ)
      KFOURC=0
      NORFL=NORFL+1
      RETURN
C
C--UNPACK THE E-MAP DATA
1350  CONTINUE
      CALL XIMTRA(MTE)
      IF ( STORE(MMTR) - 0.5 )  1600 , 1450 , 1450
1450  RFL(3)=AINT(0.0001*STORE(MMTR)+0.5)
      X=0.01*STORE(MMTR)-100.*RFL(3)
      RFL(2)=AINT(X+SIGN(0.5,X+0.1))
      X=100.*(X-RFL(2))
      RFL(1)=AINT(X+SIGN(0.5,X+0.1))
      N6D=N6D+1
C--CHECK IF THERE IS A SIN AND COSINE
      IF(ABS(STORE(MMTR+4))+ABS(STORE(MMTR+5))-0.000001)1350,1350,1500
1500  CONTINUE
      STORE(M6+3)=0.
      STORE(M6+4)=1.
      STORE(M6+5)=STORE(MMTR+2)*SQRT(STORE(MMTR+4)*STORE(MMTR+4)
     2 +STORE(MMTR+5)*STORE(MMTR+5))
      STORE(M6+6)=ATAN2(STORE(MMTR+5),STORE(MMTR+4))
      GOTO 1300
C
C--RESET POINTERS TO START OF REFLECTION LIST
1550  L6R=L6DUMP
      N6R=N6DUMP
      GOTO 1650
C--END OF THE E-MAP PROCESSING  -  REPOSITION THE TAPE
1600  CALL ESKIP(NE)
1650  CONTINUE
      KFOURC=-1
      RETURN
      END
C
CODE FOR XFPRT1
      SUBROUTINE XFPRT1
C--INITIALISATION PART OF THE FOURIER PRINTING ROUTINE
C
C  NCN  NUMBER OF CHARACTERS PER GRID NUMBER
C  NLINE   NUMBER OF LINES PER LINE OF THE MAP.
C  NCHAR   NUMBER OF CHARACTERS PER GRID NUMBER
C  NCHARC  NUMBER OF CHARACTERS PER NUMBER DOWN THE MARGINS
C  NSPACE  NUMBER OF SPACES AFTER THE NUMBER DOWN THE MARGIN (MIN 2)
C
C--USEAGE OF VARIABLES :
C
C  MA  NUMBER OF CHARACTERS PER GRID NUMBER.
C  MB  SMALLEST NUMBER THAT WILL NOT FIT INTO 'MA' CHARACTERS.
C  MC  LARGEST NUMBER THAT WILL NOT FIT INTO 'MA' CHARACTERS.
C  MD  NUMBER OF LINES PER ROW OF MAP
C  ME  ADDRESS OF THE MAP COORDINATES ACROSS THE TOP OF THE MAP.
C  MF  NUMBER OF CHARACTERS PER NUMBER DOWN THE MARGIN.
C  MG  NUMBER OF CHARACTERS AFTER A NUMBER DOWN THE MARGIN (MIN = 2).
C  MH  ADDRESS OF THE LAST PIECE OF MARGIN INFORMATION IN THE ARRAY AT '
C  MI  ADDRESS OF THE FIRST PIECE OF INFORMATION AFTER THE MARGIN IN THE
C  MJ  ADDRESS OF THE LINE OF STARS FOR THE NUMBERS AT THE TOP.
C  MK  ADDRESS OF THE LAST BLANK BEFORE THE FIRST '*' IN THE 'ME' ARRAY.
C      (I.E. MH-1).
C  ML  NUMBER OF CHARACTERS ACROSS A PAGE.
C  MM  ADDRESS OF THE BUFFER FOR A LINE OF CHARACTERS.
C  MN  SMALLEST NUMBER THAT WILL NOT FIT INTO 'MF' CHARACTERS.
C  MO  LARGEST NUMBER THAT WILL NOT FIT INTO 'MF' CHARACTERS.
C  MP  MAXIMUM NUMBER OF NUMBERS PER LINE THAT CAN BE PRINTED.
C  MQ  LAST WORD OF THE '*' ARRAY TO BE PRINTED ON THE CURRENT PAGE.
C  MR  LAST WORD OF THE NUMBERS ALONG 'Y' TO BE PRINTED FOR THE CURRENT
C  MS  FIRST WORD OF THE NUMBERS ALONG 'Y' FOR THE CURRENT PAGE.
C  MT  1  MARGIN CAN BE FITTED AT THE END OF THE CURRENT SET OF LINES.
C      0  NO MARGIN CAN BE FITTED IN.
C  MU  NUMBER OF CHARACTERS FOR THE CURRENT SET OF GRID POINTS ON A LINE
C  MV  OFFSET OF THE CURRENT FIRST NUMBER ALONG 'Y'.
C  MW  NUMBER OF GRID POINTS TO PRINT ON A LINE ON THIS PAGE.
C  MX  NUMBER OF GRID POINTS ALREADY PRINTED ON A LINE ON THE CURRENT PA
C  MY  NUMBER OF THE PASS THROUGH EACH SECTION.
C  MZ  NUMBER OF GRID POINTS ON EACH LINE LEFT.
C
C--
      INCLUDE 'FOURTP.INC'
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XFOURC.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XLISTI.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QFOURC.INC'
C
C
      EQUIVALENCE (IPAGE(1),NCHPIN),(IPAGE(2),NLNPIN)
      EQUIVALENCE (IPAGE(3),NCHPPG),(IPAGE(4),NLNPPG)
C
C--CHECK IF WE SHOULD SET UP THE PRINT VARIABLES
      IF(IPRINT)1150,1000,1000
C--SET UP THE DEFAULT LIST TYPE
1000  CONTINUE
      LN=8
      IREC=1100
C--SET UP THE GRID POINT NUMBERS
      MA=NCHAR
      MB=10**MA
      MC=-10**(MA-1)
      MD=NLINE
C--SET UP THE MARGIN PARAMETERS
      MF=NCHARC
      MN=10**MF
      MO=-10**(MF-1)
      MG=MAX0(2,NSPACE)
C--SET UP THE TOP OF PAGE NUMBERS
      ME=NFL
      MI=KCHNFL(MF+MG)
C--BLANK OUT THIS AREA
      CALL XMVSPD(IB,ISTORE(ME),MF+MG)
C--RECORD THE POSITION OF THE LAST PIECE OF MARGIN DATA
      MH=MI-1
C--RECORD THE POSITION LAST BLANK BEFORE THE '*'
      MK=MH-1
C--SET UP THE NUMBERS
      MJ=KCHNFL(JH*MA)
      L=JB
      I=MI
      DO 1050 M=1,JH
      L=MOD(L,JE)
      CALL XNUMB(L,I,MA,MB,MC)
      L=L+KG
1050  CONTINUE
C--SET UP THE LINE OF '*' TO PRINT UNDER THE NUMBERS
      I=MJ
      MM=KCHNFL(JH*MA+MG)
      DO 1100 M=1,JH
      CALL XMVSPD(IB,ISTORE(I),MA)
      I=I+MA
      CALL XMVSPD(IA,ISTORE(I-1),1)
1100  CONTINUE
C--A FINAL '*'
      CALL XMVSPD(IB,ISTORE(I),MG)
      I=I+MG
      CALL XMVSPD(IA,ISTORE(I-1),1)
C--SET UP THE LINE BUFFER
      ML=NCHPPG
      I=KCHNFL(ML)
C--COMPUTE THE MAXIMUM NUMBER OF GRID POINTS PER PAGE
      MP=MIN0(JH,(ML-MF-MG)/MA)
1150  CONTINUE
      RETURN
      END
C
CODE FOR XFPRT2
      SUBROUTINE XFPRT2
C--PRINT ROUTINE OF THE FOURIER  -  SECTION IS AT 'L81'
C
C--
      INCLUDE 'FOURTP.INC'
      INCLUDE 'ISTORE.INC'
C
C
      CHARACTER*16 CTYPE(10)
      CHARACTER*8 CWEIGH(4), CDENMN(2)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XFOURC.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLST14.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QFOURC.INC'
C
C
      EQUIVALENCE (IPAGE(1),NCHPIN),(IPAGE(2),NLNPIN)
      EQUIVALENCE (IPAGE(3),NCHPPG),(IPAGE(4),NLNPPG)
C
C
C
      DATA CDENMN / 'Negated ', '        ' /
      DATA CWEIGH / '    Main','     Sim','        ' , 'Weighted' /
      DATA CTYPE / 'Fobs - map' , 'FC - map' , 'Difference map' ,
     2             '2FO - FC map' , 'Optimal Fo map',
     2 'FO Patterson' ,
     3 'Fc Patterson', '(Fo-Fc)**2 Patt', '(FoSQ-FcSQ) Patt',
     4 'E - map' /
C
C
C--SET UP THE INITIAL FLAGS
      IF (KJ) 1000, 1050, 1000
C--FIRST SECTION  -  PRINT THE MAP TYPE
1050  CONTINUE
c      L=2*IABS(NWT)+1
c      K=L+1
c      J=NTYP+1
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1101)
      WRITE ( NCWU , 1100 ) CDENMN((NGMAP+3)/2),
     1 CWEIGH(NWT+3) , CTYPE(NTYP)
      WRITE(NCWU,1101)
1101  FORMAT(//)
      ENDIF
      WRITE ( CMON , 1100 ) CDENMN((NGMAP+3)/2),
     1 CWEIGH(NWT+3) , CTYPE(NTYP)
      CALL XPRVDU(NCVDU, 1,0)
1100  FORMAT ( ' Computed map is ',
     1   A,A, 1X , A )
1000   CONTINUE
C---- DO WE WANT A PRINT OUT
      IF (IPRINT) 2250, 1150, 1150
1150  CONTINUE
      MZ=JH
      MY=0
C--CHECK IF THERE IS MORE TO PRINT ON THIS SECTION
1200  CONTINUE
      IF(MZ)2200,2200,1250
C--PRINT THE NEXT PART OF THE CURRENT SECTION
1250  CONTINUE
      MY=MY+1
C--PRINT OUT THE PAGE HEADINGS
      M=NINT(STORE(L14+12)*STORE(L14+15))
      CALL XPRTCN
c      L=2*IABS(NWT)+1
c      K=L+1
c      J=NTYP+1
      IF (ISSPRT .EQ. 0) THEN
        WRITE (NCWU,1300) IXYZ,M,MY,CDENMN((NGMAP+3)/2),
     1                    CWEIGH(NWT+3),CTYPE(NTYP), SS, NV
      ENDIF
1300  FORMAT ( 1X,A1,' Down,  ',A1, ' Across,  ','Section at ',A1,
     2 ' = ' , I4, ', Part ', I2,/,A, A, 1X, A, 4X, 'Multiplied by',
     3 F11.3, 5X, 'Scan', I3, // )
C--COMPUTE THE NUMBER OF GRID POINTS PER LINE PRINTED ALREADY
      MX=JH-MZ
C--COMPUTE THE NUMBER TO PRINT THIS TIME
      MW=MIN0(MP,MZ)
C--COMPUTE THE NUMBER OF CHARACTERS ALREADY PRINTED
      MV=MX*MA
C--OMPUTE THE NUMBER OF CHARACTER TO PRINT ON ALINE THIS TIME
      MU=MW*MA
      MT=0
C--CHECK IF WE CAN FIT A MARGIN DOWN THE RIGHT HAND SIDE
      IF(2*(MF+MG)+MU-ML)1350,1350,1400
C--A MARGIN DOWN THE RIGHT WILL FIT
1350  CONTINUE
      MT=1
C--PRINT OUT THE INITIAL CAPTIONS ACROSS THE TOP OF THE PAGE
1400  CONTINUE
      MS=MI+MV
      MR=MS+MU-1
C--THE LINE OF NUMBERS WE REQUIRE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1450)(ISTORE(I),I=ME,MH),(ISTORE(I),I=MS,MR)
      ENDIF
1450  FORMAT(1H ,120A1)
C--AND NOW THE '*' UNDERNEATH
      MQ=MJ+MU-1
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1450)(ISTORE(I),I=ME,MK),IA,(ISTORE(I),I=MJ,MQ)
      ENDIF
C--NOW PRINT THE SECTION  -  A LINE AT A TIME
      M81=L81+MX
      I=JA
      DO NN=1,JG
        J=M81
        K=MM
        L=MOD(I,JD)
C--SET UP THE LEFT HAND MARGIN
        CALL XNUMB(L,K,MF,MN,MO)
        CALL XMVSPD(IB,ISTORE(K),MG)
        K=K+MG
        CALL XMVSPD(IA,ISTORE(K-1),1)
C--NOW LOOP OVER EACH GRID POINT TO BE PRINTED
        DO N=1,MW
C--CHECK IF THIS NUMBER IS BELOW THE ALLOWED MINIMUM
          IF(STORE(J)-THRES1)1550,1550,1500
C--CHECK IF THE NUMBER IS OVER THE MAXIMUM
1500      CONTINUE
          IF(STORE(J)-THRES2)1600,1550,1550
C--NUMBER IS OUT OF RANGE  -  OUTPUT BLANKS
1550      CONTINUE
          CALL XMVSPD(IB,ISTORE(K),MA)
          K=K+MA
          GOTO 1650
C--NUMBER CAN BE PRINTED
1600      CONTINUE
          M=NINT(STORE(J))
          CALL XNUMB(M,K,MA,MB,MC)
C--UPDATE FOR THE NEXT POINT
1650      CONTINUE
          J=J+1
        END DO
C--CHECK FOR A RIGHT HAND MARGIN
        IF(MT)1800,1800,1750
C--RIGHT MARGIN REQUIRED
1750  CONTINUE
        CALL XMVSPD(IB,ISTORE(K),MG)
        K=K+MG
        CALL XMVSPD(IA,ISTORE(K-1),1)
        CALL XNUMB(L,K,MF,MN,MO)
C--CHECK IF MORE THAN ONE LINE IS REQUIRED PER ROW
1800  CONTINUE
        IF(MD-1)1950,1950,1850
C--OUTPUT SOME BLANK LINES
1850    CONTINUE
        DO J=2,MD
          IF (ISSPRT .EQ. 0) WRITE(NCWU,1450)
        END DO
C--PRINT THE CURRENT LINE
1950    CONTINUE
        K=K-1
        IF (ISSPRT .EQ. 0) WRITE(NCWU,1450)(ISTORE(J),J=MM,K)
        M81=M81+MD8
        I=I+KF
      END DO
C--CHECK FOR MORE THAN ONE PER ROW
      IF(MD-1)2150,2150,2050
C--PRINT THE BLANK LINES
2050  CONTINUE
      DO J=2,MD
        IF (ISSPRT .EQ. 0) WRITE(NCWU,1450)
      END DO
C--CAPTIONS AT THE BOTTOM OF THE PAGE
2150  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1450)(ISTORE(J),J=ME,MK),IA,(ISTORE(J),J=MJ,MQ)
      ENDIF
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1450)(ISTORE(J),J=ME,MH),(ISTORE(J),J=MS,MR)
      ENDIF
      MZ=MZ-MW
      GOTO 1200
C--END OF THIS SECTION
2200  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1450)
      ENDIF
2250  CONTINUE
      RETURN
      END
C
CODE FOR XNUMB
      SUBROUTINE XNUMB(NUMBER,IADD,N,MAX,MIN)
C--CONVERT A NUMBER TO ALPHA-NUMERIC AND STORE IT
C
C  NUMBER  THE NUMBER TO CONVERT
C  IADD    THE ADDRESS IN STORE AT WHICH TO PLACE IT  (UPDATED ON RETURN
C  N       THE NUMBER OF DIGITS REQUIRED.
C  MAX     THE SMALLEST NUMBER THAT WILL NOT FIT.
C  MIN     THE LARGEST NUMBER THAT WILL NOT FIT.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XCHARS.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CHECK IF THE NUMBER IS IN RANGE
      IF(NUMBER-MAX)1050,1000,1000
C--NUMBER IS TOO LARGE  -  OUTPUT 'N' PLUSES
1000  CONTINUE
      CALL XMVSPD(IPLUS,ISTORE(IADD),N)
      GOTO 1350
C--CHECK IF IT IS TOO SMALL
1050  CONTINUE
      IF(NUMBER-MIN)1100,1100,1150
C--THE NUMBER IS TOO SMALL
1100  CONTINUE
      CALL XMVSPD(MINUS,ISTORE(IADD),N)
      GOTO 1350
C--OUTPUT THE NUMBER
1150  CONTINUE
      L=IADD+N-1
      CALL XMVSPD(IB,ISTORE(IADD),N)
      I=IABS(NUMBER)
C--LOOP OVER EACH DIGIT
      DO 1200 M=1,N
      J=I/10
      K=I-J*10
      I=J
      CALL XMOVE(NUMB(K+1),ISTORE(L),1)
      L=L-1
C--CHECK IF THE NUMBER IS NOW ZERO
      IF(I)1200,1250,1200
1200  CONTINUE
C--CHECK THE SIGN OF THE ORIGINAL NUMBER
1250  CONTINUE
      IF(NUMBER)1300,1350,1350
C--OUTPUT A MINUS
1300  CONTINUE
      CALL XMVSPD(MINUS,ISTORE(L),1)
C--AND NOW RETURN
1350  CONTINUE
      IADD=IADD+N
      RETURN
      END
C
CODE FOR ESKIP
      SUBROUTINE ESKIP(NE)
C--POSITION THE INPUT E-TAPE FOR SOLUTION 'NE'
C
C--
      INCLUDE 'STORE.INC'
      INCLUDE 'XTAPES.INC'
      INCLUDE 'XTAPED.INC'
C
C--REWIND THE INPUT TAPE AND READ THE FIRST BLOCK
      CALL XIMTR(MTE)
      J=NE
C--DECREMENT THE NUMBER OF FILES TO BE SKIPPED
1000  CONTINUE
      J=J-1
      MMTR=NMTR
C--CHECK FOR THE END
      IF(J)1100,1100,1050
C--READ THE NEXT REFLECTION
1050  CONTINUE
      CALL XIMTRA(MTE)
      IF(STORE(MMTR)-0.5)1000,1050,1050
C--AND NOW RETURN
1100  CONTINUE
      RETURN
      END
C
CODE FOR XFSWOP
      SUBROUTINE XFSWOP(A,IDIM,ISTEP1,MD1,NBLOCK)
C--INTERCHANGE THE DATA IN THE ARRAY 'A', USING THE LIST 14 INTERCHANGE
C  DIRECTIVES. THE RESULTS ARE WRITTEN BACK TO 'A', AND THE LOCATIONS
C  FROM 'STORE(NFL)' ONWARDS ARE USED AS INTERMEDIATE STORAGE.
C
C  A       ARRAY HOLDING THE DATA TO BE SORTED.
C  IDIM    THE DIMENSION OF THE ARRAY 'A'. THIS IS NOT NECESSARILY
C          'MD1*NBLOCK', AS THE DATA MAY BE ARRANGED DIFFERENTLY, FOR
C          EXAMPLE IN LIST 14, WHERE 'ISTEP1' IS 6 WHILE 'MD1' IS 1.
C  ISTEP1  INCREMENT BETWEEN SUCCESSIVE ELEMENTS IN A BLOCK.
C  MD1     INCREMENT BETWEEN SUCCESSIVE BLOCKS.
C  NBLOCK  NUMBER OF BLOCKS OF DATA TO SORT.
C
C--THE DATA ARE PRESUMED TO FORM A CONTINUOUS BLOCK WHOSE TOTAL LENGTH
C  BEFORE AND AFTER SWOPPING IS '3*NBLOCK'.
C
C--
C
C
      DIMENSION A(IDIM)
C
      INCLUDE 'XFOURC.INC'
      INCLUDE 'STORE.INC'
C
      I=3*NBLOCK
      CALL XSWOP(IAXIS,A,IDIM,ISTEP1,MD1,STORE(NFL),I,ISTEP1,MD1,
     2 NBLOCK)
      CALL XMOVE(STORE(NFL),A(1),I)
      RETURN
      END
C
CODE FOR XSWOP
      SUBROUTINE XSWOP(IAXIS,A,IDIM1,ISTEP1,MD1,B,IDIM2,ISTEP2,MD2,
     2  NBLOCK)
C--ROUTINE TO APPLY THE SORT DIRECTIVES IN 'IAXIS' TO THE DATA IN 'A',
C  AND OUTPUT THE RESULTS IN 'B'.
C
C  IAXIS(1)  COMPONENT OF 'A' TO BE TAKEN FIRST.
C  IAXIS(2)  COMPONENT OF 'A' TO BE TAKEN SECOND.
C  IAXIS(3)  COMPONENT OF 'A' TO BE TAKEN THIRD.
C  A         ARRAY HOLDING THE INPUT DATA.
C  IDIM1     THE DIMENSION OF 'A'.
C  ISTEP1    INCREMENT BETWEEN SUCCESSIVE INPUT ELEMENTS IN A BLOCK.
C  MD1       INCREMENT BETWEEN SUCCESSIVE BLOCKS OF DATA IN 'A'.
C  B         ARRAY TO HOLD THE RESULTS
C  IDIM2     THE DIMENSION OF 'B'.
C  ISTEP2    INCREMENT BETWEEN SUCCESSIVE OUTPUT ELEMENTS IN A BLOCK.
C  MD2       INCREMENT BETWEEN SUCCESSIVE OUTPUT BLOCKS.
C  NBLOCK    NUMBER OF BLOCKS OF DATA TO PROCESS.
C
C--
C
C
      DIMENSION A(IDIM1),B(IDIM2),IAXIS(3),IXX(3)
C
C--COMPUTE THE CORRECT SORTED INCREMENTS
      DO 1000 K=1,3
      IXX(K)=(IAXIS(K)-1)*ISTEP1
1000  CONTINUE
      I=1
      J=1
C--PROCESS SUCCESSIVE BLOCKS
      DO 1100 K=1,NBLOCK
      M=J
C--LOOP OVER EACH COORDINATE
      DO 1050 L=1,3
      N=I+IXX(L)
      CALL XMOVE(A(N),B(M),1)
      M=M+ISTEP2
1050  CONTINUE
      I=I+MD1
      J=J+MD2
1100  CONTINUE
      RETURN
      END
C
CODE FOR XUSWOP
      SUBROUTINE XUSWOP(IAXIS,B,IDIM2,ISTEP2,MD2,A,IDIM1,ISTEP1,MD1,
     2  NBLOCK)
C--ROUTINE TO UNSWOP DATA FROM A FOURIER
C
C  IAXIS(1)  COMPONENT OF 'A' TO BE TAKEN FIRST.
C  IAXIS(2)  COMPONENT OF 'A' TO BE TAKEN SECOND.
C  IAXIS(3)  COMPONENT OF 'A' TO BE TAKEN THIRD.
C  B         ARRAY TO HOLD THE INPUT DATA TO BE UNSORTED
C  IDIM2     THE DIMENSION OF 'B'.
C  ISTEP2    INCREMENT BETWEEN SUCCESSIVE OUTPUT ELEMENTS IN A BLOCK.
C  MD2       INCREMENT BETWEEN SUCCESSIVE OUTPUT BLOCKS.
C  A         ARRAY HOLDING THE RESULTS.
C  IDIM1     THE DIMENSION OF 'A'.
C  ISTEP1    INCREMENT BETWEEN SUCCESSIVE INPUT ELEMENTS IN A BLOCK.
C  MD1       INCREMENT BETWEEN SUCCESSIVE BLOCKS OF DATA IN 'A'.
C  NBLOCK    NUMBER OF BLOCKS OF DATA TO PROCESS.
C
C--
C
C
      DIMENSION A(IDIM1),B(IDIM2),IAXIS(3),IXX(3)
C
C--COMPUTE THE CORRECT SORTED INCREMENTS
      DO 1000 K=1,3
      IXX(K)=(IAXIS(K)-1)*ISTEP1
1000  CONTINUE
      I=1
      J=1
C--PROCESS SUCCESSIVE BLOCKS
      DO 1100 K=1,NBLOCK
      M=J
C--LOOP OVER EACH COORDINATE
      DO 1050 L=1,3
      N=I+IXX(L)
      CALL XMOVE(B(M),A(N),1)
      M=M+ISTEP2
1050  CONTINUE
      I=I+MD1
      J=J+MD2
1100  CONTINUE
      RETURN
      END
C
C
C
C
C
C
CODE FOR KFRRSN
      FUNCTION KFRRSN ( GRID, COORD1,COORD2,COORD3, IPRINT)
C -- THIS FUNCTION CHECKS IF IT IS REASONABLE TO HAVE A FOURIER PEAK
C    AT THE POSITION GIVEN BY THE LOCAL COORDINATE 'GRID'
C
C    INPUT:
C      GRID      LOCAL COORDS, IN RANGE +/-1
C      IPRINT    0 = NO PRINT
C      COORD       X,Y,Z COORDINATES OF PEAK TO BE TESTED, IN AN ARRAY
C                    WITH THREE ELEMENTS
C
C    RETURN VALUE:
C      -1          PEAK IS UNREASONABLE
C       1          PEAK IS REASONABLE
C
C
      DIMENSION GRID(3)
C
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
C
      DATA AXSMIN / -1.1 /
      DATA AXSMAX /  1.1 /
C
C
      KFRRSN = 1
C
      DO I = 1 , 3
        IF ( GRID(I) .LT. AXSMIN ) KFRRSN = -1
        IF ( GRID(I) .GT. AXSMAX ) KFRRSN = -1
      END DO
C
C
      IF ( KFRRSN .LT. 0 ) THEN
       IF (ISSPRT .EQ. 0) WRITE(NCWU,2005) COORD1,COORD2,COORD3
       IF (IPRINT .GT. 0 ) THEN
        WRITE ( CMON ,2005) COORD1,COORD2,COORD3
        CALL XPRVDU(NCVDU, 1,0)
       ENDIF
2005   FORMAT(1X,'Malformed peak at ', 3F10.4)
      ENDIF
C
C
      RETURN
      END



CODE FOR XMASK
      SUBROUTINE XMASK(INTERN)
C
C--
      PARAMETER (NPROCS = 16)
      DIMENSION PROCS(NPROCS)
      CHARACTER CSRQ*80
      INCLUDE 'STORE.INC'
      INCLUDE 'QSTORE.INC'
      INCLUDE 'ISTORE.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XTAPES.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XLST02.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLST06.INC'
      INCLUDE 'XLST14.INC'
      INCLUDE 'XLST12.INC'
      INCLUDE 'ICOM12.INC'
      INCLUDE 'XLST23.INC'
      INCLUDE 'XLST29.INC'
      INCLUDE 'XDSTNC.INC'
      INCLUDE 'XLST42.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'TSSCHR.INC'
      INCLUDE 'XSSCHR.INC'
      INCLUDE 'UFILE.INC'
      INCLUDE 'XPDS.INC'
      INCLUDE 'XLIMIT.INC'
      COMMON /XMASKD/ IMSKOP,ITYP05,ILIMIT,XMIN,XDIVS,XMAX,YMIN,
     1 YDIVS,YMAX,ZMIN,ZDIVS,ZMAX,IATRAD,ATMULT,ATCNST,ATVOID
      DIMENSION IDIVS(3)
      DIMENSION IIND3(3)
      DIMENSION STEPS(3)
      DIMENSION XJ(3)
      DIMENSION X(10), XO(10), KEY(9), COEF(9)

      INCLUDE 'ICOM42.INC'

      EQUIVALENCE (IMSKOP, PROCS(1))
      INCLUDE 'QLST42.INC'

#if !defined(_HOL_) 
      DATA IPEAK/'Q   '/
#else
      DATA IPEAK/4HQ   /


#endif
      INCLUDE 'IDIM42.INC'


C--INITIALISE THE TIMING FUNCTION
      CALL XTIME1(1)

C--READ THE DATA
      ISTAT = KRDDPV ( PROCS, NPROCS)
      IF ( ISTAT .LT. 0 ) GO TO 9910
      CALL XRSL
      CALL XCSAE

C--LOAD LISTS ONE, TWO, FIVE, TWENTY-NINE AND FORTY

      IF ( KEXIST(1) .LT. 1 ) GOTO 9900
      IF ( KEXIST(2) .LT. 1 ) GOTO 9900
      IF ( KEXIST(5) .LT. 1 ) GOTO 9900
      IF ( KEXIST(29) .LT. 1 ) GOTO 9900
      
      IF (KHUNTR ( 1,0,IADDL,IADDR,IADDD,-1) .LT. 0) CALL XFAL01
      IF (KHUNTR ( 2,0,IADDL,IADDR,IADDD,-1) .LT. 0) CALL XFAL02
      IF (KHUNTR ( 5,0,IADDL,IADDR,IADDD,-1) .LT. 0) CALL XFAL05
      IF (KHUNTR (23,0,IADDL,IADDR,IADDD,-1) .LT. 0) CALL XFAL23
      IF (KHUNTR (29,0,IADDL,IADDR,IADDD,-1) .LT. 0) CALL XFAL29
      IF ( IERFLG .LT. 0 ) GO TO 9900

      STOLER = STORE(L23SP+5)
      I = KSPINI( -1, STOLER)

      IF ( ( ILIMIT .EQ. -1 ) .AND. 
     1  ( KEXIST(42) .GE. 1 ) )THEN ! Use existing L42.
C -- Load existing list forty-two:
        IF (KHUNTR (42,0,IADDL,IADDR,IADDD,-1) .LT. 0) CALL XFAL42
        IF ( IERFLG .LT. 0 ) GO TO 9900
        WRITE(CMON,'(A)')'Loaded existing List 42'
        CALL XPRVDU(NCVDU,1,0)
        DO I = 0,2
            WRITE(CMON,'(4(A,F8.3),A)')
     1      'Limits are', STORE(L42L+I*3),
     2      ' to ',STORE(L42L+I*3+2),
     2      ' in ',STORE(L42L+I*3+1),' steps of ',
     3      ((STORE(L42L+I*3+2)-STORE(L42L+I*3))/
     3      STORE(L42L+I*3+1))*STORE(L1P1+I), ' Angstrom.'
            CALL XPRVDU(NCVDU,1,0)                     
            IDIVS(I+1) = NINT(STORE(L42L+I*3+1))
          END DO
      ELSE
C -- C R E A T E   A   N E W   L I S T   4 2:
        IRCZAP = -1
        CALL XFILL (IRCZAP, ICOM42, IDIM42)
        N42L = 1
        N42M = 1            
        N42V = 1
        CALL XCELST ( 42, ICOM42, IDIM42 )

        WRITE(CMON,'(A,2(/6I9))') 'ICOM42:',(ICOM42(I),I=1,12)
        CALL XPRVDU(NCVDU,3,0)

C -- Set limits
        L42L = KCHLFL(MD42L) !Increase storage for L42L record

        IF ( ILIMIT .EQ. 0 ) THEN
          CALL XMOVE(PROCS(4), STORE(L42L), 9)
          DO I = 0,2
            WRITE(CMON,'(3(A,F8.3),A)')
     1      'Limits are', STORE(L42L+I*3),
     2      ' to ',STORE(L42L+I*3+2),
     2      ' in ',STORE(L42L+I*3+1), ' steps.'
            CALL XPRVDU(NCVDU,1,0)
            IDIVS(I+1) = NINT(STORE(L42L+I*3+1))
          END DO

        ELSE
          IF ( ILIMIT .EQ. -1 ) THEN
            WRITE(CMON,'(A/A)')
     1      'Could not load any existing mask data (L42)',
     2      'Using Fourier limits (L14).'
            CALL XPRVDU(NCVDU,2,0)
          END IF

          IF (KHUNTR ( 14,0,IADDL,IADDR,IADDD,-1) .LT. 0) CALL XFAL14

          IF ( ILIMIT .EQ. 2 ) THEN   ! Modified L14, use limits, but
                                      ! get resolution from command line.
            DO I = 0,2
              STORE(L14+1+I*MD14) = PROCS(5+I*3)
            END DO
          END IF

          DO I = 0,2
            STORE(L42L+I*3)   = STORE(L14+I*MD14)
            STORE(L42L+I*3+2) = STORE(L14+I*MD14+2)
            RANGE = ABS(STORE(L42L+I*3+2)-STORE(L42L+I*3))
            ARANGE = STORE(L1P1+I)*RANGE
            STORE(L42L+I*3+1)=NINT(0.49999+(ARANGE/STORE(L14+I*MD14+1)))
            WRITE(CMON,'(3(A,F8.3),A)')
     1      'Limits are', STORE(L42L+I*3),
     2      ' to ',STORE(L42L+I*3+2),
     2      ' in ',STORE(L42L+I*3+1), ' steps.'
            CALL XPRVDU(NCVDU,1,0)
            IDIVS(I+1) = NINT(STORE(L42L+I*3+1))
          END DO

        ENDIF

        N42M = IDIVS(1) * IDIVS(2) * IDIVS(3)
c        N42V = N42M  ! Not needed yet

        IF ( NFL + N42M + N42V .GT. LFL ) GOTO 9920

        L42M = KCHLFL(N42M) !Increase storage for L42M records
        L42V = KCHLFL(N42V) !Increase storage for L42V records

        IRCZAP = -1
        CALL XFILL (IRCZAP, ISTORE(L42M), N42M)


        ISTAT = KHUNTR(42,101,IADDL,IADDR,IADDD,-1)
        IF ( ISTAT.NE.0 ) GOTO 9900
        ISTORE(IADDR+3) = L42L   ! Change header pointer to new data

        ISTAT = KHUNTR(42,102,IADDL,IADDR,IADDD,-1)
        IF ( ISTAT.NE.0 ) GOTO 9900
        ISTORE(IADDR+3) = L42M   ! Change header pointer to new data

        ISTAT = KHUNTR(42,103,IADDL,IADDR,IADDD,-1)
        IF ( ISTAT.NE.0 ) GOTO 9900
        ISTORE(IADDR+3) = L42V   ! Change header pointer to new data

      ENDIF

      DO I = 0,2
       STEPS(I+1)= (STORE(L42L+I*3+2)-STORE(L42L+I*3))/STORE(L42L+I*3+1)
      END DO
C Set up matrix for mapping indices onto the MASK and VALUE arrays.
      IIND3(1) = 1
      IIND3(2) = IDIVS(1)
      IIND3(3) = IDIVS(2) * IDIVS(1)

      WRITE(CMON,'(A,3I8)') 'Divisions:',(IDIVS(I),I=1,3)
      CALL XPRVDU(NCVDU,1,0)
      WRITE(CMON,'(A,3I8)') 'Index matrix:',(IIND3(I),I=1,3)
      CALL XPRVDU(NCVDU,1,0)
      WRITE(CMON,'(A,3F15.8)') 'Steps:',(STEPS(I),I=1,3)
      CALL XPRVDU(NCVDU,1,0)

C Branch on type of operation (IMSKOP)
C   0 - ACCESSIBLE  Mark 1 all solvent accessible areas. Assume all zeroes
C                      and put ones where solvent might fit.
C   1 - OUTSIDE     Mark 1 all areas outside molecules. Assume all ones
C                      and put zeroes inside the atoms.
C   2 - INSIDE      Mark 1 all areas inside molecules. Assume all zeroes
C                      and put ones inside the atoms.
C   3 - CLOSETO     Mark 1 all areas just outside molecules.
C                   Assume all zeroes, put ones inside (atom+voidatom)
C                   radius, then zeroes inside the atoms.
C   4 - SHRINK      Change limits to trim any layers with all zeroes in MASK.
C   5 - SHOW        Extend L5 with QH peaks corresponding to ones in MASK.
C   6 - SETFC       Set FC and phase in L6 to Fourier transform of MASK.

      IF ( IMSKOP .LE. 3 ) THEN ! All masking cases start here.

         MASKIN = 1  ! Inside molecule
         MASKOU = 0  ! Outside molecule
         MASKST = 0  ! Initial value for whole array

         IF ( IMSKOP .EQ. 1 ) THEN
           MASKIN = 0
           MASKOU = 1
           MASKST = 1
         END IF


C Run through grid, mask areas as inside or outside the molecule, given
C the tolerances supplied.

         JU = NFL       ! Next free memory location
         NFL = NFL + 5

         JT=12
         AT = 0.5
         AC = 4.0
         BT = 0.      ! NO ANGLES TO BE LOOKED FOR
         BC = 0.    

         IDIM12=40    ! USE A NULL LIST 12.
         DO I=1,IDIM12
          ICOM12(I)=NOWT
         END DO
         L12=-1
         M12=-1


         I29=L29 + (N29-1)*MD29
         I5 = L5 + (N5-1)*MD5
         DO M5=L5,I5,MD5       ! SCAN LIST 5 SETTING SPARE TO VDW/COV RADIUS
           IFOUND = 0
           DO M29= L29,I29,MD29
             JZ=M29+IATRAD
             IF (ISTORE(M5) .EQ. ISTORE(M29)) THEN
               STORE(M5+13) = STORE(JZ)
               IFOUND = 1
             END IF
           END DO
           IF ( IFOUND .EQ. 0 ) THEN
             IF ( ISTORE(M5) .EQ. IPEAK ) THEN
               STORE(M5+13) = 0.0
               if (issprt .eq. 0) then
                 WRITE(CMON,'(3A)')'Atom type: ',ISTORE(M5),
     2           ' ignored.'
               endif
             ELSE IF ( IATRAD .EQ. 1 ) THEN
               STORE(M5+13) = 0.77
               if (issprt .eq. 0) then
                 WRITE(CMON,'(3A)')'Atom type: ',ISTORE(M5),
     2           ' not in LIST 29 - using COV radius of 0.77A'
               endif
             ELSE
               STORE(M5+13) = 1.78
               if (issprt .eq. 0) then
                 WRITE(CMON,'(3A)')'Atom type: ',ISTORE(M5),
     2           ' not in LIST 29 - using VDW radius of 1.78A'
               endif
             END IF
           END IF
         END DO


         CALL XDIST2 ! LOAD LISTS 1 AND 2, AND SET UP SOME CONSTANTS

C-------SET UP A FEW STACK CONSTANTS
         JB=NFL
         JC=JB+MD5
         JD=JC+20
         JE=JD+30
         IF ( JE .GE. LFL ) GOTO 9930  ! CHECK THE STORE AREA

         AO = AC        ! FIX THE RADII FOR 1-2 CONTACTS
         AP = AC * AC

         IABAT=NFL   ! SET THE TARGET ATOM ADDRESSES
         M5A = IABAT
         NFL=NFL+6
         STORE(IABAT+2)=1.0
         STORE(IABAT+3)=.05


         CALL XFILL (MASKST, ISTORE(L42M), N42M) !Outside by default

         NNZ = 0
         NNZS = 0

C----- LOOP OVER ALL SECTIONS
         DO IZSECT = 0, IDIVS(3)-1
           STORE(IABAT+6) = STORE(L42L+6) + STEPS(3) * IZSECT
           CALL SLIDER(IZSECT,IDIVS(3)-1)
           DO IXSECT = 0, IDIVS(1)-1
             STORE(IABAT+4) = STORE( L42L ) + STEPS(1) * IXSECT
             DO IYSECT = 0, IDIVS(2)-1
               STORE(IABAT+5) = STORE(L42L+3) + STEPS(2) * IYSECT
C GET ADDRESS of THIS POINT in L42M array.
               M42M=L42M+IXSECT+IIND3(2)*IYSECT+IIND3(3)*IZSECT

               M5=L5  ! RESET THE CONTACT ATOM
               NFL=JE ! RESET BEGINNING OF DISTANCE STACK TO JE EVERY TIME
               JFNVC = 0
               ITRANS = 1
               NDIST = KDIST1( N5, JL, JT, JFNVC, 0, ITRANS, 0, 4, 0)
c                WRITE(CMON,'(A,3I4,A,I5)') 'Point ',
c     1           IZSECT,IXSECT,IYSECT,' bonds: ',NDIST
c                CALL XPRVDU(NCVDU,1,0)
               NBONDS = NDIST
               IF ( IMSKOP .NE. 0 ) THEN ! Simple inside/outside atom.
                  DO K = JE, JE+(JT*(NBONDS-1)),JT
                    IAD5 = ISTORE(K)
                    IF ( ISTORE(IAD5) .NE. IPEAK ) THEN
                      IF ( IMSKOP .EQ. 3 ) THEN
                         IF ( STORE(K+10) .LT.
     1    STORE(ISTORE(K)+13) * ATMULT + ATCNST ) THEN   ! Inside molecule
                             ISTORE(M42M) = MASKOU
                             EXIT
                          ELSE IF ( STORE(K+10) .LT.
     1    STORE(ISTORE(K)+13) * ATMULT + ATCNST + ATVOID ) THEN   ! Close to molecule
                             ISTORE(M42M) = MASKIN
                          END IF
                      ELSE IF ( STORE(K+10) .LT.
     1    STORE(ISTORE(K)+13) * ATMULT + ATCNST ) THEN   ! Inside molecule
                         ISTORE(M42M) = MASKIN
                         EXIT
                      END IF
                    END IF
                  END DO
               ELSE ! Solvent accessible region
                  IACCES = 1
                  DO K = JE, JE+(JT*(NBONDS-1)),JT
                    IAD5 = ISTORE(K)
                    IF ( ISTORE(IAD5) .NE. IPEAK ) THEN
c                    WRITE(CMON,'(A,F8.3)')'Inaccessible distance: ',
c     1        STORE(ISTORE(K)+13) * ATMULT + ATCNST + ATVOID
c                   CALL XPRVDU(NCVDU,1,0)
                      IF ( STORE(K+10) .LT.
     1    STORE(ISTORE(K)+13) * ATMULT + ATCNST + ATVOID ) THEN   ! Inaccessible
                        IACCES = 0
                        EXIT
                      END IF
                    END IF
                  END DO
                  IF ( IACCES .EQ. 1 ) THEN ! Set surrounding points to MASKIN.
C If we are doing accessible volume and no contacts to this point,
C then need to set MASKIN for this point, and all points within a
C radius of ATVOID
                    ISTORE(M42M) = 1
C Work out steps equivalent to ATVOID in each axial direction.
                    JXSTPS = NINT(.5+(ATVOID /(STORE(L1P1)*STEPS(1))))
                    JYSTPS = NINT(.5+(ATVOID /(STORE(L1P1+1)*STEPS(2))))
                    JZSTPS = NINT(.5+(ATVOID /(STORE(L1P1+2)*STEPS(3))))
C Truncate wrt edges of mask region.
                    JXMIN = MAX(0,IXSECT-JXSTPS)
                    JYMIN = MAX(0,IYSECT-JYSTPS)
                    JZMIN = MAX(0,IZSECT-JZSTPS)
                    JXMAX = MIN(IDIVS(1)-1,IXSECT+JXSTPS)
                    JYMAX = MIN(IDIVS(2)-1,IYSECT+JYSTPS)
                    JZMAX = MIN(IDIVS(3)-1,IZSECT+JZSTPS)

                    NTOT=(JXMAX-JXMIN+1)*(JYMAX-JYMIN+1)*(JZMAX-JZMIN+1)

C For each included point test distance to central point vs ATVOID.
                    DO JZSECT = JZMIN,JZMAX
                      XJ(3) = STORE(L42L+6) + STEPS(3) * JZSECT
                      DO JXSECT = JXMIN,JXMAX
                        XJ(1) = STORE( L42L ) + STEPS(1) * JXSECT
                        DO JYSECT = JYMIN,JYMAX
                          J42M=L42M+JXSECT+IIND3(2)*JYSECT+
     1                              IIND3(3)*JZSECT
                          IF ( ISTORE(J42M) .EQ. 0 ) THEN
                            XJ(2) = STORE(L42L+3) + STEPS(2) * JYSECT
C Test distance.
                            IF (XDSTN2(STORE(IABAT+4),XJ)
     1                                           .LT.ATVOID**2) THEN
                              ISTORE(J42M) = MASKIN
                            END IF
                          END IF
                        END DO
                      END DO
                    END DO
                  END IF
               END IF

C If mask is set, do special position calc
               IF ( ISTORE( M42M ) .NE. 0 ) THEN
                 NNZ = NNZ + 1
C X,XO,KEY & COEF are used/set by KSPGET, and need not be initialised.
C MGM is 1/occ. M5S points to atom record.
C -1 tells it not to update parameters.
C JUNK is the number that were updated.
C Return value = -1 if on a special position.
                 IF (KSPGET(X,XO,KEY,COEF,MGM,IABAT,1,JUNK).LE.0) THEN
                   NNZS = NNZS + 1
                   ISTORE( M42M )  = MGM
                 END IF
               END IF
C-------JK IS CURRENT NEXT FREE ADDRESS - SAVE AND SET LAST ENTRY
               NFL = JL
               JK = JL - JT
             END DO
           END DO
         END DO

         WRITE(CMON,'(4X,I7,A)') NNZ, ' points set in the mask'
         CALL XPRVDU(NCVDU,1,0)
         IF ( NNZS .GT. 0 ) THEN
           WRITE(CMON,'(4X,A,I7,A)') ' including ',
     1                        NNZS, ' on or near special positions.'
           CALL XPRVDU(NCVDU,1,0)
         END IF

      ELSE IF ( IMSKOP .EQ. 4 ) THEN
C Shrink the storage.
C Not done yet.
         WRITE(CMON,'(4X,A)') 'Shrink storage feature not implemented.'
         CALL XPRVDU(NCVDU,1,0)
      ELSE IF ( IMSKOP .EQ. 5 ) THEN
C Show the mask as a series of QH peaks.
         NNZ = 0
         CALL XSSRQ(IADSRQ,NSRQ)   ! Save current SRQ.
         DO IZSECT = 0, IDIVS(3)-1
           CALL SLIDER(IZSECT,IDIVS(3)-1)
           RZ = STORE(L42L+6) + STEPS(3) * IZSECT
           DO IXSECT = 0, IDIVS(1)-1
             RX = STORE( L42L ) + STEPS(1) * IXSECT
             DO IYSECT = 0, IDIVS(2)-1
               RY = STORE(L42L+3) + STEPS(2) * IYSECT
C GET ADDRESS of THIS POINT in L42M array.
               M42M=L42M+IXSECT+IIND3(2)*IYSECT+IIND3(3)*IZSECT

               IF ( ISTORE(M42M) .NE. 0 ) THEN
                  NNZ = NNZ + 1
                  IF( NNZ .EQ. 1 ) THEN ! Write header to SRQ
                    WRITE(CSRQ,'(A)')'#EDIT'
                    CALL XISRC(CSRQ)
                  END IF

                  WRITE(CSRQ,'(A,I5,5(1X,F11.6))')'ATOM R ', NNZ, 
     2               1.0,1.0, RX, RY, RZ
                  CALL XISRC(CSRQ)
               END IF
             END DO
           END DO
         END DO
         IF (NNZ.GT.0) THEN
            WRITE(CSRQ,'(A)')'END'
            CALL XISRC(CSRQ)
         END IF

         WRITE(CMON,'(4X,I7,A)') NNZ, ' points added to atom list.'
         CALL XPRVDU(NCVDU,1,0)

         CALL XRSRQ(IADRSQ,NSRQ)   !Reinstate previous SRQ

      ELSE IF ( IMSKOP .EQ. 6 ) THEN
C Set Fc and phase in L6 based on current mask.
         IULN = KTYP06(1)   ! 1=L6, 2=L7.
         CALL XFAL06(IULN,1)   ! Load list 6, ready for updating.
         DO WHILE ( KFNR(1) .GE. 0 )
           CALL XMASKF ( FA, FB, STORE(M6), STORE(M6+16), 0 ) 
           STORE(M6+5)= SQRT( FA**2 + FB**2 )
           STORE(M6+6)= ATAN2( FB, FA )
           CALL XSLR(1)   ! Store last reflection
           CALL XACRT(6)  ! Keep running totals for FC
           CALL XACRT(7)  ! Keep running totals for phase
         END DO
         CALL XERT(IULN)  ! Write updated L6 to disk.
         WRITE(CMON,'(4X,A)') 'Fc values in L6 updated to FT of mask.'
         CALL XPRVDU(NCVDU,1,0)
      END IF

1111  CONTINUE

      CALL XWLSTD (42,ICOM42,IDIM42,-1,-1)


3350  CONTINUE
      CALL XOPMSG (IOPBND, IOPEND, 201)
      CALL XTIME2(1)
      RETURN
C
9900  CONTINUE
C -- ERRORS
      CALL XOPMSG ( IOPBND , IOPABN , 0 )
      GOTO 3350
9910  CONTINUE
C -- INPUT ERROR
      CALL XOPMSG ( IOPBND , IOPCMI , 0 )
      GO TO 9900
9920  CONTINUE
C -- NOT ENOUGH STORE
      WRITE ( CMON, 9925 )
      CALL XPRVDU(NCVDU, 1,0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU, '(A)') CMON( 1)(:)
9925  FORMAT ( 1X ,
     1'Not enough stack to allocate the resolution of mask specified' )
      CALL XERHND ( IERERR )
      GO TO 9900
9930  CONTINUE
C
C-------INSUFFICIENT SPACE
      CALL XOPMSG ( IOPHYD , IOPSPC , 0 )
      GO TO 9900

      END


CODE FOR XMASKF
      SUBROUTINE XMASKF(FA, FB, HKL, STL2, ICAXES)

C Compute the Fourier transform of the mask using the HKL indices.
C Some lists must be loaded: 2, 42
C
C FA - real component of FT of list 42.
C FB - imag component of FT of list 42.
C HKL(3) - the indices that you want.
C STL2 - (sin(theta)/lambda)^2. Set to zero for no temp factor correction.
C ICAXES -  0 Do nothing special
C           1 Swap HKL back to original axis system. L42I must be
C             pointing to an original copy of L2I.
C
C--
      INCLUDE 'STORE.INC'
      INCLUDE 'ISTORE.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XLST02.INC'
      INCLUDE 'XLST42.INC'
      INCLUDE 'XFOURC.INC'
      INCLUDE 'XIOBUF.INC'
      REAL HKL(3), THKL(3), HKL42(3)
      DIMENSION IIND3(3)
      DIMENSION STEPS(3)
      DIMENSION XJ(3)
      INCLUDE 'QSTORE.INC'
      EQUIVALENCE (IX,IAXIS(1)),(IY,IAXIS(2)),(IZ,IAXIS(3))


      DO I = 0,2
       STEPS(I+1)=(STORE(L42L+I*3+2)-STORE(L42L+I*3))/STORE(L42L+I*3+1)
      END DO


      BT = EXP(-4.*STL2)    ! Assume U of 0.05
c       BT = 1.               ! No temp fac.

c      WRITE(CMON(1),'(A,3F8.5)')'Steps=',(STEPS(I),I=1,3)
c      CALL XPRVDU(NCVDU,1,0)

C Set up matrix for mapping indices onto the MASK and VALUE arrays.
      IIND3(1) = 1
      IIND3(2) = NINT(STORE(L42L+1))
      IIND3(3) = NINT(STORE(L42L+4)) * IIND3(2)

c      WRITE(CMON(1),'(A,3I5)')'IndexV=',(IIND3(I),I=1,3)
c      CALL XPRVDU(NCVDU,1,0)


C NB. Lattice translations are ignored as the effect is constant, and
C would be normalised out.

      TNNZ = 0.0   ! Number of non-zeroes in the whole cell
      FA  = 0.0 ! A-part
      FB  = 0.0 ! B-part

C----- LOOP OVER ALL SECTIONS

c      WRITE(CMON(1),'(A,3I5)')'Divs ',NINT(STORE(L42L+7)),
c     1 NINT(STORE(L42L+4)),NINT(STORE(L42L+1))
c      CALL XPRVDU(NCVDU,1,0)

      IF ( ICAXES .EQ. 1 ) THEN
         HKL42(IX)=HKL(1)         ! Unswap the indices for
         HKL42(IY)=HKL(2)       ! list 42 contribution.
         HKL42(IZ)=HKL(3)
      ELSE
         CALL XMOVE(HKL(1),HKL42(1),3)
         L42I = L2I
         N42I = N2I
         MD42I = MD2I
      END IF

      DO IZSECT = 0, NINT(STORE(L42L+7))-1
         DO IYSECT = 0, NINT(STORE(L42L+4))-1
            DO IXSECT = 0, NINT(STORE(L42L+1))-1
C GET ADDRESS of THIS POINT in L42M array.
               M42M=L42M+IXSECT+IIND3(2)*IYSECT+IIND3(3)*IZSECT
               IF ( ISTORE(M42M) .NE. 0) THEN
                 XJ(1) = STORE( L42L ) + STEPS(1) * IXSECT
                 XJ(2) = STORE(L42L+3) + STEPS(2) * IYSECT
                 XJ(3) = STORE(L42L+6) + STEPS(3) * IZSECT
                 DO ISYM = L42I, L42I+MD42I*(N42I-1), MD42I
                   CALL XMLTMM(STORE(ISYM),HKL42,THKL,3,3,1)
                   CALL DVPROD(STORE(ISYM+9),HKL42,PSHIF)
                   CALL DVPROD(XJ,THKL,FI)
                   FA=FA + (cos( TWOPI*(FI+PSHIF) )/FLOAT(ISTORE(M42M)))
                   IF(IC.EQ.0)
     1               FB=FB+(sin( TWOPI*(FI+PSHIF) )/FLOAT(ISTORE(M42M)))
                   TNNZ = TNNZ + 1
                 END DO
               END IF
            END DO
         END DO
      END DO

C NB, for centro structures FA will be half the actual value,
C but TNNZ is too, so the normalized answer is correct without
C introducing further operations. (Same principle as lattice translations).

      IF ( TNNZ .GT. 0 ) THEN
        FA = FA * BT / TNNZ
        FB = FB * BT / TNNZ   ! Normalise
      END IF

c      WRITE(CMON(1),'(A,F9.1)')'Nnonzero=',TNNZ
c      CALL XPRVDU(NCVDU,1,0)

      RETURN
      END



cCODE FOR KATMIS
c      FUNCTION KATMIS(NADR3)
cC Compute the number of missing atoms in a structure,
cC using lists 29 and 5. Store the results in a vector
cC at L3Q, the same length as N3.
c
c\XLST02
c\XLST03
c\XLST05
c\XLST23
c\XLST29
c
c\XIOBUF
c\XUNITS
c
c\XFOURC
c
c\STORE
c\ISTORE
c\QSTORE
c
cC Dor each atom in L3 (scattering factors), find
cC the difference between the number of atoms supposed to be
cC in the cell, L29, and the number in L5 * multipliciy. Store this
cC value in the order of L3 at NFL.
c
c
c      IF (KHUNTR (2,0, IADDL,IADDR,IADDD, -1) .LT. 0) GOTO 9902
c      IF (KHUNTR (3,0, IADDL,IADDR,IADDD, -1) .LT. 0) GOTO 9903
c      IF (KHUNTR (5,0, IADDL,IADDR,IADDD, -1) .LT. 0) GOTO 9905
c      IF (KHUNTR (23,0, IADDL,IADDR,IADDD, -1) .LT. 0) GOTO 9923
c      IF (KHUNTR (29,0, IADDL,IADDR,IADDD, -1) .LT. 0) GOTO 9929
c
c      toler = store(l23sp+5)
c      call xprc17 (0, 0, TOLER, -1) ! Update special position
c
c      L3Q = NADR3
c
c      DO I = 0, N3-1
cC Find this atom type in L29.
c         J=KCOMP(1,ISTORE(L3+MD3*I),ISTORE(L29),N29,MD29)-1
c         IF(J.LT.0)THEN
c           STORE(L3Q+I) = 0.0
c         ELSE
c           STORE(L3Q+I) = STORE(L29+MD29*J+4) * STORE(L2C+3)
c         END IF
c      END DO
c
c      DO I = 0, N5-1
cC Find this atom type in L3.
c         J=KCOMP(1,ISTORE(L5+MD5*I),ISTORE(L3),N3,MD3)-1
c         IF(J.LT.0)THEN
cC This error should not be possible.
c            WRITE(CMON,'(2A)')
c     1     '{E Error List3 scattering factor missing: ',ISTORE(L5+MD5*I)
c            CALL XPRVDU(NCVDU,1,0)
c         ELSE IF ( istore(l23sp+1) .ge. 0 ) THEN
c           STORE(L3Q+J) = STORE(L3Q+J) -
c     1      (STORE(L5+MD5*I+2) * STORE(L5+MD5*I+13) * STORE(L2C+3))
c         ELSE
c           STORE(L3Q+J) = STORE(L3Q+J) -
c     1      (STORE(L5+MD5*I+2) * STORE(L2C+3))
c         END IF
c      END DO
c
c      NMISS = 0
c      NNEGA = 0
c      DO I = 0, N3-1
c         NMISS = NMISS + STORE(L3Q+I)
c         IF ( STORE(L3Q+I) .LT. 0.0 ) NNEGA = NNEGA + 1
c      END DO
c
c      IF ( NNEGA .GT. 0 ) THEN
c         WRITE(CMON,'(4(A/))')
c     1 'The number of missing atoms of some types negative. This is ',
c     2 'either due to having too many atoms in the model, or ',
c     3 'specifying the wrong formula in list 29.',
c     4 'Number of missing atoms of each type:'
c         CALL XPRVDU(NCVDU,4,0)
c         DO I = 0, N3-1
c           WRITE(CMON,'(3X,A,F8.3)')ISTORE(L3+MD3*I),STORE(L3Q+I)
c           CALL XPRVDU(NCVDU,1,0)
c         END DO
c         GOTO 9900
c      END IF
c      IF ( NMISS .EQ. 0 ) THEN
c         WRITE(CMON,'(4(A/))')
c     1 '{IThe number of missing atoms is zero, based on the',
c     2 '{Idifference between the model and the formula specified',
c     3 '{Iin list 29. The Fourier will proceed, but no weights will',
c     4 '{Ibe used.'
c         CALL XPRVDU(NCVDU,4,0)
c      END IF
c
c      WRITE(CMON,'(/A/)')
c     1 ' Atom type    Number missing'
c      CALL XPRVDU(NCVDU,3,0)
c      DO I = 0, N3-1
c        WRITE(CMON,'(4X,A,10X,F8.3)')ISTORE(L3+MD3*I),STORE(L3Q+I)
c        CALL XPRVDU(NCVDU,1,0)
c      END DO
c
c      KATMIS = 0
c      RETURN
c
c9900  CONTINUE
c      KATMIS = -1
c      RETURN
c9902  CONTINUE
c      WRITE(CMON,'(A)')'{E List 2 must be loaded when calling ATMISS'
c      CALL XPRVDU(NCVDU,1,0)
c      GOTO 9900
c9903  CONTINUE
c      WRITE(CMON,'(A)')'{E List 3 must be loaded when calling ATMISS'
c      CALL XPRVDU(NCVDU,1,0)
c      GOTO 9900
c9905  CONTINUE
c      WRITE(CMON,'(A)')'{E List 5 must be loaded when calling ATMISS'
c      CALL XPRVDU(NCVDU,1,0)
c      GOTO 9900
c9923  CONTINUE
c      WRITE(CMON,'(A)')'{E List 23 must be loaded when calling ATMISS'
c      CALL XPRVDU(NCVDU,1,0)
c      GOTO 9900
c9929  CONTINUE
c      WRITE(CMON,'(A)')'{E List 29 must be loaded when calling ATMISS'
c      CALL XPRVDU(NCVDU,1,0)
c      GOTO 9900
c      END


cCODE FOR XSSSF
c      SUBROUTINE XSSSF(STL2,SSF,SSSF)
c
c\STORE
c\ISTORE
c\XLST02
c\XLST03
c\XLST29
c\XFOURC
c\XIOBUF
c\XUNITS
c\QSTORE
c
c
cC Compute sum of scattering factors (SSF) and the sum of the
cC squares of the scattering factors (SSSF) of missing atoms
cC at given angle (STL2) = (sin(theta)/lambda)**2.
c
c
cC The values at L3Q are the total number of atoms in the cell,
cC so no symmetry correction is necessary.
c
cc      BT = EXP(-4.*STL2)   ! Average temperature factor correction (U=0.05)
c      ST = SQRT(STL2)
c      CALL XSCATT(ST)   ! Puts form factors at L3TR
c      SSF = 0.0
c      SSSF = 0.0
c
cC--FORM THE SUM OF THE SQUARES OF THE FORM FACTORS AND THE SUM
c      DO I=0,N3-1
c         J=L3TR+I*MD3TR
c         SSSF= SSSF + STORE(L3Q+I) * STORE(J) * STORE(J)
c         SSF = SSF  + STORE(L3Q+I) * STORE(J)
cc         WRITE(CMON,'(A,2F9.4)') ISTORE(L3+I*MD3),STORE(L3Q+I),STORE(J)
cc         CALL XPRVDU(NCVDU,1,0)
c      END DO
c
c      END

CODE FOR MDBESL
      SUBROUTINE MDBESL(X,BSLI0,BSLI1)
C Polynomial approximation to modified Bessel functions I0(x), I1(x)
C BSLI0 - first order modified bessel function I0(x)
C BSLI1 - second order modified bessel function I1(x)
c make y double April 2014
      DOUBLE PRECISION BSLI0,BSLI1,T,T2,X,Y
      IF (X.EQ.0.0D0) THEN
           BSLI0=1.0D0
           BSLI1=0.0D0
           RETURN
      ELSE IF (X.LE.3.75D0) THEN
           Y=(X/3.75D0)**2
           BSLI0=(((((.0045813D0*Y+.0360768D0)*Y+.2659732D0)
     &               *Y+1.2067492D0)*Y+3.0899424D0)*Y
     &                              +3.5156229D0)*Y+1.0D0
           BSLI1=X*((((((.00032411D0*Y+.00301532D0)*Y
     &        +.02658733D0)*Y+.15084934D0)*Y+.51498869D0)
     &         *Y+.87890594D0)*Y+.5D0)
        ELSE
           Y=3.75D0/X
           BSLI0=((((((((.00392377D0*Y-.01647633D0)*Y
     &         +.02635537D0)*Y-.02057706D0)*Y+.916281D-2)*Y
     &         -.157565D-2)*Y+.225319D-2)*Y+.01328592D0)*Y
     &         +.39894228D0)*DEXP(X)/DSQRT(X)
           BSLI1=((((((((-.420059D-2*Y+.01787654D0)*Y
     &         -.02895312D0)*Y+.02282967D0)*Y-.01031555D0)*Y
     &         +.163801D-2)*Y-.00362018D0)*Y-.03988024D0)*Y
     &         +.39894228D0)*DEXP(X)/DSQRT(X)
        ENDIF
        RETURN
        END


