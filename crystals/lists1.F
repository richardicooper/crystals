C $Log: not supported by cvs2svn $
C Revision 1.13  2005/01/23 08:29:11  rich
C Reinstated CVS change history for all FPP files.
C History for very recent (January) changes may be lost.
C
C Revision 1.1.1.1  2004/12/13 11:16:09  rich
C New CRYSTALS repository
C
C Revision 1.12  2004/09/28 11:01:17  rich
C Don't raise warning flag on DISK/DELETE. Scares people.
C
C Revision 1.11  2003/01/14 10:19:05  rich
C g77 spots missing comma in Format statement.
C
C Revision 1.10  2002/02/12 12:48:35  Administrator
C reformat output to print new dates properly
C
C Revision 1.9  2001/09/28 10:50:56  ckp2
C New date style when printing lists.
C
C Revision 1.8  2001/09/11 09:29:16  ckp2
C New #DISK options. Give a list number to the PRINT directive to only
C get info for that list.
C
C Revision 1.7  2001/09/11 08:29:29  ckp2
C In #DISK, punch the absolute values of the list type and list serial, the delete
C and to be retained status can be obtained from other flags further along the
C output.
C
C Revision 1.6  2001/09/07 14:21:35  ckp2
C Fiddled around with #DISK to allow time and date to be stored for each entry.
C There is a year 2038 problems with the date format, it'll seem like 1970 again.
C Also added a punch directive which will allow scripts to get hold of the DSC
C info in a script readable format. Will write some scripts soon.
C
C Revision 1.5  2001/02/26 10:28:03  richard
C RIC: Added changelog to top of file
C
C

C ######################################################################
C Subroutine below in a module because of explicit interface necessary
C ######################################################################

C> Module containing some subroutine for lists1 because an explicit interdace is needed
      module lists1_mod

      contains

CODE FOR XRLIND
C> READ THE ENTRY FOR A LIST IN THE CURRENT INDEX TABLE
      SUBROUTINE XRLIND(LN,LSN,NFW,LL,IOW,NOS,IDATE, nostop)
C
C  LN      THE LIST TYPE NUMBER
C  LSN     THE LIST SERIAL NUMBER
C  NFW     FIRST WORD OCCUPIED BY THE LIST
C          'NFW' IS SET NEGATIVE IF NO SUCH LIST EXISTS
C  LL      LIST LENGTH
C  IOW     THE UPDATE FLAG, TAKEN FROM THE LAST WRITE/OVERWRITE OPERATIO
C  NOS     THE SERIAL NUMBER OF THE ORIGINAL VERSION OF THIS LIST.
C  DATE    DATE THAT THE LIST WAS CREATED ON
C
C--
C
C
      DIMENSION IDATE(2)
C
      INCLUDE 'XFILE.INC'
      INCLUDE 'XLISTS.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XLSVAL.INC'
C
      INCLUDE 'QFILE.INC'
      INCLUDE 'QLISTS.INC'
C
      integer, intent(out), optional :: nostop !< report error only, do not stop execution. zero=no error, negative otherwise
C
C
      DATA I / 0 /
C
C--CHECK IF THIS LIST NUMBER IS ALLOWED
      if(present(nostop)) then
        ISTAT=KLSCHK(LN , 0 , 0 , ILSCLN , ILSMSG , I , IERPRG,nostop)
      else
        ISTAT=KLSCHK(LN , 0 , 0 , ILSCLN , ILSMSG , I , IERPRG)
      end if
C--COMPUTE THE ADDRESS IN THE CURRENTLIST INDEX
      I=LN*IL+IL+1
      IF(LIST(I))1000,1000,1100
C--NO LIST STORED  -  SET THE FIRST WORD ADDRESS NEGATIVE
1000  CONTINUE
CDJWFEB98
      LSN = 0
      LL = 0
      IOW = 0
      NOS = 0
      IDATE(1) = 0
      IDATE(2) = 0
      NFW=-1
1050  CONTINUE
      RETURN
C--TRANSFER THE INFORMATION WE HAVE FOUND IN THE CURRENT LIST INDEX
1100  CONTINUE
      LSN=LIST(I+1)
      NFW=LIST(I+2)
      LL=(LIST(I+3)-LIST(I+2))/KINCRF(1)+1
      IOW=LIST(I+4)
      NOS=LIST(I+5)
      CALL XMOVEI (LIST(I+6),IDATE(1),1)
      CALL XMOVEI (LIST(I+7),IDATE(2),1)
      GOTO 1050
      END
C
CODE FOR KLSCHK
C> GENERAL LIST CHECKING ROUTINE
      FUNCTION KLSCHK(LN, LSN, LRSN, IREQ, IMSG, IADDR, IERR, nostop )
C
C
C    LN      LIST TYPE
C   LSN      SERIAL NUMBER
C  LRSN      RELATIVE SERIAL NUMBER. ONLY USED IF LSN = 0
C  IREQ      REQUEST TYPE. VALUES ARE:-
C
C      ILSCLN     1       CHECK FOR VALID LIST TYPE. LSN/LRSN NOT USED
C      ILSCLS     2       CHECK FOR VALID LIST TYPE/SERIAL. LRSN NOT
C                          USED.
C      ILSCLV     3       CHECK FOR VALID LIST SERIAL NUMBER. LN/LRSN
C                          NOT USED.
C      ILSEXI     4       CHECK IF A LIST OF THIS TYPE/SERIAL EXISTS.
C      ILSAVI     5       CHECK IF A LIST OF THIS TYPE/SERIAL CAN BE
C                          USED.
C      ILSRFI     6       CHECK LIST EXISTS AND LOCATE IT IN FILE INDEX
C            THESE VALUES ARE SET IN COMMON BLOCK /XLSVAL/
C
C  IMSG      MESSAGE FLAG.
C
C      ILSNMS    -1      NO MESSAGE
C      ILSMSG    +1      ERROR MESSAGES PRINTED
C            THESE VALUES ARE SET IN COMMON BLOCK /XLSVAL/
C
C IADDR      ADDRESS OF FILE INDEX ENTRY FOR THE REQUESTED LIST. SET
C            FOR REQUEST TYPE 'ILSRFI' , AND
C            REQUEST TYPES 'ILSEXI' AND 'ILSAVI' IF INDEX IS READ
C  IERR      ERROR FLAG. TYPE OF ERROR TO SIGNAL, IF ANY. FOR REQUESTS
C            OF TYPE 'ILSAVI' , INVALID LN OR LSN OR LRSN
C            CAUSE PROGRAMMING ERROR TO BE SIGNALLED.
C
C            RETURN VALUES :-
C                 -1      ERROR DURING PROCESSING.
C                  1      LIST CHECK SUCCESSFUL
C
C
      INCLUDE 'XFILE.INC'
      INCLUDE 'XLISTS.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XLSVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QFILE.INC'
      INCLUDE 'QLISTS.INC'
C
      integer, intent(out), optional :: nostop !< report error only, do not stop execution. zero=no error, negative otherwise

      IFAIL = -1
      if(present(nostop)) then
        nostop=0
        imsg=-1
      end if
C
C -- ENSURE THAT THE SYSTEM IS INITIALISED
      CALL XLC
C
C -- SET READ FILE INDEX FLAG
      IRDFIL = -1
      IF ( LSN .NE. 0 ) IRDFIL = 1
      IF ( LRSN .NE. 0 ) IRDFIL = 1
      IF ( IREQ .EQ. ILSRFI ) IRDFIL = 1
C
C -- FIRST SECTION. CHECK IS 'LIST TYPE'
      IF ( IREQ .EQ. ILSCLV ) GO TO 2100
      IF ( LN .LE. 0 ) GO TO 9910
      IF ( LN .GT. MLN ) GO TO 9910
C
2100  CONTINUE
C -- SERIAL O.K. OR SKIPPED. NEXT CHECK IS 'SERIAL NUMBER'
      IF ( IREQ .EQ. ILSCLN ) GO TO 8000
      LSER = LSN
      IF ( LSN .NE. 0 ) GO TO 2200
C -- PROCESSING OF RELATIVE SERIAL NUMBER. NOT ALLOWED FOR 'ILSCLS'
      IF ( IREQ .EQ. ILSCLS ) GO TO 9920
C -- LOOK UP CURRENT LIST IN INDEX.
      I = IL + IL * LN + 1
      IF ( LIST(I) .EQ. 0 ) GO TO 9930
      LSER = IABS ( LIST(I+1) ) + LRSN
2200  CONTINUE
C -- CHECK CALCULATED SERIAL NUMBER VALID
      IF ( LSER .LE. 0 ) GO TO 9920
C
C -- LIST TYPE/SERIAL O.K.  NEXT CHECK IS 'EXISTS'
      IF ( IREQ .LT. ILSEXI ) GO TO 8000
C -- FIND THE ACTUAL LIST REQUESTED.
      IF ( IRDFIL .GE. 1 ) GO TO 3100
      GO TO 3200
3100  CONTINUE
      CALL XFINDE ( LN , LSER , IADDR , -1 )
C -- CHECK THAT THERE IS A LIST OF THE REQUESTED TYPE/SERIAL .
      IF ( IADDR .LE. 0 ) GO TO 9940
      ITYPE = INDEXF(IADDR)
      IUSAGE = INDEXF(IADDR+4)
      IERROR = INDEXF(IADDR+5)
      GO TO 4000
C
3200  CONTINUE
      LOCLST = IL + ( IL * LN ) + 1
      IF ( LIST(LOCLST) .EQ. 0 ) GO TO 9940
      ITYPE = LIST(LOCLST)
      IUSAGE = LIST(LOCLST+4)
      IERROR = LIST(LOCLST+5)
      GO TO 4000
C
4000  CONTINUE
C -- LIST REQUESTED HAS NOW BE LOCATED. NEXT CHECK IS 'AVAILABLE'
      IF ( IREQ .LT. ILSAVI ) GO TO 8000
      IF ( IREQ .EQ. ILSRFI ) GO TO 8000
C -- FAILURES NOW INDICATE LIST NOT AVAILABLE
      IFAIL = 0
C -- CHECK THAT LIST IS AVAILABLE FOR USE
      IF ( ITYPE .LE. 0 ) GO TO 9950
      IF ( IUSAGE .LT. 0 ) GO TO 9960
      IF ( IERROR .LE. 0 ) GO TO 9970
C
C
8000  CONTINUE
      KLSCHK = 1
      RETURN
C
C
9910  CONTINUE
      IF ( IMSG .LT. 0 ) GO TO 9990
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 9915 ) LN
      ENDIF
cfeb08      WRITE ( NCAWU , 9915 ) LN
      WRITE ( CMON, 9915 ) LN
      CALL XPRVDU(NCEROR, 1,0)
9915  FORMAT ( 1X , I8 , ' is not a valid list type number' )
      GO TO 9990
9920  CONTINUE
      IF ( IMSG .LT. 0 ) GO TO 9990
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 9925 ) LSER
      ENDIF
cfeb08      WRITE ( NCAWU , 9925 ) LSER
      WRITE ( CMON, 9925 ) LSER
      CALL XPRVDU(NCEROR, 1,0)
9925  FORMAT ( 1X , I8 , ' is not a valid list serial number' )
      GO TO 9990
9930  CONTINUE
      IF ( IMSG .LT. 0 ) GO TO 9992
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 9935 ) LN
      ENDIF
cfeb08      WRITE ( NCAWU , 9935 ) LN
      WRITE ( CMON, 9935 ) LN
      CALL XPRVDU(NCEROR, 1,0)
9935  FORMAT ( 1X , 'No list of type ' , I8 , ' stored' )
      GO TO 9992
9940  CONTINUE
      IF ( IMSG .LT. 0 ) GO TO 9992
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 9945 ) LN , LSER
      ENDIF
cfeb08      WRITE ( NCAWU , 9945 ) LN , LSER
      WRITE ( CMON, 9945 ) LN , LSER
      CALL XPRVDU(NCEROR, 1,0)
9945  FORMAT ( 1X , 'No list of type ' , I8 , ' and serial ' , I8 ,
     2 ' stored' )
      GO TO 9992
9950  CONTINUE
      IF ( IMSG .LT. 0 ) GO TO 9992
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 9955 ) LN , LSER
      ENDIF
cfeb08      WRITE ( NCAWU , 9955 ) LN , LSER
      WRITE ( CMON, 9955 ) LN , LSER
      CALL XPRVDU(NCEROR, 1,0)
9955  FORMAT ( 1X , 'List type ' , I8 , ' with serial ' , I8 ,
     2 ' has been deleted' )
      GO TO 9992
9960  CONTINUE
      IF ( IMSG .LT. 0 ) GO TO 9992
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 9965 ) LN , LSER
      ENDIF
cfeb08      WRITE ( NCAWU , 9965 ) LN , LSER
      WRITE ( CMON, 9965 ) LN , LSER
      CALL XPRVDU(NCEROR, 1,0)
9965  FORMAT ( 1X , 'List type ' , I8 , ' with serial ' , I8 ,
     2 ' is marked as being written to' )
      GO TO 9992
9970  CONTINUE
      IF ( IMSG .LT. 0 ) GO TO 9992
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 9975 ) LN , LSER
      ENDIF
cfeb08      WRITE ( NCAWU , 9975 ) LN , LSER
      WRITE ( CMON, 9975 ) LN , LSER
      CALL XPRVDU(NCEROR, 1,0)
9975  FORMAT ( 1X , 'List type ' , I8 , ' with serial ' , I8 ,
     2 ' is marked as an error list' )
      GO TO 9992
C
9990  CONTINUE
      ISTAT = IERR
      IF ( IREQ .EQ. ILSAVI ) ISTAT = IERPRG
      GO TO 9995
9992  CONTINUE
      ISTAT = IERR
9995  CONTINUE
      if(.not. present(nostop)) then 
        CALL XERHND ( ISTAT )
      else
        nostop=-1
      end if
      KLSCHK = IFAIL
      RETURN
C
      END
C
      end module

C ######################################################################
C Subroutine below not in module
C ######################################################################

CODE FOR XALTES
      SUBROUTINE XALTES(LN,IV)
C--ALTER THE ERROR STATUS OF LIST TYPE 'LN'
C
C  LN  THE LIST TYPE NUMBER.
C  IV  THE SIGN OF THE NEW ERROR STATUS :
C
C      -1  ERROR LIST.
C      +1  NOT AN ERROR LIST.
C
      use lists1_mod, only: klschk
      
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XLSVAL.INC'
      ISTAT = KLSCHK ( LN , 0 , 0 , ILSEXI , ILSNMS , I , IERNOP )
      IF ( ISTAT .GT. 0 ) CALL XLSALT ( LN , 0 , 0 , ILSERF , IV )
      RETURN
      END
C
CODE FOR KEXIST
      FUNCTION KEXIST(LN)
C--CHECK IF LIST 'LN' EXISTS.
C
C--RETURN VALUES ARE :
C
C  -1  LIST EXISTS, BUT IS MARKED AS AN ERROR LIST.
C   0  NO SUCH LIST EXISTS.
      use lists1_mod, only: klschk
      
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XLSVAL.INC'
C
C -- FIRST CHECK SERIAL NUMBER
      ISTAT = KLSCHK ( LN , 0 , 0 , ILSCLN , ILSMSG , I , IERPRG )
C -- THEN CHECK IF AVAILABLE. NO MESSAGE IF NOT AVAILABLE
      KEXIST = KLSCHK ( LN , 0 , 0 , ILSAVI , ILSNMS , I , IERNOP )
      RETURN
      END
C
CODE FOR XMKOWF
      SUBROUTINE XMKOWF(LN,IOWF)
C--ALTER THE OVERWRITE FLAG FOR A LIST.
C
C  LN      THE LIST TYPE.
C  IOWF    THE NEW OVERWRITE FLAG.
C
C          -1  THIS LIST IS BEING OVERWRITTEN.
C           0  THIS LIST IS READY TO BE USED.
C          +1  THIS LIST IS BEING CAREFULLY UPDATED.
C
      use lists1_mod, only: klschk
      
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XLSVAL.INC'

C -- CHECK THAT LIST EXISTS
      ISTAT = KLSCHK ( LN , 0 , 0 , ILSEXI , ILSNMS , I , IERNOP )
C -- IF IT DOES THEN ALTER FLAG
      IF ( ISTAT .GT. 0 ) CALL XLSALT ( LN , 0 , 0 , ILSOWF , IOWF )
      RETURN
      END
C
CODE FOR XWLIND
      SUBROUTINE XWLIND(LN,NFW,LL,IOWF,NEW)
C--WRITE THE ENTRY FOR A NEWLY CREATED LIST INTO THE FILE INDEX
C  AND THE CURRENT LIST INDEX.
C
C  LN   THE LIST TYPE NUMBER
C  NFW  FIRST WORD OCCUPIED BY THE LIST
C  LL   LIST LENGTH
C  IOWF  THE WRITE/OVERWRITE FLAG :
C
C        -1  THIS LIST IS STILL BEING OVERWRITTEN.
C         0  THIS LIST IS READY TO USE.
C        +1  THIS LIST IS STILL BEING CAREFULLY UPDATED.
C
C  NEW  THE NEW VERSION CONTROL FLAG :
C
C       -1  THIS IS NOT A NEW VERSION.
C        0  THIS IS A NEW VERSION.
C
C--
C
      use lists1_mod, only: xrlind, klschk
C
      CHARACTER*24 CDT
      DIMENSION ID(4)
C
      INCLUDE 'XFILE.INC'
      INCLUDE 'XLISTS.INC'
      INCLUDE 'XFILEC.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XLSVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QFILE.INC'
      INCLUDE 'QLISTS.INC'
      INCLUDE 'QFILEC.INC'
      INCLUDE 'QUNITS.INC'
C
C
      EQUIVALENCE (ID(1),XID(1))
C
C
C
      DATA I/0/,J/0/,K/0/,L/0/,M/0/,N/0/
C
      ISTAT = KLSCHK ( LN , 0 , 0 , ILSCLN , ILSMSG , I , IERPRG )
C--READ THE INFORMATION FOR THE CURRENT LIST OF THIS TYPE
      CALL XRLIND(LN,K,L,M,N,NOS,ID(1))
C--CHECK IF THIS IS AN OVERWRITE
      IF(NFW-L)1050,1000,1050
C--THIS IS AN OVERWRITE  -  CHECK THE LIST LENGTH
1000  CONTINUE
      LL=MAX0(LL,M)
C--UPDATE THE NEXT FREE DISC ADDRESS AS NECESSARY
1050  CONTINUE
      NLW=NFW+KINCRF(LL)
      IDWZAP = 0
      N=MAX0(KNEXTF(IDWZAP),NLW)
      CALL XNEXTF(N)
C--SET 'NLW' TO THE LAST WORD USED.
      NLW=NLW-1
C--BEGIN THE SEARCH FOR ALL LISTS OF THIS TYPE
      J=0
      CALL XFINDE(LN,0,I,-1)
C--CHECK FOR THE END OF THE FILE INDEX
1100  CONTINUE
      IF(I)1200,1200,1150
C--UPDATE THE CURRENT MAXIMUM SERIAL NUMBER
1150  CONTINUE
      J=MAX0(IABS(INDEXF(I+1)),J)
C--RESUME THE SEARCH
      CALL XFINDE(LN,0,I,0)
      GOTO 1100
C--COMPUTE THE NEW SERIAL NUMBER
1200  CONTINUE
      LSN=J+1
C--CHECK IF THIS IS A NEW VERSION
      IF(NEW)1300,1250,1250
C--THISI IS A NEW VERSION  -  MARK IT AS SUCH
1250  CONTINUE
      NOS=LSN
C--CHECK FOR AN OVERWRITE
1300  CONTINUE
      NOS=IABS(NOS)
      IF(NFW-L)1400,1350,1400
C--UPDATE  -  SEARCH FOR THE FILE INDEX BLOCK
1350  CONTINUE
      ISTAT = KLSCHK ( LN , K , 0 , ILSRFI , ILSMSG , I , IERPRG )
C--ENTER THE LIST INFORMATION IN THE FILE INDEX
1400  CONTINUE
      I=IABS(I)
      CALL XWLIE(INDEXF(I),LN,LSN,NFW,NLW,IOWF,NOS)
C--WRITE THE INDEX BACK TO DISC
      CALL XRWIBL(INDEXF(1))
C--UPDATE THE CURRENT LIST INDEX
      CALL XTTLI ( I, LN)
      CALL XRWIBL(LIST(1))
CDJWFEC97>
C-- SEE XWLSTD
CJAN98      IF (LN .EQ. 5) THEN
CJAN98        CALL XGDBUP('WRITE')
CJAN98      ENDIF
CDJWFEB97<
      IF ( ( ISSLSM .EQ. 3 ) .OR. ( ISSLSM .EQ. 4 ) ) THEN
C -- PRINT THE MESSAGE TO THE USER, IF REQUIRED
        IF ( ( ISSLNM .EQ. 0 ) .OR. ( ISSLNM .EQ. LN ) ) THEN
cdjw0202
      IF (ISSPRT .EQ. 0) THEN
       IF ( ID(3) .NE. 0 ) THEN
C -- Old style date format.
            WRITE(CDT,'(2A4)') ID(3),ID(4)
       ELSE
C -- New style date format.
        CALL XCDATE(ID(4),CDT)
       ENDIF
       WRITE(NCWU,901)LN,LSN,NOS,NFW,LL,CDT
901    FORMAT
     1 (' List',I3,' Serial',I5,' Original',I4,' Address',I7,' Size',
     2 I7,14X,' Date ',A24,'   To Disc')
cfeb08        WRITE ( NCAWU,910) LN,LSN,CDT
        WRITE ( CMON, 910) LN,LSN,CDT
        CALL XPRVDU(NCVDU, 1,0)
910     FORMAT(1X,'List ',I4,' Serial ',I4,'  Date ',A24,
     1  '  written to disc.')
      ENDIF
        ENDIF
      ENDIF
      RETURN
      END
C
CODE FOR KRCLI
      FUNCTION KRCLI(LN,LSN,NFW,NLW,IOWF,NOS,ID)
C--READ THE DETAILS OF A LIST FROM THE CURRENT LIST INDEX
C
C  LN      THE LIST TYPE.
C  LSN     THE LIST SERIAL NUMBER.
C  NFW     THE FIRST WORD USED.
C  NLW     THE LAST WORD USED.
C  IOWF    THE WRITE/OVERWRITE STATUS.
C  NOS     THE ORIGINAL SERIAL NUMBER.
C  ID      THE DATE CREATED.
C
C--RETURN VALUES OF 'KRCI' ARE :
C  -1  NO SUCH LIST.
C   0  LIST IS PRESENT.
C
C--
C
      DIMENSION ID(2)
C
      INCLUDE 'XFILE.INC'
      INCLUDE 'XLISTS.INC'
C
      INCLUDE 'QFILE.INC'
      INCLUDE 'QLISTS.INC'
C
C--COMPUTE THE ADDRESS
      I=IABS(LN)*IL+IL+1
C--CHECK IF THE LIST EXISTS
      IF(LIST(I))1100,1000,1100
C--NO SUCH LIST
1000  CONTINUE
      KRCLI=-1
1050  CONTINUE
      RETURN
C--FETCH THE DETAILS
1100  CONTINUE
      LN=LIST(I)
      LSN=LIST(I+1)
      NFW=LIST(I+2)
      NLW=LIST(I+3)
      IOWF=LIST(I+4)
      NOS=LIST(I+5)
      ID(1)=LIST(I+6)
      ID(2)=LIST(I+7)
      KRCLI=0
      GOTO 1050
      END
C
CODE FOR XWCLI
      SUBROUTINE XWCLI(LN,LSN,NFW,NLW,IOWF,NOS,ID)
C--WRITE AN ENTRY INTO THE CURRENT LIST INDEX
C
C  LN      THE LIST TYPE.
C  LSN     THE LIST SERIAL NUMBER.
C  NFW     THE FIRST WORD USED.
C  NLW     THE LAST WORD USED.
C  IOWF    THE WRITE/OVERWRITE STATUS.
C  NOS     THE ORIGINAL SERIAL NUMBER.
C  ID      THE DATE CREATED.
C
C--
C
      DIMENSION ID(2)
C
      INCLUDE 'XFILE.INC'
      INCLUDE 'XLISTS.INC'
C
      INCLUDE 'QFILE.INC'
      INCLUDE 'QLISTS.INC'
C
C--WRITE THE ENTRY INTO THE TABLE
      I=IABS(LN)*IL+IL+1
      LIST(I)=LN
      LIST(I+1)=LSN
      LIST(I+2)=NFW
      LIST(I+3)=NLW
      LIST(I+4)=IOWF
      LIST(I+5)=NOS
      LIST(I+6)=ID(1)
      LIST(I+7)=ID(2)
      CALL XRWIBL(LIST(1))
      RETURN
      END
C
CODE FOR KRFI
      FUNCTION KRFI(LN,LSN,NFW,NLW,IOWF,NOS,ID)
C--READ THE DATA FOR A LIST FROM THE FILE INDEX.
C
C  LN      THE LIST TYPE  -  NOT CHECKED BY THIS ROUTINE.
C  LSN     THE LIST SERIAL NUMBER. IF THIS IS ZERO, THE SEARCH BEGINS AT
C          START OF THE FILE INDEX. OTHERWISE, A PREVIOUS SEARCH IS RESU
C          THIS VARIABLE IS UPDATED UPON RETURN.
C  NFW     SET TO THE FIRST WORD USED ON RETURN.
C  NLW     SET TO THE LAST WORD USED ON RETURN.
C  IOWF    SET TO THE WRITE/OVERWRITE FLAG ON RETURN.
C  NOS     SET TO THE ORIGINAL SERIAL NUMBER ON RETURN.
C  ID      SET TO THE DATE OF CREATION ON RETURN.
C
C--RETURN VALUES OF 'KRFI' ARE :
C
C  -1  NO MORE LISTS OF THE TYPE INDICATED.
C   0  NEW LIST FOUND, AND ALL THE DATA ARE SET.
C
C--
C
      DIMENSION ID(2)
C
      INCLUDE 'XFILE.INC'
      INCLUDE 'XLISTS.INC'
C
      INCLUDE 'QFILE.INC'
      INCLUDE 'QLISTS.INC'
C
C--SET THE LIST TYPE
      IULN=IABS(LN)
C--SET THE SERIAL NUMBER FOR THE CALL TO ZERO
      I=0
C--CHECK FOR A NEW SEARCH
      IF(LSN)1150,1000,1150
C--NEW SEARCH  -  INITIATE IT
1000  CONTINUE
      CALL XFINDE(IULN,I,J,-1)
C--CHECK FOR THE END
      IF(J)1050,1200,1200
C--NO MORE  -  SET THE RETURN VALUE
1050  CONTINUE
      KRFI=-1
1100  CONTINUE
      RETURN
C--RESUME THE SEARCH
1150  CONTINUE
      CALL XFINDE(IULN,I,J,0)
      IF(J)1050,1200,1200
C--SET THE RETURN VALUES
1200  CONTINUE
      LN=INDEXF(J)
      LSN=INDEXF(J+1)
      NFW=INDEXF(J+2)
      NLW=INDEXF(J+3)
      IOWF=INDEXF(J+4)
      NOS=INDEXF(J+5)
      ID(1)=INDEXF(J+6)
      ID(2)=INDEXF(J+7)
      KRFI=0
      GOTO 1100
      END
C
CODE FOR XWFI
      SUBROUTINE XWFI(LN,LSN,NFW,NLW,IOWF,NOS,ID,NEW)
C--WRITE AN ENTRY INTO THE FILE INDEX.
C
C  LN      THE LIST TYPE.
C  LSN     THE LIST SERIAL NUMBER
C  NFW     THE FIRST WORD USED.
C  NLW     THE LAST WORD USED.
C  IOWF    THE WRITE/OVERWRITE FLAG.
C  NOS     THE ORIGINAL SERIAL NUMBER.
C  ID      THE DATE CREATED.
C  NEW     THE NEW ENTRY FLAG :
C
C          -1  THIS IS NOT A NEW ENTRY  -  OVERWRITE THE INFORMATION
C              FOR THE LIST GIVEN BY 'LN' AND 'LSN'.
C           0  CREATE A NEW ENTRY.
C
C--
C
      DIMENSION ID(2)
C
      INCLUDE 'XFILE.INC'
      INCLUDE 'XLISTS.INC'
C
      INCLUDE 'QFILE.INC'
      INCLUDE 'QLISTS.INC'
C
C--FIND THE TRUE VALUE OF 'LN'
      IULN=IABS(LN)
C--CHECK FOR A NEW ENTRY
      IF(NEW)1150,1000,1000
C--SET THE POINTERS TO HUNT TO THE END OF THE FILE INDEX TABLE
1000  CONTINUE
      IULN=0
      I=0
C--FIND THE NEXT ENTRY FOR THIS LIST
      CALL XFINDE(IULN,I,J,-1)
C--SET THE ENTRIES
1100  CONTINUE
      J=IABS(J)
      INDEXF(J)=LN
      INDEXF(J+1)=LSN
      INDEXF(J+2)=NFW
      INDEXF(J+3)=NLW
      INDEXF(J+4)=IOWF
      INDEXF(J+5)=NOS
      INDEXF(J+6)=ID(1)
      INDEXF(J+7)=ID(2)
C--REWRITE THE TABLE
      CALL XRWIBL(INDEXF(1))
      RETURN
C
C--SEARCH FOR A SPECIFIC ENTRY TO UPDATE
1150  CONTINUE
      IULSN=IABS(LSN)
      CALL XFINDL(IULN,IULSN,J,-1)
      GOTO 1100
      END
C
CODE FOR XSETFI
      SUBROUTINE XSETFI
C--START A FILE FROM SCRATCH BY CREATING THE FIRST FILE INDEX LINKS
C
      INCLUDE 'XFILE.INC'
      INCLUDE 'XLISTS.INC'
      INCLUDE 'XCOMPD.INC'
      INCLUDE 'XFILEC.INC'
      INCLUDE 'XCONST.INC'
C
      INCLUDE 'QFILE.INC'
      INCLUDE 'QFILEC.INC'
      INCLUDE 'QLISTS.INC'
C
C
      DATA I/0/,J/0/,K/0/,L/0/,M/0/
C
C--FIND THE LENGTH OF A BLOCK IN THE FILE INDEX
      J=LNFLE
C--SET UP THE FIRST BLOCK ON THE DISC
      DO 1000 I=1,J
      INDEXF(I)=NOWT
1000  CONTINUE
C--COMPUTE THE NEXT FREE DISC ADDRESS
      L=KINCRS(J)
C--SET UP THE CONSTANTS FOR THE CONTROL BLOCK
      INDEXF(1)=L
      INDEXF(9)=J
C--WRITE THE INITIAL CONTROL BLOCK TO THE DISC
      CALL XUP(0,INDEXF(1),J)
      CALL XDUMP
C--FIND THE LENGTH OF A BLOCK ON THE DISC
      I=KNWR(J)
C--COMPUTE THE ADDRESS OF THE LAST WORD OF THE FIRST FILE INDEX BLOCK
      K=L+I-1
C--FIND THE LENGTH OF AN ENTRY IN AN INDEX
      IL=8
C--SET UP THE ENTRY IN THE INDEX BLOCK
      CALL XWLIE(INDEXF(1),IFILE,1,I,K,IL,J)
C--SET UP THE ENTRY IN THE PART TO BE WRITTEN OUT TO DISC
      CALL XMOVEI (INDEXF(1),INDEXF(IL+1),IL)
C--ZERO THE REST OF THE BLOCK
      L=IL+IL+1
      DO 1050 M=L,J
      INDEXF(M)=0
1050  CONTINUE
C--MARK THE END OF THE CURRENT BLOCK OF THE FILE INDEX
      INDEXF(J+1)=IEND
C--WRITE THIS NEW BLOCK TO THE DISC
      CALL XRWIBL(INDEXF(1))
C--UPDATE THE CONTROL BLOCK  -  FETCH IT BACK
      CALL XDOWN(0,INDEXF(IL+1),J)
      INDEXF(IL+1)=K+1
      INDEXF(IL+3)=I
C--SET UP THE DEFAULT TITLE
      INDEXF(IL+7)=10
      M=IL+INDEXF(IL+7)
      CALL XMOVE(KTITL(1),INDEXF(M+1),20)
      CALL OVERFL(M)
C--OUTPUT THE CONTROL BLOCK TO THE DISC
      CALL XUP(0,INDEXF(IL+1),J)
      CALL XDUMP
C--SET UP THREE FILE INDEX TABLES
      MAXMLN=2*(J/IL)
      K=-1
      L=MLN+1
      M=0
      DO 1100 I=1,MAXMLN
      CALL XFINDE(L,M,N,K)
      K=0
1100  CONTINUE
      RETURN
      END
C
CODE FOR XSETLI
      SUBROUTINE XSETLI
C--SET UP THE CURRENT LIST INDEX TABLE ON A NEW FILE
C
      INCLUDE 'XFILE.INC'
      INCLUDE 'XLISTS.INC'
      INCLUDE 'XFILEC.INC'
C
      INCLUDE 'QFILE.INC'
      INCLUDE 'QLISTS.INC'
      INCLUDE 'QFILEC.INC'
C
C
C
      DATA I/0/,J/0/,K/0/,L/0/
C
C--BRING DOWN THE CONTROL BLOCK
      CALL XLDCBL(INDEXF(IL+1),5)
C--FIND THE DISC ADDRESS FOR THE CURRENT LIST INDEX BLOCK
      J=KNWR(I)
      J=(INDEXF(IL+1)+J-1)/J*J
C--FIND THE LENGTH OF EACH ENTRY AND THE NUMBER OF ENTRIES ALLOWED
      K=LNLST
      MLN=K/IL-2
      L=J+KINCRS(K)
C--CHECK THAT THERE IS ENOUGH ROOM
      CALL XUP(L,LIST(1),1)
C--ALTER THE FLAGS IN THE CONTROL BLOCK
      INDEXF(IL+1)=L+KINCRF(1)
      INDEXF(IL+5)=J
C--SET UP THE CONTROL INFORMATION IN THE CURRENT LIST INDEX ARRAY
      L=L-1
      CALL XWLIE(LIST(1),ILIST,1,J,L,MLN,K)
      CALL XMOVEI (LIST(1),LIST(IL+1),IL)
C--CLEAR THE TABLE BEFORE WRITING IT TO THE DISC
      L=IL+IL+1
      DO 1050 I=1,MLN
      DO 1000 K=1,IL
      LIST(L)=0
      L=L+1
1000  CONTINUE
1050  CONTINUE
C--TERMINATE THE TABLE AND WRITE IT TO THE DISC
      LIST(L)=IEND
      CALL XRWIBL(LIST(1))
C--REWRITE THE CONTROL BLOCK
      CALL XUP(0,INDEXF(IL+1),INDEXF(IL+9))
      CALL XDUMP
C--SET THE CURRENT VERSION OF EACH LIST AS THE LAST CREATED
      CALL XSETCL
      RETURN
      END
C
CODE FOR XSETCL
      SUBROUTINE XSETCL
C--ENTRY FOR RESETTING THE LIST INDEX SO THAT IT CONTAINS ALL THE LATEST
C  LISTS THAT HAVE BEEN WRITTEN
C
C--
      INCLUDE 'XFILE.INC'
      INCLUDE 'XLISTS.INC'
      INCLUDE 'XFILEC.INC'
C
      INCLUDE 'QFILE.INC'
      INCLUDE 'QLISTS.INC'
      INCLUDE 'QFILEC.INC'
C
C
C
      DATA I/0/,J/0/
C
      CALL XLC
      J=1
C--FETCH THE NEXT BLOCK OF THE FILE INDEX FROM THE DISC
1000  CONTINUE
      I=IL+1
      CALL XFCFI(J,I)
      J=I+IL
C--CHECK FOR THE END OF THE CURRENT BLOCK
1050  CONTINUE
      IF(INDEXF(J)-IFILE)1100,1000,1250
C--CHECK IF THIS POSITION CONTAINS AN ENTRY
1100  CONTINUE
      IF(INDEXF(J))1200,1200,1150
1150  CONTINUE
      CALL XTTLI ( J, LN)
C--MOVE ONTO THE NEXT ENTRY
1200  CONTINUE
      J=J+IL
      GOTO 1050
C--REWRITE THE CURRENT LIST INDEX TO THE DISC
1250  CONTINUE
      CALL XRWIBL(LIST(1))
      RETURN
      END
C
CODE FOR XFINDL
      SUBROUTINE XFINDL(LN,LSN,L,ITYPE)
C--FIND THE GIVEN LIST ANS CHECK THAT IT DOES EXIST IN THE FILE INDEX.
C
C  LN    THE LIST NUMBER.
C  LSN   THE LIST SERIAL NUMBER.
C  L     THE ADDRESS OF THE ENTRY IN THE FILE INDEX  -  SET ON RETURN.
C  ITYPE   THE TYPE OF CALL :
C
C          -1  SYSTEM CALL.
C           0  USER CALL.
C          +1  PROBABLY USER CALL, BUT COULD BE SYSTEM.
C
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QUNITS.INC'
C
C--SEARCH FOR THE LIST
      CALL XFINDE(LN,LSN,L,-1)
C--CHECK IF THIS INDICATES A NEW ENTRY
      IF(L)1000,1000,1100
C--NEW ENTRY  -  LIST DOES NOT EXIST
1000  CONTINUE
      ISTAT = IERERR
      IF ( ITYPE .LT. 0 ) ISTAT = IERPRG
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1050)LN,LSN
      ENDIF
cfeb08      WRITE(NCAWU,1050)LN,LSN
      WRITE ( CMON, 1050) LN,LSN
      CALL XPRVDU(NCEROR, 1,0)
1050  FORMAT(' List type ',I5,'  with serial number ',I8,
     2 '  is not present on disc')
      CALL XERHND ( ISTAT )
      RETURN
1100  CONTINUE
      RETURN
      END
C
CODE FOR XFINDE
      SUBROUTINE XFINDE(LN,LSN,IADD,IT)
C--SEARCH THE FILE INDEX TO FIND THE LIST OF TYPE LN
C
C  LN    LIST TYPE (IF EQUAL TO 0, THE NEXT FREE LOCATION IS FOUND)
C  LSN   LIST SERIAL NUMBER  (IF EQUAL TO 0, THE FIRST LIST OF TYPE 'LN'
C        IS RETURNED, OTHERWISE BOTH 'LN' AND 'LSN' MUST MATCH)
C  IADD  ADDRESS OF THE ENTRY IN THE INDEX AFTER A SUCCESSFUL FIND
C        IADD IS SET NEGATIVE WHEN A NEW INDEX TABLE IS CREATED
C  IT    THE TYPE OF ENTRY :
C        -1  START A NEW SEARCH
C         0  RESUME AN OLD SEARCH
C
C--THIS SUBROUTINE ASSUMES THAT 'LSN' IS GREATER THAN ZERO, ALTHOUGH
C  'LN' MAY TAKE ANY VALUE.
C
C--
C
      INCLUDE 'XFILE.INC'
      INCLUDE 'XLISTS.INC'
      INCLUDE 'XFILEC.INC'
C
C
      COMMON /XFINDC/I,J,K,L,M,N,LASTA,LASTL,NSER,NNN
C
      INCLUDE 'QFILE.INC'
      INCLUDE 'QLISTS.INC'
      INCLUDE 'QFILEC.INC'
C
C--CHECK IF THIS IS AN INITIAL ENTRY OR A RESUME
      IF(IT)1000,1100,1100
C--INITIAL ENTRY
1000  CONTINUE
      I=1
1050  CONTINUE
      J=IL+1
      CALL XFCFI(I,J)
      I=J
C--RESUME THE SEARCH
1100  CONTINUE
      I=I+IL
      IADD=-I
C--CHECK IF THERE ARE ANY MORE ENTRIES IN THE FILE INDEX
      IF(INDEXF(I))1150,1350,1150
C--CHECK FOR THE END OF THIS BLOCK OF THE FILE INDEX
1150  CONTINUE
      IF(INDEXF(I)-IFILE)1200,1050,1450
C--CHECK IF THIS IS THE LIST TYPE WE WANT
1200  CONTINUE
      IF(IABS(INDEXF(I))-LN)1100,1250,1100
C--CHECK IF WE ARE SEARCHING FOR A SPECIFIC SERIAL NUMBER
1250  CONTINUE
      IF(LSN)1400,1300,1400
C--WE WANT THE NEXT LIST OF THIS TYPE IN THE FILE INDEX
1300  CONTINUE
      IADD=I
1350  CONTINUE
      RETURN
C--WE ARE SEARCHING FOR A SPECIFIC SERIAL NUMBER
1400  CONTINUE
      IF(IABS(INDEXF(I+1))-IABS(LSN))1100,1300,1100
C--END OF INDEX  -  CREATE ANOTHER TABLE AND LINK IT IN
1450  CONTINUE
      IF(INDEXF(I)-IEND)1650,1500,1650
C--RECORD THE ADDRESS AND LENGTH OF THE LAST BLOCK OF THE INDEX
1500  CONTINUE
      LASTA=INDEXF(IL+3)
      LASTL=INDEXF(IL+6)
C--INCREMENT THE SERIAL NUMBER OF THE BLOCK
      NSER=INDEXF(IL+2)+1
C--FIND THE NUMBER OF WORDS IN A DISC BLOCK
      M=KNWR(I)
C--COMPUTE THE DISC ADDRESS OF THE NEXT BLOCK
      L=(KNEXTF(I)+M-1)/M*M
C--FIND THE NUMBER OF WORDS IN AN INDEX BLOCK
      N=LNFLE
C--COMPUTE THE LAST WORD OF THE NEW BLOCK
      M=L+KINCRS(N)-1
C--SET UP THE NEW ENTRY
      CALL XWLIE(INDEXF(IL+1),IFILE,NSER,L,M,IL,N)
      K=IL+IL+1
      IADD=-K
C--SET ALL THE ENTRIES IN THIS NEW BLOCK TO ZERO
1550  CONTINUE
      INDEXF(K)=0
      K=K+1
      IF(K-I)1550,1600,1600
C--MARK THE END OF THE INDEX
1600  CONTINUE
      INDEXF(I)=IEND
      J=INDEXF(IL+3)
      K=INDEXF(IL+6)
C--OUTPUT THE NEW BLOCK TO THE DISC
      CALL XRWIBL(INDEXF(1))
C--UPDATE THE NEXT FREE ADDRESS POINTER
      CALL XNEXTF(M+1)
C--BRING DOWN THE OLD LIST INDEX BLOCK
      CALL XDOWN(LASTA,INDEXF(IL+1),LASTL)
C--ALTER THE INDEX ENTRY OF THE TERMINATOR
      CALL XWLIE(INDEXF(I),INDEXF(IL+1),NSER,L,M,INDEXF(IL+6),N)
C--REWITE THIS BLOCK TO THE DISC
      CALL XRWIBL(INDEXF(1))
C--LOAD THE NEWLY CREATED BLOCK FROM THE DISC AGAIN
      CALL XDOWN(J,INDEXF(IL+1),K)
      I=IABS(IADD)
      GOTO 1350
C
C--ERROR BECAUSE THE FILE INDEX HAS BEEN CORRUPTED
1650  CONTINUE
      CALL XDSMSG ( 2 )
C      STOP
      CALL GUEXIT(2011)
      END
C
CODE FOR XPRTLI
      SUBROUTINE XPRTLI( IPUNCH, ILISTS )
C--PRINT THE CURRENT LIST INDEX
C--OR PUNCH IF IPUNCH .EQ. 1
C--ALL LISTS IF ILISTS .EQ 0, otherwise only lists ILISTS
C
      INCLUDE 'XLISTS.INC'
C
      CALL XLC
      CALL XPRT(1,LIST,IPUNCH,ILISTS)
      CALL XLOADL
      RETURN
      END
C
CODE FOR XPRTFI
      SUBROUTINE XPRTFI( IPUNCH, ILISTS )
C--PRINT THE COMPLETE FILE INDEX
C--OR PUNCH IF IPUNCH .EQ. 1
C--ALL LISTS IF ILISTS .EQ 0, otherwise only lists ILISTS
C
      INCLUDE 'XFILE.INC'
C
      INCLUDE 'QFILE.INC'
C
      CALL XLC
      CALL XFCFI(1,(IL+1))
      CALL XPRT(2,INDEXF,IPUNCH,ILISTS)
      RETURN
      END
C
CODE FOR XPRT
      SUBROUTINE XPRT(IN,ID,IPUNCH,ILISTS)
C--COMMON PRINT ROUTINES FOR THE CURRENT LIST INDEX AND THE FILE INDEX
C
C  IN=1  PRINT THE CURRENT LIST INDEX
C  IN=2  PRINT THE FILE INDEX
C  ID    THE INDEX ENTRY THAT IS TO BE PRINTED
C  IPUNCH = 0 Don't punch.
C  IPUNCH = 1 To Punch file.
C
C--
C
      INCLUDE 'XFILED.INC'
C
C
      CHARACTER*20 CINDEX(2)
      CHARACTER*20 CDELET(3)
      CHARACTER*10 CERROR(2)
      CHARACTER*24 CDT
C
      INCLUDE 'XFILE.INC'
      INCLUDE 'XFILEC.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QFILE.INC'
      INCLUDE 'QFILEC.INC'
      INCLUDE 'QUNITS.INC'
C
C
      EQUIVALENCE (IB,IC)
C
C
C
      DATA CINDEX / ' current list index ' , ' index of file lists' /
      DATA CERROR / '          ' , 'Error list' /
      DATA CDELET / '                    ' , '  not to be deleted ' ,
     2              '      to be deleted ' /
C
      DATA I / 0 / , J / 0 / , L / 0 /
C
C
C--PRINT THE HEADER FOR THE TOP OF THE NEXT PAGE
1000  CONTINUE
      CALL XPRTCN
C**MACHINE SPECIFIC IN ALL PROBABILITY


1050  FORMAT ( 1X , 'Print' , A , '  part' , I3 , 5X , 'Address' , I8 ,
     2 5X , 'Length' , I7 , 5X , 'Created on ' , 2A4 / )
1051  FORMAT ( 1X , 'Print' , A , '  part' , I3 , 5X , 'Address' , I8 ,
     2 5X , 'Length' , I7 , 5X , 'Created on ' , A24 / )
1060  FORMAT ( 1X, 'Print', A20, ' part ', I3, ' Created on ', 2A4)
1061  FORMAT ( 1X, 'Print', A20, ' part ', I3, ' Created on ', A24)


      IF ( ID(IL+7) .NE. 0 ) THEN
C -- Old style date format.
        IF (ISSPRT .EQ. 0) THEN
           WRITE(NCWU,1050)CINDEX(IN),ID(IL+2),ID(IL+3),
     1                       ID(IL+6),ID(IL+7),ID(IL+8)
        ENDIF
cfeb08        WRITE ( NCAWU , 1060 ) CINDEX(IN), ID(IL+2), ID(IL+7), ID(IL+8)
        WRITE ( CMON , 1060 ) CINDEX(IN),  ID(IL+2), ID(IL+7), ID(IL+8)
        CALL XPRVDU(NCVDU, 1,0)
      ELSE
C -- New style date format.
        CALL XCDATE(ID(IL+8),CDT)
        IF (ISSPRT .EQ. 0) THEN
          WRITE (NCWU,1051) CINDEX(IN),ID(IL+2),ID(IL+3),ID(IL+6),CDT
        ENDIF
cfeb08        WRITE ( NCAWU , 1061 ) CINDEX(IN), ID(IL+2), CDT
        WRITE ( CMON , 1061 ) CINDEX(IN),  ID(IL+2), CDT
        CALL XPRVDU(NCVDU, 1,0)
      END IF
C
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 1100 )
      ENDIF
1100  FORMAT ( 17X , 'List type    Serial no.       Address        ' ,
     2 'Use flag  Orig. serial    Date created' / )
cfeb08      WRITE ( NCAWU , 1110 )
      WRITE ( CMON, 1110)
      CALL XPRVDU(NCVDU, 1,0)
1110  FORMAT (1X,
     1 'Type Serial Use  Origin       Date' )
C
      I = IL + IL + 1
C--CHECK FOR THE END OF THE CURRENT INDEX BLOCK
1150  CONTINUE
      IF(ID(I)-IFILE)1200,1700,1900
1200  CONTINUE
C -- CHECK IF THERE IS AN ENTRY TO PRINT AT THIS POSITION IN THE BLOCK
      IF ( ID(I) .EQ. 0 ) GO TO 1650
C
      J = I + 7
C
C -- CHECK IF THIS LIST IS MARKED AS AN ERROR LIST
C
      IERROR = 1
      IF ( ID(I+5) .LT. 0 ) IERROR = 2
C
C -- CHECK IF THE LIST HAS BEEN DELETED
C
      IDELET = 1
      IF ( ID(I) .LT. 0 ) THEN
        IDELET = 3
      ELSE IF ( ID(I+1) .LT. 0 ) THEN
        IDELET = 2
      ENDIF
C
C --- CHECK IF WE ARE PRINTING THIS TYPE OF LIST
C
      IF ((ILISTS.NE.0) .AND. (ILISTS.NE.ABS(ID(I)))) GOTO 1650

C
C -- WRITE DETAILS FOR THIS LIST
C
      IF (ISSPRT .EQ. 0) THEN
       IF ( ID(I+6) .NE. 0 ) THEN
C Old style date format:
       WRITE (NCWU , 1450) CDELET(IDELET),(ID(L),L=I,J),CERROR(IERROR)
       ELSE
       CALL XCDATE(ID(I+7),CDT)
C New style date format:
       WRITE(NCWU,1451)CDELET(IDELET),(ID(L),L=I,I+5),CDT,CERROR(IERROR)
       END IF
      ENDIF
1450  FORMAT ( A , I6 , I11 , I13, ' to' , I8, I9, I11,12X, 2A4, 6X, A )
1451  FORMAT ( A , I6 , I11 , I13, ' to' , I8, I9, I11, 1X, A24, 1X, A )
C
      IF ( ID(I+6) .NE. 0 ) THEN
C Old style date format:
cfeb08        WRITE ( NCAWU, 1452) ID(I), ID(I+1), ID(I+4), ID(I+5),
cfeb08     2   ID(I+6) , ID(I+7) , CERROR(IERROR)(1:5), CDELET(IDELET)
        WRITE ( CMON, 1452) ID(I), ID(I+1), ID(I+4), ID(I+5),
     2   ID(I+6) , ID(I+7) , CERROR(IERROR)(1:5), CDELET(IDELET)
        CALL XPRVDU(NCVDU, 1,0)
        IF ( IPUNCH .EQ. 1 )
     2     WRITE ( NCPU,1454 ) ABS(ID(I)),ABS(ID(I+1)),ID(I+4),ID(I+5),
     3                        IERROR-1,IDELET-1,ID(I+6),ID(I+7)
      ELSE
C New style date format:
        CALL XCDATE(ID(I+7),CDT)
cfeb08        WRITE ( NCAWU, 1453) ID(I), ID(I+1), ID(I+4), ID(I+5),
cfeb08     2   CDT , CERROR(IERROR)(1:5), CDELET(IDELET)
        WRITE ( CMON, 1453) ID(I), ID(I+1), ID(I+4), ID(I+5),
     2   CDT , CERROR(IERROR)(1:5), CDELET(IDELET)
        CALL XPRVDU(NCVDU, 1,0)
        IF ( IPUNCH .EQ. 1 )
     2     WRITE ( NCPU,1455 ) ABS(ID(I)),ABS(ID(I+1)),ID(I+4),ID(I+5),
     3                        IERROR-1,IDELET-1,CDT
      ENDIF
1452    FORMAT ( 1X,I3, 1X, I6, 1X, I3, 2X, I5, 7X, 2A4,13X, A5, A20)
1453    FORMAT ( 1X,I3, 1X, I6, 1X, I3, 2X, I5, 3X, A24, 1X, A5, A20)
1454    FORMAT ( 1X,I3, 1X, I6, 1X, I3, 2X, I5,7X, I1, 1X, I1, 1X, 2A4)
1455    FORMAT ( 1X,I3, 1X, I6, 1X, I3, 2X, I5,7X, I1, 1X, I1, 1X, A24)

C NB Punch format has date at the end, and a 1 or 0 representation of
C error and delete flags. This makes it easy to read with a script.


1650  CONTINUE

C -- GET NEXT LIST
      I = I + IL
      GOTO 1150


C--FETCH THE NEXT BLOCK OF INFORMATION
1700  CONTINUE
      CALL XFCFI(I,(IL+1))
C--CHECK IF THIS INDEX IS EMPTY
      I=IL+IL+1
C--CHECK FOR THE END OF THE CURRENT TABLE
1750  CONTINUE
      IF(ID(I)-IFILE)1800,1700,1900
C--THIS NOT THE END OF THE BLOCK  -  CHECK FOR AN ENTRY
1800  CONTINUE
      IF(ID(I))1000,1850,1000
C--EMPTY  -  CHECK THE NEXT
1850  CONTINUE
      I=I+IL
      GOTO 1750
C--END OF THE COMPLETE INDEX  -  PRINT THE NEXT FREE WORD
1900  CONTINUE
      CALL XDASUM(0)
C
      CALL XLINES
      RETURN
      END
C
CODE FOR XWTTLE
      SUBROUTINE XWTTLE
C--WRITE THE COMPOUND OR TILE TO DISC
C
      INCLUDE 'XFILE.INC'
      INCLUDE 'XCOMPD.INC'
C
      INCLUDE 'QFILE.INC'
C
      CALL XLC
C--LOAD THE CONTROL BLOCK
      CALL XLDCBL(INDEXF(IL+1),0)
C--COMPUTE THE ADDRESS OF THE TITLE AND THEN READ IT
      J=INDEXF(IL+7)+IL+1
C--STORE THE TITLE IN THE CONTROL BLOCK
      CALL XMOVE(KTITL(1),INDEXF(J),20)
      CALL OVERFL(J)
C--REWRITE THE CONTROL TO THE DISC
      CALL XUP(0,INDEXF(IL+1),INDEXF(IL+9))
      CALL XDUMP
      RETURN
      END
C
CODE FOR XPRTCN
      SUBROUTINE XPRTCN
C--PRINT THE NAME  TOGETHER WITH THE PAGE FLIPS ETC.
C
C
C
      DIMENSION ID(4)
C
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XFILEC.INC'
      INCLUDE 'XCOMPD.INC'
C
      INCLUDE 'XNWPGE.INC'
      INCLUDE 'QUNITS.INC'
C
C
      EQUIVALENCE (XID(1),ID(1))
C
      CALL XLC
C**MACHINE SPECIFIC
      CALL XDATE(ID(1),ID(2))
      CALL XTIME(ID(3),ID(4))
C--CHECK IF A NEW PAGE IS REQUIRED
      IF(NWPAGE)1100,900,900
C--NEW PAGE IS REQUIRED
900   CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1000)KTITL,ID
      ENDIF
1000  FORMAT('1',20A4,5X,'Date  ',2A4,4X,'Time  ',2A4,//)
      GOTO 1300
C--A NEW PAGE IS NOT REQUIRED
1100  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1200)KTITL,ID
      ENDIF
1200  FORMAT(//,1X,20A4,5X,'Date  ',
     2 2A4 , 4X , 'Time  ' , 2A4 , // )
C--AND NOW RETURN
1300  CONTINUE
      RETURN
      END
C
CODE FOR XLC
      SUBROUTINE XLC
C--INITIAL SUBROUTINE TO LOAD ALL THE FILE INDEX INFORMATION
C
      INCLUDE 'XFILEC.INC'
C
      INCLUDE 'QFILEC.INC'
C
C--CHECK IF THE SYSTEM HAS ALREADY BEEN INITIALISED
      IF(IACCL)1000,1050,1050
1000  CONTINUE
      CALL XLOADF
      CALL XLOADL
      IACCL=1
1050  CONTINUE
      RETURN
      END
C
CODE FOR XLOADL
      SUBROUTINE XLOADL
C--LOAD THE DETAILS OF THE LIST INDICES AT THE START OF A RUN
C
      INCLUDE 'XFILE.INC'
      INCLUDE 'XLISTS.INC'
      INCLUDE 'XFILEC.INC'
C
      INCLUDE 'QFILE.INC'
      INCLUDE 'QFILEC.INC'
C
C--LOAD THE CONTROL BLOCK
      CALL XLDCBL(LIST(1),0)
C--LOAD THE FIRST 32 WORDS OF THE CURRENT LIST INDEX
      CALL XDOWN(LIST(5),LIST,32)
C--CHECK THAT THE BLOCK WE HAVE LOADED IS A CURRENT LIST INDEX
      IF(LIST(1)-ILIST)1000,1050,1000
1000  CONTINUE
      CALL XDSMSG ( 3 )
C--CHECK THAT THE LENGTH OF THE INDEX IS REASONABLE
1050  CONTINUE
      IF(LIST(6)-LNLST)1150,1150,1100
1100  CONTINUE
      CALL XDSMSG ( 1 )
C--LOAD THE WHOLE OF THE CURRENT LIST INDEX
1150  CONTINUE
      CALL XDOWN(LIST(3),LIST(IL+1),LIST(6))
      RETURN
      END
C
CODE FOR XLOADF
      SUBROUTINE XLOADF
C--LOAD THE DETAILS OF THE FILE INDEX WHEN BEGINNING TO USE A FILE
C
      INCLUDE 'XFILE.INC'
      INCLUDE 'XCOMPD.INC'
C
C
C
      DATA J / 0 /
C
C--READ DOWN THE CONTROL BLOCK
      CALL XLDCBL(INDEXF(1),0)
C--STORE THE TITLE OF THE COMPOUND IN ITS ARRAY
      J=INDEXF(7)
      CALL XMOVE(INDEXF(J+1),KTITL(1),20)
      CALL OVERFL(J)
C--LOAD THE FIRST BLOCK OF THE FILE INDEX
      INDEXF(6)=INDEXF(9)
      CALL XFCFI(1,1)
      RETURN
      END
C
CODE FOR XLDCBL
      SUBROUTINE XLDCBL(IA,IFLAG)
C--LOAD THE FIRST BLOCK ON THE DISC  -  THE CONTROL BLOCK
C
C  IA      THE ARRAY INTO WHICH THE BLOCK SHOULD BE LOADED
C  IFLAG   THE NUMBER OF A LOCATION THAT MAY BE UNSET  -  GENERALLY
C          THE ADDRESS OF THE CURRENT LIST INDEX, WITH A VALUE OF 5.
C
C--
      DIMENSION IA(*)
C
      INCLUDE 'XFILEC.INC'
C
      INCLUDE 'QFILEC.INC'
C
C
C
      DATA I/0/
C
C--READ DOWN THE FIRST NINE WORDS
      CALL XDOWN(0,IA(1),9)
C--CHECK THAT ALL THE VALUES HAVE BEEN SET POSITIVE
      DO 1050 I=1,9,2
      IF(IA(I))1000,1000,1050
C--VALUE IS NOT POSITIVE  -  CHECK IF IT MUST BE SET
1000  CONTINUE
      IF(I-IFLAG)1150,1050,1150
1050  CONTINUE
C--CHECK THAT THE BLOCK TO BE LOADED IS NOT TOO LONG
      IF(IA(9)-LNFLE)1100,1100,1150
C--ALL OKAY  -  LOAD THE BLOCK AND RETURN
1100  CONTINUE
      LENGTH = MIN0 ( LNFLE - 8 , IA(9) )
      CALL XDOWN ( 0 , IA(1) , LENGTH )
      RETURN
C
C--DISC IS NOT A SYSTEM DISC OR IS CORRUPT
1150  CONTINUE
      CALL XDSMSG ( 1 )
C      STOP
      CALL GUEXIT(2012)
      END
C
CODE FOR XWLIE
      SUBROUTINE XWLIE(LOC,LN,LSN,NFW,NLW,IOW,NOS)
C--WRITE LIST INDEX ENTRY
C
C  LOC  IS THE ADDRESS WHERE THE ENTRY IS TO BE MADE
C  LN   THE LIST TYPE NUMBER
C  LSN  THE LIST SERIAL NUMBER
C  NFW  FIRST WORD OCCUPIED BY THE LIST
C  NLW  LAST  WORD OCCUPIED BY THE LIST
C  IOW  THE UPDATE FLAG, TAKEN FROM THE LAST WRITE/OVERWRITE OPERATION.
C  NOS  THE SERIAL NUMBER OF THE ORIGINAL VERSION OF THIS LIST.
C
C--THIS SUBROUTINE SETS THE DATE
C
C--
C
C
      DIMENSION LOC(8)
C
      LOC(1)=LN
      LOC(2)=LSN
      LOC(3)=NFW
      LOC(4)=NLW
      LOC(5)=IOW
      LOC(6)=IABS(NOS)
C**MACHINE SPECIFIC
C      CALL XDATE(LOC(7),LOC(8))
C RIC2001 - use new date format (nsecs since 01/01/1970)
      LOC(7) = 0
      CALL XNDATE(LOC(8))
      RETURN
      END
C
CODE FOR XTTLI
      SUBROUTINE XTTLI ( IN, LN)
C--TRANSFER AN ENTRY FROM 'INDEXF(IN)' TO THE CURRENT LIST INDEX
C
      INCLUDE 'XFILE.INC'
      INCLUDE 'XLISTS.INC'
C
      INCLUDE 'QFILE.INC'
      INCLUDE 'QLISTS.INC'
C
C
C
      DATA I/0/,J/0/,K/0/
C
C--COMPUTE ITS ADDRESS
      I=ABS(INDEXF(IN))*IL+IL+1
      J=IN
C--PRESERVE THE ORIGINAL SERIAL NUMBER OF THE ORIGINAL VERSION OF THIS L
      K=LIST(I+5)
C--MOVE THE ENTRY ACROSS
      CALL XMOVEI (INDEXF(J),LIST(I),IL)
C--MARK THIS LIST AS NOT AN ERROR LIST
      LIST(I+5)=IABS(LIST(I+5))
C----- ONLY CHECK THE LIST 6 ERROR STATUS SINCE THIS CONSISTS OF A
C      SEPARAT HEADER AND BODY
      IF (LN .NE. 6 ) GOTO 1050
C--CHECK IF THE LIST WAS ORIGINALLY MARKED AS AN ERROR LIST
      IF(K)1000,1050,1050
C--THIS LIST SHOULD BE MARKED AS AN ERROR LIST
1000  CONTINUE
      LIST(I+5)=-LIST(I+5)
1050  CONTINUE
      RETURN
      END
C
CODE FOR XFCFI
      SUBROUTINE XFCFI(I,J)
C--FETCH THE CURRENT FILE INDEX
C
C  I  ADDRESS OF THE INFORMATION OF THE NEXT FILE INDEX
C     IN 'INDEX'
C  J  ADDRESS AT WHICH THE INFORMATION IS TO BE BROUGHT DOWN
C     IN 'INDEX'.
C
C--
      INCLUDE 'XFILE.INC'
      INCLUDE 'XFILEC.INC'
C
      INCLUDE 'QFILEC.INC'
C
C
C
      DATA K/0/,L/0/
C
C--FIND THE ADDRESS ANF LENGTH OF THE BLOCK DEFINED BY 'I'
      K=INDEXF(I+2)
      L=INDEXF(I+5)
C--BRING DOWN THE REQUIRED BLOCK
      CALL XDOWN(K,INDEXF(J),L)
C--CHECK THAT THE FILE INDEX IS CORRECTLY SET UP AND HAS NOT BEEN
C  CORRUPTED
      IF(INDEXF(J)-IFILE)1050,1000,1050
1000  CONTINUE
      RETURN
1050  CONTINUE
      CALL XDSMSG ( 2 )
C      STOP
      CALL GUEXIT(2013)
      END
C
CODE FOR XRWIBL
      SUBROUTINE XRWIBL(IND)
C--REWRITE AN INDEX BLOCK TO THE DISC
C
C--
      INCLUDE 'XFILEN.INC'
      INCLUDE 'XFILE.INC'
C
      INCLUDE 'QFILE.INC'
C
C--REWRITE THE BLOCK
      CALL XUP(IND(IL+3),IND(IL+1),IND(IL+6))
C--ENSURE THAT THE TRANSFER IS COMPLETE
      CALL XDUMP
      RETURN
      END
C
CODE FOR KNEXTF
      FUNCTION KNEXTF(IN)
C--ASSIGN THE NEXT FREE FLOATING POINT LOCATION
C
C  IN  DUMMY ARGUMENT WHICH IS NOT USED
C
C--
C
C
C
      DIMENSION ID(4)
C
      INCLUDE 'XFILEC.INC'
C
C
C
      EQUIVALENCE (XID(1),ID(1))
C
      IDWZAP = IN
      CALL XDOWN(0,ID(1),1)
      KNEXTF=ID(1)
      RETURN
      END
C
CODE FOR XNEXTF
      SUBROUTINE XNEXTF(IN)
C--WRITE THE VALUE OF 'IN' AS THE NEW NEXT FREE LOCATION
C
C  IN  NEW NEXT FREE DISC ADDRESS (IN 24 BIT WORDS)
C
C--
C
C
      DIMENSION ID(4)
C
      INCLUDE 'XFILEC.INC'
C
C
C
      EQUIVALENCE (XID(1),ID(1))
C
      ID(1)=IN
      CALL XUP(0,ID(1),1)
      CALL XDUMP
      RETURN
      END
C
CODE FOR XLINES
      SUBROUTINE XLINES
C--OUTPUT A FEW BLANK LINES TO SEPARATE PARTS OF AJOB
C
C--
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
C
C--PRINT THE BLANK LINES
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1000)
      ENDIF
1000  FORMAT(//,1X)
      RETURN
      END
C
C
CODE FOR XDSMSG
      SUBROUTINE XDSMSG ( ICODE )
C -- COMMON OUTPUT ROUTINE FOR FATAL DISC ERRORS
C
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
C
      GO TO ( 2100 , 2200 , 2300 , 9910 ) , ICODE
      GO TO 9910
C
2100  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 2105 )
      ENDIF
cfeb08      WRITE ( NCAWU , 2105 )
      WRITE ( CMON, 2105 )
      CALL XPRVDU(NCEROR, 1,0)
2105  FORMAT ( 1X , 'The disc file has been corrupted or is ' ,
     2 'not a system file' )
      GO TO 8000
C
2200  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 2205 )
      ENDIF
cfeb08      WRITE ( NCAWU , 2205 )
      WRITE ( CMON, 2205 )
      CALL XPRVDU(NCEROR, 1,0)
2205  FORMAT ( 1X , 'The file index has been corrupted' )
      GO TO 8000
C
2300  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 2305 )
      ENDIF
cfeb08      WRITE ( NCAWU , 2305 )
      WRITE ( CMON, 2305 )
      CALL XPRVDU(NCEROR, 1,0)
2305  FORMAT ( 1X , 'The current list index has been corrupted' )
      GO TO 8000
C
8000  CONTINUE
      CALL XERHND ( IERCAT )
C      STOP
      CALL GUEXIT(2014)
C
9910  CONTINUE
      CALL XOPMSG ( IOPCRY , IOPINT , 0 )
C      STOP
      CALL GUEXIT(2015)
      END
C
C
C
CODE FOR XLSALT
      SUBROUTINE XLSALT ( LN , LSN , LRSN , IFLAG , IVALUE )
C
C -- GENERAL LIST FLAG ALTERING ROUTINE
C
C    LN      LIST TYPE.
C   LSN      LIST SERIAL NUMBER.
C  LRSN      LIST RELATIVE SERIAL NUMBER. ( ONLY USED IF LSN = 0 )
C IFLAG      LIST FLAG TO ALTER. VALUES ARE :-
C
C      SYMBOL      VALUE  USE
C      ------      -----  ---
C      ILSERF      1      ERROR
C      ILSRTF      2      RETAIN FLAG
C      ILSPUF      2      PURGE
C      ILSDLF      3      DELETE
C      ILSOWF      4      OVERWRITE
C      ILSCUR      5      CURRENT LIST
C
C            VALUES ARE SET IN COMMON BLOCK /XLSVAL/
C
C IVALUE     NEW VALUE ( IGNORED FOR IFLAG = 5 )
C
C      SYMBOL     VALUE   USE                     USED WITH
C      ------     -----   ---                     ---- ----
C      ILSSET     -1      SET FLAG                ERROR/RETAIN DELETE
C      ILSCLR     +1      CLEAR FLAG              ERROR/RETAIN/DELETE
C
C      ILSOVR     -1      LIST BEING OVERWRITTEN  OVERWRITE
C      ILSRDY      0      LIST READY              OVERWRITE
C      ILSUPD     +1      LIST BEING UPDATED      OVERWRITE
C
C
      use lists1_mod, only: klschk
      
      LOGICAL WRFILE , WRCURR , REQCUR
C
      INCLUDE 'XFILE.INC'
      INCLUDE 'XLISTS.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XLSVAL.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QFILE.INC'
      INCLUDE 'QLISTS.INC'
C
C
C -- CHECK THAT REQUESTED LIST EXISTS
      ISTAT = KLSCHK ( LN , LSN , LRSN , ILSRFI , ILSMSG ,
     2 INDFIL , IERERR )
      IF ( ISTAT .LE. 0 ) GO TO 9900
C
C -- SET UP DATA REQUIRED
      INDCUR = IL + ( IL * LN ) + 1
      LSNCUR = IABS ( LIST(INDCUR+1) )
      LSNREQ = IABS ( INDEXF(INDFIL+1) )
C -- WRFILE/WRCURR INDICATE THAT FILE/CURRENT INDEX IS TO BE REWRITTEN
      WRFILE = .TRUE.
      WRCURR = .TRUE.
      REQCUR = ( LSNCUR .EQ. LSNREQ )
C
C -- BRANCH ON REQUESTED FUNCTION.
      GO TO ( 1000 , 2000 , 3000 , 4000 , 5000 , 9910 ) , IFLAG
      GO TO 9910
C
1000  CONTINUE
C -- ALTER 'ERROR' FLAG
      IOFF = 5
      INEWVL = IVALUE * MAX0 ( IABS ( LIST(INDCUR+5) ) , 1 )
      GO TO 4500
C
2000  CONTINUE
C -- ALTER 'PURGE' FLAG
      IOFF = 1
      INEWVL = IVALUE * IABS ( INDEXF(INDFIL+1) )
cdjwjan2001
      write(cmon,2201) ln, lsnreq
      call xprvdu(ncvdu,1,0)
2201  format('Disc operation on LIST',i4,
     1 ' Serial',i6)
      GO TO 4500
C
3000  CONTINUE
C -- ALTER 'DELETE' FLAG
      IF ( .NOT. REQCUR ) GO TO 3100
C -- CURRENT VERSION TO BE ALTERED. WARN USER, IF DELETE FLAG SET
      IF ( IVALUE .NE. ILSSET ) GO TO 3100
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 3005 ) LN , LSNCUR
      ENDIF
cfeb08      WRITE ( NCAWU , 3005 ) LN , LSNCUR
      WRITE ( CMON, 3005 ) LN , LSNCUR
      CALL XPRVDU(NCEROR, 2,0)
3005  FORMAT ( 1X , 'List type ' , I3 , ' with serial number ' , I5 ,
     2 ' is the current version. ' ,/
     3 ' You may still save this list with DELETE n ACTION=NO' )
C RIC04: Don't issue warning, scares people.
c      CALL XERHND ( IERWRN )
3100  CONTINUE
      IOFF = 0
      INEWVL = IVALUE * IABS ( INDEXF(INDFIL) )
      GO TO 4500
C
4000  CONTINUE
C -- ALTER 'OVERWRITE' FLAG
      IOFF = 4
      INEWVL = IVALUE
      GO TO 4500
C
4500  CONTINUE
C -- COMMON ROUTINE TO ALTER REQUIRED FLAGS
      WRCURR = REQCUR
      ICURFL = INDCUR + IOFF
      IFILFL = INDFIL + IOFF
      IF ( WRCURR ) LIST(ICURFL) = INEWVL
      IF ( WRFILE ) INDEXF(IFILFL) = INEWVL
      GO TO 8000
C
5000  CONTINUE
C -- ALTER CURRENT LIST
      CALL XTTLI (INDFIL, LN)
      GO TO 8000
C
8000  CONTINUE
C -- FINISH PROCESSING
      IF ( WRCURR ) CALL XRWIBL ( LIST(1) )
      IF ( WRFILE ) CALL XRWIBL ( INDEXF(1) )
      RETURN
C
9900  CONTINUE
C -- ERRORS
      RETURN
9910  CONTINUE
C -- INTERNAL ERROR
      CALL XOPMSG ( IOPCRY , IOPINT , 0 )
      GO TO 9900
      END
