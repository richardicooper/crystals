CODE FOR XRDHI
      SUBROUTINE XRDHI(IFIRST)
C--THIS ROUTINE READS A CARD FILE CONTAINING A SPECIFICATION OF EACH
C  '#' INSTRUCTION AND ITS ASSOCIATED DIRECTIVES AND PARAMETERS, AND
C  OUTPUTS THE RESULTS IN AN INTERNAL FORMAT TO THE DISC AS A LIST 50.
C  WITHIN THIS LIST, SEVERAL TYPES OF DATA RECORD ARE USED :
C
C  IFIRST  THE NUMBER OF THE FIRST COMMAND ADDED IN THIS RUN. THIS IS 1
C          FOR A COMPLETELY NEW FILE AND THE NUMBER OF THE FIRST NEW
C          COMMAND FOR AN APPEND.
C
C  50  RECORD TYPE 50 CONTAINS THE NAMES OF THE INSTRUCTIONS, EACH ONE
C      FOLLOWING DIRECTLY AFTER THE ONE BEFORE IT. THE FORMAT IS
C      ONE CHARACTER PER WORD, AND MAY BE REPRESENTED AS :
C
C          0  THE NUMBER OF CHARACTERS IN THE COMPLETE NAME.
C      1  NAME 1, WORD 1.
C      2  NAME 1, WORD 2.
C
C -51  RECORD TYPE 51 CONTAINS A SET OF DISC POINTERS TO
C      RECORDS 60, 61, 62, 63 AND 64 FOR EACH INSTRUCTION. THE
C      FORMAT OF EACH ENTRY IS AS FOLLOWS :
C
C      0  DISC ADDRESS OF THE RECORD HEADER PRECEDING RECORD 60.
C      1  DISC ADDRESS OF THE RECORD HEADER FOR RECORD TYPE 60.
C      3  DISC ADDRESS OF THE RECORD HEADER PRECEDING RECORD 61.
C
C      THIS FORMAT IS REPEATED FOR EACH RECORD TYPE FOR A INSTRUCTION,
C      AND THEN FOR EACH INSTRUCTION. THIS RECORD IS USED TO RAPIDLY
C      ACCESS DATA FOR A GIVEN INSTRUCTION.
C
C  52  THIS RECORD IS PRESENT ONCE IN THE LIST, AND CONTAINS THE
C      NECESSARY INSTRUCTIONS TO GENERATE LISTS INTERNALLY. THESE
C      INSTRUCTIONS CONTAIN THEIR '#' DELIMITERS, AND STORED IN
C      THE FOLLOWING FORMAT :
C
C      0  THE LIST TYPE NUMBER TO BE GENERATED.
C      1  THE FIRST WORD OF THE COMMAND  -  FORMAT 19A4.
C      2  THE SECOND WORD OF THE COMMAND.
C
C  60  EACH TYPE 60 RECORD CONTAINS THE NAMES OF THE DIRECTIVES
C      THAT ARE AVAILABLE WITH ONE '#' INSTRUCTION, IN THE SAME FORMAT
C      AS A TYPE 50 RECORD. EACH INSTRUCTION CAN HAVE A TYPE 60 RECORD.
C
C  61  EACH TYPE 61 RECORD CONTAINS THE DETAILS FOR THE DIRECTIVES
C      ASSOCIATED WITH ONE '#' INSTRUCTION. THE DETAILS IN A TYPE 61
C      RECORD ARE USED TO ACCESS THE PARAMETER DETAILS WHICH ARE
C      STORED IN A TYPE 62 RECORD. THE DATA IN TYPE 61 RECORDS IS
C      ARRANGED SERIALLY, AND THE ENTRY FOR EACH DIRECTIVE IS AS
C      FOLLOWS :
C
C       0  RELATIVE ADDRESS OF THE DETAILS OF THE PARAMETERS FOR THIS
C          DIRECTIVE.
C       1  NUMBER OF WORDS PER PARAMETER NAME.
C       2  NUMBER OF WORDS REQUIRED FOR THE COMPLETE PARAMETER ENTRY.
C       3  NUMBER OF PARAMETERS FOR THIS DIRECTIVE.
C       4  RELATIVE ADDRESS OF THE DIRECTIVES EXCLUDED FROM INPUT WHEN
C          THIS DIRECTIVE HAS BEEN FOUND.
C       5  NUMBER OF WORDS PER EXCLUDED DIRECTIVE.
C       6  NUMBER OF EXCLUDED DIRECTIVES.
C          THIS VALUE IS SET NEGATIVE WHEN THIS DIRECTIVE HAS BEEN
C          EXCLUDED. THE ABSOLUTE VALUE GIVES THE DIRECTIVE THAT HAS
C          EXCLUDED IT.
C       7  NUMBER OF TIMES THIS DIRECTIVE MAY APPEAR.
C          THIS VALUE IS SET FROM THE GROUP REPEAT COUNT FOR
C          DIRECTIVES THAT DEFINE DATA RECORDS.
C       8  NUMBER OF TIMES THIS DIRECTIVE HAS APPEARED.
C          DURING PROCESSING THIS LOCATION MAY BE SET AS FOLLOWS :
C
C          NEGATIVE  THIS DIRECTIVE HAS ALREADY GENERATED ERRORS.
C          OTHER     THE NUMBER OF TIMES THE DIRECTIVE HAS APPEARED.
C
C       9  THE NUMBER OF WORDS PER GROUP FOR THE RECORD DEFINED BY
C          THIS DIRECTIVE, IF THERE IS ONE.
C      10  THE NUMBER OF GROUPS FOR THE RECORD DEFINED BY THIS DIRECTIVE
C          IF THERE IS ONE.
C      11  THE RECORD TYPE DEFINED BY THIS DIRECTIVE.
C      12  THE COMMON BLOCK OFFSET FOR THE RECORD DEFINED BY THIS DIRECT
C      13  THE LIST TYPE FOR THE RECORD TO BE CREATED.
C      14  THE NUMBER OF WORDS OCCUPIED BY THE TITLE OF THIS RECORD.
C      15  THE NUMBER OF TIMES THE TITLE SHOULD BE PRINTED PER LINE.
C      16  THE RELATIVE ADDRESS IN RECORD TYPE 62 OF THE TITLE.
C      17  THE NUMBER OF WORDS OCCUPIED BY THE PRINT FORMAT FOR THE
C          PARAMETER KEYWORDS FOR THIS RECORD.
C      18  THE NUMBER OF TIMES THE PARAMETER KEYWORDS ARE TO BE PRINTED
C          PER LINE.
C      19  THE RELATIVE ADDRESS IN RECORD TYPE 62 OF THE PRINT FORMAT
C          FOR THE KEYWORDS FOR THIS RECORD.
C      20  THE NUMBER OF WORDS OCCUPIED BY THE PRINT FORMAT FOR THE
C          ELEMENTS OF THIS RECORD.
C      21  THE NUMBER OF GROUPS TO BE PRINTED PER LINE.
C      22  THE RELATIVE ADDRESS IN RECORD TYPE 62 OF THE PRINT FORMAT
C          FOR THE ELEMENTS IN THIS RECORD.
C      23  THE NUMBER OF WORDS OCCUPIED BY THE PUNCH FORMAT FOR THE
C          PARAMETER KEYWORDS FOR THIS RECORD.
C      24  THE NUMBER OF TIMES THE PARAMETER KEYWORDS ARE TO BE PUNCHED
C          PER LINE.
C      25  THE RELATIVE ADDRESS IN RECORD TYPE 62 OF THE PUNCH FORMAT
C          FOR THE KEYWORDS FOR THIS RECORD.
C      26  THE NUMBER OF WORDS OCCUPIED BY THE PUNCH FORMAT FOR THE
C          ELEMENTS OF THIS RECORD.
C      27  THE NUMBER OF GROUPS TO BE PUNCHED PER LINE.
C      28  THE RELATIVE ADDRESS IN RECORD TYPE 62 OF THE PUNCH FORMAT
C          FOR THE ELEMENTS IN THIS RECORD.
C      29  THE RELATIVE ADDRESS OF THE ENABLING DATA FOR THIS
C          DIRECTIVE.
C      30  THE NUMBER OF WORDS PER ENABLING DIRECTIVE.
C      31  THE NUMBER OF ENABLING DIRECTIVES.
C
C      THE BLOCK ABOVE IS REPEATED FOR EACH DIRECTIVE FOR THE CURRENT
C      '#' INSTRUCTION, AND ALL THE ADDRESSES ARE RELATIVE TO THE START
C      OF THE DATA STORED IN RECORD TYPE 62.
C
C  62  ASSOCIATED WITH EACH TYPE 61 RECORD IS A TYPE 62 RECORD, WHICH
C      CONTAINS DETAILS OF THE PARAMETERS FOR EACH DIRECTIVE. EACH
C      DIRECTIVE HAS A POINTER IN RECORD TYPE 61 INDICATING THE START
C      OF ITS PARAMETERS, WHICH ARE STORED SERIALLY AND
C      FORM THE FIRST PART OF THIS RECORD. THE REST OF THE
C      RECORD IS TAKEN WITH FURTHER DATA ADDRESSED VIA THE PARAMETER
C      INFORMATION. THE FORMAT OF AN ENTRY FOR A PARAMETER STARTS
C      WITH THE PARAMETER NAME AS FOLLOWS :
C
C      0  NAME 1, WORD 1.
C      1  NAME 1, WORD 2.
C
C      AFTER THE NAME, THE REST OF THE PARAMETER INFORMATION IS STORED,
C      ATTHE OFFSET GIVEN IN WORD 2 ABOVE, RELATIVE TO THE START OF THE
C      CURRENT PARAMETER. THE NUMBER OF WORDS OF ADDITIONAL DATA
C      IS GIVEN BY WORD 2 MINUS WORD 1 ABOVE.
C      THE FORMAT OF THE REST OF THE DATA FOR EACH PARAMETER IS :
C
C       0  PARAMETER TYPE ON INPUT :
C
C          +1  FIXED POINT NUMBER.
C          +2  FLOATING POINT NUMBER.
C          +3  CHARACTER STRING.
C          +4  STRING TO BE INTERPRETED BY THE CALLING ROUTINE.
C            +5  LONG CHARACTER STRING STORED AS BYTES
C
C       1  RELATIVE ADDRESS OF THE PERMITTED VALUES FOR THIS PARAMETER
C          ON INPUT.
C       2  NUMBER OF WORDS PER PERMISSABLE VALUE.
C       3  NUMBER OF PERMISSABLE VALUES.
C       4  COMMON BLOCK OFFSET FOR THIS PARAMETER.
C       5  TYPE OF ARGUMENT TO BE STORED IN THE COMMON BLOCK. IF THE
C          NUMBER OF PERMISSABLE VALUES IS ZERO, WORD 5 IS SET EQUAL
C          TO WORD 0. IF PERMISSABLE VALUES ARE ALLOWED, WORD 5 IS SET T
C          1, INDICATING AN INTEGER WHICH CAN GIVE THE POSITION OF THE
C          FOUND PERMISSABLE VALUE.
C          NUMBER OF PERMISSABLE VALUES IS ZERO, WORD 5 MUST EQUAL WORD
C          0. IF THE NUMBER OF PERMISSABLE VALUES IS NOT ZERO, THE
C          VALUE FOUND MAY BE STORED (WORD 0 EQUALS WORD 5), OR
C          ANOTHER TYPE OF ARGUMENT MAY BE STORED. THE MOST COMMON
C          EXAMPLE OF THIS IS TO STORE AN INTEGER TO INDICATE THE
C          POSITION OF THE PERMISSABLE VALUE FOUND ON INPUT.
C          IN THIS CASE, WORD 0 WOULD BE 3 AND WORD 5 WOULD BE 1.
C       6  VALUE TO BE ASSIGNED IF THE FIRST PERMISSABLE VALUE
C          IS FOUND. THIS IS AN INTEGER, AND SUCCESSIVE PERMISSABLE
C          VALUES ARE INCREMENTED ACCORDINGLY FROM THIS VALUE.
C       7  DEFAULT INDICATOR :
C
C          -1  NO DEFAULT AVAILABLE.
C           0  DEFAULT VALUE STORED.
C
C       8  DEFAULT VALUE, TYPE GIVEN BY WORD 5.
C       9  NUMBER OF TIMES THIS PARAMETER MAY OCCUR.
C      10  THE NUMBER OF TIMES THIS PARAMETER HAS BEEN INPUT.
C
C      THE REST OF THE TYPE 62 RECORD IS DATA POINTED TO BY THE FIRST
C      PART OF THE RECORD.
C
C  63  THIS RECORD CONTAINS A LIST OF THE LISTS THAT THE '#' INSTRUCTION
C      REQUIRES. THE LISTS ARE STORED BY NUMBER, ONE AFTER THE OTHER.
C
C  64  THIS RECORD CONTAINS THE LOAD DETAILS, WHICH ARE SPECIFIC TO
C      EACH MACHINE. ON THE ICL 1906A, THE FORMAT IS :
C
C      0  THE INSTRUCTION NUMBER FOR THE GIVEN PROGRAM.
C      1  MINIMUM CORE SIZE REQUIRED.
C      2  WORD 1 OF THE FILE NAME TO 'CONT'.
C      3  WORD 2.
C
C--RECORD TYPE 50 IS STORED AS ABOVE, BUT AS EACH INSTRUCTION
C  REQUIRES A RECORD OF TYPE 60, 61, 62, 63 AND 64, THESE ARE STORED
C  WITH RECORD NUMBERS OF -(10000*N + M). 'N' IS THE NUMBER OF THE
C  CURRENT INSTRUCTION IN THE INPUT STREAM, AND M IS THE 60 VALUE.
C  THIS MEANS THAT ONLY RECORD 50 IS LOADED IMMEDIATELY, BUT THAT
C  POINTERS ARE SET UP TO THE REST.
C
C
C
C --            THE FORMAT OF THE INPUT FILE
C               --- ------ -- --- ----- ----
C
C    1   NEW FILE/APPEND FLAG
C            A SPACE IN COLUMN ONE OF THE FIRST CARD INDICATES A NEW
C        FILE. OTHERWISE AN EXISTING LIST 50 IS EXTENDED - IF AN
C        INSTRUCTION IS SPECIFIED IN THE INPUT FILE WHICH IS ALREADY
C        DEFINED IN THE LIST 50, THE OLD DEFINITION IS REPLACED BY THE
C        NEW ONE.
C
C            THE FIRST RECORD OF THE INPUT FOR A NEW COMMAND FILE IS
C        USED AS A TITLE FOR THAT FILE.
C
C
C
C    2   LIST CREATION INSTRUCTIONS
C            THESE GIVE THE INSTRUCTIONS USED TO CREATE CERTAIN LISTS.
C        THE INPUT FILE SHOULD CONTAIN THE FOLLOWING :-
C
C       A     1 RECORD ( FORMAT : I3 ) SPECIFING THE NUMBER OF DEFINITIO
C                                     RECORDS FOLLOWING ( = NR52 )
C
C       B     NR52 RECORDS ( FORMAT : I3,1X,19A4 ) SPECIFYING THE LIST
C                                     NUMBER AND THE INSTRUCTION WHICH
C                                     GENERATES IT.
C
C
C
C    3    #INSTRUCTION DEFINITIONS
C             THESE DEFINE THE #INSTRUCTIONS AVAILABLE.
C
C       A    1 RECORD ( FORMAT : 12A1 , 3X , 3I5 )
C            12A1 : INSTRUCTION NAME
C            I5   : NUMBER OF DIRECTIVES FOR THIS INSTRUCTION ( = NR60 )
C            I5   : NUMBER OF LISTS REQUIRED ( = NR63 )
C            I5   : NUMBER OF 'LOAD DETAIL' RECORDS ( = NR64 )
C
C       B    NR64 RECORDS ( FORMAT : I4 , I8 , 68A1 )
C            I4   : JUMP NUMBER - RETURNED BY 'KNXTOP' FOR THIS
C                   #INSTRUCTION
C            I8   : CORE SIZE REQUIRED
C            68A1 : NAME OF PROGRAM WHICH EXECUTES THIS #INSTRUCTION
C
C
C
C       C    1 RECORD ( FORMAT : 20I5 ) -- IF NR60 IS GREATER THAN ZERO
C            I5   : LIST NUMBERS TO BE USED
C
C
C
C       DIRECTIVE DEFINTIONS : - ( NR60 TIMES )
C
C       D    1 RECORD ( FORMAT : I4 , 1X , 12A1 , 3X , 12I5 )
C            I4   : DIRECTIVE SEQUENCE NUMBER - IF THIS VALUE IS NEGATIV
C                   THIS DIRECTIVE IS DEFINED BY A PREVIOUS ONE, GIVEN B
C                   THE ABSOLUTE VALUE
C            12A1 : DIRECTIVE NAME
C            I5   : NUMBER OF PARAMETERS
C            I5   : REPEAT COUNT FOR THIS DIRECTIVE - IF NEGATIVE, COUNT
C                   IS GIVEN BY COMMON BLOCK OFFSET OF ABSOLUTE VALUE
C            I5   : NUMBER OF EXCLUDED DIRECTIVES
C            I5   : NUMBER OF ENABLING DIRECTIVES
C            I5   : LENGRP            -- DATA RECORD DEFINITIONS ONLY
C                   IF NEGATIVE, AS FOR REPEAT COUNT ABOVE
C            I5   : NGRP              -- DATA RECORD DEFINITIONS ONLY
C                   IF NEGATIVE, AS FOR REPEAT COUNT ABOVE
C            I5   : RECORD NUMBER     -- DATA RECORD DEFINITIONS ONLY
C            I5   : COMMON BLOCK OFFSET  -- DATA RECORD DEFINITIONS ONLY
C                   THERE MUST BE FOUR SLOTS AVAILABLE IN THE COMMON
C                   BLOCK FOR EACH DATA RECORD TYPE
C            I5   : LIST TYPE NUMBER  -- DATA RECORD DEFINITIONS ONLY
C
C
C
C     E      FORMAT SPECIFICATION FLAGS ( FORMAT : 5X , 18I5 )
C                         -- DATA RECORD DEFINITIONS ONLY
C            I5   : TITLE PRINTER 1     0 = NO PRINT / 1 = PRINT
C            I5   : TITLE PRINTER 2     0 = NO PRINT / 1 = PRINT
C            I5   : KEY WORD PRINTER 1  0 = NO PRINT / 1 = PRINT
C            I5   : KEY WORD PRINTER 2  0 = NO PRINT / 1 = PRINT
C            I5   : VALUES PRINTER 1    0 = NO PRINT / 1 = PRINT
C            I5   : VALUES PRINTER 2    0 = NO PRINT / 1 = PRINT
C            I5   : VALUES PRINTER 1    0 = NO PRINT / 1 = PRINT
C            I5   : KEY WORD PUNCH   1  0 = NO PUNCH / 1 = PUNCH
C            I5   : KEY WORD PUNCH   2  0 = NO PUNCH / 1 = PUNCH
C            I5   : VALUES PUNCH   1    0 = NO PUNCH / 1 = PUNCH
C            I5   : VALUES PUNCH   2    0 = NO PUNCH / 1 = PUNCH
C
C
C
C     F      TITLE/FORMAT SPECIFICATIONS ( FORMAT : 20A4 )
C                        -- AS REQUIRED BY PREVIOUS RECORD
C
C
C
C     G      EXCLUDED DIRECTIVES ( FORMAT : 5X , 19I5 )
C                        -- IF REQUIRED
C            I5   : NUMBER OF EXCLUDED DIRECTIVE 1 ...
C
C
C
C     H      ENABLING DIRECTIVES ( FORMAT : 5X , 18I5 )
C                        -- IF REQUIRED
C            I5   : NUMBER OF ENABLING DIRECTIVE 1
C            I5   : NUMBER OF ENABLING PARAMETER 1 -- IF 0, WHOLE
C                   DIRECTIVE IS ENABLING
C            I5   : VALUE 1
C            ( ... AS REQUIRED )
C
C
C
C     I      PARAMETER TYPE SPECIFICATION ( FORMAT : 5X , 19I5 )
C                        -- IF THERE ARE PARAMETERS
C            I5   : TYPE OF PARAMETER 1 : -
C                                                1 INTEGER
C                                                2 FLOATING
C                                                3 CHARACTER
C                                                4 SPECIAL
C            ( ... AS REQUIRED )
C
C
C
C     PARAMETER DEFINITIONS ( AS MANY AS REQUIRED FOR EACH DIRECTIVE )
C
C
C
C     J      PARAMETER DEFINITION ( FORMAT : 5X , 12A1 , 3X , 5I5 , * )
C                                       * DEPENDS ON TYPE OF PARAMETER
C            12A1 : PARAMETER KEYWORD
C            I5   : COMMON BLOCK OFFSET -- NOT FOR DATA RECORDS
C            I5   : DEFAULT VALUE FLAG -- -1 NO DEFAULT
C                                          0 DEFAULT PROVIDED
C            I5   : REPEAT COUNT
C            I5   : NUMBER OF ALLOWED VALUES -- 0 MEANS ANY VALUE IS
C                                                 ALLOWED
C                                            -- -VE MEANS DEFINED BY
C                                               PREVIOUS DIRECTIVE
C            I5   : VALUE ASSOCIATED WITH FIRST ALLOWED VALUE
C            *    : DEFAULT VALUE ( AS REQUIRED -- DEPENDS ON TYPE )
C                                    INTEGER   I10
C                                    FLOATING  F20.10
C                                    CHARACTER 1X , A4
C
C
C
C     K     ALLOWED VALUE SPECIFICATION ( FORMAT : 5X , * )
C                                    * DEPENDS ON PARAMETER TYPE
C                                    INTEGER   7I10
C                                    FLOATING  5E15.5
C                                    CHARACTER 5 ( 13A1 , 2X )
C
C
C
C     END OF PARAMETER DEFINITION
C
C
C
C     END OF DIRECTIVE DEFINITION
C
C
C
C     END OF INSTRUCTION DEFINITION
C
C
C
C
C--
C
      DIMENSION IICHAR(12), RICHAR(12), RCMAGE(80), ITITLE(20)
\ISTORE
\HEADES
\ICOM50
C
\XDISC
\XDISCS
\STORE
\XLISTI
\XUNITS
\XSSVAL
\XCHARS
\XLST50
\XCONST
\XCARDS
\XCOMPD
\XERVAL
\XLSVAL
C
C
      EQUIVALENCE (NWPAR,MDR62N),(NWPART,MDR62D)
\QSTORE
\QCOM50
      EQUIVALENCE (RCMAGE(1),LCMAGE(1))
      EQUIVALENCE (IICHAR(1),RICHAR(1))
      EQUIVALENCE (ITITLE(1),KTITL(1))
C
C--SET UP SOME STRING LENGTH POINTERS
      LKW=12
      LKW1=13
      MAXKWT = 5
C--CLEAR THE STORE
      CALL XCSAE
      CALL XRSL
C--NUMBER OF WORDS PER PARAMETER IDENTIFIER IN RECORD 62
      NWPAR=LKW1
C--NUMBER OF WORDS PER COMPLETE PARAMETER ENTRY IN RECORD 62
      NWPART=NWPAR+11
C--LENGTH OF PARAMETER FOR INPUT HERE
      NWPAR1=NWPAR-2
C--ASSUME A NEW FILE INITIALLY
      IRPLCE=-1
      IFIRST=1
C--SWITCH TO THE COMMAND FILE DISC
      NUDUMP = KSWPDU ( NCIFU )
C--READ THE FIRST CARD
      READ ( NUCOM,950 ) ( LCMAGE(I),I=1,80 )
950   FORMAT ( 80A1 )
C
C -- CHECK FIRST CHARACTER. IF BLANK THEN THIS WILL BE A NEW FILE
C    OTHERWISE, THIS IS AN APPEND
C
      IF ( LCMAGE(1) .EQ. IB ) GO TO 1220
C
C--APPEND ACTION  -  LOAD THE OLD LIST 50
      IRPLCE=0
      CALL XLOADF
      CALL XLOADL
      CALL XFAL50
C--CREATE A DATA RECORD TO HOLD RECORD 52
      CALL XCSAE
      L=LR52
      LR52=KCEDR(LN,1,52,MDR52,NR52,9)
C--MOVE THE DATA INTO THE ARRAY
      CALL XMOVE(STORE(L),STORE(LR52),MDR52*NR52)
C--MOVE RECORD 50 DOWN TO THE BOTTOM OF CORE
      L=LR50
      LR50=NFL
      CALL XRSL
C--ALLOCATE SPACE FOR RECORD 50
      NFL=LR50
      IREC=50
      N=MDR50*NR50
      MR50=KCHNFL(N)
C--MOVE THE DATA
      CALL XMOVE(STORE(L),STORE(LR50),N)
      IFIRST=NR50+1
C--LOAD RECORD 51 INTO CORE
      IREC=51
      N=MDR51*NR51
      L=LR51
C--ALLOCATE SPACE
      LR51=KCHLFL(N)
C--BRING IT DOWN
      CALL XDOWNF(L,STORE(LR51),N)
C--SET THE OTHER POINTER
      MR51=LR51+(NR51-1)*MDR51
C--READ THE DETAILS FOR THIS LIST
      CALL XRLIND(LN,I,IADDI,LENGTH,K,L,STORE(NFL))
      IADDR=IADDI
      IADDL=0
C--SEARCH FOR RECORD 52
1000  CONTINUE
      IADD1=IADDL
      IADD2=IADDR
      IF(KLDDRH(IADDL,IADDR,IBUFF))1250,1050,1050
C--CHECK FOR RECORD 52
1050  CONTINUE
      IF(IBUFF(7)-52)1000,1100,1000
C--SET THE OTHER POINTER FOR RECORD 52
1100  CONTINUE
      IADD3=IBUFF(1)
C--MOVE TO THE END OF THE CHAIN
1150  CONTINUE
      IF(KLDDRH(IADDL,IADDR,IBUFF))1200,1150,1150
C--END OF THE CHAIN  -  ASSIGN THE NEW FREE ADDRESS
1200  CONTINUE
      IDWZAP = 0
      IADDR=KNEXTF(IDWZAP)
      GOTO 1500
C
1220  CONTINUE
C -- STORE THE FIRST LINE AS A TITLE FOR THE COMMAND FILE
C -- FILL TITLE WITH SPACES
      CALL XMVSPD ( IB, ITITLE(1),20 )
C -- PACK TITLE
      CALL XFA4CS ( RCMAGE(1),KTITL(1),80 )
C -- WRITE TITLE TO DISC
      CALL XWTTLE
C
C--NUMBER OF WORDS PER '#' INSTRUCTION
1250  CONTINUE
      MDR50=LKW1
C--NUMBER OF WORDS PER DIRECTIVE NAME
      MDR60=LKW1
C--INITIALISE THE DISC
      CALL XSETFI
      CALL XSETLI
C--SET UP THE OUTPUT LIST TYPES
      LN=50
      IREC=0
C--SET ASIDE AN AREA TO STORE THE INSTRUCTION NAMES
      LR50=NFL
      MR50=LR50
      NR50=0
C--FIND THE NEXT FREE DISC ADDRESS
      IDWZAP = 0
      IADDI=KNEXTF(IDWZAP)
C--SET THE POINTERS FOR THE RECORD TRANSFERS
      IADDR=IADDI
      IADDL=0
      LENGTH=0
C--SET UP THE DISC ADDRESS RECORD TYPE 51
      MDR51=2*NCOM
      NR51=0
      LR51=LFL+1
      MR51=LR51-MDR51
C--READ THE LIST GENERATION COMMANDS
      MDR52=20
      READ(NUCOM,1300)NR52
1300  FORMAT(I3,1X,19A4)
C--CREATE A DATA RECORD FOR THE DATA  -  EVEN IF THERE IS NONE
      LR52=KCEDR(LN,1,52,MDR52,NR52,9)
C--CHECK IF THERE ARE ANY LIST GENERATION COMMANDS TO BE READ
      IF(NR52)1450,1450,1350
C--READ THE COMMANDS
1350  CONTINUE
      DO 1400 I=1,NR52
      MR52=LR52+MDR52-1
      READ(NUCOM,1300)(ISTORE(J),J=LR52,MR52)
      LR52=LR52+MDR52
1400  CONTINUE
C--UPDATE THE DATA RECORD HEADER DATA
1450  CONTINUE
      CALL XUDRH(LN,52,MDR52,NR52)
C--RECORD THE DISC ADDRESSES AND WRITE THE RECORD TO DISC
      IADD1=IADDL
      IADD2=IADDR
      CALL XWDRTD(LN,52,IADDL,IADDR,LENGTH,ICOM50,IDIM50,0,IBUFF)
      IADD3=IADDR
C--INSERT ANOTHER UNUSED RECORD BETWEEN THE CONTROL RECORDS AND THE STAR
      CALL XWDRTD(LN,52,IADDL,IADDR,LENGTH,ICOM50,IDIM50,0,IBUFF)
C--INITIAL CAPTION
1500  CONTINUE
      CALL XPRTCN
C--NUMBER OF WORDS PER DIRECTIVE NAME
      MDR60=LKW1
C--SET SOME USEFUL POINTERS FOR READING
      MDR501=MDR50-2
      MDR601=MDR60-2
C--NUMBER OF WORDS NEEDED TO STORE DETAILS FOR EACH DIRECTIVE
      MDR61=32
C--NUMBER OF WORDS PER ENTRY IN RECORD 62  -  A DUMMY VALUE
      MDR62=1
C--NUMBER OF WORDS PER LIST IN THE LISTS TO BE USED RECORD
      MDR63=1
C--VALUES FOR THE LOAD DETAILS
      MDR64=19
C
C--START OF THE LOOP TO READ THE NEXT '#' INSTRUCTION
1550  CONTINUE
      CALL XCSAE
      CALL XRSL
C--MOVE RECORD TYPE 51 DOWN CORE TO ACCOMMODATE THE NEW ENTRY
      I=LR51
      LFL=LR51-1
C--ALLOCATE SPACE FOR THE NEW ENTRY
      LR51=KCHLFL(MDR51)
C--CHECK IF THERE IS DATA TO MOVE
      IF(NR51)1650,1650,1600
C--MOVE THE DATA DOWN
1600  CONTINUE
      CALL XMOVE(STORE(I),STORE(LR51),MDR51*NR51)
C--ZERO THE NEW ENTRIES
1650  CONTINUE
      CALL XZEROF(STORE(MR51),MDR51)
C--ZERO THE RECORD TYPE
      IREC=0
C--SET UP 'NFL' AND 'LFL' TO AVOID THE INSTRUCTION NAMES AND DETAILS
      NFL=MR50
C--PREPARE AN AREA INTO WHICH THE NEXT INSTRUCTION NAME CAN BE READ
      I=KCHNFL(MDR50)
C--INITIALISE THE COMMON BLOCK POINTERS
      DO 1700 I=LCOM,MCOM,MDCOM
      ICOM50(I)=NOWT
1700  CONTINUE
C--READ THE NEXT INSTRUCTION NAME
      J=MR50+MDR501
      READ(NUCOM,1750,END=6200)(ISTORE(I+1),I=MR50,J),NR60,NR63,NR64
1750  FORMAT(12A1,3X,3I5)
C--COMPUTE THE MAXIMUM LENGTH FOR THIS NAME
      CALL XMAXCH(STORE(MR50),MDR50)
      JRPLCE=1
C--CHECK FOR AN APPEND
      IF(IRPLCE)1900,1800,1800
C--APPEND  -  SEARCH FOR THIS DIRECTIVE
1800  CONTINUE
      I=KCOMP(MDR50-1,ISTORE(MR50+1),ISTORE(LR50+1),NR50,MDR50)
C--CHECK FOR SUCCESS
      IF(I)1900,1900,1850
C--BLANK OUT THE PREVIOUS ENTRY
1850  CONTINUE
      I=LR50+(I-1)*MDR50
      CALL XMVSPD(IB,ISTORE(I+1),MDR50-1)
      JRPLCE=2
C--UPDATE AFTER THE READ
1900  CONTINUE
      MR50=NFL
      NR50=NR50+1
      NR51=NR50
      IRF=NR50*MULT50
C--SET UP A RECORD TO RECEIVE THE LOAD DETAILS
      NR64=MAX0(NR64,1)
      LR64=KCEDR(LN,1,-(IRF+64),MDR64,NR64,LCOM+4*MDCOM)
      MR64=LR64
C--READ THE DETAILS
      J=NFL
      K=KCHNFL(68)-1
C--LOOP OVER EACH INPUT LOAD DETAIL
      DO 2150 N=1,NR64
      READ(NUCOM,1950)ISTORE(MR64),ISTORE(MR64+1),(STORE(I),I=J,K)
1950  FORMAT(I4,I8,68A1)
C--BLANK OUT THE TRUE RECORD
      L=MR64+MDR64-3
      DO 2000 I=MR64,L
      ISTORE(I+2)=IB
2000  CONTINUE
C--SEARCH FOR THE FIRST NON-BLANK CHARACTER
      DO 2050 I=J,K
      IF(ISTORE(I).EQ.IB)GOTO 2050
C--NON-BLANK  -  COMPRESS TO A4 AND STORE
      CALL XFA4CS(STORE(I),STORE(MR64+2),K-I+1)
      GOTO 2100
2050  CONTINUE
C--UPDATE FOR THE NEXT LOAD DETAIL
2100  CONTINUE
      MR64=MR64+MDR64
2150  CONTINUE
C--CHECK IF THERE ARE ANY LISTS REQUIRED BY THIS INSTRUCTION
      IF(NR63)2350,2350,2200
C--LIST TO BE INPUT  -  CREATE A RECORD TO RECEIVE THEM
2200  CONTINUE
      LR63=KCEDR(LN,1,-(IRF+63),MDR63,NR63,LCOM+3*MDCOM)
      MR63=LR63
C--READ THE REQUIRED LISTS
      J=MR63+MDR63*NR63-1
      READ(NUCOM,2250)(ISTORE(I),I=MR63,J)
2250  FORMAT(16I5)
C--CHECK THAT THE INPUT LIST TYPES ARE VALID
      DO 2300 I=MR63,J
      ISTAT = KLSCHK ( LN , 0 , 0 , ILSCLN , ILSMSG , I , IERSEV )
2300  CONTINUE
C
C--CHECK IF THERE ARE ANY DIRECTIVES TO BE READ FOR THIS INSTRUCTION
2350  CONTINUE
      IF(NR60)5900,5900,2400
C--DIRECTIVES TO BE READ  -  SET RECORD TYPE 60 TO RECEIVE THE NAMES
2400  CONTINUE
      LR60=KCEDR(LN,1,-(IRF+60),MDR60,NR60,LCOM)
      MR60=LR60
C--SET UP A TYPE 61 RECORD TO RECEIVE THE DIRECTIVE POINTERS
      NR61=NR60
      LR61=KCEDR(LN,1,-(IRF+61),MDR61,NR61,LCOM+MDCOM)
      MR61=LR61
C--ZERO THIS AREA
      CALL XZEROF(STORE(MR61),MDR61*NR61)
C--SET UP AN AREA TO RECEIVE THE PARAMETER NAMES AND DETAILS
      LR62=KCEDR(LN,1,-(IRF+62),MDR62,0,LCOM+2*MDCOM)
      MR62=LR62
C--PRESERVE THE BASE ADDRESS OF THIS RECORD FOR RELATIVE ADDRESSING
      IBASE=MR62
C--LOOP OVER EACH EXPECTED INPUT DIRECTIVE
      DO 5850 JA=1,NR60
C--READ THE DIRECTIVE NAME
      J=MR60+MDR601
      JC=MR61+9
      JD=JC+4
      READ(NUCOM,2450)K,(ISTORE(I+1),I=MR60,J),ISTORE(MR61+3),
     2 ISTORE(MR61+7),ISTORE(MR61+6),ISTORE(MR61+31),(ISTORE(I),I=JC,
     3 JD)
2450  FORMAT(I4,1X,12A1,3X,10I5)
C--COMPUTE THE MAXIMUM LENGTH FOR THIS NAME
      CALL XMAXCH(STORE(MR60),MDR60)
C--CHECK IF THIS DIRECTIVE IS DEFINED BY ONE GIVEN PREVIOUSLY
      IF(K)2500,2600,2600
C--THIS DIRECTIVE IS DEFINED BY A PREVIOUS ONE
2500  CONTINUE
      K=IABS(K)
C--CHECK THAT THE INDICATED DIRECTIVE HAS BEEN READ IN
      IF(K-JA)2550,2650,2650
C--SET THE POINTERS
2550  CONTINUE
      K=LR61+(K-1)*MDR61
      CALL XMOVE(STORE(K),STORE(MR61),MDR61)
      GOTO 5800
C--CHECK THE DIRECTIVE SEQUENCE NUMBER
2600  CONTINUE
      IF(K-JA)2650,2750,2650
C--NOT THE CORRECT NUMBER
2650  CONTINUE
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2700)K,(ISTORE(I+1),I=MR60,J)
      ENDIF
2700  FORMAT(' Directive sequence error : ',I4,1X,12A1)
      CALL XERHND ( IERSEV )
C--CHECK IF THIS DIRECTIVE DEFINES A RECORD
2750  CONTINUE
      IF(ISTORE(MR61+11))2800,3100,2800
C--A RECORD IS DEFINED HERE  -  READ THE TITLE AND FORMATS
2800  CONTINUE
      JE=MR61+14
      JG=3
      JF=JE+4*JG
C--READ THE CONSTANTS FOR THE TITLE AND FORMATS
      READ(NUCOM,3700)(ISTORE(I),ISTORE(I+1),I=JE,JF,JG)
C--LOOP OVER THE TITLE AND FORMATS, READING WHERE NECESSARY
      DO 2950 I=JE,JF,JG
C--CHECK IF THIS ITEM IS DEFINED
      ISTORE(I+2)=NOWT
      IF(ISTORE(I))2950,2950,2850
C--DEFINED  -  COMPUTE THE LENGTH TO BE STORED
2850  CONTINUE
      ISTORE(I)=ISTORE(I)*20
      ISTORE(I+1)=MAX0(1,ISTORE(I+1))
C--SET UP AN AREA TO RECEIVE THE DATA
      J=NFL
      ISTORE(I+2)=J-IBASE
      K=KCHNFL(ISTORE(I))-1
      READ(NUCOM,2900)(STORE(L),L=J,K)
2900  FORMAT(20A4)
C--CHECK THE VALUE STORED FOR THE COMMON BLOCK OFFSET
2950  CONTINUE
      IF(ISTORE(MR61+12))3000,3000,3150
C--ILLEGAL COMMON BLOCK OFFSET
3000  CONTINUE
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3050)
      ENDIF
3050  FORMAT(' Illegal common block offset for data record')
      CALL XERHND ( IERSEV )
C--NORMAL DIRECTIVE  -  ENSURE A MINIMUM OF ZERO REPEATS
3100  CONTINUE
      ISTORE(MR61+7)=MAX0(0,ISTORE(MR61+7))
C--CHECK IF THERE IS A LIST OF DIRECTIVES TO BE EXCLUDED IF THIS IS FOUN
3150  CONTINUE
      IF(ISTORE(MR61+6))3300,3300,3200
C--EXCLUDED DIRECTIVES GIVEN  -  PREPARE AN AREA FOR THEM
3200  CONTINUE
      ISTORE(MR61+5)=1
C--PREPARE AN AREA TO RECEIVE THE EXCLUDED DIRECTIVES
      J=NFL
      K=KCHNFL(ISTORE(MR61+5)*ISTORE(MR61+6))-1
C--SET THE RELATIVE ADDRESS
      ISTORE(MR61+4)=J-IBASE
C--READ THE EXCLUDED DIRECTIVES
      READ(NUCOM,3250)(ISTORE(I),I=J,K)
3250  FORMAT(5X,15I5)
C--CHECK IF THERE IS A LIST OF ENABLING DIRECTIVES GIVEN
3300  CONTINUE
      IF(ISTORE(MR61+31))3400,3400,3350
C--ENABLING DIRECTIVES GIVEN  -  PREPARE AN AREA FOR THEM
3350  CONTINUE
      ISTORE(MR61+30)=3
C--PREPARE AN AREA TO RECEIVE THE ENABLING DIRECTIVES
      J=NFL
      K=KCHNFL(ISTORE(MR61+30)*ISTORE(MR61+31))-1
C--SET THE RELATIVE ADDRESS
      ISTORE(MR61+29)=J-IBASE
C--READ THE ENABLING DIRECTIVES
      READ(NUCOM,3250)(ISTORE(I),I=J,K)
C--CHECK IF THIS DIRECTIVE HAS ANY PARAMETERS ASSOCIATED WITH IT
3400  CONTINUE
      IF(ISTORE(MR61+3))3450,5800,3650
C--PARAMETERS ARE DEFINED BY A PREVIOUS DIRECTIVE
3450  CONTINUE
      K=IABS(ISTORE(MR61+3))
C--CHECK THAT THE DIRECTIVE HAS BEEN READ IN
      IF(K-JA)3600,3500,3500
C--ILLEGAL REFERENCE
3500  CONTINUE
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3550)
      ENDIF
3550  FORMAT(' Illegal parameter set reference')
      CALL XERHND ( IERSEV )
C--MOVE THE POINTERS ACROSS
3600  CONTINUE
      K=LR61+(K-1)*MDR61
      CALL XMOVE(STORE(K),STORE(MR61),4)
      GOTO 5800
C--PARAMETERS TO BE READ  -  SET UP THE LENGTH POINTERS
3650  CONTINUE
      NPARAM=ISTORE(MR61+3)
      ISTORE(MR61+2)=NWPART
      ISTORE(MR61+1)=NWPAR
C--CREATE AN AREA TO RECEIVE THAT PARAMETER NAMES AND DETAILS
      J=NFL
      L=ISTORE(MR61+2)*ISTORE(MR61+3)
      K=KCHNFL(L)-ISTORE(MR61+2)
C--ZERO THE APPOINTED AREA
      CALL XZEROF(STORE(J),L)
C--SET THE RELATIVE ADDRESS
      ISTORE(MR61)=J-IBASE
C--READ THE INPUT AND STORED PARAMETER TYPES
      L=K+NWPAR
      K=J+NWPAR
      READ(NUCOM,3700)(ISTORE(I),I=K,L,NWPART)
3700  FORMAT(5X,15I5)
C--CHECK THE PARAMETER TYPES PROVIDED
      DO 3850 I=K,L,NWPART
C--INPUT PARAMETER TYPE
      IF(ISTORE(I))3900,3900,3750
3750  CONTINUE
      IF(ISTORE(I)-MAXKWT)3800,3800,3900
C--SET THE TYPE TO BE STORED
3800  CONTINUE
      ISTORE(I+5)=ISTORE(I)
3850  CONTINUE
      GOTO 4000
C--SOME TYPE OF ERROR
3900  CONTINUE
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3950)
      ENDIF
3950  FORMAT(' Illegal parameter type')
      CALL XERHND ( IERSEV )
C
C--LOOP OVER EACH PARAMETER FOR THIS DIRECTIVE AND INPUT ITS DETAILS
4000  CONTINUE
      DO 5750 JB=1,NPARAM
      K=J+NWPAR1
      L=J+NWPAR
C--FIND THE PARAMETER TYPE
      ITYPEI=ISTORE(L)
      ITYPES=ISTORE(L+5)
C--CHECK ON THE TYPE OF DATA TO BE STORED FOR THIS PARAMETER
      GOTO(4300, 4200, 4100, 4100, 4100, 4050),ITYPES
C4050  STOP600
4050  CALL GUEXIT(600)
C--CHARACTER STRING  -  READ THE PARAMETER KEYWORD AND DEFAULT VALUE
4100  CONTINUE
      READ(NUCOM,4150)(ISTORE(I+1),I=J,K),ISTORE(L+4),ISTORE(L+7),
     2 ISTORE(L+9),ISTORE(L+3),ISTORE(L+6),IICHAR
4150  FORMAT(5X,12A1,3X,5I5,1X,12A1)
      CALL XFA4CS(RICHAR(1),STORE(L+8),4)
      GOTO 4400
C--FLOATING POINT NUMBER  -  READ THE PARAMETER KEYWORD AND DEFAULT VALU
4200  CONTINUE
      READ(NUCOM,4250)(ISTORE(I+1),I=J,K),ISTORE(L+4),ISTORE(L+7),
     2 ISTORE(L+9),ISTORE(L+3),ISTORE(L+6),STORE(L+8)
4250  FORMAT(5X,12A1,3X,5I5,E20.10)
      GOTO 4400
C--FIXED POINT NUMBER  -  READ THE PARAMETER KEYWORD AND DEFAULT VALUE
4300  CONTINUE
      READ(NUCOM,4350)(ISTORE(I+1),I=J,K),ISTORE(L+4),ISTORE(L+7),
     2 ISTORE(L+9),ISTORE(L+3),ISTORE(L+6),ISTORE(L+8)
4350  FORMAT(5X,12A1,3X,5I5,I10)
C--COMPUTE THE MAXIMUM LENGTH FOR THIS KEYWORD
4400  CONTINUE
      CALL XMAXCH(STORE(J),NWPAR)
C--SET THE REPEAT COUNT UP PROPERLY
      ISTORE(L+9)=MIN0(MAX0(ISTORE(L+9),0),1)
C--CHECK IF WE ARE FORMING A DATA RECORD FROM THIS DIRECTIVE
      IF(ISTORE(MR61+11))4450,4500,4450
C--DATA RECORD TO BE FORMED  -  NO OFFSET IS REQUIRED
4450  CONTINUE
      ISTORE(L+4)=0
      GOTO 4650
C--SIMPLE DATA ON THIS DIRECTIVE  -  CHECK THE COMMON BLOCK OFFSET
4500  CONTINUE
      IF(ISTORE(L+4))4550,4550,4650
C--ILLEGAL OFFSET
4550  CONTINUE
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4600)ISTORE(L+4)
      ENDIF
4600  FORMAT(' Illegal common block offset : ',I5)
      CALL XERHND ( IERSEV )
C--CHECK IF A SET OF PERMISSABLE VALUES IS INCLUDED FOR THIS PARAMETER
4650  CONTINUE
      IF(ISTORE(L+3))4700,5700,4950
C--THE ALLOWED VALUES HAVE BEEN READ IN FOR A PREVIOUS DIRECTIVE
4700  CONTINUE
      K=IABS(ISTORE(L+3))
C--CHECK THAT THE DIRECTIVE HAS BEEN INPUT
      IF(K-JA)4850,4850,4750
C--ILLEGAL REFERENCE
4750  CONTINUE
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4800)
      ENDIF
4800  FORMAT(' Illegal allowed set reference')
      CALL XERHND ( IERSEV )
C--COMPUTE THE DIRECTIVE ADDRESS AND CHECK THE PARAMETER NUMBER
4850  CONTINUE
      K=LR61+(K-1)*MDR61
      IF(ISTORE(L+6)-ISTORE(K+3))4900,4900,4750
C--COMPUTE THE ADDRESS OF THE PARAMETER
4900  CONTINUE
      K=LR62+ISTORE(K)+(ISTORE(L+6)-1)*NWPART+NWPAR
C--MOVE ALL THE DETAILS, INCLUDING DEFAULT DATA, ACROSS
      CALL XMOVE(STORE(K),STORE(L),4)
      CALL XMOVE(STORE(K+5),STORE(L+5),4)
      GOTO 5700
C--PERMISSABLE VALUES TO BE READ  -  SET UP AN AREA
4950  CONTINUE
      ISTORE(L+5)=1
C--CHECK THAT THE INPUT TYPE ALLOWS PERMISSABLE VALUES
      IF(ISTORE(L)-4)5000,3900,3900
C--NOW SET THE AREA UP
5000  CONTINUE
      M=NFL
      ISTORE(L+1)=M-IBASE
      ISTORE(L+2)=1
C--CHECK ON THE TYPE OF INPUT PARAMETER
      IF(ITYPEI-3)5100,5050,5100
C--CHARACTER STRING  -  ALTER THE LENGTH OF EACH ARGUMENT
5050  CONTINUE
      ISTORE(L+2)=NWPAR
C--ALLOCATE THE SPACE
5100  CONTINUE
      N=KCHNFL(ISTORE(L+2)*ISTORE(L+3))-1
C--CHECK THE TYPE OF INPUT PARAMETER AGAIN
      GOTO(5550, 5350, 5200, 5200, 5200, 5150),ITYPEI
C5150  STOP601
5150  CALL GUEXIT(601)
C--CHARACTER STRING
5200  CONTINUE
      READ(NUCOM,5250)(ISTORE(I+1),I=M,N)
5250  FORMAT((5X,5(13A1,2X)))
C--CHECK FOR A DEFAULT VALUE
      ISTORE(L+8)=KCOMP(NWPAR-1,IICHAR(1),ISTORE(M+1),ISTORE(L+3),
     2 ISTORE(L+2))
C--LOOP OVER EACH VALUE, SETTING THE MAXIMUM LENGTH
      N=ISTORE(L+3)
      DO 5300 I=1,N
      CALL XMAXCH(STORE(M),ISTORE(L+2))
      M=M+ISTORE(L+2)
5300  CONTINUE
      GOTO 5650
C--FLOATING POINT NUMBER
5350  CONTINUE
      READ(NUCOM,5400)(STORE(I),I=M,N)
5400  FORMAT(5X,5E15.5)
      DO 5500 I=M,N
      IF(ABS(STORE(I)-STORE(L+8))-ZERO)5450,5500,5500
C--A MATCH  -  SET THE DEFAULT POINTER
5450  CONTINUE
      ISTORE(L+8)=I-M+1
      GOTO 5650
5500  CONTINUE
      ISTORE(L+8)=-1
      GOTO 5650
C--FIXED POINT NUMBER
5550  CONTINUE
      READ(NUCOM,5600)(ISTORE(I),I=M,N)
5600  FORMAT(5X,7I10)
      ISTORE(L+8)=KCOMP(1,ISTORE(L+8),ISTORE(M),ISTORE(L+3),ISTORE(L+2)
     2 )
C--SET THE DEFAULT VALUE POINTERS
5650  CONTINUE
      ISTORE(L+7)=ISTORE(L+8)-1
      ISTORE(L+8)=ISTORE(L+8)+ISTORE(L+6)-1
C--UPDATE FOR THE NEXT PARAMETER FOR THIS DIRECTIVE
5700  CONTINUE
      J=J+NWPART
5750  CONTINUE
C--ALL PARAMETERS READ FOR THIS DIRECTIVE  -  UPDATE FOR THE NEXT
5800  CONTINUE
      MR60=MR60+MDR60
      MR61=MR61+MDR61
5850  CONTINUE
C--END OF THIS INSTRUCTION  -  OUTPUT THE VARIOUS RECORDS TO DISC
      NR62=NFL-IBASE
C--OUTPUT THE PARAMETER DETAILS TO DISC
5900  CONTINUE
      IREC=-(IRF+60)
      L=MR51
      DO 6100 I=LCOM,MCOM,MDCOM
C--CHECK IF SUCH A RECORD EXISTS
      IF(ICOM50(I)-NOWT)5950,6050,5950
C--SUCH A RECORD DOES EXIST  -  UPDATE ITS HEADER BLOCK
5950  CONTINUE
      CALL XUDRH(LN,IREC,ICOM50(I+2),ICOM50(I+3))
C--PRESERVE THE DATA ADDRESS
      K=ICOM50(I)
C--RECORD THE DISC ADDRESSES
      ISTORE(L)=IADDL
      ISTORE(L+1)=IADDR
C--OUTPUT THE RECORD HEADER BLOCK
      CALL XWDRTD(LN,IREC,IADDL,IADDR,LENGTH,ICOM50,IDIM50,0,IBUFF)
C--CHECK IF THERE IS SOME DATA TO OUTPUT
      M=ICOM50(I+2)*ICOM50(I+3)
      IF(M)6050,6050,6000
C--NOW WRITE THE RECORD ITSELF
6000  CONTINUE
      CALL XUPF(ICOM50(I),ISTORE(K),M)
C--UPDATE FOR THE NEXT RECORD
6050  CONTINUE
      IREC=IREC-1
      L=L+2
6100  CONTINUE
C--PRINT A MESSAGE TO INDICATE THE END OF THIS INSTRUCTION
      J=MR50-MDR50
      K=J+MDR50-2
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,6150)(ISTORE(I+1),I=J,K),(IB,I=1,JRPLCE)
      ENDIF
6150  FORMAT(' Instruction processed : ',14A1,'Replacement')
      GOTO 1550
C
C--END OF THE DATA  -  CREATE RECORD TYPE 50 NOW
6200  CONTINUE
      I=KCEDR(LN,1,50,MDR50,NR50,1)
C--MOVE THE DATA ACROSS
      CALL XMOVE(STORE(LR50),STORE(I),MDR50*NR50)
C--UPDATE THE RECORD HEADER
      CALL XUDRH ( LN , 50 , MDR50 , NR50 )
C--WRITE THE RECORD TO THE DISC
      IADD4=IADDL
      IADD5=IADDR
      CALL XWDRTD(LN,50,IADDL,IADDR,LENGTH,ICOM50,IDIM50,0,IBUFF)
      IADD6=IADDR
C--CLEAR THE STORE
      CALL XCSAE
      CALL XRSL
      LFL=LR51-1
C--CREATE A RECORD TYPE 51
      IREC=-51
      I=KCEDR(LN,1,IREC,MDR51,0,5)
C--UPDATE THE RECORD HEADER
      CALL XUDRH(LN,IREC,MDR51,NR51)
C--WRITE THE RECORD TO THE DISC
      I=LR51
      CALL XWDRTD(LN,IREC,IADDL,IADDR,LENGTH,ICOM50,IDIM50,0,IBUFF)
C--OUTPUT THE DATA TO THE DISC
      CALL XUPF(LR51,ISTORE(I),MDR51*NR51)
C--NOW SWITCH RECORDS 50 AND 51 SO THAT THEY ARE AFTER RECORD 52
      IBUFF(1)=IADD5
      CALL XUPF(IADD2,IBUFF(1),1)
C--ALTER THE BACKWARD POINTER FOR RECORD 50
      L=KINCRF(1)
      IBUFF(1)=IADD2
      CALL XUPF(IADD5+L,IBUFF(1),1)
C--NOW THE FORWARD POINTER OF RECORD 51
      IBUFF(1)=IADD3
      CALL XUPF(IADD6,IBUFF(1),1)
C--NOW THE BACKWARD POINTER FOR THE RECORD ORIGINALLY AFTER 52
      IBUFF(1)=IADD6
      CALL XUPF(IADD3+L,IBUFF(1),1)
C--AND NOW THE END OF CHAIN POINTER
      IBUFF(1)=0
      CALL XUPF(IADD4,IBUFF(1),1)
C--WRITE THE INFORMATION TO THE DISC ABOUT THIS LIST
      CALL XWLIND(LN,IADDI,LENGTH,0,0)
C--SWITCH BACK TO THE ORIGINAL DISC
      N = KSWPDU ( NUDUMP )
      RETURN
      END
C
CODE FOR XMAXCH
      SUBROUTINE XMAXCH(IN,N)
C--SET THE MAXIMUM LENGTH ALLOWED FOR A CHARACTER STRING.
C
C  IN      THE ARRAY CONTAINING THE STRING  -  IN WORDS 2 TO 'N'.
C          THE MAXIMUM LENGTH IS SET IN WORD 1.
C  N       THE NUMBER OF POSSIBLE CHARACTERS PLUS THE LENGTH WORD.
C
C--
C
      DIMENSION IN(N)
C
\XUNITS
\XSSVAL
\XCHARS
\XERVAL
\XIOBUF
C
C--CHECK IF THE FIRST CHARACTER IS BLANK
      IF(IN(2).EQ.IB)GOTO 1050
C--INITIALISE
      J=N
      IN(1)=N-1
C--LOOP OVER EACH OF THE CHARACTERS, STARTING WITH THE LAST
      DO 1000 I=2,N
      IF(IN(J).NE.IB)RETURN
C--DECREMENT THE COUNT
      IN(1)=IN(1)-1
C--UPDATE THE CURRENT POSITION
      J=J-1
1000  CONTINUE
C--A COMPLETE SET OF BLANKS OR A LEADING BLANK
1050  CONTINUE
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1100)
      ENDIF
1100  FORMAT(' Keywords that start with a blank',
     2 ' or contain all blanks are illegal')
      CALL XERHND ( IERSEV )
      RETURN
      END
C
CODE FOR XPRTHI
      SUBROUTINE XPRTHI(ITYPE,ISTART,ISTOP)
C--LIST THE INSTRUCTIONS DETAILS STORED IN LIST 50 TO THE LINE
C  PRINTER.
C
C  ITYPE   THE TYPE OF PRINT REQUIRED :
C
C          -1  PRINT DETAILS OF ALL DIRECTIVES AND DATA RECORDS.
C           0  PRINT DETAILS OF USER DIRECTIVES ONLY.
C
C  ISTART  THE DIRECTIVE NUMBER AT WHICH TO START PRINTING.
C
C--
\ISTORE
\ICOM50
C
      CHARACTER*1 CCONT(4)
      CHARACTER*8 CFM(5)
      CHARACTER*4 CNONE
C
\STORE
\XLISTI
\XUNITS
\XSSVAL
\XLST50
\XCONST
\XCHARS
\XWORKA
\XIOBUF
C
\QSTORE
\QCOM50
C
C
      DATA CCONT / ' ' , ' ' , '(' , ')' /
      DATA CFM / 'Title   ' , 'Key prt ' , 'Print   ' , 'Key prt ' ,
     2           'Punch   ' /
      DATA CNONE / 'None' /
C
C--CLEAR THE CORE
      CALL XCSAE
      CALL XRSL
C--LOAD THE INITIAL PART OF LIST 50
      CALL XFAL50
C--ASSIGN A POINTER TO THE INSTRUCTION NAMES
      MR50=LR50
      MDR501=MDR50-2
C -- IF A FINAL INSTRUCTION NUMBER HAS BEEN GIVEN, DON'T PRINT LIST
C    GENERATION COMMANDS. THESE ARE ONLY OUTPUT IF ALL INSTRUCTIONS ARE
C    REQUIRED.
      IF ( ISTOP .GT. 0 ) GO TO 1100
C--CHECK IF THERE ARE ANY LIST GENERATION COMMANDS
      IF(NR52)1100,1100,1000
C--PRINT THE LIST GENERATION COMMANDS
1000  CONTINUE
      CALL XPRTCN
      MR52=LR52+MDR52*NR52-1
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1050)(ISTORE(I),I=LR52,MR52)
      ENDIF
1050  FORMAT(' List generation commands',/,' List type',5X,
     2 'Instruction', 1X,I8,5X,19A4)
C--RECORD 'NFL' AND 'LFL'
1100  CONTINUE
      JA=NFL
      JB=LFL
C
C--LOOP OVER EACH INSTRUCTION
      CALL XPRTCN
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1150)
      ENDIF
1150  FORMAT(' Available instructions')
      JSTOP=ISTOP
      IF(JSTOP)1152,1152,1153
1152  CONTINUE
C----- PRINT EVERYTHING
      JSTOP = NR50
      GOTO 1155
1153  CONTINUE
      JSTOP=ISTART+JSTOP-1
1155  CONTINUE
      JSTOP=MIN(JSTOP,NR50)
      DO 4700 JZ=1,JSTOP
C--CHECK IF WE SHOULD DETAILS OF THIS INSTRUCTION
      IF(JZ-ISTART)4650,1200,1200
C--CLEAR STORE AND RE-ALLOCATE IT
1200  CONTINUE
      CALL XCSAE
      CALL XRSL
      NFL=JA
      LFL=JB
C--LOAD THE DETAILS FOR THE CURRENT INSTRUCTION
      CALL XLL50R(JZ)
      MDR601=MDR60-2
C--PRINT THE INSTRUCTION NAME AND NUMBER OF DIRECTIVES
      J=MR50+MDR501
      IF (ISSPRT .EQ.0) WRITE(NCWU,1250) IH,(ISTORE(I+1),I=MR50,J),NR60
      WRITE(NCAWU,1250) IH,(ISTORE(I+1),I=MR50,J),NR60
      IF(IQUN.NE.JQUN) THEN
      WRITE ( CMON, 1250) IH,(ISTORE(I+1),I=MR50,J),NR60
      CALL XPRVDU(NCVDU, 1,0)
      ENDIF
1250  FORMAT(1X,13A1,5X,I3,'  Directives')
C--PRINT THE LOAD DETAILS
      DO 1350 K=1,NR64
      J=MR64+MDR64-1
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1300)(ISTORE(I),I=MR64,J)
      ENDIF
      WRITE(NCAWU,1300)(ISTORE(I),I=MR64,J)
1300  FORMAT(' Link ',I2,5X,'Min. core size ',I8,5X,20A4)
      MR64=MR64+MDR64
1350  CONTINUE
C--CHECK IF THERE IS ANY LIST INFORMATION STORED
      IF(NR63)1500,1500,1400
C--PRINT THE LISTS TO BE USED
1400  CONTINUE
      MR63=LR63+(NR63-1)*MDR63
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1450)(ISTORE(I),I=LR63,MR63,MDR63)
      ENDIF
      WRITE(NCAWU,1450)(ISTORE(I),I=LR63,MR63,MDR63)
1450  FORMAT('  Uses lists :  ',25I4)
C--CHECK IF THERE ARE ANY DIRECTIVES FOR THIS INSTRUCTION
1500  CONTINUE
      IF(NR60)4650,4650,1550
C
C--LOOP OVER EACH DIRECTIVE FOR THIS INSTRUCTION
1550  CONTINUE
      DO 4600 JY=1,NR60
C--CHECK IF ALL DIRECTIVES SHOULD BE PRINTED
      IF(ITYPE)1650,1600,1600
C--USER DIRECTIVES ONLY  -  CHECK THE NUMBER OF REPEATS ALLOWED
1600  CONTINUE
      IF(ISTORE(MR61+7))1650,3350,1650
C--FIND THE LAST WORD OF THE DIRECTIVE NAME
1650  CONTINUE
      J=MR60+MDR601
C--FIND THE ABSOLUTE VALUE OF THE REPEAT COUNT
      M=IABS(ISTORE(MR61+7))
      N=1
C--CHECK IF THE REPEAT COUNT OR ITS ADDRESS IS GIVEN
      IF(ISTORE(MR61+7))1700,1750,1750
C--ITS ADDRESS IS GIVEN
1700  CONTINUE
      N=3
C--PRINT THE DIRECTIVE AND ITS DETAILS
1750  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1800)JY,(ISTORE(I+1),I=MR60,J),ISTORE(MR61+3),
     2 CCONT(N),M,CCONT(N+1),ISTORE(MR61+6),ISTORE(MR61+31)
      ENDIF
      WRITE(NCAWU,1801)JY,(ISTORE(I+1),I=MR60,J),ISTORE(MR61+3)
      WRITE ( CMON, 1801) JY,(ISTORE(I+1),I=MR60,J), ISTORE(MR61+3)
      CALL XPRVDU(NCVDU, 1,0)
1801  FORMAT(5X,I3,'. ',12A1,5X,I3,'  Parameter keyword(s)')
1800  FORMAT(/5X,I3,'. ',12A1,5X,I3,'  Parameter keyword(s)',5X,A1,I4,
     2 A1,'  Repeat(s)',5X,I2,'  excluded and ',I2,
     3 '  enabling directive(s)'/)
C--CHECK IF THERE ARE ANY PARAMETERS FOR THIS DIRECTIVE
      IF(ISTORE(MR61+3))3350,3350,1850
C--SET UP THE ADDRESS POINTERS TO THE PARAMETER RECORD
1850  CONTINUE
      JS=ISTORE(MR61)+LR62
      JW=ISTORE(MR61+3)
C
C--LOOP OVER EACH OF THE PARAMETER KEYWORDS
      DO 3300 JX=1,JW
C--COMPUTE THE ADDRESS OF THE REST OF THE DATA FOR THIS PARAMETER
      JT=JS+ISTORE(MR61+1)
C--COMPUTE THE ADDRESS OF THE FINAL WORD OF THE NAME
      JU=JT-2
C--SET UP THE PARAMETER TYPE
      ITYPEI=ISTORE(JT)
      ITYPES=ISTORE(JT+5)
C--CHECK IF THERE ARE ANY PERMISSABLE VALUES STORED
      IF(ISTORE(JT+3))1900,1900,2400
C--NO PERMISSABLE VALUES  -  CHECK FOR A DEFAULT VALUE
1900  CONTINUE
      IF(ISTORE(JT+7))1950,2000,2000
C--NO DEFAULT GIVEN
1950  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,1955)(ISTORE(I+1),I=JS,JU),ISTORE(JT+4),ISTORE(JT+9),
     2 CNONE
      ENDIF
      WRITE(NCAWU,1965)(ISTORE(I+1),I=JS,JU),CNONE
      WRITE ( CMON, 1965) (ISTORE(I+1),I=JS,JU),CNONE
      CALL XPRVDU(NCVDU, 1,0)
1965  FORMAT(11X,12A1,5X,'Default value = ',A4)
1955  FORMAT(34X,12A1,5X,'L = ',I3,I13,6X,'Default value = ',A4)
      GOTO 3250
C--CHECK THE TYPE OF PARAMETER STORED
2000  CONTINUE
      GOTO(2300, 2200, 2100, 1950, 2100, 2050),ITYPES
C2050  STOP604
2050  CALL GUEXIT(604)
C--CHARACTER STRING
2100  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2150)(ISTORE(I+1),I=JS,JU),ISTORE(JT+4),ISTORE(JT+9),
     2 ISTORE(JT+8)
      ENDIF
      WRITE(NCAWU,2151)(ISTORE(I+1),I=JS,JU),      ISTORE(JT+8)
      WRITE ( CMON, 2151) (ISTORE(I+1),I=JS,JU),ISTORE(JT+8)
      CALL XPRVDU(NCVDU, 1,0)
2151  FORMAT(11X,12A1,5X,'Default value = ',A4)
2150  FORMAT(34X,12A1,5X,'L = ',I3,I13,6X,'Default value = ',A4)
      GOTO 3250
C--FLOATING POINT NUMBER
2200  CONTINUE
      WRITE(NCAWU,2251)(ISTORE(I+1),I=JS,JU),STORE(JT+8)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2250)(ISTORE(I+1),I=JS,JU),ISTORE(JT+4),ISTORE(JT+9),
     2 STORE(JT+8)
      ENDIF
      WRITE ( CMON, 2251) (ISTORE(I+1),I=JS,JU),STORE(JT+8)
      CALL XPRVDU(NCVDU, 1,0)
2251  FORMAT(11X,12A1,5X,'Default value = ',E15.5)
2250  FORMAT(34X,12A1,5X,'L = ',I3,I13,6X,'Default value = ',E15.5)
      GOTO 3250
C--FIXED POINT NUMBER
2300  CONTINUE
      WRITE(NCAWU,2351)(ISTORE(I+1),I=JS,JU),ISTORE(JT+8)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2350)(ISTORE(I+1),I=JS,JU),ISTORE(JT+4),ISTORE(JT+9),
     2 ISTORE(JT+8)
      ENDIF
      WRITE ( CMON, 2351) (ISTORE(I+1),I=JS,JU),ISTORE(JT+8)
      CALL XPRVDU(NCVDU, 1,0)
2351  FORMAT(11X,12A1,5X,'Default value = ',I10)
2350  FORMAT(34X,12A1,5X,'L = ',I3,I13,6X,'Default value = ',I10)
      GOTO 3250
C--PERMISSABLE VALUES STORED  -  CHECK FOR A DEFAULT VALUE
2400  CONTINUE
      JC=0
      IF(ISTORE(JT+7))2600,2450,2450
C--DEFAULT VALUE INDICATED  -  COMPUTE ITS POSITION IN THE PERMISSABLE V
2450  CONTINUE
      J=ISTORE(JT+8)-ISTORE(JT+6)
      IF(J)2600,2500,2500
C--DEFAULT IS PARTLY IN RANGE  -  CHECK THE MAXIMUM
2500  CONTINUE
      IF(J-ISTORE(JT+3))2550,2600,2600
C--DEFAULT VALUE IS IN RANGE  -  PRINT THE PERMISSABLE VALUES
2550  CONTINUE
      JC=J+1
C--PRINT THE KEYWORD AND NUMBER OF VALUES
2600  CONTINUE
      WRITE(NCAWU,2651)(ISTORE(I+1),I=JS,JU),ISTORE(JT+3)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2650)(ISTORE(I+1),I=JS,JU),ISTORE(JT+4),ISTORE(JT+9),
     2 ISTORE(JT+3)
      ENDIF
      WRITE ( CMON, 2651) (ISTORE(I+1),I=JS,JU),ISTORE(JT+3)
      CALL XPRVDU(NCVDU, 1,0)
2651  FORMAT(11X,12A1,'with ',I5,
     2 '  permissable values')
2650  FORMAT(34X,12A1,5X,'L = ',I3,I13,6X,'with ',I5,
     2 '  permissable values'/)
C--PREPARE TO LOOP OVER THE PERMISSABLE VALUES
      JR=ISTORE(JT+3)
      JQ=ISTORE(JT+1)+LR62
      JO=ISTORE(JT+6)
C--LOOP OVER THE PERMISSABLE VALUES
      DO 3200 JP=1,JR
      JV=1
C--CHECK IF THIS IS THE DEFAULT VALUE
      IF(JP-JC)2750,2700,2750
C--THIS IS THE DEFAULT VALUE
2700  CONTINUE
      JV=2
C--BRANCH ON THE INPUT TYPE
2750  CONTINUE
      GOTO(3050, 2950, 2850, 2850, 2850, 2800),ITYPEI
C2800  STOP605
2800  CALL GUEXIT(605)
C--CHARACTER STRING
2850  CONTINUE
      J=JQ+ISTORE(JT+2)-2
      WRITE(NCAWU,2901)JO,(ISTORE(I+1),I=JQ,J),(IB,I=1,JV)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,2900)JO,(ISTORE(I+1),I=JQ,J),(IB,I=1,JV)
      ENDIF
      WRITE ( CMON, 2901) JO,(ISTORE(I+1),I=JQ,J),(IB,I=1,JV)
      CALL XPRVDU(NCVDU, 1,0)
2901  FORMAT(22X,I4,1X,14A1,'Default value')
2900  FORMAT(86X,I4,1X,14A1,'Default value')
      GOTO 3150
C--FLOATING POINT NUMBER
2950  CONTINUE
      WRITE(NCAWU,3001)JO,STORE(JQ),(IB,I=1,JV)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3000)JO,STORE(JQ),(IB,I=1,JV)
      ENDIF
      WRITE ( CMON, 3001) JO,STORE(JQ),(IB,I=1,JV)
      CALL XPRVDU(NCVDU, 1,0)
3001  FORMAT(22X,I4,1X,E15.5,2A1,'Default value')
3000  FORMAT(86X,I4,1X,E15.5,2A1,'Default value')
      GOTO 3150
C--FIXED POINT NUMBER
3050  CONTINUE
      WRITE(NCAWU,3101)JO,ISTORE(JQ),(IB,I=1,JV)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3100)JO,ISTORE(JQ),(IB,I=1,JV)
      ENDIF
      WRITE ( CMON, 3101)JO,ISTORE(JQ),(IB,I=1,JV)
      CALL XPRVDU(NCVDU, 1,0)
3101  FORMAT(22X,I4,1X,I10,2A1,'Default value')
3100  FORMAT(86X,I4,1X,I10,2A1,'Default value')
C--UPDATE FOR THE NEXT PERMISSABLE VALUE
3150  CONTINUE
      JQ=JQ+ISTORE(JT+2)
      JO=JO+1
3200  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3500)
      ENDIF
C--UPDATE FOR THE NEXT PARAMETER
3250  CONTINUE
      JS=JS+ISTORE(MR61+2)
3300  CONTINUE
C
C--CHECK IF THERE ARE ANY EXCLUDED DIRECTIVES FOR THIS DIRECTIVE
3350  CONTINUE
      IF(ISTORE(MR61+6))3600,3600,3400
C--EXCLUDED DIRECTIVES TO BE PRINTED  -  SET UP THE ADDRESS POINTERS
3400  CONTINUE
      WRITE(NCAWU,3450)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3450)
      ENDIF
      WRITE ( CMON, 3450)
      CALL XPRVDU(NCVDU, 1,0)
3450  FORMAT(10X,'Excludes :')
      N=ISTORE(MR61+6)
      M=ISTORE(MR61+4)+LR62
C--LOOP OVER THE EXCLUDED DIRECTIVES
      DO 3550 L=1,N
      J=LR60+(ISTORE(M)-1)*MDR60
      K=J+MDR601
      WRITE(NCAWU,3500)L,(ISTORE(I+1),I=J,K)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3500)L,(ISTORE(I+1),I=J,K)
      ENDIF
      WRITE ( CMON, 3500) L,(ISTORE(I+1),I=J,K)
      CALL XPRVDU(NCVDU, 1,0)
3500  FORMAT(23X,I4,1X,1X,12A1)
C--UPDATE FOR THE NEXT DIRECTIVE
      M=M+ISTORE(MR61+5)
3550  CONTINUE
C--CHECK IF THERE ARE ANY ENABLING DIRECTIVES FOR THIS DIRECTIVE
3600  CONTINUE
      IF(ISTORE(MR61+31))4000,4000,3650
C--ENABLING DIRECTIVES TO BE PRINTED  -  SET UP THE ADDRESS POINTERS
3650  CONTINUE
      WRITE(NCAWU,3700)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3700)
      ENDIF
      WRITE ( CMON, 3700)
      CALL XPRVDU(NCVDU, 1,0)
3700  FORMAT(10X,'Enabled by :')
      N=ISTORE(MR61+31)
      M=ISTORE(MR61+29)+LR62
C--LOOP OVER THE ENABLING DIRECTIVES
      DO 3950 L=1,N
      J=LR60+(ISTORE(M)-1)*MDR60
      K=J+MDR601
C--CHECK IF THE JUST THE DIRECTIVE IS REQUIRED
      IF(ISTORE(M+1))3750,3750,3800
C--JUST THE DIRECTIVE
3750  CONTINUE
      WRITE(NCAWU,3500)L,(ISTORE(I+1),I=J,K)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3500)L,(ISTORE(I+1),I=J,K)
      ENDIF
      WRITE ( CMON, 3500) L,(ISTORE(I+1),I=J,K)
      CALL XPRVDU(NCVDU, 1,0)
      GOTO 3900
C--DIRECTIVE AND KEYWORD VALUE ARE REQUIRED
3800  CONTINUE
      WRITE(NCAWU,3850)L,(ISTORE(I+1),I=J,K),ISTORE(M+1),ISTORE(M+2)
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,3850)L,(ISTORE(I+1),I=J,K),ISTORE(M+1),ISTORE(M+2)
      ENDIF
      WRITE (CMON, 3850)L,(ISTORE(I+1),I=J,K),ISTORE(M+1),ISTORE(M+2)
      CALL XPRVDU(NCVDU, 1,0)
3850  FORMAT(23X,I4,1X,12A1,' with parameter',I4,' stored as',I4)
C--UPDATE FOR THE NEXT DIRECTIVE
3900  CONTINUE
      M=M+ISTORE(MR61+30)
3950  CONTINUE
C--CHECK IF THIS DIRECTIVE ALSO DEFINES A DATA RECORD
4000  CONTINUE
      IF(ISTORE(MR61+11))4050,4550,4050
C--DATA RECORD DEFINED  -  PRINT ITS DETAILS
4050  CONTINUE
      K=IABS(ISTORE(MR61+9))
      L=1
      IF(ISTORE(MR61+9))4100,4150,4150
C--LOCATION NOT VALUE STORED
4100  CONTINUE
      L=3
C--CHECK THE NUMBER OF GROUPS
4150  CONTINUE
      M=IABS(ISTORE(MR61+10))
      N=1
      IF(ISTORE(MR61+10))4200,4250,4250
C--LOCATION STORED
4200  CONTINUE
      N=3
C--NOW PRINT THE DETAILS
4250  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4300)ISTORE(MR61+11),ISTORE(MR61+13),CCONT(L),K,
     2 CCONT(L+1),CCONT(N),M,CCONT(N+1),ISTORE(MR61+12)
      ENDIF
4300  FORMAT( 10X, 'Defines record type ', I6,'  for list type ',
     2 I5, 5X, 'LENGRP = ', A1, I5, A1, 5X, 'NGROUP = ', A1, I5, A1,
     3 5X, 'Offset = ', I5)
C--LOOP OVER THE TITLE AND FORMATS
      JQ=MR61+14
      JS=3
      JR=JQ+4*JS
      I=1
      DO 4500 J=JQ,JR,JS
C--CHECK IF THIS TITLE OR FORMAT IS GIVEN
      IF(ISTORE(J))4450,4450,4350
C--PRINT THIS INFORMATION
4350  CONTINUE
      K=ISTORE(J+2)+LR62
      L=K+ISTORE(J)-1
      IF (ISSPRT .EQ. 0) THEN
      WRITE(NCWU,4400) CFM(I) , (STORE(M),M=K,L)
      ENDIF
4400  FORMAT ( 10X , A , 'format : ' , 20A4/10(10X,20A4/))
C--UPDATE FOR THE NEXT
4450  CONTINUE
      I=I+1
4500  CONTINUE
C--UPDATE FOR THE NEXT DIRECTIVE
4550  CONTINUE
      MR60=MR60+MDR60
      MR61=MR61+MDR61
4600  CONTINUE
C
C--UPDATE FOR THE NEXT INSTRUCTION
4650  CONTINUE
      MR50=MR50+MDR50
4700  CONTINUE
      RETURN
      END
CODE FOR KGVAL
        FUNCTION KGVAL(CINSTR, CDIR, CPARAM, CVALUE, CDEF,
     1                INSTR, IDIR, IPARAM, IVAL, JVAL, VAL, JTYPE)
C
C----- GET  TEXT OR VALUE CORRESPONDING TO PARAMETER CPARAM OR IPARAM
C       FOR THE DIRECTIVE CDIR IN THE INSTRUCTION CINSTR
C
C
C      IF INSTR +VE, USE AS INDEX AND FIND CPARAM
C      IF        -VE, USE CPARAM AND RETURN INDEX
C      IF IVAL .EQ. NOWT, RETURN DEFAULT VALUES IN JVAL,VAL OR JTYPE
C       RETURN -1 IF FAIL
C
C
      CHARACTER *(*) CINSTR, CDIR, CPARAM, CVALUE, CDEF
C
\ISTORE
C
\STORE
\XLST50
\XUNITS
\XSSVAL
\XCONST
C
\QSTORE
C
      JVAL = 0
      VAL = 0.0
C
C----- LINSTR LDIR LPARAM LVALUE LENGTHS
C      SET BY BUFFER LENGTH IN NEXT FEW ROUTINES
C
      LDIR   = MIN0 (15, LEN (CDIR))
      LPARAM = MIN0 (15, LEN (CPARAM))
      LVALUE = MIN0 (15, LEN (CVALUE))
C
      KGVAL = 1
C----- SAVE WORKSPACE ADDRESS
      NFLSAV = NFL
      LFLSAV = LFL
C
C----- FIND THE INSTRUCTION DETAILS
      IF ( KIVAL ( INSTR, CINSTR, LINSTR) .LE. 0) GOTO 6000
C
C----- FIND THE DIRECTIVE DETAILS
      IF ( KDVAL ( IDIR, CDIR, LDIR) .LE. 0) GOTO 6000
C
C----- FIND THE PARAMETER DETAILS
      IF (KPVAL (IPARAM, CPARAM, LPARAM, IVAL, JTYPE, IDEF, DEF,
     1 CDEF, CVALUE ) .LE. 0) GOTO 6000
C
C----- RESTORE WORK SPACE
      NFL = NFLSAV
      LFL = LFLSAV
      RETURN
6000  CONTINUE
C      WRITE(NCAWU,*) ' some sort of failure in KGVAL'
      KGVAL = -1
      RETURN
      END
C
CODE FOR KIVAL
      FUNCTION KIVAL ( INSTR, CINSTR, LINSTR)
C
C----- GIVEN AN INSTRUCTION NAME OR NUMBER, CHECKS ITS
C      VALIDITY AND RETURNS DIRECTIVE INFO
      CHARACTER *(*) CINSTR
      DIMENSION ITEXT(15)
\ISTORE
C
\STORE
\XLST50
\XUNITS
\XSSVAL
\XCONST
C
\QSTORE
C
      KIVAL = 0
C----- LOAD LIST 50 IF REQUIRED, SINCE WE NEED TO FIND
      IF (KHUNTR (50,0, IADDL,IADDR,IADDD, -1) .NE. 0) CALL XFAL50
C
      LINSTR = MIN0 (15, LEN (CINSTR))
      IF (INSTR .LE. 0) THEN
C----- LOOK FOR INSTRUCTION
        READ (CINSTR, '(15A1)') (ITEXT(I), I=1,LINSTR)
        LINL = MIN0( LINSTR, MDR50-1)
        INSTR = KCHKDS (ITEXT, LINSTR, LINL, ISTORE(LR50), NR50, MDR50)
        IF (INSTR .LE. 0) GOTO 6000
      ELSE
C----- STORE INSTRUCTION NAME
        IF (INSTR .GT. NR50) GOTO 6000
        LINSTR = MIN0( LEN(CINSTR), MDR50-1)
        ISTART = LR50 + (INSTR-1) * MDR50 +1
        IEND = ISTART + LINSTR-1
        WRITE(CINSTR, '(15A1)') (ISTORE(I), I=ISTART,IEND)
      ENDIF
C----- LOAD RELAVENT BIT OF LIST 50
      CALL XLL50R(INSTR)
      KIVAL = 1
6000  CONTINUE
      RETURN
      END
C
CODE FOR KDVAL
      FUNCTION KDVAL ( IDIR, CDIR, LDIR )
C
C----- GIVEN AN DIRECTIVE NAME OR NUMBER, CHECKS ITS
C      VALIDITY AND RETURNS PARAMETER INFO
      CHARACTER *(*) CDIR
      DIMENSION ITEXT(15)
      PARAMETER (IDIMN =100)
      DIMENSION ICOMN(IDIMN)
\ISTORE
C
\STORE
\XLST50
\XUNITS
\XSSVAL
\XCONST
C
\QSTORE
C
      CALL XZEROF(ICOMN, IDIMN)
C
      KDVAL = 0
      LDIR   = MIN0 (15, LEN (CDIR))
      IF (IDIR .LE. 0) THEN
C----- LOOK FOR THE DIRECTIVE
        READ (CDIR, '(15A1)') (ITEXT(I), I=1,LDIR)
        JDIR = MIN0( LDIR, MDR60-1)
        IDIR = KCHKDS (ITEXT, LDIR, JDIR, ISTORE(LR60), NR60, MDR60)
        IF (IDIR .LE. 0) GOTO 6000
      ELSE
C----- STORE DIRECTIVE NAME
        IF (IDIR .GT. NR60) GOTO 6000
C----- NOTE THE -2 ????
        LDIR = MIN0( LEN(CDIR), MDR60-2)
        ISTART = LR60 + (IDIR-1) * MDR60 +1
        IEND = ISTART + LDIR-1
        WRITE(CDIR, '(15A1)' ) (ISTORE(I), I=ISTART,IEND)
      ENDIF
      CALL XDIRFL (IDIR, ICOMN, IDIMN)
      IF (NR62D .LE. 0) GOTO 6000
      KDVAL = 1
6000  CONTINUE
      RETURN
      END
C
CODE FOR KPVAL
      FUNCTION KPVAL (IPARAM, CPARAM, LPARAM, IVAL,
     1                JTYPE, IDEF, DEF, CDEF, CVALUE)
C
C----- GIVEN A PARAMETER NAME OR NUMBER, CHECKS ITS
C      VALIDITY AND RETURNS VALUE INFO
C
      CHARACTER *(*) CPARAM, CVALUE, CDEF
      DIMENSION ITEXT(15)
\ISTORE
C
\STORE
\XLST50
\XUNITS
\XSSVAL
\XCONST
C
\QSTORE
C
      LPARAM = MIN0 (15, LEN (CPARAM))
      IF (IPARAM .LE. 0) THEN
C----- LOOK FOR THE PARAMETER
        READ (CPARAM, '(15A1)') (ITEXT(I), I=1,LPARAM)
        JPARAM = MIN0( LPARAM, MDR62N-1)
        IPARAM =
     1  KCHKDS (ITEXT, LPARAM, JPARAM, ISTORE(LR62N), NR62N, MDR62N)
        IF (IPARAM .LE. 0) GOTO 6000
      ELSE
C----- STORE PARAMETER NAME
        IF (IPARAM .GT. NR62N) GOTO 6000
        LPARAM = MIN0( LEN(CPARAM), MDR62N-1)
        ISTART = LR62N + (IPARAM-1) * MDR62D +1
        IEND = ISTART + LPARAM-1
        WRITE(CPARAM, '(15A1)' ) (ISTORE(I), I=ISTART,IEND)
      ENDIF
C
C----- SET THE START OF THE DEFAULT VALUES PLUS OTHER GOODIES
      MR62D = LR62D + MDR62D*(IPARAM-1)
      JTYPE = ISTORE( MR62D)
      NVAL = ISTORE(MR62D+3)
      LVAL = LR62 + ISTORE(MR62D+1)
      MDVAL = ISTORE(MR62D+2)
      MVAL = LVAL + ( NVAL - 1 ) * MDVAL
      IFVAL = ISTORE(MR62D+6)
C
C----- FIND THE DEFAULT ADDRESS
C
      IDEFLT = ISTORE(MR62D+7)
      IF (IDEFLT .GE. 0) THEN
        IF (NVAL .GE. 0) THEN
          IDEFAD = LVAL + ( ISTORE(MR62D+8)-ISTORE(MR62D+6) )*MDVAL
        ELSE
          IDEFAD = MR62D+8
        ENDIF
      ENDIF
      IADD = IDEFAD
      IDEF = 0
      DEF = 0.0
      CDEF = ' '
      CVALUE = ' '
      IF (JTYPE .EQ. 1) THEN
            IDEF = ISTORE(LVAL)
      ELSE IF (JTYPE .EQ. 2) THEN
            DEF = STORE(LVAL)
      ELSE
        LDEF = MIN (LEN(CDEF), MDVAL-2)
        WRITE (CDEF, '(12A1)') ( ISTORE(J), J = IADD+1,IADD+LDEF )
C
        IF (IVAL .GE. NOWT) THEN
C----- SET THE ACTUAL VALUE FOR TEXT ARGUMENTS
          IPARAD = LVAL + ( IVAL -ISTORE(MR62D+6) ) * MDVAL
          IADD = IPARAD
          LVAL = MIN (LEN(CVALUE), MDVAL-2)
          WRITE (CVALUE, '(12A1)') (ISTORE(J), J = IADD+1,IADD+LVAL)
        ENDIF
      ENDIF
C
      KPVAL = 1
6000  CONTINUE
      RETURN
      END
C
CODE FOR KDLIS
      FUNCTION KDLIS ( A)
C
C----- RETURNS LIST OF POSSIBLE DIRECTIVES
C----- THE INSTRUCTION MUST HAVE BEEN LOADED (EG BY A CALL TO KIVAL)
\ISTORE
C
\STORE
\XLST50
\XUNITS
\XSSVAL
\XCONST
\XIOBUF
C
\QSTORE
C
      A = A
      MR60 = LR60
      WRITE ( CMON, 90 ) NR60
      CALL XPRVDU(NCVDU, 1,0)
90    FORMAT( ' Expecting ', I4, ' directives' )
      DO 200 K = 1, NR60
C----- CHECK ITS A USER DIRECTIVE
      IF (ISTORE(MR61+7) .NE. 0) THEN
        J = MR60 + MDR60-2
        WRITE(NCAWU, '(1X, I5, 2X, 12A1)')  K, (ISTORE(I+1),I=MR60,J)
        WRITE ( CMON, '(1X, I5, 2X, 12A1)')  K, (ISTORE(I+1),I=MR60,J)
        CALL XPRVDU(NCVDU, 1,0)
      ENDIF
      MR60 = MR60 + MDR60
200   CONTINUE
      KDLIS = 0
      RETURN
      END
C
C
CODE FOR KPLIS
      FUNCTION KPLIS ( A)
C
C----- RETURNS LIST OF POSSIBLE PARAMETERS
C----- THE DIRECTIVE MUST HAVE BEEN LOADED (EG BY A CALL TO KDVAL)
\ISTORE
C
\STORE
\XLST50
\XUNITS
\XSSVAL
\XCONST
\XIOBUF
C
\QSTORE
C
      A = A
      JW = ISTORE(MR61+3)
      JS = ISTORE(MR61) + LR62
 
      WRITE ( CMON, 90) JW
      CALL XPRVDU(NCVDU, 1,0)
90    FORMAT( ' Expecting ', I4, ' directives' )
      DO 200 JX = 1, JW
      JT = JS + ISTORE(MR61+1)
      JU = JT - 2
        WRITE(NCAWU, '(1X, I5, 2X, 12A1)')  JX, (ISTORE(I+1),I=JS,JU)
      WRITE ( CMON, '(1X, I5, 2X, 12A1)')  JX, (ISTORE(I+1),I=JS,JU)
      CALL XPRVDU(NCVDU, 1,0)
      JS = JS + ISTORE(MR61+2)
200   CONTINUE
      KPLIS = 0
      RETURN
      END
C
C
CODE FOR KVLIS
      FUNCTION KVLIS ( A, LVAL, NVAL, MDVAL)
C
C----- RETURNS LIST OF POSSIBLE VALUES AND DEFAULT
C
\ISTORE
C
\STORE
\XLST50
\XUNITS
\XSSVAL
\XCONST
\XIOBUF
C
\QSTORE
C
      A = A
      DO 999 I = 1,  NVAL
      IADD = LVAL + (I - ISTORE(MR62D+6)) * MDVAL
      WRITE ( NCAWU , 1050 ) I, ( ISTORE(J) ,
     2 J = IADD+1,IADD+MDVAL-2 )
      WRITE ( CMON, 1050 ) I, (ISTORE(J),J = IADD+1,IADD+MDVAL-2 )
      CALL XPRVDU(NCVDU, 1,0)
1050  FORMAT ( 1X , 'value', I6, ' is : ' , 12A1 )
C
999   CONTINUE
      KVLIS = 0
      RETURN
      END
C
CODE FOR K50TST
      SUBROUTINE K50TST
C
C----- TEST THE LIST50 ACCESS ROUTINES
\ISTORE
      CHARACTER *13 CINST, CDIR, CPAR, CDEF, CVALUE
C
\STORE
\XLST50
\XUNITS
\XSSVAL
\XCONST
\XIOBUF
C
\QSTORE
C
      WRITE(NCAWU,'(A)') ' ######## INSTRUCTIONS ################'
      WRITE ( CMON, '(A39)') ' ######## INSTRUCTIONS ################'
      CALL XPRVDU(NCVDU, 1,1)
      LINST = 13
      INST = 33
      CINST(1:13) = '!!!!!!!!!!!!!'
      WRITE ( CMON, '(A39)') ' ######### CALL BY VALUE ##############'
      CALL XPRVDU(NCVDU, 1,1)
      WRITE ( CMON, '(2I4,A13,A1)') INST, LINST, CINST(1:LINST),'#'
      CALL XPRVDU(NCVDU, 1,1)
      I = KIVAL ( INST, CINST, LINST)
      WRITE ( CMON, '(2I4,A13,A1)')  INST, LINST, CINST(1:LINST),'#'
      CALL XPRVDU(NCVDU, 1,1)
      WRITE ( CMON, '(A10)') ' KDLISTING'
      CALL XPRVDU(NCVDU, 1,1)
      A = 0.0
      I =  KDLIS(A)
      LINST = 7
      INST = 0
      CINST(1:7) = 'goodies'
      WRITE ( CMON, '(A39)') ' ######### CALL BY NAME ###############'
      CALL XPRVDU(NCVDU, 1,1)
      WRITE ( CMON, '(2I4,A7,A1)')  INST, LINST, CINST(1:LINST),'#'
      CALL XPRVDU(NCVDU, 1,1)
      I = KIVAL ( INST, CINST(1:7), LINST)
      WRITE ( CMON, '(2I4,A7,A1)')  INST, LINST, CINST(1:LINST),'#'
      CALL XPRVDU(NCVDU, 1,1)
C
C
      WRITE ( CMON, '(A39)') ' ######## DIRECTIVES ##################'
      CALL XPRVDU(NCVDU, 1,1)
      LINDIR = 13
      IDIR = 4
      CDIR(1:4) = '!!!!'
      WRITE ( CMON, '(A39)') ' ######### CALL BY VALUE ##############'
      CALL XPRVDU(NCVDU, 1,1)
      WRITE ( CMON, '(2I4,A13,A1)')  IDIR, LINDIR, CDIR(1:LINDIR),'#'
      CALL XPRVDU(NCVDU, 1,1)
      I = KDVAL ( IDIR, CDIR(1:13), LINDIR)
      WRITE ( CMON, '(2I4,A13,A1)')  IDIR, LINDIR, CDIR(1:LINDIR),'#'
      CALL XPRVDU(NCVDU, 1,1)
      LINDIR = 11
      IDIR = 0
      CDIR(1:6) = 'refine'
      WRITE ( CMON, '(A39)') ' ######### CALL BY NAME ###############'
      CALL XPRVDU(NCVDU, 1,1)
      WRITE ( CMON, '(2I4,A11,A1)')  IDIR, LINDIR, CDIR(1:LINDIR),'#'
      CALL XPRVDU(NCVDU, 1,1)
      I = KDVAL ( IDIR, CDIR(1:6), LINDIR)
      WRITE ( CMON, '(2I4,A11,A1)')  IDIR, LINDIR, CDIR(1:LINDIR),'#'
      CALL XPRVDU(NCVDU, 1,1)
      WRITE ( CMON, '(A10)') ' KPLISTING'
      CALL XPRVDU(NCVDU, 1,1)
      I =  KPLIS(A)
      WRITE ( CMON, '(A39)') ' ######## PARAMETERS ##################'
      CALL XPRVDU(NCVDU, 1,1)
      LINPAR = 10
      IPAR = 13
      CPAR(1:10) = '!!!!!!!!!!!!!'
      IVAL = NOWT
      WRITE ( CMON, '(A39)') ' ######### CALL BY VALUE ##############'
      CALL XPRVDU(NCVDU, 1,1)
      WRITE ( CMON, '(2I4,A10,A1)')  IPAR, LINPAR, CPAR(1:LINPAR),'#'
      CALL XPRVDU(NCVDU, 1,1)
      I = KPVAL ( IPAR, CPAR, LINPAR, IVAL, JTYPE, IDEF, DEF,
     1 CDEF, CVALUE )
      WRITE ( CMON, '(A19,2I4,A2,A10)') 'IPAR, LINPAR, CPAR ',IPAR,
     2 LINPAR,' |', CPAR
      CALL XPRVDU(NCVDU, 1,1)
      WRITE ( CMON, '(A23,4I4)') 'IVAL, JTYPE, IDEF, DEF ',
     2 IVAL,JTYPE,IDEF,DEF
      CALL XPRVDU(NCVDU, 1,1)
      WRITE ( CMON, '(A6,A13)') ' CDEF ', CDEF
      CALL XPRVDU(NCVDU, 1,1)
      WRITE ( CMON, '(A8,A13)') ' CVALUE ',CVALUE
      CALL XPRVDU(NCVDU, 1,0)
      CALL XPAUSE (6000)
12345 CONTINUE
      RETURN
      END
C
C
