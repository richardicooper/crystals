C $Log: not supported by cvs2svn $
C
CDJWOCT2000 MANY COMMON BLOCKS HAVE BEEN REPLACED BY
C           MACRO DEFINITIONS FOR COMPATIBILITY WITH
C           THE REST OF CRYSTALS
CODE FOR ADJ1
      LOGICAL FUNCTION ADJ1(MCONNI, MCONNJ)
C
C MCONNJ = A CONNECTION TO THE STRUCTURE NODE
C MCONNI = A CONNECTION TO THE QUERY NODE
C RETURNS TRUE IF THE CORRESPONDING DISTANCES ARE OK
C MCONNI+1 HOLDS DISTANCE IN THE STRUCTURE
C MCONNJ+1 HOLDS DESIRED DISTANCE IN THE QUERY
C MCONNJ+2 HOLDS TOLERANCE FOR DESIRED DISTANCE
C
CCRYSTALS CODE FOR FIND.INC
C INCLUDE FILE FOR THE FIND ROUTINES
C
C THE NAMES OF THE FILES CONTAINING THE STRUCTURES (QUERY AND SUPERSTR,
C IF ANY) ARE HELD IN ISTORE.  THE ONLY LIMIT ON THE NUMBER OF QUERIES
C BEING SEARCHED FOR SIMULTANEOUSLY IS THE DIMENSION OF ISTORE, IE
C CRYSTALS WILL EVENTUALLY RUN OUT OF MEMORY.
C
C NB, NOTE THAT IT IS ASSUMED THAT CATFLA, CSERFL, CSPEFL ARE ALL OF THE
C SAME LENGTH
C     CHARACTER*3 CATFLA, CSERFL, CSPEFL
C
C     CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
C     CHARACTER*10 CDIGIT
C
C THIS IS THE FLAG TO STICK IN A COMMAND PACKET TO INDICATE THE NUMBER
C OF THIS OCCURRENCE OF THIS STRUCTURE (SET IN FINDBD TO *NOC)
C     CHARACTER*5 CNOCC
C
C LIKEWISE THE MAXIMUM SERIAL NUMBER FROM THE STRUCTURE
C     CHARACTER*5 CMAXS
C     LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
C    1        LNOISO, LPERT, LMULTI
C
C USEFUL CHARACTER VARIABLES
C CATFLA = THE FLAG CORRESPONDING TO AN ATOM IN THE COMMANDS IN A FILE
C CURRENTLY SET IN THE CHARACTER STATEMENT ABOVE TO A LENGTH OF 3.
C CHANGE THIS IF YOU NEED TO CHANGE ITS LENGTH! SET IN FINDBD TO '*AT'
C LIKEWISE CSERFL AND CSPEFL FOR SERIAL AND SPECIES FLAG SET TO *SE
C AND *SP RESPECTIVELY
C     COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
C     COMMON /ICHFIN/ ISPECQ
C
C     COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
C
C     COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
C
C TYPE OF SEARCH:
C LOVERL = .TRUE. DIFFERENT SUBSTRUCTURES MAY OVERLAP
C LISOMO = .TRUE. IF AN ISOMORPHISM HAS BEEN FOUND
C LCV    = .TRUE. IF A CV FOUND
C LNEWS  = .TRUE. IF ANY NEW SETS WERE GENERATED
C LEXTEN = .TRUE. IF LIST 5(10) IS TO BE EXTENDED TO COMPLETE
C                 ITS CONNECTIVITY
C LMCS   = .TRUE. IF MCS SEARCH
C LSORT  = .TRUE. IF QUERIES ARE TO BE SORTED IN DECREASING SIZE ORDER
C LEXACT = .TRUE. IF ANY QUERY FILE HAD AN EXACT SPECIFICATION
C LSOVER = .TRUE. IF THE CURRENT QUERY IS ALLOWED TO SELF-OVERLAP
C LNOISO = .TRUE. IF XCORST TURNS UP A NON-ISOMORPHISM
C LMULTI = .TRUE. IF MULTIPLE FOR THIS QUERY
C LPERT  = .TRUE. IF PERTURBING STRUCTURE
C
C     COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
C    C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
C
C NEED ALL THOSE VARIABLES USED BY XRSL, XCSAE, XDIST2
C XLDR05.  - IE AT LEAST THOSE REFERENCED BY FIND.
C
C THE CURRENT FORMAT OF AN ENTRY IN THE GENERAL LIST IS:
C
C 0> NO OF NODES IN THE GRAPH CORRESPONDING TO THIS STRUCTURE
C 1> NO OF NODES OF THIS STRUCTURE AS YET UNASSIGNED (USED IF LOVERL
C   FALSE)
C 2> ADDRESS OF THE FIRST ENTRY IN THE FIXED PART OF THE NODE LIST
C   DESCRIBING THE GRAPH
C 3> ADDRESS OF THE FIRST ENTRY OF THE AREA AT THE END OF THE GENERAL
C   STRUCTURE LIST HOLDING DETAILS OF THE ISOMORPHISMS (DESCRIBED IN
C   XCRLIF).  SET TO ZERO INITIALLY.  SET TO -1 IF NO ISOMORPHISM WAS
C   FOUND.  USED ALSO AS A TEST FOR WHETHER THIS QUERY STRUCTURE HAS
C   BEEN ATTEMPTED BEFORE.
C 4> NO OF ISOMORPHISMS FOUND WITHIN THE SUPERSTRUCTURE FOR THIS SUBSTR
C   SET TO ZERO INITIALLY
C 5> WHERE TO SEND THE OUTPUT
C   1 = TO A FILE
C   2 = TO 'PUNCH'
C   3 = TO THE SCREEN
C 6> =1 IF MULTIPLE SEARCH FOR THIS QUERY. =2 IF SINGLE, =0 IF THIS STRU
C   IS THE STRUCTURE (IE THE SEARCHEE)
C 7> DEFAULT OVERWRITE/APPEND FLAG; WHAT TO DO IF THE OUTPUT FILE (DEFAU
C   NAME OR NAME DEFINED IN OUTFILE) EXISTS
C   1 = OVERWRITE
C   2 = APPEND
C 8> ADDRESS OF BEGINNING OF OUTFILE INFO (=0 IF NONE)
C 9> NUMBER OF OUTFILES FOR THIS STRUCTURE
C 10> TYPE OF ACTUAL STRUCTURE INFO (EG LIST 5 )
C   1 = LIST 5 ACTUAL
C   2 = LIST 10 ACTUAL
C   3 = ATOM LIST FROM CSD-TYPE DATA FILE
C   4 = SAME FORMAT AS LIST 5, BUT START AND NO OF ENTRIES MUST BE
C       SPECIFIED (MD5 STAYS THE SAME)
C   5 = SAME FORMAT AS LIST 10, BUT START AND NO OF ENTRIES MUST BE
C       SPECIFIED
C DETAILS OF ACTUAL STRUCTURE INFO FOLLOW IN THE NEXT THREE SLOTS:
C TYPE: 1     2     3     4     5
C 11> POINTER TO BEGINNING OF INPUT FILENAME INFO
C 12> NUMBER OF ATOMS
C 13> BEGINNING OF ATOM INFO
C 14> SLOTS PER ATOM
C 15> NO OF INTEGERS REQUIRED TO STORE A SET OF NODES OF THE GRAPH
C   CORRESPONDING TO THIS STRUCTURE, INCLUDING ITS CARDINALITY
C 16> ADDRESS OF BEGINNING OF 'KNOWN' INFO (=0 IF NONE)
C 17> NUMBER OF 'KNOWN' PAIRINGS FOR THIS STRUCTURE
C 18> ARE INSTANCES OF THIS STRUCTURE ALLOWED TO OVERLAP WITH EACH OTHER
C     =1 IF YES, =2 IF NO, =0 IF THIS IS THE STRUCTURE
C 19>  MSTRUC+19 - THE BINARY VECTOR DESCRIBING WHICH OF THE SET OF COMM
C PACKETS (AT THE END OF A QUERY FILE) SHOULD BE USED.  IF THE 3RD BIT
C IS SET, USE THE 3RD STRUCTURE.  ETC.
C INITIALLY HAVE A MAXIMUM OF L1INT (=31) POSSIBLE COMMAND PACKETS.
C IE HAVE ONLY ONE SLOT HOLDING THIS INFO
C SUBSEQUENTLY, MAY WANT TO INCREASE THIS NUMBER, SO HAVE THE NUMBER
C OF INTEGERS AVAILABLE SET AS THE VARIABLE NCPCKT (=1).
C HENCE TO INCREASE IN MULTIPLES OF L1INT, SET NCPCKT TO THE NEW
C NUMBER OF INTEGERS REQUIRED, & ALTER MDSTRU BY THE SAME AMOUNT.
C ALSO, CHANGE THE NUMBER OF POSSIBLE REPEATS OF THE 'OPTION' PARAMETER
C OF THE APPLY DIRECTIVE IN COMMANDS.SRC
C BOTH OF THESE ALTERATIONS ARE MADE IN FINDBD.F & ASSUME THAT THE
C GENERAL LIST HAS THESE INTEGERS AT THE END.  IF MDSTRU HAS BEEN
C ALTERED SO THAT IT IS > 20 ALREADY THEN YOU WON'T BE ABLE TO DO THIS
C WITHOUT SHIFTING THE REFERENCES AROUND.
C   ONLY USE 31 OF THE POSSIBLE 32 BITS AVAILABLE BECAUSE ONE IS THE
C SIGN BIT, HENCE NOT ACCESSIBLE BY THE SAME MATHEMATICAL (IE POWERS
C OF 2) OPERATIONS.
C
C GLOBALS:
C LSTRUC = START OF STRUCTURES LIST
C NSTRUC = NUMBER OF STRUCTURES BEING CONSIDERED
C MDSTRU = LENGTH OF AN ENTRY
C
C     COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
C
C THE LIST CONTAINING THE GRAPH FOR EACH STRUCTURE CONTAINS A FIXED
C PART WITH FOUR ENTRIES PER NODE, AND THEN AN AREA CONTAINING THE
C CONNECTIVITY INFO - POINTED TO BY TWO OF THE ELEMENTS OF THE FIXED
C PART.
C LNODES IS STORED AT ISTORE (MSTRUC+2)
C NNODES IS STORED AT ISTORE (MSTRUC)
C MNODES LOOPS FROM LNODES TO LNODES + NNODES - MDNODE
C (WHERE MDNODE = 4)
C MNODES   --> ADDRESS OF FIRST CONNECTION TO THIS NODE
C MNODES+1 --> NUMBER OF CONNECTIONS TO THIS NODE
C MNODES+2 --> ADDRESS OF BEGINNING OF INFO ABOUT THIS NODE
C MNODES+3 --> ADDRESS OF END OF INFO ABOUT THIS NODE
C INTYPE IS THE TYPE OF GRAPH
C  1 ==> ATOMS AS NODES
C  2 ==> BONDS AS NODES
C     COMMON /GRAPH / MDNODE, INTYPE
C
C NTOPIS = THE LAST POSITION IN THE AREA HOLDING ISOMORPHISM INFO
C     COMMON /ISOMO / NTOPIS
C
C NEEDED FOR DISTANCES & ANGLES CALCULATION
C     COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
C
C SOME COMMONLY NEEDED INFORMATION ABOUT THE CURRENT QUERY STRUCTURE
C NINTQ  = NO OF INTEGERS REQUIRED TO STORE ONE SET OF THE QUERY STR
C         (INCLUDING CARDINALITY)
C MOFFSQ = OFFSET FROM THE BEGINNING OF AN ENTRY IN THE SET LIST OF
C          SETS OF THE QUERY STRUCTURE
C NNODEQ = NO OF NODES OF THE GRAPH CORRESPONDING TO THE QUERY STR
C NSTRUQ = SERIAL NO OF THE QUERY STRUCTURE
C NIDENT = NO OF NODES OF THE QUERY STRUCTURE IDENTIFIED THUS FAR
C
C     COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
C
C SOME COMMONLY NEEDED INFORMATION ABOUT THE SUPERSTRUCTURE
C NINTSU = NO OF INTEGERS REQUIRED TO STORE ONE SET OF THE SUPERSTR
C          (INCLUDING CARDINALITY)
C NNODSU = NO. OF NODES INITIALLY IN THE STRUCTURE GRAPH
C NREMSU = NO. OF UNASSIGNED NODES IN THE STRUCTURE GRAPH
C     COMMON /SUPER / NINTSU, NNODSU, NREMSU
C     COMMON /RSUPER/ RMAXSE
C
C 'PARAMETER' DIRECTIVE REAL NUMBERS
C     COMMON /RPARAM/ RTHRES, RMIN, RMAX
C
C DEFAULTS FOR DISTANCE CALC
C     COMMON /RMDEF / RMADEF, RMIDEF
C
C DETAILS OF THE SETS HELD
C LSETS  = START OF THE SETS
C NSETS  = NO. OF SETS
C MDSETS = SIZE OF A SET ENTRY
C L1INT  = NO. OF SET ELEMENTS HELD BY ONE INTEGER
C LPSL   = LOWEST ADDRESS OF THE `CURRENTLY ACTIVE' P.S.
C LNEW   = LOWEST ADDRESS OF THE `NEW' SETS TO BE USED IN AN
C          INTERSECTION.
C FORMAT OF A SET ENTRY:
C MSETS  -->  0 IF THESE SETS CAN BE USED IN ANY STRUCTURE
C            -1 IF AS 0 BUT CONNECTIVITY HAS BEEN APPLIED
C             N IF STRUCTURE N WAS ASSUMED IN GENERATING THIS SET
C            -N AS N BUT CONNECTIVITY APPLIED
C        --> CARDINALITY OF SET WITH THIS PROPERTY CORRESPONDING TO 1ST
C        --> FIRST INTEGER HOLDING ELEMENTS OF THIS SET FOR THIS STR
C        --> NEXT INTEGER
C        --> ETC
C        --> LAST INTEGER HOLDING ELEMENTS OF FIRST SET
C        --> CARDINALITY OF SET WITH THIS PROPERTY CORRESPONDING TO 2ND
C        --> FIRST INTEGER HOLDING ELEMENTS OF THIS SET FOR THIS STR
C        --> ETC
C SEE XINSET
C     COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
C
C A HANDY NUMBER CORRESPONDING TO ALL THE BITS OF A 32 BIT INTEGER SET T
C     COMMON /CONS  / IUNIVE
C
C MORE HANDY NUMBERS
C     COMMON /NPOWE2/ N2POWS(0:30)
C
C MAXIMUM NUMBER OF ISOMORPHISMS FOR ANY ONE QUERY
C MAXIMUM NUMBER OF EXTENSIONS TO LIST 5 IF CTRL EXTEND=YES
C     COMMON /NMAXIS/ MAXISO, MAXEXT
C
C ERRORS
C NERRFI = 0  NO ERROR
C          1  ERROR IN XBRGRL
C          2  ERROR IN XL5TOG
C     COMMON / ERRS / NERRFI
C     COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
C
C------------------------------------------------------
C
      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
\XCONST
\STORE
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
      RS  = STORE(MCONNJ+1)
      RQ  = STORE(MCONNI+1)
      RTQ = STORE(MCONNI+2)
      IF ((RQ .GT. ZERO) .AND. (RTQ .GT. ZERO)) THEN
          ADJ1 = (  (RS .GT. (RQ - RTQ))
     1        .AND. (RS .LT. (RQ + RTQ)))
      ELSE
          ADJ1 = .TRUE.
      END IF
      RETURN
      END

CODE FOR ADJ2
      LOGICAL FUNCTION ADJ2(MCONNI, MCONNJ)
      ADJ2 = .TRUE.
      RETURN
      END
CODE FOR ALTOG
      SUBROUTINE ALTOG(LATFOU, LBONDS, LNODES, NNODES, IPERAT)
C
C TAKES LINKED LISTS OF ATOMS AND BONDS AND CONSTRUCTS
C ATOMS-AS-NODES GRAPH
C
C LNODES --> FIXED PART
C MDNODE =
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      IPERAT = 6
      IPERBO = 3
C
C DO THE FIXED LENGTH BITS
      MATFOU = LATFOU
      LNODES = KSTALL(NNODES*MDNODE)
      DO 1000, MNODES = LNODES, LNODES+(NNODES-1)*MDNODE, MDNODE
          MINFO = KSTALL(IPERAT)
          ISTORE(MNODES)   = 0
          ISTORE(MNODES+1) = 0
          ISTORE(MNODES+2) = MINFO
          ISTORE(MNODES+3) = MINFO + IPERAT - 1
C
C LIST 5 ADDRESS & SYMMETRY STUFF
          DO 900, MMINF = 1, 6
              ISTORE(MINFO+MMINF-1) = ISTORE(MATFOU+MMINF)
900       CONTINUE
C
C NOW REPLACE THE LIST 5 ADDRESS WITH THE GRAPH ADDRESS FOR USE BELOW
C ---HERE
          ISTORE(MATFOU+1) = 1+ (MNODES-LNODES)/MDNODE
          IF (MATFOU .EQ. 0) THEN
C NERRFI = NERRFI_ERROR_CONSTRUCTING_ATOM_GRAPH
              NERRFI = 157
              GO TO 9900
          END IF
          MATFOU = ISTORE(MATFOU)
1000  CONTINUE
C
C FILL IN THE BONDS
      MATFOU = LATFOU
      DO 5000, MNODES = LNODES, LNODES+(NNODES-1)*MDNODE, MDNODE
C
C LOOK FOR ALL BONDS INVOLVING THIS NODE
C EACH BOND OCCURS UP TO TWICE IN THE BOND LINKED LIST.
C EACH BOND TO THIS ATOM WILL DEFINITELY OCCUR WITH IT
C AS THE PIVOT ATOM
          MBONDS = ISTORE(LBONDS)
2000      CONTINUE
          IF (MBONDS .NE. 0) THEN
              IF (ISTORE(MBONDS+1) .EQ. MATFOU) THEN
                  MTMPBO = KSTALL(IPERBO)
                  IF (ISTORE(MNODES) .EQ. 0) THEN
                      ISTORE(MNODES) = MTMPBO
                  END IF
C NODE
                  ISTORE(MTMPBO  ) = ISTORE(ISTORE(MBONDS+2)+1)
C BOND LENGTH
                   STORE(MTMPBO+1) =  STORE(MBONDS+3)
                   STORE(MTMPBO+2) =  0.0
                  ISTORE(MNODES+1) = ISTORE(MNODES+1) + 1
              END IF
              MBONDS = ISTORE(MBONDS)
              GO TO 2000
          END IF
C
C ERROR CHECKING WOULD BE DONE IN PREVIOUS LOOP
          MATFOU = ISTORE(MATFOU)
5000  CONTINUE
9900  CONTINUE
      RETURN
      END
CODE FOR CHAUTO
      LOGICAL FUNCTION CHAUTO(ITSQU, LSQTMP, NSQU)
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      IF (ITSQU .NE. 0) THEN
          DO 2000, MSQ = ITSQU, ITSQU + (NSQU-1)*MDSETS, MDSETS
              CHAUTO = .TRUE.
              DO 1000, MMSQ = 1, NINTSU
                  IF (ISTORE(MSQ+MMSQ)
     1           .NE. ISTORE(LSQTMP+MMSQ)) THEN
                      CHAUTO = .FALSE.
                      GO TO 1500
                  END IF
1000      CONTINUE
C GOT THROUGH ONE ROUND WITHOUT CHANGING CHAUTO
          RETURN
1500      CONTINUE
2000  CONTINUE
      ELSE
          CHAUTO = .FALSE.
      END IF
      ITSQU = LSQTMP
      NSQU  = NSQU + 1
      RETURN
      END
CODE FOR DELSQ
      SUBROUTINE DELSQ(MFROM, MSQ)
C
C DELETE ALL THE STRUCTURE NODES IN THE SINGLE SET AT MSQ
C FROM THE SET AT MFROM

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
C DELETE THE STRUCTURE NODES IN MSQ FROM MFROM
      DO 1000, MM = 2, NINTSU
          ITMP  = KKNOT(ISTORE(MSQ+MM))
          ITMP2 = ISTORE(MFROM+MM)
          ISTORE(MFROM+MM) = KAND(ITMP, ITMP2)
1000  CONTINUE
C
C RECALCULATE CARDINALITY FOR MFROM
      NCARD = 0
      DO 2000, MNODE = 1, NNODSU
C
          MINTSU = MFROM+(MNODE-1)/L1INT + 2
          IBIT   = MOD((MNODE-1), L1INT)
          NPOWE2 = N2POWS(IBIT)
          IF (KAND(ISTORE(MINTSU),NPOWE2) .EQ. NPOWE2)NCARD = NCARD+1
2000  CONTINUE
      ISTORE(MFROM+1) = NCARD
      RETURN
      END
CODE FOR FINDBD
      BLOCK DATA FINDBD
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
      DATA NKEYBO, NREAD2, NSCREE, NWRIT2 / 5, 12, 6, 13/
      DATA NCHPER / 94/
      DATA NERRFI / 0 /
      DATA LSTRUC, MDSTRU, NCPCKT / 0, 20, 1/
      DATA MDNODE / 4/
      DATA MAXISO / 0/
      DATA RMADEF,RMIDEF / 2.0, 0.5 /
      DATA LSETS, NSETS, MDSETS, L1INT / 0, 0, 0, 31/
      DATA IUNIVE / 2147483647/
      DATA LNEW / 0/
      DATA NIDENT / 0/
      DATA LPSL / 0 /
      DATA D12 / 2.0 /, D12S / 4.0 /
      DATA TOLER /0.6/, ITRANS / 0 /
      DATA CATFLA, CSERFL, CSPEFL /'*AT', '*SE', '*SP'/
      DATA CNOCC, CMAXS/'*NOCC', '*MAXS'/
      DATA ISPECQ /'Q   '/
      DATA CPLUS, CMINUS, CTIMES, CDIV /'+','-','*','/'/
      DATA CDIGIT /'0123456789'/
      DATA N2POWS /1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024,
     1             2048, 4096, 8192, 16384, 32768, 65536, 131072,
     2             262144, 524288, 1048576, 2097152, 4194304,
     3             8388608, 16777216, 33554432, 67108864,
     4             134217728, 268435456, 536870912, 1073741824 /
C
      END
CODE FOR GPDENS
      REAL FUNCTION GPDENS(RDIST, RMEAN, RESD)
C
C RETURNS THE VALUE AT RDIST OF THE GAUSSIAN PROBABILITY DEFINED BY
C MEAN RMEAN AND ESD RESD
      DOUBLE PRECISION DRDIST, DRMEAN, DRESD, DANS, DTMP
C      DOUBLE PRECISION DRT2P, DMULT
      COMMON/XCONST/NOWT,PI,TWOPI,TWOPIS,RTD,DTR,
     2 UISO,ZERO,ZEROSQ,VALUE,VALUSQ
C

      DRDIST = DBLE(RDIST)
      DRMEAN = DBLE(RMEAN)
      DRESD  = DBLE(RESD)
C
C MOVE TO BLOCK DATA FINDBD
C WANT TO KEEP ON 0-1 SCALE
C      DRT2P  = DBLE(TWOPI)
C      DRT2P  = DSQRT(DRT2P)
C
C PRE EXPONENTIAL
C      DMULT  = 1D0/DRT2P
C
C THE BIT INSIDE
      DTMP   = (DRDIST-DRMEAN)/(DRESD)
      DTMP   = DTMP * DTMP / 2D0
C      DANS   = (DMULT/DRESD) * DEXP(-DTMP)
      DANS   = DEXP(-DTMP)
C
      GPDENS = REAL(DANS)
      RETURN
      END
CODE FOR KGTSER
      FUNCTION KGTSER (IATSEQ, MSTRUC)
C
C RETURNS THE SERIAL NUMBER OF THE ATOM WITH SEQUENCE NUMBER
C IATSEQ IN THE STRUCTURE AT MSTRUC

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
\XLST05
C
      IINFO = ISTORE (MSTRUC+10)
      LATS  = ISTORE (MSTRUC+13)
      NATS  = ISTORE (MSTRUC+12)
      MDATS = ISTORE (MSTRUC+14)
      IF (INTYPE .EQ. 1) THEN
          IF  (IINFO .EQ. 1) THEN
                IF ((IATSEQ.LE.NATS) .AND. (IATSEQ.GT.0)) THEN
                      ITMP   = LATS+((IATSEQ-1)*MDATS)
                      ITMP   = ISTORE(ITMP)
                      RTMP   =  STORE (L5+(ITMP-1)*MD5+1)
                      KGTSER = NINT (RTMP)
                ELSE
C NERRFI = NERRFI_BAD_SEQUENCE
                      NERRFI = 41
                END IF
          ELSE IF (IINFO .EQ. 3) THEN
C CURRENTLY FOR CSD TYPE FILES, SPECIES IS IN THE SAME PLACE
                IF ((IATSEQ.LE.NATS) .AND. (IATSEQ.GT.0)) THEN
                      ITMP   = LATS+((IATSEQ-1)*MDATS)
                      ITMP   = ISTORE (ITMP+2)
                      KGTSP  = ISTORE (ITMP)
                ELSE
C NERRFI = NERRFI_BAD_SEQUENCE
                      NERRFI = 41
                END IF
          ELSE
          END IF
      ELSE IF (INTYPE .EQ. 2) THEN
          ITMP = LATS + (IATSEQ-1)*MDATS
          RTMP =  STORE(ITMP+1)
          KGTSER = NINT(RTMP)
      END IF
      RETURN
      END
CODE FOR KGTSP
      FUNCTION KGTSP (IATSEQ, MSTRUC)
C
C RETURNS AS AN INTEGER THE SPECIES OF THE ATOM WITH SEQUENCE
C NUMBER IATSEQ IN THE STRUCTURE AT MSTRUC

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
\XLST05
C
      IINFO = ISTORE (MSTRUC+10)
      LATS  = ISTORE (MSTRUC+13)
      NATS  = ISTORE (MSTRUC+12)
      MDATS = ISTORE (MSTRUC+14)
      IF (INTYPE .EQ. 1) THEN
          IF  (IINFO .EQ. 1) THEN
                IF ((IATSEQ.LE.NATS) .AND. (IATSEQ.GT.0)) THEN
                      ITMP   = LATS+((IATSEQ-1)*MDATS)
                      ITMP   = ISTORE(ITMP)
                      KGTSP  = ISTORE (L5+(ITMP-1)*MD5)
                ELSE
C NERRFI = NERRFI_BAD_SEQUENCE
                      NERRFI = 41
                END IF
          ELSE IF (IINFO .EQ. 3) THEN
C CURRENTLY FOR CSD TYPE FILES, SPECIES IS IN THE SAME PLACE
                IF ((IATSEQ.LE.NATS) .AND. (IATSEQ.GT.0)) THEN
                      ITMP   = LATS+((IATSEQ-1)*MDATS)
                      ITMP   = ISTORE (ITMP+2)
                      KGTSP  = ISTORE (ITMP)
                ELSE
C NERRFI = NERRFI_BAD_SEQUENCE
                      NERRFI = 41
                END IF
          ELSE
          END IF
      ELSE IF (INTYPE .EQ. 2) THEN
          ITMP = LATS + (IATSEQ-1)*MDATS
          KGTSP = ISTORE(ITMP)
      END IF
      RETURN
      END
CODE FOR KMATST
      FUNCTION KMATST (LFLSAV, ISEQ)
C
C SEARCH DOWN THE TEMPORARY STACK (LFLSAV ==> LFL+1)
C RETURN VALUE IS THE ADDRESS OF THE ENTRY CORRESPONDING TO QUERY
C ATOM WITH SERIAL NUMBER ISEQ
C RETURN VALUE IS -1 IF THE ATOM ISN'T THERE

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      KMATST = -1
      MAT    = LFLSAV + 2
1000  CONTINUE
      MAT    = MAT - 2
      IF (MAT .GT. LFL) THEN
            IF  (ISTORE (MAT) .EQ. ISEQ) THEN
                  KMATST = MAT
            ELSE
                  GO TO 1000
            END IF
      END IF
      RETURN
      END
CODE FOR KNCPTU
      FUNCTION KNCPTU (MSTRUC, ICPABR)
C
C RETURNS THE NEXT COMMAND PACKET TO USE AFTER THAT WITH SERIAL NUMBER
C ICPABR ACCORDING TO THE COMMAND PACKET VECTOR OF STRUCTURE MSTRUC
C (WHICH STARTS AT MSTRUC+18)

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      IF ((ICPABR .LT. 0) .OR. (ICPABR .GT. (NCPCKT*L1INT))) THEN
C NERRFI = NERRFI_BAD_ICPABR
            NERRFI = 52
            GO TO 9900
      END IF
      KNCPTU = 0
C
      DO 1000, MTMP = ICPABR+1, NCPCKT*L1INT
             ITMP = MOD ((MTMP-1), L1INT)
C             ITMP2 = MSTRUC + ((MTMP-1)/L1INT) + 18
             ITMP2 = MSTRUC + ((MTMP-1)/L1INT) + 19
             ITMP  = N2POWS(ITMP)
             IF(KAND(ITMP,ISTORE(ITMP2)).EQ.ITMP)THEN
                   KNCPTU = MTMP
                   GO TO 2000
             END IF
1000  CONTINUE
2000  CONTINUE
9900  CONTINUE
      RETURN
      END
CODE FOR KNCR
      FUNCTION KNCR (N, IR)
C
C NUMBER OF COMBINATIONS OF IR OBJECTS TAKEN FROM N DIFFERENT
C OBJECTS = N!/(N-IR)!IR!
C SET TO MAXISO + 1 IF LOOKS LIKE THE CALCULATION WILL GO WRONG

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
      IF ((N .LT. IR) .OR. (N .LT. 0) .OR. (IR .LT. 0)) THEN
C NERRFI = NERRFI_INCORRECT_ARGUMENT_TO_KNCR
            NERRFI = 50
            GO TO 9900
      END IF
C
      IF ((N-IR) .LE. 12) THEN
          NFACT  = 1
          DO 1000, M = N-IR+1, N
                NFACT = NFACT * M
1000      CONTINUE
          IF ( NFACT .GT. 0) THEN
            IF (IR .LE. 12) THEN
              IRFACT = 1
              DO 3000, M = 1, IR
                    IRFACT = IRFACT * M
3000          CONTINUE
              KNCR  = NFACT/IRFACT
            ELSE
              KNCR = MAXISO + 1
            END IF
          ELSE
C Oops, NFACT has overflowed.
            KNCR = MAXISO + 1
          END IF
      ELSE
              KNCR = MAXISO + 1
      END IF
9900  CONTINUE
      RETURN
      END
CODE FOR KKNOT
      FUNCTION KKNOT ( N )
C
C DJK 15/1/92
C----- CHANGED TO KKNOT TO AVOID CONFLICT WITH DIGITAL VISUAL FORTRAN,
C      DC 98
C
C BITWISE NOT OF THE INTEGER N
      KKNOT = NOT ( N )
      RETURN
      END
CODE FOR KSPEAT
      FUNCTION KSPEAT (MSTRUC, ISEQ)
C
C GIVES THE ATOMIC SPECIES OF THE ISEQ'TH ATOM OF THE STRUCTURE AT
C MSTRUC AS AN INTEGER.  PUT SPECIFIC ATOM INFO TREATMENT IN HERE.

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      IATYPE = ISTORE (MSTRUC+10)
      IF (ISEQ .GT. ISTORE(MSTRUC+12)) THEN
C            NERRFI = NERRFI_WRONG_ATOM_SEQUENCE
            NERRFI = 29
            GO TO 9900
      END IF
      IADDAT = ISTORE(MSTRUC+13) + (ISEQ-1)*ISTORE (MSTRUC+14)
      IF ((IATYPE.EQ.1) .OR. (IATYPE.EQ.2) .OR. (IATYPE.EQ.3)) THEN
            KSPEAT = ISTORE (IADDAT)
      ELSE
C            NERRFI = NERRFI_BAD_ATTYPE
            NERRFI = 30
      END IF
9900  CONTINUE
      RETURN
      END
CODE FOR KXOR
      FUNCTION KXOR ( I, J )
C
C DJK 15/1/92
C
C BITWISE XOR OF THE INTEGERS I AND J
      KXOR = XOR ( I, J )
      RETURN
      END
CODE FOR LPRESE
      LOGICAL FUNCTION LPRESE ( NNODE, MNEW, MOFFSE)
C
C LPRESE = .TRUE. IF THE NNODETH NODE (I.E. BIT) OF THE STRUCTURE SET
C          STORED AT MNEW IS SET.  OTHERWISE .FALSE.
C
C MOFFSE = OFFSET FROM THE BEGINNING OF ANY SET ENTRY OF THE SET
C          CORRESPONDING TO THE CURRENT STRUCTURE
C
C LOCALS:
C
C IADDIN = ADDRESS IN ISTORE OF THE INTEGER FROM THE SET AT MNEW HOLDING
C          THE BIT CORRESPONDING TO THE NNODETH NODE.
C NCOMPS = INTEGER FROM THE SET AT MNEW HOLDING THE BIT CORRESPONDING TO
C          THE NNODETH NODE.
C NCOMPN = AN INTEGER WITH THE _ONLY_ BIT SET BEING THAT CORRESPONDING
C          TO THE NNODETH NODE.
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
      IADDIN = MNEW + MOFFSE + ((NNODE-1)/ L1INT) + 1
      NCOMPS = ISTORE (IADDIN)
      NCOMPN = MOD ((NNODE-1), L1INT)
      NCOMPN = N2POWS(NCOMPN)
      LPRESE = (NCOMPN .EQ. KAND (NCOMPN, NCOMPS))
      RETURN
      END
CODE FOR LSACOR
      LOGICAL FUNCTION LSACOR (LFLSAV, ICOMMS, MATCOM)
C
C SEARCH DOWN THE TEMPORARY STACK (LFLSAV ==> LFL+1)
C RETURNS .TRUE. IF ICOMMS IS AT THE SLOT BELOW ANY POSITION
C OTHER THAN MATCOM

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      LSACOR = .FALSE.
      MAT    = LFLSAV + 2
1000  CONTINUE
      MAT    = MAT - 2
      IF (MAT .GT. MATCOM) THEN
            IF  (ISTORE (MAT-1) .EQ. ICOMMS) THEN
                  LSACOR = .TRUE.
                  RETURN
            ELSE
                  GO TO 1000
            END IF
      END IF
2000  CONTINUE
      MAT    = MAT - 2
      IF (MAT .GT. LFL) THEN
            IF  (ISTORE (MAT-1) .EQ. ICOMMS) THEN
                  LSACOR = .TRUE.
                  RETURN
            ELSE
                  GO TO 2000
            END IF
      END IF
      RETURN
      END
CODE FOR MAXSEN
      SUBROUTINE MAXSEN()
C
C FROM LIST 5 CALCULATE HIGHEST STRUCTURE SERIAL NUMBER

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\XLST05
      COMMON/XLST10/L10,M10,MD10,N10,L10A,M10A,MD10A,N10A
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
C
      RMAXSE = 0.0
      IF (ISTORE(LSTRUC+10) .EQ. 1) THEN
C LIST 5
          LATS = L5
          NATS = N5
          MDATS = MD5
      ELSE IF (ISTORE(LSTRUC+10) .EQ. 2) THEN
C LIST 10
          LATS = L10
          NATS = N10
          MDATS = MD10
      ELSE
C NERRFI = NERRFI_NO_ATOM_INFO
                  NERRFI = 345
                  GO TO 9900
      END IF
C
      DO 1000, MATS = LATS, LATS+(NATS-1)*MDATS, MDATS
          SERIAL = STORE(MATS+1)
          IF (SERIAL .GT. RMAXSE) RMAXSE = SERIAL
1000  CONTINUE
9900  CONTINUE
      RETURN
      END
CODE FOR NEWASS
      SUBROUTINE NEWASS(MSTRUC)
C
C DJK
C AS ULLMANN
C INITIAL GUESS AT M (M0) IS THE PS
C MATRIX AT DEPTH D GIVEN BY MD
C DEPTH IN SEARCH TREE
      INTEGER ID, LFLSAV, IHSTAR, IMDSTA, ITMP, IFSTAR, LPSENT, LPSLM,
     1       MADDD, LPSLMD, K, IJ, LFOUND, ITSQU, NSQU
      LOGICAL CHAUTO, LPRESE, LSUCC

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
\XUNITS
C
C NUMBER OF STRUCTURE
      N = (MSTRUC-LSTRUC)/MDSTRU
C
C CREATE VECTOR H TO RECORD WHICH COLUMN HAS BEEN SELECTED AT WHICH
C DEPTH.  H(D) = ISTORE(IHSTAR+D-1) = K IF COLUMN K SELECTED AT DEPTH D.
      LFLSAV = LFL
      LFL = LFL - NNODEQ
      IHSTAR = LFL + 1
      DO 900, ITMP = 1, NNODEQ
          ISTORE (IHSTAR+ITMP-1) = 0
900   CONTINUE
C
C CREATE VECTOR TO RECORD ADDRESS OF MATRIX MD STORED FOR ASSIGNMENT AT
C DEPTH D. ISTORE(IMDSTA+D-1) = MDADD, ADDRESS OF MD AT DEPTH D.
      LFLSAV = LFL
      LFL = LFL - NNODEQ
      IMDSTA = LFL + 1
C
      DO 1000, ITMP = 1, NNODEQ
          LFL = LFL - (NNODEQ*MDSETS)
          ISTORE (IMDSTA+ITMP-1) = LFL + 1
1000  CONTINUE
C
C NSQU SQUASHED ISOMORPHISMS (UNIONS OF THE STRUCTURE ATOM SETS)
C FOR CHECKING AUTOMORPHISMS ARE AT ITSQU
      ITSQU = 0
      NSQU  = 0
C
C CREATE BINARY VECTOR F TO RECORD WHICH COLUMNS ARE USED AT THE
C CURRENT STATE OF THE CALCULATION.  IT STARTS AT IFSTAR.
      LFL = LFL - NINTSU
      IFSTAR = LFL + 1
C
C SAVE PS ADDRESS ON ENTRY
      LPSENT = LPSL
C --------------------------------------------------------------------
C (0) SPECIAL TREATMENT FOR 1-NODE GRAPHS (NOT TREATED BY ULLMANN)
      IF (NNODEQ .EQ. 1) THEN
          LPSLM  = KSTALL (NNODEQ*MDSETS)
          NSETS  = NSETS + NNODEQ
          CALL PSCOPY(LPSENT, LPSLM, 1)
C
C EACH 1-BIT STRUCTURE ELEMENT OF THE PS (WHICH IS A 1-ROW TABLE) IS
C A VALID MATCH
          DO 1500, IJ = 1, NNODSU
              IF (LPRESE(IJ, LPSLM, 1)) THEN
C
                  WRITE (NCAWU,'(A,I4)')
     1  'FOUND QUERY ', N
C
C CREATE A NEW PS WITH JUST THIS BIT SET
                  LNEWPS = KSTALL(MDSETS)
                  NSETS  = NSETS + 1
                  ISTORE(LNEWPS) = -NSTRUQ
                  ISTORE(LNEWPS+1) = 1
                  DO 1400, ITMP = 1, NINTSU-1
                      ISTORE(LNEWPS+ITMP+1) = 0
1400              CONTINUE
                  CALL SETFEL(IJ, 1, (LNEWPS+1))
                  IF (ISTORE(MSTRUC+3) .EQ. 0)
     1                ISTORE(MSTRUC+3) = NTOPIS
                  ISTORE(NTOPIS) = LNEWPS
                  ISTORE(MSTRUC+4) = ISTORE(MSTRUC+4)+1
                  NTOPIS = NTOPIS + 1
                  IF ((.NOT. LMULTI) .OR.
     1                (LMULTI .AND. (ISTORE(MSTRUC+4) .GE. MAXISO))
     2               ) GO TO 1600
              END IF
1500      CONTINUE
1600      CONTINUE
          GO TO 9800
      END IF
C --------------------------------------------------------------------
C (1) MAKE A COPY OF THE PS (M = M0)
      LPSLM  = KSTALL (NNODEQ*MDSETS)
      NSETS  = NSETS + NNODEQ
C
C COPY UP THE ORIGINAL PS TO THIS AREA, SETTING THE FIRST ELEMENT OF EAC
C SET TO NSTRUQ SO THAT IF THE ASSIGNMENTS WORK, THEY AREN'T USED BY
C SUBSEQUENT STRUCTURES
      CALL PSCOPY(LPSENT, LPSLM, 1)
C
C FIRST LEVEL OF DEPTH
      ID = 1
C
C      ISTORE(IHSTAR) = 1
      ISTORE(IHSTAR) = 0
C      WRITE (NCAWU, *) (ISTORE(IHSTAR+II-1), ' ', II = 1, NNODEQ)
C      WRITE (NCAWU,*)
C
C SET F(I) = 0 FOR ALL I = 1 TO NO OF NODES IN STRUCTURE
      DO 2000, ITMP = 1, NINTSU
          ISTORE(IFSTAR+ITMP-1) = 0
2000  CONTINUE
C      REFINE M - IF EXIT FAIL THEN GIVE UP HERE
      CALL XULLRF(LPSLM, LSUCC)
C      LSUCC = .TRUE.
      IF (.NOT. LSUCC) THEN
C
C FILL IN WHATEVER DETAILS & EXIT
          GO TO 9800
      END IF
C
C --------------------------------------------------------------------
C (2) IF THERE IS NO J SUCH THAT M(D,J) = 1 AND F(J) = 0 GO TO (7)
3000  CONTINUE
      MADDD   = LPSLM + (ID-1)*MDSETS
      DO 4000, IJ = 1, NNODSU
          IF (LPRESE(IJ,MADDD,1) .AND.
     1       (.NOT. LPRESE (IJ, IFSTAR, 0)))
     2        GO TO 5000
4000  CONTINUE
C
C TO STEP (7)
      GO TO 9600
5000  CONTINUE
C
C CREATE MD - A COPY OF M
      LPSLMD  = ISTORE (IMDSTA+ID-1)
      CALL PSCOPY (LPSLM, LPSLMD, 1)
C
      IF (LMCS) THEN
          IF (ID .EQ. 1) THEN
              K = ISTORE (IHSTAR)
          ELSE
              K = ISTORE (IHSTAR+ID-2)
          END IF
      ELSE
          IF (ID .EQ. 1) THEN
              K = ISTORE (IHSTAR)
          ELSE
              K = 0
          END IF
      END IF
C --------------------------------------------------------------------
C (3)
6000  CONTINUE
      K = K + 1
      MADDD   = LPSLM + (ID-1)*MDSETS
      IF ( (.NOT.LPRESE(K, MADDD, 1))
     1.OR. LPRESE (K, IFSTAR, 0)         )
     2  GO TO 6000
C
C      FOR ALL J <> K SET M(D,J) = 0
      DO 7000, ITMP=MADDD+2, MADDD + NINTSU
          ISTORE(ITMP) = 0
7000  CONTINUE
      CALL SETFEL(K, 1, (MADDD+1))
      ISTORE(MADDD+1) = 1
C      CALL OUTSET (' SECTION 3 ', 3, MADDD)
C      WRITE(6,*)' SECTION 3:',(ISTORE(IFSTAR+ITMP-1), ITMP=1, NINTSU)
C      WRITE (NCAWU,*)
C
C NOT IN ULLMANN
C      ISTORE (IHSTAR+ID-1) = K
C      CALL SETFEL(K, 1, IFSTAR)
C      CALL OUTSET (' BEFORE XULLRF ', 1, 0)
      CALL XULLRF(LPSLM, LSUCC)
C      LSUCC = .TRUE.
C      CALL OUTSET (' AFTER XULLRF ', 1, 0)
      IF (.NOT. LSUCC) THEN
C
C FILL IN WHATEVER DETAILS & EXIT
          GO TO 8000
      END IF
C
C --------------------------------------------------------------------
C (4)
      IF (ID .LT. NNODEQ) THEN
          GO TO 9400
      ELSE
C
C ISOMORPHISM FOUND
C SQUASH IT INTO ONE SET AT THE LFL-END OF MEMORY
          LFL = LFL - MDSETS
          LSQTMP = LFL + 1
          CALL XUNION(LPSLM, LPSLM+(MDSETS*(NNODEQ-1)), LSQTMP, 2)
C CHECK IT'S NOT AN AUTOMORPHISM OF ONE ALREADY FOUND
          IF (.NOT.CHAUTO(ITSQU, LSQTMP, NSQU)) THEN
C
              WRITE (NCAWU,'(A,I4)') 'FOUND QUERY ',N
C
C COPY IT TO THE TOP OF THE STACK OF SETS
              LFOUND = KSTALL(NNODEQ*MDSETS)
              CALL PSCOPY (LPSLM, LFOUND, 1)
              NSETS  = NSETS + NNODEQ
              IF (ISTORE(MSTRUC+3) .EQ. 0)
     1            ISTORE(MSTRUC+3) = NTOPIS
              ISTORE(NTOPIS) = LFOUND
              ISTORE(MSTRUC+4) = ISTORE(MSTRUC+4)+1
              NTOPIS = NTOPIS + 1
              IF (.NOT. LSOVER) THEN
C
C NEED TO DELETE THESE NODES FROM M AND FROM ALL THE M'S STORED
C FOR DIFFERENT DEPTHS TO MAKE THEM NO LONGER AVAILABLE
C      CALL OUTSET (' BEFORE DELSQ ON MPSLM ', 1, 0)
                  DO 7300, MPSLM=LPSLM,LPSLM+(NNODEQ-1)*MDSETS,MDSETS
                     CALL DELSQ(MPSLM, LSQTMP)
7300              CONTINUE
C      CALL OUTSET (' AFTER DELSQ ON MPSLM ', 1, 0)
                  DO 7500, ITMP = 1, NNODEQ
                      MTMP = ISTORE(IMDSTA+ITMP-1)
C LOOP OVER THE PS STARTING AT MTMP
                      DO 7400, MMTMP = MTMP, MTMP+(NNODEQ-1)*MDSETS,
     1                                      MDSETS
C      CALL OUTSET (' BEFORE DELSQ ON MMTMP ', 3, MMTMP)
                          CALL DELSQ(MMTMP, LSQTMP)
C      CALL OUTSET (' AFTER DELSQ ON MMTMP ', 3, MMTMP)
7400                  CONTINUE
7500              CONTINUE
              END IF
              IF ((.NOT. LMULTI) .OR.
     1            (LMULTI .AND. (ISTORE(MSTRUC+4) .GE. MAXISO))
     2           ) GO TO 9800
          ELSE
              LFL = LFL + MDSETS
          END IF
      END IF
C
C --------------------------------------------------------------------
C (5)
8000  CONTINUE
C      MADDD   = LPSLM + (ID-1)*MDSETS
      MADDD   = LPSLMD + (ID-1)*MDSETS
      DO 9000, IJ = K+1, NNODSU
C          IF ( (      LPRESE (IJ,  MADDD, 1))
C     1    .AND.(.NOT. LPRESE (IJ, IFSTAR, 0)))
C     2    GO TO 9200
           IF (LPRESE(IJ,MADDD,1)) THEN
              IF (.NOT. LPRESE(IJ,IFSTAR,0)) THEN
                   GO TO 9200
               ELSE
C                   WRITE (6,*) IJ, ' IN F'
               END IF
           ELSE
C               WRITE (6,*) IJ, ' NOT IN MD'
           END IF
9000  CONTINUE
      GO TO 9600
9200  CONTINUE
C
      LPSLMD = ISTORE(IMDSTA+ID-1)
      CALL PSCOPY(LPSLMD, LPSLM, 1)
      GO TO 6000
C
C --------------------------------------------------------------------
C (6)
9400  CONTINUE
      ISTORE (IHSTAR+ID-1) = K
C      WRITE (NCAWU, *) (ISTORE(IHSTAR+II-1), ' ', II = 1, NNODEQ)
C      WRITE (NCAWU,*)
      CALL SETFEL(K, 1, IFSTAR)
C      WRITE(6,*)' SECTION 6:',(ISTORE(IFSTAR+ITMP-1), ITMP=1, NINTSU)
C      WRITE (NCAWU,*)
      ID = ID + 1
      GO TO 3000
C
C --------------------------------------------------------------------
C (7)
9600  CONTINUE
      IF (ID .GT. 1) THEN
          CALL SETFEL(K, 0, IFSTAR)
C      WRITE(6,*)' SECTION 7:',(ISTORE(IFSTAR+ITMP-1), ITMP=1, NINTSU)
C      WRITE (NCAWU,*)
          ID = ID - 1
          LPSLMD = ISTORE (IMDSTA+ID-1)
          CALL PSCOPY(LPSLMD, LPSLM, 1)
          K = ISTORE(IHSTAR+ID-1)
C NOT IN ULLMANN
          CALL SETFEL(K, 0, IFSTAR)
C      WRITE (NCAWU, *) (ISTORE(IHSTAR+II-1), ' ', II = 1, NNODEQ)
C      WRITE (NCAWU,*)
          GO TO 8000
      END IF
C --------------------------------------------------------------------
9800  CONTINUE
      LFL = LFLSAV
      RETURN
      END
CODE FOR OUTSET
      SUBROUTINE OUTSET (CLOCAT, IMODE, LPSLW)
C
C OUTPUT ALL THE SETS ETC
C IMODE=
C 1   DISPLAY ALL THE SETS
C 2   DISPLAY JUST THE PS
C 3   DISPLAY JUST THE SET AT LPSLW
C
\XIOBUF
\XUNITS
      LOGICAL LPRESE
      LOGICAL LON
      CHARACTER *(*) CLOCAT
      CHARACTER *8  CINFO

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
C USE LON TO SWITCH ON/OFF
      LON = .FALSE.
      LON = .TRUE.
      IF (LON) THEN
      IF (IMODE .EQ. 1) THEN
        LUSE = LSETS
        NUSE = NSETS
        CINFO = 'FULL SET'
      ELSE IF (IMODE .EQ. 2) THEN
        LUSE = LPSL
        NUSE = NNODEQ
        CINFO = 'PS      '
      ELSE IF (IMODE .EQ. 3) THEN
        LUSE = LPSLW
        NUSE = 1
        CINFO = 'CURRENT '
      ELSE
        WRITE (CMON,'(A)') 'INCORRECT IMODE VALUE IN CALL TO OUTSET'
        CALL XPRVDU(NCVDU, 1,0)
        GO TO 9900
      END IF

      WRITE (CMON,'(A)') '-------------------------------------------'
      CALL XPRVDU(NCVDU, 1,0)
      WRITE (CMON, '(1X, A8, A12,A)') CINFO, ' INFO FROM: ', CLOCAT
      CALL XPRVDU(NCVDU, 1,0)
      WRITE (CMON,'(1X,A33)')' LSETS  NSETS  LNEW  LPSL  NFL '
      CALL XPRVDU(NCVDU, 1,0)
      WRITE (CMON,'(5(1X,I6))') LSETS, NSETS, LNEW, LPSL, NFL
      CALL XPRVDU(NCVDU, 1,0)

      DO 1000, MSETS= LUSE, LUSE+(NUSE-1)*MDSETS, MDSETS
C
C LOOP OVER ALL THE STRUCTURES
        MOFF = 1
        DO 500, MSTR = LSTRUC, LSTRUC + (NSTRUC-1)*MDSTRU, MDSTRU
          WRITE (CMON, '(''    ('', I2,'')'',$)')
     1               1+((MSTR - LSTRUC)/MDSTRU)
          CALL XPRVDU(NCVDU, 1,0)
          WRITE (CMON, '('' ['',I4,'']'')') ISTORE (MSETS +MOFF)
          CALL XPRVDU(NCVDU, 1,0)
          NNO = ISTORE (MSTR)
          NSE = ISTORE (MSTR+15)
          WRITE (CMON, '(A1)') '{'
          CALL XPRVDU(NCVDU, 1,0)
            DO 498, MNO = 1, NNO
            IF (LPRESE (MNO, MSETS, MOFF)) THEN
              WRITE (CMON, '(1X,I4)')  MNO
              CALL XPRVDU(NCVDU, 1,0)
            END IF
498       CONTINUE
          WRITE (CMON,'(A1)') '}'
          CALL XPRVDU(NCVDU, 1,0)
          MOFF = MOFF + NSE
500     CONTINUE
        WRITE (CMON, '(A)') ' '
        CALL XPRVDU(NCVDU, 1,0)
1000  CONTINUE
        WRITE (CMON, '(A)') ' '
        CALL XPRVDU(NCVDU, 1,0)
9900  CONTINUE
      END IF
      RETURN
      END
CODE FOR PSCOPY
      SUBROUTINE PSCOPY(LFROM, LTO, IHOW)
C
C
C IHOW = HOW TO COPY
C 0   - COPY ALL SETS
C 1   - COPY JUST THE FIRST SET (CORRESPONDING TO SUPERSTR)

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      IF (IHOW .EQ. 0) THEN
          MTRANT = MDSETS
      ELSE IF (IHOW .EQ. 1) THEN
          MTRANT = NINTSU+1
      ELSE
C          NERRFI = NERRFI_BAD_IHOW_TO_PSCOPY
          NERRFI = 156
          RETURN
      END IF
      DO 2000, MTRANS = 1, NNODEQ*MDSETS, MDSETS
           DO 1000, MMTRAN = 1, MTRANT
                 ISTORE(LTO+MTRANS+MMTRAN-2)
     1                =ISTORE(LFROM+MTRANS+MMTRAN-2)
1000       CONTINUE
           ISTORE (LTO+MTRANS-1) = NSTRUQ
2000  CONTINUE
      RETURN
      END
CODE FOR RMAXDI
      REAL FUNCTION RMAXDI()
C
C RETURNS MAXIMUM DISTANCE IN ANY INPUT FILE

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      COMMON/XCONST/NOWT,PI,TWOPI,TWOPIS,RTD,DTR,
     2 UISO,ZERO,ZEROSQ,VALUE,VALUSQ
      CHARACTER *80 CNAME
      CHARACTER *80  CREAD, CUPPER
      CHARACTER*8 CFMTXP
      CHARACTER CT*1
C
C RMAX IS A HARD LIMIT
      IF (ABS(RMAX-RMADEF) .GT. ZERO) THEN
          RMAXU = RMAX
          GO TO 9900
      END IF
C
C START AT 2.0
      RMAXU = 2.0
C
      DO 9000, MSTRUC=LSTRUC,LSTRUC+(NSTRUC-1)*MDSTRU,MDSTRU
C
C
          ITOPIN = ISTORE (MSTRUC+11)
          IF (ITOPIN .LE. MSTRUC) GO TO 8000
          ISIZE  = ISTORE (ITOPIN)
          WRITE (CFMTXP, '(2H( , I2, 3HA1))') ISIZE
          WRITE (CNAME(1:ISIZE), CFMTXP) (ISTORE(ITOPIN+J), J=1, ISIZE)
          OPEN  (NREAD2, FILE=CNAME(1:ISIZE), STATUS='OLD', IOSTAT=IOS)
          IF (IOS .NE. 0) THEN
                NERRFI = 1
                GO TO 9900
          END IF
C
C THIS IS THE START OF THE LOOP OVER THE LINES OF THE FILE.
1000  CONTINUE
          READ (NREAD2, '(A80)', END=8000, ERR=7000) CREAD
C
C CONVERT TO UPPER CASE
          CALL XCCUPC (CREAD, CUPPER)
C
C REMOVE REDUNDANT SPACES
          CALL XCREMS (CUPPER, CREAD, LREAD)
C
          IF (CREAD(1:2) .EQ. 'DI')  THEN
              ISER1R = KGTNUM(CREAD( 4    :), CT, NC)
              IPOS   = NC+5
              ISER2R = KGTNUM(CREAD(IPOS:), CT, NC)
              READ(CREAD(NC+IPOS+1:), '(F4.2,1X,F4.2)',IOSTAT=IERR)
     1                                          RDIST, RTOLE
              IF (IERR .GT. 0) THEN
C NERRFI = NERRFI_BAD_RDIST_READ
                  NERRFI = 94
                  GO TO 9900
              END IF
C
C COMPARE RDIST+TOLE FOR ATOM GRAPHS
C         RDIST+3*RTOLE (3*ESD) FOR BOND GRAPHS
              IF (INTYPE .EQ. 1) THEN
                  RCOMP = RDIST + RTOLE
              ELSE IF (INTYPE .EQ. 2) THEN
                  RCOMP = RDIST + (3.0*RTOLE)
              ELSE
C                  NERRFI = NERRFI_BAD_INTYPE
                  NERRFI = 22
              END IF
              IF (RCOMP .GT. RMAXU) RMAXU = RCOMP
          END IF
C
          GO TO 1000
7000      CONTINUE
C
C ERROR DURING READ
          NERRFI = 93
          GO TO 9900
8000      CONTINUE
          CLOSE (NREAD2)
9000  CONTINUE
9900  CONTINUE
      RMAXDI = RMAXU
      CLOSE(NREAD2)
      RETURN
      END
CODE FOR RMINDI
      REAL FUNCTION RMINDI()
C
C RETURNS MINIMUM DISTANCE TO BE USED

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      COMMON/XCONST/NOWT,PI,TWOPI,TWOPIS,RTD,DTR,
     2 UISO,ZERO,ZEROSQ,VALUE,VALUSQ
      CHARACTER *80 CNAME
      CHARACTER *80  CREAD, CUPPER
      CHARACTER*8 CFMTXP
      CHARACTER CT*1
C
C RMIN IS A HARD LIMIT
      IF (ABS(RMIN-RMIDEF) .GT. ZERO) THEN
          RMINU = RMIN
          GO TO 9900
      END IF
C
C START AT 0.5
      RMINU = 0.5
C
      DO 9000, MSTRUC=LSTRUC,LSTRUC+(NSTRUC-1)*MDSTRU,MDSTRU
C
C
          ITOPIN = ISTORE (MSTRUC+11)
          IF (ITOPIN .LE. MSTRUC) GO TO 8000
          ISIZE  = ISTORE (ITOPIN)
          WRITE (CFMTXP, '(2H( , I2, 3HA1))') ISIZE
          WRITE (CNAME(1:ISIZE), CFMTXP) (ISTORE(ITOPIN+J), J=1, ISIZE)
          OPEN  (NREAD2, FILE=CNAME(1:ISIZE), STATUS='OLD')
C
C
C THIS IS THE START OF THE LOOP OVER THE LINES OF THE FILE.
1000  CONTINUE
          READ (NREAD2, '(A80)', END=8000, ERR=7000) CREAD
C
C CONVERT TO UPPER CASE
          CALL XCCUPC (CREAD, CUPPER)
C
C REMOVE REDUNDANT SPACES
          CALL XCREMS (CUPPER, CREAD, LREAD)
C
          IF (CREAD(1:2) .EQ. 'DI')  THEN
              ISER1R = KGTNUM(CREAD( 4    :), CT, NC)
              IPOS   = NC+5
              ISER2R = KGTNUM(CREAD(IPOS:), CT, NC)
              READ(CREAD(NC+IPOS+1:), '(F4.2,1X,F4.2)',IOSTAT=IERR)
     1                                          RDIST, RTOLE
              IF (IERR .GT. 0) THEN
C NERRFI = NERRFI_BAD_RDIST_READ
                  NERRFI = 94
                  GO TO 9900
              END IF
C
C COMPARE RDIST-TOLE FOR ATOM GRAPHS
C         RDIST-3*RTOLE (3*ESD) FOR BOND GRAPHS
              IF (INTYPE .EQ. 1) THEN
                  RCOMP = RDIST - RTOLE
              ELSE IF (INTYPE .EQ. 2) THEN
                  RCOMP = RDIST - (3.0*RTOLE)
              ELSE
C                  NERRFI = NERRFI_BAD_INTYPE
                  NERRFI = 22
              END IF
              IF (RCOMP .LT. RMINU) RMINU = RCOMP
          END IF
C
          GO TO 1000
7000      CONTINUE
C
C ERROR DURING READ
          NERRFI = 93
          GO TO 9900
8000      CONTINUE
          CLOSE (NREAD2)
9000  CONTINUE
9900  CONTINUE
      RMINDI = RMINU
      CLOSE(NREAD2)
      RETURN
      END
CODE FOR SETFEL
      SUBROUTINE SETFEL(N, IVALUE, IFSTAR)
C
C SET ELEMENT N OF BINARY VECTOR F STARTING AT IFSTAR TO IVALUE
C IGNORE FIRST INTEGER OF F, WHICH HOLDS CARDINALITY
C      INTEGER N, IVALUE, IFSTAR
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
\XUNITS
      IF ((N .GT. NNODSU) .OR. (N .LE. 0) .OR. (IVALUE .LT. 0)
     1    .OR. (IVALUE .GT. 1)) THEN
          WRITE (NCAWU,*)
     1  ' ERROR IN SETFEL, N =', N, ' NNODSU =', NNODSU,
     2  ' IVALUE =', IVALUE
      ELSE
          ITOSET = IFSTAR + (N-1)/L1INT + 1
          NCOMPN = MOD ((N-1), L1INT)
          NCOMPN = N2POWS(NCOMPN)
          IF (IVALUE .EQ. 1) THEN
              ISTORE(ITOSET) = KOR (NCOMPN, ISTORE(ITOSET))
          ELSE
              NCOMPN = KKNOT(NCOMPN)
              ISTORE(ITOSET) = KAND(NCOMPN, ISTORE(ITOSET))
          END IF
      END IF
      RETURN
      END
CODE FOR TFTOG
      SUBROUTINE TFTOG(LNODES, NNODES, MTMPAT, NATS, MDATS,
     1                 LFLSAV, NBONDS, MTMPBO,LATS)
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
      LNODES = KSTALL(NATS*MDNODE)
      LATS  = LNODES
      MDATS = MDNODE
      NNODES = NATS
C
C WORK OVER THE ATOM LIST PUTTING IN FIXED INFO
      M = LFLSAV
      DO 1000, MNODES = LNODES, LNODES+(NNODES-1)*MDNODE, MDNODE
          MINFO = KSTALL(MDATS)
          ISTORE(MNODES)   = 0
          ISTORE(MNODES+1) = 0
          ISTORE(MNODES+2) = MINFO
          ISTORE(MNODES+3) = NFL - 1
C
C SPECIES AS HOLLERITH
          ISTORE (MINFO) = ISTORE(M-3)
C
C SERIAL NUMBER
          ISTORE (MINFO+1) = ISTORE(M-2)
C
C NO OF CONNECTIONS
          ISTORE (MINFO+2) = ISTORE (M-1)
C
C THE EXACT NO OF CONNECTIONS FLAG
          ISTORE (MINFO+3) = ISTORE (M  )
          M = M - MTMPAT
1000  CONTINUE
C
C NOW FILL IN FLEXIBLE INFO
      MBOBEG = LFLSAV-(NATS*MTMPAT)
      DO 4000, MNODES=LNODES, LNODES+(NNODES-1)*MDNODE, MDNODE
          MINFO  = ISTORE(MNODES+2)
          ISERNO = ISTORE(MINFO+1)
C
C LOOK FOR A BOND WITH THIS SERIAL NUMBER
          DO 3000, MBO = MBOBEG,MBOBEG-((NBONDS-1)*MTMPBO),-MTMPBO
              IF (ISTORE(MBO-MTMPBO+1) .EQ. ISERNO) THEN
                  ISERBO = ISTORE(MBO-MTMPBO+2)
              ELSE IF (ISTORE(MBO-MTMPBO+2) .EQ. ISERNO) THEN
                  ISERBO = ISTORE(MBO-MTMPBO+1)
              ELSE
                  GO TO 2900
              END IF
              MBTMP = KSTALL(3)
              IF (ISTORE(MNODES) .EQ. 0) THEN
                  ISTORE(MNODES) = MBTMP
              END IF
              ISTORE(MBTMP) = ISERBO
               STORE(MBTMP+1) = STORE(MBO-MTMPBO+3)
               STORE(MBTMP+2) = STORE(MBO-MTMPBO+4)
              ISTORE(MNODES+1) = ISTORE(MNODES+1) + 1
2900          CONTINUE
3000      CONTINUE
4000  CONTINUE
      RETURN
      END
CODE FOR XADDOP
      SUBROUTINE XADDOP (IOPTIO, MSTRUC)
C
C .TRUE. IF ALL THE OPTIONS ARE CHOSEN FOR STRUCTURE AT MSTRUC
      LOGICAL ALL
C
\XIOBUF
\XUNITS
      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C      WRITE (6, *) ' FROM XADDOP: IOPTIO, MSTRUC ', IOPTIO, MSTRUC
C      WRITE (6, *) ' '
C
C OPTIONS ARE HELD AS A BINARY VECTOR IN THE INTEGERS MSTRUC+18...
C IF BIT N IS SET, APPLY OPTION N FOR THIS QUERY.
C INTEGERS ARE INITIALISED SO THAT ALL BITS ARE SET.
C ONLY THE 31 BITS ACCESSIBLE BY MATHEMATICAL OPS ARE USED IN ANY
C ONE INTEGER IN THIS AREA.
C IF ALL THE OPTIONS ARE CURRENTLY FLAGGED, & APPLY OPTION=NUMBER
C IS CHOSEN, THEN DELETE ALL THE OPTIONS AND FLAG (IE SET THE BIT
C CORRESPONDING TO) NUMBER.
C IF A SUBSET OF THE OPTIONS ARE FLAGGED, THEN ALTERATIONS FROM THE
C DEFAULT HAVE ALREADY BEEN MADE, SO DO AN 'OR' OF THE INTEGERS
C REPRESENTING THE CURRENT SET AND REPRESENTING A SET HOLDING ONLY
C INTEGER 'NUMBER' TO SET THE OPTION 'NUMBER'.
C
C CHECK IF ALL THE OPTIONS ARE FLAGGED
C      LOPTI  = MSTRUC+18
      LOPTI  = MSTRUC+19
      DO 1000, MOPTI = LOPTI, LOPTI + NCPCKT - 1
            ALL = (ISTORE (MOPTI) .EQ. IUNIVE)
            IF (.NOT. ALL) GO TO 3000
1000  CONTINUE
C
C IF YOU ARRIVE HERE, ALL OPTIONS ARE CURRENTLY CHOSEN, SO
C ZEROISE THEM ALL.
      DO 2000, MOPTI = LOPTI, LOPTI + NCPCKT - 1
            ISTORE (MOPTI) = 0
2000  CONTINUE
3000  CONTINUE
C
C WORK OUT THE ADDRESS OF THE INTEGER TO CHANGE
      ICHANG = LOPTI + IOPTIO/(L1INT+1)
C
C WORK OUT THE INTEGER FOR THE CURRENT OPTION 'IOPTIO'
      INUMBE = MOD ((IOPTIO-1), L1INT)
      INUMBE = N2POWS(INUMBE)
C
C DO THE 'OR'
      ISTORE (ICHANG) = KOR ( ISTORE(ICHANG), INUMBE)
      WRITE(CMON,'(99(I4,1X))')
     1 (ISTORE (MOPTI),MOPTI=LOPTI,LOPTI+NCPCKT-1)
      CALL XPRVDU(NCVDU, 1,0)
      RETURN
      END
CODE FOR XADDST
      SUBROUTINE XADDST (LFLSAV, CREAD)
C
C ADD THE ATOMS IN CREAD TO THE STACK BELOW LFLSAV
C
C LOCALS:
C  CREAD THE STRING BEING ANALYSED
C  LBEG  WORKS UP CREAD POINTING TO THE START OF THE NEXT SECTION
C        FOR SEARCHING FOR CATFLA (*AT), SERIAL OR SPECIES FLAGS
C ASSUME THAT THE SERIAL OR SPECIES FLAGS ARE THE SAME LENGTH AS THE
C ATOM FLAG
C  NC    NUMBER OF DIGITS IN THE INTEGER EXTRACTED BY KGTNUM
      CHARACTER*1 CT
      CHARACTER*(*) CREAD

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      LCATFL = LEN(CATFLA)
      LBEG   = 4
      LTMP   = 0
      NC     = 0
1000  CONTINUE
      LBEG   = LBEG + LTMP + NC + 2
      IAT    = INDEX (CREAD(LBEG:), CATFLA)
      ISP    = INDEX (CREAD(LBEG:), CSPEFL)
      ISE    = INDEX (CREAD(LBEG:), CSERFL)
      IF (IAT .GT. 0) THEN
            IF ((ISE .GT. 0) .AND. (ISP .GT. 0)) THEN
                  LTMP = MIN (ISP, ISE, IAT)
            ELSE IF (ISE .GT. 0) THEN
                  LTMP = MIN (IAT, ISE)
            ELSE IF (ISP .GT. 0) THEN
                  LTMP = MIN (IAT, ISP)
            ELSE
                  LTMP = IAT
            END IF
      ELSE
            IF ((ISE .GT. 0) .AND. (ISP .GT. 0)) THEN
                  LTMP = MIN (ISP, ISE)
            ELSE
                  LTMP = MAX (ISP, ISE)
            END IF
      END IF
      IF (LTMP .GT. 0) THEN
C
C THIS IS AN ATOM REFERENCE. SAVE IT BELOW LFL IF IT ISN'T THERE
C ALREADY
            IATREF = KGTNUM (CREAD((LBEG+LTMP+LCATFL-1):), CT, NC)
            IF (IATREF .LE. 0) THEN
C
C AN ATOM REFERENCE WAS GIVEN BUT NO NUMBER FOLLOWED
                  NERRFI = 18
            ELSE
C
C SEARCH DOWN THE LIST OF ATOMS STORED SO FAR TO SEE IF THIS ATOM
C HAS ALREADY BEEN ACCOUNTED FOR
                  DO 2000, MAT= LFLSAV, (LFL+2), -2
                        IF (ISTORE(MAT) .EQ. IATREF) GO TO 1000
2000            CONTINUE
C
C NEED TO ADD A NEW ATOM
                  LFL    = LFL - 2
                  IF ((LFL - NFL) .LE. 0) THEN
                        NERRFI = 19
                  ELSE
                        ISTORE (LFL+2) = IATREF
                        ISTORE (LFL+1) = 0
                        GO TO 1000
                  END IF
            END IF
      END IF
      RETURN
      END
CODE FOR XASPEC
      SUBROUTINE XASPEC
C
C GENERATE SETS ACCORDING TO ATOM SPEC, FOR AN ATOM GRAPH
C NEEDS A STACK WITH ONLY ONE ENTRY PER TYPE

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
      MOFFSE = 1
      LBOSET = LSETS + NSETS*MDSETS
C
      LTOP   = LFL
      LEND   = LTOP + 1
C
C LOOP OVER ALL STRUCTURES
      DO 5000, MSTRUC = LSTRUC, LSTRUC+MDSTRU*(NSTRUC-1), MDSTRU
          NNODES = ISTORE(MSTRUC+1)
          LNODES = ISTORE(MSTRUC+2)
          DO 4000, MNODES = LNODES, LNODES+(MDNODE*(NNODES-1)), MDNODE
              CALL XSPINF(MSTRUC, MNODES, ISPEC, IJUNK)
              IF (NERRFI .NE. 0) GO TO 9900
              INODES = ((MNODES-LNODES)/MDNODE)+1
C
C SEARCH DOWN THE STACK OF RECOGNISED ATOM SPECIES
              DO 3000, LTST = LTOP,LEND,-1
                     IF (ISTORE(LTST) .EQ. ISPEC) THEN
C
C LOCATE THE SET
                      NADDCH = LBOSET
     1                        +MDSETS*(LTOP-LTST)
     2                        +MOFFSE
C
C SET THE APPROPRIATE BIT IN THE SET
                      ISTORE(NADDCH) = ISTORE(NADDCH) + 1
                      NADDCH = NADDCH + (INODES-1)/L1INT+1
                      NBIT   = MOD((INODES-1),L1INT)
               ISTORE(NADDCH)= ISTORE(NADDCH)+N2POWS(NBIT)
C LEAP OVER 'NEW/FIRST NODE TYPE' CODE
                      GO TO 3700
                  END IF
3000          CONTINUE
C
C MUST BE NEW, OR THE FIRST, NODE TYPE
              MSETS = KSTALL(MDSETS)
              LFL = LFL -1
              IF (LFL .LE. NFL) THEN
C                  NERRFI = NERRFI_OUT_OF_STORE
                  NERRFI = 234
                  GO TO 9900
              END IF
C
C STORE THIS ATOM TYPE BELOW LTOP
              LEND = LTST
              ISTORE(LEND) = ISPEC
C
C SET ALL SETS TO EMPTY
              DO 3500, IEMPTY=MSETS,MSETS+MDSETS-1
                  ISTORE(IEMPTY) = 0
3500          CONTINUE
C LOCATE THE ACTUAL SET FOR THIS STRUCTURE
              NADDCH = MSETS + MOFFSE
C SET CARDINALITY TO 1
              ISTORE(NADDCH) = 1
C
C SET THE BIT FOR THE CURRENT STRUCTURE & CURRENT NODE
              NADDCH = NADDCH + (INODES-1)/L1INT + 1
              NBIT   = MOD((INODES-1),L1INT)
              ISTORE(NADDCH) = ISTORE(NADDCH) + N2POWS(NBIT)
C
              NSETS = NSETS + 1
C
3700      CONTINUE
4000      CONTINUE
          MOFFSE = MOFFSE + ISTORE(MSTRUC+15)
5000  CONTINUE
C      CALL OUTSET (' BEFORE Q ATOMS ', 1, 0)
C
C DEAL WITH Q ATOMS
C SAVE PRE- Q ATOM NFL
       NFLPRQ = NFL
C LOOP OVER ALL THE EXISTING SPECIES SETS
      DO 9000, LTST = LTOP, LEND, -1
C
C THE Q SETS? CURRENTLY STORED JUST LIKE ANY OTHER TYPE
          IF (ISTORE(LTST) .EQ. ISPECQ) THEN
              MQSET = LBOSET + (LTOP-LTST)*MDSETS
C MAKE A COPY
              MCQSET = KSTALL(MDSETS)
              DO 6000, MCOPY=1,MDSETS
                  ISTORE(MCQSET+MCOPY-1) = ISTORE(MQSET+MCOPY-1)
6000          CONTINUE
C
C NEED TO UNION THE Q ATOMS (BOTH QUERY & STRUCTURE) WITH EACH OF THE
C OTHER ATOM SPECIES SETS
              DO 8000, LINNER = LTOP, LEND, -1
                  IF (ISTORE(LINNER) .NE. ISPECQ) THEN
C GET ADDRESS OF SET
                      MATSET = LBOSET+(LTOP-LINNER)*MDSETS
C
C MAKE A COPY
                      IF (MCASET .EQ. 0) MCASET = KSTALL(MDSETS)
                      DO 7000, MCOPY=1,MDSETS
                          ISTORE(MCASET+MCOPY-1) =
     1                                       ISTORE(MATSET+MCOPY-1)
7000                  CONTINUE
                      CALL XUNION(MCQSET,MCASET,MATSET,3)
C                      CALL XUNION(MCQSET,MCASET,MATSET,1)
                  END IF
8000          CONTINUE
              MCASET = 0
C
C PUT THE RESULT OF THE UNION IN THE ATOM SET
C
C NOW SET THE Q SETS (AT MQSET) TO ALL ATOMS SO THAT THEY NO LONGER
C PARTITION JUST FILL UP BOTH SIDES OF THE SET
                MOFFSE = 1
                NINTS = ISTORE(LSTRUC+15)
                ISTORE(MQSET+MOFFSE) = ISTORE(LSTRUC)
                DO 8200, MTMP=1, NINTS-1
                    ISTORE(MQSET+MOFFSE+MTMP) = IUNIVE
8200              CONTINUE
C                DO 8400, MSTRUC=LSTRUC,LSTRUC+(NSTRUC-1)*MDSTRU,
C     1                            MDSTRU
C                    NINTS = ISTORE(MSTRUC+15)
C                    ISTORE(MQSET+MOFFSE) = ISTORE(MSTRUC)
C                    DO 8200, MTMP=1, NINTS-1
C                        ISTORE(MQSET+MOFFSE+MTMP) = IUNIVE
C8200                CONTINUE
C                    MOFFSE = MOFFSE + NINTS
C8400            CONTINUE
C & DROP OUT
              GO TO 9500
C
C CREATE A COPY
C              MNEW = KSTALL(MDSETS)
C              NSETS = NSETS + 1
C              ISTORE(MNEW) = 0
C              DO 6000, MTMP = 1, MDSETS
C                  ISTORE(MNEW+MTMP-1) = ISTORE(MQSET+MTMP-1)
C6000          CONTINUE
C
C              NINTSU = ISTORE(LSTRUC+15)
C
C ONE SET FOR WHICH ALL THE STRUCTURE ATOMS ARE PRESENT FOR THE
C QUERY ATOMS
C              IF (ISTORE(MQSET+NINTSU+1) .EQ. 0) THEN
C JUST FILL UP BOTH SIDES OF THE SET
C                  MOFFSE = 1
C                  DO 6500, MSTRUC=LSTRUC,LSTRUC+(NSTRUC-1)*MDSTRU,
C     1                            MDSTRU
C                      NINTS = ISTORE(MSTRUC+15)
C                      ISTORE(MQSET+MOFFSE) = ISTORE(MSTRUC)
C                      DO 6400, MTMP=1, NINTS-1
C                          ISTORE(MQSET+MOFFSE+MTMP) = IUNIVE
C6400                  CONTINUE
C                      MOFFSE = MOFFSE + NINTS
C6500              CONTINUE
C              ELSE
C                  ISTORE(MQSET+1) = ISTORE(LSTRUC)
C                  DO 7000, MTMP = 2, NINTSU
C                      ISTORE(MQSET+MTMP) = IUNIVE
C7000              CONTINUE
C              END IF
CC
CC ADD THE Q ATOMS INTO THE STRUCTURE SETS
C                  IF (ISTORE(MNEW+1) .GT. 0) THEN
C                  MOFFSE = 1
C                  DO 7500, MSTRUC=LSTRUC+MDSTRU,
C     1                            LSTRUC+(NSTRUC-1)*MDSTRU,
C     2                            MDSTRU
C                      NINTS = ISTORE(MSTRUC+15)
C                      ISTORE(MNEW+MOFFSE) = 0
C                      DO 7400, MTMP=1, NINTS-1
C                          ISTORE(MNEW+MOFFSE+MTMP) = 0
C7400                  CONTINUE
C                      MOFFSE = MOFFSE + NINTS
C7500              CONTINUE
CC CREATE A TEMPORARY SET
C                      MTMPS2 = KSTALL(MDSETS)
C                      MTMPSE = KSTALL(MDSETS)
C                      DO 8000, MBOSET = LBOSET, MNEW-MDSETS,MDSETS
CC
C                          CALL XMOVE(ISTORE(MBOSET),
C     1                               ISTORE(MTMPS2), MDSETS)
C                          CALL XUNION(MNEW,MTMPS2,MTMPSE,1)
C                          CALL XMOVE(ISTORE(MTMPSE),
C     1                               ISTORE(MBOSET),MDSETS)
C8000                  CONTINUE
C                  END IF
C              NFL   = MNEW
C
C HAVE FOUND THE Q ATOMS SET, SO CAN DROP OUT
C              GO TO 9500
          END IF
9000  CONTINUE
9500  CONTINUE
C
C RESET NFL TO ITS PRE-Q ATOM VALUE
      NFL = NFLPRQ
9900  CONTINUE
C      CALL OUTSET (' AFTER Q ATOMS ', 1, 0)
      RETURN
      END
CODE FOR XATSN
      SUBROUTINE XATSN (NSER, ISER1, ISER2, MSTRUC)
C
C RETURNS THE SERIAL NUMBERS OF THE ATOMS OF THE STRUCTURE BOND
C CORRESPONDING TO THE BOND OF QUERY STRUCTURE MSTRUC WITH SERIAL NUMBER
C NSER ACCORDING TO THE PS AT LPSL.
C
C ISER1, ISER2 ARE THE SERIAL NUMBERS RETURNED
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
      ISER1 = 0
      ISER2 = 0
C
C FIND, FROM THE P.S., THE SERIAL NUMBER OF THE STRUCTURE BOND
C CORRESPONDING TO NSER.
      MPS   = LPSL + (NSER-1)*MDSETS + 2
      NTOT  = 0
      DO 1000, I = MPS, MPS + NINTSU - 2
            NPOWE2 = ISTORE (I)
            IF (NPOWE2 .GT. 0) THEN
                  IF (I .LT. (MPS+NINTSU-2)) THEN
                        DO 2000, MBITS = 1, L1INT
                        IF ( KAND(NPOWE2,N2POWS(MBITS-1))
     1                              .EQ. N2POWS(MBITS-1) ) THEN
                             NSUSUP = NTOT+MBITS
                        END IF
2000                    CONTINUE
                  ELSE
C
C LOOP UP TO THE FIRST BIT IN THIS INTEGER WHICH IS SET
                        DO 3000, MBITS = 1, L1INT
                        IF ( KAND(NPOWE2,N2POWS(MBITS-1))
     1                              .EQ. N2POWS(MBITS-1) ) THEN
                             NSUSUP = NTOT+MBITS
                             GO TO 4000
                        END IF
3000                    CONTINUE
4000  CONTINUE
                  END IF
            ELSE
                  NTOT = NTOT + L1INT
            END IF
1000  CONTINUE
C
C FIND, FROM THE BOND LIST, THE ATOM SERIAL NUMBERS CORRESPONDING TO
C THIS BOND
      LNODES = ISTORE (LSTRUC+2)
      MNODES = LNODES + (NSUSUP-1)*MDNODE
      ISER1  = ISTORE (MNODES+2)
      ISER2  = ISTORE (ISER1+1)
      ISER1  = ISTORE (ISER1)
      RETURN
      END
CODE FOR XBRGRL
      SUBROUTINE XBRGRL
C
C BUILD RANKED GRAPH LIST (IF REQUESTED)
C THE SUPERSTRUCTURE IS ALWAYS THE FIRST ITEM IN THIS LIST
C IF REQUESTED, THE QUERY STRUCTURES WHICH FOLLOW ARE RANKED
C IN ORDER OF DECREASING SIZE OF GRAPH (NOT IN ORDER OF NUMBER
C OF ATOMS)
C INTYPE = TYPE OF GRAPH TO BUILD
C          1 => ATOM GRAPH
C          2 => BOND GRAPH
C
C LOCALS :
C  NCHLIS: TYPE OF ACTUAL STRUCTURE INFO
C          1 => WHOLE LIST 5
C          2 => WHOLE LIST 10
C          3 => ATOM LIST FROM CSD-TYPE FILE
C
\XLST05
      COMMON/XLST10/L10,M10,MD10,N10,L10A,M10A,MD10A,N10A
\XUNITS
      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
C
      WRITE (NCAWU, '(1X,A)')
     1 'BUILDING GRAPHS OF STRUCTURE AND QUERIES'
C
C ANY EXACT CONNECTIONS - DEFAULT IS NONE
      LEXACT = .FALSE.
      DO 1000, MSTRUC=LSTRUC,LSTRUC+(NSTRUC-1)*MDSTRU,MDSTRU
C
C BUILD UP THE GRAPH
            NADDFI = ISTORE (MSTRUC+11)
            NADDFI = ISTORE (NADDFI   )
            NCHLIS = ISTORE (MSTRUC+10)
            IF (NCHLIS .EQ. 1) THEN
                  IF (NADDFI .GT. 0) THEN
C
C CODE TO READ NEW WHOLE LIST 5 FROM A FILE
C                         NERRFI = NERRFI_CANT_DO
                         NERRFI = 31
                         GO TO 9900
                  ELSE
C
C LIST 5 TYPE INFO FROM LIST 5 ITSELF
C CALL TO KHUNTR HERE
C THEN CALL TO LOAD LIST 5 IF IT'S NEEDED
                        IF (KHUNTR (5,0, IADDL,IADDR,IADDD, -1)
     1                     .NE. 0)   CALL XLDR05(5)
                        LATS = L5
                        NATS = N5
                        MDATS = MD5
                  END IF
                  CALL XL5TOG(NCHLIS, LNODES, NNODES, LATS,NATS,MDATS)
                  IF (NERRFI .GT. 0) GO TO 9900
            ELSE IF (NCHLIS .EQ. 2) THEN
                  IF (NADDFI .GT. 0) THEN
C
C LIST 10 WHOLE FROM A FILE
C                        NERRFI = NERRFI_CANT_DO
                        NERRFI = 31
                        GO TO 9900
                  ELSE
C
C LIST 10 INFO FROM LIST 10
C CALL TO KHUNTR HERE
C THEN CALL TO LOAD LIST 10 IF IT'S NEEDED
                        IF (KHUNTR (10,0, IADDL,IADDR,IADDD, -1)
     1                      .NE. 0)   CALL XLDR05(10)
                        LATS   = L10
                        NATS   = N10
                        MDATS  = MD10
                  END IF
                  CALL XL5TOG(NCHLIS,LNODES,NNODES,LATS,NATS,MDATS)
                  IF (NERRFI .NE. 0) GO TO 9900
            ELSE IF (NCHLIS .EQ. 3) THEN
C
C INFO FROM CSD-TYPE DATA FILE
                  CALL XFITOB (MSTRUC,LNODES,NNODES,LATS,NATS,MDATS)
                  IF (NERRFI .NE. 0) GO TO 9900
            ELSE
C                  NERRFI = NERRFI_BAD_NCHLIS
                  NERRFI = 32
                  GO TO 9900
            END IF
C
C STICK POINTERS TO THE GRAPH INFO IN THE GENERAL STRUCTURE LIST
            ISTORE (MSTRUC  )  = NNODES
            ISTORE (MSTRUC+1)  = NNODES
            ISTORE (MSTRUC+2)  = LNODES
C
C STICK POINTERS TO THE ATOM INFO INTO THE GENERAL STRUCTURE LIST
            ISTORE (MSTRUC+12) = NATS
            ISTORE (MSTRUC+13) = LATS
            ISTORE (MSTRUC+14) = MDATS
1000  CONTINUE
C
C SORT THE GENERAL ENTRIES IF IT'S REQUIRED
      IF (LSORT) CALL XSORIF
9900  CONTINUE
      RETURN
      END
CODE FOR XBUFFW
      SUBROUTINE XBUFFW(LFLSAV,CBUFF,CUPPER,NROWCB,MSTRUC,LOCCCB)
C
C COMBINE THE INFORMATION IN THE BUFFER & THE STACK TO FILL IN
C ATOM CORRESPONDENCES GIVEN BY THE *ATN FLAGS IN CREAD
C ASSUME THE SUPERSTRUCTURE INFO IS OF TYPE LIST 5/10
C AND THE STACK EXTENDS FROM LFLSAV DOWN TO LFL+1
C CUPPER IS IN UPPER CASE AND WITH REDUNDANT SPACES REMOVED
C THE FIRST 5 CHARACTERS OF CUPPER ARE IGNORED AS THEY INCLUDE
C THE CSD COMMENT FLAG
      CHARACTER*(*) CBUFF(NROWCB)
      CHARACTER*80 CUPPER
      CHARACTER*40 CATOM
      CHARACTER*1 CT
      LOGICAL LATOM, LSPEC

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
\XLST05
      COMMON/XLST10/L10,M10,MD10,N10,L10A,M10A,MD10A,N10A
C
      LATS   = ISTORE (MSTRUC+13)
      MDATS  = ISTORE (MSTRUC+14)
C
C DEFAULT FLAG STEMS CAN BE CHANGED IN FINDBD.
      LCATFL = LEN (CATFLA  )
      LCBUFF = LEN (CBUFF(1))
C
C IINDCU IS A POINTER TO THE POSITION IN CUPPER
      IINDCU = 6
C
C IINDCB IS A POINTER TO THE COLUMN OF CBUFF AT WHICH WRITING WILL
C        CARRY ON.  IE IT GOES FROM 1 TO LCBUFF
      IINDCB = 1
C
C IROWCB POINTS TO THE ROW OF CBUFF BEING WRITTEN TO, IE IT GOES
C        FROM 1 TO 5
      IROWCB = 1
1000  CONTINUE
      INAT = INDEX (CUPPER(IINDCU:), CATFLA)
      INSE = INDEX (CUPPER(IINDCU:), CSERFL)
      INSP = INDEX (CUPPER(IINDCU:), CSPEFL)
      IF (INAT .GT. 0) THEN
            IF ((INSE .GT. 0) .AND. (INSP .GT. 0)) THEN
                  INEXTI = MIN (INSP, INSE, INAT)
            ELSE IF (INSE .GT. 0) THEN
                  INEXTI = MIN (INAT, INSE)
            ELSE IF (INSP .GT. 0) THEN
                  INEXTI = MIN (INAT, INSP)
            ELSE
                  INEXTI = INAT
            END IF
            LATOM  = (INAT .EQ. INEXTI)
      ELSE
            LATOM = .FALSE.
            IF ((INSE .GT. 0) .AND. (INSP .GT. 0)) THEN
                  INEXTI = MIN (INSP, INSE)
            ELSE
                  INEXTI = MAX (INSP, INSE)
            END IF
      END IF
      LSPEC  = (INSP .EQ. INEXTI)
      IF (INEXTI .GT. 0) THEN
C
C THERE IS ANOTHER FLAG ON THIS LINE
C WRITE EVERYTHING IN THE LINE UNTIL THIS FLAG TO CBUFF
C (IF THERE IS ANYTHING, THAT IS)
            IF (INEXTI .GT. 1) THEN
                  CALL XFIBUF (CUPPER(IINDCU:(IINDCU+INEXTI-2)),
     1                (INEXTI-1), CBUFF, NROWCB, IINDCB, IROWCB)
            END IF
            IINDCU = IINDCU + INEXTI + LCATFL - 1
C
C EXTRACT THE NUMBER OF THE QUERY ATOM THIS POINTS TO
            IATREF = KGTNUM(CUPPER(IINDCU:), CT, NC)
            IF (IATREF .LE. 0) THEN
C
C AN ATOM REFERENCE WAS GIVEN BUT NO NUMBER FOLLOWED
                  NERRFI = 18
                  GO TO 9900
            END IF
            IINDCU = IINDCU + NC
C
C SEARCH THE STACK TO FIND ITS CORRESPONDENT
            MATREF = LFLSAV + 2
2000  CONTINUE
            MATREF = MATREF - 2
            IF  (MATREF .LE. LFL) THEN
C
C STHG WRONG - OFF THE BOTTOM OF THE STACK
                   NERRFI = 20
                   GO TO 9900
            END IF
            IF (ISTORE (MATREF) .NE. IATREF) GO TO 2000
            IATSER = ISTORE (MATREF-1)
            IF (LATOM ) THEN
C THE FIRST FLAG IS TO AN ATOM
                  IINFO = ISTORE(MSTRUC+10)
                  IF (INTYPE .EQ. 1) THEN
C
                      LNODES = ISTORE(MSTRUC+2)
                      MINFO  =
     1                 ISTORE(LNODES+(ISTORE(MATREF-1)-1)*MDNODE+2)
                      IF (IINFO .EQ. 1) THEN
                          MATREF = L5 + (ISTORE(MINFO)-1)*MD5
                      ELSE
C NERRFI = NERRFI_NO_ATOM_INFO
                          NERRFI = 345
                          GO TO 9900
                      END IF
                      ATOM   = STORE (MATREF)
                      SERIAL = STORE (MATREF+1)
                      IS     = ISTORE(MINFO+1)
                      NPLI   = ISTORE(MINFO+2)
                      ITX    = ISTORE(MINFO+3)
                      ITY    = ISTORE(MINFO+4)
                      ITZ    = ISTORE(MINFO+5)
                  ELSE IF (INTYPE .EQ. 2) THEN
                      MATREF = LATS+((IATSER-1)*MDATS)
                      ATOM   = STORE (MATREF)
                      SERIAL = STORE (MATREF+1)
                      IS     = 1
                      NPLI   = 1
                      ITX    = 0
                      ITY    = 0
                      ITZ    = 0
                  END IF
                  CALL CATSTR (ATOM,SERIAL,IS,NPLI,ITX,ITY,ITZ,
     1                         CATOM,LCATOM)
            ELSE IF (LSPEC) THEN
C THE FIRST IS TO A SPECIES
                  ISPE = KGTSP  (IATSER, MSTRUC)
                  IF (NERRFI .GT. 0) GO TO 9900
                  WRITE (CATOM(1:4), '(A4)') ISPE
                  CALL XCTRIM (CATOM(1:4), LCATOM)
                  LCATOM = LCATOM -1
            ELSE
C THE FIRST IS TO JUST A SERIAL NUMBER
C GET THE SERIAL NUMBER
                  ISER = KGTSER (IATSER, MSTRUC)
                  IF (NERRFI .GT. 0) GO TO 9900
                  CATOM = ' '
                  IEND  = 0
                  CALL CIAPP (CATOM, ISER, IEND)
                  LCATOM = IEND - 1
            END IF
C
C WRITE THE ATOM INTO CATOM
C WILL NEED TO CHANGE HERE TO ACCOUNT FOR THE EXTENDED LIST 5
C            MATREF = LATS+((IATSER-1)*MDATS)
C            IF (LEXTEN) THEN
C
C DO THE ATOM BITS HERE FOR THE EXTENDED STRUCTURE
C                  ATOM   = STORE (MATREF)
C                  SERIAL = STORE (MATREF+1)
C                  IS     = ISTORE (M5REF+2)
C                  NPLI   = ISTORE (M5REF+3)
C                  ITX    = ISTORE (M5REF+4)
C                  ITY    = ISTORE (M5REF+5)
C                  ITZ    = ISTORE (M5REF+6)
C                  IS     = 1
C                  NPLI   = 1
C            ELSE
C                  ATOM   = STORE (MATREF)
C                  SERIAL = STORE (MATREF+1)
C                  IS     = ISTORE (M5REF+2)
C                  NPLI   = ISTORE (M5REF+3)
C                  ITX    = ISTORE (M5REF+4)
C                  ITY    = ISTORE (M5REF+5)
C                  ITZ    = ISTORE (M5REF+6)
C                  IS     = 1
C                  NPLI   = 1
C                  ITX    = 0
C                  ITY    = 0
C                  ITZ    = 0
C            END IF
C            CALL CATSTR (ATOM,SERIAL,IS,NPLI,ITX,ITY,ITZ,CATOM,LCATOM)
            CALL XFIBUF (CATOM, LCATOM, CBUFF, NROWCB, IINDCB, IROWCB)
            IF (NERRFI .GT. 0) GO TO 9900
C
C CHECK FOR MORE FLAGS
            GO TO 1000
      ELSE
C
C NO MORE FLAGS.  WRITE OUT THE REMAINDER OF THE LINE
            CALL XCTRIM (CUPPER(IINDCU:), LCUP)
            CALL XFIBUF (CUPPER(IINDCU:), (LCUP-1), CBUFF, NROWCB,
     1                   IINDCB, IROWCB)
      END IF
C
C PASS BACK THE INDEX OF THE LAST FILLED ROW OF THE BUFFER
      LOCCCB = IROWCB
9900  CONTINUE
      RETURN
      END
CODE FOR XCHECK
      SUBROUTINE XCHECK
C
C DJK 22/1/92
C LOOKS AT THE SET AT THE TOP POSITION IN THE SET LIST, I.E. AT ENTRY
C LSETS + (NSETS-1)*MDSETS AND CHECKS IT AGAINST OTHER SET ENTRIES FOR.
C THIS STRUCTURE.
C IF THE SETS CORRESPONDING TO THE SUPERSTRUCTURE AND THE SUBSTRUCTURE
C ARE THE SAME AS THOSE IN ANY OTHER ENTRY, THE ENTIRE NEW ENTRY IS
C FORGOTTEN BY DECREMENTING NSETS BY 1 AND NFL BY MDSETS.
C BEFORE THE TEST IS DONE, THE NEW SET IS CHECKED TO SEE IF:
C A) EITHER SUBSTRUCTURE OR SUPERSTRUCTURE SET HAS NO NODES
C B) THE SUPERSTRUCTURE SET CONTAINS ALL THE REMAINING NODES OF THE
C    SUPERSTRUCTURE
C
C LOCALS:
C MTOPSE = THE SET BEING CONSIDERED
C NINTSU = NO. OF INTEGERS REQUIRED TO STORE ONE SET OF THE
C          SUPERSTRUCTURE, INCLUDING CARDINALITY
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
      MTOPSE = LSETS + ((NSETS-1) * MDSETS)
C
      IF (((ISTORE (MTOPSE+1)      .NE.     0)
     1.AND. (ISTORE (MTOPSE+MOFFSQ) .NE.     0))
     2.AND.(ISTORE (MTOPSE+1) .LT. NREMSU)) THEN
            DO 4000, MSETS = LSETS, LSETS + ((NSETS - 2) * MDSETS)
                 IF ((ISTORE(MSETS) .EQ. NSTRUQ)
     1          .OR. (ISTORE(MSETS) .EQ. -NSTRUQ)
     2          .OR. (ISTORE(MSETS) .EQ. 0)
     3          .OR. (ISTORE(MSETS) .EQ. -1)) THEN
                  DO 2000, I = 1, NINTSU
                        IF (ISTORE( MSETS +NINTSU) .NE.
     1                      ISTORE( MTOPSE+NINTSU)) GO TO 3500
2000              CONTINUE
                  DO 3000, I = 1, NINTQ
                        IF (ISTORE( MSETS + MOFFSQ + NINTQ - 2) .NE.
     1                      ISTORE( MTOPSE+ MOFFSQ + NINTQ - 2))
     2                      GO TO 3500
3000              CONTINUE
C
C IF THE COMPARISON HAS REACHED THIS FAR, THE SETS ARE THE SAME
      NSETS = NSETS - 1
      NFL   = NFL   - MDSETS
      GO TO 9000
3500  CONTINUE
                END IF
4000  CONTINUE
      ELSE
            NSETS = NSETS - 1
            NFL   = NFL   - MDSETS
      END IF
C
9000  CONTINUE
      RETURN
      END
CODE FOR XCLFIN
      SUBROUTINE XCLFIN
C
C CLEARS THE FIND VARIABLES SO THAT REPEATED APPLICATION WON'T
C CAUSE PROBLEMS
C DON'T CLEAR NERRFI (ERROR FLAG) BECAUSE IT'S PASSED ON UP

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      LSTRUC = 0
      NSTRUC = 0
      LSETS  = 0
      NSETS  = 0
      MDSETS = 0
      LPSL   = 0
      LNEW   = 0
      INTYPE = 0
      NTOPIS = 0
      NINTQ  = 0
      MOFFSQ = 0
      NNODEQ = 0
      NSTRUQ = 0
      NIDENT = 0
      NINTSU = 0
      NNODSU = 0
      NREMSU = 0
      RETURN
      END
CODE FOR XCONNS
      SUBROUTINE XCONNS
C
C DJK
C TAKES ALL THE SETS TO WHICH CONNECTIVITY HAS NOT YET BEEN
C APPLIED & APPLIES CONNECTIVITY TO THEM
C
      CHARACTER*35 CTMP

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
C      CALL OUTSET (' ENTERING XCONNS ', 1, 0)
C
C LOOP OVER ALL THE SETS GENERATED SO FAR
C & CALCULATE CONNECTIVITY SET FOR THOSE WHICH HAVEN'T BEEN FLAGGED
C UNUSABLE.  ANY FURTHER FLAGGING GOES ON IN XCSET.
      DO 9000, MSETS = LSETS, LSETS + ((NSETS-1)*MDSETS), MDSETS
            IFLAGG = ISTORE (MSETS)
            IF (IFLAGG .GE. 0)THEN
                   CALL XCSET (MSETS, IFLAGG)
                   CTMP (1:32) = ' AFTER APPLYING CONNECTIVITY TO '
                   WRITE (CTMP(33:35),'(I3)')(((MSETS-LSETS)/MDSETS)+1)
C                   CALL OUTSET (CTMP)
            END IF
9000  CONTINUE
      LNEWS = (NSETS .GT. (((LPSL - LSETS)/MDSETS) + NNODEQ))
      RETURN
      END
CODE FOR XCORAG
      SUBROUTINE XCORAG(LFLSAV)
C
C FOR ATOMS-AS-NODES, PUT CORRESPONDENCES INTO ATOM STACK AS FOUND BY
C THE PS AT LPSL

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      LOGICAL LTMP, LPRESE
C
C LOOP OVER PS
      DO 9000, MPSTMP = LPSL, LPSL+(NNODEQ-1)*MDSETS, MDSETS
          NQAT = 1+((MPSTMP-LPSL)/MDSETS)
C
C FIND THE STRUCTURE ATOM TO WHICH THIS HAS BEEN MATCHED
          NSAT = 0
900       CONTINUE
          NSAT = NSAT + 1
          LTMP = LPRESE(NSAT, MPSTMP, 1)
          IF (.NOT. LTMP) THEN
              GO TO 900
          END IF
          IF (NERRFI .GT. 0) GO TO 9900
C
C LOCATE THIS IN THE STACK & PUT THE QUERY IN
          MAT    = LFLSAV + 2
1000      CONTINUE
          MAT    = MAT - 2
          IF (MAT .GT. LFL) THEN
              IF (NQAT .EQ. ISTORE(MAT)) ISTORE(MAT-1) = NSAT
              GO TO 1000
          END IF
9000  CONTINUE
9900  CONTINUE
      RETURN
      END
CODE FOR XCORST
      SUBROUTINE XCORST (LFLSAV, MSTRUC)
C
C TAKES A STACK OF ATOM REFERENCES AND ADDS INTO IT THE CORRESPONDING
C STRUCTURE ATOM SERIAL NUMBERS AS GIVEN IN THE PS AT LPSL FOR THE QUERY
C MSTRUC.
C INTYPE - GLOBAL SAYING TYPE OF GRAPH PROVIDED
C        = 1 ATOMS AS NODES
C        = 2 BONDS AS NODES
C
C IASTYP = TYPE OF ATOM INFO SUPPLIED FOR STRUCTURE
C IAQTYP = TYPE OF ATOM INFO SUPPLIED FOR QUERY
C        = 1 LIST 5
C        = 2 LIST 10
C        = 3 ATOM LIST FROM CSD-TYPE DATA FILE
C LOCALS:
C  NMATCH  = NUMBER OF ATOMS FROM THE STACK WHICH HAVE BEEN MATCHED
C  NACTUA  = ACTUAL NUMBER OF ATOMS WHICH NEED TO BE MATCHED, IE
C            THE LENGTH OF THE STACK
C
      LOGICAL SHOMO, QHOMO, AMATCH, BMATCH, ABMATC, BAMATC
      LOGICAL LSACOR

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
      NACTUA = (LFLSAV-LFL)/2
      IF (NACTUA .EQ. 0) THEN
C NO ATOM REFS FOR THIS FILE - BUT NO ERRORS
             GO TO 9900
      ELSE IF (NACTUA .LT. 0) THEN
C
C NEGATIVE STACK LENGTH
C            NERRFI = NERRFI_BAD_STACK
             NERRFI = 42
             GO TO 9900
      END IF
      NMATCH = 0
      LNODEQ = ISTORE (MSTRUC+2)
      IF (INTYPE .EQ. 1) THEN
          CALL XCORAG(LFLSAV)
          IF (NERRFI .GT. 0) GO TO 9900
      ELSE IF (INTYPE .EQ. 2) THEN
C
C BONDS AS NODES
C LOOP OVER THE NODES OF THE QUERY STRUCTURE
            DO 8500, MNODEQ = LNODEQ,LNODEQ+(NNODEQ-1)*MDNODE,MDNODE
C
C TEMPORARY VARIABLE HOLDING THE ADDRESS OF THE BEGINNING OF INFO ABOUT
C THIS NODE
                  MMNODE = ISTORE (MNODEQ+2)
C
C SERIAL NUMBERS OF FIRST & SECOND ATOMS IN THIS QUERY BOND
                  ISEQ1A = ISTORE (MMNODE  )
                  ISEQ1B = ISTORE (MMNODE+1)
C
C SERIAL NUMBER OF THE CURRENT QUERY NODE
                  NSERQ = ((MNODEQ-LNODEQ)/MDNODE)+1
C
C LOCATE THE STRUCTURE ATOM SERIAL NUMBERS ASSIGNED TO THIS QUERY NODE
C IN THE PS
C??                  CALL XATSN (NSERQ, ISES1A, ISES1B, LSTRUC)
                  CALL XATSN (NSERQ, ISES1A, ISES1B, MSTRUC)
C
C NOT NECESSARILY HERE GET THE SPECIES ASSOCIATED WITH THIS QUERY NODE
                  ISPQ1A = KGTSP (ISEQ1A, MSTRUC)
                  IF (NERRFI .NE. 0) GO TO 9900
                  ISPQ1B = KGTSP (ISEQ1B, MSTRUC)
                  IF (NERRFI .NE. 0) GO TO 9900
C
C DETERMINE THE CONNECTIONS TO THIS NODE
                  LCONNS = ISTORE (MNODEQ  )
                  NCONNS = ISTORE (MNODEQ+1)
                  IF (NCONNS .EQ. 0) THEN
C
C THIS IS A LONE BOND
C SEARCH FOR THE POINTERS TO THESE ATOMS IN THE STACK
                       MATCOA = KMATST (LFLSAV, ISEQ1A)
                       MATCOB = KMATST (LFLSAV, ISEQ1B)
                       IF ((MATCOA .LE. 0) .OR. (MATCOB .LE. 0)) THEN
C NERRFI = NERRFI_OFF_STACK
                             NERRFI = 27
                             GO TO 9900
                       END IF
C
C TRYING TO MATCH:
C STRUCTURE: A - B
C
C  TO QUERY: A - B
                       ISPS1A = KGTSP (ISES1A, LSTRUC)
                       ISPS1B = KGTSP (ISES1B, LSTRUC)
                       QHOMO  = (ISPQ1A .EQ. ISPQ1B)
                       SHOMO  = (ISPS1A .EQ. ISPS1B)
                       AMATCH = (ISPQ1A .EQ. ISPS1A)
                       BMATCH = (ISPQ1B .EQ. ISPS1B)
                       ABMATC = (ISPQ1A .EQ. ISPS1B)
                       BAMATC = (ISPQ1B .EQ. ISPS1A)
                       IF   ((.NOT. QHOMO) .AND. (.NOT. SHOMO)) THEN
C
C HETERONUCLEAR - NEED TO USE SPECIES TO GET A MATCH
                             IF (NERRFI .GT. 0) GO TO 9900
                             IF (AMATCH .AND. BMATCH) THEN
                                   IMSS1A = ISES1A
                                   IMSS1B = ISES1B
                             ELSE IF  (ABMATC .AND. BAMATC) THEN
                                   IMSS1A = ISES1B
                                   IMSS1B = ISES1A
                             ELSE IF ((AMATCH
     1                           .AND.((ISPQ1B .EQ. ISPECQ)
     2                           .OR.  (ISPS1B .EQ. ISPECQ)))
     3                           .OR. (BMATCH
     4                           .AND.((ISPQ1A .EQ. ISPECQ)
     5                           .OR.  (ISPS1A .EQ. ISPECQ))))THEN
                                   IMSS1A = ISES1A
                                   IMSS1B = ISES1B
                             ELSE IF ((ABMATC
     1                           .AND.((ISPQ1B .EQ. ISPECQ)
     2                           .OR.  (ISPS1A .EQ. ISPECQ)))
     3                           .OR. (BAMATC
     4                           .AND.((ISPQ1A .EQ. ISPECQ)
     5                           .OR.  (ISPS1B .EQ. ISPECQ))))THEN
                                   IMSS1A = ISES1B
                                   IMSS1B = ISES1A
                             ELSE IF ((AMATCH
     1                           .AND.(ISPQ1A .EQ. ISPECQ))
     2                           .OR. (BMATCH
     3                           .AND.(ISPQ1B .EQ. ISPECQ)))   THEN
                                   IMSS1A = ISES1B
                                   IMSS1B = ISES1A
                             ELSE IF ((ABMATC
     1                           .AND.(ISPQ1A .EQ. ISPECQ))
     2                           .OR. (BAMATC
     3                           .AND.(ISPQ1B .EQ. ISPECQ)))   THEN
                                   IMSS1A = ISES1A
                                   IMSS1B = ISES1B
                             ELSE
C NERRFI = NERRFI_ATOM_SPECIES_WRONG_IN_MATCHED_BOND
                                   NERRFI = 33
                                   GO TO 9900
                             END IF
                       ELSE IF (QHOMO .AND. SHOMO) THEN
C
C HOMONUCLEAR - DOESN'T MATTER WHICH IS WHICH, EVEN IF Q'S ARE
C INVOLVED
                             IMSS1A = ISES1A
                             IMSS1B = ISES1B
                       ELSE IF (QHOMO .AND. (.NOT. SHOMO)) THEN
C
C OK AS LONG AS THE QUERY ATOMS ARE BOTH Q'S
                             IF (ISPQ1A .EQ. ISPECQ) THEN
                                   IMSS1A = ISES1A
                                   IMSS1B = ISES1B
                             ELSE
C NERRFI = NERRFI_ATOM_SPECIES_WRONG_IN_MATCHED_BOND
                                   NERRFI = 33
                             END IF
                       ELSE IF (SHOMO .AND. (.NOT. QHOMO)) THEN
C
C OK AS LONG AS THE STRUCTURE ATOMS ARE BOTH Q'S
                             IF (ISPS1A .EQ. ISPECQ) THEN
                                   IMSS1A = ISES1A
                                   IMSS1B = ISES1B
                             ELSE
C NERRFI = NERRFI_ATOM_SPECIES_WRONG_IN_MATCHED_BOND
                                   NERRFI = 33
                             END IF
                       END IF
C
C NOW STICK THE MATCHED ATOMS IN
                       ISTORE (MATCOA-1) = IMSS1A
                       ISTORE (MATCOB-1) = IMSS1B
                       GO TO 9000
                  ELSE
C
C LOOP OVER THESE CONNECTIONS
                  DO 8000, MCONNS= LCONNS, LCONNS+(NCONNS-1)*3, 3
C
C SERIAL NUMBER OF THE CURRENT CONNECTION.
                       NSERC  = ISTORE (MCONNS)
C
C ADDRESS OF THIS NODE IN THE QUERY NODE LIST
                       MSERC  = LNODEQ + MDNODE*(NSERC-1)
                       MMNODE = ISTORE (MSERC+2)
C
C ATOMIC SERIAL NUMBERS ASSOCIATED WITH THIS BOND
                       ISEQ2A = ISTORE (MMNODE  )
                       ISEQ2B = ISTORE (MMNODE+1)
C
C WHAT ATOM FROM THE QUERY DOES THIS PAIR OF BONDS HAVE IN COMMON?
                       IF ((ISEQ1A .EQ. ISEQ2A)
     1                    .AND. (ISEQ1B .NE. ISEQ2B)) THEN
                             ICOMMQ = ISEQ1A
                             ICOQ1  = ISEQ1B
                             ICOQ2  = ISEQ2B
                       ELSE IF ((ISEQ1A .NE. ISEQ2A)
     1                         .AND. (ISEQ1B .EQ. ISEQ2B)) THEN
                             ICOMMQ = ISEQ1B
                             ICOQ1  = ISEQ1A
                             ICOQ2  = ISEQ2A
                       ELSE IF ((ISEQ1B .EQ. ISEQ2A)
     1                         .AND. (ISEQ1A .NE. ISEQ2B)) THEN
                             ICOMMQ = ISEQ1B
                             ICOQ1  = ISEQ1A
                             ICOQ2  = ISEQ2B
                       ELSE IF ((ISEQ1B .NE. ISEQ2A)
     1                         .AND. (ISEQ1A .EQ. ISEQ2B)) THEN
                             ICOMMQ = ISEQ1A
                             ICOQ1  = ISEQ1B
                             ICOQ2  = ISEQ2A
                       ELSE
C
C SOME ERROR IN THE GRAPH MEANS THAT EITHER THIS NODE IS CONNECTED
C TO ITSELF OR ONE OF ITS CONNECTIONS IS NOT ACTUALLY CONNECTED
                              NERRFI = 23
                              GO TO 9900
                       END IF
C ---
C
C LOOK FOR THIS QUERY ATOM IN THE STACK.
                       MATCOM = KMATST (LFLSAV, ICOMMQ)
C
C FIND (ACCORDING TO THE PS) ITS CORRESPONDENT FROM THE STRUCTURE
                       CALL XATSN(NSERC, ISES2A, ISES2B, LSTRUC)
C
C WHAT ATOM FROM THE STRUCTURE DOES THIS PAIR OF BONDS HAVE IN COMMON?
                       IF ((ISES1A .EQ. ISES2A)
     1                    .AND. (ISES1B .NE. ISES2B)) THEN
                             ICOMMS = ISES1A
                       ELSE IF ((ISES1A .NE. ISES2A)
     1                         .AND. (ISES1B .EQ. ISES2B)) THEN
                             ICOMMS = ISES1B
                       ELSE IF ((ISES1B .EQ. ISES2A)
     1                         .AND. (ISES1A .NE. ISES2B)) THEN
                             ICOMMS = ISES1B
                       ELSE IF ((ISES1B .NE. ISES2A)
     1                         .AND. (ISES1A .EQ. ISES2B)) THEN
                             ICOMMS = ISES1A
                       ELSE
C
C SOME ERROR IN THE GRAPH MEANS THAT EITHER THIS NODE IS CONNECTED
C TO ITSELF OR ONE OF ITS CONNECTIONS IS NOT ACTUALLY CONNECTED
                           NERRFI = 24
                           GO TO 9900
                       END IF
C
                       IF (ISTORE(MATCOM-1) .NE. 0) THEN
C A CORRESPONDENT IS ALREADY IN THE STACK
C IT MUST BE THE SAME AS ICOMMS, OTHERWISE THIS ISN'T AN ISOMORPHISM
C BETWEEN THE UNDERLYING STRUCTURES
                           IF (ISTORE(MATCOM-1) .NE. ICOMMS) THEN
                               LNOISO = .TRUE.
                               RETURN
                           END IF
                       ELSE
C
C CHECK THE STACK FOR THE SAME CORRESPONDENT
                           LNOISO = LSACOR(LFLSAV, ICOMMS, MATCOM)
                           IF (LNOISO) RETURN
C STICK THE CORRESPONDENT IN THE STACK
                           ISTORE(MATCOM-1) = ICOMMS
                       END IF
C ---
C
C ARE ANY OF THIS ATOM AND ITS NEIGHBOURS UNMATCHED?  LOOK FOR THEM IN
C THE STACK, ASSUMING THE UNFILLED PARTS OF THE STACK WERE ZEROISED.
C LUNMAT IS A LOGICAL THAT IS TRUE IF ONE OR MORE OF THESE THREE ATOMS
C IS UNMATCHED
C                       LCUNMA = .FALSE.
C                       L1UNMA = .FALSE.
C                       L2UNMA = .FALSE.
C                       MATCOM = KMATST (LFLSAV, ICOMMQ)
C                       MATCO1 = KMATST (LFLSAV, ICOQ1)
C                       MATCO2 = KMATST (LFLSAV, ICOQ2)
C                       IF (ISTORE(MATCOM) .GT. 0)
C     1                    LCUNMA = (ISTORE(MATCOM-1) .EQ. 0)
C                       IF (ISTORE(MATCO1) .GT. 0)
C     1                    L1UNMA = (ISTORE(MATCO1-1) .EQ. 0)
C                       IF (ISTORE(MATCO2) .GT. 0)
C     1                    L2UNMA = (ISTORE(MATCO2-1) .EQ. 0)
C                       LUNMAT = (LCUNMA .OR. L1UNMA .OR. L2UNMA)
CC                       IF ((MATCOM .LE. 0)
CC     1                .OR. (MATCO1 .LE. 0)
CC     1                .OR. (MATCO2 .LE. 0)) THEN
CCC NERRFI = NERRFI_OFF_STACK
CC                             NERRFI = 27
CC                             GO TO 9900
CC                       END IF
CC                       LUNMAT =  ((ISTORE(MATCOM-1) .EQ. 0)
CC     1                       .OR. (ISTORE(MATCO1-1) .EQ. 0)
CC     2                       .OR. (ISTORE(MATCO2-1) .EQ. 0))
C                       IF (LUNMAT) THEN
CC
CC LOCATE THE STRUCTURE NODE CORRESPONDENTS TO THE CONNECTED NODE FROM
CC THE PS
C                            CALL XATSN(NSERC, ISES2A, ISES2B, LSTRUC)
CC
CC WHAT ATOM FROM THE STRUCTURE DOES THIS PAIR OF BONDS HAVE IN COMMON?
C                            IF ((ISES1A .EQ. ISES2A)
C     1                         .AND. (ISES1B .NE. ISES2B)) THEN
C                                  ICOMMS = ISES1A
C                                  INCOS1 = ISES1B
C                                  INCOS2 = ISES2B
C                            ELSE IF ((ISES1A .NE. ISES2A)
C     1                              .AND. (ISES1B .EQ. ISES2B)) THEN
C                                  ICOMMS = ISES1B
C                                  INCOS1 = ISES1A
C                                  INCOS2 = ISES2A
C                            ELSE IF ((ISES1B .EQ. ISES2A)
C     1                              .AND. (ISES1A .NE. ISES2B)) THEN
C                                  ICOMMS = ISES1B
C                                  INCOS1 = ISES1A
C                                  INCOS2 = ISES2B
C                            ELSE IF ((ISES1B .NE. ISES2A)
C     1                              .AND. (ISES1A .EQ. ISES2B)) THEN
C                                  ICOMMS = ISES1A
C                                  INCOS1 = ISES1B
C                                  INCOS2 = ISES2A
C                            ELSE
CC
CC SOME ERROR IN THE GRAPH MEANS THAT EITHER THIS NODE IS CONNECTED
CC TO ITSELF OR ONE OF ITS CONNECTIONS IS NOT ACTUALLY CONNECTED
C                                  NERRFI = 24
C                                  GO TO 9900
C                            END IF
CC
CC FOR ALL THE THREE ATOM CORRESPONDENCES,
CC PUT EACH IN THE STACK, COUNT IT, & CHECK IF THE STACK IS NOW FULL
C                            IF (LCUNMA) THEN
C                     WRITE (6,*) ' LFL = ', LFL
C                     WRITE (6,*)
C                                  ISTORE (MATCOM-1) = ICOMMS
C                     WRITE (6,*) ' LFL = ', LFL
C                     WRITE (6,*)
C                                  NMATCH = NMATCH + 1
C                     WRITE (6,*) ' LFL = ', LFL
C                     WRITE (6,*)
C                            END IF
C                            IF (NMATCH .GE. NACTUA) GO TO 9000
C                            IF (L1UNMA) THEN
C                                  ISTORE (MATCO1-1) = INCOS1
C                                  NMATCH = NMATCH + 1
C                            END IF
C                            IF (NMATCH .GE. NACTUA) GO TO 9000
C                            IF (L2UNMA) THEN
C                                  ISTORE (MATCO2-1) = INCOS2
C                                  NMATCH = NMATCH + 1
C                            END IF
C                            IF (NMATCH .GE. NACTUA) GO TO 9000
C                       END IF
C
C END OF LOOP OVER CONNECTIONS
8000              CONTINUE
                  END IF
C
C END OF LOOP OVER NODES
8500      CONTINUE
CC
CC IF YOU ARRIVE HERE SOMETHING MAY BE WRONG AS THE WHOLE QUERY HAS
CC BEEN CHECKED AND SOME ATOMS ARE STILL WITHOUT PARTNERS
CC             NERRFI = 25
      ELSE
             NERRFI = 17
      END IF
9000  CONTINUE
9900  CONTINUE
      RETURN
      END
CODE FOR XCRLIF
      SUBROUTINE XCRLIF
C
C MAKE ROOM FOR DETAILS OF THE ISOMORPHISMS FOUND
C THIS INFO GOES AT THE END OF THE GRAPH LISTS
C INITIALISE THE RELEVANT ENTRIES IN THE GENERAL STRUCTURE LIST
C ASSUMES THAT THE GENERAL STRUCTURE LIST IS RANKED IN ORDER OF
C DECREASING NO OF GRAPH NODES (SET UP IN XGRGEN)
\XUNITS
      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
C CALCULATE THE MAXIMUM NUMBER OF POSSIBLE ENTRIES IN THIS LIST -
C DIFFERENT IF OVERLAPPING & IF A MULTIPLE/SINGLE SEARCH IS BEING
C DONE.
C (SEE FIND.INC)
C MSTRUC + 3 CONTAINS THE ADDRESS IN ISTORE HOLDING THE ADDRESS OF THE
C            PS HOLDING THE FIRST OF THESE ISOMORPHISMS.
C MSTRUC + 4 CONTAINS THE NO. OF ISOMORPHISMS FOUND
C
C GLOBALS:
C      NTOPIS = ADDRESS OF POSITION OF NEXT ISOMORPHISM TO BE SAVED
C               INITIALISED HERE TO THE FIRST ADDRESS OF THE AREA
C               RESERVED.
C LOCALS:
C      NLISOM: NO. OF ADDRESSES THAT NEED TO BE FREED IN STORE
C      NSUPER: NO. OF NODES IN SUPERSTRUCTURE GRAPH
C
C SET THE REQUIRED SPACE IN STORE TO ZER0
      NLISOM = 0
      NSUPER = ISTORE (LSTRUC)
C
C SET THE LIMIT ON THE MAXIMUM NUMBER OF POSSIBLE ISOMORPHISMS
C      IF ((MAXISO .EQ. 0) .OR. (MAXISO.GT.NSUPER)) MAXISO  = NSUPER
      IF (MAXISO .EQ. 0) MAXISO  = NSUPER
C TEMPORARY LOGICAL VARIABLE
C LOOP OVER THE QUERY STRUCTURES
      DO 1000, MSTRUC = LSTRUC+MDSTRU,
     1                    LSTRUC+(MDSTRU*(NSTRUC-1)), MDSTRU
            NQUERY = ISTORE(MSTRUC)
            LSOVER = (ISTORE(MSTRUC+18) .EQ. 1)
            IF ( ISTORE(MSTRUC+6) .EQ. 1) THEN
C MULTIPLE OCCURRENCE POSSIBLE FOR THIS QUERY
                  IF (LSOVER) THEN
C ALLOWED TO OVERLAP WITH ITSELF
                        NLISOM = NLISOM + KNCR(NSUPER,NQUERY)
                        IF (NLISOM .GT. MAXISO) THEN
                            WRITE (NCWU, '(A,I6)')
     1         'SETTING MAXIMUM NUMBER OF ISOMORPHISMS TO:',MAXISO
                            NLISOM=MAXISO
                        END IF
                        IF (NERRFI .NE. 0) GO TO 9900
                  ELSE
                        NLISOM = NLISOM + (NSUPER/NQUERY)
                  END IF
            ELSE IF ( ISTORE(MSTRUC+6) .EQ. 2) THEN
C SINGLE OCCURRENCE OF THIS QUERY ONLY BEING SEARCHED FOR
                  NLISOM = NLISOM + 1
            ELSE
C SOME ERROR ALREADY
C NERRFI = NERRFI_ERROR_IN_ISTORE(MSTRUC+6)
                  NERRFI = 51
                  GO TO 9900
            END IF
C
C ZEROISE RELEVANT ELEMENTS OF GENERAL STRUCTURE LIST
            ISTORE (MSTRUC+3) = 0
            ISTORE (MSTRUC+4) = 0
1000  CONTINUE
C
C MAKE ROOM FOR DETAILS OF THE ISOMORPHISMS FOUND
      IF (NLISOM .GT. 0) THEN
            NTOPIS = KSTALL (NLISOM)
      ELSE
            NERRFI = 9
      END IF
9900  CONTINUE
      RETURN
      END
CODE FOR XCSET
      SUBROUTINE XCSET (IADDEN, IFLAGG)
C
C TAKES THE ENTRY IN THE SET LIST AT ADDRESS IADDEN AND ADDS A NEW ENTRY
C TO THE END OF THE LIST, CORRESPONDING TO THE FIRST SHELL CONNECTIVITY
C OF ALL THE SETS IN THIS ENTRY.  IF IFLAGG = 0 THEN CONNECTIVITY IS
C CALCULATED FOR SUPERSTRUCTURE & ALL QUERIES.  IF NOT, THEN IT IS ONLY
C CALCULATED FOR SUPERSTRUCTURE & THE CURRENT QUERY.
C THE ENTRY AT IADDEN IS FLAGGED NEGATIVE TO SAY CONNECTIVITY HAS BEEN
C APPLIED.  IF IFLAGG > 0 THEN THIS IS PASSED ON TO THE NEW ENTRY.
C
C GLOBALS:
C LSETS  = ADDRESS OF THE FIRST ENTRY IN THE SET LIST
C NSETS  = NUMBER OF ENTRIES IN THE SET LIST
C MDSETS = LENGTH OF ONE SET LIST ENTRY
C LSTRUC, ETC.
C
C LOCALS:
C MOFFSE = OFFSET FROM THE BEGINNING OF THE ENTRY OF THE CURRENT SET.
C NINTES = NUMBER OF INTEGERS REQUIRED TO STORE A SET OF THE CURRENT
C          STRUCTURE, INCLUDING THE INTEGER CONTAINING ITS CARDINALITY
C MSETS  = ADDRESS OF THE NEW ENTRY BEING CREATED
C LNODES = ADDRESS OF THE FIRST FIXED ENTRY IN THE NODE LIST
C NNODET = INITIAL NUMBER OF NODES IN THE CURRENT STRUCTURE
C MNODES = ADDRESS OF THE CURRENT NODE
C LCONNS = ADDRESS OF THE SERIAL NUMBER OF THE FIRST NODE CONNECTED TO
C          THE CURRENT NODE
C NCONNS = THE NUMBER OF NODES CONNECTED TO THIS NODE
C MCONNS = USED TO WORK THROUGH THE NODES CONNECTED TO THIS NODE
C IADDCO = USED TO POINT TO THE INTEGER CORRESPONDING TO THE PART OF
C          THE NEW SET THAT NEEDS TO BE CHANGED IF THE CURRENT NODE IS
C          NOT ALREADY HELD IN THIS SET.
C ICARDI = ADDRESS OF THE CARDINALITY OF THE NEW SET
C ISERCO = SERIAL NUMBER OF THE CURRENT NODE
C
      LOGICAL LPRESE
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
C SET UP THE NEW SET AT THE END OF THE SET LIST
      MSETS = LSETS + (NSETS*MDSETS)
      NFL   = KCHNFL (MDSETS)
C
C TRANSFER THE 'USE' FLAG
      ISTORE ( MSETS ) = IFLAGG
      DO 500, I = MSETS + 1, MSETS + MDSETS - 1
            ISTORE (I) = 0
500   CONTINUE
      NSETS = NSETS + 1
C
C THE FIRST SET TO CONSIDER IS AT THE BEGINNING OF THE ENTRY
      MOFFSE = 1
C
C DEFINITELY APPLY CONNECTIVITY TO THE FIRST STRUCTURE (THE
C SUPERSTRUCTURE)
      LNODES = ISTORE (LSTRUC+2)
      NNODET = ISTORE (LSTRUC)
      NINTES = ISTORE (LSTRUC+15)
C
C TEST EACH NODE FOR PRESENCE IN THE CURRENT SET
      DO 2000, I = 1, NNODET
            IF ( LPRESE (I, IADDEN, MOFFSE)) THEN
C
C DETERMINE THE ADDRESS OF THE FIRST CONNECTED NODE AND THE NUMBER OF
C CONNECTED NODES.
                  MNODES = LNODES + ((I-1)*MDNODE)
                  LCONNS = ISTORE (MNODES    )
                  NCONNS = ISTORE (MNODES + 1)
C
C LOOP OVER THE CONNECTED NODES
                  DO 1000, MCONNS = LCONNS,
     1                LCONNS + (NCONNS - 1)*3, 3
C
C SAVE THEM IN THE NEW ENTRY BY .OR.ING THEM WITH THE APPROPRIATE POWER
C OF TWO, SO LONG AS THEY DO NOT APPEAR ALREADY IN THE SET BEING
C CONSTRUCTED (WOULD THEN MISCALCULATE CARDINALITY).
                        ISERCO = ISTORE (MCONNS)
                        IF (.NOT. LPRESE (ISERCO, MSETS, MOFFSE)) THEN
                             ICARDI = MSETS  + MOFFSE
                             IADDCO = ICARDI + ((ISERCO-1)/L1INT) + 1
                             NBIT   = MOD ((ISERCO-1), L1INT)
                             ISTORE(IADDCO)
     1                               = KOR(ISTORE(IADDCO),N2POWS(NBIT))
C
C INCREMENT THE CARDINALITY
                             ISTORE (ICARDI) = ISTORE (ICARDI) + 1
                        END IF
1000              CONTINUE
                  END IF
2000        CONTINUE
C
C IF THE SET AT IADDEN WAS GENERATED FROM A COMPLEMENT, ONLY NEED TO
C APPLY CONNECTIVITY TO THE CURRENT STRUCTURE SET.  OTHERWISE, APPLY
C IT TO ALL THE STRUCTURE SETS.
      IF (IFLAGG .EQ. 0) THEN
C
C CHANGE THE ENTRY AT IADDEN TO SAY THAT CONNECTIVITY HAS BEEN APPLIED
            ISTORE (IADDEN) = - 1
C
C APPLY CONNECTIVITY TO _ALL_ THE REMAINING SETS
            DO 5000, MSTRUC = LSTRUC + MDSTRU,
     1                        LSTRUC + (NSTRUC-1)*MDSTRU, MDSTRU
                  LNODES = ISTORE (MSTRUC+2)
                  NNODET = ISTORE (MSTRUC  )
                  NINTES = ISTORE (MSTRUC+15)
C
C TEST EACH NODE FOR PRESENCE IN THE CURRENT SET
                  DO 4000, I = 1, NNODET
                        IF ( LPRESE (I, IADDEN, MOFFSE)) THEN
C
C DETERMINE THE ADDRESS OF THE FIRST CONNECTED NODE AND THE NUMBER OF
C CONNECTED NODES.
                              MNODES = LNODES + ((I-1)*MDNODE)
                              LCONNS = ISTORE (MNODES    )
                              NCONNS = ISTORE (MNODES + 1)
C
C LOOP OVER THE CONNECTED NODES
                              DO 3000, MCONNS = LCONNS,
     1                                   LCONNS + (NCONNS - 1)*3, 3
C
C SAVE THEM IN THE NEW ENTRY BY .OR.ING THEM WITH THE APPROPRIATE POWER
C OF TWO, SO LONG AS THEY DO NOT APPEAR ALREADY IN THE SET BEING
C CONSTRUCTED (WOULD THEN MISCALCULATE CARDINALITY).
                              ISERCO = ISTORE (MCONNS)
                              IF (.NOT.
     1                             LPRESE (ISERCO, MSETS, MOFFSE)) THEN
                                   ICARDI = MSETS  + MOFFSE
                                   IADDCO = ICARDI+((ISERCO-1)/L1INT)+1
                                   NBIT   = MOD ((ISERCO-1), L1INT)
                                   ISTORE(IADDCO)
     1                                =KOR(ISTORE(IADDCO),N2POWS(NBIT))
C
C INCREMENT THE CARDINALITY
                                   ISTORE (ICARDI) = ISTORE (ICARDI)+1
                              END IF
3000                          CONTINUE
                        END IF
4000              CONTINUE
                 MOFFSE = MOFFSE + NINTES
5000        CONTINUE
C
      ELSE
C
C CHANGE THE ENTRY AT IADDEN TO SAY THAT CONNECTIVITY HAS BEEN APPLIED
            ISTORE (IADDEN) = - IFLAGG
C
C APPLY CONNECTIVITY ONLY TO THE SET CORRESPONDING TO THIS STRUCTURE
            MSTRUC = LSTRUC + (NSTRUQ-1)*MDSTRU
            LNODES = ISTORE (MSTRUC+2)
C
C TEST EACH NODE FOR PRESENCE IN THE CURRENT SET
            DO 7000, I = 1, NNODEQ
                  IF ( LPRESE (I, IADDEN, MOFFSQ)) THEN
C
C DETERMINE THE ADDRESS OF THE FIRST CONNECTED NODE AND THE NUMBER OF
C CONNECTED NODES.
                        MNODES = LNODES + ((I-1)*MDNODE)
                        LCONNS = ISTORE (MNODES    )
                        NCONNS = ISTORE (MNODES + 1)
C
C LOOP OVER THE CONNECTED NODES
                        DO 6000, MCONNS = LCONNS,
     1                          LCONNS + (NCONNS - 1)*3, 3
C
C SAVE THEM IN THE NEW ENTRY BY .OR.ING THEM WITH THE APPROPRIATE POWER
C OF TWO, SO LONG AS THEY DO NOT APPEAR ALREADY IN THE SET BEING
C CONSTRUCTED (WOULD THEN MISCALCULATE CARDINALITY).
                              ISERCO = ISTORE (MCONNS)
                              IF (.NOT.
     1                             LPRESE (ISERCO, MSETS, MOFFSQ)) THEN
                                   ICARDI = MSETS  + MOFFSQ
                                   IADDCO = ICARDI+((ISERCO-1)/L1INT)+1
                                   NBIT   = MOD ((ISERCO-1), L1INT)
                                   ISTORE(IADDCO)
     1                                =KOR(ISTORE(IADDCO),N2POWS(NBIT))
C
C INCREMENT THE CARDINALITY
                                   ISTORE (ICARDI) = ISTORE (ICARDI)+1
                              END IF
6000                    CONTINUE
                  END IF
7000        CONTINUE
      END IF
C
C CHECK THE NEW SET FOR USEFULNESS
            CALL XCHECK
      RETURN
      END
CODE FOR XDEGS
       SUBROUTINE XDEGS
C
C GENERATE SETS ACCORDING TO THE DEGREE OF EACH NODE - I.E., THE NUMBER
C OF CONNECTED NODES.
C LOOP OVER ALL THE STRUCTURES
C      FOR EACH STRUCTURE:
C            LOOP OVER ALL THE NODES
C           FOR EACH NODE:
C                  DETERMINE DEGREE
C                  IF (DEGREE IS HIGHEST YET FOUND) THEN
C                  ZEROISE THE UNUSED SETS UP TO THE ONE THAT NOW NEEDS
C                  TO BE USED
C                  END IF
C                  SET APPROPRIATE BIT IN APPROPRIATE SET
C
C GLOBAL VARIABLES:
C LSETS  = FIRST ADDRESS OF SET LIST
C NSETS  = NUMBER OF SETS
C MDSETS = TOTAL LENGTH OF A SET ENTRY (FOR ALL STRUCTURES)
C
C LSTRUC = ADDRESS OF FIRST ENTRY IN GENERAL STRUCTURE LIST
C NSTRUC = NUMBER OF STRUCTURES FOR WHICH SETS ARE BEING GENERATED
C MDSTRU = LENGTH OF AN ENTRY IN GENERAL STRUCTURE LIST
C
C LOCAL VARIABLES:
C NNODES = NUMBER OF NODES IN THE GRAPH CORRESPONDING TO THE CURRENT
C          STRUCTURE
C LNODES = START OF THE NODE LIST OF THE CURRENT STRUCTURE
C INODES = SERIAL NUMBER OF THE CURRENT NODE
C
C NDEG   = DEGREE OF THIS NODE
C NDEMAX = HIGHEST DEGREE YET FOUND IN THE NODES OF ALL STRUCTURES
C NADDCH = STORE OF THE ADDRESS OF VARIOUS SET-HOLDING INTEGERS
C NBIT   = POWER OF 2 TO ADD TO A PARTICULAR INTEGER TO SET A BIT
C          !!N.B.!! STARTS AT ZERO, GOES UP TO 30 !!!
C MOFFSE = OFFSET FROM THE START OF ANY ENTRY IN THE SET LIST FOR SETS
C          OF THE NEXT STRUCTURE
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
      MOFFSE = 1
      NDEMAX = -1
C
C LOOP OVER ALL THE STRUCTURES
      DO 5000, MSTRUC = LSTRUC, LSTRUC+(MDSTRU*(NSTRUC-1)), MDSTRU
      LNODES = ISTORE (MSTRUC+2)
      NNODES = ISTORE (MSTRUC  )
C
C LOOP OVER ALL THE NODES FOR THIS STRUCTURE
            DO 4000, MNODES = LNODES, LNODES+(MDNODE*(NNODES-1)), MDNODE
            INODES = ((MNODES - LNODES)/MDNODE) + 1
C
C DETERMINE DEGREE
            NDEG   = ISTORE (MNODES+1)
            NADDCH = LSETS + (MDSETS*(NSETS-NDEMAX+NDEG-1)) + MOFFSE
C
            IF (NDEG .GT. NDEMAX) THEN
C
                  INCSET = (NDEG - NDEMAX)*MDSETS
                  NFL = KCHNFL (INCSET)
C
C ZEROISE THE UNUSED SETS UP TO THE ONE THAT NOW NEEDS TO BE USED
                  DO 3500, IEMPTY = LSETS+MDSETS*NSETS,
     1                              LSETS+MDSETS*(NSETS+NDEG-NDEMAX) - 1
                      ISTORE (IEMPTY) = 0
3500  CONTINUE
C
                  NSETS  = NSETS + NDEG - NDEMAX
                  ISETS  = NSETS
                  NDEMAX = NDEG
            END IF
C
C FOR THIS SET AND ALL THOSE BEFORE IT:
            NBIT   = MOD ( (INODES-1), L1INT)
C
C            DO 3750, IADDCH = NADDCH-(MDSETS*(NDEG-1)), NADDCH, MDSETS
            DO 3750, IADDCH = NADDCH-(MDSETS*NDEG), NADDCH, MDSETS
C
C INCREMENT THE CARDINALITY
                  ISTORE (IADDCH) = ISTORE (IADDCH) + 1
C
C SET THE BIT FOR THE CURRENT STRUCTURE & THE CURRENT NODE
                  JADDCH = IADDCH + (INODES-1)/L1INT + 1
                  ISTORE (JADDCH) = ISTORE (JADDCH) + N2POWS(NBIT)
3750  CONTINUE
4000  CONTINUE
      MOFFSE = MOFFSE + ISTORE (MSTRUC+15)
5000  CONTINUE
      RETURN
      END
CODE FOR XDELNO
      SUBROUTINE XDELNO ( NNODE, MNEW, MOFFSE)
C
C DELETES THE NNODETH NODE FROM THE SET AT MNEW AND OFFSET MOFFSE
C ONLY DOES THE DELETION IF THE NODE IS THERE.
C
C MOFFSE = OFFSET FROM THE BEGINNING OF ANY SET ENTRY OF THE SET
C          CORRESPONDING TO THE CURRENT STRUCTURE
C
C LOCALS:
C
C IADDIN = ADDRESS IN ISTORE OF THE INTEGER FROM THE SET AT MNEW HOLDING
C          THE BIT CORRESPONDING TO THE NNODETH NODE.
C NCOMPS = INTEGER FROM THE SET AT MNEW HOLDING THE BIT CORRESPONDING TO
C          THE NNODETH NODE.
C NCOMPN = AN INTEGER WITH THE _ONLY_ BIT SET BEING THAT CORRESPONDING
C          TO THE NNODETH NODE.
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      LOGICAL LPRESE
C
      IF (LPRESE(NNODE, MNEW, MOFFSE)) THEN
            IADDIN = MNEW + MOFFSE + ((NNODE-1)/ L1INT) + 1
            NCOMPS = ISTORE (IADDIN)
            NCOMPN = MOD ((NNODE-1), L1INT)
            NCOMPN = N2POWS(NCOMPN)
            ISTORE(IADDIN) = KXOR (NCOMPN, NCOMPS)
C
C CARDINALITY
            ISTORE(MNEW+MOFFSE) = ISTORE(MNEW+MOFFSE) - 1
      END IF
      RETURN
      END
CODE FOR XDENAM
      SUBROUTINE XDENAM(MSTRUC, CDEFAU, LDEFAU, CFIN, LCFIN,IAPPO)
C
C CREATE A DEFAULT QUERY OUTPUT FILENAME FOR STRUCTURE CORRESPONDING TO
C ENTRY MSTRUC
C RETURNS CDEFAU(1:LDEFAU)
C CFIN, LCFIN = INPUT FILENAME, USED TO CREATE DEFAULT IF NONE IS GIVEN
C IAPPO = DEFAULT APPEND/OVERWRITE STATUS FOR THE OUTPUT FROM THIS QUERY
C THIS IS A SECOND WAY OF SETTING MSTRUC+7, & HAS PRIORITY
C
      CHARACTER *(*) CDEFAU, CFIN
      CHARACTER *8 CFMTXP
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      CDEFAU = ' '
      LDEFAU = 0
C
C FIRST CHECK THROUGH THE OUTFILE STACK FOR A DEFAULT NAME
C THIS IS AN OUTFILE DIRECTIVE WITH A VALID QUERY BUT ZERO IN THE
C OCCURRENCE AND OPTION SLOTS
      LOUTF  = ISTORE (MSTRUC+8)
      NOUTF  = ISTORE (MSTRUC+9)
C
C DEFAULT APPEND/OVERWRITE ACTION BASED ON COMMAND LINE
      IAPPO  = ISTORE (MSTRUC+7)
      MOUTF  = LOUTF
      DO 1000, MTMP = 1, NOUTF
          IF ((ISTORE(MOUTF) .EQ. 0).AND.(ISTORE(MOUTF+1) .EQ. 0))THEN
C
C A NEW DEFAULT FOR THIS QUERY
              LDEFAU = ISTORE (MOUTF+3)
              WRITE (CFMTXP, '(2H( , I2, 3HA1))') LDEFAU
                  WRITE (CDEFAU(1:LDEFAU), CFMTXP)
     1                  (ISTORE(J),J=MOUTF+4,MOUTF+3+LDEFAU)
              IAPPO = ISTORE(MOUTF+2)
          END IF
          MOUTF   = MOUTF + ISTORE (MOUTF+3) + 4
1000  CONTINUE
      IF (LDEFAU .EQ. 0) THEN
C
C NOT IN LIST: CREATE A DEFAULT NAME
          ITOPIN = ISTORE (MSTRUC+11)
          LCFIN  = ISTORE (ITOPIN)
          IF (LCFIN .GT. LEN(CFIN)) THEN
                NERRFI = 47
                GO TO 9900
          END IF
          WRITE (CFMTXP, '(2H( , I2, 3HA1))') LCFIN
          WRITE (CFIN(1:LCFIN), CFMTXP) (ISTORE(ITOPIN+J), J=1, LCFIN)
          J = LCFIN + 1
          CDEFAU = CFIN
4000      CONTINUE
          J = J - 1
          IF ((CFIN(J:J).NE.'.').AND.(J.GT.1)) GO TO 4000
          IF (J.EQ.1) THEN
              J = LCFIN
              CDEFAU = CFIN(1:J)//'.OUT'
              LDEFAU = J+4
          ELSE
C
C NO PERIOD IN FILENAME
              CDEFAU = CFIN(1:J)//'OUT'
              LDEFAU = J+3
          END IF
      END IF
9900  CONTINUE
      RETURN
      END
CODE FOR XEDEGS
      SUBROUTINE XEDEGS
C
C GENERATE SETS ACCORDING TO THE EXACT NUMBER OF CONNECTIONS, IF
C SPECIFIED.
C FOR EACH BOND TYPE INVOLVING AT LEAST ONE EXACT CONNECTED ATOM,
C CREATE A STACK ENTRY:
C ----- HIGH ADDRESSES:    (LFLSAV)
C SPECIES OF FIRST ATOM
C NO. OF EXACT CONNECTIONS TO FIRST ATOM (ZERO IF NOT EXACT)
C SPECIES OF SECOND ATOM
C NO. OF EXACT CONNECTIONS TO SECOND ATOM (ZERO IF NOT EXACT)
C -----  LOW ADDRESSES:    (LFL)
C FIRST ATOM ALWAYS HAS THE HIGHER NUMBER OF CONNECTIONS

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      LOGICAL LFOUND
C
C DROP OUT OF THIS ROUTINE IF NONE OF THE FILES SPECIFIED AN EXACT
C ATOM NCA
      IF (LEXACT) THEN
      MTMPBO = 4
      LFLSAV = LFL
C SAVE THE CURRENT NFL WHICH WILL BE WHERE THE EXACT SETS WILL START
      LBOSET = NFL
      MOFFSE = 1
      IF (INTYPE .EQ. 1) THEN
C
C LOOP BACKWARDS THROUGH THE STRUCTURES.  SUPERSTRUCTURE IS
C PROBABLY FROM LIST 5 OR 10, HENCE CAN'T DEFINE EXACT NCA.
C CAN, HOWEVER, DEFINE EXACT NCA IF QUERY IS FROM A FILE
C MUST BE FROM CSD FILE
          MOFFSE = MDSETS
          DO 500, MSTRUC=LSTRUC+(NSTRUC-1)*MDSTRU,LSTRUC,-MDSTRU
             NINTE  = ISTORE(MSTRUC+15)
             MOFFSE = MOFFSE-NINTE
             LNODES = ISTORE(MSTRUC+2)
             NNODES = ISTORE(MSTRUC)
             IF (ISTORE(MSTRUC+10) .EQ. 3) THEN
C FROM FILE NOT L5, MAY HAVE EXACT ATOMS
                 DO 400, MNODES=LNODES,
     1                          LNODES+(NNODES-1)*MDNODE, MDNODE
                     NCONNS = ISTORE(MNODES+1)
                     MINFO = ISTORE(MNODES+2)
                     MNODSE = 1+((MNODES-LNODES)/MDNODE)
                     IF (ISTORE(MINFO+3) .EQ. 1) THEN
C THIS IS AN EXACT ATOM
C SEARCH DOWN THE STACK TO FIND THE SET CORRESPONDING TO THIS E NCA
                         MLAT = LFLSAV + 2
300                      CONTINUE
                         MLAT = MLAT - 2
                         IF (MLAT .GT. LFL) THEN
                             IF (ISTORE(MLAT) .EQ. NCONNS) THEN
C FOUND IT - ADD CURRENT ONE TO THE ENTRY
                                 MTMPSE = ISTORE(MLAT-1)
                                 ISTORE(MTMPSE+MOFFSE)
     1                                      =ISTORE(MTMPSE+MOFFSE)+1
                                 NCOMPN=MOD((MNODSE-1),L1INT)
                                 NCOMPN=N2POWS(NCOMPN)
                              ITOSET = MTMPSE+MOFFSE+(MNODSE-1)/L1INT+1
                              ISTORE(ITOSET)=KOR(NCOMPN,ISTORE(ITOSET))
                                 GO TO 390
                             ELSE
                                 GO TO 300
                             END IF
                         END IF
C ARRIVED HERE => NEED TO ADD A NEW SET AND STACK ENTRY
                         MLAT = KCHLFL(2) + 1
                         MTMPSE = KSTALL(MDSETS)
                         ISTORE(MLAT) = NCONNS
                         ISTORE(MLAT-1) = MTMPSE
C
                         DO 380,MTMP =1, NINTE
                             ISTORE(MTMPSE+MTMP) = 0
380                      CONTINUE
C
                         ISTORE(MTMPSE+MOFFSE)
     1                             = ISTORE(MTMPSE+MOFFSE)+1
                         NCOMPN=MOD((MNODSE-1),L1INT)
                         NCOMPN=N2POWS(NCOMPN)
                         ITOSET = MTMPSE+MOFFSE+(MNODSE-1)/L1INT+1
                         ISTORE(ITOSET)=KOR(NCOMPN,ISTORE(ITOSET))
                         NSETS = NSETS + 1
390                      CONTINUE
                     END IF
400              CONTINUE
             ELSE IF (ISTORE(MSTRUC+10) .EQ. 1) THEN
C
C LIST 5 TYPE INFO
C NNODSU USED IN SETFEL
                 NNODSU = ISTORE(MSTRUC)
                 DO 480, MNODES=LNODES,LNODES+(NNODES-1)*MDNODE,MDNODE
                     NCONNS = ISTORE(MNODES+1)
C
C SEARCH FOR THIS NUMBER OF CONNECTIONS IN THE STACK
                     MNODSE = 1+((MNODES-LNODES)/MDNODE)
                     MLAT = LFLSAV+2
420                  CONTINUE
                     MLAT = MLAT - 2
                     IF (MLAT .EQ. LFL) THEN
                         GO TO 470
                     ELSE
                         IF (ISTORE(MLAT) .EQ. NCONNS) THEN
                             MTMPSE = ISTORE(MLAT-1)
C
C SET THE STRUCTURE SET ELEMENT FOR THIS NODE
                             ISTORE(MTMPSE+1) = ISTORE(MTMPSE+1)+1
                             CALL SETFEL(MNODSE,1,
     1                              (MTMPSE+MOFFSE))
                         ELSE
                             GO TO 420
                         END IF
                     END IF
470                  CONTINUE
480              CONTINUE
             END IF
500       CONTINUE
C
C NO NEW SETS RIGHT NOW
      ELSE IF (INTYPE .EQ. 2) THEN
C
C NERRFI = NERRFI_CAN'T_DO_YET
            NERRFI = 96
            GO TO 9900
C LOOP OVER ALL THE STRUCTURES, INCLUDING THE FIRST
C            DO 5000, MSTRUC = LSTRUC,
C     1                          LSTRUC+(NSTRUC-1)*MDSTRU, MDSTRU
C
C CAN AN EXACT NUMBER OF CONNECTIONS TO THIS ATOM BE SPECIFIED? -
C IE IS THIS ATOM INFO FROM A CSD-TYPE FILE?
C            IF (ISTORE(MSTRUC+10) .EQ. 3) THEN
C LOOP OVER ALL THE NODES, GETTING THE ATOM INFO ABOUT EACH ONE
C SO THAT THE SPECIES AND EXACT NUMBER OF CONNECTIONS CAN BE USED
C TO DEFINE NEW SETS
C                  LNODES = ISTORE (MSTRUC+2)
C                  NNODES = ISTORE (MSTRUC  )
C                  LATS   = ISTORE (MSTRUC+13)
C                  NATS   = ISTORE (MSTRUC+12)
C                  MDATS  = ISTORE (MSTRUC+14)
C                  DO 4000, MNODES=LNODES,
C     1                     LNODES+(NNODES-1)*MDNODE, MDNODE
C                        INODES = ((MNODES-LNODES)/MDNODE)+1
C                        NBIT   = MOD ((INODES-1),L1INT)
C                        MOFFBI = (INODES-1)/L1INT
C                        LINFO = ISTORE(MNODES+2)
C                        ISER1 = ISTORE (LINFO)
C                        ISER2 = ISTORE (LINFO+1)
C                        MAT1 = LATS + (ISER1-1)*MDATS
C                        MAT2 = LATS + (ISER2-1)*MDATS
C                        IF1  = ISTORE(MAT1+3)
C                        IF2  = ISTORE(MAT2+3)
CC
CC LOOK FOR THIS BOND TYPE IN THE STACK IF ONE OR BOTH OF THE
CC ATOMS HAS AN EXACT NUMBER OF CONNECTIONS SPECIFIED
C                        IF ((IF1 .GT. 0) .AND. (IF2 .GT. 0)) THEN
CC ASSIGN THE EXACT NUMBER OF CONNECTIONS, NEC1 = HIGHER
C                               IF (ISTORE(MAT1+2) .GT.
C     1                             ISTORE(MAT2+2)) THEN
C                                     NEC1 = ISTORE (MAT1+2)
C                                     ISP1 = ISTORE (MAT1)
C                                     NEC2 = ISTORE (MAT2+2)
C                                     ISP2 = ISTORE (MAT2)
C                               ELSE
C                                     NEC1 = ISTORE (MAT2+2)
C                                     ISP1 = ISTORE (MAT2)
C                                     NEC2 = ISTORE (MAT1+2)
C                                     ISP2 = ISTORE (MAT1)
C                               END IF
C                        ELSE IF ((IF1.GT.0) .AND. (IF2.EQ.0)) THEN
C                               NEC1   = ISTORE (MAT1+2)
C                               ISP1   = ISTORE (MAT1)
C                               NEC2   = 0
C                               ISP2   = 0
C                        ELSE IF ((IF1.EQ.0) .AND. (IF2.GT.0)) THEN
C                               NEC1   = ISTORE (MAT2+2)
C                               ISP1   = ISTORE (MAT2)
C                               NEC2   = 0
C                               ISP2   = 0
C                        ELSE
CC
CC NEITHER ATOM HAS AN EXACT NUMBER OF CONNECTIONS SPECIFIED
CC HOP OVER THE SEARCH THROUGH THE STACK
C                              GO TO 3000
C                        END IF
CC SEARCH THROUGH THE STACK
CC ----- HIGH ADDRESSES:    (LFLSAV)
CC SPECIES OF FIRST ATOM
CC NO. OF EXACT CONNECTIONS TO FIRST ATOM (ZERO IF NOT EXACT)
CC SPECIES OF SECOND ATOM
CC NO. OF EXACT CONNECTIONS TO SECOND ATOM (ZERO IF NOT EXACT)
CC ----  LOW ADDRESSES: (LFL)
C                        LFOUND = .FALSE.
C                        DO 1000, MST = LFLSAV, LFL+MTMPBO,-MTMPBO
C                              IF (NEC2 .EQ. 0) THEN
CC COMPARE EVERY ATOM OF EVERY ENTRY
C                                    IF ((ISTORE(MST  ).EQ.ISP1)
C     1                             .AND.(ISTORE(MST-1).EQ.NEC1))THEN
C                                          IF (ISTORE(MST-3).EQ.0)THEN
CC THIS IS THE BOND ITSELF
C                                          IF(.NOT.LFOUND)LFOUND=.TRUE.
C                                          END IF
CC INCLUDE THIS NODE IN THE SET CORRESPONDING TO THIS STACK ENTRY
C                                          MCH = LBOSET+MOFFSE+ MDSETS*
C     1                                           ((LFLSAV-MST)/MTMPBO)
CC CARDINALITY
C                                          ISTORE(MCH) = ISTORE(MCH)+1
CC BITS
C                                          MCH=MCH+MOFFBI+1
C                                          ISTORE(MCH) = ISTORE(MCH)
C     1                                                + N2POWS(NBIT)
C                                    ELSE IF ((ISTORE(MST-2) .EQ. ISP1)
C     1                             .AND.(ISTORE(MST-3).EQ.NEC1)) THEN
CC INCLUDE THIS NODE IN THE SET CORRESPONDING TO THIS STACK ENTRY
C                                          MSET = LBOSET + MDSETS*
C     1                                           ((LFLSAV-MST)/MTMPBO)
CC CARDINALITY
C                                          ISTORE(MCH) = ISTORE(MCH)+1
CC BITS
C                                          MCH=MCH+MOFFBI+1
C                                          ISTORE(MCH) = ISTORE(MCH)
C     1                                                + N2POWS(NBIT)
C                                    END IF
C                              ELSE
CC BOTH ATOMS HAVE AN EXACT NUMBER OF CONNECTIONS SPECIFIED
C                                    IF(((ISTORE(MST).EQ.ISP1)
C     1                             .AND.(ISTORE(MST-1).EQ.NEC1)
C     2                             .AND.(ISTORE(MST-2).EQ.ISP2)
C     3                             .AND.(ISTORE(MST-3).EQ.NEC2))
C     4                             .OR.((ISTORE(MST).EQ.ISP2)
C     5                             .AND.(ISTORE(MST-1).EQ.NEC2)
C     6                             .AND.(ISTORE(MST-2).EQ.ISP1)
C     7                             .AND.(ISTORE(MST-3).EQ.NEC1)))
CC     8                             .OR.((ISTORE(MST).EQ.ISP1)
CC     9                             .AND.(ISTORE(MST-1).EQ.NEC1)
CC     1                             .AND.(ISTORE(MST-2).EQ.0)
CC     2                             .AND.(ISTORE(MST-3).EQ.0)))
C     3                              THEN
C THIS IS A MATCH
C                                          IF(.NOT.LFOUND)LFOUND=.TRUE.
CC INCLUDE THIS NODE IN THE SET CORRESPONDING TO THIS STACK ENTRY
C                                          MCH = LBOSET+MOFFSE+ MDSETS*
C     1                                           ((LFLSAV-MST)/MTMPBO)
CC CARDINALITY
C                                          ISTORE(MCH) = ISTORE(MCH)+1
CC BITS
C                                          MCH=MCH+MOFFBI+1
C                                          ISTORE(MCH) = ISTORE(MCH)
C     1                                                + N2POWS(NBIT)
C                                    END IF
C                              END IF
C1000                    CONTINUE
CC IF NOT, CREATE A NEW SET
C                  IF (.NOT. LFOUND) THEN
C                       LFL = LFL - MTMPBO
C                       ISTORE (LFL+MTMPBO  ) = ISP1
C                       ISTORE (LFL+MTMPBO-1) = NEC1
C                       ISTORE (LFL+MTMPBO-2) = ISP2
C                       ISTORE (LFL+MTMPBO-3) = NEC2
CC                  IF (.NOT. LFOUND) THEN
C                        NSETS = NSETS + 1
C                        MCH   = KSTALL(MDSETS)
CC ZEROISE
C                        DO 2000,MZERO=MCH,NFL-1
C                              ISTORE(MZERO)=0
C2000                    CONTINUE
C                        MCH  = MCH + MOFFSE
C                        ISTORE(MCH) = 1
C                        MCH  = MCH + MOFFBI + 1
C                        ISTORE(MCH) = ISTORE(MCH) + N2POWS(NBIT)
C                  END IF
C3000  CONTINUE
C4000              CONTINUE
C            END IF
C            MOFFSE = MOFFSE + ISTORE (MSTRUC+15)
C5000      CONTINUE
CC
CC IF THE FIRST STRUCTURE WAS A LIST 5/10 TYPE, NONE OF ITS NODES WILL
CC BE ASSIGNED TO SETS YET.  WORK OUT ALL THE NODE TYPES &
CC PUT THEM IN THE NECESSARY SETS
C            IF ((ISTORE (LSTRUC+10) .EQ. 1)
C     1     .OR. (ISTORE (LSTRUC+10) .EQ. 2)
C     2     .OR. (ISTORE (LSTRUC+10) .EQ. 4)
C     3     .OR. (ISTORE (LSTRUC+10) .EQ. 5)) THEN
C               LNODES = ISTORE (LSTRUC+2)
C               NNODES = ISTORE (LSTRUC  )
C               LATS   = ISTORE (LSTRUC+13)
C               NATS   = ISTORE (LSTRUC+12)
C               MDATS  = ISTORE (LSTRUC+14)
C               DO 8000, MNODES=LNODES,LNODES+(NNODES-1)*MDNODE,MDNODE
C                     INODES = ((MNODES-LNODES)/MDNODE)+1
C                     NBIT   = MOD ((INODES-1),L1INT)
C                     MOFFBI = (INODES-1)/L1INT
CC SERIAL NUMBERS OF THE ATOMS IN THE BOND
C                     LINFO   = ISTORE (MNODES+2)
C                     ISER1   = ISTORE (LINFO  )
C                     ISER2   = ISTORE (LINFO+1)
C                     MAT1 = LATS + (ISER1-1)*MDATS
C                     MAT2 = LATS + (ISER2-1)*MDATS
CC GET THE SPECIES
C                     ISP1 = ISTORE (MAT1)
C                     ISP2 = ISTORE (MAT2)
CC GET THE NUMBER OF CONNECTIONS OF EACH ATOM (= NUMBER OF OTHER NODES
CC FEATURING THIS ATOM)
C                     IC1     = 0
C                     IC2     = 0
C                     DO 6000, MMNODE=LNODES,LNODES+(NNODES-1)*MDNODE,
C     1                                     MDNODE
C                           LINFO  = ISTORE (MMNODE+2)
C                           ISER11 = ISTORE (LINFO)
C                           ISER12 = ISTORE (LINFO+1)
C                           IF ((ISER11 .EQ. ISER1) .OR.
C     1                         (ISER12 .EQ. ISER1)) THEN
C                                 IC1 = IC1 + 1
C                           END IF
C                           IF ((ISER11 .EQ. ISER2) .OR.
C     1                         (ISER12 .EQ. ISER2)) THEN
C                                 IC2 = IC2 + 1
C                           END IF
C6000                 CONTINUE
C                     IF (IC2 .GT. IC1) THEN
CC SWAP ROUND SO THAT HIGHEST IS FIRST, AS IN THE STACK
C                           ICTMP  = IC1
C                           ISPTMP = ISP1
C                           IC1    = IC2
C                           ISP1   = ISP2
C                           IC2    = ICTMP
C                           ISP2   = ISPTMP
C                     END IF
CC NOW SEARCH DOWN THE STACK FOR BONDS LIKE THIS ONE (MATCHING ACTUAL
CC NUMBER OF CONNECTIONS IN THE STRUCTURE WITH EXACT NUMBER OF CONNECTIO
CC IN THE QUERY
CC ----- HIGH ADDRESSES:    (LFLSAV)
CC SPECIES OF FIRST ATOM
CC NO. OF EXACT CONNECTIONS TO FIRST ATOM (ZERO IF NOT EXACT)
CC SPECIES OF SECOND ATOM
CC NO. OF EXACT CONNECTIONS TO SECOND ATOM (ZERO IF NOT EXACT)
CC ----  LOW ADDRESSES: (LFL)
C                     DO 7000, MST = LFLSAV, LFL+MTMPBO,-MTMPBO
C                            IF (((ISTORE(MST  ) .EQ. ISP1)
C     1                     .AND. (ISTORE(MST-1) .EQ.  IC1)
C     2                     .AND. (ISTORE(MST-2) .EQ. ISP2)
C     3                     .AND. (ISTORE(MST-3) .EQ.  IC2))
C     4                     .OR. ((ISTORE(MST  ) .EQ. ISP1)
C     5                     .AND. (ISTORE(MST-1) .EQ.  IC1)
C     6                     .AND. (ISTORE(MST-2) .EQ.    0)
C     7                     .AND. (ISTORE(MST-3) .EQ.    0))
C     8                     .OR. ((ISTORE(MST  ) .EQ. ISP2)
C     9                     .AND. (ISTORE(MST-1) .EQ.  IC2)
C     1                     .AND. (ISTORE(MST-2) .EQ.    0)
C     2                     .AND. (ISTORE(MST-3) .EQ.    0))) THEN
CC STICK THE CURRENT STRUCTURE NODE IN THIS SIDE OF THE RELEVANT SET
C                                  MSET = LBOSET + MDSETS*
C     1                                   ((LFLSAV-MST)/MTMPBO)
CC CARDINALITY
C                           ISTORE(MSET+1) = ISTORE(MSET+1)+1
C                                  MCH  = MSET + MOFFBI + 2
C                           ISTORE(MCH) = ISTORE(MCH) + N2POWS(NBIT)
C                            END IF
C7000                 CONTINUE
C8000           CONTINUE
C            END IF
      ELSE
C NERRFI = NERRFI_BAD_INTYPE
            NERRFI = 22
      END IF
9900  CONTINUE
      LFL   = LFLSAV
C
C END OF THE 'ANY EXACT' IF
      END IF
      RETURN
      END
CODE FOR XFBTOC
      SUBROUTINE XFBTOC (LNODES, NNODES)
C
C DJK
C FROM THE FIXED PART OF A _BOND_ GRAPH LIST, CALCULATES THE NECESSARY
C FLEXIBLE LENGTH PART CONTAINING CONNECTIVITY, AND ALTERS THE
C NECESSARY ELEMENTS OF THE FIXED ENTRY.
C ASSUMES THAT ISTORE(MNODES+2) AND ISTORE(MNODES+2)+1 HOLD POINTERS
C THAT DESCRIBE THE SERIAL NUMBERS OF THE ACTUAL STRUCTURES.  EG, FOR
C LIST 5, THEY CONTAIN THE SERIAL NUMBERS.
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
      DO 5000, MNODES = LNODES, LNODES + (NNODES-1)*MDNODE, MDNODE
C
C SAVE THE ADDRESS OF THE START OF THE CONNECTED NODES
            ISTORE(MNODES) = NFL
C
C RETRIEVE THE LIST 5 SERIAL NUMBER OF THE ATOMS
C AT EITHER END OF THE BOND CORRESPONDING TO MNODES.
            IMNO1 = ISTORE (ISTORE (MNODES+2)    )
            IMNO2 = ISTORE (ISTORE (MNODES+2) + 1)
            DO 4000, MMNODE = LNODES, LNODES+(NNODES-1)*MDNODE, MDNODE
C
C RETRIEVE THE LIST 5 SERIAL NUMBER OF THE ATOMS
C AT EITHER END OF THE BOND CORRESPONDING TO MMNODE.
            IMMNO1 = ISTORE (ISTORE (MMNODE+2)    )
            IMMNO2 = ISTORE (ISTORE (MMNODE+2) + 1)
C
C THE EXCLUSIVE OR .NEQV. IS PROBABLY QUICKER THAN CHECKING AT EACH STEP
C WHETHER MNODES = MMNODE.
                  IF (((IMMNO1 .EQ. IMNO1  )
     1         .NEQV.  (IMMNO2 .EQ. IMNO2  ))
     2           .OR. ((IMMNO1 .EQ. IMNO2  )
     3         .NEQV.  (IMMNO2 .EQ. IMNO1  ))) THEN
                        ISTORE(MNODES+1) = ISTORE(MNODES+1) + 1
                        ISTORE(NFL     ) = 1 + (MMNODE - LNODES)/MDNODE
C
C LEAVE TWO EXTRA SLOTS
                        NFL = KCHNFL(3)
                  END IF
4000  CONTINUE
5000  CONTINUE
      RETURN
      END
CODE FOR XFIBUF
      SUBROUTINE XFIBUF (CTEXT, LCTEXT, CBUFF, NROWCB, IINDCB, IROWCB)
C
C WRITE THE LINE CTEXT, INTO THE CHARACTER BUFFER CBUFF, MAKING SOME
C DECISION ABOUT WHETHER TO BREAK OVER LINES IF THERE ISN'T ENOUGH
C SPACE ON THE CURRENT LINE.  NEXT POSITION OF CBUFF TO WRITE TO
C = ELEMENT IINDCB OF ROW IROWCB
C CBUFF HAS NROWCB ROWS
      CHARACTER*(*) CBUFF(NROWCB)
      CHARACTER*(*) CTEXT

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      LCBUFF = LEN (CBUFF(1))
C
C WORK OUT THE NO. OF ELEMENTS OF CTEXT IT IS POSSIBLE TO FIT
C INTO THE REST OF THE BUFFER
      INLAST = LCBUFF - IINDCB + 1
C
      IF (LCTEXT .LT. INLAST) THEN
C
C THERE IS ROOM - WRITE IT OUT.  THIS WILL WORK IF NCHARS=0
            CBUFF(IROWCB)(IINDCB:) = CTEXT(1:LCTEXT)
            IINDCB = IINDCB + LCTEXT
      ELSE
C
C WORK BACK DOWN CTEXT, FINDING THE POSITION OF THE FIRST BLANK
            MIND = INLAST + 1
1000  CONTINUE
            MIND = MIND   - 1
            IF ((MIND .GT. 0) .AND. (CTEXT(MIND:MIND) .NE. ' '))
     1           GO TO 1000
            IF  (MIND .GT. 0) THEN
C
C WRITE OUT WHAT YOU CAN.
                  CBUFF(IROWCB)(IINDCB:) = CTEXT(1:MIND)
                  IINDCB = IINDCB + MIND
            END IF
C
C CONTINUE AFTER THE BLANK.  MAY WANT TO IMPROVE HERE FOR AESTHETICS
C NO ERROR CHECKING IS INCLUDED SHOULD TWO CONTINUATIONS BE REQUIRED.
C - THIS WOULD IMPLY THAT CBUFF << CTEXT IN LENGTH.
            IROWCB = IROWCB + 1
            IF (IROWCB .GT. NROWCB) THEN
                  NERRFI = 21
            ELSE
                  CBUFF(IROWCB) = 'CONT '
                  IINDCB = 6
                  CBUFF(IROWCB)(IINDCB:) = CTEXT((MIND+1):LCTEXT)
                  CALL XCTRIM (CBUFF(IROWCB), IINDCB)
            END IF
      END IF
      RETURN
      END
CODE FOR XFIERR
      SUBROUTINE XFIERR
C
C DJK 13/8/93
C ERROR HANDLER
      PARAMETER(NEVAL=47)
      CHARACTER *66 CERRVA(NEVAL)
C
\XIOBUF
\XUNITS
      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
      CERRVA(1)  = 'OPENING QUERY FILE'
      CERRVA(36) = 'STRUCTURE FROM FILE: NOT YET IMPLEMENTED'
      CERRVA(47) = 'QUERY FILENAME TOO LONG'
C
      IF (NERRFI .EQ. 0) THEN
          WRITE (CMON, '(1X, A8)') 'NO ERROR'
          CALL XPRVDU(NCVDU, 1,0)
      ELSE IF (NERRFI .LE. NEVAL) THEN
          WRITE (CMON, '(1X, A79)') '#FIND: ERROR '// CERRVA(NERRFI)
          CALL XPRVDU(NCVDU, 1,0)
      ELSE
          WRITE (CMON, '(1X, A13, I3)') '#FIND: ERROR ', NERRFI
          CALL XPRVDU(NCVDU, 1,0)
      END IF
      RETURN
      END
CODE FOR XFIND
      SUBROUTINE XFIND
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
C GENERATE GRAPHS CORRESPONDING TO THE STRUCTURE
C  & THE QUERY STRUCTURES.
      CALL XGRGEN
      IF (NERRFI .NE. 0) GO TO 9900
C
C GENERATE SETS ACCORDING TO NODE PROPERTIES FOR STRUCTURE
C  & ALL QUERY STRUCTURES.
      CALL XSEGEN
      IF (NERRFI .NE. 0) GO TO 9900
C
C TEST ALL THE QUERY STRUCTURES FOR SUBGRAPH ISOMORPHISM GIVEN THE SETS
C JUST GENERATED.
      CALL XSUISO
      IF (NERRFI .NE. 0) GO TO 9900
C
C USE THE RESULTS.
      CALL XOUTPU
9900  CONTINUE
C
C CLEAR ALL THE VARIABLES USED
      CALL XCLFIN
      RETURN
      END
CODE FOR XFINDR
      SUBROUTINE XFINDR
C
C STRUCTURE MATCHING ROUTINES
C
C COMMAND INPUT
C NOTE SPECIAL PROCESSING REQUIRED FOR STRING TYPE PARAMETERS, TYPE 4.
C
C STORE IS SPLIT AT THE ADDRESS LEFLEX.  NEW GENERAL STRUCTURE LIST
C ENTRIES ARE BUILT ABOVE THIS ADDRESS, FOR TRANSFERRING DOWN LATER.
C FLEXIBLE LENGTH
C COMMANDS ARE READ INTO THE TOP OF STORE (BELOW LFL) AND THE NECESSARY
C INFO TRANSLATED DOWN TO THE FORMING STRUCTURE LIST (LSTRUC ...) ABOVE
C NFL.  FLEXIBLE INFO (FILENAMES ETC) EVENTUALLY STORED ABOVE NFL
C TRANSFERRED DOWN AT THE END OF COMMAND INPUT.
C
C DIRECTIVES 'KNOWN', 'APPLY' AND 'OUTFILE' CAN SUPPLY AS A PARAMETER
C A QUERY NUMBER.  THIS REFERS TO THE SEQUENCE OF QUERIES AS THEY ARE
C READ IN, NOT AFTER SORTING.
C THE DEFAULT OF ZERO IMPLIES THE QUERY NUMBER MOST RECENTLY GIVEN IN
C A QUERY DIRECTIVE.
C IT IS ASSUMED THAT DIRECTIVES DEFINING THE RELEVANT QUERIES WILL
C PRECEDE THESE DIRECTIVES.
C GIVING ONE OF THESE DIRECTIVES WITH NO PRECEDING QUERY DIRECTIVE OR
C NO PRECEDING QUERY DIRECTIVE DEFINING THE QUERY SPECIFIED WILL GIVE
C AN ERROR.
C
C----- TO HOLD REAL FORMAT EXPRESSION
      CHARACTER*16 CSSMAC , CSSOPS , CSSDAT , CSSPRG
      CHARACTER*64 CSSCMD, CSSNDA, CSSCST, CSSDST, CSSSCT, CSSELE
      CHARACTER*64 CSSVDU, CSSLPT
C
      EXTERNAL FINDBD

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
      COMMON/XCARDS/IMAGE(80),NC,ND,LASTCH,NI,NILAST,NS,MON,ICAT,
     2 IEOF,IHFLAG,NUSRQ,NREC,IPOSRQ,ITYPFL,INSTR,IDIRFL,IPARAM,IPARAD,
     3 NWCHAR , LCMAGE(80), IMNSRQ
      COMMON/XCHARS/IB,IH,NUMB(10),IPLUS,MINUS,IA,ISLASH,IEXP,
     2 ILB,IRB,ICOMMA,IEQUAL,IPOINT,ISEMIC,IQ,IX(3)
      COMMON/XLISTI/L0,M0,MD0,N0,LN,LSN,IREC,LEF,LSTLEF,MAPS
\XUNITS
      COMMON /XSSVAL/ ISSISS , ISSVER , ISSMAC(2) , ISSOPS(2) ,
     2 ISSDAT(4) , ISSSEG , ISSOLD , ISSNEW , ISSCIF , ISSFNF ,
     3 ISSREA , ISSWRI , ISSBFS , ISSNBF , ISSPAG , ISSRLI ,
     4 ISSBLI , ISSWLI , ISSRLF , ISSBLF , ISSWLF , ISSPRG(2) ,
     5 ISSLSM , ISSSPD , ISSTIM , ISSL11 , ISSLNM , ISSINI ,
     6 ISSSTA , ISSBAN , ISSSFI , ISSDAR , ISSTML , ISSFLC,
     7 ISSMSG , ISSPRT , ISSEOF , ISSERF , ISSOKF , ISSSCR,
     8 ISSUNK , ISSGEN , ISSFLM , ISSPAS , ISSEXP,  ISSUEQ
      COMMON /XSSCHR/ CSSMAC, CSSOPS, CSSDAT, CSSPRG, CSSCMD, CSSNDA,
     2 CSSCST , CSSDST, CSSSCT, CSSELE, CSSVDU, CSSLPT
      COMMON /XSSLSN/ LSSMAC, LSSOPS, LSSDAT, LSSPRG, LSSCMD, LSSNDA,
     2 LSSCST , LSSDST, LSSSCT, LSSELE, LSSVDU, LSSLPT
      COMMON /XERVAL/ IERNOP,IERSFL,IERWRN,IERERR,IERSEV,IERCAT,
     2 IERPRG,IERABO,IERUNW
      COMMON /XOPVAL/ IOPCRY , IOPPUR , IOPLPC , IOPSSM , IOPMER ,
     2 IOPABS , IOPCOR , IOPREF , IOPFOU , IOPWEI , IOPANA , IOPTFC ,
     3 IOPMOD , IOPLSM , IOPHYD , IOPLSI , IOPLSC , IOPLEX , IOPL12 ,
     4 IOPL16 , IOPCHK , IOPCPR , IOPSOR , IOPREO , IOPSFS , IOPPCH ,
     5 IOPDIS , IOPTOR , IOPPRA , IOPTLS , IOPAXS , IOPPPR , IOPREG ,
     6 IOPSIM , IOPTRI , IOPSLA , IOPFPL , IOPDAB , IOPDSP , IOPINV ,
     7 IOPGNP , IOPP22 , IOPSCP , IOPSGP , IOPQCK , IOPCMP
      COMMON /XOPMVL/ IOPABN , IOPCMI , IOPEND , IOPPRC , IOPSPC ,
     2 IOPLSP , IOPINT , IOPLSE , IOPVER
C
C
C CLEAR STORE
      CALL XCSAE
      CALL XRSL
C
C SAVE ADDRESSES FOR RESETTING AFTER 9700
      LFLSAV = LFL
      NFINAL = NFL
C
C ERROR FLAG
      NERRFI = 0
C
C AMOUNT OF MEMORY TO ALLOCATE TO FLEXIBLE STUFF
C CURRENTLY 1/2 OF STORE
      LEFLEX = (LFL-NFL)/2
C
C LENGTH OF AREA NEEDED TO HOLD COMMAND INFO EXTRACTED BY STANDARD ROUTI
      IDIMBF = 29
C
C MAX LENGTH OF THE FLEXIBLE (TYPE 4) BIT OF THE COMMAND LINES
      IMALEN = 80
C
C A COUNTER FOR THE NUMBER OF QUERIES
      NQCOUN = 0
C
C CLEAR AN AREA WHERE THE STANDARD ROUTINES WILL PLACE THE COMMAND INFO
CMAR98
      ICOMBF = KSTALL(IDIMBF)
      NFLPSE = KSTALL(LEFLEX)
      CALL XZEROF (STORE(ICOMBF), IDIMBF)
      CALL XZEROF (STORE(NFLPSE), LEFLEX)
      NTMPAR = NFL
      LFLPSE = NFL - 1
C
C SET UP THE GENERAL STRUCTURE AREA IN ITS TEMPORARY FORM.
C FIRST STRUCTURE IS THE SEARCHEE, IE USUALLY LIST 5.
      LSTRUC = NFL
      NSTRUC = 1
      NFL    = KCHNFL (MDSTRU)
      DO 500, M = LSTRUC, LSTRUC+MDSTRU-1
            ISTORE (M) = 0
500   CONTINUE
C
C -- READ DIRECTIVE CARD
1000  CONTINUE
      IDIRNM = KRDNDC ( ISTORE(ICOMBF) , IDIMBF )
      IF ( IDIRNM .LT. 0 ) THEN
C
C END OF DIRECTIVES
             GO TO 6000
      ELSE IF ( IDIRNM .EQ. 0 ) THEN
C
C CONTINUATION
             CALL XMONTR ( 0 )
             GO TO 1000
      ENDIF
C
      IF  ((IDIRNM .EQ. 2)
     1.OR. (IDIRNM .EQ. 3)
     2.OR. (IDIRNM .EQ. 5)
     3.OR. (IDIRNM .EQ. 6)) THEN
C
C QUERY, KNOWN OR OUTFILE DIRECTIVE
C MAY TERMINATE WITH A 'SPECIAL' PARAMETER, IE ONE FOR INTERPRETATION
C HERE.  USE THE SAME CODE TO READ THE PARAMETERS INCLUDING THE SPECIAL
C ONE THEN ACT ON DIRECTIVE TYPE.
2000  CONTINUE
            IDWZAP = 0
            IF (KFNDNP(IDWZAP) .LE. 0) GO TO 1000
C
C READ THE PARAMETERS NORMALLY UNTIL THE SPECIAL ONE IS MET.
C ASSUME THE SPECIAL ONE IS ALWAYS LAST.
            ISTAT = KRDPV ( ISTORE(ICOMBF) , IDIMBF )
            IF ( ISTAT .LT. 0 ) GO TO 1000
            IF ( ISTAT .EQ. 0 ) GO TO 2000
C
C----- FIND NEXT AND LAST NON- BLANK ITEMS
            NC = KNEQUL ( NC , IB )
            IF ( NC .LE. 0 ) GO TO 7000
            IF ( NC .GT. LASTCH ) GO TO 7000
            LC = LASTCH
            DO 2500 I = LASTCH, NC, -1
                  IF (IMAGE(LC) .NE. IB) GOTO 3000
            LC = LC - 1
2500        CONTINUE
3000  CONTINUE
C
C FORCE CHECKING & DEFAULT FILLING IN
            IERRPV = KCHKPV (IDIRNM, ISTORE(ICOMBF), IDIMBF, -1)
            IF (IERRPV .EQ. -1) GO TO 8000
            ISIZE = MIN ( LC - NC + 1 , IMALEN)
C
C NOW ACT ON DIRECTIVE TYPE
            IF (IDIRNM .EQ. 2) THEN
C
C 'QUERY'
                 CALL XQADD(ICOMBF, NQCOUN, ISIZE, LFLPSE, NFLPSE)
                 IF (NERRFI .GT. 0) GO TO 8700
            ELSE IF (IDIRNM .EQ. 3) THEN
C
C 'KNOWN'
C FIRST, CHECK IF THE QUERY NUMBER GIVEN OR IMPLIED IS VALID
C                 NCQ = ISTORE(ICOMBF+10)
                 NCQ = ISTORE(ICOMBF+11)
                 IF (NCQ .LE. 0) THEN
                       IF (NQCOUN .GT. 0) THEN
C ASSUME THE MOST RECENT QUERY IS REFERRED TO
                             MSTRUC = LSTRUC+(MDSTRU*NQCOUN)
                       ELSE
                             GO TO 8700
                       END IF
                 ELSE
                       IF (NCQ .GT. NQCOUN) THEN

C NOT A VALID QUERY TO BE REFERRING TO
                             GO TO 8700
                       ELSE
                             MSTRUC = LSTRUC+(MDSTRU*NCQ)
                       END IF
                 END IF
                 CALL XKNADD(ICOMBF, MSTRUC, ISIZE, LFLPSE, NFLPSE)
                 IF (NERRFI .GT. 0) GO TO 8700
            ELSE IF (IDIRNM .EQ. 5) THEN
C
C 'OUTFILE'
C                  NCQ = ISTORE(ICOMBF+16)
                  NCQ = ISTORE(ICOMBF+17)
                  IF (NCQ .LE. 0) THEN
                        IF (NQCOUN .GT. 0) THEN
                              MSTRUC = LSTRUC+(MDSTRU*NQCOUN)
                        ELSE
                              GO TO 8700
                        END IF
                  ELSE
                        IF (NCQ .GT. NQCOUN) THEN
                              GO TO 8700
                        ELSE
                              MSTRUC = LSTRUC+(MDSTRU*NCQ)
                        END IF
                  END IF
                  CALL XOADD(ICOMBF, MSTRUC, ISIZE, LFLPSE, NFLPSE)
                  IF (NERRFI .GT. 0) GO TO 8700
            ELSE IF (IDIRNM .EQ. 6) THEN
C
C 'SFILE'
                  CALL XSFILE(ICOMBF,ISIZE,LFLPSE,NFLPSE)
                  IF (NERRFI .GT. 0) GO TO 8700
            END IF
      ELSE IF (IDIRNM .EQ. 4) THEN
C
C 'APPLY'.
4000  CONTINUE
            IDWZAP = 0
            IPAR = KFNDNP(IDWZAP)
            IF (IPAR .LT. 0) THEN
                  GO TO 1000
            ELSE IF (IPAR .EQ. 0) THEN
C
C END OF PARAMETERS
C FORCE DEFAULTS & CHECKING AGAIN
                  IERRPV = KCHKPV
     1                     (IDIRNM, ISTORE(ICOMBF), IDIMBF, -1)
                  IF (IERRPV .EQ. -1) GO TO 8000
C
C PROCESS STRAIGHT AWAY.
C CHECK THE QUERY NUMBER (YET AGAIN) AS ABOVE
C                  NCQ = ISTORE(ICOMBF+13)
                  NCQ = ISTORE(ICOMBF+14)
                  IF (NCQ .LE. 0) THEN
                        IF (NQCOUN .GT. 0) THEN
                              MSTRUC = LSTRUC+(MDSTRU*NQCOUN)
                        ELSE
                              GO TO 8700
                        END IF
                  ELSE
                        IF (NCQ .GT. NQCOUN) THEN
                              GO TO 8700
                        ELSE
                              MSTRUC = LSTRUC+(MDSTRU*NCQ)
                        END IF
                  END IF
C
C 'OPTION', 'NOT'
C                  IOPTIO = ISTORE (ICOMBF+14)
                  IOPTIO = ISTORE (ICOMBF+15)
                  IF (IOPTIO .GT. 0) CALL XADDOP(IOPTIO, MSTRUC)
C                  INOTOP = ISTORE (ICOMBF+15)
                  INOTOP = ISTORE (ICOMBF+16)
                  IF (INOTOP .GT. 0) CALL XNOTOP(INOTOP, MSTRUC)
                  IF (NERRFI .GT. 0) GO TO 8700
            ELSE
                  ISTAT = KRDPV ( ISTORE(ICOMBF) , IDIMBF )
                  IF ( ISTAT .EQ. 0 ) GO TO 4000
                  IF ( ISTAT .LT. 0 ) GO TO 1000
            END IF
      ELSE
C
C A NORMAL DIRECTIVE TYPE, IN THIS CASE CTRL
5000  CONTINUE
            IDWZAP = 0
            IF (KFNDNP(IDWZAP) .LE. 0) GO TO 1000
            ISTAT = KRDPV ( ISTORE(ICOMBF) , IDIMBF )
            IF ( ISTAT .LT. 0 ) GO TO 1000
            IF ( ISTAT .EQ. 0 ) GO TO 5000
            GO TO 8000
      END IF
      GO TO 1000
6000  CONTINUE
      IF ( LEF .GT. 0 ) GO TO 9930
      IF ( NERRFI .NE. 0 ) GO TO 9900
C
C NEED SOME ERROR ESCAPE HERE IF THINGS GO WRONG
C TRANSFER THE STUFF FROM THE NORMAL DIRECTIVES, IN THIS CASE JUST
C CTRL.
      LOVERL = (ISTORE (ICOMBF  ) .EQ. 1)
      LSORT  = (ISTORE (ICOMBF+1) .EQ. 1)
      LMCS   = (ISTORE (ICOMBF+2) .EQ. 1)
      INTYPE =  ISTORE (ICOMBF+3)
      LEXTEN = (ISTORE (ICOMBF+4) .EQ. 1)
C
C PUT IN TYPE OF STRUCTURE FILE ( IF IT HASN'T YET BEEN PUT IN BY
C SFILE DIRECTIVE).  IF YOU HAVE A STRUCTURE FILE, DEFAULT FORMAT
C IS CSD.  IF NOT, DEFAULT FORMAT IS LIST 5.  THESE DEFAULTS
C CAN BE CHANGED IN COMMANDS.SRC.
C      IF (ISTORE(LSTRUC+11).EQ.0) ISTORE(LSTRUC+10)=ISTORE(ICOMBF+21)
      IF (ISTORE(LSTRUC+11).EQ.0) ISTORE(LSTRUC+10)=ISTORE(ICOMBF+22)
C
C GET PROBABILITY DENSITY THRESHOLD FOR SETS BASED ON BOND LENGTHS
      RTHRES =  STORE(ICOMBF+24)
C
C GET ENFORCED MAXIMUM NUMBER OF ISOMORPHISMS
      MAXISO = ISTORE(ICOMBF+25)
C
C GET ENFORCED MAXIMUM ATOM-ATOM CONTACT USED IN CALCULATING THE GRAPH
      RMIN   =  STORE(ICOMBF+26)
C
C GET ENFORCED MAXIMUM ATOM-ATOM CONTACT USED IN CALCULATING THE GRAPH
      RMAX   =  STORE(ICOMBF+27)
C
C GET MAXIMUM NUMBER OF ATOMS THAT CAN BE ADDED TO LIST 5 IF
C CTRL EXTEND=YES
      MAXEXT = ISTORE(ICOMBF+28)
C
C MOVE THE FLEXIBLE BITS (OUTFILE ETC) TO THE TOP OF THE AREA HOLDING
C THE GENERAL STRUCTURE LIST AND MOVE THE WHOLE LOT DOWN TO THE LOW
C END OF MEMORY (OVERWRITING WHATEVER HAS BEEN PUT THERE SO FAR!)
      CALL XFLTOP (LFLPSE, NFINAL, NTMPAR)
      IF (NERRFI .GT. 0) GO TO 8700
C
C INPUT COMPLETED
C      LFL    = LFLSAV
      CALL XFIND
      IF (NERRFI .GT. 0) GO TO 8700
C ALL RETURNS COME VIA HERE.
9700  CONTINUE
      NFL = NFINAL
      LFL = LFLSAV
      RETURN
C
9800  CONTINUE
      LEF = LEF + 1
      GO TO 1000
7000  CONTINUE
      CALL XMONTR(0)
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 9815 )
      ENDIF
      WRITE ( NCAWU , 9815 )
9815  FORMAT ( 1X, 'ILLEGAL DATA CARD. ' )
      GO TO 9800
8000  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 9825 )
      ENDIF
      WRITE ( NCAWU ,9825 )
9825  FORMAT (' ERRORS DURING INPUT')
      GOTO 9800
9900  CONTINUE
      CALL XOPMSG (IOPQCK, IOPABN, 0)
      IDIRFL = -1
      GO TO 9700
9930  CONTINUE
      CALL XOPMSG (IOPQCK, IOPCMI, 0)
      GO TO 9900
8700  CONTINUE
      CALL XFIERR
      GO TO 9930
      END
CODE FOR XFITOB
      SUBROUTINE XFITOB (MSTRUC,LNODES,NNODES,LATS,NATS,MDATS)
C
C TAKES A CSD-TYPE DATA FILE AND GENERATES FROM IT A GRAPH
C CORRESPONDING TO THE QUERY STRUCTURE DESCRIBED
C
C CNAME  = NAME OF FILE
C INTYPE = TYPE OF GRAPH HELD FOR THE _SUPERSTRUCTURE_
C        = 1 FOR ATOM GRAPH
C        = 2 FOR BOND GRAPH
C
C NO NEED TO BUILD THE GRAPH IF INTYPE .NE. (TYPE OF FILE GIVEN)
C
C FILE FORMAT:
C 0. FILES ARE READ FROM TOP TO BOTTOM(!) (IE IN THE NORMAL WAY)
C    IN 80-CHARACTER RECORDS.  LINE LENGTHS > 80 ARE TRUNCATED.
C 0.5 FILE READING IS NOT CASE-SENSITIVE
C 1. SPACES AT THE BEGINNING OF LINES ARE IGNORED.
C 2. UNTIL A LINE BEGINNING `END' IS FOUND, ONLY LINES STARTING
C    WITH `AT', `BO' OR `DI' ARE READ.
C 3. IF AN `END' IS NOT FOUND, THE FILE READ IS ABORTED IN ERROR.
C 4. WHEN LOADING A GRAPH, STOP READING AT THE `END' LINE.
C 4.5 `AT' RECORDS LOOK LIKE THIS:
C      AT3 C 3 E
C 5. I.E. THE `AT' IS FOLLOWED IMMEDIATELY BY AN INTEGER SERIAL
C    NUMBER FOR THE ATOM.  THIS SERIAL NUMBER, RATHER THAN THE ORDER
C    OF THE ATOM IN THE FILE, GIVES THE ATOM SERIAL NUMBER.
C 6. THE SECOND ITEM IN AN `AT' RECORD IS THE ATOMIC SPECIES.
C 7. THE NEXT ITEM IS THE NUMBER OF CONNECTED NON-HYDROGEN ATOMS.
C 8. CURRENTLY IGNORE OTHER INFO ON THIS LINE, EG `E' INDICATING
C    THAT THERE MUST BE EXACTLY THIS NUMBER OF CONNECTED ATOMS
C 8.5 `BO' RECORDS LOOK LIKE THIS:
C      BO 3 14 1
C 9. `BO' RECORDS FOLLOW.  THEY CONSIST OF `BO' FOLLOWED BY THE
C    TWO INTEGER SERIAL NUMBERS (FROM THE ABOVE LIST OF ATOMS)
C    WHICH THE BOND IS BETWEEN, SEPARATED BY ANY NUMBER OF SPACES.
C 10. THE THIRD INTEGER IN A `BO' RECORD IS THE BOND ORDER, NOT
C     USED AT PRESENT, BUT WILL EVENTUALLY BE USED, POSSIBLY WITH
C     A LOOKUP TABLE OF BOND LENGTHS, TO GIVE A BOND LENGTH.
C 11. OUT OF ORDER INTEGERS/CHARACTERS WILL CAUSE AN ERROR.
C 12. ANYTHING ELSE IN A `BO' RECORD IS IGNORED.
C 13. AFTER THE FIRST `BO' RECORD, `AT' RECORDS CAUSE AN ERROR
C 14. INCONSISTENCIES BETWEEN `BO' AND `AT' RECORDS WILL CAUSE AN
C     ERROR.
C 15. DUPLICATE BONDS ARE NOT CHECKED FOR
C 16. A CONTIGUOUS SERIES OF SERIAL NUMBERS STARTING AT 1 MUST BE GIVEN
C     STILL MAKE SPACE TO STORE THE SERIAL NUMBER IN CASE IT'S DECIDED T
C     HAVE SEPARATE SEQUENCE & SERIAL NUMBERS
C 17. 'DI' RECORDS LOOK LIKE THIS:
C     DI 1 2 1.53 0.2
C     IE THE FIRST TWO FIELDS ARE ATOM SERIAL NUMBERS, THE NEXT TWO ARE
C     THE REQUIRED DISTANCE BETWEEN THESE ATOMS AND THE TOLERANCE
C     - IE A STRUCTURE WILL MATCH IF DISTANCE = 1.53 +/- 0.2
C
C HOW IT WORKS:
C  READ THE ATOMS & THE BONDS INTO STORE BELOW LFL
C  WHEN THEY'RE ALL THERE (IE WHEN 'END' IS READ) COPY THEM DOWN IN THE
C  NECESSARY FORMAT (IE BONDS AS NODES OR ATOMS AS NODES)
C  CREATE THE ATOM LIST AT THE END OF THE GRAPH
C
C LOCALS:
C LFLSAV = SAVED ADDRESS OF LFL ON ENTRY
C IPOSRE = POINTS TO A CHARACTER IN CREAD
C CTMP   = TEMPORARY STORE FOR ATOMIC SPECIES AS CHARACTER
C CT     = ARGUMENT TO KGTNUM: THE TERMINATING CHARACTER FOUND
C NC     = ARGUMENT TO KGTNUM: THE NUMBER OF DIGITS IN THE EXTRACTED
C          INTEGER
C NATS = NUMBER OF ATOMS READ UP
C NBONDS = NUMBER OF BONDS READ UP
C LNODES = FIRST ENTRY IN THE FIXED PART OF THE GRAPH LIST
C NNODES = NUMBER OF NODES IN THE GRAPH
C MTMPAT = NO OF ADDRESSES PER ATOM IN THE TEMPORARY STORE
C MTMPBO = NO OF ADDRESSES PER BOND IN THE TEMPORARY STORE
C MBOBEG = BEGINNING OF TEMPORARY INFO ABOUT BONDS
C ISER1  = SERIAL NUMBER OF FIRST ATOM IN BOND
C ISER2  = SERIAL NUMBER OF SECOND ATOM IN BOND
C RLENGT = LENGTH OF THE BOND
C GLOBALS:
C MDNODE = 4 (SET IN FINDBD) = NUMBER OF ADDRESSES PER FIXED ENTRY
\XIOBUF
\XUNITS
      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      CHARACTER *80 CNAME
      CHARACTER *80  CREAD, CUPPER
      CHARACTER*8 CFMTXP
      CHARACTER CTMP*4, CT*1
      ITOPIN = ISTORE (MSTRUC+11)
      ISIZE  = ISTORE (ITOPIN)
      WRITE (CFMTXP, '(2H( , I2, 3HA1))') ISIZE
      WRITE (CNAME(1:ISIZE), CFMTXP) (ISTORE(ITOPIN+J), J=1, ISIZE)
      OPEN  (NREAD2, FILE=CNAME(1:ISIZE), STATUS='OLD')
C
C INITIALIZATIONS
C WHATEVER HAPPENS, THE FIXED BIT OF THE GRAPH WILL START AT THE
C CURRENT VALUE OF NFL
      LNODES = NFL
      NNODES = 0
      LFLSAV = LFL
      NATS   = 0
      MDATS  = 4
      NBONDS = 0
      MTMPAT = 4
      MTMPBO = 4
C
C THE START OF THE FIXED PART OF THE NODE LIST
      ISTORE(MSTRUC+2) = LNODES
C
C CALCULATE DEFAULT LENGTH+TOLER WHICH WILL BE ASSUMED FOR BONDS IN THE
C FILE IF A DISTANCE IS NOT GIVEN
      RDLEN = (RMADEF+RMIDEF)/2.0
      RDTOL = (RMADEF-RMIDEF)/2.0
C
C THIS IS THE START OF THE LOOP OVER THE LINES OF THE FILE.
1000  CONTINUE
      READ (NREAD2, '(A80)', END=7000, ERR=8000) CREAD
C
C CONVERT TO UPPER CASE
      CALL XCCUPC (CREAD, CUPPER)
C
C REMOVE REDUNDANT SPACES
      CALL XCREMS (CUPPER, CREAD, LREAD)
C
      IF (CREAD(1:3) .EQ. 'END') THEN
            GO TO 2000
      ELSE IF (CREAD(1:2) .EQ. 'AT') THEN
C
C CHECK FOR MIXING OF BO & AT RECORDS
            IF (NBONDS .GT. 0) THEN
                    NERRFI = 14
                    GO TO 9900
            END IF
C
C ADD AN ATOM ENTRY TO JUST BELOW LFL, IN THE ORDER:
C --- LOW ADDRESSES  ---
C ATOMIC SPECIES AS HOLLERITH
C SERIAL NUMBER
C NUMBER OF CONNECTED ATOMS
C 0 IF NON-EXACT, 1 IF EXACT NUMBER OF CONNECTIONS
C --- HIGH ADDRESSES ---
            LFL    = LFL - MTMPAT
            NATS = NATS + 1
            IF ((LFL - NFL) .LE. 0) THEN
C
C YOU'RE REALLY IN TROUBLE
                  NERRFI = 6
                  GO TO 9900
            END IF
C
C THE SERIAL NUMBER
            ISTORE (LFL+2) = KGTNUM(CREAD(3:), CT, NC)
C            WRITE (CMON,*) ' SERIAL NUMBER ', ISTORE(LFL+2), ' CT ', CT
C            CALL XPRVDU(NCVDU, 1, 0)
            IPOSRE = NC + 3
            IPOSR2 = IPOSRE + INDEX(CREAD((IPOSRE+1):), ' ')
C
C GET THE SPECIES
            CTMP   = CREAD((IPOSRE+1):IPOSR2)
            READ (CTMP, '(A4)')  ISTORE (LFL+1)
C
C THE CONNECTIONS
            ISTORE(LFL+3)= KGTNUM(CREAD((IPOSR2+1):),CT,NC)
            IPOSR2 = IPOSR2 + NC
            IF (INDEX (CREAD((IPOSR2+1):), 'E') .GT. 0) THEN
                   ISTORE (LFL+4) = 1
                   IF (.NOT. LEXACT) LEXACT = .TRUE.
            ELSE
                   ISTORE (LFL+4) = 0
            END IF
      ELSE IF (CREAD(1:2) .EQ. 'BO') THEN
             IF (NATS .EQ. 0) THEN
                   NERRFI = 15
                   GO TO 9900
             END IF
C
C ADD AN ENTRY TO JUST BELOW LFL, FORMAT:
C --- LOW ADDRESSES  ---
C SERIAL NUMBER OF FIRST ATOM IN BOND
C SERIAL NUMBER OF SECOND ATOM IN BOND
C LENGTH OF BOND
C TOLERANCE FOR BOND
C --- HIGH ADDRESSES ---
            LFL    = LFL - MTMPBO
            IF ((LFL - NFL) .LE. 0) THEN
C
C YOU'RE REALLY IN TROUBLE
                  NERRFI = 6
                  GO TO 9900
            END IF
            NBONDS = NBONDS + 1
C
C EXTRACT THE FIRST SERIAL NUMBER OF THE BOND
            ISTORE (LFL+1) = KGTNUM(CREAD( 4    :), CT, NC)
            ISTORE (LFL+2) = KGTNUM(CREAD((NC+5):), CT, NC)
C
C PUT IN THE BOND LENGTH ETC HERE, WHEN POSSIBLE
C             STORE (LFL+3) = 0.0
C             STORE (LFL+4) = 0.0
C PUT IN DEFAULT BOND LENGTHS AND TOLERANCES - SAME AS THOSE
C FOR GENERATING GRAPHS
             IF (INTYPE .EQ. 1) THEN
                 STORE (LFL+3) = RDLEN
                 STORE (LFL+4) = RDTOL
             ELSE
                 STORE (LFL+3) = RDLEN
                 STORE (LFL+4) = RDTOL / 2.0
             END IF
      ELSE IF (CREAD(1:2) .EQ. 'DI') THEN
          IF (NATS .EQ. 0) THEN
C NERRFI = NERRFI_CAN'T_DO_DIST_YET
              NERRFI = 95
              GO TO 9900
          END IF
          ISER1R = KGTNUM(CREAD( 4    :), CT, NC)
          IPOS   = NC+5
          ISER2R = KGTNUM(CREAD(IPOS:), CT, NC)
          READ(CREAD(NC+IPOS+1:), '(F5.3,1X,F5.3)',IOSTAT=IERR)
     1                                          RDIST, RTOLE
          IF (IERR .GT. 0) THEN
C NERRFI = NERRFI_BAD_RDIST_READ
              NERRFI = 94
              GO TO 9900
          END IF

C TREAT AS A NEW BOND IF POSSIBLE
C SEACH FOR THIS BOND
          MBOBEG = LFLSAV - (NATS*MTMPAT)
          DO 1500, MBO = MBOBEG,MBOBEG-((NBONDS-1)*MTMPBO),-MTMPBO
              ISER1 = ISTORE(MBO-MTMPBO+1)
              ISER2 = ISTORE(MBO-MTMPBO+2)
              IF ( ((ISER1 .EQ. ISER1R) .AND. (ISER2 .EQ. ISER2R))
     1         .OR.((ISER2 .EQ. ISER1R) .AND. (ISER1 .EQ. ISER2R))) THEN
C FOUND IT
                   STORE(MBO-MTMPBO+3) = RDIST
                   STORE(MBO-MTMPBO+4) = RTOLE
                  GO TO 1600
              END IF
1500      CONTINUE
C IF YOU GET HERE, NEED TO ADD THIS 'DIST' AS IF IT'S A BOND
          LFL    = LFL - MTMPBO
          IF ((LFL - NFL) .LE. 0) THEN
C
C YOU'RE REALLY IN TROUBLE
                NERRFI = 6
                GO TO 9900
          END IF
          NBONDS = NBONDS + 1
          ISTORE(LFL+1) = ISER1R
          ISTORE(LFL+2) = ISER2R
           STORE(LFL+3) = RDIST
           STORE(LFL+4) = RTOLE
1600      CONTINUE
      END IF
      GO TO 1000
2000  CONTINUE
C
C THE END OF A (SO FAR) GOOD FILE HAS BEEN REACHED
C STILL NEED TO DO SOME WORK.
      IF (INTYPE .EQ. 1) THEN
            CALL TFTOG(LNODES, NNODES, MTMPAT, NATS, MDATS,
     1                 LFLSAV, NBONDS, MTMPBO, LATS)
            IF (NERRFI .NE. 0) GO TO 9900
      ELSE IF (INTYPE .EQ. 2) THEN
            NNODES = NBONDS
C
C MAKE ROOM FOR THE FIXED BIT (BUT DON'T FILL IT IN YET)
            NFLTMP = KSTALL (NNODES*MDNODE)
            DO 3900, MZERO = NFLTMP, NFL - 1
                  ISTORE (MZERO) = 0
3900        CONTINUE
            MBOBEG = LFLSAV - (NATS*MTMPAT)
C
C NOW SORT OUT THE CONNECTIVITY (FLEXIBLE) PART OF THE GRAPH
C LOOP OVER THE TEMPORARY BOND STORE
            DO 4000, MBO = MBOBEG,MBOBEG-((NBONDS-1)*MTMPBO),-MTMPBO
                 ISER1  = ISTORE (MBO-MTMPBO+1)
                 ISER2  = ISTORE (MBO-MTMPBO+2)
                 MNODES = LNODES+(MDNODE*((MBOBEG - MBO)/MTMPBO))
                 DO 3000, MMBO=MBOBEG, MBOBEG-((NBONDS-1)*MTMPBO),
     1                                    -MTMPBO
                       IISER1 = ISTORE(MMBO-MTMPBO+1)
                       IISER2 = ISTORE(MMBO-MTMPBO+2)
                       MMNODE = LNODES+(MDNODE*((MBOBEG-MMBO)/MTMPBO))
C
C THE EXCLUSIVE OR .NEQV. IS PROBABLY QUICKEST
                  IF (((IISER1 .EQ. ISER1  )
     1         .NEQV.  (IISER2 .EQ. ISER2  ))
     2           .OR. ((IISER1 .EQ. ISER2  )
     3         .NEQV.  (IISER2 .EQ. ISER1  ))) THEN
C
C THE BONDS HAVE ONE & ONLY ONE ATOM IN COMMON.
                        IF (ISTORE(MNODES).EQ. 0) ISTORE (MNODES)  = NFL
                        ISTORE (MNODES+1) = ISTORE(MNODES+1) + 1
                        ISTORE (NFL     ) = 1 + (MMNODE - LNODES)/MDNODE
                        NFL    = KCHNFL(3)
                  END IF
3000             CONTINUE
4000        CONTINUE
C            WRITE (6,*) (ISTORE(M), M=LFLSAV, LFL, -1)
C
C NOW LOOP OVER THE NODES AGAIN, FILLING IN INFO ABOUT EACH NODE
            NINFO        = 4
            DO 6000, MNODES=LNODES, LNODES+(NNODES-1)*MDNODE, MDNODE
C
C GET THE SERIAL NUMBERS
                  MTMP        = ((MNODES-LNODES)/MDNODE)
                  MTMP        = MBOBEG - (MTMP*MTMPBO)
                  ISER2        = ISTORE (MTMP-MTMPBO+2)
                  ISER1        = ISTORE (MTMP-MTMPBO+1)
                  RLENGT       =  STORE (MTMP-MTMPBO+3)
                  RTOLE        =  STORE (MTMP-MTMPBO+4)
C
C NOW THE SERIAL NUMBERS ARE AVAILABLE, MAKE THE NEW FIXED ENTRY
                  ISTORE (MNODES+2) = KSTALL(NINFO)
                  I            = ISTORE (MNODES+2)
                  ISTORE (MNODES+3) = I+NINFO-1
C
C WHATEVER HAPPENS, STICK THE SERIAL NUMBERS IN THE FIRST TWO SLOTS
                  ISTORE (I  ) = ISER1
                  ISTORE (I+1) = ISER2
                   STORE (I+2) = RLENGT
                   STORE (I+3) = RTOLE
6000    CONTINUE
C
C NOW TRANSFORM THE TEMPORARY STORE BELOW LFL INTO AN ATOM LIST
      LATS   = KSTALL (MDATS*NATS)
      MATS   = LATS - MDATS
      DO 6500, M = LFLSAV, LFLSAV-((NATS-1)*MTMPAT), -MTMPAT
           MATS = MATS + MDATS
C
C SPECIES AS HOLLERITH
           ISTORE (MATS  ) = ISTORE (M-3)
C
C SERIAL NUMBER
           ISTORE (MATS+1) = ISTORE (M-2)
           IF (ISTORE (MATS+1) .NE. (1+(LFLSAV-M)/MTMPAT)) THEN
C                 NERRFI = NERRFI_BAD_ATOM_ORDER
                  NERRFI = 157
                 GO TO 9900
           END IF
C
C NO OF CONNECTIONS
           ISTORE (MATS+2) = ISTORE (M-1)
C
C THE EXACT NO OF CONNECTIONS FLAG
           ISTORE (MATS+3) = ISTORE (M  )
6500  CONTINUE
C
C A NORMAL READ SHOULD END HERE
      END IF
      LFL   = LFLSAV
      GO TO 9900
7000  CONTINUE
C
C END OF FILE REACHED BEFORE 'END' WAS READ
      NERRFI = 7
      GO TO 9900
8000  CONTINUE
C
C ERROR TRYING TO READ THE FILE AS (A80) LINE
      NERRFI = 8
9900  CONTINUE
      CLOSE (NREAD2)
      RETURN
      END
CODE FOR XFLTOP
      SUBROUTINE XFLTOP (LFLPSE, NFINAL, NTMPAR)
C
C MOVE FLEXIBLE BITS UP TO ABOVE STRUCTURE ENTRIES
C CHANGE ALL ADDRESSES TO RELATIVE ONES

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      DO 5000, MSTRUC = LSTRUC, LSTRUC+(NSTRUC-1)*MDSTRU, MDSTRU
C
C OUTFILE INFO
            LOUTF = ISTORE (MSTRUC+8)
            NOUTF = ISTORE (MSTRUC+9)
C
C NOW STORE IN ORDER:
C  LOW ADDRESS --> OCCURRENCE NO.
C              --> OPTION NUMBER
C              --> OVERWRITE/APPEND
C              --> LENGTH IN CHARS
C              --> FILENAME ... (ONE SLOT PER CHAR)
C HIGH ADDRESS --> ... MORE FILENAME
             IF (NOUTF .GT. 0) THEN
                   LFIRST = NFL
                   DO 2000, M = 1, NOUTF
                         ILENG = ISTORE (LOUTF - 4)
                         LTMP  = KSTALL (ILENG + 4)
C SWAP THE ORDER OF THINGS AROUND
                         ISTORE (LTMP  ) = ISTORE (LOUTF  )
                         ISTORE (LTMP+1) = ISTORE (LOUTF-1)
                         ISTORE (LTMP+2) = ISTORE (LOUTF-2)
                         ISTORE (LTMP+3) = ILENG
                         DO 1000, MTMP = 1, ILENG
                              ISTORE(LTMP+3+MTMP)=ISTORE(LOUTF-4-MTMP)
1000                     CONTINUE
C                         DO 2001,MM= LTMP,LTMP+ILENG+3
C      WRITE (6,'(I7,A9, I10)')MM,' OUTFILE ', ISTORE(MM)
C2001                     CONTINUE
                         LOUTF = ISTORE (LOUTF-3)
2000              CONTINUE
C
C STORE NEW RELATIVE ADDRESS.
                    ISTORE (MSTRUC+8) = LFIRST - MSTRUC
              END IF
C
C INFILE/SFILE INFO
              IINF   = ISTORE (MSTRUC + 11)
              IF (IINF .GT. 0) THEN
                    ILENG  = ISTORE (IINF)
                    LTMP   = KSTALL (ILENG + 1)
                    ISTORE (LTMP) = ILENG
C                    WRITE (6,'(I7,A14)')LTMP, ' INFILE/SFILE '
                    DO 3000, M = 1, ILENG
                          ISTORE (LTMP+M) = ISTORE (IINF-M)
C                    WRITE (6,'(I7,A14)')LTMP+M, ' INFILE/SFILE '
3000                CONTINUE
                    ISTORE (MSTRUC+11) = LTMP - MSTRUC
              END IF
C
C KNOWN INFO
              LKNOW = ISTORE (MSTRUC+16)
              NKNOW = ISTORE (MSTRUC+17)
              IF (NKNOW .GT. 0) THEN
C
C NOW STORE IN ORDER:
C  LOW ADDRESS --> QUERY NO.
C              --> STRUCTURE ATOMIC SERIAL NUMBER
C HIGH ADDRESS --> QUERY ATOMIC SERIAL NUMBER
                   LFIRST = NFL
                   DO 4000, M = 1, NKNOW
                         LTMP  = KSTALL (3)
                         ISTORE (LTMP  ) = ISTORE (LKNOW  )
C                    WRITE (6,'(I7,A7)')LTMP, ' KNOWN '
                         ISTORE (LTMP+1) = ISTORE (LKNOW-1)
C                    WRITE (6,'(I7,A7)')LTMP+1, ' KNOWN '
                         ISTORE (LTMP+2) = ISTORE (LKNOW-2)
C                    WRITE (6,'(I7,A7)')LTMP+2, ' KNOWN '
                         LKNOW = ISTORE (LKNOW-3)
4000               CONTINUE
C
C STORE NEW RELATIVE ADDRESS.
                   ISTORE (MSTRUC+16) = LFIRST - MSTRUC
              END IF
5000  CONTINUE
C
C MOVE THE WHOLE LOT DOWN TO THE LOW END OF MEMORY
      NTOMOV = NFL - NTMPAR
      CALL XMOVE(ISTORE(NTMPAR),ISTORE(NFINAL),NTOMOV)
      NFL    = NFINAL + NTOMOV
      LSTRUC = NFINAL
C
C NOW CONVERT TO ABSOLUTE ADDRESSES
      DO 6000, MSTRUC=LSTRUC, LSTRUC+MDSTRU*(NSTRUC-1), MDSTRU
            ISTORE (MSTRUC+ 8) = ISTORE(MSTRUC+ 8) + MSTRUC
            ISTORE (MSTRUC+11) = ISTORE(MSTRUC+11) + MSTRUC
            ISTORE (MSTRUC+16) = ISTORE(MSTRUC+16) + MSTRUC
                         LOUTF = ISTORE(MSTRUC+8)
                         NOUTF = ISTORE(MSTRUC+9)
                         MOUTF = LOUTF
                         DO 6010, M = 1, NOUTF
                         ILENG = ISTORE(MOUTF+3)
C                         DO 6001, MM= MOUTF,MOUTF+ILENG+3
C      WRITE (6,'(I7,A9, I10)')MM,'MOVED OUTFILE ', ISTORE(MM)
C6001                     CONTINUE
                         MOUTF = MOUTF + ILENG + 4
6010                     CONTINUE
6000  CONTINUE
      RETURN
      END
CODE FOR XGRGEN
      SUBROUTINE XGRGEN
C
C GENERATE GRAPHS CORRESPONDING TO THE STRUCTURE & QUERIES

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
C BUILD RANKED GRAPH LIST (IF REQUIRED - CHECK LSORT)
      CALL XBRGRL
      IF (NERRFI .NE. 0) GO TO 9900
C
C MAKE ROOM FOR THE ISOMORPHISMS FOUND
      CALL XCRLIF
      IF (NERRFI .NE. 0) GO TO 9900
9900  CONTINUE
      RETURN
      END
CODE FOR XIARCO
      SUBROUTINE XIARCO(CBUFF, NROWCB, CMTYPE, LCHANG)
C
C CHANGE ARITHMETIC IN CBUFF TO SOMETHING MEANINGFUL
C CMTYPE IS THE TYPE OF MATHS OPERATION TO BE DONE
C
      CHARACTER*(*) CBUFF(NROWCB)
      CHARACTER *1 CURCHA
      CHARACTER *9 CNEWNU
      CHARACTER *4 CFMTXP
      CHARACTER *1 CMTYPE
      LOGICAL LCHANG

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
C CAN ONLY DO +,-,*, INTEGER /
      IF (INDEX('+-*/', CMTYPE) .EQ. 0) THEN
          NERRFI = 89
          GO TO 9900
      END IF
C
      LCBUFF = LEN(CBUFF(1))
C
      ICURNU = 0
      DO 4000, IROWCB = 1, NROWCB
          INPCB  = 1
          ICURNU = 0
          IBCN   = 0
C
C WORK ALONG THE LINE TOTTING UP ANY NUMBERS THAT APPEAR
          DO 2000, IPCB = INPCB, LCBUFF
              CURCHA = CBUFF(IROWCB)(IPCB:IPCB)
              INPCB = INPCB+1
              IDIGIT = INDEX(CDIGIT, CURCHA)
              IF (IDIGIT .GT. 0) THEN
                  IF (ICURNU .EQ. 0) IBCN   = IPCB
                  ICURNU = ICURNU*10 + IDIGIT - 1
              ELSE
C
C CHECK FOR MATHS SYMBOLS.
                  IF ((CURCHA .EQ. CMTYPE)
     1           .AND.(ICURNU .NE. 0)) THEN
C
C GET THE NEXT NUMBER
                      INNUM  = 0
                      IDNNUM = 1
1000                  CONTINUE
                      CURCHA =CBUFF(IROWCB)(IPCB+IDNNUM:IPCB+IDNNUM)
                      IDIGIT = INDEX(CDIGIT, CURCHA)
                      IF (IDIGIT .NE. 0) THEN
                          INNUM  = INNUM * 10 + IDIGIT - 1
                          IDNNUM = IDNNUM + 1
                          GO TO 1000
                      ELSE IF ((CURCHA .EQ. ' ').AND.(IDNNUM.EQ.0)) THEN
C WAIT FOR A NUMBER
                          IDNNUM = IDNNUM + 1
                          GO TO 1000
                      ELSE
                          IF (IDNNUM .EQ. 0) THEN
C NO SECOND NUMBER FOR THIS OPERATION
                              NERRFI = 91
                              GO TO 9900
                          END IF
C
C DO THE MATHS REQUIRED
                          IF (CMTYPE .EQ. CPLUS) THEN
                              NEWNUM = ICURNU+INNUM
                          ELSE IF (CMTYPE .EQ. CMINUS) THEN
                              NEWNUM = ICURNU-INNUM
                          ELSE IF (CMTYPE .EQ. CTIMES) THEN
                              NEWNUM = ICURNU*INNUM
                          ELSE IF (CMTYPE .EQ. CDIV  ) THEN
                              IF (INNUM .NE. 0) THEN
C NOTE THIS IS DIVISION WITH TRUNCATION
                                  NEWNUM = ICURNU/INNUM
                              ELSE
C NERRFI ATTEMPTED DIVISION BY ZERO
                                  NERRFI = 90
                                  GO TO 9900
                              END IF
                          END IF
                          RNEWNU = ABS(REAL (NEWNUM))
                          IF (NEWNUM .NE. 0) THEN
                              LNEWNU = 1+ INT(ALOG10(RNEWNU))
                          ELSE
                              LNEWNU = 1
                          END IF
C MAKE ROOM FOR - SIGN
                          IF (NEWNUM .LT. 0) LNEWNU = LNEWNU + 1
                          CFMTXP = '(I )'
                          WRITE (CFMTXP(3:3), '(I1)' ) LNEWNU
                          CNEWNU = ' '
                          WRITE (CNEWNU(1:LNEWNU), CFMTXP) NEWNUM
C
C CHANGE THE BUFFER
                          INPCB = IPCB+IDNNUM
                          CBUFF(IROWCB) =
     1                          CBUFF(IROWCB)(1:IBCN-1)
     2                        //CNEWNU(1:LNEWNU)
     3                        //CBUFF(IROWCB)(INPCB:)
                          INPCB = IBCN + LNEWNU
                          IBCN  = 0
                          LCHANG = .TRUE.
                      END IF
C
C CAN'T USE THIS NUMBER ANYMORE
                  ELSE IF (CURCHA .NE. ' ') THEN
                      ICURNU = 0
                  END IF
              END IF
2000      CONTINUE
4000  CONTINUE
9900  CONTINUE
      RETURN
      END
CODE FOR XINSET
       SUBROUTINE XINSET
C
C     INITIALISE THE SET STACK.
C     A SET IS HELD AS A BINARY VECTOR OF LENGTH THE NUMBER OF NODES IN
C THE GRAPH CORRESPONDING TO THE STRUCTURE OR SUBSTRUCTURE.  EACH BIT
C CORRESPONDS TO A NODE, AND IS SET IF THE NODE HAS THE PARTICULAR
C PROPERTY GENERATING THE SET.
C     THE VECTORS ARE HELD AS DECIMAL INTEGERS.  BITS ARE SET BY ADDING
C THE APPROPRIATE POWER OF 2.  MORE THAN ONE INTEGER WILL BE NEEDED TO
C STORE THE SETS CORRESPONDING TO A STRUCTURE OF MORE THAN N1INT NODES.
C     SETS ARE GENERATED FOR SUPERSTRUCTURE AND ALL SUBSTRUCTURES.
C     THEY ARE HELD IN ADJACENT POSITIONS IN A STACK.
C
C AN ENTRY IN THE STACK (ONE ENTRY PER SET GENERATING PROPERTY):
C > FLAG INDICATING WHETHER THIS ENTRY CAN BE USED WITH THE CURRENT
C   STRUCTURE (EXPLAINED BELOW)
C > CARDINALITY OF SET OF A ATOMS WITH PROPERTY
C > FIRST INTEGER OF SET OF A ATOMS
C > ETC
C > CARDINALITY OF SET OF B ATOMS WITH PROPERTY
C > FIRST INTEGER OF SET OF B ATOMS
C > ETC
C HENCE MDSETS WILL DEPEND UPON THE NUMBER OF STRUCTURES BEING COMPARED,
C AND THEIR SIZE.
C
C MSETS  -->  0 IF THESE SETS CAN BE USED IN ANY STRUCTURE
C            -1 IF AS 0 BUT CONNECTIVITY HAS BEEN APPLIED
C             N IF STRUCTURE N WAS ASSUMED IN GENERATING THIS SET
C            -N AS N BUT CONNECTIVITY APPLIED
C THE FIRST ELEMENT OF ANY SET ENTRY, IF NON-ZERO, IS THE SERIAL NUMBER
C IN THE GENERAL STRUCTURE STACK OF THE STRUCTURE WITH WHICH IT CAN BE
C USED.  OTHERWISE, THIS ELEMENT IS ZERO.  THIS IS SO THAT THE SETS
C GENERATED WITH EARLIER STRUCTURES CAN BE USED WITH THE CURRENT
C STRUCTURE SO LONG AS THEY WERE NOT GENERATED BY USING THE COMPLEMENT
C OF AN APPROPRIATE SET, OR DERIVED (BY CONNECTIVITY) FROM SUCH A SET.
C
C GLOBAL VARIABLES:
C LSETS  = FIRST ADDRESS OF THE SETS STACK
C NSETS  = NUMBER OF SETS
C MDSETS = LENGTH OF AN ENTRY
C
C NSTRUC = TOTAL NUMBER OF STRUCTURES
C L1INT  = NUMBER OF BITS USED PER INTEGER (=31)
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
      LSETS  = NFL
      NSETS  = 0
      MDSETS = 1
C
C LOOP OVER THE STRUCTURES STORED
      DO 5000, MSTRUC = LSTRUC, LSTRUC+(MDSTRU*(NSTRUC-1)), MDSTRU
C
C CALCULATE NUMBER OF INTEGERS REQUIRED TO STORE A SET CORRESPONDING TO
C THIS STRUCTURE, INCLUDING ITS CARDINALITY.
      NNODES = ISTORE (MSTRUC)
      ISTORE (MSTRUC+15) = ((NNODES-1) / L1INT) + 2
      MDSETS = MDSETS + ISTORE (MSTRUC+15)
5000  CONTINUE
C
      RETURN
      END
CODE FOR XINSTR
      SUBROUTINE XINSTR ( NQUERY )
C
C INITIALIZE (AND ZEROISE) A LIST CONTAINING GENERAL INFO ABOUT THE
C STRUCTURES BEING CONSIDERED
C
C THE CURRENT FORMAT OF AN ENTRY IN THE GENERAL LIST IS:
C
C > NO OF NODES IN THE GRAPH CORRESPONDING TO THIS STRUCTURE
C > NO OF NODES OF THIS STRUCTURE AS YET UNASSIGNED (USED IF LOVERL
C   FALSE OR LMULTI TRUE)
C > ADDRESS OF THE FIRST ENTRY IN THE FIXED PART OF THE NODE LIST
C   DESCRIBING THE GRAPH
C > ADDRESS OF THE FIRST ENTRY OF THE AREA AT THE END OF THE GENERAL
C   STRUCTURE LIST HOLDING DETAILS OF THE ISOMORPHISMS (DESCRIBED IN
C   XCRLIF)
C > NO OF ISOMORPHISMS FOUND WITHIN THE SUPERSTRUCTURE FOR THIS SUBSTR
C > TYPE OF ACTION TO BE TAKEN ON FINDING THE ISOMORPHISM
C   1 = SIMPLY WRITE OUT DETAILS TO THE SCREEN
C > DETAILS OF WHAT TO DO WITH THE ISOMORPHISM (EG COMMANDS STORE)
C > DITTO (DESCRIBED IN       )
C > DITTO (DESCRIBED IN       )
C > TYPE OF ACTUAL STRUCTURE INFO (EG LIST 5 )
C   1 = LIST 5 ACTUAL
C   2 = LIST 10 ACTUAL
C   3 = SAME FORMAT AS LIST 5, BUT START AND NO OF ENTRIES MUST BE
C       SPECIFIED (MD5 STAYS THE SAME)
C   4 = SAME FORMAT AS LIST 10, BUT START AND NO OF ENTRIES MUST BE
C       SPECIFIED
C   5 = GRAPH LIST ONLY (FROM DATA FILE, FORMAT DESCRIBED IN XGRGEN)
C > DETAILS OF ACTUAL STRUCTURE INFO
C > DITTO (DESCRIBED IN XGRGEN)
C > DITTO (DESCRIBED IN XGRGEN)
C
C GLOBALS:
C LSTRUC = START OF STRUCTURES LIST
C NSTRUC = NUMBER OF STRUCTURES BEING CONSIDERED
C MDSTRU = LENGTH OF AN ENTRY
C
C LOCALS:
C NQUERY = NO OF QUERY STRUCTURES
C NROOM  = AMOUNT OF ROOM REQUIRED BY GEN STR LIST
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
      LSTRUC = NFL
C
C MAKE ROOM FOR THE GENERAL STRUCTURE LIST
      NSTRUC = NQUERY + 1
      NROOM  = NSTRUC * MDSTRU
      NFL = KCHNFL (NROOM)
C
      DO 1000, M = 1, NROOM
           ISTORE(LSTRUC+M-1) = 0
1000  CONTINUE
      RETURN
      END
CODE FOR XINTER
      SUBROUTINE XINTER (M1, M2, M3)
C
C DJK 17/12/91
C
C INTERSECTS THE SETS IN THE SET LIST ENTRY AT ISTORE ADDRESS M1 WITH
C THOSE AT M2 AND STORES THE RESULT AT M3.
C ANY OR ALL THREE OF M1, M2 AND M3 MAY BE EQUAL
C
C LOCALS:
C NBONDT = TOTAL NUMBER OF BONDS WHICH THE STRUCTURE STARTED OUT WITH
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
      MOFFSE = 1
C
      DO 2000, MSTRUC = LSTRUC, LSTRUC + (NSTRUC-1)*MDSTRU, MDSTRU
      NCARD  = 0
      NINTES = ISTORE (MSTRUC + 15)
      NBONDT = ISTORE (MSTRUC     )
C
C DO THE INTERSECTION FOR ALL SET-HOLDING INTEGERS EXCEPT THE LAST ONE
            DO 1000, I = 1, NINTES - 2
                  ISTORE (M3+MOFFSE+I)
     1          = KAND   (ISTORE(M1+MOFFSE+I),ISTORE (M2+MOFFSE+I))
C
C START CARDINALITY CALCULATION
                DO 500, J=0, L1INT-1
                      NPOWE2 = N2POWS(J)
                      IF (KAND(ISTORE(M3+MOFFSE+I), NPOWE2) .EQ. NPOWE2)
     1                                                 NCARD = NCARD + 1
500   CONTINUE
1000  CONTINUE
C
C DO THE INTERSECTION FOR THE LAST SET-HOLDING INTEGER
            ISTORE (M3+MOFFSE+I) =
     1      KAND ( ISTORE(M1+MOFFSE+I), ISTORE (M2+MOFFSE+I))
C
C CONTINUE CARDINALITY CALCULATION - DON'T LOOK AT THE EXCESS BITS AT
C THE END OF THE LAST INTEGER.
C
            DO 1500, J=0, MOD ((NBONDT-1), L1INT)
                  NPOWE2 = N2POWS(J)
                  IF (KAND(ISTORE(M3+MOFFSE+I), NPOWE2) .EQ. NPOWE2)
     1                                           NCARD = NCARD + 1
1500  CONTINUE
C
C STORE THE CARDINALITY.
      ISTORE (M3+MOFFSE) = NCARD
      MOFFSE = MOFFSE + NINTES
2000  CONTINUE
C
      RETURN
      END
CODE FOR XKNADD
      SUBROUTINE XKNADD(ICOMBF, MSTRUC, ISIZE, LFLPSE, NFLPSE)
C
C SAVE INFO ABOUT A 'KNOWN PAIR' BELOW LFLPSE AND STICK A POINTER TO
C THIS INFO IN THE GENERAL STRUCTURE LIST.
C SAVE AT LFLPSE END OF STORE:
C    QUERY NUMBER SPECIFIED OR IMPLIED
C    STRUCTURE ATOMIC SERIAL NUMBER SPECIFIED
C    QUERY ATOMIC SERIAL NUMBER SPECIFIED (IF ANY)
C    POINTER TO THE FIRST ITEM OF THE NEXT BLOCK OF KNOWN PAIR INFO
C
C THIS IS A CHAINED LIST WHEN IT'S READ IN TO ALLOW IT TO BE BUILT UP
C WHATEVER ORDER THE COMMANDS COME IN
C
C ICOMBF = BEGINNING OF AREA HOLDING INFO READ IN BY
C          PARAMETER READING ROUTINES
C ISIZE  = NO OF CHARACTERS IN FILENAME
C MSTRUC = POINTER TO CURRENT GENERAL STRUCTURE ENTRY
C
      CHARACTER *8 CFMTXP
      CHARACTER *80 CBUFF

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      COMMON/XCARDS/IMAGE(80),NC,ND,LASTCH,NI,NILAST,NS,MON,ICAT,
     2 IEOF,IHFLAG,NUSRQ,NREC,IPOSRQ,ITYPFL,INSTR,IDIRFL,IPARAM,IPARAD,
     3 NWCHAR , LCMAGE(80), IMNSRQ
C
C FREE SPACE FOR THE INFO
      ITOPIN = LFLPSE
      LFLPSE    = LFLPSE - 4
      IF ((LFLPSE-NFLPSE) .LE. 0) THEN
            NERRFI = 19
            GO TO 9900
      END IF
      MCHA   = ISTORE (MSTRUC+16)
      IF (MCHA .EQ. 0) THEN
C
C SAVE POINTER
            ISTORE (MSTRUC+16) = ITOPIN
      ELSE
C
C READ DOWN CHAINED LIST & SAVE POINTER IN LAST LINK
            DO 1000, M = 1, ISTORE(MSTRUC+17)
                  MCHA = ISTORE (MCHA-3)
1000        CONTINUE
            ISTORE (MCHA) = ITOPIN
      END IF
C
C QUERY, STRUCTURE ATOM, QUERY ATOM
C      ISTORE (ITOPIN  ) = ISTORE (ICOMBF+10)
      ISTORE (ITOPIN  ) = ISTORE (ICOMBF+11)
C
C THE FOLLOWING IS HERE UNTIL ATOM INTERPRETATION IS POSSIBLE
      ISTORE (ITOPIN-1) = -1
C WRITE THE ATOM INTO A BUFFER
      WRITE (CFMTXP, '(2H( , I2, 3HA1))') ISIZE
      WRITE (CBUFF(1:ISIZE),CFMTXP)(LCMAGE(J),J=NC,NC+ISIZE-1)
C      WRITE (6, *) ' FROM XKNADD: ', CBUFF(1:ISIZE)
C      ISTORE (ITOPIN-2) = ISTORE (ICOMBF+11)
      ISTORE (ITOPIN-2) = ISTORE (ICOMBF+12)
C      WRITE (6, '(I7, A7)') ITOPIN, ' KNOWN '
C      WRITE (6, '(I7, A7)') (ITOPIN - 1), ' KNOWN '
C      WRITE (6, '(I7, A7)') (ITOPIN - 2), ' KNOWN '
C      WRITE (6, '(I7, A7)') (ITOPIN - 3), ' KNOWN '
C
C INCREMENT THE NUMBER OF KNOWN PAIRS
      ISTORE (MSTRUC+17) = ISTORE(MSTRUC+17) + 1
      NC = LASTCH + 1
9900  CONTINUE
      RETURN
      END
CODE FOR XL5TOA
      SUBROUTINE XL5TOA(NCHLIS,L5USED,N5USED,NNODES,LNODES,LATS,NATS,
     1                  MDATS)
C
C BUILD A GRAPH CONSISTING OF NODES CORRESPONDING TO ATOMS
C
C LOCALS:
C  IPERNO = ITEMS OF INFO PER NODE OF GRAPH
C  ITOMOV = OFFSET OF THE TEMPORARY STORE OF THE NODE INFO FROM ITS
C           FINAL LOCATION.
C  NTOMOV = NUMBER OF ITEMS OF INFORMATION TO MOVE
C  ILOINF = LOWEST ADDRESS OF NODE INFO (AFTER MOVING)
      DIMENSION ICOM12(40)
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
      COMMON/XDSTNC/AT,AC,BT,BC,BP,AP,AO,IDIST,LBOX,MBOX,MDBOX,NBOX,
     2 LFNVC,MFNVC,MDFNVC,NFNVC,MFNVCA
\XUNITS
\XSSVAL
\XLISTI
\XCONST
\XCHARS
\XLEXIC
\XWORKA
\XLST01
\XLST02
\XLST05
\XLST12
\XERVAL
\XOPVAL
C
      EQUIVALENCE (L12,ICOM12(1))
C
C GET PARAMETERS FOR THE DISTANCE SEARCH
      D12    = RMAXDI()
      IF (NERRFI .GT. 0) GO TO 9900
      DMIN12 = RMINDI()
      IF (NERRFI .GT. 0) GO TO 9900
      D12S = D12*D12
      D12MS  = DMIN12*DMIN12
      IF (NERRFI .GT. 0) GO TO 9900
C
C IPERNO = NO OF ITEMS OF INFO PER NODE.
      IPERNO = 7
      JT=12
      BMAX = D12
C      AT = 0.5
      AT = DMIN12
      AC = D12
C--SET THE INPUT PARAMETER DEFAULTS
      SX=1.0
      JS=0
      JZ=0
C----- LOAD LISTS 1 AND 2, AND SET UP SOME CONSTANTS
       CALL XDIST2
       IF ( IERFLG .LT. 0 ) THEN
              NERRFI = 3
              GO TO 9900
       END IF
C--SET THE DIMENSION OF THE COMMON BLOCK FOR LIST 12
      IDIM12=40
C--INDICATE THAT LIST 12 IS NOT TO BE USED
      DO 1050 I=1,IDIM12
      ICOM12(I)=NOWT
1050  CONTINUE
      L12=-1
      M12=-1
C
C COPY THE INFO INTO THE FIXED PART
C--SET UP A FEW CONSTANTS
      JB=NFL
      JC=JB+MD5
      JD=JC+20
      JE=JD+30
C--CHECK THE STORE AREA
      IF ( JE .GE. LFL ) THEN
            NERRFI = 10
            GO TO 9900
      END IF
C
C----- FIX THE RADII FOR 1-2 CONTACTS
      AC = D12
      AO = D12
      AP = D12S
      BP = D12MS
C
C RESTRICT TO NO TRANSLATION FOR NOW
C      ITRANS = -1
      IF (LEXTEN) THEN
          ITRANS = 0
      ELSE
          ITRANS = -1
      END IF
C
C----- SET THE TARGET ATOM ADDRESSES
      MATOM = 0
      IN    = N5USED
C
C ZCOIN = DISTANCE FOR THINGS TO BE COINCIDENT (ZERO IS TOO SMALL)
      ZCOIN = 0.001
C
C KDIST1 USES UP TO JE AS WORKSPACE.
      NFL = JE
      L5TMP = JE
C ADD IEXTE TO ALLOW IEXTE/2 EXTENSIONS TO LIST 5
C AN EXTENSION TAKES UP 14 (MD5) SLOTS
C CURRENT SIZE OF ENTRY IN KDIST1 STACK IS 12 SLOTS
C HENCE IF THE STACK STARTS IMMEDIATELY AFTER THE EXTENDABLE LIST 5,
C 2 SLOTS WOULD BE OVERWRITTEN.
      IF (MAXEXT .NE. 0) THEN
          IEXTE = MAXEXT*2
      ELSE
          IEXTE = N5*2
      END IF
C
C LEXTE POINTS TO THE START OF THE EXTENSION
      LEXTE = 0
      NFL =  KCHNFL(N5USED*MD5+IEXTE)
      M5A   = L5TMP
      M5    = L5TMP
C
C LIKEWISE FOR BOND INFO
      LBONDS = LFL
      LFL = LFL - 1
      ISTORE(LBONDS) = 0
      MBONDS = LBONDS
C
C PERTURBATION CODE HERE TO AVOID SETTING UP COMMAND LINE ETC
C - ONLY RUN IT IF A FILE 'PERTURB' EXISTS
      INQUIRE (FILE='PERTURB', EXIST=LPERT)
      IF (LPERT) THEN
          OPEN (NCHPER, FILE='PERTURB', IOSTAT=IERR)
          IF (IERR .GT. 0) THEN
              WRITE (NCAWU, '(A7,I3)') 'IOSTAT=', IERR
              GO TO 9900
          END IF
C          CALL XPERT
          IF (NERRFI .GT. 0) GO TO 9900
      END IF
C
C MAKE A COPY OF L5
C + SET UP A CHAINED LIST BELOW LFL FOR THE ATOM INFO
      LFLSAV = LFL
      MDATFO = IPERNO+1
      LATFOU = KCHLFL(MDATFO)
      MATFOU = LATFOU
C
      DO 2000, MTMP = 1, N5USED*MD5, MD5
          DO 1900, MMTMP = 1, MD5
              ISTORE(L5TMP+MTMP+MMTMP-2) = ISTORE(L5+MTMP+MMTMP-2)
1900      CONTINUE
C
C ADDRESS IN THE TEMPORARY LIST 5
          ISTORE(MATFOU+1) = L5TMP+MTMP-1
C SYMMETRY STUFF
          ISTORE(MATFOU+2) = 1
          ISTORE(MATFOU+3) = 1
          ISTORE(MATFOU+4) = 0
          ISTORE(MATFOU+5) = 0
          ISTORE(MATFOU+6) = 0
C
          ISTORE(MATFOU+7) = L5TMP+MTMP-1
C
C MARK THE END OF THE LIST
          IF (MTMP .LT. (1+(N5USED-1)*MD5)) THEN
              ISTORE(MATFOU  ) = KCHLFL(MDATFO)
              MATFOU = ISTORE(MATFOU)
          ELSE
              MLAST = MATFOU
              ISTORE(MATFOU) = 0
          END IF
2000  CONTINUE
C
      L5SAV  = L5
      L5     = L5TMP
C      M5     = M5A
C      M5 = L5
C
C     LOOPS BACK TO 2500 UNTIL MATOM=N5
2500  CONTINUE
      LDISTA = NFL
      JS     = NFL
C
C LOCATE PIVOT ATOM IN THE CHAINED ATOM LIST
      MPIVOT = LATFOU
2550  CONTINUE
      IF (MPIVOT .NE. 0) THEN
          IF (ISTORE(MPIVOT+7).EQ.M5A) THEN
              GO TO 2560
          ELSE
              MPIVOT = ISTORE(MPIVOT)
              GO TO 2550
          END IF
      ELSE
C             NERRFI = NERRFI_SHOULD_BE_THERE_BUT_ISN'T
          NERRFI = 155
          GO TO 9900
      END IF
2560  CONTINUE
C
C --  COMPUTE DISTANCE STACK
      NDISTA = KDIST1( IN, JS, JT, 0, TOLER, ITRANS)
      NFL    = JS
C
      IF (NDISTA .GT. 0) THEN
C
C THERE ARE SOME CONNECTIONS TO THIS ATOM
C          WRITE (6,*) '-------------------------'
          DO 3000, MDISTA = LDISTA, LDISTA + (NDISTA-1)*JT, JT
C          WRITE (6, '(12I8)')   (ISTORE(I+MDISTA-1), I=1,12)
C          WRITE (6, '(12F8.2)') (STORE(I+MDISTA-1), I=1,12)
C
              IF ((ISTORE(MDISTA+2) .NE. 1) .OR.
     1            (ISTORE(MDISTA+3) .NE. 1) .OR.
     2            (ISTORE(MDISTA+4) .NE. 0) .OR.
     3            (ISTORE(MDISTA+5) .NE. 0) .OR.
     4            (ISTORE(MDISTA+6) .NE. 0)) THEN
C
C LOOK FOR THE TRANSFORMED ATOM IN THE CHAINED LIST
                  MATFOU = LEXTE
2600              CONTINUE
                  IF (MATFOU .NE. 0) THEN
C CHECK IT OUT - SAME ATOM + SYMMETRY OPS ETC?
                      IF ((ISTORE(MATFOU+1) .EQ. ISTORE(MDISTA))
     1              .AND. (ISTORE(MATFOU+2) .EQ. ISTORE(MDISTA+2))
     2              .AND. (ISTORE(MATFOU+3) .EQ. ISTORE(MDISTA+3))
     3              .AND. (ISTORE(MATFOU+4) .EQ. ISTORE(MDISTA+4))
     4              .AND. (ISTORE(MATFOU+5) .EQ. ISTORE(MDISTA+5))
     5              .AND. (ISTORE(MATFOU+6) .EQ. ISTORE(MDISTA+6)))THEN
C DON'T ADD TO LIST 5, LEAVE LINKED LIST
                          MOTHER = MATFOU
                          GO TO 2900
                      END IF
                      MLAST  = MATFOU
                      MATFOU = ISTORE(MATFOU)
                      GO TO 2600
                  ELSE
C BOTTOM OF LIST - ADD A NEW ENTRY IF THERE'S ROOM
                      IF (LEXTEN .AND.
     1                    (N5 .LT. (N5USED+IEXTE/2))) THEN
C
C SECOND ATOM HAS HAD TO BE MOVED - ADD THE TRANSFORMED
C VERSION TO THE END OF LIST 5
                          DO 2800, MTMP = 1, MD5
C
C ALL MD5 ITEMS FROM THE L5 ENTRY
                             ISTORE(L5+MD5*N5+MTMP-1)
     1                      = ISTORE(ISTORE(MDISTA)+MTMP-1)
2800                      CONTINUE
C
C NEW COORDINATES FROM THE DISTANCE STACK
                          ISTORE(L5+MD5*N5+4) = ISTORE(MDISTA+7)
                          ISTORE(L5+MD5*N5+5) = ISTORE(MDISTA+8)
                          ISTORE(L5+MD5*N5+6) = ISTORE(MDISTA+9)
                          N5 = N5 + 1
C
C SORT OUT THE CHAINED LIST BELOW LFL
                          MATFOU = MLAST
                          ISTORE(MATFOU) = KCHLFL(MDATFO)
                          MATFOU = ISTORE(MATFOU)
                          ISTORE(MATFOU)   = 0
                          ISTORE(MATFOU+1) = ISTORE(MDISTA  )
                          ISTORE(MATFOU+2) = ISTORE(MDISTA+2)
                          ISTORE(MATFOU+3) = ISTORE(MDISTA+3)
                          ISTORE(MATFOU+4) = ISTORE(MDISTA+4)
                          ISTORE(MATFOU+5) = ISTORE(MDISTA+5)
                          ISTORE(MATFOU+6) = ISTORE(MDISTA+6)
                          ISTORE(MATFOU+7) = L5 + MD5*(N5-1)
                          IF (LEXTE .EQ. 0) LEXTE = MATFOU
                          MOTHER = MATFOU
                      END IF
                  END IF
              ELSE
C ALL THESE WERE ADDED IN A CONTIGUOUS AREA OF MEMORY
                  MOTHER = LATFOU-((ISTORE(MDISTA)-L5)*MDATFO/MD5)
              END IF
2900      CONTINUE
C
C ADD BOND INFO NOW
          IF (STORE(MDISTA+10) .GT. ZCOIN) THEN
              ISTORE(MBONDS)   = KCHLFL(4)
              MBONDS = ISTORE(MBONDS)
              ISTORE(MBONDS+1) = MPIVOT
              ISTORE(MBONDS+2) = MOTHER
              ISTORE(MBONDS+3) = ISTORE(MDISTA+10)
              ISTORE(MBONDS) = 0
          END IF
3000      CONTINUE
      END IF
C
C--UPDATE FOR THE NEXT TARGET ATOM.
      M5A = M5A + MD5
      MATOM = MATOM + 1
C
C----RESET BEGINNING OF DISTANCE STACK
      NFL   = L5 + N5*MD5 + IEXTE
C      NFL   = JE
C      M5    = L5
      M5    = L5TMP
C
C----END OF LOOP ?
      IF (MATOM  .LT. N5) GOTO 2500
C
C READ THROUGH ATOM LIST ONCE MORE CONVERTING ALL LIST 5 ADDRESSES
C TO SERIAL NUMBERS FROM LIST 5
      MATFOU = LATFOU
      NATTMP = 0
6000  CONTINUE
      IF (MATFOU .GT. 0) THEN
          NATTMP = NATTMP + 1
          ISTORE(MATFOU+1) = 1+ (ISTORE(MATFOU+1) - L5)/MD5
C          WRITE (6,*) 'LIST 5:',ISTORE(MATFOU+1)
          MATFOU = ISTORE(MATFOU)
          GO TO 6000
      ELSE
          IF (NATTMP .NE. N5) THEN
C NERRFI = NERRFI_ERROR_CONSTRUCTING_ATOM_GRAPH
              NERRFI = 156
              GO TO 9900
          END IF
      END IF
C
C CONVERT THESE LISTS TO GRAPHS
      NNODES = N5
C
C RESET
      NFL = L5
      L5 = L5SAV
      N5 = N5USED
C
      CALL ALTOG(LATFOU, LBONDS, LNODES, NNODES,IPERAT)
      IF (NERRFI .GT. 0) GO TO 9900
C
C SAVE THE ADDRESS OF THE NODE LIST FOR THIS STRUCTURE IN THE
C GENERAL STRUCTURE LIST
C      ISTORE (LSTRUC+2) = LNODES
C
C SAVE THE NUMBER OF NODES IN THE GENERAL STRUCTURE LIST
C      ISTORE (LSTRUC) = NNODES
C      ISTORE (LSTRUC+1) = NNODES
C
      LATS = ISTORE(LNODES+2)
      NATS = NNODES
      MDATS = IPERAT
C
9900  CONTINUE
      LFL = LFLSAV
      RETURN
      END
CODE FOR XL5TOB
      SUBROUTINE XL5TOB(NCHLIS,L5USED,N5USED,NNODES,LNODES)
C
C BUILD A GRAPH CONSISTING OF NODES CORRESPONDING TO INTERATOMIC
C DISTANCES.
C
C LOCALS:
C  IPERNO = ITEMS OF INFO PER NODE OF GRAPH
C  ITOMOV = OFFSET OF THE TEMPORARY STORE OF THE NODE INFO FROM ITS
C           FINAL LOCATION.
C  NTOMOV = NUMBER OF ITEMS OF INFORMATION TO MOVE
C  ILOINF = LOWEST ADDRESS OF NODE INFO (AFTER MOVING)
      DIMENSION ICOM12(40)
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
      COMMON/XDSTNC/AT,AC,BT,BC,BP,AP,AO,IDIST,LBOX,MBOX,MDBOX,NBOX,
     2 LFNVC,MFNVC,MDFNVC,NFNVC,MFNVCA
\XUNITS
\XSSVAL
\XLISTI
\XCONST
\XCHARS
\XLEXIC
\XWORKA
\XLST01
\XLST02
\XLST05
\XLST12
\XERVAL
\XOPVAL
C
      EQUIVALENCE (L12,ICOM12(1))
C
C ASSUMING THAT GPDENS AT 4 ESD'S FROM THE MEAN = ENOUGH
C
C GET PARAMETERS FOR THE DISTANCE SEARCH
      D12  = RMAXDI()
      IF (NERRFI .GT. 0) GO TO 9900
      D12S = D12*D12
C
C IF DOING ANOTHER TYPE OF GRAPH (EG ATOM) USING THIS CODE, MAY NEED
C TO CHANGE IPERNO
      IPERNO = 8
      JT=12
      BMAX = D12
      AT = 0.5
      AC = D12
C--SET THE INPUT PARAMETER DEFAULTS
      SX=1.0
      JS=0
      JZ=0
C----- LOAD LISTS 1 AND 2, AND SET UP SOME CONSTANTS
       CALL XDIST2
       IF ( IERFLG .LT. 0 ) THEN
              NERRFI = 3
              GO TO 9900
       END IF
C--SET THE DIMENSION OF THE COMMON BLOCK FOR LIST 12
      IDIM12=40
C--INDICATE THAT LIST 12 IS NOT TO BE USED
      DO 1050 I=1,IDIM12
      ICOM12(I)=NOWT
1050  CONTINUE
      L12=-1
      M12=-1
C--SET UP A FEW CONSTANTS
      JB=NFL
      JC=JB+MD5
      JD=JC+20
      JE=JD+30
C--CHECK THE STORE AREA
      IF ( JE .GE. LFL ) THEN
            NERRFI = 10
            GO TO 9900
      END IF
C
C----- FIX THE RADII FOR 1-2 CONTACTS
      AC = D12
      AO = D12
      AP = D12S
C
C----- SET THE TARGET ATOM ADDRESSES
      MATOM = 0
C      M5A   = L5
      M5A   = L5USED
C      IN    = N5
      IN    = N5USED
C
C----SET BEGINNING OF DISTANCE STACK TO JE + MDNODE, TO AVOID ANY
C ATTEMPT TO USE THE ADDRESSES NEEDED BY THE NODE LIST
C KDIST1 USES UP TO JE AS WORKSPACE.  WHEN USING THE STACK,
C THE MINIMUM LENGTH OF A STACK ENTRY > MDNODE, SO WRITING ANOTHER
C NODE ENTRY WON'T OVERWRITE THE BITS OF THE STACK STILL TO BE
C READ.
      NFL    = JE + MDNODE
      LNODES = JE
      M5     = M5A
      MNODES = LNODES
      NNODES = 0
C
C SAVE THE ADDRESS OF THE NODE LIST FOR THIS STRUCTURE IN THE
C APPROPRIATE SLOT IN THE GENERAL STRUCTURE LIST
C      ISTORE (LSTRUC+2) = LNODES
C     LOOPS BACK TO 2500 UNTIL MATOM=N5
2500  CONTINUE
      LDISTA = NFL
      JS     = NFL
C
C --  COMPUTE DISTANCE STACK
      NDISTA = KDIST1( IN, JS, JT, 0, TOLER, ITRANS)
      NFL    = JS
C
      IF (NDISTA .GT. 0) THEN
C
C THERE ARE SOME CONNECTIONS TO THIS ATOM
C MAKE ROOM FOR THE INFO ABOUT THESE ATOMS, BELOW LFL
C IN THIS (THE BOND GRAPH) CASE THERE ARE 8 ITEMS PER NODE
            MINFO = LFL + 1
            LFL = KCHLFL ( NDISTA * IPERNO ) - 1
            NNODES = NNODES + NDISTA
C
C ADD THESE NODES TO THE NODE LIST
            DO 3000, MDISTA = LDISTA, LDISTA + (NDISTA-1)*JT, JT
                  MINFO  = MINFO  - IPERNO
C
C ZEROISE THE INFORMATION ABOUT CONNECTED BONDS
                  ISTORE (MNODES  ) = 0
                  ISTORE (MNODES+1) = 0
C
C SAVE THE LOWEST ADDRESS CONTAINING INFO ABOUT THIS NODE
                  ISTORE (MNODES+2) = MINFO
C
C SAVE THE HIGHEST ADDRESS CONTAINING INFO ABOUT THIS NODE
                  ISTORE (MNODES+3) = IPERNO
                  IF (NCHLIS .EQ. 1) THEN
C
C LIST 5 SERIAL NUMBERS MAY NEED HERE TO BE CONVERTED BACK TO REAL
C SERIAL NUMBERS + SYMMETRY OPS IF THE LIST 5 WAS EXTENDED BY SYMMETRY
C WHATEVER HAPPENS, THE FIRST TWO SLOTS MUST HOLD THE SERIAL NUMBERS
C THE LIST 5 SERIAL NUMBER OF THE FIRST ATOM (THE PIVOT ATOM IN THE
C DISTANCE CALCULATION)
                  ISTORE (MINFO) = 1+((M5A-L5)/MD5)
C
C THE LIST 5 SERIAL NUMBER OF THE SECOND ATOM
                  ISTORE (MINFO+1) = 1+((ISTORE (MDISTA)-L5)/MD5)
                  ELSE
C
C STORE DIFFERENT INFO IF THE LIST WAS A SELECTION OF LIST 5
C IE DO A CONVERSION BACK TO LIST 5 SERIAL NUMBERS FROM THE
C SUBSET SERIAL NUMBERS
C                        NERRFI = NERRFI_CANT_DO_YET
                        NERRFI = 34
                        GO TO 9900
                  END IF
C
C THE BOND LENGTH
                   STORE (MINFO+2) = STORE (MDISTA+10)
C
C ASSUME THAT THE LIST 5 BEING WORKED ON HAS ALL THE SYMMETRY
C INFO IN IT ALREADY.
C
C THE SYMMETRY INFO FOR THE SECOND ATOM
C                  DO 2900, I = 1, 5
C                        ISTORE (MINFO+2+I) = ISTORE (MDISTA+1+I)
C2900  CONTINUE
                  MNODES = MNODES + MDNODE
3000  CONTINUE
      END IF
C
C--UPDATE FOR THE NEXT TARGET ATOM.
      M5A = M5A + MD5
      MATOM = MATOM + 1
C
C LOOK FOR BONDS ONLY TO ATOMS NOT YET USED AS PIVOT ATOMS - TO AVOID
C FINDING THE SAME BOND TWICE
      IN = IN - 1
C
C----RESET BEGINNING OF DISTANCE STACK
      NFL   = LNODES + (NNODES+1)*MDNODE
      M5    = M5A
C
C----END OF LOOP ?
      IF (MATOM .LT. N5) GOTO 2500
      NFL   = NFL - MDNODE
C
C SAVE THE NUMBER OF NODES IN THE GENERAL STRUCTURE LIST
C      ISTORE (LSTRUC) = NNODES
C      ISTORE (LSTRUC+1) = NNODES
C
C CALCULATE THE CONNECTIVITY INFO.
      CALL XFBTOC (LNODES, NNODES)
C
C MOVE THE INFO DOWN TO JUST ABOVE THE GRAPH OF THIS STRUCTURE.
C DO THIS USING THE OFFSET RATHER THAN PIECE BY PIECE
C THIS WILL RESULT IN THE ORDER OF THE INFO BEING OPPOSITE TO THAT OF
C THE NODES IN THE FIXED PART, BUT THE ADDRESSES ARE THERE ANYWAY,
       NTOMOV = NNODES * IPERNO
       ITOMOV = LFL - NFL + 1
       ILOINF = KSTALL (NTOMOV)
       CALL XMOVE (STORE(LFL+1), STORE(ILOINF), NTOMOV)
       LFL    = LFL + NTOMOV
C
C NOW NEED TO DECREMENT THE POINTERS IN THE BOND STACK BY THE OFFSET
C ITOMOV.
      DO 8000, MNODES = LNODES, LNODES + ((NNODES-1)*MDNODE), MDNODE
            ISTORE (MNODES+2) = ISTORE (MNODES+2) - ITOMOV
8000  CONTINUE
C
9900  CONTINUE
      RETURN
      END
CODE FOR XL5TOG
      SUBROUTINE XL5TOG (NCHLIS, LNODES, NNODES, LATS, NATS,MDATS)
C
C TAKES A LIST 5 AND GENERATES A GRAPH FROM IT
C ACTION DEPENDS ON WHAT TYPE OF GRAPH IS REQUIRED
C INTYPE = 1    'ATOM' GRAPH REQUIRED ( NODES = ATOMS )
C          2    'BOND' GRAPH REQUIRED ( NODES = BONDS )
C
C NCHLIS = 1    LIST 5 WHOLE INPUT
C        = 2    LIST 10 WHOLE INPUT
C        = 3    CSD-TYPE FILE
C (ALSO TREAT LIST 5 SELECTION HERE)
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
\XLST05
      COMMON/XLST10/L10,M10,MD10,N10,L10A,M10A,MD10A,N10A
C
C MNODES   --> ADDRESS OF FIRST CONNECTION TO THIS NODE
C MNODES+1 --> NUMBER OF CONNECTIONS TO THIS NODE
C MNODES+2 --> ADDRESS OF BEGINNING OF INFO ABOUT THIS NODE
C MNODES+3 --> NUMBER OF ITEMS OF INFO ABOUT THIS NODE
C
      IF (NCHLIS .EQ. 1) THEN
            L5USED = L5
            N5USED = N5
      ELSE IF (NCHLIS .EQ. 2) THEN
C                  NERRFI = NERRFI_CANT_DO_YET
            NERRFI = 35
            GO TO 9900
      ELSE
C
C STICK CODE IN HERE FOR THE SELECTION OF LIST 5/10
C - IE MAYBE CREATE A NEW LIST, CONTIGUOUS WITH JUST THE SELECTED
C ATOMS IN - USE OTHER VALUES OF NCHLIS TO ACCESS THIS
C LIKEWISE STICK CODE IN FOR HANDLING ATOMS FROM A DATA FILE
C                  NERRFI = NERRFI_CANT_DO_YET
            NERRFI = 36
            GO TO 9900
      END IF
      IF ( INTYPE .EQ. 1 ) THEN
C
C EACH NODE CORRESPONDS TO AN ATOM
C NODE INFO WILL BE OF THE FORM:
C LOW ADDRESSES:
C      LIST 5 ADDRESS OF THE FIRST ATOM (AT ISTORE(ISTORE(MDNODE+2)))
C      S
C      NPLI
C      T(X)
C      T(Y)
C      T(Z)                             (AT ISTORE(ISTORE(MDNODE+3)))
C HIGH ADDRESSES
C THIS ORDER IS MAINTAINED WHEREVER THIS INFO IS STORED
C
       CALL XL5TOA (NCHLIS,L5USED,N5USED,NNODES,LNODES,LATS,NATS,MDATS)
            IF (NERRFI .NE. 0) GO TO 9900
      ELSE IF ( INTYPE .EQ. 2) THEN
C
C EACH NODE WILL CORRESPOND TO A PAIR OF ATOMS.
C FOR THIS TYPE OF GRAPH, STORE THEM IN THE
C ADDRESSES POINTED TO BY ISTORE (MNODE+2) --> ISTORE (MNODE+3).
C INITIALLY PUT THIS INFO BELOW LFL (TO KEEP IT OUT OF THE WAY)
C THEN TRANSFER IT DOWN TO THE AREA DIRECTLY AFTER THE GRAPH.
C THIS AREA WILL CONTAIN:
C LOW ADDRESSES:
C      LIST 5 ADDRESS OF THE FIRST ATOM (AT ISTORE(ISTORE(MDNODE+2)))
C      LIST 5 ADDRESS OF THE SECOND ATOM
C      DISTANCE
C      S
C      NPLI
C      T(X)
C      T(Y)
C      T(Z)                             (AT ISTORE(ISTORE(MDNODE+3)))
C HIGH ADDRESSES
C THIS ORDER IS MAINTAINED WHEREVER THIS INFO IS STORED
C
            CALL XL5TOB (NCHLIS,L5USED,N5USED,NNODES,LNODES)
            IF (NERRFI .NE. 0) GO TO 9900
      ELSE
           NERRFI = 5
           GO TO 9900
      END IF
9900  CONTINUE
      RETURN
      END
CODE FOR XNOCC
      SUBROUTINE XNOCC (CBUFF, NROWCB, NCURRE)
C
C CBUFF  = THE BUFFER BEING OPERATED ON
C NROWCB = NUMBER OF LINES IN CBUFF
C NCURRE = THE NUMBER OF THE CURRENT OCCURRENCE AS CALCULATED IN XPSTOS
C CONVERT THE OCCURRENCE FLAGS INTO NUMBERS
C
C SCANS EACH LINE OF CBUFF & REPLACES EACH OCCURRENCE OF '*NOCC' (OR
C WHATEVER THAT'S BEEN CHANGED TO) WITH THE INTEGER VALUE OF NCURRE.
C NO EXPANSION OF THE LINE IS CATERED FOR, SO (IN THE CASE OF *NOCC)
C ONLY 5-DIGIT OCCURRENCE NUMBERS WILL FIT IN.  SO, IF YOU HAVE A
C FRAGMENT THAT OCCURS MORE THAN 99999 TIMES (EG EVERY BOND IN A
C 100000 - BOND STRUCTURE) THEN NERRFI = 53 IS GIVEN, ALTHOUGH YOU
C COULD CHANGE THAT HERE IF IT BECOMES A REGULAR PROBLEM.
C
C MODIFIED TO ALSO HANDLE *MAXS - THE MAXIMUM SERIAL NUMBER IN THE
C STRUCTURE
      CHARACTER*(*) CBUFF(NROWCB)
      CHARACTER*4   CFMTXP

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      IF ((NCURRE .LE. 0) .OR. (NCURRE .GT. 99999)) THEN
C NERRFI = NERRFI_OCCURRENCE_NO_OUT_OF_BOUNDS
            NERRFI = 53
            GO TO 9900
      END IF
C
C DEFAULT FLAG FOR OCCURRENCE NUMBER CAN BE CHANGED IN FINDBD
      LCBUFF = LEN (CBUFF(1))
      LCNOCC = LEN (CNOCC)
C
C SORT OUT THE FORMAT FOR THE WRITES
      RNCURR = REAL (NCURRE)
      CFMTXP = '(I )'
      WRITE (CFMTXP(3:3), '(I1)' ) (1+INT(ALOG10(RNCURR)))
      DO 2000, MBUFF = 1, NROWCB
1000  CONTINUE
            INDNOC = INDEX(CBUFF(MBUFF), CNOCC)
            IF (INDNOC .GT. 0) THEN
C FILL IT WITH BLANKS
                  CBUFF(MBUFF)(INDNOC:(INDNOC+LCNOCC-1)) = ' '
C WRITE THE NUMBER
                  WRITE (CBUFF(MBUFF)(INDNOC:(INDNOC+LCNOCC-1)),
     1                  CFMTXP) NCURRE
C REMOVE REDUNDANT SPACES INTRODUCED WITH THE NUMBER
                  CALL XCREMS (CBUFF(MBUFF), CBUFF(MBUFF), LCBUFF)
                  GO TO 1000
            END IF
2000  CONTINUE
C
C DEFAULT FLAG FOR OCCURRENCE NUMBER CAN BE CHANGED IN FINDBD
      LCNOCC = LEN (CMAXS)
C
C SORT OUT THE FORMAT FOR THE WRITES
      CFMTXP = '(I )'
      WRITE (CFMTXP(3:3), '(I1)' ) (1+INT(ALOG10(RMAXSE)))
      NMAXSE = NINT(RMAXSE)
      DO 4000, MBUFF = 1, NROWCB
3000  CONTINUE
            INDNOC = INDEX(CBUFF(MBUFF), CMAXS)
            IF (INDNOC .GT. 0) THEN
C FILL IT WITH BLANKS
                  CBUFF(MBUFF)(INDNOC:(INDNOC+LCNOCC-1)) = ' '
C WRITE THE NUMBER
                  WRITE (CBUFF(MBUFF)(INDNOC:(INDNOC+LCNOCC-1)),
     1                  CFMTXP) NMAXSE
C REMOVE REDUNDANT SPACES INTRODUCED WITH THE NUMBER
                  CALL XCREMS (CBUFF(MBUFF), CBUFF(MBUFF), LCBUFF)
                  GO TO 3000
            END IF
4000  CONTINUE
9900  CONTINUE
      RETURN
      END
CODE FOR XNOTOP
      SUBROUTINE XNOTOP (IOPTIO, MSTRUC)
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C      WRITE (6, *) ' FROM XNOTOP: IOPTIO, MSTRUC ', IOPTIO, MSTRUC
C      WRITE (6, *) ' '
C
C OPTIONS ARE HELD AS A BINARY VECTOR IN THE INTEGERS MSTRUC+16...
C IF BIT N IS SET, APPLY OPTION N FOR THIS QUERY.
C INTEGERS ARE INITIALISED SO THAT ALL BITS ARE SET.
C ONLY THE 31 BITS ACCESSIBLE BY MATHEMATICAL OPS ARE USED IN ANY
C ONE INTEGER IN THIS AREA.
C GIVEN THE INTEGER WITH ONLY BIT IOPTIO SET, AND THE INTEGER YOU
C WANT TO UNSET IT IN, YOU NEED THE FOLLOWING TRUTH TABLE:
C BIT FROM THE INTEGER THERE 1 0 1 0
C BIT FROM IOPTIO            1 1 0 0
C DESIRED EFFECT             0 0 1 0
C THIS IS ACHIEVED USING
C (BIT FROM INTEGER THERE .AND. (.NOT. (INTEGER WITH IOPTIO BIT SET))
C
C CHECK IF ALL THE OPTIONS ARE FLAGGED
C      LOPTI  = MSTRUC+18
      LOPTI  = MSTRUC+19
C
C WORK OUT THE ADDRESS OF THE INTEGER TO CHANGE
      ICHANG = LOPTI + IOPTIO/(L1INT+1)
C
C WORK OUT THE INTEGER FOR THE CURRENT OPTION 'IOPTIO'
      INUMBE = MOD ((IOPTIO-1), L1INT)
      INUMBE = N2POWS(INUMBE)
C
      INUMBE = KKNOT (INUMBE)
      ISTORE (ICHANG) = KAND ( ISTORE(ICHANG), INUMBE)
C      WRITE (6,*) (ISTORE(MOPTI), MOPTI=LOPTI,LOPTI+NCPCKT-1)
C      WRITE (6, *) ' '
      RETURN
      END
CODE FOR XNPA
      SUBROUTINE XNPA (LPSTT, ISTA, IQTA)
C
C WORKS OUT THE NEXT POSSIBLE ASSIGNMENT TO MAKE ON A PS.
C
C LPSTT = BEGINNING OF THE PS
C ISTA  RETURNED AS THE NODE OF THE STRUCTURE SET THAT CAN BE ASSIGNED
C IQTA  RETURNED AS THE QUERY NODE TO BE ASSIGNED

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      IQTA   = 0
C
C LOOP OVER THE PS
      DO 3000, M = LPSTT, LPSTT+(NNODEQ*MDSETS), MDSETS
C
C CHECK FOR STRUCTURE SETS OF CARDINALITY > 1.  USE THE FIRST ONE OF
C THESE TO MAKE AN ASSIGNMENT.
            ICARDS = ISTORE(M+1)
            IF      (ICARDS .GT. 1) THEN
                 IQTA   =  ((M - LPSTT) /MDSETS) + 1
C
C NOW LOCATE THE STRUCTURE NODE
                 DO 2000, MSTR = 1, NINTSU-1
                       NTMP  = ISTORE (M+MSTR+1)
                       IF (NTMP .GT. 0) THEN
                             DO 1000, MBITS=1, L1INT
                                   NTMP2 = N2POWS(MBITS-1)
                                   IF (KAND(NTMP2,NTMP).EQ.NTMP2)THEN
                                      ISTA = ((MSTR-1)*L1INT)+MBITS
                                        GO TO 4000
                                   END IF
1000                         CONTINUE
                       END IF
2000             CONTINUE
            ELSE
                 IF (ICARDS .EQ. 0) GO TO 4000
            END  IF
3000  CONTINUE
4000  CONTINUE
      RETURN
      END
CODE FOR XOADD
      SUBROUTINE XOADD(ICOMBF, MSTRUC, ISIZE, LFLPSE, NFLPSE)
C
C SAVE INFO ABOUT A NEW OUTFILE BELOW LFLPSE AND STICK A POINTER TO THIS
C INFO IN THE GENERAL STRUCTURE LIST.
C GIVEN AN OUTFILE DIRECTIVE, WANT TO SAVE AT LFLPSE END OF STORE:
C    OCCURRENCE NUMBER SPECIFIED OR IMPLIED
C    OPTION NUMBER SPECIFIED OR IMPLIED
C    OVERWRITE/APPEND FLAG
C    POINTER TO THE FIRST ITEM OF THE NEXT BLOCK OF OUTFILE INFO
C    LENGTH OF THE FILENAME INFO IN CHARACTERS (ISIZE)
C    FILENAME
C
C THIS IS A CHAINED LIST WHEN IT'S READ IN TO ALLOW IT TO BE BUILT UP
C WHATEVER ORDER THE COMMANDS COME IN
C
C ICOMBF = BEGINNING OF AREA HOLDING INFO READ IN BY
C          PARAMETER READING ROUTINES
C ISIZE  = NO OF CHARACTERS IN FILENAME
C MSTRUC = POINTER TO CURRENT GENERAL STRUCTURE ENTRY
C
      CHARACTER *8 CFMTXP
      CHARACTER *80 CBUFF

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      COMMON/XCARDS/IMAGE(80),NC,ND,LASTCH,NI,NILAST,NS,MON,ICAT,
     2 IEOF,IHFLAG,NUSRQ,NREC,IPOSRQ,ITYPFL,INSTR,IDIRFL,IPARAM,IPARAD,
     3 NWCHAR , LCMAGE(80), IMNSRQ
C
C FREE SPACE FOR THE INFO
      ITOPIN = LFLPSE
      LFLPSE    = LFLPSE - ISIZE - 5
C      DO 999, M=ITOPIN,LFLPSE+1,-1
C       WRITE (6,'(I7,A9)') M, ' OUTFILE '
C999   CONTINUE
      IF ((LFLPSE-NFLPSE) .LE. 0) THEN
            NERRFI = 19
            GO TO 9900
      END IF
      MCHA   = ISTORE (MSTRUC+8)
      NCHA   = ISTORE (MSTRUC+9)
      IF (MCHA .EQ. 0) THEN
C
C SAVE POINTER
            ISTORE (MSTRUC+8) = ITOPIN
      ELSE
C
C READ DOWN CHAINED LIST & SAVE POINTER IN LAST LINK
            DO 1000, M = 1, NCHA-1
                  MCHA = ISTORE(MCHA - 3)
1000        CONTINUE
            ISTORE (MCHA - 3) = ITOPIN
      END IF
C
C LENGTH OF CHAIN
      ISTORE (MSTRUC+9) = ISTORE (MSTRUC+9) + 1
C
C OCCURRENCE, OPTION NUMBER & OVERWRITE/APPEND
      ISTORE (ITOPIN  ) = ISTORE (ICOMBF+18)
      ISTORE (ITOPIN-1) = ISTORE (ICOMBF+19)
      ISTORE (ITOPIN-2) = ISTORE (ICOMBF+20)
      ISTORE (ITOPIN-4) = ISIZE
C
C FILENAME
      DO 2000, J = NC, NC + ISIZE - 1
            ISTORE (ITOPIN-5+NC-J) = LCMAGE(J)
2000  CONTINUE
      NC = LASTCH + 1
C
C GET IT OUT TO CHECK
      ITOP  = ITOPIN
      ILENG = ISTORE (ITOP-4)
      WRITE (CFMTXP, '(2H( , I2, 3HA1))') ILENG
      WRITE (CBUFF(1:ILENG), CFMTXP) (ISTORE (ITOP-4-J), J=1, ILENG)
C      WRITE (6, *) ' FROM XOADD: ', CBUFF(1:ILENG)
C      WRITE (6, *) ITOP, ' TO ', ITOP-ILENG-4
C      WRITE (6, *)
9900  CONTINUE
      RETURN
      END
CODE FOR XOUBU
      SUBROUTINE XOUBU(MSTRUC,CBUFF,NROWCB,CFOUT,LCFOUT,IAPPO,LOCCCB)
C
C BUFFER OUTPUT
C CFOUT = OUTFILE (IF GIVEN)
C LCFOUT = LENGTH OF OUTFILE NAME
C LOCCCB = LAST OCCUPIED ROW OF CBUFF
C IAPPO  = 1 IF OVERWRITE, =2 IF APPEND - DEFAULT IS APPEND
C LCFOUT > 0 IF FILE OUTPUT IS REQUIRED, OVERRIDING IOUTTY
C
\XIOBUF
\XUNITS
      CHARACTER*(*) CBUFF(NROWCB)
      CHARACTER*(*) CFOUT
      LOGICAL LOPEN

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      IOUTTY = ISTORE (MSTRUC+5)
      IF (IOUTTY .EQ. 1) THEN
C FILE OUTPUT
C ASSUME THAT IF YOU'RE NOT OVERWRITING, THE FILE WILL BE IN THE
C RIGHT POSITION (IE ASSUME THAT THE FILE WILL NOT HAVE BEEN CLOSED
C OR REWOUND SINCE THE LAST WRITE)
             INQUIRE (FILE=CFOUT(1:LCFOUT),OPENED=LOPEN,NUMBER=NWRI)
             IF (.NOT. LOPEN) THEN
                   NWRI = NWRIT2
                   OPEN (NWRI, FILE=CFOUT(1:LCFOUT), ERR=9950)
                   IF (IAPPO .EQ. 1) THEN
                          REWIND (NWRI)
                   ELSE IF (IAPPO .EQ. 2) THEN
C READ DOWN TO THE BOTTOM TO POSITION THE WRITE
1000                      CONTINUE
                          READ (NWRI, '(80X)', END=2000)
                          GO TO 1000
2000                      CONTINUE
                          BACKSPACE (NWRI)
                   END IF
             ELSE
                   IF (IAPPO .EQ. 1) REWIND (NWRI)
             END IF
             DO 4000, M = 1, LOCCCB
                  IF (CBUFF(M) .NE. ' ')
     1                WRITE (NWRI, '(A80)') CBUFF(M)
4000         CONTINUE
C
C SG-SPECIFIC! WRITING TO FILES & THEN READING THEM STRAIGHT BACK!
C             CALL FLUSH(NWRI)
      ELSE IF (IOUTTY .EQ. 2) THEN
C PUNCH OUTPUT
C           NERRFI = NERRFI_CANT_DO_YET
            NERRFI = 48
      ELSE IF (IOUTTY .EQ. 3) THEN
C SCREEN
            DO 5000, M = 1, LOCCCB
                  IF (CBUFF(M) .NE. ' ')
     1                WRITE (CMON, '(1X, A80)') CBUFF(M)
                      CALL XPRVDU(NCVDU, 1,0)
5000        CONTINUE
      ELSE
C NERRFI = NERRFI_ILLEGAL_OUTTYPE
           NERRFI=97
      END IF
9900  CONTINUE
      RETURN
9950  CONTINUE
C     NERRFI = NERRFI_ERROR_OPENING_OUTFILE
      NERRFI = 46
      GO TO 9900
      END
CODE FOR XOUNAM
      SUBROUTINE XOUNAM(MSTRUC, CFNOND, LNONDE, IAPPO, NOCC, ICPABR)
C
C CHECK LINKED LIST CREATED BY OUTFILE DIRECTIVE FOR A FILENAME
      CHARACTER *(*) CFNOND
      CHARACTER *8 CFMTXP

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
C GET START OF OUTFILE STACK ASSOCIATED WITH THIS STRUCTURE
      LOUTF  = ISTORE (MSTRUC+8)
      NOUTF  = ISTORE (MSTRUC+9)
      MOUTF  = LOUTF
C APPEND/OVERWRITE FLAG AS DEFINED IN THE OUTFILE STACK
      IAPPO  = 0
C NON DEFAULT FILENAME FOUND FROM STACK = CFNOND, LENGTH LNONDE
      CFNOND = ' '
      LNONDE = 0
      DO 7500, MTMP = 1, NOUTF
           IF  ((ISTORE(MOUTF  ) .EQ. NOCC      )
     1    .AND. (ISTORE(MOUTF+1) .EQ. (ICPABR))) THEN
C
C THIS IS A STRAIGHT NON-DEFAULT ENTRY FOR WHICH A SINGLE OCCURRENCE HAS
C HAD A FILENAME SPECIFIED
                  LNONDE = ISTORE (MOUTF+3)
                   IAPPO = ISTORE (MOUTF+2)
                  WRITE (CFMTXP, '(2H( , I2, 3HA1))') LNONDE
                  WRITE (CFNOND(1:LNONDE), CFMTXP)
     1                  (ISTORE(J),J=MOUTF+4,MOUTF+3+LNONDE)
           ELSE IF  ((ISTORE(MOUTF  ) .EQ. -1         )
     1    .AND. (ISTORE(MOUTF+1) .EQ. (ICPABR)      )
     2    .AND. (NOCC            .EQ. ISTORE(MSTRUC+4))) THEN
C
C THIS IS A 'LAST OCCURRENCE'
                  LNONDE = ISTORE (MOUTF+3)
                   IAPPO = ISTORE (MOUTF+2)
                  WRITE (CFMTXP, '(2H( , I2, 3HA1))') LNONDE
                  WRITE (CFNOND(1:LNONDE), CFMTXP)
     1                  (ISTORE(J),J=MOUTF+4,MOUTF+3+LNONDE)
           ELSE IF  ((ISTORE(MOUTF  ) .EQ. 0         )
     1    .AND.      (ISTORE(MOUTF+1) .EQ. (ICPABR))
     2    .AND.      (LNONDE          .EQ. 0         )) THEN
C
C NO OCCURRENCE SPECIFIED
                  LNONDE = ISTORE (MOUTF+3)
                   IAPPO = ISTORE (MOUTF+2)
                  WRITE (CFMTXP, '(2H( , I2, 3HA1))') LNONDE
                  WRITE (CFNOND(1:LNONDE), CFMTXP)
     1                  (ISTORE(J),J=MOUTF+4,MOUTF+3+LNONDE)
           ELSE IF  ((ISTORE(MOUTF  ) .EQ. NOCC      )
     1    .AND.      (ISTORE(MOUTF+1) .EQ. 0         )
     2    .AND.      (LNONDE          .EQ. 0         )) THEN
C
C NO OPTION SPECIFIED
                  LNONDE = ISTORE (MOUTF+3)
                   IAPPO = ISTORE (MOUTF+2)
                  WRITE (CFMTXP, '(2H( , I2, 3HA1))') LNONDE
                  WRITE (CFNOND(1:LNONDE), CFMTXP)
     1                  (ISTORE(J),J=MOUTF+4,MOUTF+3+LNONDE)
           ELSE IF  ((ISTORE(MOUTF  ) .EQ. -1        )
     1    .AND.      (ISTORE(MOUTF+1) .EQ. 0         )
     2    .AND.      (LNONDE          .EQ. 0         )
     3    .AND.      (NOCC            .EQ. ISTORE(MSTRUC+4))) THEN
                  LNONDE = ISTORE (MOUTF+3)
                   IAPPO = ISTORE (MOUTF+2)
                  WRITE (CFMTXP, '(2H( , I2, 3HA1))') LNONDE
                  WRITE (CFNOND(1:LNONDE), CFMTXP)
     1                  (ISTORE(J),J=MOUTF+4,MOUTF+3+LNONDE)
           ELSE IF  ((ISTORE(MOUTF  ) .EQ. 0         )
     1    .AND.      (ISTORE(MOUTF+1) .EQ. 0         )
     2    .AND.      (LNONDE          .EQ. 0         )) THEN
                  LNONDE = ISTORE (MOUTF+3)
                   IAPPO = ISTORE (MOUTF+2)
                  WRITE (CFMTXP, '(2H( , I2, 3HA1))') LNONDE
                  WRITE (CFNOND(1:LNONDE), CFMTXP)
     1                  (ISTORE(J),J=MOUTF+4,MOUTF+3+LNONDE)
           END IF
           MOUTF   = MOUTF + ISTORE (MOUTF+3) + 4
7500  CONTINUE
      RETURN
9900  CONTINUE
      END
CODE FOR XOUTPU
       SUBROUTINE XOUTPU
C
C OUTPUT OF THE FIND ROUTINES
\XIOBUF
\XUNITS
       CHARACTER*80 CFIN
       CHARACTER*80 CDEFAU

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C       INCLUDE 'FIND.INC'
C
C MSTRUC + 5  = ACTION TO BE TAKEN ON FINDING THE ISOMORPHISM
C   1 = SIMPLY WRITE OUT DETAILS TO THE SCREEN
C
C LOCALS:
C  NPSOUT: NO. OF ISOMORPHISMS FOR THIS QUERY
C  LPSOUT: ADDRESS OF THE ADDRESS OF THE FIRST PS FOR THIS QUERY
C  MPSOUT: LOOP OVER THE ADDRESSES OF THE PS'S FOR THIS QUERY
C  NOUTTY: TYPE OF OUTPUT REQUIRED (IE CONTENTS OF ISTORE(MSTRUC+5))
      MOFFSQ = 1
C
C LOOP OVER ALL THE QUERY STRUCTURES
      DO 9000, MSTRUC = LSTRUC + MDSTRU,
     1                  LSTRUC + ((NSTRUC-1) * MDSTRU) , MDSTRU
           NPSOUT = ISTORE (MSTRUC+ 4)
           IF (NPSOUT .GT. 0) THEN
C
               N = (MSTRUC-LSTRUC)/MDSTRU
               WRITE (CMON,'(A,I4)') 'WRITING OUTPUT FOR QUERY ',N
               CALL XPRVDU(NCVDU, 1,0)
C
C CREATE A DEFAULT OUTPUT FILENAME & APPEND/OVERWRITE ACTION
               CALL XDENAM (MSTRUC, CDEFAU, LDEFAU, CFIN, LCFIN,IAPPO)
               IF (NERRFI .GT. 0) GO TO 9900
C
C LOOP OVER ALL THE PS'S CORRESPONDING TO ISOMORPHISMS FOR THIS QUERY
               NNODEQ = ISTORE (MSTRUC   )
               NINTQ  = ISTORE (MSTRUC+15)
               MOFFSQ = MOFFSQ + ISTORE(MSTRUC-MDSTRU+15)
               NSTRUQ = ((MSTRUC-LSTRUC)/MDSTRU)+1
               LPSOUT = ISTORE (MSTRUC+3)
               NOUTTY = ISTORE (MSTRUC+5)
               DO 8000, MPSOUT = LPSOUT, LPSOUT + NPSOUT - 1
C
C THE CURRENT PS IS PASSED THROUGH USING LPSL
                   LPSL   = ISTORE (MPSOUT)
                   CALL XPSTOS (MSTRUC, CDEFAU, LDEFAU, LPSOUT,
     1                          MPSOUT,IAPPO)
8000           CONTINUE
           ELSE
               WRITE (CMON,'(A,I4,A)') 'NO INSTANCES OF QUERY ',N,
     1                                  ' LOCATED'
               CALL XPRVDU(NCVDU, 1,0)
           END IF
9000  CONTINUE
9900  CONTINUE
      RETURN
      END
CODE FOR XPARTI
      SUBROUTINE XPARTI(MSTRUC)
C
C DJK THE NEW ONE
C TEMPORARY USE OF NFL ASSUMES THAT AT THE END OF THIS ROUTINE,
C NFL WILL BE AT THE END OF THE SET AREA
C
C LOCALS:
C  LPSO   ADDRESS OF THE LAST PS FOR THIS STRUCTURE
C  INCTMP NO. OF ADDRESSES REQUIRED FOR ONE PS OF THIS STRUCTURE
C
      LOGICAL LPRESE

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C      CALL OUTSET (' ENTERING XPARTI ', 1, 0)
C
      INCTMP = MDSETS*(NNODEQ+1)
C      MSTRUC = LSTRUC + (NSTRUQ-1)*MDSTRU
C
C IS THIS THE FIRST TIME FOR THIS QUERY?
      IF (LPSL .EQ. 0) THEN
C
C TAKE ALL THE SETS SO FAR (FROM THE VERY BEGINNING) THAT ARE
C ALLOWED FOR THIS STRUCTURE.
C IE SET LNEW TO LSETS
            LNEW   = LSETS
C ??? I'VE SWAPPED THESE TWO LINES ROUND
C            LPSO   = LPSL
C            LPSL   = KSTALL (INCTMP)
            LPSL   = KSTALL (INCTMP)
            LPSO   = LPSL
            NSETS  = NSETS + NNODEQ
            CALL XPSTO1

C      CALL OUTSET (' BEFORE XSDEL', 2, 0)
            IF (.NOT.LOVERL) CALL XSDEL(MSTRUC)
C      CALL OUTSET (' AFTER XSDEL', 2, 0)
      ELSE
C
C SAVE THE OLD PS ADDRESS
            LPSO = LPSL
C
C TAKE ALL THE SETS SINCE THE LAST PS FOR THIS STR
C ASSUME: 1) THAT THE NEW SETS START DIRECTLY AFTER THE LAST PS
C         2) THAT THE VARIABLE LPSL CURRENTLY HOLDS THE ADDRESS OF
C            THE LAST PS.
            INCTMP = MDSETS*(NNODEQ+1)
            LNEW   = LPSL + INCTMP - MDSETS
C
            LPSL   = KSTALL (INCTMP)
            NSETS  = NSETS + NNODEQ
C
C TRANSFER THE CONTENTS OF THE LAST P.S. TO THE NEW P.S.
            DO 900, I = 1, NNODEQ*MDSETS
                  ISTORE (LPSL+I-1) = ISTORE (LPSO+I-1)
900         CONTINUE
C            CALL OUTSET ( ' AFTER TRANSFER OF LAST PS ',1,0)
C            CALL OUTSET ( ' AFTER TRANSFER OF LAST PS ',2,0)
      END IF
C
C CHECK HERE FOR CV'S IN THE NEW SETS USABLE BY THE CURRENT STRUCTURE
      DO 1000, MNEW = LNEW, LPSL - MDSETS, MDSETS
            IF ((ABS(ISTORE(MNEW)) .EQ. NSTRUQ)
     1     .OR.      (ISTORE(MNEW)  .EQ. 0     )) THEN
                  LCV = (ISTORE(MNEW+1) .LT. ISTORE(MNEW+MOFFSQ))
                  IF (LCV) GO TO 9890
            END IF
1000  CONTINUE
C
C
C CALCULATE THE ADDRESS OF THE TEMPORARY SET ENTRY FOR HOLDING SET
C COMPLEMENTS
      MTEMP  = LPSL + (NNODEQ*MDSETS)
C
C LOOP OVER THE P.S.
      DO 9000, MPSL = LPSL, LPSL+(NNODEQ-1)*MDSETS, MDSETS
C
            NNODE = ((MPSL - LPSL) / MDSETS) + 1
            DO 8000, MNEW = LNEW, LPSL-MDSETS, MDSETS
C
C SEARCH THE NEW SETS FOR THOSE CONTAINING THE CURRENT NODE.  IF FOUND,
C INCLUDE THEM IN THE INTERSECTION WITH THE ENTRY CORRESPONDING TO THIS
C NODE IN THE OLD P.S. (I.E. THE ENTRY AT MPSO).
            IF ((ISTORE(MNEW) .EQ. 0) .OR. (ISTORE(MNEW) .EQ. -1)
     1     .OR. (ABS(ISTORE(MNEW)) .EQ. NSTRUQ))  THEN
                  IF ( LPRESE ( NNODE, MNEW, MOFFSQ)) THEN
                        CALL XINTER ( MNEW, MPSL, MPSL)
C
C OTHERWISE USE THE COMPLEMENT OF THE SETS AT MNEW IN THE
C INTERSECTION BUT ONLY IF THE CARDINALITIES OF THIS SET AND THE
C SUPERSTRUCTURE SET ARE EQUAL.
                  ELSE IF ( ISTORE (MNEW+1)
     1                .EQ.  ISTORE (MNEW+MOFFSQ) ) THEN
C
C CALCULATE THE COMPLEMENT OF THIS SET AND STORE IT IN THE TEMPORARY
C ENTRY AT THE END OF THE SET LIST.  IT DOES NOT MATTER IF THE UNUSED
C BITS AT THE END OF THE LAST INTEGER HOLDING A SET ARE SET TO '1' AS
C THEY WILL BE IGNORED DURING READING.  'NOT'ING A POSITIVE INTEGER WILL
C ALWAYS GIVE A NEGATIVE RESULT BUT THIS WILL ALSO BE IGNORED.
                             DO 6000, N = 1, NINTSU - 1
                             ISTORE(MTEMP+N+1)=KKNOT(ISTORE(MNEW+N+1))
6000  CONTINUE
                             DO 7000, N = 1, NINTQ - 1
                             ISTORE (MTEMP+N+MOFFSQ) =
     1                                  KKNOT ( ISTORE (MNEW+N+MOFFSQ))
7000  CONTINUE
C
C INCLUDE IT IN THE INTERSECTION
                              CALL XINTER (MTEMP, MPSL, MPSL)
C
C FLAG THE SET ENTRY IN THE NEW P.S. SO THAT THIS ENTRY IS NOT USED BY
C OTHER STRUCTURES.
                              ISTORE (MPSL) = NSTRUQ
                  END IF
            END IF
8000  CONTINUE
      LCV = (ISTORE(MPSL+1) .LT. ISTORE(MPSL+MOFFSQ))
      IF (LCV) GO TO 9890
9000  CONTINUE
C
C LOOP OVER THE P.S. TO MAKE USE OF THE COMPLEMENT INFORMATION _WITHIN_
C THE P.S.
      DO 9500, MPSL = LPSL, LPSL+(NNODEQ-1)*MDSETS, MDSETS
            IF  ((ISTORE (MPSL+1) .EQ. ISTORE (MPSL+MOFFSQ))
     1     .AND. (ISTORE (MPSL+MOFFSQ) .NE. NNODEQ)) THEN
C
C STORE THE COMPLEMENT IN THE TEMPORARY STORE
                 DO 9200, N = 1, NINTSU - 1
                      ISTORE (MTEMP+N+1) = KKNOT(ISTORE(MPSL+N+1))
9200  CONTINUE
                 DO 9300, N = 1, NINTQ - 1
                      ISTORE (MTEMP+N+MOFFSQ) =
     1                KKNOT ( ISTORE (MPSL+N+MOFFSQ))
9300  CONTINUE
C
C LOOP OVER THE NODES OF THE SUBSTRUCTURE SET ENTRY HELD IN THE
C TEMPORARY STORE TAKING THE INTERSECTION OF THE TEMPORARY STORE WITH
C THE RELEVANT P.S. ENTRIES.
                 DO 9400, INODE = 1, NNODEQ
                        IF (LPRESE (INODE, MTEMP, MOFFSQ)) THEN
                              MNODE = LPSL+((INODE-1)*MDSETS)
                              CALL XINTER(MTEMP, MNODE, MNODE)
C
C FLAG THE SET ENTRY IN THE NEW P.S. SO THAT THIS ENTRY IS NOT USED BY
C FUTURE STRUCTURES.
                              ISTORE (MNODE) = NSTRUQ
                        END IF
9400  CONTINUE
            END IF
9500  CONTINUE
C
C LOOP OVER THE P.S. ONCE MORE, TO CALCULATE NIDENT
C AND TO SEE IF AN ISOMORPHISM HAS BEEN FOUND
      LISOMO = .TRUE.
      NIDENT = 0
      DO 9600, MPSL = LPSL, LPSL+(NNODEQ-1)*MDSETS, MDSETS
            IF  ((ISTORE (MPSL+1) .EQ. 1)
     1     .AND. (ISTORE (MPSL+MOFFSQ) .EQ. 1)) THEN
C
C THIS IS A CORRESPONDENCE
                  NIDENT = NIDENT + 1
            ELSE
                  LISOMO = .FALSE.
            END IF
9600  CONTINUE
      GO TO 9900
9890  CONTINUE
C
C COME HERE IN THE CASE OF A CV.
C RESET SOME VALUES TO SAVE SPACE IN THE SET HOLDING AREA
C NFL RESET BELOW
C      NFL   = LPSL
      NSETS = NSETS - NNODEQ
      LPSL  = 0
9900  CONTINUE
C
C RESET NFL TO FORGET THE TEMPORARY SET AREA, ASSUME THAT IT'S NOW
C AT THE END OF THE SETS
      NFL = LSETS + (MDSETS*NSETS)
C      CALL OUTSET (' LEAVING XPARTI ', 1, 0)
C      CALL OUTSET (' LEAVING XPARTI ', 2, 0)
      RETURN
      END
CODE FOR XPDENS
      SUBROUTINE XPDENS
C
C GENERATE SETS BASED ON BOND LENGTHS FOR BONDS-AS-NODES
C FOR THIS TYPE OF GRAPH, ASSUME THE TWO FLOATING POINT NUMBERS
C TAKEN AS INPUT FOR A `DIST' RECORD ARE THE MEAN BOND LENGTH
C REQUIRED AND ITS ESD.
C IF THESE VALUES ARE NON-ZERO FOR A NODE OF A QUERY STRUCTURE,
C CAN GENERATE A NEW SET WITH THIS QUERY NODE AS A MEMBER
C
C GENERATE STRUCTURE MEMBERS OF THIS NEW SET (NOT OTHER QUERIES)
C
C MEMBERS OF THIS NEW SET ARE THOSE STRUCTURE NODES FOR WHICH
C (ASSUMING A GAUSSIAN CENTRED ON THE GIVEN MEAN)
C THE PROBABILITY DENSITY >= PDENS THRESHOLD
C
C THIS IS APPLYING BAYES' THEOREM TO THE CLASSIFICATION PROBLEM
C `CAN THIS BOND BE CLASSED AS ONE FROM THIS DISTRIBUTION OR NOT?'
C
C CAN ALTER THE PDENS THRESHOLD TO ALLOW MORE TOLERANCE IN
C MATCHING THE STRUCTURE

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      COMMON/XCONST/NOWT,PI,TWOPI,TWOPIS,RTD,DTR,
     2 UISO,ZERO,ZEROSQ,VALUE,VALUSQ
C
C HOLD ESDS & MEANS AT THE TOP END OF STORE
      LFLSAV = LFL
      NDIST  = 0
      MDDIST = 3
      MOFFSE = 1 + ISTORE(LSTRUC+15)
C
C LOOP OVER ALL THE QUERY STRUCTURES
      DO 2000, MSTRUC = LSTRUC+MDSTRU,
     1                    LSTRUC+(NSTRUC-1)*MDSTRU, MDSTRU
C
C LOOP OVER ALL THE NODES FOR THIS QUERY
          NNODES = ISTORE(MSTRUC)
          LNODES = ISTORE(MSTRUC+2)
          DO 1000, MNODES=LNODES,LNODES+(NNODES-1)*MDNODE,MDNODE
              MINFO = ISTORE(MNODES+2)
              NQNODE = (MNODES-LNODES)/MDNODE + 1
C
C IF A MEAN, ESD ARE GIVEN, CREATE A NEW SET
              RMEAN = STORE(MINFO+2)
              RESD  = STORE(MINFO+3)
              IF ((RMEAN .GT. ZERO) .AND. (RESD .GT. ZERO)) THEN
                  MNEWSE = KSTALL(MDSETS)
                  DO 500, MTMP = 1, MDSETS
                      ISTORE(MNEWSE+MTMP-1) = 0
500               CONTINUE
                  NSETS = NSETS + 1
C
C SET THE BIT CORRESPONDING TO THIS QUERY NODE
C FIRST SET THE CARDINALITY
                  ISTORE(MNEWSE+MOFFSE) = 1
                  NBIT = MOD((NQNODE-1), L1INT)
                  JADDCH = MNEWSE+MOFFSE+(NQNODE-1)/L1INT + 1
                  ISTORE(JADDCH) = N2POWS(NBIT)
C
C SAVE THE RELEVANT INFORMATION BELOW LFL
                  LDIST           = KCHLFL(MDDIST)
                  ISTORE(LDIST)   = MNEWSE
                   STORE(LDIST+1) = RMEAN
                   STORE(LDIST+2) = RESD
                  NDIST = NDIST + 1
              END IF
1000      CONTINUE
          MOFFSE = MOFFSE + ISTORE(MSTRUC+15)
2000  CONTINUE
C
C NOW WORK OVER THE NODES OF THE STRUCTURE TO FILL IN THEIR BITS INTO
C THE SETS
      LNODES = ISTORE(LSTRUC+2)
      NNODSU = ISTORE(LSTRUC)
      DO 4000, MNODES=LNODES,LNODES+(NNODSU-1)*MDNODE,MDNODE
          MINFO  = ISTORE(MNODES+2)
          RDIST  =  STORE(MINFO+2)
          NSNODE = (MNODES-LNODES)/MDNODE + 1
C
C WORK DOWN THE AREA OF RMEAN, RESD PAIRS DEFINING THE PROBABILITY
C DENSITY
          DO 3000, MDIST=LDIST, LDIST+(NDIST-1)*MDDIST, MDDIST
              MNEWSE = ISTORE(MDIST)
              RMEAN  =  STORE(MDIST+1)
              RESD   =  STORE(MDIST+2)
              PDENS  = GPDENS(RDIST, RMEAN, RESD)
C
C INCLUDE THE STRUCTURE NODE IN THE SET IF ABOVE THE THRESHOLD
              IF (PDENS .GT. RTHRES) THEN
                  NBIT = MOD((NSNODE-1), L1INT)
                  IUSE1 = N2POWS(NBIT)
                  JADDCH = MNEWSE + (NSNODE-1)/L1INT + 2
                  IUSE2 = ISTORE(JADDCH)
                  ISTORE(JADDCH) = KOR(IUSE1, IUSE2)
C INCREMENT CARDINALITY
                  ISTORE(MNEWSE+1) = ISTORE(MNEWSE+1) + 1
              END IF
3000      CONTINUE
4000  CONTINUE
      LFL = LFLSAV
      RETURN
      END
CODE FOR XPSTO1
      SUBROUTINE XPSTO1
C
C DJK

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
C SET THE INITIAL VALUES IN THE P.S. TO '1' FOR EACH NODE OF EACH P.S.
C SET OF EACH STRUCTURE SO THAT THE FIRST INTERSECTION IS VALID.
            DO 500, MPSL = LPSL, LPSL+(NNODEQ-1)*MDSETS, MDSETS
                  MOFFSE = 1
                  DO 600, M = LSTRUC, LSTRUC+(MDSTRU*(NSTRUC-1)), MDSTRU
                        ISTORE(MPSL+MOFFSE) = ISTORE(M)
                        NCURSE = ISTORE (M+15)
                        DO 700, N = 1, NCURSE-1
                              ISTORE (MPSL + MOFFSE + N) = IUNIVE
700   CONTINUE
                        MOFFSE = MOFFSE + NCURSE
600   CONTINUE
500   CONTINUE
      RETURN
      END
CODE FOR XPSTOS
      SUBROUTINE XPSTOS(MSTRUC,CDEFAU,LDEFAU,LPSOUT,MPSOUT,IAPPD)
C
C TAKES THE PS AT LPSL AND THE QUERY STRUCTURE AT MSTRUC IN THE
C GENERAL LIST AND WRITES OUT DETAILS OF THE ISOMORPHISM
C
C CDEFAU = DEFAULT OUTPUT FILENAME LDEFAU = ITS LENGTH
C LPSOUT = ADDRESS OF ADDRESS OF FIRST PS IN THE STACK CURRENTLY
C BEING PROCESSED
C MPSOUT = ADDRESS OF ADDRESS OF PS CURRENTLY BEING PROCESSED
C (THIS INFO NEEDED TO CONSTRUCT OUTPUT FILENAME)
C IAPPD  = DEFAULT APPEND/OVERWRITE ACTION FROM 'QUERY' DIRECTIVE
C
C FORMS A STACK AT THE HIGH END OF MEMORY HOLDING THE ATOMS REFERRED
C TO IN THE COMMANDS IN THE FILE.
C THE STACK HAS TWO ENTRIES PER ATOM: THE ATOM SERIAL NUMBER FROM THE
C QUERY AND THAT OF THE STRUCTURE (THE SEARCHEE)
C
C THE SEQUENCE OF OPERATIONS IS:
C 1) READ THROUGH THE FILE FORMING THE STACK BUT WITHOUT THE STRUCTURE
C    CORRESPONDENCES
C 2) OPERATE ON THE STACK TO FILL IN THE STRUCTURE CORRESPONDENCES AS
C    ATOM SERIAL NUMBERS (SUBROUTINE XCORST)
C 3) REWIND THE FILE & THIS TIME WRITE OUT THE COMMANDS TO THE BUFFER
C    CBUFF, EXPANDING ALL THE `*ATN' FLAGS INTO FULL REFERENCES FROM THE
C    STRUCTURE
C
C MY GUESS IS THAT ONE LINE COULD AT MOST BE EXPANDED INTO 5 WHAT
C WITH ATOM SPECIFICATIONS & CONTINUATIONS & ALL.  HENCE SET THE
C DIMENSION OF CBUFF (= IDCB) TO 5.
C
\XIOBUF
\XUNITS
      PARAMETER (IDCB = 5)
      CHARACTER *(*) CDEFAU
      CHARACTER*80 CREAD, CUPPER, CBUFF(IDCB), CFILE, CFNOND
      CHARACTER*8 CFMTXP
      LOGICAL LEXIST, LFIRST, USETHI,LCHANG

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      COMMON/XCARDS/IMAGE(80),NC,ND,LASTCH,NI,NILAST,NS,MON,ICAT,
     2 IEOF,IHFLAG,NUSRQ,NREC,IPOSRQ,ITYPFL,INSTR,IDIRFL,IPARAM,IPARAD,
     3 NWCHAR , LCMAGE(80), IMNSRQ
C
      NOCC   = MPSOUT - LPSOUT + 1
C
C GENERATE THE DEFAULT FILENAME FOR THIS PS HERE
C NVER IS THE EXTENSION, WHICH WILL KEEP INCREASING UNTIL A NEW ONE
C IS FOUND
      INQUIRE (FILE=CDEFAU(1:LDEFAU), EXIST=LEXIST)
      IF ((NOCC .EQ. 1) .AND. LEXIST) THEN
          WRITE (CMON, '(1X,A,A)')
     1    'OUTPUT FILE ALREADY EXISTS:',CDEFAU(1:LDEFAU)
          CALL XPRVDU(NCVDU, 1,0)
      ENDIF
C
C NO OF ROWS IN CBUFF.
      NROWCB = IDCB
C
C MAKE ROOM FOR AN AREA BELOW LFL HOLDING ALL THE REQUIRED ATOM
C CORRESPONDENCES
      LFLSAV = LFL
C
C THE FILE CORRESPONDING TO THIS STRUCTURE
      IINFO  = ISTORE (MSTRUC+11)
      ISIZE  = ISTORE (IINFO)
      IF (ISIZE .LE. 0) THEN
C
C HMM ... STRUCTURE DIDN'T COME FROM A FILE
C            NERRFI = NERRFI_CANT_DO
            NERRFI = 36
            GO TO 9900
      END IF
      WRITE (CFMTXP, '(2H( , I2, 3HA1))') ISIZE
      WRITE (CFILE(1:ISIZE), CFMTXP) (ISTORE(IINFO+J), J=1, ISIZE)
C      MFILES = 1+((MSTRUC - LSTRUC)/MDSTRU)
C
C LOOP OVER THE FILE CONSIDERING ONLY THOSE LINES WHICH ARE CSD
C COMMENTS
      OPEN (NREAD2, FILE=CFILE(1:ISIZE))
C
C FORCE A REWIND AS THIS MAY NOT BE THE FIRST TIME
      REWIND (NREAD2)
C
C A POINTER SAYING WHICH COMMAND PACKET IS ABOUT TO BE READ
      ICPABR = 1
C
C A LOGICAL SAYING WHETHER TO USE THIS COMMAND PACKET OR NOT
      USETHI = .FALSE.
C
C SEARCH FORWARD FOR THE FIRST COMMAND PACKET WHICH THE BINARY VECTOR
C SAYS YOU CAN USE.  THIS IS IFIRST
      IFIRST = KNCPTU (MSTRUC, 0)
      IF (NERRFI .NE. 0) GO TO 9900
C
C NO FIRST PACKET ==> GET OUT
      IF (IFIRST .EQ. 0) GO TO 8000
C
C A POINTER SAYING WHICH COMMAND PACKET IS ABOUT TO BE USED ACCORDING
C TO THE BINARY VECTOR
      ICPNTU = IFIRST
1000  CONTINUE
      READ (NREAD2, '(A80)', END=4000, ERR=9000) CREAD
C
C CONVERT TO UPPER CASE
      CALL XCCUPC (CREAD, CUPPER)
C
C REMOVE REDUNDANT SPACES
      CALL XCREMS (CUPPER, CREAD, LREAD)
      IF (CREAD(1:4) .EQ. 'COMM') THEN
C
C READ THIS LINE AS PART OF A POTENTIAL COMMAND
            IF ((CREAD(6:13) .EQ. 'COMMANDS') .OR.
     1          (CREAD(6:11) .EQ. 'OPTION'  )) THEN
C
C NO FURTHER PACKET? GO ON TO THE WRITING BIT
                  IF (ICPNTU .EQ. 0) GO TO 4000
                  USETHI = (ICPABR .EQ. ICPNTU)
                  IF (USETHI) THEN
C
C SEARCH FORWARD FOR THE NEXT COMMAND PACKET AFTER ICPABR
C WHICH THE BINARY VECTOR SAYS YOU CAN USE.
                        ICPNTU = KNCPTU (MSTRUC, ICPABR)
                        IF (NERRFI .NE. 0) GO TO 9900
                        ICPABR = ICPABR + 1
                  ELSE
                        ICPABR = ICPABR + 1
                  END IF
            ELSE
C
C PART OF A COMMAND PACKET.
C ADD THE ATOMS IN CREAD TO THE STACK BELOW LFLSAV
                  IF (USETHI) CALL XADDST (LFLSAV, CREAD)
                  IF (NERRFI .GT. 0) GO TO 9900
            END IF
      END IF
C
C READ THE NEXT LINE
      GO TO 1000
C
C COME HERE AT THE END OF THE FIRST PASS OVER THE FILE
4000  CONTINUE
C
C NOW OPERATE ON THE STACK TO FILL IN THE CORRESPONDENCES
      LNOISO = .FALSE.
      CALL XCORST (LFLSAV, MSTRUC)
      IF (NERRFI .GT. 0) GO TO 9900
C
C CHECK IF XCORST TURNED UP A NON-ISOMORPHISM
      IF (LNOISO) GO TO 8000
C
C GET MAXIMUM SERIAL NUMBER
      CALL MAXSEN ()
      IF (NERRFI .GT. 0) GO TO 9900
C
C START AGAIN, THIS TIME USING THE STACK TO CREATE THE COMMANDS
      REWIND (NREAD2)
C
C A POINTER SAYING WHICH COMMAND PACKET IS ABOUT TO BE READ
      ICPABR = 1
C
C A POINTER SAYING WHICH COMMAND PACKET IS ABOUT TO BE USED ACCORDING
C TO THE BINARY VECTOR IN MSTRUC+18...
      ICPNTU = IFIRST
      USETHI = .FALSE.
5000  CONTINUE
      READ (NREAD2, '(A80)', END=8000, ERR=9000) CREAD
C
C CONVERT TO UPPER CASE
      CALL XCCUPC (CREAD, CUPPER)
C
C REMOVE REDUNDANT SPACES
      CALL XCREMS (CUPPER, CREAD, LREAD)
      IF (CREAD(1:4) .EQ. 'COMM') THEN
C
C READ THIS LINE AS PART OF A POTENTIAL COMMAND
          IF ((CREAD(6:13) .EQ. 'COMMANDS') .OR.
     1        (CREAD(6:11) .EQ. 'OPTION'  )) THEN
C
C NO FURTHER PACKET? LEAVE THE WRITING CODE
              IF (ICPNTU .EQ. 0) GO TO 8000
              USETHI = (ICPABR .EQ. ICPNTU)
              IF (USETHI) THEN
C
C USE THIS COMMAND PACKET
C SET TRUE IF THE NEXT LINE TO BE READ IS THE FIRST LINE OF THIS
C COMMAND PACKET
                  LFIRST = .TRUE.
C SEARCH FORWARD FOR THE NEXT COMMAND PACKET WHICH THE BINARY VECTOR
C SAYS YOU CAN USE.
                  ICPNTU = KNCPTU (MSTRUC, ICPABR)
                  IF (NERRFI .NE. 0) GO TO 9900
C CHECK IF THIS OCCURRENCE, OPTION COMBINATION HAS BEEN GIVEN A SPECIAL
C OUTPUT FILENAME IN THE OUTFILE STACK
                  CALL XOUNAM(MSTRUC,CFNOND,LNONDE,IAPPO,NOCC,ICPABR)
                  ICPABR = ICPABR + 1
              ELSE
                  ICPABR = ICPABR + 1
              END IF
          ELSE
C
C PART OF A COMMAND PACKET.
C OVERRIDE THE DEFAULT APPEND/OVERWRITE FLAG IF ONE WAS FOUND AND THIS
C IS THE FIRST LINE
C IF ONE WASN'T USE THE DEFAULT
              IF (USETHI) THEN
                  IF (LFIRST) THEN
                      LFIRST = .FALSE.
                      IF (IAPPO .EQ. 0) IAPPO  = IAPPD
                  ELSE
C THIS ISN'T THE FIRST LINE, SO APPEND WHATEVER HAPPENS
                       IAPPO  = 2
                   END IF
C OPERATE ON THE LINE CREAD AND THE STACK OF ATOM CORRESPONDENCES
C TO FILL AN OUTPUT BUFFER
                   CALL XBUFFW (LFLSAV, CBUFF, CREAD, NROWCB,
     1                          LSTRUC,LOCCCB)
                   IF (NERRFI .GT. 0) GO TO 9900
C
C OPERATE ON THE BUFFER CBUFF TO CONVERT THE OCCURRENCE FLAGS INTO
C NUMBERS (*NOC)
                   CALL XNOCC (CBUFF, NROWCB, NOCC)
                   IF (NERRFI .GT. 0) GO TO 9900
C
C OPERATE ON THE BUFFER CBUFF TO CONVERT THE ARITHMETIC BITS INTO
C SOMETHING MEANINGFUL
7600               CONTINUE
                   LCHANG = .FALSE.
                   CALL XIARCO (CBUFF, NROWCB, '*',LCHANG)
                   CALL XIARCO (CBUFF, NROWCB, '/',LCHANG)
                   IF (NERRFI .GT. 0) GO TO 9900
                   IF (LCHANG) GO TO 7600
                   LCHANG = .FALSE.
                   CALL XIARCO (CBUFF, NROWCB, '+',LCHANG)
                   CALL XIARCO (CBUFF, NROWCB, '-',LCHANG)
                   IF (NERRFI .GT. 0) GO TO 9900
                   IF (LCHANG) GO TO 7600
C
C DO THE OUTPUT
C USE THE NON-DEFAULT FILENAME IF ONE IS GIVEN
                   IF (LNONDE .GT. 0) THEN
                       CALL XOUBU(MSTRUC,CBUFF,NROWCB,CFNOND,
     1                            LNONDE, IAPPO, LOCCCB)
                   ELSE
                       CALL XOUBU(MSTRUC,CBUFF,NROWCB,CDEFAU,
     1                            LDEFAU, IAPPO, LOCCCB)
                   END IF
                   IF (NERRFI .GT. 0) GO TO 9900
               END IF
          END IF
      END IF
C
C READ THE NEXT LINE
      GO TO 5000
8000  CONTINUE
C
C RESET LFL
      LFL = LFLSAV
      GO TO 9900
C
9000  CONTINUE
C
C ERROR IN READ
      NERRFI = 26
9900  CONTINUE
C
C WHATEVER HAPPENS, MAKE SURE NREAD2 IS CLOSED
      CLOSE (NREAD2)
      RETURN
      END
CODE FOR XQADD
      SUBROUTINE XQADD(ICOMBF, NQCOUN, ISIZE, LFLPSE, NFLPSE)
C
C ADD A NEW QUERY TO THE GENERAL STRUCTURE LIST
C
C ICOMBF = BEGINNING OF AREA HOLDING INFO READ IN BY
C          PARAMETER READING ROUTINES
C NQCOUN = NO OF QUERIES READ IN SO FAR
C ISIZE  = NO OF CHARACTERS IN FILENAME
C CFMTXP = FORMAT EXPRESSION FOR WRITING FILENAME
C
      CHARACTER *8 CFMTXP
      CHARACTER *80 CBUFF
      LOGICAL LEXIST

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      COMMON/XCARDS/IMAGE(80),NC,ND,LASTCH,NI,NILAST,NS,MON,ICAT,
     2 IEOF,IHFLAG,NUSRQ,NREC,IPOSRQ,ITYPFL,INSTR,IDIRFL,IPARAM,IPARAD,
     3 NWCHAR , LCMAGE(80), IMNSRQ
\XUNITS
      LEXIST = .TRUE.
C
C FREE SPACE FOR THE GENERAL STRUCTURE ENTRY, &
C GET HOLD OF THE FIXED LENGTH INFO ABOUT THIS QUERY
      MSTRUC = KSTALL(MDSTRU)
      NSTRUC = NSTRUC + 1
      NQCOUN = NQCOUN + 1
C
C WHERE THE OUTPUT IS GOING
C      ISTORE (MSTRUC+5) = ISTORE (ICOMBF+6)
      ISTORE (MSTRUC+5) = ISTORE (ICOMBF+7)
C
C MULTIPLE?
      ISTORE (MSTRUC+6) = ISTORE (ICOMBF+5)
C
C SELF OVERLAP
      ISTORE (MSTRUC+18) = ISTORE(ICOMBF+6)
C
C OVERWRITE/APPEND
C      ISTORE (MSTRUC+7)  = ISTORE (ICOMBF+7)
      ISTORE (MSTRUC+7)  = ISTORE (ICOMBF+8)
C
C INITIALISE OUTFILE INFO
      ISTORE (MSTRUC+8)  = 0
      ISTORE (MSTRUC+9)  = 0
C
C INITIALISE KNOWN INFO
      ISTORE (MSTRUC+16)  = 0
      ISTORE (MSTRUC+17)  = 0
C
C INITIALIZE COMMAND APPLICATION INFO AREA
C      DO 1000, MAPP = MSTRUC+18, MSTRUC+18+NCPCKT-1
      DO 1000, MAPP = MSTRUC+19, MSTRUC+19+NCPCKT-1
            ISTORE(MAPP) = IUNIVE
1000  CONTINUE
C
C SAVE THE FILENAME & ITS SIZE BELOW LFL
      LTOPIN = LFLPSE
      LFLPSE = LFLPSE - ISIZE - 1
C      DO 1001,M=LTOPIN,LFLPSE+1, -1
C        WRITE (6,'(I7,A7)') M, ' QUERY '
C1001  CONTINUE
      IF ((LFLPSE-NFLPSE) .LE. 0) THEN
            NERRFI = 19
C            NC     = LASTCH + 1
            GO TO 9900
      END IF
      ISTORE (LTOPIN) = ISIZE
      WRITE (CFMTXP, '(2H( , I2, 3HA1))') ISIZE
      WRITE (CBUFF(1:ISIZE), CFMTXP) (LCMAGE(J), J=NC, NC+ISIZE-1)
      INQUIRE(FILE=CBUFF(1:ISIZE),EXIST=LEXIST)
      IF (.NOT. LEXIST) THEN
C            NERRFI = NERRFI_NONEXISTENT_QUERY_FILE
            NERRFI = 28
            WRITE (NCAWU,*) ' NON EXISTENT QUERY FILE '
            NC     = LASTCH + 1
            GO TO 9900
      END IF
      DO 2000, J = NC, NC + ISIZE - 1
            ISTORE (LTOPIN-1-J+NC) = LCMAGE(J)
2000  CONTINUE
      NC = LASTCH + 1
C
C POINTER
      ISTORE (MSTRUC+11) = LTOPIN
C
C FILE TYPE
C      ISTORE (MSTRUC+10) = ISTORE (ICOMBF+8)
      ISTORE (MSTRUC+10) = ISTORE (ICOMBF+9)
C
C GET IT OUT TO CHECK
      ITOP  = ISTORE(MSTRUC+11)
      ILENG = ISTORE (ITOP)
      WRITE (CFMTXP, '(2H( , I2, 3HA1))') ILENG
      WRITE (CBUFF(1:ILENG), CFMTXP) (ISTORE (ITOP-J), J=1, ILENG)
C      WRITE (6, *) ' IN XQADD ', CBUFF(1:ILENG)
C      WRITE (6, *) ITOP, ' TO ', ITOP-ILENG
C      WRITE (6, *)
9900  CONTINUE
      RETURN
      END
CODE FOR XSDEL
      SUBROUTINE XSDEL(MSTRUC)
C
C DELETE STUFF FROM THE PS JUST FORMED IF DIFFERENT SUBSTRUCTURES
C NOT ALLOWED TO OVERLAP
C MSTRUC = CURRENT STRUCTURE
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
      IF (MSTRUC .GT. (LSTRUC+MDSTRU)) THEN
          LFLSAV = LFL
C
C CREATE ROOM FOR A SET HOLDING ALL STRUCTURE ATOMS ASSIGNED THUS FAR
          LALLST = KCHLFL(MDSETS)
C
C LOOP OVER ALL QUERY STRUCTURES UP TO BUT NOT INCLUDING THE CURRENT ONE
          DO 4000, MMSTR = LSTRUC+MDSTRU, MSTRUC - MDSTRU, MDSTRU
              NNOTMP = ISTORE (MMSTR)
C
C LOCATE THE PS'S FOR THIS STRUCTURE
              LPSTMP = ISTORE (MMSTR+3)
              NPSTMP = ISTORE (MMSTR+4)
C
              DO 3000, IPSTMP = LPSTMP, LPSTMP+NPSTMP-1
                  MPSTMP = ISTORE(IPSTMP)
                  LSETMP = KCHLFL(MDSETS)
              CALL XUNION(MPSTMP, MPSTMP+(NNOTMP-1)*MDSETS, LSETMP, 3)
C                  CALL OUTSET (' LSETMP ', 3, LSETMP)
3000          CONTINUE
4000      CONTINUE
C
C PUT THE RESULTS FOR SEPARATE STRUCTURES TOGETHER
          CALL XUNION(LSETMP, (LALLST-MDSETS), LALLST, 3)
C          CALL OUTSET (' LALLST ', 3, LALLST)
C
C DELETE LALLST FROM THE CURRENT PS
          DO 6000, MPSL= LPSL, LPSL+(NNODEQ-1)*MDSETS, MDSETS
C
C CARDINALITY
              ISTORE(MPSL+1) = ISTORE(MPSL+1) - ISTORE(LALLST+1)
              DO 5000, I= 1, NINTSU-1
                  ITMP = KKNOT (ISTORE(LALLST+I+1))
                  ISTORE(LPSL+I+1) = KAND(ISTORE(LPSL+I+1),ITMP)
5000          CONTINUE
6000      CONTINUE
          LFL = LFLSAV
      END IF
      RETURN
      END
CODE FOR XSEGEN
      SUBROUTINE XSEGEN

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
C INITIAL SET - GENERATING ROUTINES
C
C INITIALISE THE VARIABLES DESCRIBING SET-HOLDING AREA
      CALL XINSET
C
C BY SPECIES
      IF (INTYPE .EQ. 2) THEN
          CALL XSPECS
      ELSE IF (INTYPE .EQ. 1) THEN
          CALL XASPEC
      END IF
C      CALL OUTSET ( ' AFTER XSPECS ', 1, 0)
      IF (NERRFI .GT. 0) GO TO 9900
C
C BY NODE DEGREE
      CALL XDEGS
C      CALL OUTSET ( ' AFTER XDEGS ', 1, 0)
      IF (NERRFI .GT. 0) GO TO 9900
C
C EXACT ATOM DEGREE
      CALL XEDEGS
C      CALL OUTSET ( ' AFTER XEDEGS ', 1, 0)
      IF (NERRFI .GT. 0) GO TO 9900
C
C FOR BONDS AS NODES, GENERATE SETS BASED ON DISTANCES
      IF (INTYPE .EQ. 2) CALL XPDENS
C      CALL OUTSET ( ' AFTER XPDENS ', 1, 0)
      IF (NERRFI .GT. 0) GO TO 9900
9900  CONTINUE
      RETURN
      END
CODE FOR XSFILE
      SUBROUTINE XSFILE(ICOMBF, ISIZE, LFLPSE, NFLPSE)
C
C SAVE INFO ABOUT A STRUCTURE FILE BELOW LFLPSE AND STICK A POINTER
C TO THIS INFO IN THE FIRST ENTRY OF THE GENERAL STRUCTURE LIST.
C NEED TO SORT OUT EXCLUSION OF SFILE DIRECTIVE BY CTRL=L5 OR L10.
C GIVEN AN SFILE DIRECTIVE, WANT TO SAVE AT LFLPSE END OF STORE:
C    LENGTH OF THE FILENAME INFO IN CHARACTERS (ISIZE)
C    FILENAME
C
C ICOMBF = BEGINNING OF AREA HOLDING INFO READ IN BY
C          PARAMETER READING ROUTINES
C ISIZE  = NO OF CHARACTERS IN FILENAME
C
      CHARACTER *8 CFMTXP
      CHARACTER *80 CBUFF
      LOGICAL LEXIST

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      COMMON/XCARDS/IMAGE(80),NC,ND,LASTCH,NI,NILAST,NS,MON,ICAT,
     2 IEOF,IHFLAG,NUSRQ,NREC,IPOSRQ,ITYPFL,INSTR,IDIRFL,IPARAM,IPARAD,
     3 NWCHAR , LCMAGE(80), IMNSRQ
C
C FREE SPACE FOR THE INFO
      ITOPIN = LFLPSE
      LFLPSE    = LFLPSE - ISIZE - 1
C      DO 999, M=ITOPIN,LFLPSE+1,-1
C       WRITE (6,'(I7,A9)') M, ' SFILE '
C999   CONTINUE
      IF ((LFLPSE-NFLPSE) .LE. 0) THEN
            NERRFI = 19
            GO TO 9900
      END IF
C
C OCCURRENCE, OPTION NUMBER & OVERWRITE/APPEND
      ISTORE (ITOPIN) = ISIZE
C
C FILENAME
      WRITE (CFMTXP, '(2H( , I2, 3HA1))') ISIZE
      WRITE (CBUFF(1:ISIZE), CFMTXP) (LCMAGE(J), J=NC, NC+ISIZE-1)
      INQUIRE (FILE=CBUFF(1:ISIZE), EXIST=LEXIST)
      IF (.NOT. LEXIST) THEN
C NERRFI = NERRFI_NONEXISTENT_SFILE
            NERRFI = 29
            NC = LASTCH + 1
            GO TO 9900
      END IF
      DO 2000, J = NC, NC + ISIZE - 1
            ISTORE (ITOPIN-1+NC-J) = LCMAGE(J)
2000  CONTINUE
      NC = LASTCH + 1
C
C SAVE DETAILS IN GENERAL STRUCTURE LIST
C FILE TYPE
C      ISTORE (LSTRUC+10) = ISTORE (ICOMBF+22)
      ISTORE (LSTRUC+10) = ISTORE (ICOMBF+23)
C POINTER
      ISTORE (LSTRUC+11) = ITOPIN
C
C GET IT OUT TO CHECK
      ITOP  = ITOPIN
      ILENG = ISTORE (ITOP)
      WRITE (CFMTXP, '(2H( , I2, 3HA1))') ILENG
      WRITE (CBUFF(1:ILENG), CFMTXP) (ISTORE (ITOP-J), J=1, ILENG)
C      WRITE (6, *) ' FROM XSFILE: ', CBUFF(1:ILENG)
C      WRITE (6, *) ITOP, ' TO ', ITOP-ILENG
C      WRITE (6, *)
9900  CONTINUE
      RETURN
      END
CODE FOR XSORIF
      SUBROUTINE XSORIF
C
C IF REQUESTED, THE QUERY STRUCTURES WHICH FOLLOW ARE RANKED
C IN ORDER OF DECREASING SIZE OF GRAPH (NOT IN ORDER OF NUMBER
C OF ATOMS)
C
C      LOGICAL SORTED

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
C SORT THE FILES FOR THE STRUCTURES INTO ORDER OF
C DECREASING NUMBER OF NODES.
CLABEL1  CONTINUE
C      SORTED = .TRUE.
C      DO LABEL2, MFILE = 3, NCFILE
C            IF (LFILES (MFILE-1) .LT. LFILES(MFILE)) THEN
C
C SWAP
C                  ILFTMP = LFILES(MFILE)
C                  CFTMP  = CFILES(MFILE)
C                  LFILES(MFILE) = LFILES(MFILE-1)
C                  CFILES(MFILE) = CFILES(MFILE-1)
C                  LFILES(MFILE-1) = ILFTMP
C                  CFILES(MFILE-1) = CFTMP
C                  SORTED = .FALSE.
C            END IF
CLABEL2  CONTINUE
C      IF (.NOT. SORTED) GO TO LABEL1
      RETURN
      END
CODE FOR XSPECS
      SUBROUTINE XSPECS
C
C GENERATE THE SETS CORRESPONDING TO THE ATOMIC SPECIES OF EACH NODE.
C
C SCANS OVER ALL THE STRUCTURES STORED
C FOR EACH STRUCTURE:
C     LOOPS OVER ALL THE NODES.
C     FOR EACH NODE:
C         HAS THIS TYPE OF BOND BEEN FOUND BEFORE?
C                  YES - PUT THIS NODE IN THE APPROPRIATE SET FOR
C                        THIS STRUCTURE.
C                  NO  - REMEMBER THIS TYPE OF NODE.
C                        PUT THIS NODE IN THE APPROPRIATE SET FOR
C                        THIS STRUCTURE.
C
C THE SETS ARE STORED IN THE SET LIST - DESCRIBED IN
C THE BOND TYPES ARE 'REMEMBERED' IN THE STACK STORED IN LOCATIONS
C LTOP...LEND.  EACH ENTRY HOLDS THE ATOM TYPES AT EITHER END OF THE
C BOND AS THE HOLLERITHS ISPEC1 AND ISPEC2.  THIS STACK IS FORGOTTEN ON
C LEAVING THIS ROUTINE.
C
C CURRENTLY ONLY WORKS ON BOND GRAPHS.
C COULD BE ADAPTED TO WORK ON ATOM GRAPHS IF XSPINF IS CHANGED TO FILL
C THE SECOND ATOM SPECIES SLOT WITH A CONSTANT.
C
C GLOBAL VARIABLES:
C LSETS  = FIRST ADDRESS OF SET LIST
C NSETS  = NUMBER OF SETS
C MDSETS = TOTAL LENGTH OF A SET ENTRY (FOR ALL STRUCTURES)
C
C LSTRUC = ADDRESS OF FIRST ENTRY IN GENERAL STRUCTURE LIST
C NSTRUC = NUMBER OF STRUCTURES FOR WHICH SETS ARE BEING GENERATED
C MDSTRU = LENGTH OF AN ENTRY IN GENERAL STRUCTURE LIST
C
C LOCAL VARIABLES:
C NNODES = NUMBER OF NODES IN THE CURRENT STRUCTURE
C LNODES = START OF THE NODE LIST OF THE CURRENT STRUCTURE
C INODES = SERIAL NUMBER OF THE CURRENT NODE
C NADDCH = STORE OF THE ADDRESS OF VARIOUS SET-HOLDING INTEGERS
C NBIT   = POWER OF 2 TO ADD TO A PARTICULAR INTEGER TO SET A BIT
C          !!N.B.!! STARTS AT ZERO, GOES UP TO 30 !!!
C LTOP   = TOP OF THE SET ATOMIC SPECIES STACK (INITIALLY LFL)
C LEND   = END OF THE SET ATOMIC SPECIES STACK
C ISPEC1 = SPECIES OF FIRST ATOM OF BOND
C ISPEC2 = SPECIES OF SECOND ATOM OF BOND
C MOFFSE = OFFSET FROM THE START OF ANY ENTRY IN THE SET LIST FOR SETS
C          OF THE NEXT STRUCTURE
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
      MOFFSE = 1
      LBOSET = LSETS + NSETS*MDSETS
C
C MAKE SURE THAT IF THIS IS THE FIRST SET, THE COMPARISON ISN'T MADE.
C - SET LEND SUCH THE DO LOOP ( TO 3000 ) IS OF ZERO COUNT.
      LTOP   = LFL
      LEND   = LTOP + 2
C
C LOOP OVER ALL THE STRUCTURES
      DO 5000, MSTRUC = LSTRUC, LSTRUC+(MDSTRU*(NSTRUC-1)), MDSTRU
            NNODES = ISTORE (MSTRUC+1)
            LNODES = ISTORE (MSTRUC+2)
C
C LOOP OVER ALL THE NODES FOR THIS STRUCTURE
            DO 4000, MNODES = LNODES, LNODES+(MDNODE*(NNODES-1)), MDNODE
C
C GET THE SPECIES INFO
                  CALL XSPINF (MSTRUC, MNODES, ISPEC1, ISPEC2)
                  IF (NERRFI .NE. 0) GO TO 9900
                  INODES = ((MNODES - LNODES)/MDNODE) + 1
C
C SEARCH DOWN THE STACK OF RECOGNISED BOND SPECIES FOR THIS BOND
                  DO 3000, LTST = LTOP, LEND, -2
                      IF    ((( ISTORE (LTST  ) .EQ. ISPEC1)
     1                  .AND. ( ISTORE (LTST-1) .EQ. ISPEC2))
     2                  .OR. (( ISTORE (LTST  ) .EQ. ISPEC2)
     3                  .AND. ( ISTORE (LTST-1) .EQ. ISPEC1))) THEN
C
C LOCATE THE SET
                        NADDCH =   LBOSET
     1                           + MDSETS*(LTOP-LTST)/2
     2                           + MOFFSE
C
C INCREMENT THE CARDINALITY OF THAT SET
                        ISTORE (NADDCH) = ISTORE (NADDCH) + 1
C
C SET THE APPROPRIATE BIT IN THE SET
C
                        NADDCH = NADDCH + (INODES-1)/L1INT + 1
                        NBIT   = MOD ((INODES-1), L1INT)
               ISTORE (NADDCH) = ISTORE (NADDCH) + (N2POWS(NBIT))
C
C LEAP OVER THE 'NEW OR FIRST NODE TYPE' CODE
                        GO TO 3700
                      END IF
3000  CONTINUE
C
C MUST BE A NEW, OR THE FIRST, BOND TYPE
            NFL = KCHNFL(MDSETS)
            LFL = LFL - 2
C
C STORE THIS BOND SET TYPE BELOW LTOP
            LEND  = LTST
            ISTORE (LEND  ) = ISPEC1
            ISTORE (LEND-1) = ISPEC2
C
C           SET ALL SETS FOR THIS PROPERTY TO EMPTY
                  DO 3500, IEMPTY = LSETS+(MDSETS*NSETS),
     1                              LSETS+(MDSETS*(NSETS+1))-1
                      ISTORE (IEMPTY) = 0
3500  CONTINUE
C
C LOCATE THE SET ( AT ADDRESS NADDCH )
            NADDCH = LSETS + MDSETS*NSETS + MOFFSE
C
C SET THE CARDINALITY TO 1
            ISTORE (NADDCH) = 1
C
C           SET THE BIT FOR THE CURRENT STRUCTURE & THE CURRENT NODE
            NADDCH = NADDCH + (INODES-1)/L1INT + 1
            NBIT   = MOD ( (INODES-1), L1INT)
            ISTORE (NADDCH) = ISTORE(NADDCH) + (N2POWS(NBIT))
C
            NSETS  = NSETS + 1
C
3700  CONTINUE
4000  CONTINUE
C
      MOFFSE = MOFFSE + ISTORE (MSTRUC+15)
5000  CONTINUE
C      CALL OUTSET (' BEFORE Q ATOMS ', 1, 0)
C
C NSSETS = NUMBER OF TYPES OF SPECIES SETS
            NSSETS = NSETS - ((LBOSET - LSETS)/MDSETS)
C
C MLSET  = ADDRESS OF FINAL SET
            MLSET  = LSETS + (NSETS-1)*MDSETS
C
C TREATMENT FOR 'Q' ATOMS
C LOOP OVER THE STACK AGAIN
C CREATE THREE TEMPORARY SETS
            MTSET  = KSTALL (MDSETS)
            MTSET2 = KSTALL (MDSETS)
            MTSET3 = KSTALL (MDSETS)
            DO 9000, LTST = LTOP, LEND, -2
C
C MQSET = SET CORRESPONDING TO CURRENT ENTRY IN BOND STACK
                  MQSET  = LBOSET + ((LTOP-LTST)*MDSETS/2)
                  IF ((ISTORE (LTST  ) .EQ. ISPECQ) .AND.
     1                (ISTORE (LTST-1) .EQ. ISPECQ)) THEN
C
C Q-Q BOND
C FIRST, INCLUDE THE 'Q' ATOMS IN ALL THE OTHER SETS
C MAKE A TEMPORARY COPY
C                        CALL XMOVE(ISTORE(MQSET),ISTORE(MTSET),MDSETS)
C
C LOOP OVER ALL THE SETS
C                        DO 6000, MTSETS=LBOSET, MLSET, MDSETS
C
C MAKE A TEMPORARY COPY
C                              CALL XMOVE(ISTORE(MTSETS),
C     1                                   ISTORE(MTSET2), MDSETS)
C
C DO THE UNION
C                              CALL XUNION ( MTSET, MTSET2, MTSETS, 1)
C6000                    CONTINUE
C
C SECOND, INCLUDE EVERY SPECIES SET INTO THIS ONE
                        CALL XUNION (LBOSET,MLSET,MTSET,1)
C
C MOVE THE UNION FROM ITS CURRENT TEMPORARY POSITION TO MQSET
                        CALL XMOVE(ISTORE(MTSET),ISTORE(MQSET),MDSETS)
                  ELSE IF ((ISTORE (LTST  ) .EQ. ISPECQ)
     1                .OR. (ISTORE (LTST-1) .EQ. ISPECQ)) THEN
C
C ONLY ONE OF THE SPECIES IS A 'Q' - NEED TO BOTH:
C (A) INCLUDE THIS SET IN ALL THE SETS CORRESPONDING TO BONDS IN WHICH
C    THE OTHER ATOM APPEARS
C AND
C (B) INCLUDE IN THIS SET ALL THE SETS CORRESPONDING TO BONDS IN WHICH
C    THE OTHER ATOM APPEARS
C BY TAKING THE APPROPRIATE UNIONS
C MAKE A TEMPORARY COPY
                        CALL XMOVE(ISTORE(MQSET),ISTORE(MTSET),MDSETS)
C
C ISPECO = SPECIES OF THE OTHER ATOM
                        IF (ISTORE (LTST) .EQ. ISPECQ) THEN
                              ISPECO = ISTORE (LTST-1)
                        ELSE
                              ISPECO = ISTORE (LTST  )
                        END IF
C (A)
C CONTINUATION LINES 2 & 3 ADDED 25/5 (Q-Q BONDS)
                        DO 7000, LTTST = LTOP, LEND, -2
                              IF ((ISTORE(LTTST  ) .EQ. ISPECO)
     1                       .OR. (ISTORE(LTTST-1) .EQ. ISPECO))THEN
                                    M=LBOSET+((LTOP-LTTST)*MDSETS/2)
                                    CALL XMOVE (ISTORE(M),
     1                                          ISTORE(MTSET2),MDSETS)
                                    CALL XUNION(MTSET,MTSET2,MTSET3,1)
                                    CALL XMOVE (ISTORE(MTSET3),
     1                                          ISTORE(M),MDSETS)
C      CALL OUTSET (' DURING (A) ', 1, 0)
                              END IF
7000                    CONTINUE
C      CALL OUTSET (' AFTER (A) ', 1, 0)
C (B)
C MBOSET = BOTTOM SET IN A STACK OF SETS TEMPORARILY COPIED TO ENABLE
C          THE UNION
C LINES 2&3 ADDED
                        MBOSET = NFL
                        MSET   = 0
                        DO 8000, LTTST = LTOP, LEND, -2
                              IF ((ISTORE(LTTST  ) .EQ. ISPECO)
     1                       .OR. (ISTORE(LTTST-1) .EQ. ISPECO))THEN
                                    M=LBOSET+((LTOP-LTTST)*MDSETS/2)
                                    MSET  = KSTALL (MDSETS)
                                    CALL XMOVE (ISTORE(M),
     1                                          ISTORE(MSET),MDSETS)
                              END IF
8000                    CONTINUE
                        IF (MSET.GT.0) THEN
                              CALL XUNION(MBOSET,MSET,MTSET2,1)
                              CALL XMOVE(ISTORE(MTSET2),
     1                                   ISTORE(MQSET),MDSETS)
                        END IF
C      CALL OUTSET (' AFTER (B) ', 1, 0)
                  END IF
9000        CONTINUE
C
C RESET LFL AND NFL
      LFL = LTOP
      NFL = MTSET
9900  CONTINUE
      RETURN
      END
CODE FOR XSPINF
      SUBROUTINE XSPINF (MSTRUC, MNODES, ISPEC1, ISPEC2)
C
C RETURNS AS ISPEC1 AND ISPEC2 THE ATOMIC SPECIES ASSOCIATED WITH
C THE NODE MNODES OF THE STRUCTURE MSTRUC
C IF INTYPE=1, ONLY ISPEC1 IS MEANINGFUL

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      LINFO  = ISTORE (MNODES+2)
      IF (INTYPE .EQ. 1) THEN
           ISPEC2 = 0
C
C GET THE SERIAL NUMBER OF THE ATOM
           IF (ISTORE(MSTRUC+10) .EQ. 3) THEN
               ISER1  = 1 + (MNODES-ISTORE(MSTRUC+2))/MDNODE
           ELSE
               ISER1  = 1 + (MNODES-ISTORE(MSTRUC+2))/MDNODE
C               ISER1  = ISTORE(ISTORE(MNODES+2))
C               ISER1  = 1 + (MNODES-ISTORE(MSTRUC+2))/MDNODE
           END IF
           ISPEC1 = KGTSP (ISER1, MSTRUC)
           GO TO 9900
      ELSE IF ( INTYPE .EQ. 2) THEN
C
C GET THE SERIAL NUMBERS OF THE TWO ATOMS IN THE BOND
           ISER1  = ISTORE (LINFO  )
           ISER2  = ISTORE (LINFO+1)
C
C GET THE ADDRESSES OF THE ATOM SPECS (DEPENDS ON HOW THE ATOMS ARE
C STORED)
           ISPEC1 = KGTSP (ISER1, MSTRUC)
           ISPEC2 = KGTSP (ISER2, MSTRUC)
           IF (NERRFI .GT. 0) GO TO 9900
      ELSE
C           NERRFI = NERRFI_BAD_INTYPE
           NERRFI = 40
      END IF
9900  CONTINUE
      RETURN
      END
CODE FOR XSUISO
      SUBROUTINE XSUISO
C
C TEST ALL SETS FOR SUBGRAPH ISOMORPHISM GIVEN THE SETS OF NODES
C ALREADY GENERATED.
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
\XUNITS
C
C RETRIEVE SOME USEFUL INFO ABOUT THE SUPERSTRUCTURE
      NNODSU  = ISTORE (LSTRUC)
      NINTSU  = ISTORE (LSTRUC+15)
      NREMSU  = ISTORE (LSTRUC+1)
C
C
C SET THE LIMIT ON THE MAXIMUM NUMBER OF POSSIBLE ISOMORPHISMS
C      MAXISO  = NNODSU
      MOFFSQ  = 1
C
C
      WRITE (NCAWU, '(A)') 'SEARCHING'
C
C LOOP OVER ALL THE QUERY STRUCTURES
      DO 9000, MSTRUC = LSTRUC + MDSTRU,
     1             LSTRUC +(MDSTRU*(NSTRUC-1)), MDSTRU
C
            LISOMO = .FALSE.
C
            LPSL   = 0
C
C CALCULATE/RETRIEVE THE COMMONLY REQUIRED INFORMATION ABOUT THIS
C SUBSTRUCTURE.
            NNODEQ = ISTORE (MSTRUC)
            NINTQ  = ISTORE (MSTRUC+15)
            MOFFSQ = MOFFSQ + ISTORE (MSTRUC-MDSTRU+15)
            NSTRUQ = ((MSTRUC - LSTRUC)/MDSTRU) + 1
            LSOVER = (ISTORE(MSTRUC+18) .EQ. 1)
            LMULTI = (ISTORE(MSTRUC+ 6) .EQ. 1)
1000  CONTINUE
C
C PARTITION THE NEW SETS ACCORDING TO THIS QUERY STRUCTURE
C TO GIVE A NEW P.S.
C      CALL OUTSET (' BEFORE XPARTI ', 1, 0)
      CALL XPARTI(MSTRUC)
C      CALL OUTSET (' AFTER XPARTI ', 1, 0)
C
      IF (LISOMO) THEN
C
            N = (MSTRUC-LSTRUC)/MDSTRU
            WRITE (NCAWU,'(A,I4)') 'FOUND QUERY ', N
C
C THIS IS THE FIRST PS ADDRESS FOR THIS QUERY; SAVE ITS ADDRESS IN
C ISTORE (MSTRUC+3)
            IF (ISTORE(MSTRUC+3) .EQ. 0) ISTORE(MSTRUC+3) = NTOPIS
C
C SAVE THIS PS ADDRESS
            ISTORE (NTOPIS) = LPSL
C
C INCREMENT BY ONE THE NUMBER OF PS'S SAVED FOR THIS STRUCTURE
            ISTORE (MSTRUC + 4) = ISTORE (MSTRUC + 4) + 1
C
C INCREMENT BY ONE THE ADDRESS OF THE LAST PS SAVED IN THIS AREA
            NTOPIS = NTOPIS + 1
C
C DELETE THIS SUBSTRUCTURE IF DIFFERENT SUBGRAPHS ARE NOT BEING
C ALLOWED TO OVERLAP
C            IF (.NOT. LOVERL) CALL XSDEL
C
C THE STRUCTURE WOULD NOT BE RESOLVED HERE IF IT WERE TO OCCUR MORE
C THAN ONCE.  HENCE DON'T NEED TO COPE WITH MULTIPLE OCCURRENCE HERE.
      ELSE IF (LCV) THEN
C
C SAVE THE FAILURE
            ISTORE (MSTRUC + 3) = -1
      ELSE
C
C APPLY CONNECTIVITY TO THE NEW SETS AND THE PS
C -> A NEW SET OF NEW SETS
             CALL XCONNS
             IF (LNEWS) THEN
C
C GO BACK TO PARTITION
                   GO TO 1000
             ELSE
C
C ASSIGNMENT CODE
C      CALL OUTSET (' BEFORE XASSIG ', 1, 0)
C                   CALL XASSIG(MSTRUC)
                   CALL NEWASS(MSTRUC)
                   IF (NERRFI .GT. 0) GO TO 9900
             END IF
      END IF
C
C END OF LOOP OVER ALL QUERY STRUCTURES.
9000  CONTINUE
9900  CONTINUE
C      CALL OUTSET (' END ', 1, 0)
      RETURN
      END
CODE FOR XULLRF
      SUBROUTINE XULLRF (LPSTT, LSUCC)
C
C LSUCC  TRUE IF NO PROBLEMS ARISE FROM THE REFINEMENT
C LISOMO TRUE IF AN ISOMORPHISM IS EXPOSED
C LALTER TRUE IF IN THE LAST SCAN OF THE PS, ANY BIT WAS ALTERED BY
C             THE ALGORITHM
C NCQNI = CURRENT QUERY NODE (I)
C NCSNJ = CURRENT STRUCTURE NODE (J)
      LOGICAL LSUCC, LALTER, LDEL
      LOGICAL LPRESE, ADJ1, ADJ2

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
      LSUCC  = .TRUE.
      MSTRUQ = LSTRUC + ((NSTRUQ-1)*MDSTRU)
C
C RETURN HERE IF PS WAS ALTERED
1000  CONTINUE
      LALTER = .FALSE.
C
C LOOP OVER THE PS
      DO 8000, MPSTT = LPSTT, LPSTT+((NNODEQ-1)*MDSETS), MDSETS
C
C CARDINALITY OF THE STRUCTURE SET
            ICARDI = ISTORE (MPSTT+1)
            IACCCA = 0
            NCQNI  = ((MPSTT-LPSTT)/MDSETS)+1
C
C LOOP OVER EVERY POSSIBLE PAIRING FOR THIS QUERY NODE
            DO 6000, MSTR = 1, NINTSU-1
                  NTMP   = ISTORE(MPSTT+MSTR+1)
                  IF (NTMP .NE. 0) THEN
                        DO 5000, MBITS = 1, L1INT
                              NTMP2 = N2POWS (MBITS-1)
                              IF (KAND(NTMP2, NTMP) .EQ. NTMP2) THEN
                                    NCSNJ  =((MSTR-1)*L1INT)+MBITS
                                    IACCCA = IACCCA + 1
C
C WE HAVE A SUITABLE PAIR (NCQNI, NCSNJ):
C  ARE THERE MORE NODES CONNECTED TO THE QUERY NODE THAN TO THE
C  STRUCTURE NODE?
      MNODEI = ISTORE(MSTRUQ+2) + ((NCQNI-1)*MDNODE)
      MNODEJ = ISTORE(LSTRUC+2) + ((NCSNJ-1)*MDNODE)
      LDEL   = (ISTORE(MNODEI+1) .GT. ISTORE(MNODEJ+1))
      IF (.NOT. LDEL) THEN
C
C  CONSIDER ALL THE THE CONNECTIONS TO THE QUERY NODE
C  FOR EACH CONNECTION, IS THERE AT LEAST ONE POSSIBLE CORRESPONDENT
C  IN THE SET OF NODES CONNECTED TO THE STRUCTURE NODE?
           LCONNI = ISTORE(MNODEI)
           LCONNJ = ISTORE(MNODEJ)
C
C REWRITE THIS EFFICIENTLY - A FEW TOO MANY DOUBLE NEGATIVES!
           NCONNI = ISTORE(MNODEI+1)
           NCONNJ = ISTORE(MNODEJ+1)
           DO 3000, MCONNI = LCONNI, LCONNI+(NCONNI-1)*3, 3
                 MPSCO = LPSTT+((ISTORE(MCONNI)-1)*MDSETS)
                 LDEL   = .TRUE.
                 DO 2000, MCONNJ = LCONNJ, LCONNJ+(NCONNJ-1)*3, 3
                       NSERJ  = ISTORE (MCONNJ)
                       LDEL   = .NOT. LPRESE(NSERJ, MPSCO, 1)
                       IF (.NOT. LDEL) THEN
C CHECK ADJACENCY CONDITIONS
                           IF (INTYPE .EQ. 1) THEN
C ATOMS AS NODES
                               IF (ADJ1(MCONNI,MCONNJ)) GO TO 2500
                           ELSE IF (INTYPE .EQ. 2) THEN
C BONDS AS NODES + CONNECTIVITY CHECK
                               IF (ADJ2(MCONNI,MCONNJ)) GO TO 2500
                           END IF
                       END IF
2000             CONTINUE
                 IF (LDEL) GO TO 4000
2500             CONTINUE
3000       CONTINUE
      END IF
4000  CONTINUE
      IF (LDEL) THEN
           IF (ISTORE (MPSTT+1) .GT. 1) THEN
C
C DELETE THIS STRUCTURE NODE FROM THE PS
                 CALL XDELNO (NCSNJ, MPSTT, 1)
                 LALTER = .TRUE.
           ELSE
C
C DROP OUT OF ROUTINE AS ZERO CARDINALITY (IE NO CORRESPONDENTS TO THIS
C QUERY NODE) IS IMPLIED.
                 LSUCC  = .FALSE.
                 GO TO 9000
           END IF
      END IF
C
C DROP OUT IF THE CARDINALITY OF THIS STRUCTURE SET HAS BEEN REACHED,
C AND GO ON TO THE NEXT ROW OF THE PS
                                   IF (IACCCA.GE.ICARDI) GO TO 7000
                              END IF
5000                    CONTINUE
                  END IF
6000        CONTINUE
7000        CONTINUE
8000  CONTINUE
      IF (LALTER) GO TO 1000
C
C CHECK HERE FOR AN ISOMORPHISM
            LISOMO = .TRUE.
            DO 8500, MPSTT = LPSTT, LPSTT+ ((NNODEQ-1)*MDSETS), MDSETS
                  IF (ISTORE (MPSTT+1) .NE. 1) THEN
                         LISOMO = .FALSE.
                         GO TO 8600
                  END IF
8500        CONTINUE
8600        CONTINUE
9000  CONTINUE
      RETURN
      END
CODE FOR XUNION
      SUBROUTINE XUNION (M1, M2, M3, IUNION)
C
C TAKES THE UNION OF ALL THE SETS FROM SET ENTRY M1 TO M2, AND STORES
C THE RESULT IN M3.  TAKE CARE WITH THE ORDER - ASSUMES THAT M3 IS
C NOT ONE OF THE SETS BETWEEN M1 AND M2
C
C LOCALS:
C IUNION = 1 IF ALL QUERY STRUCTURE SETS ARE BEING USED
C        = 2 IF ONLY THE STRUCTURE & THE CURRENT QUERY STRUCTURE IS
C            BEING USED.
C        = 3 IF ONLY THE STRUCTURE SETS ARE OF INTEREST.
C NBONDT = TOTAL NUMBER OF BONDS WHICH THE STRUCTURE STARTED OUT WITH
C

      CHARACTER*3 CATFLA, CSERFL, CSPEFL
      CHARACTER*1 CPLUS, CMINUS, CTIMES, CDIV
      CHARACTER*10 CDIGIT
      CHARACTER*5 CNOCC
      CHARACTER*5 CMAXS
      LOGICAL LOVERL,LISOMO,LCV,LNEWS,LEXTEN,LMCS,LSORT,LEXACT,LSOVER,
     1        LNOISO, LPERT, LMULTI
      COMMON /CHFIND/ CATFLA, CSERFL, CSPEFL, CNOCC, CMAXS
      COMMON /ICHFIN/ ISPECQ
      COMMON /CARCHA/ CPLUS, CMINUS, CTIMES, CDIV, CDIGIT
\STORE
      COMMON /UNITS / NKEYBO, NREAD2, NSCREE, NWRIT2, NCHPER
      COMMON/LODATA/ LOVERL, LISOMO, LCV, LNEWS, LEXTEN, LMCS, LSORT,
     C               LEXACT, LSOVER, LNOISO, LPERT, LMULTI
      COMMON /STRUCS/ LSTRUC, NSTRUC, MDSTRU, NCPCKT
      COMMON /GRAPH / MDNODE, INTYPE
      COMMON /ISOMO / NTOPIS
      COMMON /CONNLI/ D12, D12S, TOLER, ITRANS
      COMMON /QUERY / NINTQ, MOFFSQ, NNODEQ, NSTRUQ, NIDENT
      COMMON /SUPER / NINTSU, NNODSU, NREMSU
      COMMON /RSUPER/ RMAXSE
      COMMON /RPARAM/ RTHRES, RMIN, RMAX
      COMMON /RMDEF / RMADEF, RMIDEF
      COMMON /SETS  / LSETS, NSETS, MDSETS, L1INT, LPSL, LNEW
      COMMON /CONS  / IUNIVE
      COMMON /NPOWE2/ N2POWS(0:30)
      COMMON /NMAXIS/ MAXISO, MAXEXT
      COMMON / ERRS / NERRFI
      COMMON /TIMES / INPSCOPY, INXULLRF, INNEWASS
\ISTORE
\QSTORE
C      INCLUDE 'FIND.INC'
C
      IF ((IUNION .NE. 1).AND.(IUNION.NE.2).AND.(IUNION.NE.3))THEN
C
C INCORRECT FOURTH ARGUMENT
            NERRFI = 12
            GO TO 9900
      END IF
C
C TRANSFER THE FIRST ENTRY UP INTO THE DESTINATION AREA.
      IF (IUNION .NE. 3) THEN
          DO 400, MTR = 1, MDSETS
               ISTORE (M3+MTR-1) = ISTORE(M1+MTR-1)
400       CONTINUE
      ELSE
          DO 405, MTR = 1, NINTSU
               ISTORE (M3+MTR-1) = ISTORE(M1+MTR-1)
405       CONTINUE
          DO 410, MTR = NINTSU+1, MDSETS
               ISTORE (M3+MTR-1) = 0
410       CONTINUE
      END IF
C
      DO 3000, MI = M1, M2, MDSETS
            MOFFSE = 1
            DO 2000, MSTRUC = LSTRUC, LSTRUC + (NSTRUC-1)*MDSTRU, MDSTRU
             NINTES = ISTORE (MSTRUC + 15)
             IF (IUNION .EQ. 2) THEN
              IF ((MSTRUC .NE. LSTRUC) .AND.
     1            (MSTRUC .NE. (LSTRUC+(NNODEQ-1)*MDSTRU))) GO TO 1900
             ELSE IF (IUNION .EQ. 3) THEN
              IF (MSTRUC .NE. LSTRUC) GO TO 1900
             END IF
C
C DO THE UNION
             DO 1000, I = 1, NINTES - 1
                   ISTORE (M3+MOFFSE+I)
     1           = KOR   (ISTORE(M3+MOFFSE+I),ISTORE (MI+MOFFSE+I))
1000         CONTINUE
1900         CONTINUE
             MOFFSE = MOFFSE + NINTES
2000        CONTINUE
3000  CONTINUE
C
      MOFFSE = 1
      DO 7000, MSTRUC = LSTRUC, LSTRUC + (NSTRUC-1)*MDSTRU, MDSTRU
            NINTES = ISTORE (MSTRUC + 15)
            IF (IUNION .EQ. 2) THEN
             IF ((MSTRUC .NE. LSTRUC) .AND.
     1           (MSTRUC .NE. (LSTRUC+(NNODEQ-1)*MDSTRU))) GO TO 6500
            ELSE IF (IUNION .EQ. 3) THEN
             IF (MSTRUC .NE. LSTRUC) GO TO 6500
            END IF
            NBONDT = ISTORE (MSTRUC     )
            NCARD  = 0
C
C START CARDINALITY CALCULATION
            DO 505, I = 1, (NINTES - 2)
            DO 500, J=0, L1INT-1
                  NPOWE2 = N2POWS(J)
                  IF (KAND(ISTORE(M3+MOFFSE+I), NPOWE2) .EQ. NPOWE2)
     1                                                 NCARD = NCARD + 1
500         CONTINUE
505         CONTINUE
C
C CONTINUE CARDINALITY CALCULATION - DON'T LOOK AT THE EXCESS BITS AT
C THE END OF THE LAST INTEGER.
C
            I = NINTES - 1
            DO 1500, J=0, MOD ((NBONDT-1), L1INT)
                  NPOWE2 = N2POWS(J)
                  IF (KAND(ISTORE(M3+MOFFSE+I), NPOWE2) .EQ. NPOWE2)
     1                                           NCARD = NCARD + 1
1500        CONTINUE
C
C STORE THE CARDINALITY.
            ISTORE (M3+MOFFSE) = NCARD
            MOFFSE = MOFFSE + NINTES
6500  CONTINUE
7000  CONTINUE
9900  CONTINUE
      RETURN
      END
