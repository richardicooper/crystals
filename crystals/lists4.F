C $Log: not supported by cvs2svn $
C Revision 1.31  2011/05/18 11:49:01  rich
C DJW: extension to L29 to include version info.
C RIC: found bug in Weighting SCHEME 17 - read L30 value for Nparams without loading L30 first.
C
C Revision 1.30  2011/04/04 09:21:07  djw
C Clarify output text about anomalous scatterers.
C
C Revision 1.29  2011/03/21 13:57:21  rich
C Update files to work with gfortran compiler.
C
C Revision 1.28  2011/03/15 09:00:09  djw
C More work on LIST 9
C Routine which use LISTs 5,9,10 all use the same common block, ICOM05, for loading from the disk and for
C creating output.
C If one needs two of these lists in memeory at the same time, the calling routine must sort out the common
C block (l5,l9,l10) addresses itself.
C XFAL09 loads a LIST 9, and saves the LIST 5 addresses if L5 is already in core.
C
C Revision 1.27  2011/02/07 17:01:15  djw
C Use #PUNCH 5 E as a stop-gap mechanism for creating a LIST 9 with paramter esds. The matrix of constraint is applied
C
C Revision 1.26  2011/02/04 17:40:01  djw
C XPCH5E either prints table of esds or creates a LIST 9. Operations need to be separated in the near future
C
C Revision 1.25  2010/09/20 14:59:51  djw
C Enable storage of an auxilliary radiation at the end of each scattering factor record in LIST 3
C
C Revision 1.24  2009/07/31 12:43:03  djw
C Re name the internal command RESTRAIN  to DORESTRAIN so that REESTRAIN can by used as name for LIST 16
C
C Revision 1.23  2007/03/08 11:50:38  djw
C Partial shifts for Stefans code
C
C Revision 1.22  2005/01/23 08:29:11  rich
C Reinstated CVS change history for all FPP files.
C History for very recent (January) changes may be lost.
C
C Revision 1.1.1.1  2004/12/13 11:16:08  rich
C New CRYSTALS repository
C
C Revision 1.21  2004/08/09 11:20:07  rich
C Kill some more NCAWU writes. Fix one XPRVDU where not enough lines
C were output.
C
C Revision 1.20  2003/12/02 11:53:47  rich
C Code to support LIST 42 (XFAL42).
C Memory area to remember unpermuted cell in \FOURIER (L1ORIG).
C Memory area to build output buffer in \REGULARISE (CPCH).
C
C Revision 1.19  2003/08/05 11:11:12  rich
C Commented out unused routines - saves 50Kb off the executable.
C
C Revision 1.18  2003/05/13 15:35:39  djw
C Raise SFLS cycle limit to 10, give warning and abandon if more
C
C Revision 1.17  2003/02/14 17:09:02  djw
C Extend codes to work wih list 6 and list 7.  Note that sfls, calc and
C recine have the parameter ityp06, which corresponds to the types
C pickedip for lists 6 and 7  from the command file
C
C Revision 1.16  2002/11/29 15:28:37  rich
C Tidied XRD33 code (indents only, don't worry: no END DOs)
C
C Revision 1.15  2002/02/13 15:32:19  Administrator
C Reduce calls to SPECIAL in multicycle SFLS, enable shift reversal monitoring, and fix Lachlans shift bounding
C
C Revision 1.14  2002/02/12 12:55:38  Administrator
C Allow filtering of reflections in SFLS/CALC
C
C Revision 1.13  2002/02/01 14:41:29  Administrator
C Enable CALC to get additional R factors and display them in SUMMARY
C
C Revision 1.12  2002/01/09 14:59:17  Administrator
C bound shifts, abandon ill-conditioned problem
C
C Revision 1.11  2001/10/10 17:08:21  Administrator
C Find best-match list 3 and 26 for weird wavelengths - warn user
C
C Revision 1.10  2001/10/05 13:31:51  ckp2
C
C Implementation of Lists 40 and 41.
C ===================================
C New commands:
C #LIST 41 - contains a list of bonds and bondtypes. It is generated by typing
C #BONDCALC which calculates bonds from LIST1,2,5,29 and 40.
C 40 contains info about how to do the bond calculation and can override
C covalent radii, force or break specific bonds and set limits for pairs
C of elements.
C #PUNCH 40 A - produces a LIST 40, #PUNCH 40 B - produces a #BONDING command
C which may be used to input a list 40 in a more user friendy manner (no READ
C card). #BONDING may also be used to EXTEND an existing list 40.
C #SUM L 40 - summary of bonding building info. #SUM L 41 - the bonds.
C #BONDCALC creates a L40 if there is none, and also only carries out calculation
C if significant change has occured to L5. (unless "#BONDCALC FORCE").
C See manual for more details.
C
C Revision 1.9  2001/02/26 10:28:03  richard
C RIC: Added changelog to top of file
C
C
CODE FOR XRD01
      SUBROUTINE XRD01
C--READ LIST TYPE 1, THE CELL PARAMETERS
C
C--
      use lists2_mod, only: xldlst

      INCLUDE 'ISTORE.INC'
      INCLUDE 'ICOM01.INC'
      INCLUDE 'ICOM20.INC'
C
      INCLUDE 'STORE.INC'
C
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XLST20.INC'
      INCLUDE 'XOPVAL.INC'
C
      INCLUDE 'QLST01.INC'
      INCLUDE 'QLST20.INC'
      INCLUDE 'QSTORE.INC'
C
      INCLUDE 'IDIM20.INC'
C
      INCLUDE 'IDIM01.INC'
C--READ THE CELL PARAMETERS FROM THE DATA STREAM
      IF(KRDDPV(ICOM01,IDIM01))1100,1000,1000
C--CALL THE FUNCTION THAT PRODUCES THE OUTPUT LIST 1
1000  CONTINUE
      IF(KFRM01(IDIM01))1100,1050,1050
C--LIST SUCESSFULLY INPUT  -  OUTPUT IT TO DISC
1050  CONTINUE
      CALL XWLSTD(1,ICOM01,IDIM01,-1,1)
C----- LOAD LIST 20
      CALL XLDLST(20,ICOM20,IDIM20,-1)
C----- PREPARE LIST 20 ELEMENTS
      CALL XTRANS(STORE(L1O1),STORE(L20M),3,3)
      CALL XTRANS(STORE(L1O2),STORE(L20I),3,3)
C--STORE THE LIST ON DISC
      CALL XSTR20( 20, 0, 1)
      GOTO 1150
C--ERRORS DURING THE INPUT
1100  CONTINUE
      CALL XOPMSG ( IOPLSI , IOPLSP , 1 )
      CALL XALTES(1,-1)
1150  CONTINUE
      RETURN
      END
C
CODE FOR KFRM01
      FUNCTION KFRM01(ICELL)
C--FORM THE UNIT CELL PARAMETER LIST, LIST 1
C
C  ICELL   A DUMMY ARGUMENT.
C
C--THE RETURN VALUES ARE :
C
C  -1  ERRORS FOUND
C   0  ALL OKAY
C
C--THIS ROUTINE WILL PROCESS EITHER RECIPROCAL OR REAL CELL
C  PARAMETERS. THE PARAMETERS PROVIDED SHOULD BE INDICATED BY
C  SETTING THE REPEAT COUNT FOR THE FIRST PARAMETER OF THE
C  CORRESPONDING DIRECTIVE TO 1 BEFORE THIS ROUTINE IS CALLED. THIS
C  VARIABLE IS LOCATED AT 'ISTORE(LR62D+10)' FOR THE APPROPIATE
C  DIRECTIVE, AND IS AUTOMATICALLY SET DURING INPUT. THE ANGLES
C  CAN PROVIDED IN DEGREES OR AS THEIR COSINES, SO THAT FOUR POSSIBLE
C  INPUT FORMATS ARE ALLOWED :
C
C  1  REAL CELL AND ANGLES
C  2  REAL CELL AND COSINES
C  3  RECIPROCAL CELL AND ANGLES
C  4  RECIPROCAL CELL AND COSINES
C
C--
      INCLUDE 'ICOM01.INC'
      INCLUDE 'ISTORE.INC'
C
      DIMENSION AA(26),IADD1(4),IADD2(3)
      ! doing some calculations in double precision to improve numerical stability
      double precision, dimension(26) :: aad
      integer, parameter :: dp=kind(1.0d0)
      double precision od, hd, dstore
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XLST50.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XCONST.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XIOBUF.INC'
      INCLUDE 'XSSVAL.INC'
C
      INCLUDE 'QLST01.INC'
      INCLUDE 'QSTORE.INC'
C
      EQUIVALENCE (AA(1),A)
      EQUIVALENCE (U,NU),(V,NV),(W,NW),(X,NX),(Y,NY),(Z,NZ)
C
C
      DATA IADD1(1)/2/,IADD1(2)/3/,IADD1(3)/1/,IADD1(4)/2/
      DATA IADD2(1)/5/,IADD2(2)/-2/,IADD2(3)/-5/
C
      ICELL = ICELL
      INCLUDE 'IDIM01.INC'
C--LOAD THE POINTERS FOR THE REAL CELL PARAMETERS INPUT DIRECTIVE
      CALL XDIRFL(1,ICOM01,IDIM01)
C--ASSUME THAT THE REAL CELL PARAMETERS HAVE BEEN INPUT
      M=L1P1
      N=L1P2
C--CHECK IF THE REAL CELL PARAMETERS ARE INDICATED
      IF(ISTORE(LR62D+10))1000,1000,1050
C--A REAL CELL PARAMETER HAS NOT BEEN INPUT
1000  CONTINUE
      M=L1P2
      N=L1P1
C--CHECK IF THE ANGLES OR THEIR COSINES HAVE BEEN INPUT
1050  CONTINUE
      K=M+3
      IF(ABS(STORE(K))-1.1)1100,1200,1200
1100  CONTINUE
C--CONVERT THE COSINES TO THE ANGLES
      DO 1150 I=1,3
      STORE(K)=ACOS(STORE(K))
      K=K+1
1150  CONTINUE
      GOTO 1300
C--CONVERT THE INPUT ANGLES FROM DEGREES TO RADIANS
1200  CONTINUE
      DO 1250 I=1,3
      STORE(K)=STORE(K)*DTR
      K=K+1
1250  CONTINUE
C--START TO CALCULATE THE MISSING CELL PARAMETERS AND VOLUMES
1300  CONTINUE
      NW=1
      NX=M+2
C--CALCULATE THE SINE AND COSINES OF THE INPUT ANGLES
      DO 1350 NY=M,NX
      AA(NW)=COS(STORE(NY+3))
      AA(NW+3)=SIN(STORE(NY+3))
      AAD(NW)=COS(real(STORE(NY+3),dp))
      AAD(NW+3)=SIN(real(STORE(NY+3), dp))
      NW=NW+1
1350  CONTINUE
C--CALCULATE THE VOLUMES
      O=STORE(M)*STORE(M+1)*STORE(M+2)
      od=real(STORE(M), dp)*real(STORE(M+1), dp)*real(STORE(M+2), dp)
      ! replaced with double precision calculation
      !STORE(M+6)=O*SQRT(1.-A*A-B*B-C*C+2.*A*B*C)
      dstore=Od*SQRT(
     1  1.d0-aad(1)**2-aad(2)**2-aad(3)**2+2.d0*Aad(1)*aad(2)*aad(3))
      ! replaced with double precision calculation
      STORE(M+6)=dstore
      STORE(N+6)=1.0d0/dstore
      O=Od*1.0d0/dstore
      Od=Od*1.0d0/dstore
C--CALCULATE THE MISSING PARAMETERS
      H=1./(D*E*F)
      Hd=1.0d0/(aad(4)*aad(5)*aad(6))
      NU=1
      NZ=N
      DO 1400 NY=M,NX
      NV=IADD1(NU)
      NW=IADD1(NU+1)
      ! replaced with double precision calculation
      !STORE(NZ)=O*AA(NU+3)/STORE(NY)
      !STORE(NZ+3)=ACOS((AA(NV)*AA(NW)-AA(NU))*AA(NU+3)*H)
      STORE(NZ)=Od*AAD(NU+3)/STORE(NY)
      STORE(NZ+3)=ACOS((AAD(NV)*AAD(NW)-AAD(NU))*AAD(NU+3)*Hd)
      NU=NU+1
      NZ=NZ+1
1400  CONTINUE
C--CALCULATE THE ORTHOGONALIZATION MATRICES
      STORE(L1O1)=STORE(L1P1)*
     1  SIN(real(STORE(L1P1+4),dp))*SIN(real(STORE(L1P2+5),dp))
      STORE(L1O1+1)=0.
      STORE(L1O1+2)=0.
      STORE(L1O1+3)=-STORE(L1P1)*
     1  SIN(real(STORE(L1P1+4),dp))*COS(real(STORE(L1P2+5), dp))
      STORE(L1O1+4)=STORE(L1P1+1)*SIN(real(STORE(L1P1+3), dp))
      STORE(L1O1+5)=0.
      STORE(L1O1+6)=STORE(L1P1)*COS(real(STORE(L1P1+4), dp))
      STORE(L1O1+7)=STORE(L1P1+1)*COS(real(STORE(L1P1+3), dp))
      STORE(L1O1+8)=STORE(L1P1+2)
C--CALCULATE THE INVERSE ORTHOGONALISATION MATRIX
      IF(KINV2(3,STORE(L1O1),STORE(L1M2),9,0,STORE(L1M1),STORE(L1M1+9),
     2 9))1450,1550,1450
C--THE REAL ORTHOGONALISATION MATRIX IS SINGULAR
1450  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1500)
      WRITE ( CMON, 1500)
      CALL XPRVDU(NCVDU, 2,0)
1500  FORMAT(/,' Singular orthogonalisation matrix',/)
      GOTO 1750
C--NOW TRANSPOSE THIS MATRIX SO THAT IT IS STORED BY ROWS
1550  CONTINUE
      CALL XTRANS(STORE(L1M2),STORE(L1O2),3,3)
C--CALCULATE THE ORTHOGONALISATION MATRICES WITHOUT CELL PARAMS.
      DO 1650 I=1,3
      NU=L1O1+I
      NV=L1P1+I
      NW=L1O1+MD1O1+I
      NX=L1O2+I
      NY=L1P2+I
      NZ=L1O2+MD1O2+I
C--LOOP OVER A GIVEN PARAMETER
      DO 1600 J=1,3
      STORE(NW-1)=STORE(NU-1)/STORE(NV-1)
      STORE(NZ-1)=STORE(NX-1)/STORE(NY-1)
      NU=NU+3
      NW=NW+3
      NX=NX+3
      NZ=NZ+3
1600  CONTINUE
1650  CONTINUE
C--CALCULATE THE METRIC TENSORS
      CALL XMLTMT(STORE(L1O1),STORE(L1O1),STORE(L1M1),3,3,3)
      CALL XMLTMT(STORE(L1O2),STORE(L1O2),STORE(L1M2),3,3,3)
C--AND NOW THE METRIC TENSORS WITHOUT CELL PARAMETERS
      NU=L1O1+MD1O1
      NV=L1M1+MD1M1
      CALL XMLTMT(STORE(NU),STORE(NU),STORE(NV),3,3,3)
      NU=L1O2+MD1O2
      NV=L1M2+MD1M2
      CALL XMLTMT(STORE(NU),STORE(NU),STORE(NV),3,3,3)
C--CALCULATE THE ANISO TEMPERATURE FACTOR AND RIJ TERMS
      I=L1P2+3
      J=L1M2
      DO 1700 NX=1,3
C--TERMS FOR CONVERSION FROM ISO TO ANISO ATOMS
      NU=L1C+NX
      STORE(NU-1)=COS(STORE(I))
C--RIJ TERMS NOW
      NU=L1S+NX
      STORE(NU-1)=0.25*STORE(J)
      NY=J+IADD2(NX)
      STORE(NU+2)=0.5*STORE(NY)
C--T.F. TERMS NOW
      NU=L1A+NX
      STORE(NU-1)=-TWOPIS*STORE(J)
      NY=L1P2+IADD1(NX)
      NZ=L1P2+IADD1(NX+1)
      STORE(NU+2)=-2.0*TWOPIS*STORE(NY-1)*STORE(NZ-1)
      I=I+1
      J=J+4
1700  CONTINUE
C--SET THE RETURN VALUE AND EXIT
      KFRM01=0
      GOTO 1800
C--ERRORS FOUND
1750  CONTINUE
      KFRM01=-1
1800  CONTINUE
      RETURN
      END
C
CODE FOR XFAL01
      SUBROUTINE XFAL01
C--ROUTINE TO LOAD LIST 1 FROM THE DISC
C
C--
      use lists2_mod, only: xldlst

      double precision D(3), RN, CALP, CBET, CGAM
      integer, parameter :: dp=kind(1.0d0)
      INCLUDE 'ICOM01.INC'
C
      INCLUDE 'XLST01.INC'
      INCLUDE 'STORE.INC'
      INCLUDE 'XGUIOV.INC'
C
      INCLUDE 'QLST01.INC'
C
      INCLUDE 'IDIM01.INC'
C--LOAD THE LIST
      CALL XLDLST(1,ICOM01,IDIM01,-1)
C----- LOAD THE MATRIX FOR THE GUI
      CALP=COS(real(STORE(L1P1+3),dp))
      CBET=COS(real(STORE(L1P1+4),dp))
      CGAM=COS(real(STORE(L1P1+5),dp))
      RN=SQRT(1.0d0+2.0d0*CALP*CBET*CGAM-CALP**2-CBET**2-CGAM**2)
      D(1)=SIN(real(STORE(L1P1+3),dp))/(RN*STORE(L1P1))
      D(2)=SIN(real(STORE(L1P1+4),dp))/(RN*STORE(L1P1+1))
      D(3)=SIN(real(STORE(L1P1+5),dp))/(RN*STORE(L1P1+2))
      DO 110 I=1,3
       DO 120 J=1,3
        K=J-3+I*3
        L=I-3+J*3
        GUMTRX(K) = STORE(L1O1+K-1)
        GUMTRX(K+9) = STORE(L1O2+K-1)
        GUMTRX(L+18)= GUMTRX(K)*D(J)
120    CONTINUE
110   CONTINUE
      LGUIL1 = .TRUE.
      RETURN
      END
C
CODE FOR XSPCFM
      SUBROUTINE XSPCFM ( CSYMIN , IUNIQU , ISPECI , CSYMOU )
C
C -- REFORMAT A SPACE GROUP SYMBOL, POSSIBLY APPLYING THE UNIQUE AXIS
C    CONSTRAINT SPECIFIED
C
C -- INPUT :-
C      CSYMIN      INPUT SYMBOL
C      IUNIQU      UNIQUE AXIS SPECIFIED ( IGNORED EXCEPT FOR MONOCLINIC
C                  SPACE GROUPS IN WHICH ONLY ONE AXIS IS SPECIFIED )
C                    1  A UNIQUE
C                    2  B UNIQUE
C                    3  C UNIQUE
C      ISPECI      METHOD BY WHICH IUNIQU WAS DETERMINED
C                    1  USER SPECIFIED
C                    2  WORKED OUT FROM LIST 1
C                    3  ARBITRARY ASSIGNMENT BY THE PROGRAM
C
C -- OUTPUT :-
C      CSYMOU      OUTPUT SYMBOL
C
C
C
C
      CHARACTER*(*) CSYMIN , CSYMOU
C
      PARAMETER ( NAXIS = 3 )
      DIMENSION IAXIS1(NAXIS), IAXIS2(NAXIS), IAXIST(NAXIS)
C
      CHARACTER*1 CAXIS(3)
      CHARACTER*32 CREASN(3)
C
      PARAMETER ( NALLOW = 16 )
      CHARACTER*1 CALLOW(NALLOW)
      DIMENSION IATYPE(NALLOW)
C
C
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      DATA CALLOW / '-' , '6' , '5' , '4' , '3' , '2' , '1' ,
     2              '/' , 'M' , 'A' , 'B' , 'C' , 'D' , 'N' ,
     3              '(' , ')' /
C
      DATA IATYPE /  0 ,   6 ,   0  ,   4 ,   3 ,   2 ,   1 ,
     2               0 ,   2 ,   2  ,   2 ,   2 ,   2 ,   2 ,
     3               0 ,   0 /
C
      DATA CAXIS / 'a' , 'b' , 'c' /
      DATA CREASN / 'explicitly requested by the user' ,
     2              'consistent with the unit cell' ,
     3              'assumed by the program' /
C
C
C
C
C -- SET LIMITS ON SYMBOL SCAN
C
      IPOS = 1
      MAXLEN = LEN ( CSYMIN )
C
C -- GIVE INITIAL VALUES TO AXIS INTERPRETATIONS
C
      DO 1100 I = 1  , NAXIS
        IAXIST(I) = 0
        IAXIS1(I) = -1
        IAXIS2(I) = -1
1100  CONTINUE
C
C
C -- FIND THE LATTICE TYPE SYMBOL
C
      IPOS = KCCNEQ ( CSYMIN , IPOS , ' ' )
      IF ( IPOS .LE. 0 ) GO TO 9910
C
      ILATTP = IPOS
      ILATEN = IPOS
      IF (CSYMIN(IPOS+1:IPOS+1) .NE. ' ') GOTO 9940
C
C -- SCAN THE REST OF THE SYMBOL
C
C
      INONSP = KCCNEQ ( CSYMIN , IPOS + 1 , ' ' )
      IF ( INONSP .LE. 0 ) GO TO 9930
C
      IWASSP = 1
      NFOUND = 0
C
      DO 2000 I = INONSP , MAXLEN
        IF ( CSYMIN(I:I) .EQ. ' ' ) THEN
          IWASSP = 1
          GO TO 2000
        ENDIF
C
        IF ( IWASSP .EQ. 1 ) THEN
          NFOUND = NFOUND + 1
          IAXIS1(NFOUND) = I
        ENDIF
C
        IWASSP = 0
C
        ITYPE = KCCOMP ( CSYMIN(I:I) , CALLOW , NALLOW , 1 )
        IF ( ITYPE .LE. 0 ) GO TO 9920
        IF ( IAXIST(NFOUND) .LE. 0 ) THEN
          IAXIST(NFOUND) = MAX (IATYPE(ITYPE), IAXIST(NFOUND) )
        ENDIF
C
        IAXIS2(NFOUND) = I
2000  CONTINUE
C
      DO 2001 I = 1,3
        IF (IAXIS2(I)-IAXIS1(I) .GT. 3 ) GOTO 9950
2001  CONTINUE
C
C -- FIX UP MONOCLINIC SYMBOLS
C
      IF ( NFOUND .EQ. 1 ) THEN
        IF ( IAXIST(1) .EQ. 2 ) THEN
      IF (ISSPRT .EQ. 0) THEN
          WRITE ( NCWU , 6005 ) CAXIS(IUNIQU) , CREASN(ISPECI)
      ENDIF
          WRITE ( CMON, 6005 ) CAXIS(IUNIQU), CREASN(ISPECI)
          CALL XPRVDU(NCVDU, 1,0)
6005      FORMAT (1X , 'The unique axis has been set to "' , A1 ,
     2 '" - ' , A32 )
C
          IAXIS1(IUNIQU) = IAXIS1(1)
          IAXIS2(IUNIQU) = IAXIS2(1)
          IAXIST(IUNIQU) = IAXIST(1)
          DO 6100 I = 1 , 3
            IF ( I .EQ. IUNIQU ) GO TO 6100
            IAXIST(I) = -1
6100      CONTINUE
          NFOUND = 3
        ENDIF
      ENDIF
C
      IF (NFOUND .EQ. 1) THEN
        IOFSET = 2
      ELSE
        IOFSET = 1
      ENDIF
C
8000  CONTINUE
C
C
C -- GENERATE THE RESULTANT SYMBOL
C
      CSYMOU = ' '
      IPOS = 1
C
C -- INSERT THE LATTICE TYPE
C
      CSYMOU(IPOS:) = CSYMIN(ILATTP:ILATEN)
      IPOS = IPOS + ( ILATEN - ILATTP ) + IOFSET
C
C -- INSERT EACH AXIS SYMBOL - EITHER A GENERATED '1', NO SYMBOL, OR
C    THE ACTUAL INPUT
C
      DO 8200 I = 1 , 3
        IF ( IAXIST(I) .EQ. -1 ) THEN
          CSYMOU(IPOS:) = '1'
          IPOS = IPOS + 2
        ELSE IF ( IAXIST(I) .EQ. 0 ) THEN
        ELSE
          DO 8100 J = IAXIS1(I) , IAXIS2(I)
            IF ( CSYMIN(J:J) .EQ. ' ' ) GO TO 8100
            CSYMOU(IPOS:IPOS) = CSYMIN(J:J)
            IPOS = IPOS + 1
8100      CONTINUE
          IPOS = IPOS + 1
        ENDIF
8200  CONTINUE
C
C
9000  CONTINUE
      RETURN
C
C
9900  CONTINUE
      CALL XERHND ( IERERR )
      GO TO 9000
9910  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 9915 )
      ENDIF
      WRITE ( CMON, 9915 )
      CALL XPRVDU(NCVDU, 1,0)
9915  FORMAT ( 1X , 'The space group symbol is missing' )
      GO TO 9900
9920  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 9925 ) CSYMIN(1:MAXLEN)
      ENDIF
      WRITE ( CMON, 9925 ) CSYMIN(1:MAXLEN)
      CALL XPRVDU(NCVDU, 1,0)
9925  FORMAT ( 1X, 'The symbol "', A, '" contains an illegal character')
      GO TO 9900
9930  CONTINUE
      IF (ISSPRT .EQ. 0) THEN
      WRITE ( NCWU , 9935 )
      ENDIF
      WRITE ( CMON, 9935 )
      CALL XPRVDU(NCVDU, 1,0)
9935  FORMAT ( 1X , 'The symbol given is too short' )
      GO TO 9900
C
9940  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 9945 )
      WRITE ( CMON, 9945)
      CALL XPRVDU(NCVDU, 1,0)
9945  FORMAT(' The parts of the symbol MUST be separated by spaces')
      GOTO 9900
9950  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 9955 ) I
      WRITE ( CMON, 9955) I
      CALL XPRVDU(NCVDU, 1,0)
9955  FORMAT(' Part',I5,' of the symbol contains too many characters')
      GOTO 9900
      END
CODE FOR XSAVSG
      SUBROUTINE XSAVSG(LBUFF2, NBUFF2)
C
C----- STORE THE SPACE GROUP SYMBOL IN LIST 2
C      LBUFF2  START OF SYMBOL IN ISTORE
C      NBUFF2  NO OF TERMS ITEMS IN REPRESENTATION
C
C      FIRST ITEM IS LATTICE TYPE, FOLLOWED DIRECTLY BY FIRST SYMBOL.
C      OTHER SYMBOLS SEPARATED BY SPACES.
C
      INCLUDE 'ISTORE.INC'
      INCLUDE 'ICOM02.INC'
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST02.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QLST02.INC'
C
      IERFLG = -1
      CALL XFILL (IB, ISTORE(L2SG), MD2SG)
      M2SG = L2SG
C----- WE USE A 4 WORD WORKAREA AT NFL
      L = NFL
      CALL XFILL (IB, ISTORE(L), 4)
C----- LATTICE TYPE
      ISTORE(L) = ISTORE(LBUFF2)
      CALL XSRA (ISTORE(L), ISTORE(M2SG))
      CALL XFILL (IB, ISTORE(L), 4)
      M2SG = M2SG + 1
      J = LBUFF2 + 1
      M = L2SG + MD2SG
      DO 1000 I = 2,NBUFF2
C----- LOOK FOR A BLANK
      IF (ISTORE(J) .NE. IB) THEN
        ISTORE(L) = ISTORE(J)
        L = L + 1
      ELSE
C-----  CHECK THERE IS SOMETHING TO SAVE
        IF(L .NE. NFL) THEN
            IF (M2SG .GE. M) GOTO 1100
            L = NFL
            CALL XSRA (ISTORE(L), ISTORE(M2SG))
            CALL XFILL (IB, ISTORE(L), 4)
            M2SG = M2SG + 1
            ENDIF
      ENDIF
      J = J + 1
1000  CONTINUE
      IERFLG = 1
1100  CONTINUE
      RETURN
      END
C
C
CODE FOR XRD02
      SUBROUTINE XRD02
C--READ LIST TYPE 2, THE SYMMETRY RELATIONSHIPS
C
C--DURING THE SYMMETRY OPERATOR READING, THE FOLLOWING VARIABLES ARE USE
C
C  N3  THE NUMBER OF OPERATORS READ.
C  N4  NUMBER CONTROL FLAG :
C
C      0  NO NUMBER READ YET
C      1  NUMBER READ FOR THIS OPERATOR.
C
C  N5  NEXT ARGUMENT TYPE CONTROL :
C
C      0  NEXT ARGUMENT MUST BE AN OPERATOR.
C      1  NEXT ARGUMENT MUST BE X, Y, Z OR A NUMBER.
C
C--
      INCLUDE 'ICOM02.INC'
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XWORK.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XCARDS.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XLST02.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
C
      EQUIVALENCE (M1,H),(N1,D),(N5,E),(N3,F),(N4,G)
      INCLUDE 'QLST02.INC'
      INCLUDE 'QSTORE.INC'
C
      INCLUDE 'IDIM02.INC'
C--INDCIATE NO INITIAL DIRECTIVE
      IDIR=-1
C--READ THE NEXT DIRECTIVE FROM THE INPUT STREAM
1000  CONTINUE
      LAST=IDIR
      IDIR=KRDNDC(ICOM02,IDIM02)
C--CHECK THE REPLY
      IF(IDIR)2750,1050,1200
C--CONTINUATION CARD  -  CHECK THE LAST DIRECTIVE
1050  CONTINUE
      IF(LAST-1)1100,1100,1750
C--READ THE NEXT PARAMETER OFF THE CURRENT CARD
1100  CONTINUE
      IDWZAP = 0
      IF(KFNDNP(IDWZAP))1000,1000,1150
C--READ THE VALUE
1150  CONTINUE
      IF(KRDPV(ICOM02,IDIM02))1000,1100,1100
C--NEW DIRECTIVE  -  CHECK ITS TYPE
1200  CONTINUE
      IF (IDIR .LE. 1) GOTO 1100
      IF (IDIR .NE. 2) GOTO 1100
C
C--READ THE NEXT SYMMETRY OPERATOR
      CALL XZEROF(STORE(IPARAD),MD2)
C--READ THE PARAMETER KEYWORD
1300  CONTINUE
      IDWZAP = 0
      IF(KFNDNP(IDWZAP))1000,1000,1350
C--SET THE FLAGS FORM THE NEXT PART OF THIS OPERATOR
1350  CONTINUE
      K=IPARAD+(IPARAM-1)*3
      M=IPARAD+IPARAM+8
      N3=0
      N4=0
C--CHECK FOR AN INITIAL '+' OR '-' SIGN
      C=1.
      N5=0
      IF(IMAGE(NC).EQ.IPLUS)GOTO 1650
      IF(IMAGE(NC).EQ.MINUS)GOTO 1550
C--INITIAL ARGUMENT MUST A COORDINATE OR NUMBER
      N5=1
      GOTO 2000
C
C--CHECK THE NEXT ARGUMENT FOR A '+' OR '-' SIGN
1400  CONTINUE
      IF(IMAGE(NC).EQ.IPLUS)GOTO 1600
      IF(IMAGE(NC).EQ.MINUS)GOTO 1550
C--NOT A '+' OR '-' SIGN  -  CHECK THE TYPE OF ARGUMENT REQUIRED
      IF(N5)1750,1450,2000
C--OPERATOR EXPECTED  -  CHECK FOR ','
1450  CONTINUE
      IF(IMAGE(NC).NE.ICOMMA)GOTO 1500
C--WE HAVE FOUND ','  -  UPDATE THE POINTERS
      NC=NC+1
C--CHECK IF THE LAST OPERATOR ENDED CORRECTLY
      IF(N3)1750,1750,1300
C--NOT A ','  -  CHECK FOR ';' AND FAIL IF NOT
1500  CONTINUE
      IF(IMAGE(NC).NE.ISEMIC)GOTO 1750
C--WE HAVE FOUND ';'  -  UPDATE AND CHECK IF THIS IS VALID
      NC=NC+1
      IF(N3)1750,1750,1000
C
C--'-' FOUND  -  ALTER 'C'
1550  CONTINUE
      C=-1.
      GOTO 1650
C--'+' FOUND  -  ALTER 'C'
1600  CONTINUE
      C=1.
C--CHECK IF '+' OR '-' SHOULD BE HERE
1650  CONTINUE
      IF(N5)1750,1700,1750
C--UPDATE THE CHARACTER POSITION
1700  CONTINUE
      N5=1
      NC=NC+1
      NC=KNEQUL(NC,IB)
C--CHECK FOR END OF CARD
      IF(NC)1750,1750,1400
C
C--ERROR IN THIS SYMMETRY OPERATOR
1750  CONTINUE
      JCAT=ICAT
      ICAT=1
      CALL XMONTR(0)
      ICAT=JCAT
C--CHECK FOR END OF CARD
      IF(NC)1800,1800,1850
C--END OF CARD  -  ADJUST THE VALUE
1800  CONTINUE
      NC=LASTCH
C--WRITE THE POSITION OUT
1850  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1900)(IB,I=1,NC),IA
      WRITE ( CMON, 1901) (IB,I=1,MIN(71,NC)),IA
      CALL XPRVDU(NCVDU, 1,0)
1901  FORMAT(5X,82A1)
1900  FORMAT(7X,82A1)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1950)
      WRITE ( CMON, 1950)
      CALL XPRVDU(NCVDU, 1,0)
1950  FORMAT(' Symmetry operator format error,',
     2 ' marked by an ''*''')
      LEF=LEF+1
      IDIRFL=-1
      GOTO 1000
C
C--NOW CHECK FOR X, Y OR Z.
2000  CONTINUE
      N5=0
      J=KCOMP(1,IMAGE(NC),IX(1),3,1)
      IF(J)2300,2300,2050
C--COORDINATE FOUND  -  CHECK THAT THIS IS THE FIRST TIME
2050  CONTINUE
      J=K+J
      IF(NINT(STORE(J-1)))1750,2100,1750
C--UPDATE THE COUNTER AND STORE THE OPERATOR
2100  CONTINUE
      N3=N3+1
      STORE(J-1)=C
C--UPDATE THE CARD POSITION
      NC=NC+1
C--FIND THE NEXT NON-BLANK CHARACTER
2200  CONTINUE
      NC=KNEQUL(NC,IB)
      IF(NC)2250,2250,1400
C--END OF CARD  -  CHECK THAT THE LAST OPERATOR ENDED CORRECTLY
2250  CONTINUE
      IF(N3)1750,1750,1000
C
C--NOW CHECK FOR A NUMBER  -  THE ONLY THING LEFT
2300  CONTINUE
      IF(N4)2350,2350,1750
C--WE HAVE NOT FOUND A NUMBER BEFORE  -  ATTEMPT TO READ ONE
2350  CONTINUE
      N4=1
      IF(KINPUT(A))2500,2400,1750
C--NUMBER READ OKAY  -  SEARCH FOR THE NEXT NON-BLANK CHARACTER
2400  CONTINUE
      IF(IMAGE(NC-1).EQ.ICOMMA)NC=NC-1
      NC=KNEQUL(NC,IB)
      IF(NC)2450,2450,2500
C--END OF CARD  -  CHECK ITS VALIDITY
2450  CONTINUE
      STORE(M)=A*C
      GOTO 2250
C--NUMBER FOLLOWED BY MORE CHARACTERS
2500  CONTINUE
      IF(IMAGE(NC).EQ.ISLASH)GOTO 2550
C--NOT FOLLOWED BY '/'  -  END OF NUMBER
      STORE(M)=A*C
      GOTO 1400
C--NUMBER OF FOLLOWED BY '/'  -  READ THE REST OF THE FRACTION
2550  CONTINUE
      NC=NC+1
      NC=KNEQUL(NC,IB)
      IF(NC)1750,1750,2600
C--READ THE REST OF THE NUMBER
2600  CONTINUE
      IF(KINPUT(B))2650,2650,1750
C--CHECK THAT IT IS NOT ZERO
2650  CONTINUE
      IF(IMAGE(NC-1).EQ.ICOMMA)NC=NC-1
      IF(B-0.001)1750,1750,2700
C--COMPUTE THE NUMBER
2700  CONTINUE
      STORE(M)=C*A/B
      GOTO 2200
C
C--CHECK THAT THE INPUT WENT OKAY
2750  CONTINUE
      IF(LEF)3050,2800,3050
C--INPUT OKAY  -  CALCULATE THE INVERSE MATRICES
2800  CONTINUE
      M2=L2
      M2I=L2I
      DO 3000 I=1,N2
      IF(KINV2(3,STORE(M2),STORE(M2I),9,0,STORE(L2T),STORE(L2T+3),3))
     2 2850,2950,2850
C--SINGULAR MATRIX
2850  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU,2900)I
      WRITE ( CMON, 2900) I
      CALL XPRVDU(NCVDU, 1,0)
2900  FORMAT(' Matrix',I5,'  is singular')
      GOTO 3050
C--UPDATE FOR THE NEXT MATRIX
2950  CONTINUE
      STORE(M2I+9)=-STORE(M2+9)
      STORE(M2I+10)=-STORE(M2+10)
      STORE(M2I+11)=-STORE(M2+11)
      M2=M2+MD2
      M2I=M2I+MD2I
3000  CONTINUE
C--CALCULATE THE NON-PRIMITIVE LATTICE TRANSLATIONS
      CALL XLAT(STORE(L2P))
      CALL XUDRH(2,105,0,N2P)
C--CALCULATE THE FIRST MULTIPLIER
      G2=FLOAT(IC+1)*FLOAT(N2P)
C--COMPUTE THE SECOND MULTIPLIER
      T2=G2*FLOAT(N2)
C--SET UP THE CONSTANTS BLOCK
      STORE(L2C)=FLOAT(IC)
      STORE(L2C+1)=FLOAT(IL)
      STORE(L2C+2)=G2
      STORE(L2C+3)=T2
C--FORM THE LIST ON THE DISC
      CALL XWLSTD(2,ICOM02,IDIM02,-1,1)
      GOTO 3100
3050  CONTINUE
      CALL XOPMSG ( IOPLSI , IOPLSP , 2 )
      CALL XALTES (2,-1)
      CALL XERHND ( IERERR )
3100  CONTINUE
      RETURN
      END
C
CODE FOR XLAT
      SUBROUTINE XLAT(HL)
C--SET UP IN HL THE UNIT CELL SHIFTS FOR THE NON-PRIMITIVE LATTICE
C
C  HL  THE ARRAY IN WHICH THE OPERATORS ARE SET UP
C
C--THIS SUBROUTINE ALSO SETS SOME VARIABLES AS WELL AS 'HL'
C
C  N2P  THE NUMBER OF SPEARATE SHIFT VECTORS NEEDED TO DESCRIBE
C       THIS LATTICE.
C
C--
C
      DIMENSION HL(12)
C
      INCLUDE 'XLST02.INC'
C
C--SET UP 'N2P'
      N2P=IL
C--CHECK IF THIS LATTICE IS 'A', 'B' OR 'C' CENTRED
      IF(IL-4)1050,1050,1000
C--ADJUST 'N2P' ACCORDINGLY
1000  CONTINUE
      N2P=2
C--SET UP THE NULL OPERATOR
1050  CONTINUE
      DO 1100 I=1,3
      HL(I)=0.
1100  CONTINUE
      GOTO(1550,1150,1300,1400,1150,1150,1150),IL
C--'I' , 'A' , 'B' OR 'C' CENTRED LATTICE
1150  CONTINUE
      DO 1200 I=4,6
      HL(I)=0.5
1200  CONTINUE
      IF(IL-4)1550,1550,1250
1250  CONTINUE
      HL(IL-1)=0.
      GOTO 1550
C--'R' CENTRED LATTICE
1300  CONTINUE
      DO 1350 I=5,6
      HL(I)=2./3.
      HL(I+3)=1./3.
1350  CONTINUE
      HL(4)=HL(8)
      HL(7)=HL(5)
      GOTO 1550
C--'F' CENTRED LATTICE
1400  CONTINUE
      K=4
      DO 1500 I=4,12,4
      DO 1450 J=1,3
      HL(K)=0.5
      K=K+1
1450  CONTINUE
      HL(I)=0.
1500  CONTINUE
1550  CONTINUE
      RETURN
      END
C
CODE FOR XFAL02
      SUBROUTINE XFAL02
C--ROUTINE TO LOAD LIST 2 FROM THE DISC
C
C--
      use lists2_mod, only: xldlst

      INCLUDE 'ISTORE.INC'
      INCLUDE 'ICOM02.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLST02.INC'
        COMMON /PERM02/ RLIST2(1000),ICFLAG,LSYM,NSYM,MDSYM,LNONP,NNONP
      INCLUDE 'XGUIOV.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QLST02.INC'
C
      INCLUDE 'IDIM02.INC'
C--LOAD THE LIST
      CALL XLDLST(2,ICOM02,IDIM02,-1)
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--FIND THE CONSTANTS FROM THE CONSTANTS RECORD
      IC=NINT(STORE(L2C))
      IL=NINT(STORE(L2C+1))
      G2=STORE(L2C+2)
      T2=STORE(L2C+3)
C--Put necessary info in PERM02 block.
C--Centre flag
      ICFLAG = IC
C--Symmetry matrices
        LSYM = 1
        NSYM = N2
        MDSYM = MD2
      DO 10 I = 1, N2*MD2
         RLIST2(I) = STORE(I+L2-1)
10    CONTINUE
C--Non primitice lattice translations
        LNONP = N2*MD2+1
        NNONP = N2P
      DO 20 I = 1, N2P*MD2P
         RLIST2(I + LNONP - 1) = STORE(I + L2P - 1)
20    CONTINUE
      LGUIL2 = .TRUE.
C -- NORMAL AND ERROR EXIT
9900  CONTINUE
      RETURN
      END
C
CODE FOR XFAL03
      SUBROUTINE XFAL03
C--ROUTINE TO LOAD LIST 3 FROM THE DISC
C
C--
      use lists2_mod, only: xldlst

      INCLUDE 'ICOM03.INC'
C
      INCLUDE 'XLST03.INC'
C
      INCLUDE 'QLST03.INC'
C
      INCLUDE 'IDIM03.INC'
C--LOAD THE LIST
      CALL XLDLST(3,ICOM03,IDIM03,-1)
      RETURN
      END
C
CODE FOR XSCATT
      SUBROUTINE XSCATT(ST)
C--CALCULATE AND STORE THE SCATTERING FACTORS FOR THE ATOMS IN LIST 3
C
C  ST  THE VALUE OF SIN(THETA)/LAMBDA FOR THE CALCULATION
C
C--LIST 3 IS ASSUMED TO HAVE BEEN LOADED, AND THE RESULTS APPEAR AT
C  'L3TR' AND 'L3TI' FOR THE REAL AND IMAGINARY COMPONENTS
C  RESPECTIVELY.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST03.INC'
      INCLUDE 'XUNITS.INC'
C
      INCLUDE 'QSTORE.INC'
C
C--CHECK IF THERE ARE ANY FORM FACTORS STORED
      IF(N3)1100,1100,1000
C--CALCULATE SIN(THETA)/LAMBDA SQUARED
1000  CONTINUE
      SST=ST*ST
C--ASSIGN VARIOUS POINTERS
      M3=L3
      M3TR=L3TR
      M3TI=L3TI
C--LOOP OVER ACH FORM FACTOR TYPE IN TURN
      DO 1050 JZ=1,N3
      JU=M3+3
C--COMPUTE THE INVARIANT PART
      RPART = STORE(JU)*EXP(-STORE(JU+1)*SST)+STORE(JU+2)
     2 *EXP(-STORE(JU+3)*SST)+STORE(JU+4)*EXP(-STORE(JU+5)*SST)
     3 +STORE(JU+6)*EXP(-STORE(JU+7)*SST)+STORE(JU+8)
C--COMPUTE THE REAL PART
      STORE(M3TR) = RPART+STORE(M3+1)
C--COMPUTE THE IMAGINARY PART
      STORE(M3TI)=STORE(M3+2)
C----- CHECK FOR AN AUXILLIARY RADIATION
Cdjwsep2010 Store FF with appropriate anomalous scattering
      IF((MD3 .EQ. 14) .AND. (MD3TR .EQ. 2)) THEN
            STORE(M3TR+1) = RPART+STORE(M3+12)
            STORE(M3TI+1) = STORE(M3+13)
      ENDIF
csjwsep2010
C--UPDATE FOR THE NEXT FORM FACTOR
      M3=M3+MD3
      M3TR=M3TR+MD3TR
      M3TI=M3TI+MD3TI
1050  CONTINUE
C--AND NOW RETURN
1100  CONTINUE
      RETURN
      END
C
CODE FOR XFAL05
      SUBROUTINE XFAL05
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST05.INC'

C--ROUTINE TO LOAD LIST 5 FROM THE DISC
      IF (KEXIST(5).GT.0) THEN   ! Only do this if a L5 exists
         CALL XLDR05(5)

C - Sanity check atom parameters & scales for NaN     
         IF (N5.GT.0) THEN   ! Only do this if L5 has some atoms
            DO MF05 = L5,L5+(N5-1)*MD5,MD5
               DO MG05 = 1, 13 ! Serial -> Spare
                  IF (ISNAN(STORE(MF05+MG05))) STORE(MF05+MG05) = 0.0
               END DO
            END DO
            DO MH05 = L5O,L5O+5
               IF (ISNAN(STORE(MH05))) STORE(MH05) = 1.0
            END DO
         END IF
      END IF
      RETURN
      END
C
CODE FOR XFAL09
      SUBROUTINE XFAL09
C--ROUTINE TO LOAD LIST 9 FROM THE DISC
c  list 9 looks like a list 5 so we can use the
c  existing subroutines and then move the pointers.
c  take care if LIST 5 is already loaded
C
      INCLUDE 'ICOM05.INC'
      INCLUDE 'ICOM09.INC'
      INCLUDE 'XLST05.INC'
      dimension dwork(idim05)
      INCLUDE 'XLST09.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'QLST05.INC'
      INCLUDE 'QLST09.INC'
C NOW A PARAMETER      INCLUDE 'IDIM05.INC'
C
c check if there is a LIST 5 already loaded - if so we must save the
c pointers
      isave = 0
      IF (KHUNTR (5,0,IADDL,IADDR,IADDD,-1) .GE. 0) then
       call xmovei(icom05(1), dwork(1), idim05)
       isave = 1
      endif
      CALL XLDR05(9)
      call xmovei(icom05(1), icom09(1), idim05)
      if(isave .eq. 1)  call xmovei( dwork(1),icom05(1), idim05)
      RETURN
      END
C
C
CODE FOR XLDR05
      SUBROUTINE XLDR05(IULN)
C--LOAD A LIST OF TYPE INTO CORE FROM DISC.
C
C  IULN    THE LIST TYPE TO LOAD. THIS LIST WILL USE THE LIST 5
C          COMMON BLOCK WHATEVER THE LIST TYPE LOADED.
C
C     THE CALLING ROUTINE MUST SAVE THE REAL LIST 5 ADDRESSES
C     IF THEY ARE ALREADY IN USE.
C
C--
      use lists2_mod, only: xldlst

      INCLUDE 'ISTORE.INC'
      INCLUDE 'ICOM05.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XUSLST.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QLST05.INC'
C
C NOW A PARAMETER      INCLUDE 'IDIM05.INC'
C--SET THE LIST TYPE
      LN5=IULN
C--LOAD THE LIST
      CALL XLDLST(LN5,ICOM05,IDIM05,-1)
      MD5A=MD5
      RETURN
      END
C
CODE FOR XLDRO5
      SUBROUTINE XLDRO5(IULN)
C--LOAD AN ORDERED LIST 5 FROM THE DISC. THIS ROUTINE LEAVES THE ATOM
C  DATA RECORD (101) AS THE LAST RECORD LOADED.
C
C  IULN    THE LIST TYPE TO LOAD. THIS LIST USES THE LIST 5 COMMON
C          BLOCK.
C
C--
      INCLUDE 'ISTORE.INC'
      INCLUDE 'ICOM05.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XUSLST.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QLST05.INC'
C
C NOW A PARAMETER      INCLUDE 'IDIM05.INC'
C--SET THE LIST TYPE
      LN5=IULN
C--LOAD THE LIST
      CALL XFAOLS(LN5,101,ICOM05,IDIM05)
      MD5A=MD5
      RETURN
      END
C
CODE FOR XCPYL5
      SUBROUTINE XCPYL5(LNIN,LNOUT,N10A,NEW)
C--COPY A LIST USING 'XLST05' IN CORE TO ANOTHER LIST USING
C  'XLST05' IN CORE.
C
C  LNIN    THE CURRENT LIST TYPE
C  LNOUT   THE NEW LIST TYPE.
C  N10A    THE NUMBER OF ATOMS TO BE TAKEN FROM THE OLD LIST 5.
C  NEW     THE NEW LIST FLAG. THIS ROUTINE SETS THIS FLAG TO
C          1 IF 'LNIN' AND 'LNOUT' DIFFER. THIS INDICATES A COMPLETELY
C          NEW LIST.
C
C--'N5' IS ASSUMED TO REFLECT THE LENGTH OF THE NEW LIST 5.
C
C--
      INCLUDE 'ICOM05.INC'
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUSLST.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCONST.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QLST05.INC'
C
C NOW A PARAMETER      INCLUDE 'IDIM05.INC'
C--CHECK IF A CHANGE OF LIT TYPE IS INDICATED
      IF(LNIN-LNOUT)1000,1550,1000
C--PRESERVE THE LIST 5 COMMON BLOCK
1000  CONTINUE
      NEW=1
      LN=LNIN
      IREC=1001
      LFL1=LFL
      KA=KCHLFL(IDIM05)
      CALL XMOVEI (ICOM05(1),ISTORE(KA),IDIM05)
C--FORM THE NEW LIST IN CORE
      CALL XCELST(LNOUT,ICOM05,IDIM05)
C--LOOP OVER EACH DATA RECORD, MOVING THE REQUIRED DATA OVER
      KC=IDIM05-3
      DO 1500 I=1,KC,4
C--CHECK IF THIS IS THE SECOND ATOM POINTERS
      IF(I-5)1050,1450,1050
C--NOT THE DUMMY POINTERS  -  CHECK FOR SOME DATA TO MOVE
1050  CONTINUE
      N=ICOM05(I+3)
      IF(N)1450,1450,1100
C--FIND THE ADDRESS OF THE DATA RECORDS
1100  CONTINUE
      JX=ICOM05(I)
      JY=ISTORE(KA)
C--FIND THE NUMBER OF DATA RECORDS PRESENT ALREADY
      M=ISTORE(KA+3)
C--CHECK IF THIS IS THE ATOM RECORD
      IF(I-1)1200,1150,1200
C--CHECK IF WE REQUIRE ANY OF THE ATOMS FORMERLY IN LIST 5
1150  CONTINUE
      M=N10A
C--FIND THE MAXIMUM AMOUNT TO MOVE FOR EACH GROUP
1200  CONTINUE
      L=MIN0(ICOM05(I+2),ISTORE(KA+2))
C--MOVE DATA FOR EACH GROUP IN TURN
      DO 1400 J=1,N
      IF(M)1350,1350,1250
C--GROUPS LEFT TO MOVE  -  CHECK THE NUMBER OF ELEMENTS TO MOVE
1250  CONTINUE
      IF(L)1350,1350,1300
C--MOVE THE ELEMENTS FOR THE CURRENT GROUP
1300  CONTINUE
      CALL XMOVE(STORE(JY),STORE(JX),L)
C--UPDATE FOR THE NEXT GROUP
1350  CONTINUE
      M=M-1
      JX=JX+ICOM05(I+2)
      JY=JY+ISTORE(KA+2)
1400  CONTINUE
C--UPDATE FOR THE NEXT RECORD
1450  CONTINUE
      KA=KA+4
1500  CONTINUE
C--RESET THE CORE LIMIT
      LFL=LFL1
C--SET 'MD5A'
      MD5A=MD5
C--AND NOW RETURN
1550  CONTINUE
      LN5=LNOUT
      RETURN
      END
C
CODE FOR XSTR05
      SUBROUTINE XSTR05(IULN,IOWF,INEW)
C--SUBROUTINE TO STORE A LIST TYPE 5 ON DISC.
C
C  IULN    THE LIST TYPE TO STORE ON DISC.
C  IOWFLG  THE WRITE/OVERWRITE STATUS FOR THIS LIST :
C
C          -1  ATTEMPT AN OVERWRITE.
C           0  WRITE A COMPLETELY NEW LIST.
C          +1  ATTEMPT A CAREFUL OVERWRITE.
C
C  INEW    THE NEW LIST FLAG :
C
C          -1  THIS IS NOT A NEW VERSION OF THIS LIST.
C           0  THIS IS A NEW LIST, WITH LINKS TO OTHER EXISTING LISTS.
C          +1  THIS IS A NEW LIST, WITH NO LINKS TO OTHER EXISTING
C              LISTS. THIS IS NORMALLY THE CASE WHEN THE LIST HAS JUST B
C              INPUT.
C
C--
      INCLUDE 'ISTORE.INC'
      INCLUDE 'ICOM05.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST05.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QLST05.INC'
C
C NOW A PARAMETER      INCLUDE 'IDIM05.INC'
C--STORE THE LIST ON DISC
      CALL XWLSTD(IULN,ICOM05,IDIM05,IOWF,INEW)
      RETURN
      END
C
CODE FOR KTYP05
      FUNCTION KTYP05(IULN)
C--SET THE TYPE OF LIST 5 TO BE USED.
C
C  IULN    THE NUMBER OF THE LIST 5, IN THE RANGE 1 TO N. THE FOLLOWING
C          TYPES ARE KNOWN AT PRESENT :
C
C          1  TYPE IS 5.
C          2  TYPE IS 10, peaks
C          3  TYPE IS 9, esd
C
C--NO OTHER TYPES ARE SUPPORTED AND AN ERROR IS REPORTED FOR ANY OTHERS.
C
C--RETURN VALUES OF 'KTYP05' ARE :
C
C  >0  THE LIST TYPE TO BE USED.
C
C--
C
      DIMENSION ITYPE(3)
C
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
C
      DATA ITYPE(1)/5/,ITYPE(2)/10/,ITYPE(3)/9/
C
C--CHECK THE INPUT VALUE
      IF(IULN)1000,1000,1100
C--TYPE IS ILLEGAL
1000  CONTINUE
      CALL XERHDR(-1)
      IF (ISSPRT .EQ. 0)  WRITE(NCWU,1050)IULN
      WRITE ( CMON, 1050) IULN
      CALL XPRVDU(NCVDU, 1,0)
1050  FORMAT(' Illegal list 5 type selector ',I5)
      CALL XERHND ( IERPRG )
CDJWJAN2001
      KTYP05 = 0
      RETURN
C--CHECK THE MAXIMUM
1100  CONTINUE
      IF(IULN-4)1150,1000,1000
C--FIND THE TYPE
1150  CONTINUE
      KTYP05=ITYPE(IULN)
      RETURN
      END
C
CODE FOR KSET53
      FUNCTION KSET53(IN)
C--SET UP THE FORM FACTOR TYPES IN LIST 5
C
C  IN  DUMMY ARGUMENT
C
C--ON RETURN 'KSET53' IS SET TO THE MAXIMUM FORM FACTOR
C  TYPE REFERENCED MINUS ONE.
C
C--LISTS 5 AND 3 ARE ASSUMED TO HAVE BEEN LOADED.
C
C--
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST03.INC'
      INCLUDE 'XLST05.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
C
      IDWZAP = IN
      M=-1
C--CHECK IF THERE ARE ANY FORM FACTORS IN LIST 3
      IF(N3)1300,1300,1000
C--CHECK IF THERE ARE ANY ATOMS IN LIST 5
1000  CONTINUE
      IF(N5)1300,1300,1050
C--LOOP OVER ALL THE ATOMS
1050  CONTINUE
      M5=L5
      DO 1250 L=1,N5
C--SCAN LIST 3
      J=KCOMP(1,ISTORE(M5),ISTORE(L3),N3,MD3)-1
C--CHECK THE REPLY
      IF(J)1100,1200,1200
C--THIS ATOM TYPE IS NOT IN LIST 3
1100  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1150)STORE(M5)
      WRITE ( CMON, 1150) STORE(M5)
      CALL XPRVDU(NCVDU, 1,0)
1150  FORMAT(' Form factor not in list 3 : ',A4)
      CALL XERHND ( IERERR )
C--STORE THE FORM FACTOR NUMBER
1200  CONTINUE
      ISTORE(M5)=J
C--UPDATE THE MAXIMUM FOUND
      M=MAX0(M,J)
C--UPDATE FOR THE NEXT ATOM
      M5=M5+MD5
1250  CONTINUE
C--SET THE RETURN VALUE AND EXIT
1300  CONTINUE
      KSET53=M
      RETURN
      END
C
CODE FOR XFAL13
      SUBROUTINE XFAL13
C--ROUTINE TO LOAD LIST 13 FROM THE DISC
C
C--
      use lists2_mod, only: xldlst

      INCLUDE 'ICOM13.INC'
C
      INCLUDE 'XLST13.INC'
C
      INCLUDE 'QLST13.INC'
C
      INCLUDE 'IDIM13.INC'
C--LOAD THE LIST
      CALL XLDLST(13,ICOM13,IDIM13,-1)
      RETURN
      END
C
C
CODE FOR XFAL20
      SUBROUTINE XFAL20
C--ROUTINE TO LOAD LIST 20 FROM THE DISC
C
C      1 = ORTHOGONALISATION MATRIX
C      2 = CRYSTAL FRACTIONS TO INERTIAL
C      3 = CRYSTAL FRACTIONS TO TLS
C      4 = USER DEFINED
      use lists2_mod, only: xldlst

      INCLUDE 'ICOM20.INC'
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST01.INC'
      INCLUDE 'XLST20.INC'
C
      INCLUDE 'QLST20.INC'
      INCLUDE 'QSTORE.INC'
C
      INCLUDE 'IDIM20.INC'
C--LOAD THE LIST
      CALL XLDLST(20,ICOM20,IDIM20,-1)
C----- CHECK FOR LIST 1, WHICH MUST BE LOADED FIRST
      IF (KHUNTR(1, 0, IADDL, IADDR, IADDD, 0) .EQ. 0) THEN
      CALL XTRANS(STORE(L1O1),STORE(L20M),3,3)
      CALL XTRANS(STORE(L1O2),STORE(L20I),3,3)
      ENDIF
      RETURN
      END
C
CODE FOR XSTR20
      SUBROUTINE XSTR20(IULN,IOWF,INEW)
C--SUBROUTINE TO STORE A LIST TYPE 20 ON DISC.
C
C  IULN    THE LIST TYPE TO STORE ON DISC.
C  IOWFLG  THE WRITE/OVERWRITE STATUS FOR THIS LIST :
C
C          -1  ATTEMPT AN OVERWRITE.
C           0  WRITE A COMPLETELY NEW LIST.
C          +1  ATTEMPT A CAREFUL OVERWRITE.
C
C  INEW    THE NEW LIST FLAG :
C
C          -1  THIS IS NOT A NEW VERSION OF THIS LIST.
C           0  THIS IS A NEW LIST, WITH LINKS TO OTHER EXISTING LISTS.
C          +1  THIS IS A NEW LIST, WITH NO LINKS TO OTHER EXISTING
C              LISTS. THIS IS NORMALLY THE CASE WHEN THE LIST HAS JUST B
C              INPUT.
C
C--
      INCLUDE 'ISTORE.INC'
      INCLUDE 'ICOM20.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST20.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QLST20.INC'
C
      INCLUDE 'IDIM20.INC'
C--STORE THE LIST ON DISC
      CALL XWLSTD(IULN,ICOM20,IDIM20,IOWF,INEW)
      RETURN
      END
C
CODE FOR XFAL14
      SUBROUTINE XFAL14
C--ROUTINE TO LOAD LIST 14 FROM THE DISC
C
C--
      use lists2_mod, only: xldlst

      INCLUDE 'ICOM14.INC'
C
      INCLUDE 'XLST14.INC'
C
      INCLUDE 'QLST14.INC'
C
      INCLUDE 'IDIM14.INC'
C--LOAD THE LIST
      CALL XLDLST(14,ICOM14,IDIM14,-1)
      RETURN
      END
C
CODE FOR XFAL24
      SUBROUTINE XFAL24
C--ROUTINE TO LOAD LIST 24 FROM THE DISC
C
C--
      use lists2_mod, only: xldlst

      INCLUDE 'ICOM24.INC'
C
      INCLUDE 'XLST24.INC'
C
      INCLUDE 'QLST24.INC'
C
      INCLUDE 'IDIM24.INC'
C--LOAD THE LIST
      CALL XLDLST(24,ICOM24,IDIM24,-1)
      RETURN
      END
C
CODE FOR XFAL25
      SUBROUTINE XFAL25
C--ROUTINE TO LOAD LIST 25 FROM THE DISC
C
C--
      use lists2_mod, only: xldlst

      INCLUDE 'ICOM25.INC'
C
      INCLUDE 'XLST25.INC'
C
      INCLUDE 'QLST25.INC'
C
      INCLUDE 'IDIM25.INC'
C--LOAD THE LIST
      CALL XLDLST(25,ICOM25,IDIM25,-1)
      RETURN
      END
C
CODE FOR XFAL29
      SUBROUTINE XFAL29
C--ROUTINE TO LOAD LIST 29 FROM THE DISC
C
C--
      use lists2_mod, only: xldlst

      INCLUDE 'ICOM29.INC'
C
      INCLUDE 'XLST29.INC'
C
      INCLUDE 'QLST29.INC'
C- dimension now set as a parameter in ICOM29.INC
c      INCLUDE 'IDIM29.INC'
C--LOAD THE LIST
      CALL XLDLST(29,ICOM29,IDIM29,-1)
      RETURN
      END
C
C
CODE FOR XFAL30
      SUBROUTINE XFAL30
C--ROUTINE TO LOAD LIST 30 FROM THE DISC
C
C--
      use lists2_mod, only: xldlst

      INCLUDE 'ICOM30.INC'
C
      INCLUDE 'XLST30.INC'
C
      INCLUDE 'QLST30.INC'
C
C---- IF NO LIST 30, CREATE ONE
      IF (KEXIST(30) .LE. 0) THEN
            CALL XCELST (30, ICOM30, IDIM30)
      ELSE
C-----LOAD THE LIST
            CALL XLDLST(30, ICOM30, IDIM30, -1)
      ENDIF
      RETURN
      END
C
CODE FOR XRD33
      SUBROUTINE XRD33
C--INPUT ROUTINES FOR THE SFLS CONTROL DATA
C
C--USE OF VARIABLES :
C
C  KA  LIST TYPE
C
C--COMMANDS ARE STORED AND OUTPUT, AS NECCESSARY, IN THE ORDER :
C
C   -1    #SPECIAL
C      0  #CALCULATE, #SCALE, #REFINE
C      1  #DORESTRAIN
C      2  #INVERT
C      3  #SOLVE
C      4  #PUNCH
C      5  #CYCLENDS
C
C--
      INCLUDE 'ISTORE.INC'
      INCLUDE 'ICOM33.INC'
C
      DIMENSION IRQ(3,8),IRCALC(3,3),IEND(2),INO(1), JRQ(3,2)
      DIMENSION INVERT(7), JTYP33(2)
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XCARDS.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XLST50.INC'
      INCLUDE 'XLST23.INC'
      INCLUDE 'XLST33.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'XIOBUF.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QLST33.INC'
C
C--SYSTEM REQUEST QUEUE ARGUMENTS
C
      DATA IVERSN /103/
C
C
C
      DATA NRQ/8/, NWRQ/3/
C
#ifdef _HOL_
      DATA JTYP33(1)/4H   1/, JTYP33(2)/4H   2/

      DATA JRQ(1,1)/4HSPEC/, JRQ(2,1)/4H  NO/, JRQ(3,1)/4H  NO/
      DATA JRQ(1,2)/4HSPEC/, JRQ(2,2)/4H LIS/, JRQ(3,2)/4H  NO/

      DATA IRQ(1,1)/4H    /,IRQ(2,1)/4H    /,IRQ(3,1)/4H    /
      DATA IRQ(1,2)/4H    /,IRQ(2,2)/4H    /,IRQ(3,2)/4H    /
      DATA IRQ(1,3)/4H    /,IRQ(2,3)/4H    /,IRQ(3,3)/4H    /
      DATA IRQ(1,4)/4HDORE/,IRQ(2,4)/4HSTRA/,IRQ(3,4)/4HIN  /
      DATA IRQ(1,5)/4HINVE/,IRQ(2,5)/4HRT  /,IRQ(3,5)/4H    /
      DATA IRQ(1,6)/4HSOLV/,IRQ(2,6)/4HE   /,IRQ(3,6)/4H    /
      DATA IRQ(1,7)/4HPUNC/,IRQ(2,7)/4HH  5/,IRQ(3,7)/4H    /
      DATA IRQ(1,8)/4HCYCL/,IRQ(2,8)/4HENDS/,IRQ(3,8)/4H    /
C
      DATA IRCALC(1,1)/4HREFI/,IRCALC(2,1)/4HNE  /,IRCALC(3,1)/4H    /
      DATA IRCALC(1,2)/4HSCAL/,IRCALC(2,2)/4HE   /,IRCALC(3,2)/4H    /
      DATA IRCALC(1,3)/4HCALC/,IRCALC(2,3)/4HULAT/,IRCALC(3,3)/4HE   /
C
      DATA INO(1)/4HNO  /

      DATA IEND(1)/4HE   /,IEND(2)/4HND  /
      ! Array invert must match commands.src
      DATA INVERT(1) /4HDEFA/
      DATA INVERT(2) /4HAUTO/, INVERT(3) /4HLDLT/
      DATA INVERT(4) /4HEIGE/, INVERT(5) /4HDP_L/
      DATA INVERT(6) /4HXCHO/, INVERT(7) /4HCHOL/
#else
      DATA JTYP33(1)/'   1'/, JTYP33(2)/'   2'/

      DATA JRQ(1,1)/'SPEC'/, JRQ(2,1)/'  NO'/, JRQ(3,1)/'  NO'/
      DATA JRQ(1,2)/'SPEC'/, JRQ(2,2)/' LIS'/, JRQ(3,2)/'  NO'/

      DATA IRQ(1,1)/'    '/,IRQ(2,1)/'    '/,IRQ(3,1)/'    '/
      DATA IRQ(1,2)/'    '/,IRQ(2,2)/'    '/,IRQ(3,2)/'    '/
      DATA IRQ(1,3)/'    '/,IRQ(2,3)/'    '/,IRQ(3,3)/'    '/
      DATA IRQ(1,4)/'DORE'/,IRQ(2,4)/'STRA'/,IRQ(3,4)/'IN  '/
      DATA IRQ(1,5)/'INVE'/,IRQ(2,5)/'RT  '/,IRQ(3,5)/'    '/
      DATA IRQ(1,6)/'SOLV'/,IRQ(2,6)/'E   '/,IRQ(3,6)/'    '/
      DATA IRQ(1,7)/'PUNC'/,IRQ(2,7)/'H  5'/,IRQ(3,7)/'    '/
      DATA IRQ(1,8)/'CYCL'/,IRQ(2,8)/'ENDS'/,IRQ(3,8)/'    '/
C
      DATA IRCALC(1,1)/'REFI'/,IRCALC(2,1)/'NE  '/,IRCALC(3,1)/'    '/
      DATA IRCALC(1,2)/'SCAL'/,IRCALC(2,2)/'E   '/,IRCALC(3,2)/'    '/
      DATA IRCALC(1,3)/'CALC'/,IRCALC(2,3)/'ULAT'/,IRCALC(3,3)/'E   '/
C
      DATA INO(1)/'NO  '/

      DATA IEND(1)/'E   '/,IEND(2)/'ND  '/
      ! Array invert must match commands.src
      DATA INVERT(1) /'DEFA'/
      DATA INVERT(2) /'AUTO'/, INVERT(3) /'LDLT'/
      DATA INVERT(4) /'EIGE'/, INVERT(5) /'DP_L'/
      DATA INVERT(6) /'XCHO'/, INVERT(7) /'CHOL'/
#endif
C
C
C--'END' DIRECTIVE
      DATA NWEND/2/
C
C--POINTERS TO THE INPUT DIRECTIVES
      DATA NREFNE/1/,NVECTR/5/,NSHIFT/6/,NFORCE/8/,NSHFTP/9/
C
      INCLUDE 'IDIM33.INC'
      IDWZAP = 0
      CALL XFILL (IDWZAP, ICOM33, IDIM33)
C--SET THE LIST TYPE TO BE USED
      KA=33
C--SET THE FLAGS FOR THE SHIFT TYPE RECORD DEFINITION DIRECTIVE
      CALL XDIRFL(NSHFTP,ICOM33,IDIM33)
C--CREATE THE DATA RECORD FOR THIS DIRECTIVE
      I=KCDRFI(ICOM33,IDIM33,0)
C--INDICATE THAT THIS DIRECTIVE HAS BEEN READ ONCE
      ISTORE(MR61+8)=ISTORE(MR61+7)
C--SET THE TYPE OF EACH SHIFT
CDJW0102  SET SOME SHIFT TYPES TO MAXIMAL, WITH VALUES
C.GENERAL .OVERALL .TYPE    .SERIAL  .OCC     .U[ISO]  
C.X       .Y       .Z       .U[11]   .U[22]   .U[33]   
C.U[23]   .U[13]   .U[12]   .SPISO   .SPSIZE  .LINISO  
C.LINSIZE .LINDEC  .LINAZI  .RINGISO .RINGSIZ .RINGDEC 
C.RINGAZI 
C----- EVERYTHING FRACTIONAL
      N=MD33ST*N33ST
      M=-1
      CALL XMVSPD(M, ISTORE(L33ST),N)
C----- NOW A FEW MAXIMAL
cdjwdec06      M=0
cdjwdec06      CALL XMVSPD(M, ISTORE(L33ST+4),11)
C--SET THE FLAGS FOR THE SHIFT VALUES RECORD
      CALL XDIRFL(NSHIFT,ICOM33,IDIM33)
C--CREATE A DATA RECORD FOR THIS DIRECTIVE
      I=KCDRFI(ICOM33,IDIM33,0)
C--LOOP OVER ALL THE DIRECTIVES THAT USE THIS ONE, SETTING THEIR CONSTAN
      DO 1000 I=NSHIFT,NFORCE
      J=LR61+(I-1)*MDR61
      ISTORE(J+7)=ISTORE(MR61+7)
      ISTORE(J+8)=1
      ISTORE(J+9)=ISTORE(MR61+9)
      ISTORE(J+10)=ISTORE(MR61+10)
1000  CONTINUE
C--ASSIGN THE DEFAULT SHIFT VALUES
      N=MD33SV*N33SV
C----- UNITY FOR FRACTIONAL
      A=1.
      CALL XMVSPF(A,STORE(L33SV),N)
C----- CONVENTIONAL UNITS FOR MAXIMAL
cdjwdec06      STORE(L33SV+4)=1.
cdjwdec06      STORE(L33SV+5)=0.05
cdjwdec06      CALL XMVSPF(1.,STORE(L33SV+6),3)
cdjwdec06      CALL XMVSPF(.05,STORE(L33SV+9),6)
C
C--SET THE FLAGS FOR THE CYCLE CONTROL RECORD
      CALL XDIRFL(NREFNE,ICOM33,IDIM33)
C--CREATE A DATA RECORD FOR THIS DIRECTIVE
      I=KCDRFI(ICOM33,IDIM33,0)
C--LOOP OVER ALL THE DIRECTIVES THAT USE THIS ONE, SETTING THEIR CONSTAN
      DO 1050 I=NREFNE,NVECTR
         J=LR61+(I-1)*MDR61
         ISTORE(J+7)=ISTORE(MR61+7)
         ISTORE(J+8)=1
         ISTORE(J+9)=ISTORE(MR61+9)
         ISTORE(J+10)=ISTORE(MR61+10)
1050  CONTINUE


C--INDICATE THAT THERE IS NO CURRENT DIRECTIVE AGAIN
      IDIRFL=-1
C--INDICATE THAT NO CYCLES HAVE BEEN FOUND YET
      NCYCLE=0
C--INDICATE NO CURRENT DIRECTIVE
      IDIR=-1
C
C
CDJWMAY03
C      MAXIMUM NUMBER OF CYCLES IS SET BY STORAGE RESERVED IN COMMANDS
C      NGROUP IN REFINE, SHIFT AND TYPEOFSHIFT (ETC) IS MAXIMUM+1
C      LENGRP IN INSTR-BLOCK IS 12*MAXIMUM
C      MAXIMUM IS CURRENTLY 10
C
      MCYCLE = N33CD-1
C
C
C--READ THE NEXT DIRECTIVE CARD
1100  CONTINUE
      LAST=IDIR
      IDIR=KRDNDC(ICOM33,IDIM33)
      IF(IDIR)2150,2100,1150    ! -ve=END / 0=CONT / +ve=directive
1150  CONTINUE
C--THIS IS A NEW DIRECTIVE  -  SEE IF IT IS 'REFINE', 'SCALE', ETC.
      IF(IDIR-NREFNE)1600,1250,1200
C--CHECK THE MAXMIMUM POSSIBLE VALUE
1200  CONTINUE
      IF(IDIR-NVECTR)1250,1250,1700
C--A CYCLE TYPE OF DIRECTIVE  -  UPDATE THE NUMBER OF CYCLES
1250  CONTINUE
      NCYCLE=NCYCLE+1
      IF (NCYCLE .GT. MCYCLE) GOTO 9940
C--MAKE ALL THE CYCLE DIRECTIVES HAVE THE SAME COUNT
      DO 1300 I=NREFNE,NVECTR
         J=LR61+(I-1)*MDR61
         ISTORE(J+8)=NCYCLE
1300  CONTINUE
C--SET THE POINTERS CORRECTLY FOR THIS DIRECTIVE
      CALL XDIRFL(IDIR,ICOM33,IDIM33)
C--SHIFT INSTRUCTIONS MAY BE ALLOWED  -  ALTER THEIR POINTERS
      K=IDIR-NREFNE+1
      DO 1500 I=NSHIFT,NFORCE
        J=LR61+(I-1)*MDR61
C--BRANCH ON THE TYPE OF CALCULATION
        GOTO(1400,1450,1450,1400,1400,1350),K
C1350   STOP137
1350    CALL GUEXIT(137)
C--ELIMINATE THE EXCLUDED DIRECTIVE COUNT FOR THE SHIFT
1400    CONTINUE
        ISTORE(J+6)=0
C--ALTER THE REPEAT COUNTERS
1450    CONTINUE
        ISTORE(J+7)=NCYCLE+1
        ISTORE(J+8)=NCYCLE
1500  CONTINUE
C--STORE THE TYPE OF ARGUMENT FOUND
      J=IPARAD+MD33CD
      ISTORE(J-1)=K
C--INCREMENT THE NUMBER OF OPERATIONS ALLOWED
      N33IB=2*(NRQ+1)*NCYCLE
C--FIND THE NEXT PARAMETER KEYWORD
1600  CONTINUE
      IDWZAP = 0
      IF(KFNDNP(IDWZAP))1100,1100,1650
C--READ THE VALUE ASSOCIATED WITH THIS PARAMETER KEYWORD
1650  CONTINUE
      IF(KRDPV(ICOM33,IDIM33))1100,1600,1600
C
1700  CONTINUE
C----- LOOK FOR REFLECTION LIST TYPE
CDJWJAN03
      IF (IDIR .EQ. 13) THEN
C--FIND THE NEXT PARAMETER KEYWORD.  PROBABLY NOT THE OPTIMAL
C      SUBROUTINES, SINCE IT RETURNS THE VALUE '0' IF NO LIST
C      NUMBER GIVEN.
1660   CONTINUE
       IDWZAP = 0
       IF(KFNDNP(IDWZAP))1680,1680,1670
C--    READ THE VALUE ASSOCIATED WITH THIS PARAMETER KEYWORD
1670   CONTINUE
       IF(KRDPV(ICOM33,IDIM33))1680,1660,1660
1680   CONTINUE
C----- BODGE BECAUSE OF ZERO RETURN
       ITYP33 = MAX(1,ITYP33)
       GOTO 1100
      ENDIF
CDJWJAN03
C--SOME TYPE OF SHIFT INFORMATION  -  CHECK FOR THE FIRST TIME
      IF(NCYCLE)1750,1750,1850
C--NO CALCULATION OF ANY TYPE SO FAR  -  SHIFTS ARE NOT ALLOWED
1750  CONTINUE
      CALL XMONTR(0)
      IF (ISSPRT .EQ. 0) WRITE(NCWU,1800)
      WRITE ( CMON, 1800)
      CALL XPRVDU(NCVDU, 1,0)
1800  FORMAT(' Shift information may only follow',
     2 ' refinement directives')
      LEF=LEF+1
      IDIRFL=-1
      GOTO 1100
C--SET THE COUNT CORRECTLY FOR THIS DIRECTIVE
1850  CONTINUE
      ISTORE(MR61+8)=NCYCLE
      CALL XDIRFL(IDIR,ICOM33,IDIM33)
C--RESET THE ONE WE HAVE FOUND
      ISTORE(MR61+8)=ISTORE(MR61+7)
C--FIND THE NEXT PARAMETER KEYWORD
1900  CONTINUE
      IDWZAP = 0
      IPAR=KFNDNP(IDWZAP)
      IF(IPAR)1100,1100,1950
C--READ THE VALUE
1950  CONTINUE
      M33ST=IPARAM+L33ST+(NCYCLE-1)*MD33ST
      ISTORE(M33ST-1)=IDIR-NSHIFT-1
      IF(KRDPV(ICOM33,IDIM33))1100,2000,2000
C--CHECK IF THIS IS A 'GENERAL' KEYWORD FOR ALL PARAMETERS
2000  CONTINUE
      IF(IPAR-1)1900,2050,1900
C--CHANGE ALL THE ENTRIES TO REFLECT THIS VALUE
2050  CONTINUE
      CALL XFILL(ISTORE(M33ST-1),ISTORE(M33ST),MD33ST-1)
C--AND NOW THE SHIFT VALUE
      M33SV=L33SV+IPARAM+(NCYCLE-1)*MD33SV
      CALL XFILL(ISTORE(M33SV-1),ISTORE(M33SV),MD33SV-1)
      GOTO 1900
C
C--A 'CONTINUATION' CARD  -  CHECK FOR SHIFT FACTORS
2100  CONTINUE
      IDIR=LAST
      IF(IDIR-NSHIFT)1600,1900,1900







C--END OF THE DIRECTIVES  -  CHECK FOR ANY ERRORS
2150  CONTINUE
      IF ( LEF .NE. 0 ) GO TO 9910
C--CHECK FOR SOME CALCULATIONS
      IF ( NCYCLE .LE. 0 ) GO TO 9920
C--UPDATE THE POINTERS FOR THE CYCLE CONTROL RECORD
      N33CD=NCYCLE
C--SET THE COUNT TO ZERO AGAIN
      NCYCLE=0
C--LOAD LIST 23 FOR CONSTRAINTS DETAILS
      CALL XFAL23
      IF ( IERFLG .LT. 0 ) GO TO 9900
C--LOOP OVER EACH CYCLE FORMING THE SYSTEM REQUEST RECORD
      M33CD=L33CD
      M33IB=L33IB
      N33IB=0
C--ASSUME NO CALCULATION OF ANY TYPE SO FAR
      KF=-1



C--LOOP OVER EACH TYPE OF CALCULATION
      DO 3450 I=1,N33CD
         M=M33CD+MD33CD
C--SET THE INITIAL INSTRUCTION GENERATION POINTERS
         LRQ = 2
C----- DONT DO 'CYCLENDS'
         MRQ = NRQ - 1
         CALL XMOVEI (JRQ(1,1), IRQ(1,2), NWRQ)
C--FIND THE TYPE OF CALCULATION
         J=ISTORE(M-1)
C--BRANCH ON THE TYPE OF CALCULATION
C             REFI SCAL CALC SOLV VECT ERRR
         GOTO(2550,2700,2800,2850,2900,2500),J
2500     CALL GUEXIT(135)

C--'REFINE' HAS BEEN INPUT FOR THIS CYCLE
2550     CONTINUE
         CALL XMOVEI (JRQ(1,2), IRQ(1,2), NWRQ)     !"SPEC LIS NO"
C----- SET INVERSION TO CHOLESKI OR EIGENVECTOR
         if(2+ ISTORE(M33CD+8)<1 .or. 
     1     2+ ISTORE(M33CD+8)>size(invert)) then
           call abort()
         end if
         IRQ(3,5) = INVERT(2+ ISTORE(M33CD+8))      !"CHOL" or "EIGE"
         KG=1
C--INDICATE THAT ANY TYPE OF CALCULATION IS NOW ALLOWED
2600     CONTINUE
         KF=-1
C--SET THE LENGTH POINTER TO BE STORED
2650     CONTINUE
         ILEN=NWEND+1
         CALL XMOVEI (IRCALC(1,KG),IRQ(1,3),NWRQ)   !"REFI","NE  "
C      STORE IN QUEUE AS CHARACTERS
         CALL XMOVEI (JTYP33(ITYP33), IRQ(3,3), 1)
         GOTO 2950

C--'SCALE' DIRECTIVE  -  SET THE POINTERS
2700     CONTINUE
         KG=2
C--ADJUST THE OUTPUT POINTERS AND DISAAALLOW ANY OTHER SIMILAR CALCULATI
2750     CONTINUE
         MRQ = LRQ + 1
         K=KF
         KF=0
C--CHECK FOR TWO SUCCESSIVE SIMILAR CYCLES
         IF(K)2650,3400,3400

C--'CALCULATE' DIRECTIVE  -  SET THE PINTERS AND ENTER THE CHECK LOOP
2800     CONTINUE
         KG=3
         GOTO 2750

C--'SOLVE' DIRECTIVE  -  SUPPRESS '#CALCULATE' AND '#CONSTRAIN'
2850     CONTINUE
         KG=1
         LRQ=5
         GOTO 2550

C--'VECTOR' DIRECTIVE  -  ALTER THE '#SOLVE' DIRECTIVE
2900     CONTINUE
         KG=3
         IRQ(3,6)=INO(1)
         GOTO 2600

C--STORE THE NECESSARY INSTRUCTIONS
2950     CONTINUE
         DO 3300 K=LRQ,MRQ
C--BRANCH ON THE INSTRUCTION TO BE ISSUED
            GOTO(3250,3250,3250,3050,3200,3250,3150,3250,3000),K
3000        GOTO 9930
C----- CHECK IF VECTOR IS ALSO SET - IF SO SKIP RESTRAIN
3050        CONTINUE
            IF(J-5)3100,3300,3100
C----- NOT A VECTOR - ISSUE RESTRAIN, TO BE SKIPPED IN XAPP26 IF
C      LIST 23 DOES NOT NEED IT
3100        CONTINUE
            GOTO 3250
C--'#PUNCH' TO BE ISSUED  -  CHECK IF IT IS NECESSARY
3150        CONTINUE
CDJW0102 - ONLY IF TYPE IS 'REFINE'. ITEM+5 USED AS 'FILTER'
C          ON 'CALC'
            IF ((J .EQ. 1) .AND. (ISTORE(M33CD+5) .LT. 0)) GOTO 3300
            IF ((J .EQ. 1) .AND. (ISTORE(M33CD+5) .GT. 0)) GOTO 3300
            GOTO 3250      
C--'#INVERT' TO BE ISSUED  -  CHECK IF THIS IS A 'VECTOR' INSTRUCTION
3200        CONTINUE
            IF(ISTORE(M-1)-5)3250,3300,3250
C--INSERT THE CURRENT INSTRUCTION IN THE DATA RECORD
3250        CONTINUE
            CALL XMVSPD(IB,ISTORE(M33IB),2*MD33IB)
            ISTORE(M33IB)=MD33IB
C--INSERT THE '#'
            ISTORE(M33IB+1)=IH
C--INSERT THE COMMAND
            CALL XMOVEI (IRQ(1,K),ISTORE(M33IB+2), NWRQ)
C--UPDATE THE POINTERS
            M33IB=M33IB+MD33IB
C--OUTPUT THE 'END' DIRECTIVE
            ISTORE(M33IB)=ILEN
            CALL XMOVEI (IEND(1), ISTORE(M33IB+1),NWEND)
C--FINAL UPDATE OF THE POINTERS
            M33IB=M33IB+MD33IB
            N33IB=N33IB+2
3300     CONTINUE
C--CHECK IF WE HAVE ISSUED THE '#CYCLENDS' DIRECTIVE
         IF(MRQ-NRQ)3350,3400,3400
C--NOT ISSUED YET  -  SET THE POINTERS
3350     CONTINUE
         LRQ=NRQ
         MRQ=NRQ
         ILEN=-(NWEND+1)
         NCYCLE=NCYCLE+1
         GOTO 2950
C--UPDATE FOR THE NEXT CYLE
3400     CONTINUE
         M33CD=M33CD+MD33CD
3450  CONTINUE



C--UPDATE THE INSTRUCTION RECORD COUNT
      CALL XUDRH(KA,104,0,N33IB)
C--UPDATE THE POINTERS FOR THE CYCLE CONTROL RECORD
      N33CD=NCYCLE
      CALL XUDRH(KA,101,0,N33CD)
C--UPDATE THE POINTERS FOR THE SHIFT VALUES RECORD
      N33SV=NCYCLE
      CALL XUDRH(KA,102,0,N33SV)
C--UPDATE THE POINTERS FOR THE SHIFT TYPES RECORD
      N33ST=NCYCLE
      CALL XUDRH(KA,103,0,N33ST)
C--UPDATE THE POINTERS TO THE VALUES FOR EACH CYCLE
      N33V=NCYCLE
      CALL XUDRH(KA,106,0,N33V)
C--WRITE THE LIST TO THE DISC
      CALL XWLSTD(KA,ICOM33,IDIM33,-1,0)
C--FIRE OUT SOME LINES
      RETURN
C
9900  CONTINUE
C -- ERRORS
      CALL XOPMSG ( IOPSFS , IOPABN , IVERSN )
      RETURN
9910  CONTINUE
      CALL XOPMSG ( IOPSFS , IOPCMI , IVERSN )
      GO TO 9900
9920  CONTINUE
C -- NO CALCULATIONS INDICATED
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 9925 )
      WRITE ( CMON, 9925 )
      CALL XPRVDU(NCVDU, 1,0)
9925  FORMAT ( 1X , 'No SFLS calculations indicated' )
      CALL XERHND ( IERERR )
      GO TO 9900
9940  CONTINUE
C -- TOO MANY CALCULATIONS INDICATED
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 9945 ) MCYCLE
      WRITE ( CMON, 9945 ) MCYCLE
      CALL XPRVDU(NCVDU, 1,0)
9945  FORMAT ( 1X , 'Too many SFLS cycles indicated, ',
     1 'Maximum = ',I3 )
      CALL XERHND ( IERERR )
      GO TO 9900
9930  CONTINUE
      CALL XOPMSG ( IOPSFS, IOPABN, IVERSN)
      CALL XERHND (IERPRG)
      END
C
CODE FOR XCYCLE
      SUBROUTINE XCYCLE
C--SUBROUTINE TO RESUME A STRUCTURE FACTOR LEAST SQUARES CALCULATION
C  AT THE NEXT COMPLETE CYCLE.
C
C--
C
      CHARACTER CFORM*12, CFMRQ*6, CIMAGE*80
      INCLUDE 'ICOM33.INC'
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XLST33.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XCARDS.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QLST33.INC'
C
      DATA CFMRQ /'(20A4)'/
      DATA CFORM /'(A1,19A4,A3)'/
C
      INCLUDE 'IDIM33.INC'
C--LOAD THE LAST LIST 33
      CALL XCSAE
      CALL XRSL
      CALL XFAL33
C--CHECK IF WE HAVE PROCESSED ALL THE '#INSTRUCTIONS' IN LIST 33
      IF ( IERFLG .LT. 0 ) GO TO 1300
      IF(ISTORE(L33CB)-N33IB)1000,1300,1300
C--LOOP OVER THE REMAINING INSTRUCTIONS ISSUING AS MANY AS REQUIRED
1000  CONTINUE
      J=ISTORE(L33CB)+1
C--UPDATE THE NUMBER OF THIS CYCLE
      ISTORE(L33CB+1)=ISTORE(L33CB+1)+1
C--INDICATE THAT THERE ARE NO SYSTEM REQUEST COMMANDS IN CORE
      KX=0
C--CHECK IF THERE IS ANY INFORMATION IN THE SYSTEM REQUEST QUEUE
      IF(NREC)1020,1020,1010
C--COMMANDS STILL IN THE QUEUE  -  READ THEM DOWN
1010  CONTINUE
      KX=NREC
      KY=20
      KZ=KX*KY
      KS=KCHLFL(KZ)
      KT=KS+KZ-1
      READ (NUSRQ,CFMRQ) (ISTORE(KR),KR=KS,KT)
      NREC=0
      IEOF=NREC
      IPOSRQ=0
      REWIND NUSRQ
C--SET UP A BUFFER TO CONTAIN THE COMMAND
1020  CONTINUE
      KB=21
      KA=NFL
      I=KCHNFL(KB)
      DO 1050 I=J,N33IB
C--COMPUTE THE CURRENT ADDRESS
      M33IB=L33IB+ISTORE(L33CB)*MD33IB
C--FIND THE LENGTH POINTER
      K=ISTORE(M33IB)
C--FIND THE ABSOLUTE VALUE OF THIS POINTER
      L=IABS(K)
C--MOVE THE DATA TO THE OUTPUT AREA
      CALL XMVSPD(IB,STORE(KA),KB)
C--NOW THE DATA
      CALL XMOVE(STORE(M33IB+1),STORE(KA),L-1)
C--ISSUE THE COMMAND
      WRITE(CIMAGE,CFORM) (STORE(IZ), IZ= KA, KA+KB-1)
      CALL XISRC (CIMAGE)
C--UPDATE THE POINTER IN LIST 33
      ISTORE(L33CB)=ISTORE(L33CB)+1
C--CHECK FOR THE LAST OPERATION
      IF(K)1100,1050,1050
1050  CONTINUE
C--REWRITE LIST 33
1100  CONTINUE
      CALL XWLSTD(LN,ICOM33,IDIM33,-1,-1)
C--ISSUE A THE SYSTEM REQUESTS
      IF(IHFLAG)1110,1120,1120
C--NO '#INSTRUCTION' WAITING
1110  CONTINUE
      I=KPSRQ(0)
      GOTO 1150
C--'#INSTRUCTION' WAITING
1120  CONTINUE
      I=KPSRQ(1)
C--CHECK IF THERE IS DATA TO BE ADDED TO THE SYSTEM REQUEST QUEUE
1150  CONTINUE
      IF(KX)1300,1300,1200
C--RECORDS TO BE OUTPUT
1200  CONTINUE
      IZZ = KS
      DO 1250 KR=1,KX
      WRITE(CIMAGE,CFMRQ) (ISTORE(IZ), IZ = IZZ, IZZ-1+KY)
      CALL XISRC (CIMAGE)
      IZZ = IZZ + KY
1250  CONTINUE
C--AND NOW RETURN
1300  CONTINUE
      RETURN
      END
C
CODE FOR XFAL27
      SUBROUTINE XFAL27
C--ROUTINE TO LOAD LIST 27 FROM THE DISC
C
C--
      use lists2_mod, only: xldlst

      INCLUDE 'ISTORE.INC'
      INCLUDE 'ICOM27.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST27.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QLST27.INC'
C
      INCLUDE 'IDIM27.INC'
C--LOAD THE LIST
      CALL XLDLST(27,ICOM27,IDIM27,-1)
      RETURN
      END
C
CODE FOR XFAL33
      SUBROUTINE XFAL33
C--ROUTINE TO LOAD LIST 33 FROM THE DISC
C
C--
      use lists2_mod, only: xldlst

      INCLUDE 'ISTORE.INC'
      INCLUDE 'ICOM33.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XLST33.INC'
C
      INCLUDE 'QSTORE.INC'
      INCLUDE 'QLST33.INC'
C
      INCLUDE 'IDIM33.INC'
C--LOAD THE LIST
      CALL XLDLST(33,ICOM33,IDIM33,-1)
      M33CD=L33CD+ISTORE(L33CB+1)*MD33CD
      M33SV=L33SV+ISTORE(L33CB+1)*MD33SV
      M33ST=L33ST+ISTORE(L33CB+1)*MD33ST
      M33V=L33V+ISTORE(L33CB+1)*MD33V
      RETURN
      END
C
C
CODE FOR XFAL38
      SUBROUTINE XFAL38
C--ROUTINE TO LOAD LIST 38 FROM THE DISC
C
C--
      use lists2_mod, only: xldlst

      INCLUDE 'ICOM38.INC'
C
      INCLUDE 'XLST38.INC'
C
      INCLUDE 'QLST38.INC'
C
      INCLUDE 'IDIM38.INC'
C--LOAD THE LIST
      CALL XLDLST(38,ICOM38,IDIM38,-1)
      RETURN
      END
C
CODE FOR XFAL39
      SUBROUTINE XFAL39
C--ROUTINE TO LOAD LIST 39 FROM THE DISC
C
C--
      use lists2_mod, only: xldlst

      INCLUDE 'ICOM39.INC'
C
      INCLUDE 'XLST39.INC'
C
      INCLUDE 'QLST39.INC'
C
C--LOAD THE LIST
      CALL XLDLST(39,ICOM39,IDIM39,-1)
      RETURN
      END
C
CODE FOR XFAL40
      SUBROUTINE XFAL40
C--ROUTINE TO LOAD LIST 40 FROM THE DISC
C
C--
      use lists2_mod, only: xldlst

      INCLUDE 'ICOM40.INC'
C
      INCLUDE 'XLST40.INC'
C
      INCLUDE 'QLST40.INC'
C
      INCLUDE 'IDIM40.INC'
C--LOAD THE LIST
      CALL XLDLST(40,ICOM40,IDIM40,-1)
      RETURN
      END
CODE FOR XFAL41
      SUBROUTINE XFAL41
C--ROUTINE TO LOAD LIST 41 FROM THE DISC
C
C--
      use lists2_mod, only: xldlst

      INCLUDE 'ICOM41.INC'
C
      INCLUDE 'XLST41.INC'
C
      INCLUDE 'QLST41.INC'
C
      INCLUDE 'IDIM41.INC'
C--LOAD THE LIST
      CALL XLDLST(41,ICOM41,IDIM41,-1)
      RETURN
      END

CODE FOR XFAL42
      SUBROUTINE XFAL42
C--ROUTINE TO LOAD LIST 42 FROM THE DISC
C
C--
      use lists2_mod, only: xldlst

      INCLUDE 'ICOM42.INC'
C
      INCLUDE 'XLST42.INC'
C
      INCLUDE 'QLST42.INC'
C
      INCLUDE 'IDIM42.INC'
C--LOAD THE LIST
      CALL XLDLST(42,ICOM42,IDIM42,-1)
      RETURN
      END
C
CODE FOR XFAL23
      SUBROUTINE XFAL23
C--ROUTINE TO LOAD LIST 23 FROM THE DISC
C
C--
      use lists2_mod, only: xldlst

      INCLUDE 'ICOM23.INC'
C
      INCLUDE 'XLST23.INC'
C
      INCLUDE 'QLST23.INC'
C
      INCLUDE 'ISTORE.INC'
      INCLUDE 'STORE.INC'
      INCLUDE 'QSTORE.INC'
      INCLUDE 'IDIM23.INC'
      
C--LOAD THE LIST
      CALL XLDLST(23,ICOM23,IDIM23,-1)  

C-- Checking L23M record
      if (md23m .le. 8) then ! old l23. Extend record and set default invertor.
      
C When extending a record, we not only need to create new space for it in store and
C update the common block, but also update the record header pointers which are stored
C just before each data block pointed to by the common block. The only is IADDR+3 (which
C should be 5 words before the start of the data block, but here we use KHUNTR to return
C IADDR, just to be on the safe side.

        ISTAT = KHUNTR(23,101,IADDL,IADDR,IADDD,-1)
        IF ( ISTAT.EQ.0 ) THEN
           newl23m=nfl
           nextnf = KCHNFL(12)
           istore(newl23m:newl23m+md23m-1)=istore(l23m:l23m+md23m-1)
           istore(newl23m+7)=0 ! invertor
           istore(newl23m+8)=0 ! huge
           md23m=9
           l23m=newl23m
           m23m=newl23m+8
           istore(iaddr+3) = newl23m
        end if
      end if
      RETURN 
 
      END
C
C
CODE FOR XQSTRT
      SUBROUTINE XQSTRT
C      QUICKSTART -
C----- A MINIMAL I/O STARTUP ROUTINE FOR READING DATA FROM OTHER SYSTEMS
C
C      IT EXPECTS CELL PARAMETERS, LAMBDA, RELECTION DETAILS, COMPOSITIO
C      SOME CHECKING DONE AT THIS STAGE, AND MORE AFTER NORMAL LISTS
C      ARE WRITTEN TO THE SYSTEM REQUEST QUEUE.
C
C      COMMAND INPUT - NOTE SPECIAL PROCESSING REQUIRED FOR
C      STRING TYPE PARAMETERS, TYPE 4.
C
      CHARACTER *80 CBUFF1, CBUFF2, CBUFF3, CBUFF4, CLINE
      CHARACTER CEND*3
C
C----- TO HOLD REAL FORMAT EXPRESSION
      CHARACTER *8 CFMTXP
      CHARACTER *4 CFSQ(3), CHKLI
      CHARACTER *1 CH(4)
      INCLUDE 'TSSCHR.INC'
C
C
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XCARDS.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XSSCHR.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'QSTORE.INC'
      INCLUDE 'XIOBUF.INC'
C
      DATA CEND /'END'/
      DATA CFSQ /'FO  ', 'FSQ ', 'FSQ '/
      DATA IDIMBF /13/
      DATA IVERSN /103/
C
C
      CALL XTIME1 ( 2 )
      WRITE (CH, '(4A1)' ) IH
CMAR98
      ICOMBF = KSTALL ( IDIMBF )
      CALL XZEROF (STORE(ICOMBF), IDIMBF)
C
C -- COMMAND INPUT SECTION - DONE 'BY HAND'
C
C -- READ DIRECTIVE CARD
1000  CONTINUE
      IDIRNM = KRDNDC ( ISTORE(ICOMBF) , IDIMBF )
      IF ( IDIRNM .LT. 0 ) THEN
        GO TO 2500
      ELSE IF ( IDIRNM .EQ. 0 ) THEN
        CALL XMONTR ( 0 )
        GO TO 1000
      ENDIF
C
      IF ( IDIRNM .EQ. 1 .OR. IDIRNM .EQ. 2 .OR. IDIRNM .EQ. 3
     1 .OR. IDIRNM .EQ. 4) THEN
C----- SPACEGROUP, FORMAT COMPOSITION, OR FILE CARD
C -- SEARCH FOR THE PARAMETER KEYWORD
        IDWZAP = 0
        IF ( KFNDNP(IDWZAP) .LE. 0 ) GO TO 9810
C----- FIND NEXT AND LAST NON- BLANK ITEMS
        NC = KNEQUL ( NC , IB )
        IF ( NC .LE. 0 ) GO TO 9810
        IF ( NC .GT. LASTCH ) GO TO 9810
        LC = LASTCH
        DO 1100 I = LASTCH, NC, -1
        IF (IMAGE(LC) .NE. IB) GOTO 1150
        LC = LC - 1
1100    CONTINUE
1150    CONTINUE
C----- CREATE AN EXACT FORMAT EXPRESSION FOR INTERNAL WRITE
        ISIZE = MIN0 ( LC - NC + 1 , LEN ( CBUFF1 ) )
        WRITE (CFMTXP, '(''( '', I2, ''A1)'')') ISIZE
      END IF
      IF (IDIRNM .EQ. 1) THEN
C----- SPACEGROUP CARD
        WRITE ( CBUFF1(1:ISIZE) , CFMTXP, ERR = 9830 )
     1      ( LCMAGE(J), J = NC, NC + ISIZE - 1 )
        ISIZE1 = ISIZE
        NC = LASTCH + 1
        GO TO 1000
      ELSE IF (IDIRNM .EQ. 2) THEN
C----- FORMAT CARD - NORMAL FORTRAN FORMATS
        WRITE ( CLINE(1:ISIZE) , CFMTXP, ERR = 9830 )
     1      ( LCMAGE(J), J = NC, NC + ISIZE - 1 )
        ISIZE2 = ISIZE
        NC = LASTCH + 1
C----- LIST 6
C----- CHECK THE FORMAT IS 'F' NOT 'I'
      JJ = 0
      JJJ = 0
      DO 2650 J = 1, ISIZE2
      IF (CLINE(J:J) .EQ. 'I') THEN
        JJ = JJ + 1
        JJJ = 1
        CBUFF2(JJ:JJ) = 'F'
      ELSE IF (CLINE(J:J) .EQ. ',' .OR. CLINE(J:J) .EQ. ')' ) THEN
        IF (JJJ .EQ. 1) THEN
            I = JJ + 1
            JJ = JJ + 2
            CBUFF2(I:JJ) = '.0'
            JJJ = 0
        END IF
        JJ = JJ + 1
        CBUFF2(JJ:JJ) = CLINE(J:J)
      ELSE
        JJ = JJ + 1
        CBUFF2(JJ:JJ) = CLINE(J:J)
      END IF
2650  CONTINUE
      ISIZE2 = JJ
      ELSE IF (IDIRNM .EQ. 3) THEN
C----- COMPOSITION CARD, TYPE THEN NUMBER
        WRITE ( CBUFF3(1:ISIZE) , CFMTXP, ERR = 9830 )
     1      ( LCMAGE(J), J = NC, NC + ISIZE - 1 )
        ISIZE3 = ISIZE
        NC = LASTCH + 1
      ELSE IF (IDIRNM .EQ. 4) THEN
C----- REFLECTION FILENAME CARD
        WRITE ( CBUFF4(1:ISIZE) , CFMTXP, ERR = 9830 )
     1      ( LCMAGE(J), J = NC, NC + ISIZE - 1 )
        ISIZE4 = ISIZE
        NC = LASTCH + 1
      ENDIF
C
C -- NORMAL DIRECTIVE. READ THE PARAMETER VALUE
2000  CONTINUE
      IDWZAP = 0
      IF ( KFNDNP ( IDWZAP ) .LE. 0 ) GO TO 1000
      ISTAT = KRDPV ( ISTORE(ICOMBF) , IDIMBF )
      IF ( ISTAT .LT. 0 ) GO TO 1000
      IF ( ISTAT .EQ. 0 ) GO TO 2000
      GO TO 9820
C
C
C
2500  CONTINUE
C -- INPUT COMPLETED
C
C -- CHECK FOR ERRORS DURING INPUT
C
      IF ( LEF .GT. 0 ) GO TO 9930
      IF ( IERFLG .LT. 0 ) GO TO 9900
C
C----- WRITE crystals INSTRUCTIONS TO THE SYSTEM REQUEST QUEUE
C----- FORMAT FOR INTERNAL READS
30    FORMAT( 10( A ) )
31    FORMAT ( A, A )
C----- SAVE THE EXISTING SRQ
      CALL XSSRQ (IADSRQ, NSRQ)
C
C----- LET THE DISK EXPAND WITHOUT LIMIT
      WRITE(CLINE, 31) CH(1), 'DISK'
      CALL XISRC (CLINE)
      WRITE(CLINE, 30) 'EXTEND SIZE = 0'
      CALL XISRC (CLINE)
      WRITE(CLINE, 30) 'END'
      CALL XISRC (CLINE)
C
C----- LIST 1
C
      WRITE (CLINE, 31) CH(1), 'LIST 1'
      CALL XISRC (CLINE)
      JJ = ICOMBF + 6
      JJJ = ICOMBF + 11
      WRITE (CLINE, 4600) 'REAL', (STORE(J), J = JJ, JJJ)
4600  FORMAT (A, 6F9.4)
      CALL XISRC (CLINE)
      CALL XISRC (CEND)
C
C----- LIST 13
      WAVE  = STORE(ICOMBF + 4)
      WRITE (CLINE, 31) CH(1), 'LIST 13'
      CALL XISRC (CLINE)
      WRITE (CLINE, 30) 'DIFFRACTION GEOM = UNKNOWN'
      CALL XISRC (CLINE)
      WRITE (CLINE, 4600) 'CONDITION WAVE = ', WAVE
      CALL XISRC (CLINE)
      CALL XISRC (CEND)
C
C----- LIST 28
      RATIO  = STORE(ICOMBF + 12)
      WRITE (CLINE, 30) CH(1), 'LIST 28'
      CALL XISRC (CLINE)
      WRITE (CLINE, 4600) 'MINIMA RATIO = ', RATIO
      CALL XISRC (CLINE)
      CALL XISRC (CEND)
C
C----- SPACEGROUP
      WRITE (CLINE, 31) CH(1), 'SPACEGROUP'
      CALL XISRC (CLINE)
      WRITE (CLINE, 31) 'SYMBOL ',  CBUFF1(1:ISIZE1)
      CALL XISRC (CLINE)
      CALL XISRC (CEND)
C
C----- OPEN REFLECTION FILE
      CHKLI = 'DATA'
      IF (CBUFF4(1:ISIZE4) .NE. 'COMMANDS' ) THEN
        CHKLI = 'HKLI'
        WRITE (CLINE, 30) CH(1), 'OPEN HKLI ',  CBUFF4(1:ISIZE4)
        CALL XISRC (CLINE)
      ENDIF
C
C----- LIST 6
C----- TYPE OF INPUT
      ILIST = ISTORE(ICOMBF + 5)
C
      IF (ILIST .LE. 2) THEN
        WRITE (CLINE, 30) CH(1), 'LIST 6'
      ELSE
        WRITE (CLINE, 30) CH(1), 'HKLI'
      ENDIF
      CALL XISRC (CLINE)
      WRITE (CLINE, 32) CHKLI, CFSQ(ILIST)
32    FORMAT
     1 ( 'READ TYPE =FIXED,  NCOEF =5, UNIT =', A,
     1 ' CHECK =NO F''S =', A)
      CALL XISRC (CLINE)
      WRITE (CLINE, 31)'FORMAT ',  CBUFF2(1:ISIZE2)
      CALL XISRC (CLINE)
      CALL XISRC (CEND)
      IF (ILIST .EQ. 3) THEN
C----- DO DATA REDUCTION
        WRITE (CLINE, 30) CH(1), 'LP'
        CALL XISRC (CLINE)
        CALL XISRC (CEND)
        WRITE (CLINE, 30) CH(1), 'SYST'
        CALL XISRC (CLINE)
        CALL XISRC (CEND)
        WRITE (CLINE, 30) CH(1), 'SORT'
        CALL XISRC (CLINE)
        CALL XISRC (CEND)
        WRITE (CLINE, 30) CH(1), 'MERGE'
        CALL XISRC (CLINE)
        CALL XISRC (CEND)
        WRITE (CLINE, 30) CH(1), 'LIST 6'
        CALL XISRC (CLINE)
        WRITE (CLINE, 30) 'READ TYPE =COPY'
        CALL XISRC (CLINE)
        CALL XISRC (CEND)
      ENDIF
C
C
C----- COMPOSITION
      WRITE (CLINE, 30) CH(1), 'COMPOSITION'
      CALL XISRC (CLINE)
      WRITE (CLINE, 31) 'CONTENT ',  CBUFF3(1:ISIZE3)
      CALL XISRC (CLINE)
      WRITE (CLINE, 31) 'SCATTER ', CSSSCT(1:LSSSCT)
      CALL XISRC (CLINE)
      WRITE (CLINE, 31) 'PROPERTIES ', CSSELE(1:LSSELE)
      CALL XISRC (CLINE)
      CALL XISRC (CEND)
C
C----- RESTORE SRQ
      CALL XRSRQ (IADSRQ, NSRQ)
C
C -- RESET STORE
      CALL XCSAE
      CALL XRSL
C
      CALL XOPMSG( IOPQCK, IOPEND, IVERSN)
      CALL XTIME2 ( 2 )
C
      RETURN
C
C
9800  CONTINUE
      LEF = LEF + 1
      GO TO 1000
9810  CONTINUE
      CALL XMONTR(0)
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 9815 )
      WRITE ( CMON, 9815 )
      CALL XPRVDU(NCVDU, 1,0)
9815  FORMAT ( 1X, 'Illegal data card. ' )
      GO TO 9800
9820  CONTINUE
      IF (ISSPRT .EQ. 0)   WRITE ( NCWU , 9825 )
      WRITE ( CMON, 9825 )
      CALL XPRVDU(NCVDU, 1,0)
9825  FORMAT (' ERRORS during input')
      GOTO 9800
9830  CONTINUE
      IF (ISSPRT .EQ. 0)  WRITE ( NCWU , 9835 )
      WRITE ( CMON, 9835 )
      CALL XPRVDU(NCVDU, 1,0)
9835  FORMAT ( ' ERRORS during internal read/writes')
      GOTO 9800
C
9900  CONTINUE
      CALL XOPMSG (IOPQCK, IOPABN, 0)
      IDIRFL = -1
      RETURN
9930  CONTINUE
      CALL XOPMSG (IOPQCK, IOPCMI, 0)
      GO TO 9900
C
      END
C
C
C
CODE FOR XFMULA
      SUBROUTINE XFMULA
C----- GENERATE LISTS 3 AND 29 IN SRQ FROM INSTRUCTION CONTAINING
C      CELL CONTENTS AND SOURCE FILE NAMES.
C
C
C      COMMAND INPUT - NOTE SPECIAL PROCESSING REQUIRED FOR
C      STRING TYPE PARAMETERS, TYPE 4.
C
C
C      FORMULA LIST      I= IADDF, JADDF, NADDF
C      SCATTERING LIST   I= IADDS, JADDS, NADDS (=40 = 2*20)
C
      DIMENSION IDEV(4)
      CHARACTER *80 CBUFF1(19), CBUFF2, CBUFF3, CLINE, CINPBF, COUTBF
      CHARACTER CEND*3
      INTEGER NBUFF1, LBUFF1, MBUFF1
      INTEGER ISIZE1(19)
C For calculating f' and f'' and mu from tables (if particular wavelength not present in files)
      LOGICAL LFPCAL
      INTEGER IZ ! atomic number
      REAL*4  AMU, RHO, FP, FPP, RAY, COMP,RENERG
      REAL*8  F_TO_MU,ATOEV,MU,ATOMX,VC
      PARAMETER ( ATOEV = 12398.4244680242D0 )        ! EV = ATOEV / LAMBDA (in A)
      parameter (F_TO_MU= 4208.031548D0)            ! Mu in microns
  
  
C
C----- TO HOLD REAL FORMAT EXPRESSION
      CHARACTER *8 CFMTXP
      CHARACTER *4 CTMP, CARG, CARGU, CUPA
C
C
      INCLUDE 'ISTORE.INC'
C
      INCLUDE 'STORE.INC'
      INCLUDE 'XCARDS.INC'
      INCLUDE 'XCHARS.INC'
      INCLUDE 'XLISTI.INC'
      INCLUDE 'XUNITS.INC'
      INCLUDE 'XSSVAL.INC'
      INCLUDE 'XLST02.INC'
      INCLUDE 'XLST13.INC'
      INCLUDE 'XERVAL.INC'
      INCLUDE 'XOPVAL.INC'
      INCLUDE 'QSTORE.INC'
      INCLUDE 'XIOBUF.INC'
C
      DATA CEND /'END'/
C
C----- IDEV  = SCPDATA, (NCEXTR)
#ifdef _HOL_
      DATA IDEV / 1HS, 1HC, 1HP, 1HD /
#else
      DATA IDEV / 'S', 'C', 'P', 'D' /
#endif
      DATA IDIMBF / 3 /, NADDF / 2 /, NADDS /40/
C     NUMBER OF WAVWLENGTHS PRESENT IN PROPERTIES FILE
      DATA NPROPW /2/
      DATA IVERSN / 100 /
C
C
      CALL XTIME1 ( 2 )
      LFPCAL = .FALSE.  !FALSE = Default to f' and f'' from scatt file, unless wavelength not present

CMAR98
      ICOMBF = KSTALL ( IDIMBF )
      CALL XZEROF (STORE(ICOMBF), IDIMBF)
      NBUFF1 = 1
      LBUFF1 = 0
C
C -- COMMAND INPUT SECTION - DONE 'BY HAND'
C
C -- READ DIRECTIVE CARD
1000  CONTINUE
      IDIRNM = KRDNDC ( ISTORE(ICOMBF) , IDIMBF )
      IF ( IDIRNM .LT. 0 ) THEN
        GO TO 2500
      ELSE IF ( IDIRNM .EQ. 0 ) THEN
        IF ( LBUFF1 .LE. 0 ) THEN
          CALL XMONTR ( 0 )
          GO TO 1000
        ENDIF
      ENDIF
C
      IF ( IDIRNM .EQ. 1 .OR. IDIRNM .EQ. 2
     1.OR. IDIRNM .EQ. 3 .OR. IDIRNM .EQ. 0 ) THEN
C----- FORMULA, SCATTERING, PROPERTIES OR CONTINUE CARD
C -- SEARCH FOR THE PARAMETER KEYWORD
        IDWZAP = 0
        IF (IDIRNM .NE. 0) THEN
          IF (KFNDNP(IDWZAP) .LE. 0) GOTO 9810
        ENDIF
C----- FIND NEXT AND LAST NON- BLANK ITEMS
        NC = KNEQUL ( NC , IB )
        IF ( NC .LE. 0 ) GO TO 9810
        IF ( NC .GT. LASTCH ) GO TO 9810
        LC = LASTCH
        DO 1100 I = LASTCH, NC, -1
        IF (IMAGE(LC) .NE. IB) GOTO 1150
        LC = LC - 1
1100    CONTINUE
1150    CONTINUE
C----- CREATE AN EXACT FORMAT EXPRESSION FOR INMTERNAL WRITE
        ISIZE = MIN0 ( LC - NC + 1 , LEN ( CBUFF1(1) ) )
        WRITE (CFMTXP, '(''( '', I2, ''A1)'')') ISIZE
      END IF
      IF ((IDIRNM .EQ. 1).OR.(IDIRNM.EQ.0)) THEN
C----- CONTENTS CARD
        IF ( LBUFF1 .EQ. 0 ) THEN
C-----   First time here. Set LBUFF1 +ve.
         LBUFF1 = 1
        ELSE IF (( LBUFF1 .LT. 0 ) .OR. ( NBUFF1.GE.19 )) THEN
C-----   Continue before CONTENTS card has started.
C-----   OR too many continue statements (max 19).
          CALL XMONTR ( 0 )
          GO TO 1000
        END IF
        WRITE ( CBUFF1(NBUFF1)(1:ISIZE) , CFMTXP, ERR = 9830 )
     1      ( LCMAGE(J), J = NC, NC + ISIZE - 1 )
        ISIZE1(NBUFF1) = ISIZE
        NC = LASTCH + 1
        NBUFF1 = NBUFF1 + 1
        GO TO 1000
C
      ELSE IF (IDIRNM .EQ. 2) THEN
C----- SCATTERING FACTOR FILE NAME
        IF ( LBUFF1 .GE. 0 ) THEN
C-----   CONTENT CARD COMPlETE. Set LBUFF1 -ve.
         LBUFF1 = -1
        END IF
        WRITE ( CBUFF2(1:ISIZE) , CFMTXP, ERR = 9830 )
     1      ( LCMAGE(J), J = NC, NC + ISIZE - 1 )
        ISIZE2 = ISIZE
        NC = LASTCH + 1
C
      ELSE IF (IDIRNM .EQ. 3) THEN
C----- PROPERTIES FILE NAME
        IF ( LBUFF1 .GE. 0 ) THEN
C-----   CONTENT CARD COMPlETE. Set LBUFF1 -ve.
         LBUFF1 = -1
        END IF
        WRITE ( CBUFF3(1:ISIZE) , CFMTXP, ERR = 9830 )
     1      ( LCMAGE(J), J = NC, NC + ISIZE - 1 )
        ISIZE3 = ISIZE
        NC = LASTCH + 1
      ENDIF
C
C -- NORMAL DIRECTIVE. READ THE PARAMETER VALUE
2000  CONTINUE
      IDWZAP = 0
      IF ( KFNDNP ( IDWZAP ) .LE. 0 ) GO TO 1000
      ISTAT = KRDPV ( ISTORE(ICOMBF) , IDIMBF )
      IF ( ISTAT .LT. 0 ) GO TO 1000
      IF ( ISTAT .EQ. 0 ) GO TO 2000
      GO TO 9820
C
C
C
2500  CONTINUE
C -- INPUT COMPLETED
C
C -- CHECK FOR ERRORS DURING INPUT
C
      IF ( LEF .GT. 0 ) GO TO 9930
      IF ( IERFLG .LT. 0 ) GO TO 9900
C
C----- IF THERE IS NO LIST 2, EXIT IN ERROR
      CALL XFAL02
      IF ( IERFLG .LT. 0 ) GO TO 9870
      T2INV = 1. / T2
C----- IF THERE IS NO LIST 13, EXIT IN ERROR
      CALL XFAL13
      IF ( IERFLG .LT. 0 ) GO TO 9870
      WAVE = STORE(L13DC)
C
C----- GET THE ELEMENTS AND CONTENTS FROM THE FORMULA CARD
C      A STORE THEM IN ISTORE(JADDF), STORE(JADDF+1) FOR EACH ELEMENT
C      IF A NUMBER ISNT GIVEN, 1 ASSUMED.
      NELEM = 0
      JADDF  = NFL
      IADDF = JADDF
C----- TYPE EXPECTED FOR NEXT ARGUMENT (+1 = NUMBER, -1 = CHARACTER)
      IARG = -1
      MBUFF1 = 1

C----- LOOP BACK HERE FOR NEXT CARD
4999  CONTINUE
      ISTART = 1
C----- RESET TO +1 AT END OF CARD
      IEND = -1
C----- CHECK IF THERE IS ANY DATA ON CARD
      IF (ISTART .GT. ISIZE1(MBUFF1)) GOTO 9860
C----- LOOP BACK HERE FOR NEXT ARGUMENT
5000  CONTINUE
      IF(KCCARG(CBUFF1(MBUFF1)(1:ISIZE1(MBUFF1)),
     1                                   ISTART,1,IPOS1,IPOS2).LE.0)THEN
        IEND = +1
        IPOS2 = ISIZE1(MBUFF1)
      END IF
C----- TRY TO PROCESS AS NUMBER
      IF (KCCNUM(CBUFF1(MBUFF1)(IPOS1:IPOS2),IRESLT,ITYPE).LE.0)THEN
C----- NOT A NUMBER
        JARG = -1
      ELSE
C      A NUMBER
        IF (ITYPE .EQ. 1) THEN
            VALUE = FLOAT(IRESLT)
        ELSE
            CALL XMOVE( IRESLT, VALUE, 1)
        END IF
        JARG = +1
      END IF
C
C
      IF ((IARG .EQ. -1) .AND. (JARG .EQ. -1)) THEN
C      STORE CHARACTER
        WRITE(CTMP, 20) CBUFF1(MBUFF1)(IPOS1:IPOS2)
        READ(CTMP, 20) ISTORE(JADDF)
        NELEM = NELEM + 1
C       EXPECT A NUMBER NEXT TIME
        IARG = +1
      ELSE IF ((IARG .EQ. +1) .AND. (JARG .EQ. +1)) THEN
C       STORE THE NUMBER
        STORE(JADDF+1) = VALUE
        IARG = -1
        JADDF = JADDF + NADDF
      ELSE IF ((IARG .EQ. +1) .AND. (JARG .EQ. -1)) THEN
C       FOUND CHARACTER, EXPECTED NUMBER
        STORE(JADDF+1) = 1.
        JADDF = JADDF + NADDF
C      STORE CHARACTER
        WRITE(CTMP, 20) CBUFF1(MBUFF1)(IPOS1:IPOS2)
        READ(CTMP, 20) ISTORE(JADDF)
        NELEM = NELEM + 1
C       EXPECT A NUMBER NEXT TIME
        IARG = +1
      ELSE
C----- ERROR
      GOTO 9850
      END IF
      IF (IEND .NE. 1)  GOTO 5000
      MBUFF1 = MBUFF1 + 1
      IF (MBUFF1 .LT. NBUFF1) GOTO 4999
C     CARD FINISHED - TIDY UP
      IF (IARG .EQ. +1) THEN
        STORE(JADDF + 1) = 1.
      ELSE
        JADDF = JADDF - NADDF
      END IF
C-----  SAVE THE LIST AND SET START OF SCATTERING FACTOR LIST.
C       THIS IS SAVED IN STORE BEFORE BEING WRITTEN TO THE SRQ INCASE
C       SOME FACTORS CANNOT BE FOUND
      I = KSTALL (JADDF - IADDF + NADDF)
      IADDS = NFL
      JADDS = IADDS
C
C
C----- OPEN THE SCATTERING FACTOR FILE
      ISIZE = ISIZE2
      CLINE(1:ISIZE) = CBUFF2(1:ISIZE)
      CALL XRDOPN (6, IDEV, CLINE(1:ISIZE), ISIZE)
      IF ( IERFLG .LT. 0) GOTO 9840
C----- READ HEADER FROM SCATTERING FACTOR FILE
C     READ WHOLE FILE
      REWIND NCEXTR
C----- SKIP COMMENT LINES
5300  CONTINUE
      IF (KRDLIN(NCEXTR, CINPBF, LENGTH)) 9720, 9710, 5301
5301  CONTINUE
      IF ((CINPBF(1:2).EQ.CHAR(92)//' ').OR.(CINPBF(1:2).EQ.'# '))
     1 GOTO 5300
C----- READ NUMBER OF WAVELENGTH TYPES
5302  CONTINUE
      ISTART = 1
      IF(KCRVAL(CINPBF, LENGTH, ISTART, IPOS1,IPOS2,VALUE) .LE .0)
     1   GOTO 9720
      IVALUE = NINT(VALUE)
C----- NUMBER OF LINES PER ELEMENT
      NLINES = 1 + IVALUE
C----- READ WAVELENGTHS
      IF (KRDLIN(NCEXTR, CINPBF, LENGTH)) 9720, 9710, 5303
5303  CONTINUE
      LAM = 0
      DELMIN = 1000.0
      ISTART = 1
      DO 5350 I = 1, IVALUE
      IF(KCRVAL(CINPBF, LENGTH, ISTART, IPOS1, IPOS2, VALUE) .LE .0)
     1   GOTO 9720
C-----  SPOT THE WAVELENGTH
        IF (ABS(VALUE-WAVE) .LE. DELMIN ) THEN 
            LAM = I
            DELMIN = ABS(VALUE-WAVE)
            WAVUSE = VALUE
        ENDIF
5350  CONTINUE
      IF (DELMIN .GE. 0.01) THEN
        LFPCAL = .TRUE.
        RENERG = ATOEV / WAVE   ! Convert A to eV.
        WRITE ( CMON, 9701) WAVE
        CALL XPRVDU(NCVDU, 2,0)
9701    FORMAT
     1 (' System files contain no resonant scattering data for '/, 
     2 ' wavelength',F8.4,' using calculated values instead.')
        IF (ISSPRT .EQ. 0) WRITE ( NCWU, '(A,A)') trim(CMON(1)),
     1  trim(CMON(2))
      ENDIF
C----- BEGIN PROCESSING FORMULA LIST
      DO J = IADDF, JADDF, NADDF
C----- CONVERT BACK TO CHARACTER
        WRITE(CTMP, 20) ISTORE(J)
        READ(CTMP, 20) CARG
        LSTART = KCCNEQ( CARG, 1, ' ')
        IF (LSTART .EQ. -1) GOTO 9730
        LSTART = MAX0( 1, LSTART)
C LEFT ADJUST STRING
        CTMP = CARG(LSTART:4)
        CARG = CTMP
        LENSER = 4
        CALL XCCUPC( CARG, CARGU)
C       READ WHOLE FILE FOR EACH ELEMENT
        REWIND NCEXTR
5400    CONTINUE
        IF (KRDLIN(NCEXTR, CINPBF, LENGTH)) 9720, 9710, 5401
5401    CONTINUE
C----- CHECK FIRST FOUR CHARACERS ONLY - REMEMBER CINPBF IS MIXED CASE
        CALL XCCUPC(CINPBF(1:LENSER),CUPA)
        IF ( (CINPBF(1:LENSER) .NE. CARG(1:LENSER)) .AND.
     1             (CUPA(1:4) .NE. CARGU(1:LENSER)) ) THEN
C----- NO MATCH SKIP REQUIRED NUMBER OF LINES
          DO I = 2,NLINES
            IF (KRDLIN(NCEXTR, CINPBF, LENGTH)) 9720, 9710, 5402
5402        CONTINUE
          END DO
C----- GO BACK FOR NEXT DATA RECORD
          GOTO 5400
        END IF
C----- MATCH
        IF (LAM .NE. 1) THEN
C----- SKIP UNTIL REQUIRED LINE
          DO I = 2,LAM
            IF (KRDLIN(NCEXTR, CINPBF, LENGTH)) 9720, 9710, 5421
5421        CONTINUE
          END DO
        END IF

        IF ( LFPCAL ) THEN   ! Ignore values from file (too far from required wavelength) - calc instead
C - Find atomic number
          iz = -1                                ! Set to -1 to get Z from element string
          call abselement( iz, CARG(1:LENSER))  ! note - will fail for charged element names, e.g. LiP1 etc.
c          if ( iz .gt. 0 ) then  
c            call absatomic_data( iz, amu, rho ) !amu not needed for resonant bit
c          end if
c          if ( iz .le. 0 .or. amu .le. 0.0 ) then                  ! fail - print message for now and fall back on closest wavelength
          if ( iz .le. 0 ) then                  ! fail - print message for now and fall back on closest wavelength
            WRITE ( CMON, 9702) CARG(1:LENSER), WAVUSE
            CALL XPRVDU(NCVDU, 2,0)
9702        FORMAT
     1 ('Cannot calculate resonant scattering contribution for ',
     2   A4, /, 
     3 'falling back on data for wavelength = ', F8.5)
            IF (ISSPRT .EQ. 0) WRITE ( NCWU, '(A,A)') trim(CMON(1)),
     1                                                trim(CMON(2))
          else
            call abscromer( iz, RENERG, fp, fpp)
            write ( cinpbf, '(A4,2(1x,F14.8))') CARG(1:LENSER), FP, FPP
            write(cmon,'(2A,2(a,F8.3))')
     1      ' Computed dispersion correction for ', CARG(1:LENSER),
     2      ' f ''= ', fp, ' f" = ', fpp
            CALL XPRVDU(NCVDU, 1,0)
          end if
      ENDIF
  
C----- CONVERT WHOLE LINE TO UPPER CASE
        COUTBF = ' '
        CALL XCCUPC (CINPBF, COUTBF)
C----- SAVE ELEMENT NAME LINE
        READ (COUTBF, 20) (ISTORE(JADDS+II), II=0,19)
        JADDS = JADDS + 20
        IF (LAM .LE. NLINES-2) THEN
C----- SKIP REMAINING LINES
          DO I = LAM, NLINES-2
            IF (KRDLIN(NCEXTR, CINPBF, LENGTH)) 9720, 9710, 5431
5431        CONTINUE
          END DO
        END IF
C----- NOW GET THE COMMON PART OF THE DATA
        IF (KRDLIN(NCEXTR, CINPBF, LENGTH)) 9720, 9710, 5441
5441    CONTINUE
C----- CONVERT WHOLE LINE TO UPPER CASE
        COUTBF = ' '
        CALL XCCUPC (CINPBF, COUTBF)
        READ(COUTBF,20) (ISTORE(JADDS+II), II= 0,19)
        II = KSTALL(NADDS)
        JADDS  = JADDS + 20
      END DO   ! GO BACK FOR NEXT ELEMENT
C
C----- ALL FINISHED - RESET JADDS TO START OF LAST ITEM
      JADDS = JADDS - NADDS
C
C----- WRITE crystals INSTRUCTIONS TO THE SYSTEM REQUEST QUEUE
C----- FORMATS FOR INTERNAL READS
10    FORMAT ( 80A1 )
20    FORMAT ( 20A4 )
30    FORMAT ( A )
31    FORMAT ( A, A )
C----- SAVE THE EXISTING SRQ
      CALL XSSRQ (IADSRQ, NSRQ)
C
C----- LIST 3
C
      WRITE (CLINE, 30) '#LIST 3'
      CALL XISRC (CLINE)
      WRITE(CLINE, 5601) 'READ NSCAT = ', NELEM
5601  FORMAT(A, I8)
      CALL XISRC (CLINE)
      DO 5600 I = IADDS, JADDS, NADDS
      WRITE (CLINE, 20) 'SCAT','    ', (ISTORE(I+J), J = 0, 17)
      CALL XISRC (CLINE)
      WRITE (CLINE, 20)  (ISTORE(I+J), J = 20, 39)
      CALL XISRC (CLINE)
5600  CONTINUE
      CALL XISRC (CEND)
C
C     RESET START OF WORK AREA
      JADDS = IADDS
C----- OPEN THE ELEMENTAL PROPERTIES FILE
      ISIZE = ISIZE3
      CLINE(1:ISIZE) = CBUFF3(1:ISIZE)
      CALL XRDOPN (6, IDEV, CLINE(1:ISIZE), ISIZE)
      IF ( IERFLG .LT. 0) GOTO 9840
C     READ WHOLE FILE
      REWIND NCEXTR
C----- SKIP COMMENT LINES
6000  CONTINUE
      IF (KRDLIN(NCEXTR, CINPBF, LENGTH)) 9720, 9710, 6050
6050  CONTINUE
      IF ((CINPBF(1:2).EQ.CHAR(92)//' ').OR.(CINPBF(1:2).EQ.'# '))
     1 GOTO 6000
C----- NUMBER OF LINES PER ELEMENT
      NLINES = 1 + NPROPW
C----- CURRENTLY ONLY TWO WAVELENGTS ARE KNOWN
      IF (ABS (WAVE-1.5418) .LE. .01) THEN
        LAM = 1
      ELSE
        LAM = 2
      END IF
C----- BEGIN PROCESSING FORMULA LIST
      DO J = IADDF, JADDF, NADDF
C----- CONVERT BACK TO CHARACTER
        WRITE(CTMP, 20) ISTORE(J)
        READ(CTMP, 20) CARG
        LSTART = KCCNEQ( CARG, 1, ' ')
        IF (LSTART .EQ. -1) GOTO 9730
        LSTART = MAX0( 1, LSTART)
C LEFT ADJUST STRING
        CTMP = CARG(LSTART:4)
        CARG = CTMP
        LENSER = 4
        CALL XCCUPC( CARG, CARGU)
C READ WHOLE FILE FOR EACH ELEMENT
        REWIND NCEXTR
6400    CONTINUE
C----- GET THE COMMON PART OF THE DATA - CONTAINS ELEMENT NAME
        IF (KRDLIN(NCEXTR, CINPBF, LENGTH)) 9720, 9710, 6401
6401    CONTINUE
C----- CHECK FIRST FOUR CHARACERS ONLY - REMEMBER CINPBF IS MIXED CASE
        IF ( (CINPBF(1:LENSER) .NE. CARG(1:LENSER)) .AND.
     1       (CINPBF(1:LENSER) .NE. CARGU(1:LENSER)) ) THEN
C----- NO MATCH SKIP REQUIRED NUMBER OF LINES
          DO I = 2,NLINES
            IF (KRDLIN(NCEXTR, CINPBF, LENGTH)) 9720, 9710, 6402
6402        CONTINUE
          END DO
C----- GO BACK FOR NEXT DATA RECORD
          GOTO 6400
        ENDIF
C----- MATCH
C----- CONVERT WHOLE LINE TO UPPER CASE
        COUTBF = ' '
        CALL XCCUPC (CINPBF, COUTBF)
        READ(COUTBF,20) (ISTORE(JADDS+II), II= 0,19)
        JADDS  = JADDS + 20
C----- LOOK FOR SECOND PART
        IF (LAM .NE. 1) THEN
C----- SKIP UNTIL REQUIRED LINE
          DO I = 1,LAM-1
            IF (KRDLIN(NCEXTR, CINPBF, LENGTH)) 9720, 9710, 6431
6431        CONTINUE
          END DO
        END IF
        IF (KRDLIN(NCEXTR, CINPBF, LENGTH)) 9720, 9710, 6435
6435    CONTINUE

        IF ( LFPCAL ) THEN   ! Ignore values from file (too far from required wavelength) - calc instead
C - Find atomic number
          iz = -1                                ! Set to -1 to get Z from element string
          call abselement( iz, CARG(1:LENSER))  ! note - will fail for charged element names, e.g. LiP1 etc.
          if ( iz .gt. 0 ) then  
            call absatomic_data( iz, amu, rho ) !amu not needed for resonant bit
          end if
c          write(cmon,*)'iz, element, amu, rho = ', iz, carg(1:lenser), amu, rho
c          CALL XPRVDU(NCVDU, 1,0)
          if ( iz .le. 0 .or. amu .le. 0.0 ) then                ! fail - print message for now and fall back on closest wavelength
            WRITE ( CMON, 9703) CARG(1:LENSER), WAVUSE
            CALL XPRVDU(NCVDU, 2,0)
9703        FORMAT
     1 (' Can''t compute interaction cross section for ',
     2   A4, /, 
     3 ' falling back on data from closest wavelength = ',F8.5)
            IF (ISSPRT .EQ. 0) WRITE ( NCWU, '(A,A)') trim(CMON(1)),
     1                                                trim(CMON(2))
          else
            call abscromer( iz, RENERG, fp, fpp)
            call absraycomp( iz, RENERG, ray, comp)
            mu= (F_TO_MU* rho*( fpp+ ray+ comp))/( amu* RENERG)
c            write(cmon,*)'amu, rho, Fp, Fpp, Mu (microns-1) = ', 
c     1                    amu, rho, fp, fpp, mu
c            CALL XPRVDU(NCVDU, 1,0)
c            write(cmon,*)'Mu (cm-1) = ', mu * 10000.0
c            CALL XPRVDU(NCVDU, 1,0)
C Convert mu (in cm-1) to photon interaction cross section (sigma_i). Formula from I.T. is:
C
C mu = (1/Vc).sigma_i, where Vc is the volume (in A^3) occupied by one atom (assuming elemental material).
C We can work this out from the atomic density and mass as follows:
C
C Vc = AW x 1E24 / (N.rho), AW = atomic weight, rho = density in gcm-3, N = Avogadro.
C We can divide top and bottom by 10^24 to keep numbers reasonable.
            Vc =  amu  / ( 0.6022 * rho )  
            atomx = mu * 1000.0 * Vc ! NB. CRYSTALS uses mm-1 units (hence 1000 conversion here instead of 10000).
            write(cmon,'(3A,F14.6)')
     1      ' Computed photon interaction cross section for ',
     2      CARG(1:LENSER), ' = ', atomx
            CALL XPRVDU(NCVDU, 1,0)
            write ( cinpbf, '(A,F14.6)') 'CONTINUE MU = ', ATOMX
          end if
        ENDIF

C----- CONVERT WHOLE LINE TO UPPER CASE
c        WRITE ( CMON, '(a)') cinpbf
c        CALL XPRVDU(NCVDU, 1,0)
        COUTBF = ' '
        CALL XCCUPC (CINPBF, COUTBF)
C----- SAVE ELEMENT NAME LINE
        READ (COUTBF, 20) (ISTORE(JADDS+II), II=0,19)
      JADDS = JADDS + 20
        IF (LAM .LE. NLINES-2) THEN
C----- SKIP REMAINING LINES
          DO I = LAM, NLINES-2
            IF (KRDLIN(NCEXTR, CINPBF, LENGTH)) 9720, 9710, 6439
6439        CONTINUE
          END DO
        END IF
        II = KSTALL(NADDS)
C----- GO BACK FOR NEXT ELEMENT
      END DO
C
C RIC: Close the file!
      CALL XRDOPN (7, IDEV, CLINE(1:ISIZE), ISIZE)
C----- ALL FINISHED - RESET JADDS TO START OF LAST ITEM
      JADDS = JADDS - NADDS
      JADDF = IADDF
C
C----- WRITE CRYSTALS INSTRUCTIONS TO THE SYSTEM REQUEST QUEUE
C
C----- LIST 29
C
      WRITE (CLINE, 30) '#LIST 29'
      CALL XISRC (CLINE)
      WRITE(CLINE, 5601) 'READ NELEM = ', NELEM
      CALL XISRC (CLINE)
      DO 6600 I = IADDS, JADDS, NADDS
      WRITE (CLINE, 20) 'ELEM','    ', (ISTORE(I+J), J = 0, 17)
      CALL XISRC (CLINE)
      WRITE (CLINE, 20)  (ISTORE(I+J), J = 20, 39)
      CALL XISRC (CLINE)
      WRITE(CLINE, 6601) 'CONT NUM = ', (T2INV * STORE(JADDF+1))
6601  FORMAT(A, F15.6)
      JADDF = JADDF + NADDF
      CALL XISRC (CLINE)
6600  CONTINUE
      CALL XISRC (CEND)
C
C----- RESTORE SRQ
      CALL XRSRQ (IADSRQ, NSRQ)
C
C -- RESET STORE
      CALL XCSAE
      CALL XRSL
C
      CALL XOPMSG( IOPCMP, IOPEND, IVERSN)
      CALL XTIME2 ( 2 )
C
      RETURN
C
C
9710  CONTINUE
      CALL XERIOM (NCEXTR, IABS(I))
      WRITE ( CMON, 9711) CLINE(1:ISIZE), CARG
      IF (ISSPRT .EQ. 0) WRITE ( NCWU, '(A)') trim(CMON(1))
      CALL XPRVDU(NCVDU, 1,0)
9711  FORMAT (' End of file ', A, ' - item  "',A,'"  not found')
      GOTO 9900
9720  CONTINUE
      CALL XERIOM (NCEXTR, IABS(I))
      WRITE ( CMON, 9721) CLINE(1:ISIZE), CARG
      IF (ISSPRT .EQ. 0) WRITE ( NCWU, '(A)') trim(CMON(1))
      CALL XPRVDU(NCVDU, 1,0)
9721  FORMAT (' Error in file ', A, ' - item  "',A,'"  not found')
      GOTO 9900
9730  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE ( NCWU, 9731) CLINE(1:ISIZE)
      WRITE ( CMON, 9731) CLINE(1:ISIZE)
      CALL XPRVDU(NCVDU, 1,0)
9731  FORMAT( ' Zero length element name')
9800  CONTINUE
      LEF = LEF + 1
      GO TO 1000
9810  CONTINUE
      CALL XMONTR(0)
      IF (ISSPRT .EQ. 0) WRITE ( NCWU , 9815 )
      WRITE ( CMON, 9815)
      CALL XPRVDU(NCVDU, 1,0)
9815  FORMAT ( 1X, 'Illegal data card. ' )
      GO TO 9800
9820  CONTINUE
      IF (ISSPRT .EQ. 0)   WRITE ( NCWU , 9825 )
      WRITE ( CMON, 9825 )
      CALL XPRVDU(NCVDU, 1,0)
9825  FORMAT (' ERRORS during input')
      GOTO 9800
9830  CONTINUE
      IF (ISSPRT .EQ. 0)   WRITE ( NCWU , 9835 )
      WRITE ( CMON, 9835 )
      CALL XPRVDU(NCVDU, 1,0)
9835  FORMAT ( ' ERRORS during internal read/writes')
      GOTO 9800
9840  CONTINUE
      CALL XERIOM (NCEXTR, IABS(I))
      IF (ISSPRT .EQ. 0) WRITE ( NCWU, 9841)  NCEXTR, CLINE(1:ISIZE)
      WRITE ( CMON, 9841)  NCEXTR, CLINE(1:ISIZE)
      CALL XPRVDU(NCVDU, 1,0)
9841  FORMAT( ' FILE open error, UNIT ', I6, ' ', A)
      GOTO 9900
9850  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE ( NCWU, 9851)
      WRITE ( CMON, 9851)
      CALL XPRVDU(NCVDU, 1,0)
9851  FORMAT ( ' ERROR in formula card')
      GOTO 9900
9860  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE ( NCWU, 9861)
      WRITE ( CMON, 9861)
      CALL XPRVDU(NCVDU, 1,0)
9861  FORMAT ( ' No data on formula card')
9870  CONTINUE
      IF (ISSPRT .EQ. 0) WRITE ( NCWU, 9871)
      WRITE ( CMON, 9871)
      CALL XPRVDU(NCVDU, 1,0)
9871  FORMAT ( ' List 2 or 13 not available')
      GOTO 9900
C
9900  CONTINUE
      CALL XOPMSG (IOPCMP, IOPABN, 0)
      IDIRFL = -1
      RETURN
9930  CONTINUE
      CALL XOPMSG (IOPCMP, IOPCMI, 0)
      GO TO 9900
      END
    
